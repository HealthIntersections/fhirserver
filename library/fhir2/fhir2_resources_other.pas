unit fhir2_resources_other;

{
  Copyright (c) 2011+, HL7 and Health Intersections Pty Ltd (http://www.healthintersections.com.au)
  All rights reserved.

  Redistribution and use in source and binary forms, with or without modification,
  are permitted provided that the following conditions are met:

   * Redistributions of source code must retain the above copyright notice, this
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice,
     this list of conditions and the following disclaimer in the documentation
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to
     endorse or promote products derived from this software without specific
     prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.

}

{$I fhir.inc}
{$I fhir2.inc}

interface

// FHIR v1.0.2 generated 2015-10-24T07:41:03+11:00

uses
  SysUtils, Classes,
  fsl_base, fsl_utilities, fsl_stream,
  fhir_objects, fhir_utilities, 
  fhir2_base, fhir2_types, fhir2_resources_base;

Type
{$IFDEF FHIR_PARAMETERS}
  TFhirParametersParameter = class;
  TFhirParametersParameterList = class;
  TFhirParameters = class;
  TFhirParametersList = class;
{$ENDIF FHIR_PARAMETERS}
{$IFDEF FHIR_AUDITEVENT}
  TFhirAuditEventEvent = class;
  TFhirAuditEventEventList = class;
  TFhirAuditEventParticipant = class;
  TFhirAuditEventParticipantList = class;
  TFhirAuditEventParticipantNetwork = class;
  TFhirAuditEventParticipantNetworkList = class;
  TFhirAuditEventSource = class;
  TFhirAuditEventSourceList = class;
  TFhirAuditEventObject = class;
  TFhirAuditEventObjectList = class;
  TFhirAuditEventObjectDetail = class;
  TFhirAuditEventObjectDetailList = class;
  TFhirAuditEvent = class;
  TFhirAuditEventList = class;
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BINARY}
  TFhirBinary = class;
  TFhirBinaryList = class;
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BUNDLE}
  TFhirBundleLink = class;
  TFhirBundleLinkList = class;
  TFhirBundleEntry = class;
  TFhirBundleEntryList = class;
  TFhirBundleEntrySearch = class;
  TFhirBundleEntrySearchList = class;
  TFhirBundleEntryRequest = class;
  TFhirBundleEntryRequestList = class;
  TFhirBundleEntryResponse = class;
  TFhirBundleEntryResponseList = class;
  TFhirBundle = class;
  TFhirBundleList = class;
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CLAIM}
  TFhirClaimPayee = class;
  TFhirClaimPayeeList = class;
  TFhirClaimDiagnosis = class;
  TFhirClaimDiagnosisList = class;
  TFhirClaimCoverage = class;
  TFhirClaimCoverageList = class;
  TFhirClaimItem = class;
  TFhirClaimItemList = class;
  TFhirClaimItemDetail = class;
  TFhirClaimItemDetailList = class;
  TFhirClaimItemDetailSubDetail = class;
  TFhirClaimItemDetailSubDetailList = class;
  TFhirClaimItemProsthesis = class;
  TFhirClaimItemProsthesisList = class;
  TFhirClaimMissingTeeth = class;
  TFhirClaimMissingTeethList = class;
  TFhirClaim = class;
  TFhirClaimList = class;
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
  TFhirClaimResponseItem = class;
  TFhirClaimResponseItemList = class;
  TFhirClaimResponseItemAdjudication = class;
  TFhirClaimResponseItemAdjudicationList = class;
  TFhirClaimResponseItemDetail = class;
  TFhirClaimResponseItemDetailList = class;
  TFhirClaimResponseItemDetailAdjudication = class;
  TFhirClaimResponseItemDetailAdjudicationList = class;
  TFhirClaimResponseItemDetailSubDetail = class;
  TFhirClaimResponseItemDetailSubDetailList = class;
  TFhirClaimResponseItemDetailSubDetailAdjudication = class;
  TFhirClaimResponseItemDetailSubDetailAdjudicationList = class;
  TFhirClaimResponseAddItem = class;
  TFhirClaimResponseAddItemList = class;
  TFhirClaimResponseAddItemAdjudication = class;
  TFhirClaimResponseAddItemAdjudicationList = class;
  TFhirClaimResponseAddItemDetail = class;
  TFhirClaimResponseAddItemDetailList = class;
  TFhirClaimResponseAddItemDetailAdjudication = class;
  TFhirClaimResponseAddItemDetailAdjudicationList = class;
  TFhirClaimResponseError = class;
  TFhirClaimResponseErrorList = class;
  TFhirClaimResponseNote = class;
  TFhirClaimResponseNoteList = class;
  TFhirClaimResponseCoverage = class;
  TFhirClaimResponseCoverageList = class;
  TFhirClaimResponse = class;
  TFhirClaimResponseList = class;
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CONTRACT}
  TFhirContractActor = class;
  TFhirContractActorList = class;
  TFhirContractValuedItem = class;
  TFhirContractValuedItemList = class;
  TFhirContractSigner = class;
  TFhirContractSignerList = class;
  TFhirContractTerm = class;
  TFhirContractTermList = class;
  TFhirContractTermActor = class;
  TFhirContractTermActorList = class;
  TFhirContractTermValuedItem = class;
  TFhirContractTermValuedItemList = class;
  TFhirContractFriendly = class;
  TFhirContractFriendlyList = class;
  TFhirContractLegal = class;
  TFhirContractLegalList = class;
  TFhirContractRule = class;
  TFhirContractRuleList = class;
  TFhirContract = class;
  TFhirContractList = class;
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_ELIGIBILITYREQUEST}
  TFhirEligibilityRequest = class;
  TFhirEligibilityRequestList = class;
{$ENDIF FHIR_ELIGIBILITYREQUEST}
{$IFDEF FHIR_ELIGIBILITYRESPONSE}
  TFhirEligibilityResponse = class;
  TFhirEligibilityResponseList = class;
{$ENDIF FHIR_ELIGIBILITYRESPONSE}
{$IFDEF FHIR_ENROLLMENTREQUEST}
  TFhirEnrollmentRequest = class;
  TFhirEnrollmentRequestList = class;
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
  TFhirEnrollmentResponse = class;
  TFhirEnrollmentResponseList = class;
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
  TFhirExplanationOfBenefit = class;
  TFhirExplanationOfBenefitList = class;
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_LIST}
  TFhirListEntry = class;
  TFhirListEntryList = class;
  TFhirList = class;
  TFhirListList = class;
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_MEDICATION}
  TFhirMedicationProduct = class;
  TFhirMedicationProductList = class;
  TFhirMedicationProductIngredient = class;
  TFhirMedicationProductIngredientList = class;
  TFhirMedicationProductBatch = class;
  TFhirMedicationProductBatchList = class;
  TFhirMedicationPackage = class;
  TFhirMedicationPackageList = class;
  TFhirMedicationPackageContent = class;
  TFhirMedicationPackageContentList = class;
  TFhirMedication = class;
  TFhirMedicationList = class;
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MESSAGEHEADER}
  TFhirMessageHeaderResponse = class;
  TFhirMessageHeaderResponseList = class;
  TFhirMessageHeaderSource = class;
  TFhirMessageHeaderSourceList = class;
  TFhirMessageHeaderDestination = class;
  TFhirMessageHeaderDestinationList = class;
  TFhirMessageHeader = class;
  TFhirMessageHeaderList = class;
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_OPERATIONOUTCOME}
  TFhirOperationOutcomeIssue = class;
  TFhirOperationOutcomeIssueList = class;
  TFhirOperationOutcome = class;
  TFhirOperationOutcomeList = class;
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORDER}
  TFhirOrderWhen = class;
  TFhirOrderWhenList = class;
  TFhirOrder = class;
  TFhirOrderList = class;
{$ENDIF FHIR_ORDER}
{$IFDEF FHIR_ORDERRESPONSE}
  TFhirOrderResponse = class;
  TFhirOrderResponseList = class;
{$ENDIF FHIR_ORDERRESPONSE}
{$IFDEF FHIR_PAYMENTNOTICE}
  TFhirPaymentNotice = class;
  TFhirPaymentNoticeList = class;
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
  TFhirPaymentReconciliationDetail = class;
  TFhirPaymentReconciliationDetailList = class;
  TFhirPaymentReconciliationNote = class;
  TFhirPaymentReconciliationNoteList = class;
  TFhirPaymentReconciliation = class;
  TFhirPaymentReconciliationList = class;
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PROCESSREQUEST}
  TFhirProcessRequestItem = class;
  TFhirProcessRequestItemList = class;
  TFhirProcessRequest = class;
  TFhirProcessRequestList = class;
{$ENDIF FHIR_PROCESSREQUEST}
{$IFDEF FHIR_PROCESSRESPONSE}
  TFhirProcessResponseNotes = class;
  TFhirProcessResponseNotesList = class;
  TFhirProcessResponse = class;
  TFhirProcessResponseList = class;
{$ENDIF FHIR_PROCESSRESPONSE}
{$IFDEF FHIR_PROVENANCE}
  TFhirProvenanceAgent = class;
  TFhirProvenanceAgentList = class;
  TFhirProvenanceAgentRelatedAgent = class;
  TFhirProvenanceAgentRelatedAgentList = class;
  TFhirProvenanceEntity = class;
  TFhirProvenanceEntityList = class;
  TFhirProvenance = class;
  TFhirProvenanceList = class;
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_SUBSCRIPTION}
  TFhirSubscriptionChannel = class;
  TFhirSubscriptionChannelList = class;
  TFhirSubscription = class;
  TFhirSubscriptionList = class;
{$ENDIF FHIR_SUBSCRIPTION}

{$IFDEF FHIR_PARAMETERS}

  // A parameter passed to or received from the operation.
  TFhirParametersParameter = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FValue : TFhirType;
    FResource : TFhirResource;
    FpartList : TFhirParametersParameterList;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetValue(value : TFhirType);
    Procedure SetResource(value : TFhirResource);
    function GetPartList : TFhirParametersParameterList;
    function GetHasPartList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirParametersParameter; overload;
    function Clone : TFhirParametersParameter; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The name of the parameter (reference to the operation definition).
    property name : String read GetNameST write SetNameST;
    // The name of the parameter (reference to the operation definition).
    property nameElement : TFhirString read FName write SetName;

    // Typed access to If the parameter is a data type. (defined for API consistency)
    property value : TFhirType read FValue write SetValue;
    // If the parameter is a data type.
    property valueElement : TFhirType read FValue write SetValue;

    // Typed access to If the parameter is a whole resource. (defined for API consistency)
    property resource : TFhirResource read FResource write SetResource;
    // If the parameter is a whole resource.
    property resourceElement : TFhirResource read FResource write SetResource;

    // A named part of a parameter. In many implementation context, a set of named parts is known as a "Tuple".
    property partList : TFhirParametersParameterList read GetPartList;
    property hasPartList : boolean read GetHasPartList;

  end;

  TFhirParametersParameterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirParametersParameterList;
    function GetCurrent : TFhirParametersParameter;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirParametersParameterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirParametersParameter read GetCurrent;
  end;

  TFhirParametersParameterList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirParametersParameter;
    procedure SetItemN(index : Integer; value : TFhirParametersParameter);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirParametersParameterList; Overload;
    function Clone : TFhirParametersParameterList; Overload;
    function GetEnumerator : TFhirParametersParameterListEnumerator;

    //  Add a FhirParametersParameter to the end of the list.
    function Append : TFhirParametersParameter;

    // Add an already existing FhirParametersParameter to the end of the list.
    procedure AddItem(value : TFhirParametersParameter); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirParametersParameter) : Integer;

    // Insert FhirParametersParameter before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirParametersParameter;

    // Insert an existing FhirParametersParameter before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirParametersParameter);

    // Get the iIndexth FhirParametersParameter. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirParametersParameter);

    // The number of items in the collection
    function Item(index : Integer) : TFhirParametersParameter;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirParametersParameters[index : Integer] : TFhirParametersParameter read GetItemN write SetItemN; default;
  End;

  // This special resource type is used to represent an operation request and response (operations.html). It has no other use, and there is no RESTful endpoint associated with it.
  TFhirParameters = class (TFhirResource)
  protected
    FparameterList : TFhirParametersParameterList;
    function GetParameterList : TFhirParametersParameterList;
    function GetHasParameterList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirParameters; overload;
    function Clone : TFhirParameters; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A parameter passed to or received from the operation.
    property parameterList : TFhirParametersParameterList read GetParameterList;
    property hasParameterList : boolean read GetHasParameterList;

  end;

  TFhirParametersListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirParametersList;
    function GetCurrent : TFhirParameters;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirParametersList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirParameters read GetCurrent;
  end;

  TFhirParametersList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirParameters;
    procedure SetItemN(index : Integer; value : TFhirParameters);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirParametersList; Overload;
    function Clone : TFhirParametersList; Overload;
    function GetEnumerator : TFhirParametersListEnumerator;

    //  Add a FhirParameters to the end of the list.
    function Append : TFhirParameters;

    // Add an already existing FhirParameters to the end of the list.
    procedure AddItem(value : TFhirParameters); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirParameters) : Integer;

    // Insert FhirParameters before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirParameters;

    // Insert an existing FhirParameters before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirParameters);

    // Get the iIndexth FhirParameters. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirParameters);

    // The number of items in the collection
    function Item(index : Integer) : TFhirParameters;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirParameters[index : Integer] : TFhirParameters read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PARAMETERS}

{$IFDEF FHIR_AUDITEVENT}

  // Identifies the name, action type, time, and disposition of the audited event.
  TFhirAuditEventEvent = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCoding;
    FsubtypeList : TFhirCodingList;
    FAction : TFhirEnum;
    FDateTime : TFhirInstant;
    FOutcome : TFhirEnum;
    FOutcomeDesc : TFhirString;
    FpurposeOfEventList : TFhirCodingList;
    Procedure SetType_(value : TFhirCoding);
    function GetSubtypeList : TFhirCodingList;
    function GetHasSubtypeList : Boolean;
    Procedure SetAction(value : TFhirEnum);
    Function GetActionST : TFhirAuditEventActionEnum;
    Procedure SetActionST(value : TFhirAuditEventActionEnum);
    Procedure SetDateTime(value : TFhirInstant);
    Function GetDateTimeST : TFslDateTime;
    Procedure SetDateTimeST(value : TFslDateTime);
    Procedure SetOutcome(value : TFhirEnum);
    Function GetOutcomeST : TFhirAuditEventOutcomeEnum;
    Procedure SetOutcomeST(value : TFhirAuditEventOutcomeEnum);
    Procedure SetOutcomeDesc(value : TFhirString);
    Function GetOutcomeDescST : String;
    Procedure SetOutcomeDescST(value : String);
    function GetPurposeOfEventList : TFhirCodingList;
    function GetHasPurposeOfEventList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAuditEventEvent; overload;
    function Clone : TFhirAuditEventEvent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Identifier for a family of the event.  For example, a menu item, program, rule, policy, function code, application name or URL. It identifies the performed function. (defined for API consistency)
    property type_ : TFhirCoding read FType_ write SetType_;
    // Identifier for a family of the event.  For example, a menu item, program, rule, policy, function code, application name or URL. It identifies the performed function.
    property type_Element : TFhirCoding read FType_ write SetType_;

    // Identifier for the category of event.
    property subtypeList : TFhirCodingList read GetSubtypeList;
    property hasSubtypeList : boolean read GetHasSubtypeList;

    // Indicator for type of action performed during the event that generated the audit.
    property action : TFhirAuditEventActionEnum read GetActionST write SetActionST;
    property actionElement : TFhirEnum read FAction write SetAction;

    // Typed access to The time when the event occurred on the source.
    property dateTime : TFslDateTime read GetDateTimeST write SetDateTimeST;
    // The time when the event occurred on the source.
    property dateTimeElement : TFhirInstant read FDateTime write SetDateTime;

    // Indicates whether the event succeeded or failed.
    property outcome : TFhirAuditEventOutcomeEnum read GetOutcomeST write SetOutcomeST;
    property outcomeElement : TFhirEnum read FOutcome write SetOutcome;

    // Typed access to A free text description of the outcome of the event.
    property outcomeDesc : String read GetOutcomeDescST write SetOutcomeDescST;
    // A free text description of the outcome of the event.
    property outcomeDescElement : TFhirString read FOutcomeDesc write SetOutcomeDesc;

    // The purposeOfUse (reason) that was used during the event being recorded.
    property purposeOfEventList : TFhirCodingList read GetPurposeOfEventList;
    property hasPurposeOfEventList : boolean read GetHasPurposeOfEventList;

  end;

  TFhirAuditEventEventListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAuditEventEventList;
    function GetCurrent : TFhirAuditEventEvent;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAuditEventEventList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAuditEventEvent read GetCurrent;
  end;

  TFhirAuditEventEventList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirAuditEventEvent;
    procedure SetItemN(index : Integer; value : TFhirAuditEventEvent);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirAuditEventEventList; Overload;
    function Clone : TFhirAuditEventEventList; Overload;
    function GetEnumerator : TFhirAuditEventEventListEnumerator;

    //  Add a FhirAuditEventEvent to the end of the list.
    function Append : TFhirAuditEventEvent;

    // Add an already existing FhirAuditEventEvent to the end of the list.
    procedure AddItem(value : TFhirAuditEventEvent); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAuditEventEvent) : Integer;

    // Insert FhirAuditEventEvent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAuditEventEvent;

    // Insert an existing FhirAuditEventEvent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAuditEventEvent);

    // Get the iIndexth FhirAuditEventEvent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAuditEventEvent);

    // The number of items in the collection
    function Item(index : Integer) : TFhirAuditEventEvent;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirAuditEventEvents[index : Integer] : TFhirAuditEventEvent read GetItemN write SetItemN; default;
  End;

  // A person, a hardware device or software process.
  TFhirAuditEventParticipant = class (TFhirBackboneElement)
  protected
    FroleList : TFhirCodeableConceptList;
    FReference : TFhirReference{Resource};
    FUserId : TFhirIdentifier;
    FAltId : TFhirString;
    FName : TFhirString;
    FRequestor : TFhirBoolean;
    FLocation : TFhirReference{TFhirLocation};
    FpolicyList : TFhirUriList;
    FMedia : TFhirCoding;
    FNetwork : TFhirAuditEventParticipantNetwork;
    FpurposeOfUseList : TFhirCodingList;
    function GetRoleList : TFhirCodeableConceptList;
    function GetHasRoleList : Boolean;
    Procedure SetReference(value : TFhirReference{Resource});
    Procedure SetUserId(value : TFhirIdentifier);
    Procedure SetAltId(value : TFhirString);
    Function GetAltIdST : String;
    Procedure SetAltIdST(value : String);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetRequestor(value : TFhirBoolean);
    Function GetRequestorST : Boolean;
    Procedure SetRequestorST(value : Boolean);
    Procedure SetLocation(value : TFhirReference{TFhirLocation});
    function GetPolicyList : TFhirUriList;
    function GetHasPolicyList : Boolean;
    Procedure SetMedia(value : TFhirCoding);
    Procedure SetNetwork(value : TFhirAuditEventParticipantNetwork);
    function GetPurposeOfUseList : TFhirCodingList;
    function GetHasPurposeOfUseList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAuditEventParticipant; overload;
    function Clone : TFhirAuditEventParticipant; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Specification of the role(s) the user plays when performing the event. Usually the codes used in this element are local codes defined by the role-based access control security system used in the local context.
    property roleList : TFhirCodeableConceptList read GetRoleList;
    property hasRoleList : boolean read GetHasRoleList;

    // Typed access to Direct reference to a resource that identifies the participant. (defined for API consistency)
    property reference : TFhirReference{Resource} read FReference write SetReference;
    // Direct reference to a resource that identifies the participant.
    property referenceElement : TFhirReference{Resource} read FReference write SetReference;

    // Typed access to Unique identifier for the user actively participating in the event. (defined for API consistency)
    property userId : TFhirIdentifier read FUserId write SetUserId;
    // Unique identifier for the user actively participating in the event.
    property userIdElement : TFhirIdentifier read FUserId write SetUserId;

    // Typed access to Alternative Participant Identifier. For a human, this should be a user identifier text string from authentication system. This identifier would be one known to a common authentication system (e.g. single sign-on), if available.
    property altId : String read GetAltIdST write SetAltIdST;
    // Alternative Participant Identifier. For a human, this should be a user identifier text string from authentication system. This identifier would be one known to a common authentication system (e.g. single sign-on), if available.
    property altIdElement : TFhirString read FAltId write SetAltId;

    // Typed access to Human-meaningful name for the user.
    property name : String read GetNameST write SetNameST;
    // Human-meaningful name for the user.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Indicator that the user is or is not the requestor, or initiator, for the event being audited.
    property requestor : Boolean read GetRequestorST write SetRequestorST;
    // Indicator that the user is or is not the requestor, or initiator, for the event being audited.
    property requestorElement : TFhirBoolean read FRequestor write SetRequestor;

    // Typed access to Where the event occurred. (defined for API consistency)
    property location : TFhirReference{TFhirLocation} read FLocation write SetLocation;
    // Where the event occurred.
    property locationElement : TFhirReference{TFhirLocation} read FLocation write SetLocation;

    // The policy or plan that authorized the activity being recorded. Typically, a single activity may have multiple applicable policies, such as patient consent, guarantor funding, etc. The policy would also indicate the security token used.
    property policyList : TFhirUriList read GetPolicyList;
    property hasPolicyList : boolean read GetHasPolicyList;

    // Typed access to Type of media involved. Used when the event is about exporting/importing onto media. (defined for API consistency)
    property media : TFhirCoding read FMedia write SetMedia;
    // Type of media involved. Used when the event is about exporting/importing onto media.
    property mediaElement : TFhirCoding read FMedia write SetMedia;

    // Typed access to Logical network location for application activity, if the activity has a network location. (defined for API consistency)
    property network : TFhirAuditEventParticipantNetwork read FNetwork write SetNetwork;
    // Logical network location for application activity, if the activity has a network location.
    property networkElement : TFhirAuditEventParticipantNetwork read FNetwork write SetNetwork;

    // The reason (purpose of use), specific to this participant, that was used during the event being recorded.
    property purposeOfUseList : TFhirCodingList read GetPurposeOfUseList;
    property hasPurposeOfUseList : boolean read GetHasPurposeOfUseList;

  end;

  TFhirAuditEventParticipantListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAuditEventParticipantList;
    function GetCurrent : TFhirAuditEventParticipant;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAuditEventParticipantList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAuditEventParticipant read GetCurrent;
  end;

  TFhirAuditEventParticipantList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirAuditEventParticipant;
    procedure SetItemN(index : Integer; value : TFhirAuditEventParticipant);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirAuditEventParticipantList; Overload;
    function Clone : TFhirAuditEventParticipantList; Overload;
    function GetEnumerator : TFhirAuditEventParticipantListEnumerator;

    //  Add a FhirAuditEventParticipant to the end of the list.
    function Append : TFhirAuditEventParticipant;

    // Add an already existing FhirAuditEventParticipant to the end of the list.
    procedure AddItem(value : TFhirAuditEventParticipant); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAuditEventParticipant) : Integer;

    // Insert FhirAuditEventParticipant before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAuditEventParticipant;

    // Insert an existing FhirAuditEventParticipant before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAuditEventParticipant);

    // Get the iIndexth FhirAuditEventParticipant. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAuditEventParticipant);

    // The number of items in the collection
    function Item(index : Integer) : TFhirAuditEventParticipant;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirAuditEventParticipants[index : Integer] : TFhirAuditEventParticipant read GetItemN write SetItemN; default;
  End;

  // Logical network location for application activity, if the activity has a network location.
  TFhirAuditEventParticipantNetwork = class (TFhirBackboneElement)
  protected
    FAddress : TFhirString;
    FType_ : TFhirEnum;
    Procedure SetAddress(value : TFhirString);
    Function GetAddressST : String;
    Procedure SetAddressST(value : String);
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirNetworkTypeEnum;
    Procedure SetType_ST(value : TFhirNetworkTypeEnum);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAuditEventParticipantNetwork; overload;
    function Clone : TFhirAuditEventParticipantNetwork; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An identifier for the network access point of the user device for the audit event.
    property address : String read GetAddressST write SetAddressST;
    // An identifier for the network access point of the user device for the audit event.
    property addressElement : TFhirString read FAddress write SetAddress;

    // An identifier for the type of network access point that originated the audit event.
    property type_ : TFhirNetworkTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

  end;

  TFhirAuditEventParticipantNetworkListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAuditEventParticipantNetworkList;
    function GetCurrent : TFhirAuditEventParticipantNetwork;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAuditEventParticipantNetworkList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAuditEventParticipantNetwork read GetCurrent;
  end;

  TFhirAuditEventParticipantNetworkList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirAuditEventParticipantNetwork;
    procedure SetItemN(index : Integer; value : TFhirAuditEventParticipantNetwork);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirAuditEventParticipantNetworkList; Overload;
    function Clone : TFhirAuditEventParticipantNetworkList; Overload;
    function GetEnumerator : TFhirAuditEventParticipantNetworkListEnumerator;

    //  Add a FhirAuditEventParticipantNetwork to the end of the list.
    function Append : TFhirAuditEventParticipantNetwork;

    // Add an already existing FhirAuditEventParticipantNetwork to the end of the list.
    procedure AddItem(value : TFhirAuditEventParticipantNetwork); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAuditEventParticipantNetwork) : Integer;

    // Insert FhirAuditEventParticipantNetwork before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAuditEventParticipantNetwork;

    // Insert an existing FhirAuditEventParticipantNetwork before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAuditEventParticipantNetwork);

    // Get the iIndexth FhirAuditEventParticipantNetwork. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAuditEventParticipantNetwork);

    // The number of items in the collection
    function Item(index : Integer) : TFhirAuditEventParticipantNetwork;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirAuditEventParticipantNetworks[index : Integer] : TFhirAuditEventParticipantNetwork read GetItemN write SetItemN; default;
  End;

  // Application systems and processes.
  TFhirAuditEventSource = class (TFhirBackboneElement)
  protected
    FSite : TFhirString;
    FIdentifier : TFhirIdentifier;
    Ftype_List : TFhirCodingList;
    Procedure SetSite(value : TFhirString);
    Function GetSiteST : String;
    Procedure SetSiteST(value : String);
    Procedure SetIdentifier(value : TFhirIdentifier);
    function GetType_List : TFhirCodingList;
    function GetHasType_List : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAuditEventSource; overload;
    function Clone : TFhirAuditEventSource; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Logical source location within the healthcare enterprise network.  For example, a hospital or other provider location within a multi-entity provider group.
    property site : String read GetSiteST write SetSiteST;
    // Logical source location within the healthcare enterprise network.  For example, a hospital or other provider location within a multi-entity provider group.
    property siteElement : TFhirString read FSite write SetSite;

    // Typed access to Identifier of the source where the event was detected. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Identifier of the source where the event was detected.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Code specifying the type of source where event originated.
    property type_List : TFhirCodingList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

  end;

  TFhirAuditEventSourceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAuditEventSourceList;
    function GetCurrent : TFhirAuditEventSource;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAuditEventSourceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAuditEventSource read GetCurrent;
  end;

  TFhirAuditEventSourceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirAuditEventSource;
    procedure SetItemN(index : Integer; value : TFhirAuditEventSource);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirAuditEventSourceList; Overload;
    function Clone : TFhirAuditEventSourceList; Overload;
    function GetEnumerator : TFhirAuditEventSourceListEnumerator;

    //  Add a FhirAuditEventSource to the end of the list.
    function Append : TFhirAuditEventSource;

    // Add an already existing FhirAuditEventSource to the end of the list.
    procedure AddItem(value : TFhirAuditEventSource); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAuditEventSource) : Integer;

    // Insert FhirAuditEventSource before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAuditEventSource;

    // Insert an existing FhirAuditEventSource before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAuditEventSource);

    // Get the iIndexth FhirAuditEventSource. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAuditEventSource);

    // The number of items in the collection
    function Item(index : Integer) : TFhirAuditEventSource;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirAuditEventSources[index : Integer] : TFhirAuditEventSource read GetItemN write SetItemN; default;
  End;

  // Specific instances of data or objects that have been accessed.
  TFhirAuditEventObject = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirIdentifier;
    FReference : TFhirReference{TFhirReference};
    FType_ : TFhirCoding;
    FRole : TFhirCoding;
    FLifecycle : TFhirCoding;
    FsecurityLabelList : TFhirCodingList;
    FName : TFhirString;
    FDescription : TFhirString;
    FQuery : TFhirBase64Binary;
    FdetailList : TFhirAuditEventObjectDetailList;
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetReference(value : TFhirReference{TFhirReference});
    Procedure SetType_(value : TFhirCoding);
    Procedure SetRole(value : TFhirCoding);
    Procedure SetLifecycle(value : TFhirCoding);
    function GetSecurityLabelList : TFhirCodingList;
    function GetHasSecurityLabelList : Boolean;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetQuery(value : TFhirBase64Binary);
    Function GetQueryST : TBytes;
    Procedure SetQueryST(value : TBytes);
    function GetDetailList : TFhirAuditEventObjectDetailList;
    function GetHasDetailList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAuditEventObject; overload;
    function Clone : TFhirAuditEventObject; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Identifies a specific instance of the participant object. The reference should always be version specific. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Identifies a specific instance of the participant object. The reference should always be version specific.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to Identifies a specific instance of the participant object. The reference should always be version specific. (defined for API consistency)
    property reference : TFhirReference{TFhirReference} read FReference write SetReference;
    // Identifies a specific instance of the participant object. The reference should always be version specific.
    property referenceElement : TFhirReference{TFhirReference} read FReference write SetReference;

    // Typed access to The type of the object that was involved in this audit event. (defined for API consistency)
    property type_ : TFhirCoding read FType_ write SetType_;
    // The type of the object that was involved in this audit event.
    property type_Element : TFhirCoding read FType_ write SetType_;

    // Typed access to Code representing the functional application role of Participant Object being audited. (defined for API consistency)
    property role : TFhirCoding read FRole write SetRole;
    // Code representing the functional application role of Participant Object being audited.
    property roleElement : TFhirCoding read FRole write SetRole;

    // Typed access to Identifier for the data life-cycle stage for the participant object. (defined for API consistency)
    property lifecycle : TFhirCoding read FLifecycle write SetLifecycle;
    // Identifier for the data life-cycle stage for the participant object.
    property lifecycleElement : TFhirCoding read FLifecycle write SetLifecycle;

    // Denotes security labels for the identified object.
    property securityLabelList : TFhirCodingList read GetSecurityLabelList;
    property hasSecurityLabelList : boolean read GetHasSecurityLabelList;

    // Typed access to An instance-specific descriptor of the Participant Object ID audited, such as a person's name.
    property name : String read GetNameST write SetNameST;
    // An instance-specific descriptor of the Participant Object ID audited, such as a person's name.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Text that describes the object in more detail.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Text that describes the object in more detail.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to The actual query for a query-type participant object.
    property query : TBytes read GetQueryST write SetQueryST;
    // The actual query for a query-type participant object.
    property queryElement : TFhirBase64Binary read FQuery write SetQuery;

    // Additional Information about the Object.
    property detailList : TFhirAuditEventObjectDetailList read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

  end;

  TFhirAuditEventObjectListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAuditEventObjectList;
    function GetCurrent : TFhirAuditEventObject;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAuditEventObjectList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAuditEventObject read GetCurrent;
  end;

  TFhirAuditEventObjectList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirAuditEventObject;
    procedure SetItemN(index : Integer; value : TFhirAuditEventObject);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirAuditEventObjectList; Overload;
    function Clone : TFhirAuditEventObjectList; Overload;
    function GetEnumerator : TFhirAuditEventObjectListEnumerator;

    //  Add a FhirAuditEventObject to the end of the list.
    function Append : TFhirAuditEventObject;

    // Add an already existing FhirAuditEventObject to the end of the list.
    procedure AddItem(value : TFhirAuditEventObject); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAuditEventObject) : Integer;

    // Insert FhirAuditEventObject before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAuditEventObject;

    // Insert an existing FhirAuditEventObject before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAuditEventObject);

    // Get the iIndexth FhirAuditEventObject. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAuditEventObject);

    // The number of items in the collection
    function Item(index : Integer) : TFhirAuditEventObject;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirAuditEventObjects[index : Integer] : TFhirAuditEventObject read GetItemN write SetItemN; default;
  End;

  // Additional Information about the Object.
  TFhirAuditEventObjectDetail = class (TFhirBackboneElement)
  protected
    FType_ : TFhirString;
    FValue : TFhirBase64Binary;
    Procedure SetType_(value : TFhirString);
    Function GetType_ST : String;
    Procedure SetType_ST(value : String);
    Procedure SetValue(value : TFhirBase64Binary);
    Function GetValueST : TBytes;
    Procedure SetValueST(value : TBytes);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAuditEventObjectDetail; overload;
    function Clone : TFhirAuditEventObjectDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Name of the property.
    property type_ : String read GetType_ST write SetType_ST;
    // Name of the property.
    property type_Element : TFhirString read FType_ write SetType_;

    // Typed access to Property value.
    property value : TBytes read GetValueST write SetValueST;
    // Property value.
    property valueElement : TFhirBase64Binary read FValue write SetValue;

  end;

  TFhirAuditEventObjectDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAuditEventObjectDetailList;
    function GetCurrent : TFhirAuditEventObjectDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAuditEventObjectDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAuditEventObjectDetail read GetCurrent;
  end;

  TFhirAuditEventObjectDetailList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirAuditEventObjectDetail;
    procedure SetItemN(index : Integer; value : TFhirAuditEventObjectDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirAuditEventObjectDetailList; Overload;
    function Clone : TFhirAuditEventObjectDetailList; Overload;
    function GetEnumerator : TFhirAuditEventObjectDetailListEnumerator;

    //  Add a FhirAuditEventObjectDetail to the end of the list.
    function Append : TFhirAuditEventObjectDetail;

    // Add an already existing FhirAuditEventObjectDetail to the end of the list.
    procedure AddItem(value : TFhirAuditEventObjectDetail); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAuditEventObjectDetail) : Integer;

    // Insert FhirAuditEventObjectDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAuditEventObjectDetail;

    // Insert an existing FhirAuditEventObjectDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAuditEventObjectDetail);

    // Get the iIndexth FhirAuditEventObjectDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAuditEventObjectDetail);

    // The number of items in the collection
    function Item(index : Integer) : TFhirAuditEventObjectDetail;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirAuditEventObjectDetails[index : Integer] : TFhirAuditEventObjectDetail read GetItemN write SetItemN; default;
  End;

  // A record of an event made for purposes of maintaining a security log. Typical uses include detection of intrusion attempts and monitoring for inappropriate usage.
  TFhirAuditEvent = class (TFhirDomainResource)
  protected
    FEvent : TFhirAuditEventEvent;
    FparticipantList : TFhirAuditEventParticipantList;
    FSource : TFhirAuditEventSource;
    Fobject_List : TFhirAuditEventObjectList;
    Procedure SetEvent(value : TFhirAuditEventEvent);
    function GetParticipantList : TFhirAuditEventParticipantList;
    function GetHasParticipantList : Boolean;
    Procedure SetSource(value : TFhirAuditEventSource);
    function GetObject_List : TFhirAuditEventObjectList;
    function GetHasObject_List : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAuditEvent; overload;
    function Clone : TFhirAuditEvent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Identifies the name, action type, time, and disposition of the audited event. (defined for API consistency)
    property event : TFhirAuditEventEvent read FEvent write SetEvent;
    // Identifies the name, action type, time, and disposition of the audited event.
    property eventElement : TFhirAuditEventEvent read FEvent write SetEvent;

    // A person, a hardware device or software process.
    property participantList : TFhirAuditEventParticipantList read GetParticipantList;
    property hasParticipantList : boolean read GetHasParticipantList;

    // Typed access to Application systems and processes. (defined for API consistency)
    property source : TFhirAuditEventSource read FSource write SetSource;
    // Application systems and processes.
    property sourceElement : TFhirAuditEventSource read FSource write SetSource;

    // Specific instances of data or objects that have been accessed.
    property object_List : TFhirAuditEventObjectList read GetObject_List;
    property hasObject_List : boolean read GetHasObject_List;

  end;

  TFhirAuditEventListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAuditEventList;
    function GetCurrent : TFhirAuditEvent;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAuditEventList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAuditEvent read GetCurrent;
  end;

  TFhirAuditEventList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirAuditEvent;
    procedure SetItemN(index : Integer; value : TFhirAuditEvent);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirAuditEventList; Overload;
    function Clone : TFhirAuditEventList; Overload;
    function GetEnumerator : TFhirAuditEventListEnumerator;

    //  Add a FhirAuditEvent to the end of the list.
    function Append : TFhirAuditEvent;

    // Add an already existing FhirAuditEvent to the end of the list.
    procedure AddItem(value : TFhirAuditEvent); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAuditEvent) : Integer;

    // Insert FhirAuditEvent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAuditEvent;

    // Insert an existing FhirAuditEvent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAuditEvent);

    // Get the iIndexth FhirAuditEvent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAuditEvent);

    // The number of items in the collection
    function Item(index : Integer) : TFhirAuditEvent;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirAuditEvents[index : Integer] : TFhirAuditEvent read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_AUDITEVENT}

{$IFDEF FHIR_BINARY}

  // A binary resource can contain any content, whether text, image, pdf, zip archive, etc.
  TFhirBinary = class (TFhirResource)
  protected
    FContentType : TFhirCode;
    FContent : TFhirBase64Binary;
    Procedure SetContentType(value : TFhirCode);
    Function GetContentTypeST : String;
    Procedure SetContentTypeST(value : String);
    Procedure SetContent(value : TFhirBase64Binary);
    Function GetContentST : TBytes;
    Procedure SetContentST(value : TBytes);

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBinary; overload;
    function Clone : TFhirBinary; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to MimeType of the binary content represented as a standard MimeType (BCP 13).
    property contentType : String read GetContentTypeST write SetContentTypeST;
    // MimeType of the binary content represented as a standard MimeType (BCP 13).
    property contentTypeElement : TFhirCode read FContentType write SetContentType;

    // Typed access to The actual content, base64 encoded.
    property content : TBytes read GetContentST write SetContentST;
    // The actual content, base64 encoded.
    property contentElement : TFhirBase64Binary read FContent write SetContent;

  end;

  TFhirBinaryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBinaryList;
    function GetCurrent : TFhirBinary;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirBinaryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBinary read GetCurrent;
  end;

  TFhirBinaryList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirBinary;
    procedure SetItemN(index : Integer; value : TFhirBinary);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirBinaryList; Overload;
    function Clone : TFhirBinaryList; Overload;
    function GetEnumerator : TFhirBinaryListEnumerator;

    //  Add a FhirBinary to the end of the list.
    function Append : TFhirBinary;

    // Add an already existing FhirBinary to the end of the list.
    procedure AddItem(value : TFhirBinary); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBinary) : Integer;

    // Insert FhirBinary before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBinary;

    // Insert an existing FhirBinary before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBinary);

    // Get the iIndexth FhirBinary. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBinary);

    // The number of items in the collection
    function Item(index : Integer) : TFhirBinary;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirBinaries[index : Integer] : TFhirBinary read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_BINARY}

{$IFDEF FHIR_BUNDLE}

  // A series of links that provide context to this bundle.
  TFhirBundleLink = class (TFhirBackboneElement)
  protected
    FRelation : TFhirString;
    FUrl : TFhirUri;
    Procedure SetRelation(value : TFhirString);
    Function GetRelationST : String;
    Procedure SetRelationST(value : String);
    Procedure SetUrl(value : TFhirUri);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBundleLink; overload;
    function Clone : TFhirBundleLink; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A name which details the functional use for this link - see [[http://www.iana.org/assignments/link-relations/link-relations.xhtml]].
    property relation : String read GetRelationST write SetRelationST;
    // A name which details the functional use for this link - see [[http://www.iana.org/assignments/link-relations/link-relations.xhtml]].
    property relationElement : TFhirString read FRelation write SetRelation;

    // Typed access to The reference details for the link.
    property url : String read GetUrlST write SetUrlST;
    // The reference details for the link.
    property urlElement : TFhirUri read FUrl write SetUrl;

  end;

  TFhirBundleLinkListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBundleLinkList;
    function GetCurrent : TFhirBundleLink;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirBundleLinkList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBundleLink read GetCurrent;
  end;

  TFhirBundleLinkList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirBundleLink;
    procedure SetItemN(index : Integer; value : TFhirBundleLink);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirBundleLinkList; Overload;
    function Clone : TFhirBundleLinkList; Overload;
    function GetEnumerator : TFhirBundleLinkListEnumerator;

    //  Add a FhirBundleLink to the end of the list.
    function Append : TFhirBundleLink;

    // Add an already existing FhirBundleLink to the end of the list.
    procedure AddItem(value : TFhirBundleLink); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBundleLink) : Integer;

    // Insert FhirBundleLink before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBundleLink;

    // Insert an existing FhirBundleLink before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBundleLink);

    // Get the iIndexth FhirBundleLink. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBundleLink);

    // The number of items in the collection
    function Item(index : Integer) : TFhirBundleLink;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirBundleLinks[index : Integer] : TFhirBundleLink read GetItemN write SetItemN; default;
  End;

  // An entry in a bundle resource - will either contain a resource, or information about a resource (transactions and history only).
  TFhirBundleEntry = class (TFhirBackboneElement)
  protected
    Flink_List : TFhirBundleLinkList;
    FFullUrl : TFhirUri;
    FResource : TFhirResource;
    FSearch : TFhirBundleEntrySearch;
    FRequest : TFhirBundleEntryRequest;
    FResponse : TFhirBundleEntryResponse;
    function GetLink_List : TFhirBundleLinkList;
    function GetHasLink_List : Boolean;
    Procedure SetFullUrl(value : TFhirUri);
    Function GetFullUrlST : String;
    Procedure SetFullUrlST(value : String);
    Procedure SetResource(value : TFhirResource);
    Procedure SetSearch(value : TFhirBundleEntrySearch);
    Procedure SetRequest(value : TFhirBundleEntryRequest);
    Procedure SetResponse(value : TFhirBundleEntryResponse);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBundleEntry; overload;
    function Clone : TFhirBundleEntry; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A series of links that provide context to this entry.
    property link_List : TFhirBundleLinkList read GetLink_List;
    property hasLink_List : boolean read GetHasLink_List;

    // Typed access to The Absolute URL for the resource. This must be provided for all resources. The fullUrl SHALL not disagree with the id in the resource. The fullUrl is a version independent reference to the resource.
    property fullUrl : String read GetFullUrlST write SetFullUrlST;
    // The Absolute URL for the resource. This must be provided for all resources. The fullUrl SHALL not disagree with the id in the resource. The fullUrl is a version independent reference to the resource.
    property fullUrlElement : TFhirUri read FFullUrl write SetFullUrl;

    // Typed access to The Resources for the entry. (defined for API consistency)
    property resource : TFhirResource read FResource write SetResource;
    // The Resources for the entry.
    property resourceElement : TFhirResource read FResource write SetResource;

    // Typed access to Information about the search process that lead to the creation of this entry. (defined for API consistency)
    property search : TFhirBundleEntrySearch read FSearch write SetSearch;
    // Information about the search process that lead to the creation of this entry.
    property searchElement : TFhirBundleEntrySearch read FSearch write SetSearch;

    // Typed access to Additional information about how this entry should be processed as part of a transaction. (defined for API consistency)
    property request : TFhirBundleEntryRequest read FRequest write SetRequest;
    // Additional information about how this entry should be processed as part of a transaction.
    property requestElement : TFhirBundleEntryRequest read FRequest write SetRequest;

    // Typed access to Additional information about how this entry should be processed as part of a transaction. (defined for API consistency)
    property response : TFhirBundleEntryResponse read FResponse write SetResponse;
    // Additional information about how this entry should be processed as part of a transaction.
    property responseElement : TFhirBundleEntryResponse read FResponse write SetResponse;

  end;

  TFhirBundleEntryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBundleEntryList;
    function GetCurrent : TFhirBundleEntry;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirBundleEntryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBundleEntry read GetCurrent;
  end;

  TFhirBundleEntryList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirBundleEntry;
    procedure SetItemN(index : Integer; value : TFhirBundleEntry);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirBundleEntryList; Overload;
    function Clone : TFhirBundleEntryList; Overload;
    function GetEnumerator : TFhirBundleEntryListEnumerator;

    //  Add a FhirBundleEntry to the end of the list.
    function Append : TFhirBundleEntry;

    // Add an already existing FhirBundleEntry to the end of the list.
    procedure AddItem(value : TFhirBundleEntry); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBundleEntry) : Integer;

    // Insert FhirBundleEntry before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBundleEntry;

    // Insert an existing FhirBundleEntry before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBundleEntry);

    // Get the iIndexth FhirBundleEntry. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBundleEntry);

    // The number of items in the collection
    function Item(index : Integer) : TFhirBundleEntry;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirBundleEntries[index : Integer] : TFhirBundleEntry read GetItemN write SetItemN; default;
  End;

  // Information about the search process that lead to the creation of this entry.
  TFhirBundleEntrySearch = class (TFhirBackboneElement)
  protected
    FMode : TFhirEnum;
    FScore : TFhirDecimal;
    Procedure SetMode(value : TFhirEnum);
    Function GetModeST : TFhirSearchEntryModeEnum;
    Procedure SetModeST(value : TFhirSearchEntryModeEnum);
    Procedure SetScore(value : TFhirDecimal);
    Function GetScoreST : String;
    Procedure SetScoreST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBundleEntrySearch; overload;
    function Clone : TFhirBundleEntrySearch; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Why this entry is in the result set - whether it's included as a match or because of an _include requirement.
    property mode : TFhirSearchEntryModeEnum read GetModeST write SetModeST;
    property modeElement : TFhirEnum read FMode write SetMode;

    // Typed access to When searching, the server's search ranking score for the entry.
    property score : String read GetScoreST write SetScoreST;
    // When searching, the server's search ranking score for the entry.
    property scoreElement : TFhirDecimal read FScore write SetScore;

  end;

  TFhirBundleEntrySearchListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBundleEntrySearchList;
    function GetCurrent : TFhirBundleEntrySearch;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirBundleEntrySearchList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBundleEntrySearch read GetCurrent;
  end;

  TFhirBundleEntrySearchList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirBundleEntrySearch;
    procedure SetItemN(index : Integer; value : TFhirBundleEntrySearch);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirBundleEntrySearchList; Overload;
    function Clone : TFhirBundleEntrySearchList; Overload;
    function GetEnumerator : TFhirBundleEntrySearchListEnumerator;

    //  Add a FhirBundleEntrySearch to the end of the list.
    function Append : TFhirBundleEntrySearch;

    // Add an already existing FhirBundleEntrySearch to the end of the list.
    procedure AddItem(value : TFhirBundleEntrySearch); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBundleEntrySearch) : Integer;

    // Insert FhirBundleEntrySearch before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBundleEntrySearch;

    // Insert an existing FhirBundleEntrySearch before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBundleEntrySearch);

    // Get the iIndexth FhirBundleEntrySearch. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBundleEntrySearch);

    // The number of items in the collection
    function Item(index : Integer) : TFhirBundleEntrySearch;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirBundleEntrySearches[index : Integer] : TFhirBundleEntrySearch read GetItemN write SetItemN; default;
  End;

  // Additional information about how this entry should be processed as part of a transaction.
  TFhirBundleEntryRequest = class (TFhirBackboneElement)
  protected
    FMethod : TFhirEnum;
    FUrl : TFhirUri;
    FIfNoneMatch : TFhirString;
    FIfModifiedSince : TFhirInstant;
    FIfMatch : TFhirString;
    FIfNoneExist : TFhirString;
    Procedure SetMethod(value : TFhirEnum);
    Function GetMethodST : TFhirHttpVerbEnum;
    Procedure SetMethodST(value : TFhirHttpVerbEnum);
    Procedure SetUrl(value : TFhirUri);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);
    Procedure SetIfNoneMatch(value : TFhirString);
    Function GetIfNoneMatchST : String;
    Procedure SetIfNoneMatchST(value : String);
    Procedure SetIfModifiedSince(value : TFhirInstant);
    Function GetIfModifiedSinceST : TFslDateTime;
    Procedure SetIfModifiedSinceST(value : TFslDateTime);
    Procedure SetIfMatch(value : TFhirString);
    Function GetIfMatchST : String;
    Procedure SetIfMatchST(value : String);
    Procedure SetIfNoneExist(value : TFhirString);
    Function GetIfNoneExistST : String;
    Procedure SetIfNoneExistST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBundleEntryRequest; overload;
    function Clone : TFhirBundleEntryRequest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The HTTP verb for this entry in either a update history, or a transaction/ transaction response.
    property method : TFhirHttpVerbEnum read GetMethodST write SetMethodST;
    property methodElement : TFhirEnum read FMethod write SetMethod;

    // Typed access to The URL for this entry, relative to the root (the address to which the request is posted).
    property url : String read GetUrlST write SetUrlST;
    // The URL for this entry, relative to the root (the address to which the request is posted).
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to If the ETag values match, return a 304 Not modified status. See the API documentation for ["Conditional Read"](http.html#cread).
    property ifNoneMatch : String read GetIfNoneMatchST write SetIfNoneMatchST;
    // If the ETag values match, return a 304 Not modified status. See the API documentation for ["Conditional Read"](http.html#cread).
    property ifNoneMatchElement : TFhirString read FIfNoneMatch write SetIfNoneMatch;

    // Typed access to Only perform the operation if the last updated date matches. See the API documentation for ["Conditional Read"](http.html#cread).
    property ifModifiedSince : TFslDateTime read GetIfModifiedSinceST write SetIfModifiedSinceST;
    // Only perform the operation if the last updated date matches. See the API documentation for ["Conditional Read"](http.html#cread).
    property ifModifiedSinceElement : TFhirInstant read FIfModifiedSince write SetIfModifiedSince;

    // Typed access to Only perform the operation if the Etag value matches. For more information, see the API section ["Managing Resource Contention"](http.html#concurrency).
    property ifMatch : String read GetIfMatchST write SetIfMatchST;
    // Only perform the operation if the Etag value matches. For more information, see the API section ["Managing Resource Contention"](http.html#concurrency).
    property ifMatchElement : TFhirString read FIfMatch write SetIfMatch;

    // Typed access to Instruct the server not to perform the create if a specified resource already exists. For further information, see the API documentation for ["Conditional Create"](http.html#ccreate). This is just the query portion of the URL - what follows the "?" (not including the "?").
    property ifNoneExist : String read GetIfNoneExistST write SetIfNoneExistST;
    // Instruct the server not to perform the create if a specified resource already exists. For further information, see the API documentation for ["Conditional Create"](http.html#ccreate). This is just the query portion of the URL - what follows the "?" (not including the "?").
    property ifNoneExistElement : TFhirString read FIfNoneExist write SetIfNoneExist;

  end;

  TFhirBundleEntryRequestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBundleEntryRequestList;
    function GetCurrent : TFhirBundleEntryRequest;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirBundleEntryRequestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBundleEntryRequest read GetCurrent;
  end;

  TFhirBundleEntryRequestList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirBundleEntryRequest;
    procedure SetItemN(index : Integer; value : TFhirBundleEntryRequest);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirBundleEntryRequestList; Overload;
    function Clone : TFhirBundleEntryRequestList; Overload;
    function GetEnumerator : TFhirBundleEntryRequestListEnumerator;

    //  Add a FhirBundleEntryRequest to the end of the list.
    function Append : TFhirBundleEntryRequest;

    // Add an already existing FhirBundleEntryRequest to the end of the list.
    procedure AddItem(value : TFhirBundleEntryRequest); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBundleEntryRequest) : Integer;

    // Insert FhirBundleEntryRequest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBundleEntryRequest;

    // Insert an existing FhirBundleEntryRequest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBundleEntryRequest);

    // Get the iIndexth FhirBundleEntryRequest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBundleEntryRequest);

    // The number of items in the collection
    function Item(index : Integer) : TFhirBundleEntryRequest;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirBundleEntryRequests[index : Integer] : TFhirBundleEntryRequest read GetItemN write SetItemN; default;
  End;

  // Additional information about how this entry should be processed as part of a transaction.
  TFhirBundleEntryResponse = class (TFhirBackboneElement)
  protected
    FStatus : TFhirString;
    FLocation : TFhirUri;
    FEtag : TFhirString;
    FLastModified : TFhirInstant;
    Procedure SetStatus(value : TFhirString);
    Function GetStatusST : String;
    Procedure SetStatusST(value : String);
    Procedure SetLocation(value : TFhirUri);
    Function GetLocationST : String;
    Procedure SetLocationST(value : String);
    Procedure SetEtag(value : TFhirString);
    Function GetEtagST : String;
    Procedure SetEtagST(value : String);
    Procedure SetLastModified(value : TFhirInstant);
    Function GetLastModifiedST : TFslDateTime;
    Procedure SetLastModifiedST(value : TFslDateTime);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBundleEntryResponse; overload;
    function Clone : TFhirBundleEntryResponse; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The status code returned by processing this entry.
    property status : String read GetStatusST write SetStatusST;
    // The status code returned by processing this entry.
    property statusElement : TFhirString read FStatus write SetStatus;

    // Typed access to The location header created by processing this operation.
    property location : String read GetLocationST write SetLocationST;
    // The location header created by processing this operation.
    property locationElement : TFhirUri read FLocation write SetLocation;

    // Typed access to The etag for the resource, it the operation for the entry produced a versioned resource.
    property etag : String read GetEtagST write SetEtagST;
    // The etag for the resource, it the operation for the entry produced a versioned resource.
    property etagElement : TFhirString read FEtag write SetEtag;

    // Typed access to The date/time that the resource was modified on the server.
    property lastModified : TFslDateTime read GetLastModifiedST write SetLastModifiedST;
    // The date/time that the resource was modified on the server.
    property lastModifiedElement : TFhirInstant read FLastModified write SetLastModified;

  end;

  TFhirBundleEntryResponseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBundleEntryResponseList;
    function GetCurrent : TFhirBundleEntryResponse;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirBundleEntryResponseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBundleEntryResponse read GetCurrent;
  end;

  TFhirBundleEntryResponseList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirBundleEntryResponse;
    procedure SetItemN(index : Integer; value : TFhirBundleEntryResponse);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirBundleEntryResponseList; Overload;
    function Clone : TFhirBundleEntryResponseList; Overload;
    function GetEnumerator : TFhirBundleEntryResponseListEnumerator;

    //  Add a FhirBundleEntryResponse to the end of the list.
    function Append : TFhirBundleEntryResponse;

    // Add an already existing FhirBundleEntryResponse to the end of the list.
    procedure AddItem(value : TFhirBundleEntryResponse); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBundleEntryResponse) : Integer;

    // Insert FhirBundleEntryResponse before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBundleEntryResponse;

    // Insert an existing FhirBundleEntryResponse before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBundleEntryResponse);

    // Get the iIndexth FhirBundleEntryResponse. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBundleEntryResponse);

    // The number of items in the collection
    function Item(index : Integer) : TFhirBundleEntryResponse;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirBundleEntryResponses[index : Integer] : TFhirBundleEntryResponse read GetItemN write SetItemN; default;
  End;

  // A container for a collection of resources.
  TFhirBundle = class (TFhirResource)
  protected
    FType_ : TFhirEnum;
    FTotal : TFhirUnsignedInt;
    Flink_List : TFhirBundleLinkList;
    FentryList : TFhirBundleEntryList;
    FSignature : TFhirSignature;
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirBundleTypeEnum;
    Procedure SetType_ST(value : TFhirBundleTypeEnum);
    Procedure SetTotal(value : TFhirUnsignedInt);
    Function GetTotalST : String;
    Procedure SetTotalST(value : String);
    function GetLink_List : TFhirBundleLinkList;
    function GetHasLink_List : Boolean;
    function GetEntryList : TFhirBundleEntryList;
    function GetHasEntryList : Boolean;
    Procedure SetSignature(value : TFhirSignature);

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBundle; overload;
    function Clone : TFhirBundle; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Indicates the purpose of this bundle- how it was intended to be used.
    property type_ : TFhirBundleTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to If a set of search matches, this is the total number of matches for the search (as opposed to the number of results in this bundle).
    property total : String read GetTotalST write SetTotalST;
    // If a set of search matches, this is the total number of matches for the search (as opposed to the number of results in this bundle).
    property totalElement : TFhirUnsignedInt read FTotal write SetTotal;

    // A series of links that provide context to this bundle.
    property link_List : TFhirBundleLinkList read GetLink_List;
    property hasLink_List : boolean read GetHasLink_List;

    // An entry in a bundle resource - will either contain a resource, or information about a resource (transactions and history only).
    property entryList : TFhirBundleEntryList read GetEntryList;
    property hasEntryList : boolean read GetHasEntryList;

    // Typed access to Digital Signature - base64 encoded. XML DigSIg or a JWT. (defined for API consistency)
    property signature : TFhirSignature read FSignature write SetSignature;
    // Digital Signature - base64 encoded. XML DigSIg or a JWT.
    property signatureElement : TFhirSignature read FSignature write SetSignature;

  end;

  TFhirBundleListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBundleList;
    function GetCurrent : TFhirBundle;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirBundleList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBundle read GetCurrent;
  end;

  TFhirBundleList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirBundle;
    procedure SetItemN(index : Integer; value : TFhirBundle);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirBundleList; Overload;
    function Clone : TFhirBundleList; Overload;
    function GetEnumerator : TFhirBundleListEnumerator;

    //  Add a FhirBundle to the end of the list.
    function Append : TFhirBundle;

    // Add an already existing FhirBundle to the end of the list.
    procedure AddItem(value : TFhirBundle); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBundle) : Integer;

    // Insert FhirBundle before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBundle;

    // Insert an existing FhirBundle before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBundle);

    // Get the iIndexth FhirBundle. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBundle);

    // The number of items in the collection
    function Item(index : Integer) : TFhirBundle;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirBundles[index : Integer] : TFhirBundle read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_BUNDLE}

{$IFDEF FHIR_CLAIM}

  // The party to be reimbursed for the services.
  TFhirClaimPayee = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCoding;
    FProvider : TFhirReference{TFhirPractitioner};
    FOrganization : TFhirReference{TFhirOrganization};
    FPerson : TFhirReference{TFhirPatient};
    Procedure SetType_(value : TFhirCoding);
    Procedure SetProvider(value : TFhirReference{TFhirPractitioner});
    Procedure SetOrganization(value : TFhirReference{TFhirOrganization});
    Procedure SetPerson(value : TFhirReference{TFhirPatient});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimPayee; overload;
    function Clone : TFhirClaimPayee; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Party to be reimbursed: Subscriber, provider, other. (defined for API consistency)
    property type_ : TFhirCoding read FType_ write SetType_;
    // Party to be reimbursed: Subscriber, provider, other.
    property type_Element : TFhirCoding read FType_ write SetType_;

    // Typed access to The provider who is to be reimbursed for the claim (the party to whom any benefit is assigned). (defined for API consistency)
    property provider : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;
    // The provider who is to be reimbursed for the claim (the party to whom any benefit is assigned).
    property providerElement : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;

    // Typed access to The organization who is to be reimbursed for the claim (the party to whom any benefit is assigned). (defined for API consistency)
    property organization : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;
    // The organization who is to be reimbursed for the claim (the party to whom any benefit is assigned).
    property organizationElement : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;

    // Typed access to The person other than the subscriber who is to be reimbursed for the claim (the party to whom any benefit is assigned). (defined for API consistency)
    property person : TFhirReference{TFhirPatient} read FPerson write SetPerson;
    // The person other than the subscriber who is to be reimbursed for the claim (the party to whom any benefit is assigned).
    property personElement : TFhirReference{TFhirPatient} read FPerson write SetPerson;

  end;

  TFhirClaimPayeeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimPayeeList;
    function GetCurrent : TFhirClaimPayee;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimPayeeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimPayee read GetCurrent;
  end;

  TFhirClaimPayeeList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimPayee;
    procedure SetItemN(index : Integer; value : TFhirClaimPayee);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimPayeeList; Overload;
    function Clone : TFhirClaimPayeeList; Overload;
    function GetEnumerator : TFhirClaimPayeeListEnumerator;

    //  Add a FhirClaimPayee to the end of the list.
    function Append : TFhirClaimPayee;

    // Add an already existing FhirClaimPayee to the end of the list.
    procedure AddItem(value : TFhirClaimPayee); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimPayee) : Integer;

    // Insert FhirClaimPayee before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimPayee;

    // Insert an existing FhirClaimPayee before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimPayee);

    // Get the iIndexth FhirClaimPayee. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimPayee);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimPayee;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimPayees[index : Integer] : TFhirClaimPayee read GetItemN write SetItemN; default;
  End;

  // Ordered list of patient diagnosis for which care is sought.
  TFhirClaimDiagnosis = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FDiagnosis : TFhirCoding;
    Procedure SetSequence(value : TFhirPositiveInt);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    Procedure SetDiagnosis(value : TFhirCoding);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimDiagnosis; overload;
    function Clone : TFhirClaimDiagnosis; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Sequence of diagnosis which serves to order and provide a link.
    property sequence : String read GetSequenceST write SetSequenceST;
    // Sequence of diagnosis which serves to order and provide a link.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The diagnosis. (defined for API consistency)
    property diagnosis : TFhirCoding read FDiagnosis write SetDiagnosis;
    // The diagnosis.
    property diagnosisElement : TFhirCoding read FDiagnosis write SetDiagnosis;

  end;

  TFhirClaimDiagnosisListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimDiagnosisList;
    function GetCurrent : TFhirClaimDiagnosis;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimDiagnosisList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimDiagnosis read GetCurrent;
  end;

  TFhirClaimDiagnosisList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimDiagnosis;
    procedure SetItemN(index : Integer; value : TFhirClaimDiagnosis);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimDiagnosisList; Overload;
    function Clone : TFhirClaimDiagnosisList; Overload;
    function GetEnumerator : TFhirClaimDiagnosisListEnumerator;

    //  Add a FhirClaimDiagnosis to the end of the list.
    function Append : TFhirClaimDiagnosis;

    // Add an already existing FhirClaimDiagnosis to the end of the list.
    procedure AddItem(value : TFhirClaimDiagnosis); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimDiagnosis) : Integer;

    // Insert FhirClaimDiagnosis before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimDiagnosis;

    // Insert an existing FhirClaimDiagnosis before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimDiagnosis);

    // Get the iIndexth FhirClaimDiagnosis. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimDiagnosis);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimDiagnosis;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimDiagnoses[index : Integer] : TFhirClaimDiagnosis read GetItemN write SetItemN; default;
  End;

  // Financial instrument by which payment information for health care.
  TFhirClaimCoverage = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FFocal : TFhirBoolean;
    FCoverage : TFhirReference{TFhirCoverage};
    FBusinessArrangement : TFhirString;
    FRelationship : TFhirCoding;
    FpreAuthRefList : TFhirStringList;
    FClaimResponse : TFhirReference{TFhirClaimResponse};
    FOriginalRuleset : TFhirCoding;
    Procedure SetSequence(value : TFhirPositiveInt);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    Procedure SetFocal(value : TFhirBoolean);
    Function GetFocalST : Boolean;
    Procedure SetFocalST(value : Boolean);
    Procedure SetCoverage(value : TFhirReference{TFhirCoverage});
    Procedure SetBusinessArrangement(value : TFhirString);
    Function GetBusinessArrangementST : String;
    Procedure SetBusinessArrangementST(value : String);
    Procedure SetRelationship(value : TFhirCoding);
    function GetPreAuthRefList : TFhirStringList;
    function GetHasPreAuthRefList : Boolean;
    Procedure SetClaimResponse(value : TFhirReference{TFhirClaimResponse});
    Procedure SetOriginalRuleset(value : TFhirCoding);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimCoverage; overload;
    function Clone : TFhirClaimCoverage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A service line item.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A service line item.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The instance number of the Coverage which is the focus for adjudication. The Coverage against which the claim is to be adjudicated.
    property focal : Boolean read GetFocalST write SetFocalST;
    // The instance number of the Coverage which is the focus for adjudication. The Coverage against which the claim is to be adjudicated.
    property focalElement : TFhirBoolean read FFocal write SetFocal;

    // Typed access to Reference to the program or plan identification, underwriter or payor. (defined for API consistency)
    property coverage : TFhirReference{TFhirCoverage} read FCoverage write SetCoverage;
    // Reference to the program or plan identification, underwriter or payor.
    property coverageElement : TFhirReference{TFhirCoverage} read FCoverage write SetCoverage;

    // Typed access to The contract number of a business agreement which describes the terms and conditions.
    property businessArrangement : String read GetBusinessArrangementST write SetBusinessArrangementST;
    // The contract number of a business agreement which describes the terms and conditions.
    property businessArrangementElement : TFhirString read FBusinessArrangement write SetBusinessArrangement;

    // Typed access to The relationship of the patient to the subscriber. (defined for API consistency)
    property relationship : TFhirCoding read FRelationship write SetRelationship;
    // The relationship of the patient to the subscriber.
    property relationshipElement : TFhirCoding read FRelationship write SetRelationship;

    // A list of references from the Insurer to which these services pertain.
    property preAuthRefList : TFhirStringList read GetPreAuthRefList;
    property hasPreAuthRefList : boolean read GetHasPreAuthRefList;

    // Typed access to The Coverages adjudication details. (defined for API consistency)
    property claimResponse : TFhirReference{TFhirClaimResponse} read FClaimResponse write SetClaimResponse;
    // The Coverages adjudication details.
    property claimResponseElement : TFhirReference{TFhirClaimResponse} read FClaimResponse write SetClaimResponse;

    // Typed access to The style (standard) and version of the original material which was converted into this resource. (defined for API consistency)
    property originalRuleset : TFhirCoding read FOriginalRuleset write SetOriginalRuleset;
    // The style (standard) and version of the original material which was converted into this resource.
    property originalRulesetElement : TFhirCoding read FOriginalRuleset write SetOriginalRuleset;

  end;

  TFhirClaimCoverageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimCoverageList;
    function GetCurrent : TFhirClaimCoverage;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimCoverageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimCoverage read GetCurrent;
  end;

  TFhirClaimCoverageList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimCoverage;
    procedure SetItemN(index : Integer; value : TFhirClaimCoverage);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimCoverageList; Overload;
    function Clone : TFhirClaimCoverageList; Overload;
    function GetEnumerator : TFhirClaimCoverageListEnumerator;

    //  Add a FhirClaimCoverage to the end of the list.
    function Append : TFhirClaimCoverage;

    // Add an already existing FhirClaimCoverage to the end of the list.
    procedure AddItem(value : TFhirClaimCoverage); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimCoverage) : Integer;

    // Insert FhirClaimCoverage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimCoverage;

    // Insert an existing FhirClaimCoverage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimCoverage);

    // Get the iIndexth FhirClaimCoverage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimCoverage);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimCoverage;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimCoverages[index : Integer] : TFhirClaimCoverage read GetItemN write SetItemN; default;
  End;

  // First tier of goods and services.
  TFhirClaimItem = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FType_ : TFhirCoding;
    FProvider : TFhirReference{TFhirPractitioner};
    FdiagnosisLinkIdList : TFhirPositiveIntList;
    FService : TFhirCoding;
    FServiceDate : TFhirDate;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirQuantity;
    FFactor : TFhirDecimal;
    FPoints : TFhirDecimal;
    FNet : TFhirQuantity;
    FUdi : TFhirCoding;
    FBodySite : TFhirCoding;
    FsubSiteList : TFhirCodingList;
    FmodifierList : TFhirCodingList;
    FdetailList : TFhirClaimItemDetailList;
    FProsthesis : TFhirClaimItemProsthesis;
    Procedure SetSequence(value : TFhirPositiveInt);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    Procedure SetType_(value : TFhirCoding);
    Procedure SetProvider(value : TFhirReference{TFhirPractitioner});
    function GetDiagnosisLinkIdList : TFhirPositiveIntList;
    function GetHasDiagnosisLinkIdList : Boolean;
    Procedure SetService(value : TFhirCoding);
    Procedure SetServiceDate(value : TFhirDate);
    Function GetServiceDateST : TFslDateTime;
    Procedure SetServiceDateST(value : TFslDateTime);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetUnitPrice(value : TFhirQuantity);
    Procedure SetFactor(value : TFhirDecimal);
    Function GetFactorST : String;
    Procedure SetFactorST(value : String);
    Procedure SetPoints(value : TFhirDecimal);
    Function GetPointsST : String;
    Procedure SetPointsST(value : String);
    Procedure SetNet(value : TFhirQuantity);
    Procedure SetUdi(value : TFhirCoding);
    Procedure SetBodySite(value : TFhirCoding);
    function GetSubSiteList : TFhirCodingList;
    function GetHasSubSiteList : Boolean;
    function GetModifierList : TFhirCodingList;
    function GetHasModifierList : Boolean;
    function GetDetailList : TFhirClaimItemDetailList;
    function GetHasDetailList : Boolean;
    Procedure SetProsthesis(value : TFhirClaimItemProsthesis);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimItem; overload;
    function Clone : TFhirClaimItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A service line number.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A service line number.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The type of product or service. (defined for API consistency)
    property type_ : TFhirCoding read FType_ write SetType_;
    // The type of product or service.
    property type_Element : TFhirCoding read FType_ write SetType_;

    // Typed access to The practitioner who is responsible for the services rendered to the patient. (defined for API consistency)
    property provider : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;
    // The practitioner who is responsible for the services rendered to the patient.
    property providerElement : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;

    // Diagnosis applicable for this service or product line.
    property diagnosisLinkIdList : TFhirPositiveIntList read GetDiagnosisLinkIdList;
    property hasDiagnosisLinkIdList : boolean read GetHasDiagnosisLinkIdList;

    // Typed access to If a grouping item then 'GROUP' otherwise it is a node therefore a code to indicate the Professional Service or Product supplied. (defined for API consistency)
    property service : TFhirCoding read FService write SetService;
    // If a grouping item then 'GROUP' otherwise it is a node therefore a code to indicate the Professional Service or Product supplied.
    property serviceElement : TFhirCoding read FService write SetService;

    // Typed access to The date when the enclosed suite of services were performed or completed.
    property serviceDate : TFslDateTime read GetServiceDateST write SetServiceDateST;
    // The date when the enclosed suite of services were performed or completed.
    property serviceDateElement : TFhirDate read FServiceDate write SetServiceDate;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to If the item is a node then this is the fee for the product or service, otherwise this is the total of the fees for the children of the group. (defined for API consistency)
    property unitPrice : TFhirQuantity read FUnitPrice write SetUnitPrice;
    // If the item is a node then this is the fee for the product or service, otherwise this is the total of the fees for the children of the group.
    property unitPriceElement : TFhirQuantity read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to An amount that expresses the weighting (based on difficulty, cost and/or resource intensiveness) associated with the good or service delivered. The concept of Points allows for assignment of point values for services and/or goods, such that a monetary amount can be assigned to each point.
    property points : String read GetPointsST write SetPointsST;
    // An amount that expresses the weighting (based on difficulty, cost and/or resource intensiveness) associated with the good or service delivered. The concept of Points allows for assignment of point values for services and/or goods, such that a monetary amount can be assigned to each point.
    property pointsElement : TFhirDecimal read FPoints write SetPoints;

    // Typed access to The quantity times the unit price for an additional  service or product or charge. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied. (defined for API consistency)
    property net : TFhirQuantity read FNet write SetNet;
    // The quantity times the unit price for an additional  service or product or charge. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied.
    property netElement : TFhirQuantity read FNet write SetNet;

    // Typed access to List of Unique Device Identifiers associated with this line item. (defined for API consistency)
    property udi : TFhirCoding read FUdi write SetUdi;
    // List of Unique Device Identifiers associated with this line item.
    property udiElement : TFhirCoding read FUdi write SetUdi;

    // Typed access to Physical service site on the patient (limb, tooth, etc.). (defined for API consistency)
    property bodySite : TFhirCoding read FBodySite write SetBodySite;
    // Physical service site on the patient (limb, tooth, etc.).
    property bodySiteElement : TFhirCoding read FBodySite write SetBodySite;

    // A region or surface of the site, e.g. limb region or tooth surface(s).
    property subSiteList : TFhirCodingList read GetSubSiteList;
    property hasSubSiteList : boolean read GetHasSubSiteList;

    // Item typification or modifiers codes, e.g. for Oral whether the treatment is cosmetic or associated with TMJ, or an appliance was lost or stolen.
    property modifierList : TFhirCodingList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Second tier of goods and services.
    property detailList : TFhirClaimItemDetailList read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

    // Typed access to The materials and placement date of prior fixed prosthesis. (defined for API consistency)
    property prosthesis : TFhirClaimItemProsthesis read FProsthesis write SetProsthesis;
    // The materials and placement date of prior fixed prosthesis.
    property prosthesisElement : TFhirClaimItemProsthesis read FProsthesis write SetProsthesis;

  end;

  TFhirClaimItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimItemList;
    function GetCurrent : TFhirClaimItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimItem read GetCurrent;
  end;

  TFhirClaimItemList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimItem;
    procedure SetItemN(index : Integer; value : TFhirClaimItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimItemList; Overload;
    function Clone : TFhirClaimItemList; Overload;
    function GetEnumerator : TFhirClaimItemListEnumerator;

    //  Add a FhirClaimItem to the end of the list.
    function Append : TFhirClaimItem;

    // Add an already existing FhirClaimItem to the end of the list.
    procedure AddItem(value : TFhirClaimItem); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimItem) : Integer;

    // Insert FhirClaimItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimItem;

    // Insert an existing FhirClaimItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimItem);

    // Get the iIndexth FhirClaimItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimItem);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimItem;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimItems[index : Integer] : TFhirClaimItem read GetItemN write SetItemN; default;
  End;

  // Second tier of goods and services.
  TFhirClaimItemDetail = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FType_ : TFhirCoding;
    FService : TFhirCoding;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirQuantity;
    FFactor : TFhirDecimal;
    FPoints : TFhirDecimal;
    FNet : TFhirQuantity;
    FUdi : TFhirCoding;
    FsubDetailList : TFhirClaimItemDetailSubDetailList;
    Procedure SetSequence(value : TFhirPositiveInt);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    Procedure SetType_(value : TFhirCoding);
    Procedure SetService(value : TFhirCoding);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetUnitPrice(value : TFhirQuantity);
    Procedure SetFactor(value : TFhirDecimal);
    Function GetFactorST : String;
    Procedure SetFactorST(value : String);
    Procedure SetPoints(value : TFhirDecimal);
    Function GetPointsST : String;
    Procedure SetPointsST(value : String);
    Procedure SetNet(value : TFhirQuantity);
    Procedure SetUdi(value : TFhirCoding);
    function GetSubDetailList : TFhirClaimItemDetailSubDetailList;
    function GetHasSubDetailList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimItemDetail; overload;
    function Clone : TFhirClaimItemDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A service line number.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A service line number.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The type of product or service. (defined for API consistency)
    property type_ : TFhirCoding read FType_ write SetType_;
    // The type of product or service.
    property type_Element : TFhirCoding read FType_ write SetType_;

    // Typed access to If a grouping item then 'GROUP' otherwise it is a node therefore a code to indicate the Professional Service or Product supplied. (defined for API consistency)
    property service : TFhirCoding read FService write SetService;
    // If a grouping item then 'GROUP' otherwise it is a node therefore a code to indicate the Professional Service or Product supplied.
    property serviceElement : TFhirCoding read FService write SetService;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to If the item is a node then this is the fee for the product or service, otherwise this is the total of the fees for the children of the group. (defined for API consistency)
    property unitPrice : TFhirQuantity read FUnitPrice write SetUnitPrice;
    // If the item is a node then this is the fee for the product or service, otherwise this is the total of the fees for the children of the group.
    property unitPriceElement : TFhirQuantity read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to An amount that expresses the weighting (based on difficulty, cost and/or resource intensiveness) associated with the good or service delivered. The concept of Points allows for assignment of point values for services and/or goods, such that a monetary amount can be assigned to each point.
    property points : String read GetPointsST write SetPointsST;
    // An amount that expresses the weighting (based on difficulty, cost and/or resource intensiveness) associated with the good or service delivered. The concept of Points allows for assignment of point values for services and/or goods, such that a monetary amount can be assigned to each point.
    property pointsElement : TFhirDecimal read FPoints write SetPoints;

    // Typed access to The quantity times the unit price for an additional  service or product or charge. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied. (defined for API consistency)
    property net : TFhirQuantity read FNet write SetNet;
    // The quantity times the unit price for an additional  service or product or charge. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied.
    property netElement : TFhirQuantity read FNet write SetNet;

    // Typed access to List of Unique Device Identifiers associated with this line item. (defined for API consistency)
    property udi : TFhirCoding read FUdi write SetUdi;
    // List of Unique Device Identifiers associated with this line item.
    property udiElement : TFhirCoding read FUdi write SetUdi;

    // Third tier of goods and services.
    property subDetailList : TFhirClaimItemDetailSubDetailList read GetSubDetailList;
    property hasSubDetailList : boolean read GetHasSubDetailList;

  end;

  TFhirClaimItemDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimItemDetailList;
    function GetCurrent : TFhirClaimItemDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimItemDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimItemDetail read GetCurrent;
  end;

  TFhirClaimItemDetailList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimItemDetail;
    procedure SetItemN(index : Integer; value : TFhirClaimItemDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimItemDetailList; Overload;
    function Clone : TFhirClaimItemDetailList; Overload;
    function GetEnumerator : TFhirClaimItemDetailListEnumerator;

    //  Add a FhirClaimItemDetail to the end of the list.
    function Append : TFhirClaimItemDetail;

    // Add an already existing FhirClaimItemDetail to the end of the list.
    procedure AddItem(value : TFhirClaimItemDetail); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimItemDetail) : Integer;

    // Insert FhirClaimItemDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimItemDetail;

    // Insert an existing FhirClaimItemDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimItemDetail);

    // Get the iIndexth FhirClaimItemDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimItemDetail);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimItemDetail;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimItemDetails[index : Integer] : TFhirClaimItemDetail read GetItemN write SetItemN; default;
  End;

  // Third tier of goods and services.
  TFhirClaimItemDetailSubDetail = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FType_ : TFhirCoding;
    FService : TFhirCoding;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirQuantity;
    FFactor : TFhirDecimal;
    FPoints : TFhirDecimal;
    FNet : TFhirQuantity;
    FUdi : TFhirCoding;
    Procedure SetSequence(value : TFhirPositiveInt);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    Procedure SetType_(value : TFhirCoding);
    Procedure SetService(value : TFhirCoding);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetUnitPrice(value : TFhirQuantity);
    Procedure SetFactor(value : TFhirDecimal);
    Function GetFactorST : String;
    Procedure SetFactorST(value : String);
    Procedure SetPoints(value : TFhirDecimal);
    Function GetPointsST : String;
    Procedure SetPointsST(value : String);
    Procedure SetNet(value : TFhirQuantity);
    Procedure SetUdi(value : TFhirCoding);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimItemDetailSubDetail; overload;
    function Clone : TFhirClaimItemDetailSubDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A service line number.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A service line number.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The type of product or service. (defined for API consistency)
    property type_ : TFhirCoding read FType_ write SetType_;
    // The type of product or service.
    property type_Element : TFhirCoding read FType_ write SetType_;

    // Typed access to The fee for an additional  service or product or charge. (defined for API consistency)
    property service : TFhirCoding read FService write SetService;
    // The fee for an additional  service or product or charge.
    property serviceElement : TFhirCoding read FService write SetService;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to The fee for an additional  service or product or charge. (defined for API consistency)
    property unitPrice : TFhirQuantity read FUnitPrice write SetUnitPrice;
    // The fee for an additional  service or product or charge.
    property unitPriceElement : TFhirQuantity read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to An amount that expresses the weighting (based on difficulty, cost and/or resource intensiveness) associated with the good or service delivered. The concept of Points allows for assignment of point values for services and/or goods, such that a monetary amount can be assigned to each point.
    property points : String read GetPointsST write SetPointsST;
    // An amount that expresses the weighting (based on difficulty, cost and/or resource intensiveness) associated with the good or service delivered. The concept of Points allows for assignment of point values for services and/or goods, such that a monetary amount can be assigned to each point.
    property pointsElement : TFhirDecimal read FPoints write SetPoints;

    // Typed access to The quantity times the unit price for an additional  service or product or charge. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied. (defined for API consistency)
    property net : TFhirQuantity read FNet write SetNet;
    // The quantity times the unit price for an additional  service or product or charge. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied.
    property netElement : TFhirQuantity read FNet write SetNet;

    // Typed access to List of Unique Device Identifiers associated with this line item. (defined for API consistency)
    property udi : TFhirCoding read FUdi write SetUdi;
    // List of Unique Device Identifiers associated with this line item.
    property udiElement : TFhirCoding read FUdi write SetUdi;

  end;

  TFhirClaimItemDetailSubDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimItemDetailSubDetailList;
    function GetCurrent : TFhirClaimItemDetailSubDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimItemDetailSubDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimItemDetailSubDetail read GetCurrent;
  end;

  TFhirClaimItemDetailSubDetailList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimItemDetailSubDetail;
    procedure SetItemN(index : Integer; value : TFhirClaimItemDetailSubDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimItemDetailSubDetailList; Overload;
    function Clone : TFhirClaimItemDetailSubDetailList; Overload;
    function GetEnumerator : TFhirClaimItemDetailSubDetailListEnumerator;

    //  Add a FhirClaimItemDetailSubDetail to the end of the list.
    function Append : TFhirClaimItemDetailSubDetail;

    // Add an already existing FhirClaimItemDetailSubDetail to the end of the list.
    procedure AddItem(value : TFhirClaimItemDetailSubDetail); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimItemDetailSubDetail) : Integer;

    // Insert FhirClaimItemDetailSubDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimItemDetailSubDetail;

    // Insert an existing FhirClaimItemDetailSubDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimItemDetailSubDetail);

    // Get the iIndexth FhirClaimItemDetailSubDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimItemDetailSubDetail);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimItemDetailSubDetail;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimItemDetailSubDetails[index : Integer] : TFhirClaimItemDetailSubDetail read GetItemN write SetItemN; default;
  End;

  // The materials and placement date of prior fixed prosthesis.
  TFhirClaimItemProsthesis = class (TFhirBackboneElement)
  protected
    FInitial : TFhirBoolean;
    FPriorDate : TFhirDate;
    FPriorMaterial : TFhirCoding;
    Procedure SetInitial(value : TFhirBoolean);
    Function GetInitialST : Boolean;
    Procedure SetInitialST(value : Boolean);
    Procedure SetPriorDate(value : TFhirDate);
    Function GetPriorDateST : TFslDateTime;
    Procedure SetPriorDateST(value : TFslDateTime);
    Procedure SetPriorMaterial(value : TFhirCoding);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimItemProsthesis; overload;
    function Clone : TFhirClaimItemProsthesis; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Indicates whether this is the initial placement of a fixed prosthesis.
    property initial : Boolean read GetInitialST write SetInitialST;
    // Indicates whether this is the initial placement of a fixed prosthesis.
    property initialElement : TFhirBoolean read FInitial write SetInitial;

    // Typed access to Date of the initial placement.
    property priorDate : TFslDateTime read GetPriorDateST write SetPriorDateST;
    // Date of the initial placement.
    property priorDateElement : TFhirDate read FPriorDate write SetPriorDate;

    // Typed access to Material of the prior denture or bridge prosthesis. (Oral). (defined for API consistency)
    property priorMaterial : TFhirCoding read FPriorMaterial write SetPriorMaterial;
    // Material of the prior denture or bridge prosthesis. (Oral).
    property priorMaterialElement : TFhirCoding read FPriorMaterial write SetPriorMaterial;

  end;

  TFhirClaimItemProsthesisListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimItemProsthesisList;
    function GetCurrent : TFhirClaimItemProsthesis;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimItemProsthesisList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimItemProsthesis read GetCurrent;
  end;

  TFhirClaimItemProsthesisList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimItemProsthesis;
    procedure SetItemN(index : Integer; value : TFhirClaimItemProsthesis);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimItemProsthesisList; Overload;
    function Clone : TFhirClaimItemProsthesisList; Overload;
    function GetEnumerator : TFhirClaimItemProsthesisListEnumerator;

    //  Add a FhirClaimItemProsthesis to the end of the list.
    function Append : TFhirClaimItemProsthesis;

    // Add an already existing FhirClaimItemProsthesis to the end of the list.
    procedure AddItem(value : TFhirClaimItemProsthesis); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimItemProsthesis) : Integer;

    // Insert FhirClaimItemProsthesis before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimItemProsthesis;

    // Insert an existing FhirClaimItemProsthesis before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimItemProsthesis);

    // Get the iIndexth FhirClaimItemProsthesis. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimItemProsthesis);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimItemProsthesis;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimItemProstheses[index : Integer] : TFhirClaimItemProsthesis read GetItemN write SetItemN; default;
  End;

  // A list of teeth which would be expected but are not found due to having been previously  extracted or for other reasons.
  TFhirClaimMissingTeeth = class (TFhirBackboneElement)
  protected
    FTooth : TFhirCoding;
    FReason : TFhirCoding;
    FExtractionDate : TFhirDate;
    Procedure SetTooth(value : TFhirCoding);
    Procedure SetReason(value : TFhirCoding);
    Procedure SetExtractionDate(value : TFhirDate);
    Function GetExtractionDateST : TFslDateTime;
    Procedure SetExtractionDateST(value : TFslDateTime);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimMissingTeeth; overload;
    function Clone : TFhirClaimMissingTeeth; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The code identifying which tooth is missing. (defined for API consistency)
    property tooth : TFhirCoding read FTooth write SetTooth;
    // The code identifying which tooth is missing.
    property toothElement : TFhirCoding read FTooth write SetTooth;

    // Typed access to Missing reason may be: E-extraction, O-other. (defined for API consistency)
    property reason : TFhirCoding read FReason write SetReason;
    // Missing reason may be: E-extraction, O-other.
    property reasonElement : TFhirCoding read FReason write SetReason;

    // Typed access to The date of the extraction either known from records or patient reported estimate.
    property extractionDate : TFslDateTime read GetExtractionDateST write SetExtractionDateST;
    // The date of the extraction either known from records or patient reported estimate.
    property extractionDateElement : TFhirDate read FExtractionDate write SetExtractionDate;

  end;

  TFhirClaimMissingTeethListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimMissingTeethList;
    function GetCurrent : TFhirClaimMissingTeeth;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimMissingTeethList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimMissingTeeth read GetCurrent;
  end;

  TFhirClaimMissingTeethList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimMissingTeeth;
    procedure SetItemN(index : Integer; value : TFhirClaimMissingTeeth);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimMissingTeethList; Overload;
    function Clone : TFhirClaimMissingTeethList; Overload;
    function GetEnumerator : TFhirClaimMissingTeethListEnumerator;

    //  Add a FhirClaimMissingTeeth to the end of the list.
    function Append : TFhirClaimMissingTeeth;

    // Add an already existing FhirClaimMissingTeeth to the end of the list.
    procedure AddItem(value : TFhirClaimMissingTeeth); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimMissingTeeth) : Integer;

    // Insert FhirClaimMissingTeeth before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimMissingTeeth;

    // Insert an existing FhirClaimMissingTeeth before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimMissingTeeth);

    // Get the iIndexth FhirClaimMissingTeeth. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimMissingTeeth);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimMissingTeeth;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimMissingTeeths[index : Integer] : TFhirClaimMissingTeeth read GetItemN write SetItemN; default;
  End;

  // A provider issued list of services and products provided, or to be provided, to a patient which is provided to an insurer for payment recovery.
  TFhirClaim = class (TFhirDomainResource)
  protected
    FType_ : TFhirEnum;
    FidentifierList : TFhirIdentifierList;
    FRuleset : TFhirCoding;
    FOriginalRuleset : TFhirCoding;
    FCreated : TFhirDateTime;
    FTarget : TFhirReference{TFhirOrganization};
    FProvider : TFhirReference{TFhirPractitioner};
    FOrganization : TFhirReference{TFhirOrganization};
    FUse : TFhirEnum;
    FPriority : TFhirCoding;
    FFundsReserve : TFhirCoding;
    FEnterer : TFhirReference{TFhirPractitioner};
    FFacility : TFhirReference{TFhirLocation};
    FPrescription : TFhirReference{Resource};
    FOriginalPrescription : TFhirReference{TFhirMedicationOrder};
    FPayee : TFhirClaimPayee;
    FReferral : TFhirReference{TFhirReferralRequest};
    FdiagnosisList : TFhirClaimDiagnosisList;
    FconditionList : TFhirCodingList;
    FPatient : TFhirReference{TFhirPatient};
    FcoverageList : TFhirClaimCoverageList;
    FexceptionList : TFhirCodingList;
    FSchool : TFhirString;
    FAccident : TFhirDate;
    FAccidentType : TFhirCoding;
    FinterventionExceptionList : TFhirCodingList;
    FitemList : TFhirClaimItemList;
    FadditionalMaterialsList : TFhirCodingList;
    FmissingTeethList : TFhirClaimMissingTeethList;
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirClaimTypeLinkEnum;
    Procedure SetType_ST(value : TFhirClaimTypeLinkEnum);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetRuleset(value : TFhirCoding);
    Procedure SetOriginalRuleset(value : TFhirCoding);
    Procedure SetCreated(value : TFhirDateTime);
    Function GetCreatedST : TFslDateTime;
    Procedure SetCreatedST(value : TFslDateTime);
    Procedure SetTarget(value : TFhirReference{TFhirOrganization});
    Procedure SetProvider(value : TFhirReference{TFhirPractitioner});
    Procedure SetOrganization(value : TFhirReference{TFhirOrganization});
    Procedure SetUse(value : TFhirEnum);
    Function GetUseST : TFhirClaimUseLinkEnum;
    Procedure SetUseST(value : TFhirClaimUseLinkEnum);
    Procedure SetPriority(value : TFhirCoding);
    Procedure SetFundsReserve(value : TFhirCoding);
    Procedure SetEnterer(value : TFhirReference{TFhirPractitioner});
    Procedure SetFacility(value : TFhirReference{TFhirLocation});
    Procedure SetPrescription(value : TFhirReference{Resource});
    Procedure SetOriginalPrescription(value : TFhirReference{TFhirMedicationOrder});
    Procedure SetPayee(value : TFhirClaimPayee);
    Procedure SetReferral(value : TFhirReference{TFhirReferralRequest});
    function GetDiagnosisList : TFhirClaimDiagnosisList;
    function GetHasDiagnosisList : Boolean;
    function GetConditionList : TFhirCodingList;
    function GetHasConditionList : Boolean;
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    function GetCoverageList : TFhirClaimCoverageList;
    function GetHasCoverageList : Boolean;
    function GetExceptionList : TFhirCodingList;
    function GetHasExceptionList : Boolean;
    Procedure SetSchool(value : TFhirString);
    Function GetSchoolST : String;
    Procedure SetSchoolST(value : String);
    Procedure SetAccident(value : TFhirDate);
    Function GetAccidentST : TFslDateTime;
    Procedure SetAccidentST(value : TFslDateTime);
    Procedure SetAccidentType(value : TFhirCoding);
    function GetInterventionExceptionList : TFhirCodingList;
    function GetHasInterventionExceptionList : Boolean;
    function GetItemList : TFhirClaimItemList;
    function GetHasItemList : Boolean;
    function GetAdditionalMaterialsList : TFhirCodingList;
    function GetHasAdditionalMaterialsList : Boolean;
    function GetMissingTeethList : TFhirClaimMissingTeethList;
    function GetHasMissingTeethList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaim; overload;
    function Clone : TFhirClaim; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The category of claim this is.
    property type_ : TFhirClaimTypeLinkEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // The business identifier for the instance: invoice number, claim number, pre-determination or pre-authorization number.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The version of the specification on which this instance relies. (defined for API consistency)
    property ruleset : TFhirCoding read FRuleset write SetRuleset;
    // The version of the specification on which this instance relies.
    property rulesetElement : TFhirCoding read FRuleset write SetRuleset;

    // Typed access to The version of the specification from which the original instance was created. (defined for API consistency)
    property originalRuleset : TFhirCoding read FOriginalRuleset write SetOriginalRuleset;
    // The version of the specification from which the original instance was created.
    property originalRulesetElement : TFhirCoding read FOriginalRuleset write SetOriginalRuleset;

    // Typed access to The date when the enclosed suite of services were performed or completed.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date when the enclosed suite of services were performed or completed.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to Insurer Identifier, typical BIN number (6 digit). (defined for API consistency)
    property target : TFhirReference{TFhirOrganization} read FTarget write SetTarget;
    // Insurer Identifier, typical BIN number (6 digit).
    property targetElement : TFhirReference{TFhirOrganization} read FTarget write SetTarget;

    // Typed access to The provider which is responsible for the bill, claim pre-determination, pre-authorization. (defined for API consistency)
    property provider : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;
    // The provider which is responsible for the bill, claim pre-determination, pre-authorization.
    property providerElement : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;

    // Typed access to The organization which is responsible for the bill, claim pre-determination, pre-authorization. (defined for API consistency)
    property organization : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;
    // The organization which is responsible for the bill, claim pre-determination, pre-authorization.
    property organizationElement : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;

    // Complete (Bill or Claim), Proposed (Pre-Authorization), Exploratory (Pre-determination).
    property use : TFhirClaimUseLinkEnum read GetUseST write SetUseST;
    property useElement : TFhirEnum read FUse write SetUse;

    // Typed access to Immediate (stat), best effort (normal), deferred (deferred). (defined for API consistency)
    property priority : TFhirCoding read FPriority write SetPriority;
    // Immediate (stat), best effort (normal), deferred (deferred).
    property priorityElement : TFhirCoding read FPriority write SetPriority;

    // Typed access to In the case of a Pre-Determination/Pre-Authorization the provider may request that funds in the amount of the expected Benefit be reserved ('Patient' or 'Provider') to pay for the Benefits determined on the subsequent claim(s). 'None' explicitly indicates no funds reserving is requested. (defined for API consistency)
    property fundsReserve : TFhirCoding read FFundsReserve write SetFundsReserve;
    // In the case of a Pre-Determination/Pre-Authorization the provider may request that funds in the amount of the expected Benefit be reserved ('Patient' or 'Provider') to pay for the Benefits determined on the subsequent claim(s). 'None' explicitly indicates no funds reserving is requested.
    property fundsReserveElement : TFhirCoding read FFundsReserve write SetFundsReserve;

    // Typed access to Person who created the invoice/claim/pre-determination or pre-authorization. (defined for API consistency)
    property enterer : TFhirReference{TFhirPractitioner} read FEnterer write SetEnterer;
    // Person who created the invoice/claim/pre-determination or pre-authorization.
    property entererElement : TFhirReference{TFhirPractitioner} read FEnterer write SetEnterer;

    // Typed access to Facility where the services were provided. (defined for API consistency)
    property facility : TFhirReference{TFhirLocation} read FFacility write SetFacility;
    // Facility where the services were provided.
    property facilityElement : TFhirReference{TFhirLocation} read FFacility write SetFacility;

    // Typed access to Prescription to support the dispensing of Pharmacy or Vision products. (defined for API consistency)
    property prescription : TFhirReference{Resource} read FPrescription write SetPrescription;
    // Prescription to support the dispensing of Pharmacy or Vision products.
    property prescriptionElement : TFhirReference{Resource} read FPrescription write SetPrescription;

    // Typed access to Original prescription to support the dispensing of pharmacy services, medications or products. (defined for API consistency)
    property originalPrescription : TFhirReference{TFhirMedicationOrder} read FOriginalPrescription write SetOriginalPrescription;
    // Original prescription to support the dispensing of pharmacy services, medications or products.
    property originalPrescriptionElement : TFhirReference{TFhirMedicationOrder} read FOriginalPrescription write SetOriginalPrescription;

    // Typed access to The party to be reimbursed for the services. (defined for API consistency)
    property payee : TFhirClaimPayee read FPayee write SetPayee;
    // The party to be reimbursed for the services.
    property payeeElement : TFhirClaimPayee read FPayee write SetPayee;

    // Typed access to The referral resource which lists the date, practitioner, reason and other supporting information. (defined for API consistency)
    property referral : TFhirReference{TFhirReferralRequest} read FReferral write SetReferral;
    // The referral resource which lists the date, practitioner, reason and other supporting information.
    property referralElement : TFhirReference{TFhirReferralRequest} read FReferral write SetReferral;

    // Ordered list of patient diagnosis for which care is sought.
    property diagnosisList : TFhirClaimDiagnosisList read GetDiagnosisList;
    property hasDiagnosisList : boolean read GetHasDiagnosisList;

    // List of patient conditions for which care is sought.
    property conditionList : TFhirCodingList read GetConditionList;
    property hasConditionList : boolean read GetHasConditionList;

    // Typed access to Patient Resource. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // Patient Resource.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Financial instrument by which payment information for health care.
    property coverageList : TFhirClaimCoverageList read GetCoverageList;
    property hasCoverageList : boolean read GetHasCoverageList;

    // Factors which may influence the applicability of coverage.
    property exceptionList : TFhirCodingList read GetExceptionList;
    property hasExceptionList : boolean read GetHasExceptionList;

    // Typed access to Name of school for over-aged dependents.
    property school : String read GetSchoolST write SetSchoolST;
    // Name of school for over-aged dependents.
    property schoolElement : TFhirString read FSchool write SetSchool;

    // Typed access to Date of an accident which these services are addressing.
    property accident : TFslDateTime read GetAccidentST write SetAccidentST;
    // Date of an accident which these services are addressing.
    property accidentElement : TFhirDate read FAccident write SetAccident;

    // Typed access to Type of accident: work, auto, etc. (defined for API consistency)
    property accidentType : TFhirCoding read FAccidentType write SetAccidentType;
    // Type of accident: work, auto, etc.
    property accidentTypeElement : TFhirCoding read FAccidentType write SetAccidentType;

    // A list of intervention and exception codes which may influence the adjudication of the claim.
    property interventionExceptionList : TFhirCodingList read GetInterventionExceptionList;
    property hasInterventionExceptionList : boolean read GetHasInterventionExceptionList;

    // First tier of goods and services.
    property itemList : TFhirClaimItemList read GetItemList;
    property hasItemList : boolean read GetHasItemList;

    // Code to indicate that Xrays, images, emails, documents, models or attachments are being sent in support of this submission.
    property additionalMaterialsList : TFhirCodingList read GetAdditionalMaterialsList;
    property hasAdditionalMaterialsList : boolean read GetHasAdditionalMaterialsList;

    // A list of teeth which would be expected but are not found due to having been previously  extracted or for other reasons.
    property missingTeethList : TFhirClaimMissingTeethList read GetMissingTeethList;
    property hasMissingTeethList : boolean read GetHasMissingTeethList;

  end;

  TFhirClaimListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimList;
    function GetCurrent : TFhirClaim;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaim read GetCurrent;
  end;

  TFhirClaimList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaim;
    procedure SetItemN(index : Integer; value : TFhirClaim);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimList; Overload;
    function Clone : TFhirClaimList; Overload;
    function GetEnumerator : TFhirClaimListEnumerator;

    //  Add a FhirClaim to the end of the list.
    function Append : TFhirClaim;

    // Add an already existing FhirClaim to the end of the list.
    procedure AddItem(value : TFhirClaim); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaim) : Integer;

    // Insert FhirClaim before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaim;

    // Insert an existing FhirClaim before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaim);

    // Get the iIndexth FhirClaim. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaim);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaim;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaims[index : Integer] : TFhirClaim read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CLAIM}

{$IFDEF FHIR_CLAIMRESPONSE}

  // The first tier service adjudications for submitted services.
  TFhirClaimResponseItem = class (TFhirBackboneElement)
  protected
    FSequenceLinkId : TFhirPositiveInt;
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirClaimResponseItemAdjudicationList;
    FdetailList : TFhirClaimResponseItemDetailList;
    Procedure SetSequenceLinkId(value : TFhirPositiveInt);
    Function GetSequenceLinkIdST : String;
    Procedure SetSequenceLinkIdST(value : String);
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
    function GetDetailList : TFhirClaimResponseItemDetailList;
    function GetHasDetailList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseItem; overload;
    function Clone : TFhirClaimResponseItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A service line number.
    property sequenceLinkId : String read GetSequenceLinkIdST write SetSequenceLinkIdST;
    // A service line number.
    property sequenceLinkIdElement : TFhirPositiveInt read FSequenceLinkId write SetSequenceLinkId;

    // A list of note references to the notes provided below.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // The adjudications results.
    property adjudicationList : TFhirClaimResponseItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

    // The second tier service adjudications for submitted services.
    property detailList : TFhirClaimResponseItemDetailList read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

  end;

  TFhirClaimResponseItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseItemList;
    function GetCurrent : TFhirClaimResponseItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseItem read GetCurrent;
  end;

  TFhirClaimResponseItemList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimResponseItem;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimResponseItemList; Overload;
    function Clone : TFhirClaimResponseItemList; Overload;
    function GetEnumerator : TFhirClaimResponseItemListEnumerator;

    //  Add a FhirClaimResponseItem to the end of the list.
    function Append : TFhirClaimResponseItem;

    // Add an already existing FhirClaimResponseItem to the end of the list.
    procedure AddItem(value : TFhirClaimResponseItem); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseItem) : Integer;

    // Insert FhirClaimResponseItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseItem;

    // Insert an existing FhirClaimResponseItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseItem);

    // Get the iIndexth FhirClaimResponseItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseItem);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseItem;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimResponseItems[index : Integer] : TFhirClaimResponseItem read GetItemN write SetItemN; default;
  End;

  // The adjudications results.
  TFhirClaimResponseItemAdjudication = class (TFhirBackboneElement)
  protected
    FCode : TFhirCoding;
    FAmount : TFhirQuantity;
    FValue : TFhirDecimal;
    Procedure SetCode(value : TFhirCoding);
    Procedure SetAmount(value : TFhirQuantity);
    Procedure SetValue(value : TFhirDecimal);
    Function GetValueST : String;
    Procedure SetValueST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseItemAdjudication; overload;
    function Clone : TFhirClaimResponseItemAdjudication; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Code indicating: Co-Pay, deductible, eligible, benefit, tax, etc. (defined for API consistency)
    property code : TFhirCoding read FCode write SetCode;
    // Code indicating: Co-Pay, deductible, eligible, benefit, tax, etc.
    property codeElement : TFhirCoding read FCode write SetCode;

    // Typed access to Monetary amount associated with the code. (defined for API consistency)
    property amount : TFhirQuantity read FAmount write SetAmount;
    // Monetary amount associated with the code.
    property amountElement : TFhirQuantity read FAmount write SetAmount;

    // Typed access to A non-monetary value for example a percentage. Mutually exclusive to the amount element above.
    property value : String read GetValueST write SetValueST;
    // A non-monetary value for example a percentage. Mutually exclusive to the amount element above.
    property valueElement : TFhirDecimal read FValue write SetValue;

  end;

  TFhirClaimResponseItemAdjudicationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseItemAdjudicationList;
    function GetCurrent : TFhirClaimResponseItemAdjudication;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseItemAdjudicationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseItemAdjudication read GetCurrent;
  end;

  TFhirClaimResponseItemAdjudicationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimResponseItemAdjudication;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseItemAdjudication);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimResponseItemAdjudicationList; Overload;
    function Clone : TFhirClaimResponseItemAdjudicationList; Overload;
    function GetEnumerator : TFhirClaimResponseItemAdjudicationListEnumerator;

    //  Add a FhirClaimResponseItemAdjudication to the end of the list.
    function Append : TFhirClaimResponseItemAdjudication;

    // Add an already existing FhirClaimResponseItemAdjudication to the end of the list.
    procedure AddItem(value : TFhirClaimResponseItemAdjudication); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseItemAdjudication) : Integer;

    // Insert FhirClaimResponseItemAdjudication before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseItemAdjudication;

    // Insert an existing FhirClaimResponseItemAdjudication before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseItemAdjudication);

    // Get the iIndexth FhirClaimResponseItemAdjudication. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseItemAdjudication);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseItemAdjudication;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimResponseItemAdjudications[index : Integer] : TFhirClaimResponseItemAdjudication read GetItemN write SetItemN; default;
  End;

  // The second tier service adjudications for submitted services.
  TFhirClaimResponseItemDetail = class (TFhirBackboneElement)
  protected
    FSequenceLinkId : TFhirPositiveInt;
    FadjudicationList : TFhirClaimResponseItemDetailAdjudicationList;
    FsubDetailList : TFhirClaimResponseItemDetailSubDetailList;
    Procedure SetSequenceLinkId(value : TFhirPositiveInt);
    Function GetSequenceLinkIdST : String;
    Procedure SetSequenceLinkIdST(value : String);
    function GetAdjudicationList : TFhirClaimResponseItemDetailAdjudicationList;
    function GetHasAdjudicationList : Boolean;
    function GetSubDetailList : TFhirClaimResponseItemDetailSubDetailList;
    function GetHasSubDetailList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseItemDetail; overload;
    function Clone : TFhirClaimResponseItemDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A service line number.
    property sequenceLinkId : String read GetSequenceLinkIdST write SetSequenceLinkIdST;
    // A service line number.
    property sequenceLinkIdElement : TFhirPositiveInt read FSequenceLinkId write SetSequenceLinkId;

    // The adjudications results.
    property adjudicationList : TFhirClaimResponseItemDetailAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

    // The third tier service adjudications for submitted services.
    property subDetailList : TFhirClaimResponseItemDetailSubDetailList read GetSubDetailList;
    property hasSubDetailList : boolean read GetHasSubDetailList;

  end;

  TFhirClaimResponseItemDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseItemDetailList;
    function GetCurrent : TFhirClaimResponseItemDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseItemDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseItemDetail read GetCurrent;
  end;

  TFhirClaimResponseItemDetailList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimResponseItemDetail;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseItemDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimResponseItemDetailList; Overload;
    function Clone : TFhirClaimResponseItemDetailList; Overload;
    function GetEnumerator : TFhirClaimResponseItemDetailListEnumerator;

    //  Add a FhirClaimResponseItemDetail to the end of the list.
    function Append : TFhirClaimResponseItemDetail;

    // Add an already existing FhirClaimResponseItemDetail to the end of the list.
    procedure AddItem(value : TFhirClaimResponseItemDetail); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseItemDetail) : Integer;

    // Insert FhirClaimResponseItemDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseItemDetail;

    // Insert an existing FhirClaimResponseItemDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseItemDetail);

    // Get the iIndexth FhirClaimResponseItemDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseItemDetail);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseItemDetail;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimResponseItemDetails[index : Integer] : TFhirClaimResponseItemDetail read GetItemN write SetItemN; default;
  End;

  // The adjudications results.
  TFhirClaimResponseItemDetailAdjudication = class (TFhirBackboneElement)
  protected
    FCode : TFhirCoding;
    FAmount : TFhirQuantity;
    FValue : TFhirDecimal;
    Procedure SetCode(value : TFhirCoding);
    Procedure SetAmount(value : TFhirQuantity);
    Procedure SetValue(value : TFhirDecimal);
    Function GetValueST : String;
    Procedure SetValueST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseItemDetailAdjudication; overload;
    function Clone : TFhirClaimResponseItemDetailAdjudication; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Code indicating: Co-Pay, deductible, eligible, benefit, tax, etc. (defined for API consistency)
    property code : TFhirCoding read FCode write SetCode;
    // Code indicating: Co-Pay, deductible, eligible, benefit, tax, etc.
    property codeElement : TFhirCoding read FCode write SetCode;

    // Typed access to Monetary amount associated with the code. (defined for API consistency)
    property amount : TFhirQuantity read FAmount write SetAmount;
    // Monetary amount associated with the code.
    property amountElement : TFhirQuantity read FAmount write SetAmount;

    // Typed access to A non-monetary value for example a percentage. Mutually exclusive to the amount element above.
    property value : String read GetValueST write SetValueST;
    // A non-monetary value for example a percentage. Mutually exclusive to the amount element above.
    property valueElement : TFhirDecimal read FValue write SetValue;

  end;

  TFhirClaimResponseItemDetailAdjudicationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseItemDetailAdjudicationList;
    function GetCurrent : TFhirClaimResponseItemDetailAdjudication;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseItemDetailAdjudicationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseItemDetailAdjudication read GetCurrent;
  end;

  TFhirClaimResponseItemDetailAdjudicationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimResponseItemDetailAdjudication;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseItemDetailAdjudication);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimResponseItemDetailAdjudicationList; Overload;
    function Clone : TFhirClaimResponseItemDetailAdjudicationList; Overload;
    function GetEnumerator : TFhirClaimResponseItemDetailAdjudicationListEnumerator;

    //  Add a FhirClaimResponseItemDetailAdjudication to the end of the list.
    function Append : TFhirClaimResponseItemDetailAdjudication;

    // Add an already existing FhirClaimResponseItemDetailAdjudication to the end of the list.
    procedure AddItem(value : TFhirClaimResponseItemDetailAdjudication); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseItemDetailAdjudication) : Integer;

    // Insert FhirClaimResponseItemDetailAdjudication before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseItemDetailAdjudication;

    // Insert an existing FhirClaimResponseItemDetailAdjudication before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseItemDetailAdjudication);

    // Get the iIndexth FhirClaimResponseItemDetailAdjudication. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseItemDetailAdjudication);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseItemDetailAdjudication;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimResponseItemDetailAdjudications[index : Integer] : TFhirClaimResponseItemDetailAdjudication read GetItemN write SetItemN; default;
  End;

  // The third tier service adjudications for submitted services.
  TFhirClaimResponseItemDetailSubDetail = class (TFhirBackboneElement)
  protected
    FSequenceLinkId : TFhirPositiveInt;
    FadjudicationList : TFhirClaimResponseItemDetailSubDetailAdjudicationList;
    Procedure SetSequenceLinkId(value : TFhirPositiveInt);
    Function GetSequenceLinkIdST : String;
    Procedure SetSequenceLinkIdST(value : String);
    function GetAdjudicationList : TFhirClaimResponseItemDetailSubDetailAdjudicationList;
    function GetHasAdjudicationList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseItemDetailSubDetail; overload;
    function Clone : TFhirClaimResponseItemDetailSubDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A service line number.
    property sequenceLinkId : String read GetSequenceLinkIdST write SetSequenceLinkIdST;
    // A service line number.
    property sequenceLinkIdElement : TFhirPositiveInt read FSequenceLinkId write SetSequenceLinkId;

    // The adjudications results.
    property adjudicationList : TFhirClaimResponseItemDetailSubDetailAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

  end;

  TFhirClaimResponseItemDetailSubDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseItemDetailSubDetailList;
    function GetCurrent : TFhirClaimResponseItemDetailSubDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseItemDetailSubDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseItemDetailSubDetail read GetCurrent;
  end;

  TFhirClaimResponseItemDetailSubDetailList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimResponseItemDetailSubDetail;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseItemDetailSubDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimResponseItemDetailSubDetailList; Overload;
    function Clone : TFhirClaimResponseItemDetailSubDetailList; Overload;
    function GetEnumerator : TFhirClaimResponseItemDetailSubDetailListEnumerator;

    //  Add a FhirClaimResponseItemDetailSubDetail to the end of the list.
    function Append : TFhirClaimResponseItemDetailSubDetail;

    // Add an already existing FhirClaimResponseItemDetailSubDetail to the end of the list.
    procedure AddItem(value : TFhirClaimResponseItemDetailSubDetail); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseItemDetailSubDetail) : Integer;

    // Insert FhirClaimResponseItemDetailSubDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseItemDetailSubDetail;

    // Insert an existing FhirClaimResponseItemDetailSubDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseItemDetailSubDetail);

    // Get the iIndexth FhirClaimResponseItemDetailSubDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseItemDetailSubDetail);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseItemDetailSubDetail;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimResponseItemDetailSubDetails[index : Integer] : TFhirClaimResponseItemDetailSubDetail read GetItemN write SetItemN; default;
  End;

  // The adjudications results.
  TFhirClaimResponseItemDetailSubDetailAdjudication = class (TFhirBackboneElement)
  protected
    FCode : TFhirCoding;
    FAmount : TFhirQuantity;
    FValue : TFhirDecimal;
    Procedure SetCode(value : TFhirCoding);
    Procedure SetAmount(value : TFhirQuantity);
    Procedure SetValue(value : TFhirDecimal);
    Function GetValueST : String;
    Procedure SetValueST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseItemDetailSubDetailAdjudication; overload;
    function Clone : TFhirClaimResponseItemDetailSubDetailAdjudication; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Code indicating: Co-Pay, deductible, eligible, benefit, tax, etc. (defined for API consistency)
    property code : TFhirCoding read FCode write SetCode;
    // Code indicating: Co-Pay, deductible, eligible, benefit, tax, etc.
    property codeElement : TFhirCoding read FCode write SetCode;

    // Typed access to Monetary amount associated with the code. (defined for API consistency)
    property amount : TFhirQuantity read FAmount write SetAmount;
    // Monetary amount associated with the code.
    property amountElement : TFhirQuantity read FAmount write SetAmount;

    // Typed access to A non-monetary value for example a percentage. Mutually exclusive to the amount element above.
    property value : String read GetValueST write SetValueST;
    // A non-monetary value for example a percentage. Mutually exclusive to the amount element above.
    property valueElement : TFhirDecimal read FValue write SetValue;

  end;

  TFhirClaimResponseItemDetailSubDetailAdjudicationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseItemDetailSubDetailAdjudicationList;
    function GetCurrent : TFhirClaimResponseItemDetailSubDetailAdjudication;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseItemDetailSubDetailAdjudicationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseItemDetailSubDetailAdjudication read GetCurrent;
  end;

  TFhirClaimResponseItemDetailSubDetailAdjudicationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimResponseItemDetailSubDetailAdjudication;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseItemDetailSubDetailAdjudication);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimResponseItemDetailSubDetailAdjudicationList; Overload;
    function Clone : TFhirClaimResponseItemDetailSubDetailAdjudicationList; Overload;
    function GetEnumerator : TFhirClaimResponseItemDetailSubDetailAdjudicationListEnumerator;

    //  Add a FhirClaimResponseItemDetailSubDetailAdjudication to the end of the list.
    function Append : TFhirClaimResponseItemDetailSubDetailAdjudication;

    // Add an already existing FhirClaimResponseItemDetailSubDetailAdjudication to the end of the list.
    procedure AddItem(value : TFhirClaimResponseItemDetailSubDetailAdjudication); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseItemDetailSubDetailAdjudication) : Integer;

    // Insert FhirClaimResponseItemDetailSubDetailAdjudication before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseItemDetailSubDetailAdjudication;

    // Insert an existing FhirClaimResponseItemDetailSubDetailAdjudication before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseItemDetailSubDetailAdjudication);

    // Get the iIndexth FhirClaimResponseItemDetailSubDetailAdjudication. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseItemDetailSubDetailAdjudication);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseItemDetailSubDetailAdjudication;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimResponseItemDetailSubDetailAdjudications[index : Integer] : TFhirClaimResponseItemDetailSubDetailAdjudication read GetItemN write SetItemN; default;
  End;

  // The first tier service adjudications for payor added services.
  TFhirClaimResponseAddItem = class (TFhirBackboneElement)
  protected
    FsequenceLinkIdList : TFhirPositiveIntList;
    FService : TFhirCoding;
    FFee : TFhirQuantity;
    FnoteNumberLinkIdList : TFhirPositiveIntList;
    FadjudicationList : TFhirClaimResponseAddItemAdjudicationList;
    FdetailList : TFhirClaimResponseAddItemDetailList;
    function GetSequenceLinkIdList : TFhirPositiveIntList;
    function GetHasSequenceLinkIdList : Boolean;
    Procedure SetService(value : TFhirCoding);
    Procedure SetFee(value : TFhirQuantity);
    function GetNoteNumberLinkIdList : TFhirPositiveIntList;
    function GetHasNoteNumberLinkIdList : Boolean;
    function GetAdjudicationList : TFhirClaimResponseAddItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
    function GetDetailList : TFhirClaimResponseAddItemDetailList;
    function GetHasDetailList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseAddItem; overload;
    function Clone : TFhirClaimResponseAddItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // List of input service items which this service line is intended to replace.
    property sequenceLinkIdList : TFhirPositiveIntList read GetSequenceLinkIdList;
    property hasSequenceLinkIdList : boolean read GetHasSequenceLinkIdList;

    // Typed access to A code to indicate the Professional Service or Product supplied. (defined for API consistency)
    property service : TFhirCoding read FService write SetService;
    // A code to indicate the Professional Service or Product supplied.
    property serviceElement : TFhirCoding read FService write SetService;

    // Typed access to The fee charged for the professional service or product.. (defined for API consistency)
    property fee : TFhirQuantity read FFee write SetFee;
    // The fee charged for the professional service or product..
    property feeElement : TFhirQuantity read FFee write SetFee;

    // A list of note references to the notes provided below.
    property noteNumberLinkIdList : TFhirPositiveIntList read GetNoteNumberLinkIdList;
    property hasNoteNumberLinkIdList : boolean read GetHasNoteNumberLinkIdList;

    // The adjudications results.
    property adjudicationList : TFhirClaimResponseAddItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

    // The second tier service adjudications for payor added services.
    property detailList : TFhirClaimResponseAddItemDetailList read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

  end;

  TFhirClaimResponseAddItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseAddItemList;
    function GetCurrent : TFhirClaimResponseAddItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseAddItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseAddItem read GetCurrent;
  end;

  TFhirClaimResponseAddItemList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimResponseAddItem;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseAddItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimResponseAddItemList; Overload;
    function Clone : TFhirClaimResponseAddItemList; Overload;
    function GetEnumerator : TFhirClaimResponseAddItemListEnumerator;

    //  Add a FhirClaimResponseAddItem to the end of the list.
    function Append : TFhirClaimResponseAddItem;

    // Add an already existing FhirClaimResponseAddItem to the end of the list.
    procedure AddItem(value : TFhirClaimResponseAddItem); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseAddItem) : Integer;

    // Insert FhirClaimResponseAddItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseAddItem;

    // Insert an existing FhirClaimResponseAddItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseAddItem);

    // Get the iIndexth FhirClaimResponseAddItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseAddItem);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseAddItem;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimResponseAddItems[index : Integer] : TFhirClaimResponseAddItem read GetItemN write SetItemN; default;
  End;

  // The adjudications results.
  TFhirClaimResponseAddItemAdjudication = class (TFhirBackboneElement)
  protected
    FCode : TFhirCoding;
    FAmount : TFhirQuantity;
    FValue : TFhirDecimal;
    Procedure SetCode(value : TFhirCoding);
    Procedure SetAmount(value : TFhirQuantity);
    Procedure SetValue(value : TFhirDecimal);
    Function GetValueST : String;
    Procedure SetValueST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseAddItemAdjudication; overload;
    function Clone : TFhirClaimResponseAddItemAdjudication; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Code indicating: Co-Pay, deductible, eligible, benefit, tax, etc. (defined for API consistency)
    property code : TFhirCoding read FCode write SetCode;
    // Code indicating: Co-Pay, deductible, eligible, benefit, tax, etc.
    property codeElement : TFhirCoding read FCode write SetCode;

    // Typed access to Monetary amount associated with the code. (defined for API consistency)
    property amount : TFhirQuantity read FAmount write SetAmount;
    // Monetary amount associated with the code.
    property amountElement : TFhirQuantity read FAmount write SetAmount;

    // Typed access to A non-monetary value for example a percentage. Mutually exclusive to the amount element above.
    property value : String read GetValueST write SetValueST;
    // A non-monetary value for example a percentage. Mutually exclusive to the amount element above.
    property valueElement : TFhirDecimal read FValue write SetValue;

  end;

  TFhirClaimResponseAddItemAdjudicationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseAddItemAdjudicationList;
    function GetCurrent : TFhirClaimResponseAddItemAdjudication;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseAddItemAdjudicationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseAddItemAdjudication read GetCurrent;
  end;

  TFhirClaimResponseAddItemAdjudicationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimResponseAddItemAdjudication;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseAddItemAdjudication);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimResponseAddItemAdjudicationList; Overload;
    function Clone : TFhirClaimResponseAddItemAdjudicationList; Overload;
    function GetEnumerator : TFhirClaimResponseAddItemAdjudicationListEnumerator;

    //  Add a FhirClaimResponseAddItemAdjudication to the end of the list.
    function Append : TFhirClaimResponseAddItemAdjudication;

    // Add an already existing FhirClaimResponseAddItemAdjudication to the end of the list.
    procedure AddItem(value : TFhirClaimResponseAddItemAdjudication); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseAddItemAdjudication) : Integer;

    // Insert FhirClaimResponseAddItemAdjudication before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseAddItemAdjudication;

    // Insert an existing FhirClaimResponseAddItemAdjudication before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseAddItemAdjudication);

    // Get the iIndexth FhirClaimResponseAddItemAdjudication. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseAddItemAdjudication);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseAddItemAdjudication;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimResponseAddItemAdjudications[index : Integer] : TFhirClaimResponseAddItemAdjudication read GetItemN write SetItemN; default;
  End;

  // The second tier service adjudications for payor added services.
  TFhirClaimResponseAddItemDetail = class (TFhirBackboneElement)
  protected
    FService : TFhirCoding;
    FFee : TFhirQuantity;
    FadjudicationList : TFhirClaimResponseAddItemDetailAdjudicationList;
    Procedure SetService(value : TFhirCoding);
    Procedure SetFee(value : TFhirQuantity);
    function GetAdjudicationList : TFhirClaimResponseAddItemDetailAdjudicationList;
    function GetHasAdjudicationList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseAddItemDetail; overload;
    function Clone : TFhirClaimResponseAddItemDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code to indicate the Professional Service or Product supplied. (defined for API consistency)
    property service : TFhirCoding read FService write SetService;
    // A code to indicate the Professional Service or Product supplied.
    property serviceElement : TFhirCoding read FService write SetService;

    // Typed access to The fee charged for the professional service or product.. (defined for API consistency)
    property fee : TFhirQuantity read FFee write SetFee;
    // The fee charged for the professional service or product..
    property feeElement : TFhirQuantity read FFee write SetFee;

    // The adjudications results.
    property adjudicationList : TFhirClaimResponseAddItemDetailAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

  end;

  TFhirClaimResponseAddItemDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseAddItemDetailList;
    function GetCurrent : TFhirClaimResponseAddItemDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseAddItemDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseAddItemDetail read GetCurrent;
  end;

  TFhirClaimResponseAddItemDetailList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimResponseAddItemDetail;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseAddItemDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimResponseAddItemDetailList; Overload;
    function Clone : TFhirClaimResponseAddItemDetailList; Overload;
    function GetEnumerator : TFhirClaimResponseAddItemDetailListEnumerator;

    //  Add a FhirClaimResponseAddItemDetail to the end of the list.
    function Append : TFhirClaimResponseAddItemDetail;

    // Add an already existing FhirClaimResponseAddItemDetail to the end of the list.
    procedure AddItem(value : TFhirClaimResponseAddItemDetail); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseAddItemDetail) : Integer;

    // Insert FhirClaimResponseAddItemDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseAddItemDetail;

    // Insert an existing FhirClaimResponseAddItemDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseAddItemDetail);

    // Get the iIndexth FhirClaimResponseAddItemDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseAddItemDetail);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseAddItemDetail;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimResponseAddItemDetails[index : Integer] : TFhirClaimResponseAddItemDetail read GetItemN write SetItemN; default;
  End;

  // The adjudications results.
  TFhirClaimResponseAddItemDetailAdjudication = class (TFhirBackboneElement)
  protected
    FCode : TFhirCoding;
    FAmount : TFhirQuantity;
    FValue : TFhirDecimal;
    Procedure SetCode(value : TFhirCoding);
    Procedure SetAmount(value : TFhirQuantity);
    Procedure SetValue(value : TFhirDecimal);
    Function GetValueST : String;
    Procedure SetValueST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseAddItemDetailAdjudication; overload;
    function Clone : TFhirClaimResponseAddItemDetailAdjudication; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Code indicating: Co-Pay, deductible, eligible, benefit, tax, etc. (defined for API consistency)
    property code : TFhirCoding read FCode write SetCode;
    // Code indicating: Co-Pay, deductible, eligible, benefit, tax, etc.
    property codeElement : TFhirCoding read FCode write SetCode;

    // Typed access to Monetary amount associated with the code. (defined for API consistency)
    property amount : TFhirQuantity read FAmount write SetAmount;
    // Monetary amount associated with the code.
    property amountElement : TFhirQuantity read FAmount write SetAmount;

    // Typed access to A non-monetary value for example a percentage. Mutually exclusive to the amount element above.
    property value : String read GetValueST write SetValueST;
    // A non-monetary value for example a percentage. Mutually exclusive to the amount element above.
    property valueElement : TFhirDecimal read FValue write SetValue;

  end;

  TFhirClaimResponseAddItemDetailAdjudicationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseAddItemDetailAdjudicationList;
    function GetCurrent : TFhirClaimResponseAddItemDetailAdjudication;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseAddItemDetailAdjudicationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseAddItemDetailAdjudication read GetCurrent;
  end;

  TFhirClaimResponseAddItemDetailAdjudicationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimResponseAddItemDetailAdjudication;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseAddItemDetailAdjudication);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimResponseAddItemDetailAdjudicationList; Overload;
    function Clone : TFhirClaimResponseAddItemDetailAdjudicationList; Overload;
    function GetEnumerator : TFhirClaimResponseAddItemDetailAdjudicationListEnumerator;

    //  Add a FhirClaimResponseAddItemDetailAdjudication to the end of the list.
    function Append : TFhirClaimResponseAddItemDetailAdjudication;

    // Add an already existing FhirClaimResponseAddItemDetailAdjudication to the end of the list.
    procedure AddItem(value : TFhirClaimResponseAddItemDetailAdjudication); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseAddItemDetailAdjudication) : Integer;

    // Insert FhirClaimResponseAddItemDetailAdjudication before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseAddItemDetailAdjudication;

    // Insert an existing FhirClaimResponseAddItemDetailAdjudication before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseAddItemDetailAdjudication);

    // Get the iIndexth FhirClaimResponseAddItemDetailAdjudication. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseAddItemDetailAdjudication);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseAddItemDetailAdjudication;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimResponseAddItemDetailAdjudications[index : Integer] : TFhirClaimResponseAddItemDetailAdjudication read GetItemN write SetItemN; default;
  End;

  // Mutually exclusive with Services Provided (Item).
  TFhirClaimResponseError = class (TFhirBackboneElement)
  protected
    FSequenceLinkId : TFhirPositiveInt;
    FDetailSequenceLinkId : TFhirPositiveInt;
    FSubdetailSequenceLinkId : TFhirPositiveInt;
    FCode : TFhirCoding;
    Procedure SetSequenceLinkId(value : TFhirPositiveInt);
    Function GetSequenceLinkIdST : String;
    Procedure SetSequenceLinkIdST(value : String);
    Procedure SetDetailSequenceLinkId(value : TFhirPositiveInt);
    Function GetDetailSequenceLinkIdST : String;
    Procedure SetDetailSequenceLinkIdST(value : String);
    Procedure SetSubdetailSequenceLinkId(value : TFhirPositiveInt);
    Function GetSubdetailSequenceLinkIdST : String;
    Procedure SetSubdetailSequenceLinkIdST(value : String);
    Procedure SetCode(value : TFhirCoding);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseError; overload;
    function Clone : TFhirClaimResponseError; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The sequence number of the line item submitted which contains the error. This value is omitted when the error is elsewhere.
    property sequenceLinkId : String read GetSequenceLinkIdST write SetSequenceLinkIdST;
    // The sequence number of the line item submitted which contains the error. This value is omitted when the error is elsewhere.
    property sequenceLinkIdElement : TFhirPositiveInt read FSequenceLinkId write SetSequenceLinkId;

    // Typed access to The sequence number of the addition within the line item submitted which contains the error. This value is omitted when the error is not related to an Addition.
    property detailSequenceLinkId : String read GetDetailSequenceLinkIdST write SetDetailSequenceLinkIdST;
    // The sequence number of the addition within the line item submitted which contains the error. This value is omitted when the error is not related to an Addition.
    property detailSequenceLinkIdElement : TFhirPositiveInt read FDetailSequenceLinkId write SetDetailSequenceLinkId;

    // Typed access to The sequence number of the addition within the line item submitted which contains the error. This value is omitted when the error is not related to an Addition.
    property subdetailSequenceLinkId : String read GetSubdetailSequenceLinkIdST write SetSubdetailSequenceLinkIdST;
    // The sequence number of the addition within the line item submitted which contains the error. This value is omitted when the error is not related to an Addition.
    property subdetailSequenceLinkIdElement : TFhirPositiveInt read FSubdetailSequenceLinkId write SetSubdetailSequenceLinkId;

    // Typed access to An error code,froma specified code system, which details why the claim could not be adjudicated. (defined for API consistency)
    property code : TFhirCoding read FCode write SetCode;
    // An error code,froma specified code system, which details why the claim could not be adjudicated.
    property codeElement : TFhirCoding read FCode write SetCode;

  end;

  TFhirClaimResponseErrorListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseErrorList;
    function GetCurrent : TFhirClaimResponseError;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseErrorList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseError read GetCurrent;
  end;

  TFhirClaimResponseErrorList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimResponseError;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseError);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimResponseErrorList; Overload;
    function Clone : TFhirClaimResponseErrorList; Overload;
    function GetEnumerator : TFhirClaimResponseErrorListEnumerator;

    //  Add a FhirClaimResponseError to the end of the list.
    function Append : TFhirClaimResponseError;

    // Add an already existing FhirClaimResponseError to the end of the list.
    procedure AddItem(value : TFhirClaimResponseError); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseError) : Integer;

    // Insert FhirClaimResponseError before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseError;

    // Insert an existing FhirClaimResponseError before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseError);

    // Get the iIndexth FhirClaimResponseError. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseError);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseError;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimResponseErrors[index : Integer] : TFhirClaimResponseError read GetItemN write SetItemN; default;
  End;

  // Note text.
  TFhirClaimResponseNote = class (TFhirBackboneElement)
  protected
    FNumber : TFhirPositiveInt;
    FType_ : TFhirCoding;
    FText : TFhirString;
    Procedure SetNumber(value : TFhirPositiveInt);
    Function GetNumberST : String;
    Procedure SetNumberST(value : String);
    Procedure SetType_(value : TFhirCoding);
    Procedure SetText(value : TFhirString);
    Function GetTextST : String;
    Procedure SetTextST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseNote; overload;
    function Clone : TFhirClaimResponseNote; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An integer associated with each note which may be referred to from each service line item.
    property number : String read GetNumberST write SetNumberST;
    // An integer associated with each note which may be referred to from each service line item.
    property numberElement : TFhirPositiveInt read FNumber write SetNumber;

    // Typed access to The note purpose: Print/Display. (defined for API consistency)
    property type_ : TFhirCoding read FType_ write SetType_;
    // The note purpose: Print/Display.
    property type_Element : TFhirCoding read FType_ write SetType_;

    // Typed access to The note text.
    property text : String read GetTextST write SetTextST;
    // The note text.
    property textElement : TFhirString read FText write SetText;

  end;

  TFhirClaimResponseNoteListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseNoteList;
    function GetCurrent : TFhirClaimResponseNote;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseNoteList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseNote read GetCurrent;
  end;

  TFhirClaimResponseNoteList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimResponseNote;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseNote);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimResponseNoteList; Overload;
    function Clone : TFhirClaimResponseNoteList; Overload;
    function GetEnumerator : TFhirClaimResponseNoteListEnumerator;

    //  Add a FhirClaimResponseNote to the end of the list.
    function Append : TFhirClaimResponseNote;

    // Add an already existing FhirClaimResponseNote to the end of the list.
    procedure AddItem(value : TFhirClaimResponseNote); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseNote) : Integer;

    // Insert FhirClaimResponseNote before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseNote;

    // Insert an existing FhirClaimResponseNote before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseNote);

    // Get the iIndexth FhirClaimResponseNote. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseNote);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseNote;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimResponseNotes[index : Integer] : TFhirClaimResponseNote read GetItemN write SetItemN; default;
  End;

  // Financial instrument by which payment information for health care.
  TFhirClaimResponseCoverage = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FFocal : TFhirBoolean;
    FCoverage : TFhirReference{TFhirCoverage};
    FBusinessArrangement : TFhirString;
    FRelationship : TFhirCoding;
    FpreAuthRefList : TFhirStringList;
    FClaimResponse : TFhirReference{TFhirClaimResponse};
    FOriginalRuleset : TFhirCoding;
    Procedure SetSequence(value : TFhirPositiveInt);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    Procedure SetFocal(value : TFhirBoolean);
    Function GetFocalST : Boolean;
    Procedure SetFocalST(value : Boolean);
    Procedure SetCoverage(value : TFhirReference{TFhirCoverage});
    Procedure SetBusinessArrangement(value : TFhirString);
    Function GetBusinessArrangementST : String;
    Procedure SetBusinessArrangementST(value : String);
    Procedure SetRelationship(value : TFhirCoding);
    function GetPreAuthRefList : TFhirStringList;
    function GetHasPreAuthRefList : Boolean;
    Procedure SetClaimResponse(value : TFhirReference{TFhirClaimResponse});
    Procedure SetOriginalRuleset(value : TFhirCoding);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseCoverage; overload;
    function Clone : TFhirClaimResponseCoverage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A service line item.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A service line item.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The instance number of the Coverage which is the focus for adjudication. The Coverage against which the claim is to be adjudicated.
    property focal : Boolean read GetFocalST write SetFocalST;
    // The instance number of the Coverage which is the focus for adjudication. The Coverage against which the claim is to be adjudicated.
    property focalElement : TFhirBoolean read FFocal write SetFocal;

    // Typed access to Reference to the program or plan identification, underwriter or payor. (defined for API consistency)
    property coverage : TFhirReference{TFhirCoverage} read FCoverage write SetCoverage;
    // Reference to the program or plan identification, underwriter or payor.
    property coverageElement : TFhirReference{TFhirCoverage} read FCoverage write SetCoverage;

    // Typed access to The contract number of a business agreement which describes the terms and conditions.
    property businessArrangement : String read GetBusinessArrangementST write SetBusinessArrangementST;
    // The contract number of a business agreement which describes the terms and conditions.
    property businessArrangementElement : TFhirString read FBusinessArrangement write SetBusinessArrangement;

    // Typed access to The relationship of the patient to the subscriber. (defined for API consistency)
    property relationship : TFhirCoding read FRelationship write SetRelationship;
    // The relationship of the patient to the subscriber.
    property relationshipElement : TFhirCoding read FRelationship write SetRelationship;

    // A list of references from the Insurer to which these services pertain.
    property preAuthRefList : TFhirStringList read GetPreAuthRefList;
    property hasPreAuthRefList : boolean read GetHasPreAuthRefList;

    // Typed access to The Coverages adjudication details. (defined for API consistency)
    property claimResponse : TFhirReference{TFhirClaimResponse} read FClaimResponse write SetClaimResponse;
    // The Coverages adjudication details.
    property claimResponseElement : TFhirReference{TFhirClaimResponse} read FClaimResponse write SetClaimResponse;

    // Typed access to The style (standard) and version of the original material which was converted into this resource. (defined for API consistency)
    property originalRuleset : TFhirCoding read FOriginalRuleset write SetOriginalRuleset;
    // The style (standard) and version of the original material which was converted into this resource.
    property originalRulesetElement : TFhirCoding read FOriginalRuleset write SetOriginalRuleset;

  end;

  TFhirClaimResponseCoverageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseCoverageList;
    function GetCurrent : TFhirClaimResponseCoverage;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseCoverageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseCoverage read GetCurrent;
  end;

  TFhirClaimResponseCoverageList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimResponseCoverage;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseCoverage);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimResponseCoverageList; Overload;
    function Clone : TFhirClaimResponseCoverageList; Overload;
    function GetEnumerator : TFhirClaimResponseCoverageListEnumerator;

    //  Add a FhirClaimResponseCoverage to the end of the list.
    function Append : TFhirClaimResponseCoverage;

    // Add an already existing FhirClaimResponseCoverage to the end of the list.
    procedure AddItem(value : TFhirClaimResponseCoverage); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseCoverage) : Integer;

    // Insert FhirClaimResponseCoverage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseCoverage;

    // Insert an existing FhirClaimResponseCoverage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseCoverage);

    // Get the iIndexth FhirClaimResponseCoverage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseCoverage);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseCoverage;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimResponseCoverages[index : Integer] : TFhirClaimResponseCoverage read GetItemN write SetItemN; default;
  End;

  // This resource provides the adjudication details from the processing of a Claim resource.
  TFhirClaimResponse = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FRequest : TFhirReference{TFhirClaim};
    FRuleset : TFhirCoding;
    FOriginalRuleset : TFhirCoding;
    FCreated : TFhirDateTime;
    FOrganization : TFhirReference{TFhirOrganization};
    FRequestProvider : TFhirReference{TFhirPractitioner};
    FRequestOrganization : TFhirReference{TFhirOrganization};
    FOutcome : TFhirEnum;
    FDisposition : TFhirString;
    FPayeeType : TFhirCoding;
    FitemList : TFhirClaimResponseItemList;
    FaddItemList : TFhirClaimResponseAddItemList;
    FerrorList : TFhirClaimResponseErrorList;
    FTotalCost : TFhirQuantity;
    FUnallocDeductable : TFhirQuantity;
    FTotalBenefit : TFhirQuantity;
    FPaymentAdjustment : TFhirQuantity;
    FPaymentAdjustmentReason : TFhirCoding;
    FPaymentDate : TFhirDate;
    FPaymentAmount : TFhirQuantity;
    FPaymentRef : TFhirIdentifier;
    FReserved : TFhirCoding;
    FForm : TFhirCoding;
    FnoteList : TFhirClaimResponseNoteList;
    FcoverageList : TFhirClaimResponseCoverageList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetRequest(value : TFhirReference{TFhirClaim});
    Procedure SetRuleset(value : TFhirCoding);
    Procedure SetOriginalRuleset(value : TFhirCoding);
    Procedure SetCreated(value : TFhirDateTime);
    Function GetCreatedST : TFslDateTime;
    Procedure SetCreatedST(value : TFslDateTime);
    Procedure SetOrganization(value : TFhirReference{TFhirOrganization});
    Procedure SetRequestProvider(value : TFhirReference{TFhirPractitioner});
    Procedure SetRequestOrganization(value : TFhirReference{TFhirOrganization});
    Procedure SetOutcome(value : TFhirEnum);
    Function GetOutcomeST : TFhirRemittanceOutcomeEnum;
    Procedure SetOutcomeST(value : TFhirRemittanceOutcomeEnum);
    Procedure SetDisposition(value : TFhirString);
    Function GetDispositionST : String;
    Procedure SetDispositionST(value : String);
    Procedure SetPayeeType(value : TFhirCoding);
    function GetItemList : TFhirClaimResponseItemList;
    function GetHasItemList : Boolean;
    function GetAddItemList : TFhirClaimResponseAddItemList;
    function GetHasAddItemList : Boolean;
    function GetErrorList : TFhirClaimResponseErrorList;
    function GetHasErrorList : Boolean;
    Procedure SetTotalCost(value : TFhirQuantity);
    Procedure SetUnallocDeductable(value : TFhirQuantity);
    Procedure SetTotalBenefit(value : TFhirQuantity);
    Procedure SetPaymentAdjustment(value : TFhirQuantity);
    Procedure SetPaymentAdjustmentReason(value : TFhirCoding);
    Procedure SetPaymentDate(value : TFhirDate);
    Function GetPaymentDateST : TFslDateTime;
    Procedure SetPaymentDateST(value : TFslDateTime);
    Procedure SetPaymentAmount(value : TFhirQuantity);
    Procedure SetPaymentRef(value : TFhirIdentifier);
    Procedure SetReserved(value : TFhirCoding);
    Procedure SetForm(value : TFhirCoding);
    function GetNoteList : TFhirClaimResponseNoteList;
    function GetHasNoteList : Boolean;
    function GetCoverageList : TFhirClaimResponseCoverageList;
    function GetHasCoverageList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponse; overload;
    function Clone : TFhirClaimResponse; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The Response business identifier.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Original request resource referrence. (defined for API consistency)
    property request : TFhirReference{TFhirClaim} read FRequest write SetRequest;
    // Original request resource referrence.
    property requestElement : TFhirReference{TFhirClaim} read FRequest write SetRequest;

    // Typed access to The version of the style of resource contents. This should be mapped to the allowable profiles for this and supporting resources. (defined for API consistency)
    property ruleset : TFhirCoding read FRuleset write SetRuleset;
    // The version of the style of resource contents. This should be mapped to the allowable profiles for this and supporting resources.
    property rulesetElement : TFhirCoding read FRuleset write SetRuleset;

    // Typed access to The style (standard) and version of the original material which was converted into this resource. (defined for API consistency)
    property originalRuleset : TFhirCoding read FOriginalRuleset write SetOriginalRuleset;
    // The style (standard) and version of the original material which was converted into this resource.
    property originalRulesetElement : TFhirCoding read FOriginalRuleset write SetOriginalRuleset;

    // Typed access to The date when the enclosed suite of services were performed or completed.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date when the enclosed suite of services were performed or completed.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to The Insurer who produced this adjudicated response. (defined for API consistency)
    property organization : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;
    // The Insurer who produced this adjudicated response.
    property organizationElement : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;

    // Typed access to The practitioner who is responsible for the services rendered to the patient. (defined for API consistency)
    property requestProvider : TFhirReference{TFhirPractitioner} read FRequestProvider write SetRequestProvider;
    // The practitioner who is responsible for the services rendered to the patient.
    property requestProviderElement : TFhirReference{TFhirPractitioner} read FRequestProvider write SetRequestProvider;

    // Typed access to The organization which is responsible for the services rendered to the patient. (defined for API consistency)
    property requestOrganization : TFhirReference{TFhirOrganization} read FRequestOrganization write SetRequestOrganization;
    // The organization which is responsible for the services rendered to the patient.
    property requestOrganizationElement : TFhirReference{TFhirOrganization} read FRequestOrganization write SetRequestOrganization;

    // Transaction status: error, complete.
    property outcome : TFhirRemittanceOutcomeEnum read GetOutcomeST write SetOutcomeST;
    property outcomeElement : TFhirEnum read FOutcome write SetOutcome;

    // Typed access to A description of the status of the adjudication.
    property disposition : String read GetDispositionST write SetDispositionST;
    // A description of the status of the adjudication.
    property dispositionElement : TFhirString read FDisposition write SetDisposition;

    // Typed access to Party to be reimbursed: Subscriber, provider, other. (defined for API consistency)
    property payeeType : TFhirCoding read FPayeeType write SetPayeeType;
    // Party to be reimbursed: Subscriber, provider, other.
    property payeeTypeElement : TFhirCoding read FPayeeType write SetPayeeType;

    // The first tier service adjudications for submitted services.
    property itemList : TFhirClaimResponseItemList read GetItemList;
    property hasItemList : boolean read GetHasItemList;

    // The first tier service adjudications for payor added services.
    property addItemList : TFhirClaimResponseAddItemList read GetAddItemList;
    property hasAddItemList : boolean read GetHasAddItemList;

    // Mutually exclusive with Services Provided (Item).
    property errorList : TFhirClaimResponseErrorList read GetErrorList;
    property hasErrorList : boolean read GetHasErrorList;

    // Typed access to The total cost of the services reported. (defined for API consistency)
    property totalCost : TFhirQuantity read FTotalCost write SetTotalCost;
    // The total cost of the services reported.
    property totalCostElement : TFhirQuantity read FTotalCost write SetTotalCost;

    // Typed access to The amount of deductible applied which was not allocated to any particular service line. (defined for API consistency)
    property unallocDeductable : TFhirQuantity read FUnallocDeductable write SetUnallocDeductable;
    // The amount of deductible applied which was not allocated to any particular service line.
    property unallocDeductableElement : TFhirQuantity read FUnallocDeductable write SetUnallocDeductable;

    // Typed access to Total amount of benefit payable (Equal to sum of the Benefit amounts from all detail lines and additions less the Unallocated Deductible). (defined for API consistency)
    property totalBenefit : TFhirQuantity read FTotalBenefit write SetTotalBenefit;
    // Total amount of benefit payable (Equal to sum of the Benefit amounts from all detail lines and additions less the Unallocated Deductible).
    property totalBenefitElement : TFhirQuantity read FTotalBenefit write SetTotalBenefit;

    // Typed access to Adjustment to the payment of this transaction which is not related to adjudication of this transaction. (defined for API consistency)
    property paymentAdjustment : TFhirQuantity read FPaymentAdjustment write SetPaymentAdjustment;
    // Adjustment to the payment of this transaction which is not related to adjudication of this transaction.
    property paymentAdjustmentElement : TFhirQuantity read FPaymentAdjustment write SetPaymentAdjustment;

    // Typed access to Reason for the payment adjustment. (defined for API consistency)
    property paymentAdjustmentReason : TFhirCoding read FPaymentAdjustmentReason write SetPaymentAdjustmentReason;
    // Reason for the payment adjustment.
    property paymentAdjustmentReasonElement : TFhirCoding read FPaymentAdjustmentReason write SetPaymentAdjustmentReason;

    // Typed access to Estimated payment data.
    property paymentDate : TFslDateTime read GetPaymentDateST write SetPaymentDateST;
    // Estimated payment data.
    property paymentDateElement : TFhirDate read FPaymentDate write SetPaymentDate;

    // Typed access to Payable less any payment adjustment. (defined for API consistency)
    property paymentAmount : TFhirQuantity read FPaymentAmount write SetPaymentAmount;
    // Payable less any payment adjustment.
    property paymentAmountElement : TFhirQuantity read FPaymentAmount write SetPaymentAmount;

    // Typed access to Payment identifier. (defined for API consistency)
    property paymentRef : TFhirIdentifier read FPaymentRef write SetPaymentRef;
    // Payment identifier.
    property paymentRefElement : TFhirIdentifier read FPaymentRef write SetPaymentRef;

    // Typed access to Status of funds reservation (For provider, for Patient, None). (defined for API consistency)
    property reserved : TFhirCoding read FReserved write SetReserved;
    // Status of funds reservation (For provider, for Patient, None).
    property reservedElement : TFhirCoding read FReserved write SetReserved;

    // Typed access to The form to be used for printing the content. (defined for API consistency)
    property form : TFhirCoding read FForm write SetForm;
    // The form to be used for printing the content.
    property formElement : TFhirCoding read FForm write SetForm;

    // Note text.
    property noteList : TFhirClaimResponseNoteList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Financial instrument by which payment information for health care.
    property coverageList : TFhirClaimResponseCoverageList read GetCoverageList;
    property hasCoverageList : boolean read GetHasCoverageList;

  end;

  TFhirClaimResponseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseList;
    function GetCurrent : TFhirClaimResponse;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponse read GetCurrent;
  end;

  TFhirClaimResponseList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimResponse;
    procedure SetItemN(index : Integer; value : TFhirClaimResponse);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimResponseList; Overload;
    function Clone : TFhirClaimResponseList; Overload;
    function GetEnumerator : TFhirClaimResponseListEnumerator;

    //  Add a FhirClaimResponse to the end of the list.
    function Append : TFhirClaimResponse;

    // Add an already existing FhirClaimResponse to the end of the list.
    procedure AddItem(value : TFhirClaimResponse); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponse) : Integer;

    // Insert FhirClaimResponse before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponse;

    // Insert an existing FhirClaimResponse before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponse);

    // Get the iIndexth FhirClaimResponse. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponse);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponse;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClaimResponses[index : Integer] : TFhirClaimResponse read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CLAIMRESPONSE}

{$IFDEF FHIR_CONTRACT}

  // List of Contract actors.
  TFhirContractActor = class (TFhirBackboneElement)
  protected
    FEntity : TFhirReference{Resource};
    FroleList : TFhirCodeableConceptList;
    Procedure SetEntity(value : TFhirReference{Resource});
    function GetRoleList : TFhirCodeableConceptList;
    function GetHasRoleList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractActor; overload;
    function Clone : TFhirContractActor; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Who or what actors are assigned roles in this Contract. (defined for API consistency)
    property entity : TFhirReference{Resource} read FEntity write SetEntity;
    // Who or what actors are assigned roles in this Contract.
    property entityElement : TFhirReference{Resource} read FEntity write SetEntity;

    // Role type of actors assigned roles in this Contract.
    property roleList : TFhirCodeableConceptList read GetRoleList;
    property hasRoleList : boolean read GetHasRoleList;

  end;

  TFhirContractActorListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractActorList;
    function GetCurrent : TFhirContractActor;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirContractActorList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractActor read GetCurrent;
  end;

  TFhirContractActorList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirContractActor;
    procedure SetItemN(index : Integer; value : TFhirContractActor);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirContractActorList; Overload;
    function Clone : TFhirContractActorList; Overload;
    function GetEnumerator : TFhirContractActorListEnumerator;

    //  Add a FhirContractActor to the end of the list.
    function Append : TFhirContractActor;

    // Add an already existing FhirContractActor to the end of the list.
    procedure AddItem(value : TFhirContractActor); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractActor) : Integer;

    // Insert FhirContractActor before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractActor;

    // Insert an existing FhirContractActor before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractActor);

    // Get the iIndexth FhirContractActor. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractActor);

    // The number of items in the collection
    function Item(index : Integer) : TFhirContractActor;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirContractActors[index : Integer] : TFhirContractActor read GetItemN write SetItemN; default;
  End;

  // Contract Valued Item List.
  TFhirContractValuedItem = class (TFhirBackboneElement)
  protected
    FEntity : TFhirType;
    FIdentifier : TFhirIdentifier;
    FEffectiveTime : TFhirDateTime;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirQuantity;
    FFactor : TFhirDecimal;
    FPoints : TFhirDecimal;
    FNet : TFhirQuantity;
    Procedure SetEntity(value : TFhirType);
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetEffectiveTime(value : TFhirDateTime);
    Function GetEffectiveTimeST : TFslDateTime;
    Procedure SetEffectiveTimeST(value : TFslDateTime);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetUnitPrice(value : TFhirQuantity);
    Procedure SetFactor(value : TFhirDecimal);
    Function GetFactorST : String;
    Procedure SetFactorST(value : String);
    Procedure SetPoints(value : TFhirDecimal);
    Function GetPointsST : String;
    Procedure SetPointsST(value : String);
    Procedure SetNet(value : TFhirQuantity);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractValuedItem; overload;
    function Clone : TFhirContractValuedItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Specific type of Contract Valued Item that may be priced. (defined for API consistency)
    property entity : TFhirType read FEntity write SetEntity;
    // Specific type of Contract Valued Item that may be priced.
    property entityElement : TFhirType read FEntity write SetEntity;

    // Typed access to Identifies a Contract Valued Item instance. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Identifies a Contract Valued Item instance.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to Indicates the time during which this Contract ValuedItem information is effective.
    property effectiveTime : TFslDateTime read GetEffectiveTimeST write SetEffectiveTimeST;
    // Indicates the time during which this Contract ValuedItem information is effective.
    property effectiveTimeElement : TFhirDateTime read FEffectiveTime write SetEffectiveTime;

    // Typed access to Specifies the units by which the Contract Valued Item is measured or counted, and quantifies the countable or measurable Contract Valued Item instances. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // Specifies the units by which the Contract Valued Item is measured or counted, and quantifies the countable or measurable Contract Valued Item instances.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to A Contract Valued Item unit valuation measure. (defined for API consistency)
    property unitPrice : TFhirQuantity read FUnitPrice write SetUnitPrice;
    // A Contract Valued Item unit valuation measure.
    property unitPriceElement : TFhirQuantity read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of the Contract Valued Item delivered. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of the Contract Valued Item delivered. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to An amount that expresses the weighting (based on difficulty, cost and/or resource intensiveness) associated with the Contract Valued Item delivered. The concept of Points allows for assignment of point values for a Contract Valued Item, such that a monetary amount can be assigned to each point.
    property points : String read GetPointsST write SetPointsST;
    // An amount that expresses the weighting (based on difficulty, cost and/or resource intensiveness) associated with the Contract Valued Item delivered. The concept of Points allows for assignment of point values for a Contract Valued Item, such that a monetary amount can be assigned to each point.
    property pointsElement : TFhirDecimal read FPoints write SetPoints;

    // Typed access to Expresses the product of the Contract Valued Item unitQuantity and the unitPriceAmt. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied. (defined for API consistency)
    property net : TFhirQuantity read FNet write SetNet;
    // Expresses the product of the Contract Valued Item unitQuantity and the unitPriceAmt. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied.
    property netElement : TFhirQuantity read FNet write SetNet;

  end;

  TFhirContractValuedItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractValuedItemList;
    function GetCurrent : TFhirContractValuedItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirContractValuedItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractValuedItem read GetCurrent;
  end;

  TFhirContractValuedItemList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirContractValuedItem;
    procedure SetItemN(index : Integer; value : TFhirContractValuedItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirContractValuedItemList; Overload;
    function Clone : TFhirContractValuedItemList; Overload;
    function GetEnumerator : TFhirContractValuedItemListEnumerator;

    //  Add a FhirContractValuedItem to the end of the list.
    function Append : TFhirContractValuedItem;

    // Add an already existing FhirContractValuedItem to the end of the list.
    procedure AddItem(value : TFhirContractValuedItem); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractValuedItem) : Integer;

    // Insert FhirContractValuedItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractValuedItem;

    // Insert an existing FhirContractValuedItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractValuedItem);

    // Get the iIndexth FhirContractValuedItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractValuedItem);

    // The number of items in the collection
    function Item(index : Integer) : TFhirContractValuedItem;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirContractValuedItems[index : Integer] : TFhirContractValuedItem read GetItemN write SetItemN; default;
  End;

  // Party signing this Contract.
  TFhirContractSigner = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCoding;
    FParty : TFhirReference{Resource};
    FSignature : TFhirString;
    Procedure SetType_(value : TFhirCoding);
    Procedure SetParty(value : TFhirReference{Resource});
    Procedure SetSignature(value : TFhirString);
    Function GetSignatureST : String;
    Procedure SetSignatureST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractSigner; overload;
    function Clone : TFhirContractSigner; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Role of this Contract signer, e.g. notary, grantee. (defined for API consistency)
    property type_ : TFhirCoding read FType_ write SetType_;
    // Role of this Contract signer, e.g. notary, grantee.
    property type_Element : TFhirCoding read FType_ write SetType_;

    // Typed access to Party which is a signator to this Contract. (defined for API consistency)
    property party : TFhirReference{Resource} read FParty write SetParty;
    // Party which is a signator to this Contract.
    property partyElement : TFhirReference{Resource} read FParty write SetParty;

    // Typed access to Legally binding Contract DSIG signature contents in Base64.
    property signature : String read GetSignatureST write SetSignatureST;
    // Legally binding Contract DSIG signature contents in Base64.
    property signatureElement : TFhirString read FSignature write SetSignature;

  end;

  TFhirContractSignerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractSignerList;
    function GetCurrent : TFhirContractSigner;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirContractSignerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractSigner read GetCurrent;
  end;

  TFhirContractSignerList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirContractSigner;
    procedure SetItemN(index : Integer; value : TFhirContractSigner);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirContractSignerList; Overload;
    function Clone : TFhirContractSignerList; Overload;
    function GetEnumerator : TFhirContractSignerListEnumerator;

    //  Add a FhirContractSigner to the end of the list.
    function Append : TFhirContractSigner;

    // Add an already existing FhirContractSigner to the end of the list.
    procedure AddItem(value : TFhirContractSigner); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractSigner) : Integer;

    // Insert FhirContractSigner before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractSigner;

    // Insert an existing FhirContractSigner before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractSigner);

    // Get the iIndexth FhirContractSigner. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractSigner);

    // The number of items in the collection
    function Item(index : Integer) : TFhirContractSigner;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirContractSigners[index : Integer] : TFhirContractSigner read GetItemN write SetItemN; default;
  End;

  // One or more Contract Provisions, which may be related and conveyed as a group, and may contain nested groups.
  TFhirContractTerm = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirIdentifier;
    FIssued : TFhirDateTime;
    FApplies : TFhirPeriod;
    FType_ : TFhirCodeableConcept;
    FSubType : TFhirCodeableConcept;
    FSubject : TFhirReference{TFhirReference};
    FactionList : TFhirCodeableConceptList;
    FactionReasonList : TFhirCodeableConceptList;
    FactorList : TFhirContractTermActorList;
    FText : TFhirString;
    FvaluedItemList : TFhirContractTermValuedItemList;
    FgroupList : TFhirContractTermList;
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetIssued(value : TFhirDateTime);
    Function GetIssuedST : TFslDateTime;
    Procedure SetIssuedST(value : TFslDateTime);
    Procedure SetApplies(value : TFhirPeriod);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetSubType(value : TFhirCodeableConcept);
    Procedure SetSubject(value : TFhirReference{TFhirReference});
    function GetActionList : TFhirCodeableConceptList;
    function GetHasActionList : Boolean;
    function GetActionReasonList : TFhirCodeableConceptList;
    function GetHasActionReasonList : Boolean;
    function GetActorList : TFhirContractTermActorList;
    function GetHasActorList : Boolean;
    Procedure SetText(value : TFhirString);
    Function GetTextST : String;
    Procedure SetTextST(value : String);
    function GetValuedItemList : TFhirContractTermValuedItemList;
    function GetHasValuedItemList : Boolean;
    function GetGroupList : TFhirContractTermList;
    function GetHasGroupList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractTerm; overload;
    function Clone : TFhirContractTerm; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Unique identifier for this particular Contract Provision. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Unique identifier for this particular Contract Provision.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to When this Contract Provision was issued.
    property issued : TFslDateTime read GetIssuedST write SetIssuedST;
    // When this Contract Provision was issued.
    property issuedElement : TFhirDateTime read FIssued write SetIssued;

    // Typed access to Relevant time or time-period when this Contract Provision is applicable. (defined for API consistency)
    property applies : TFhirPeriod read FApplies write SetApplies;
    // Relevant time or time-period when this Contract Provision is applicable.
    property appliesElement : TFhirPeriod read FApplies write SetApplies;

    // Typed access to Type of Contract Provision such as specific requirements, purposes for actions, obligations, prohibitions, e.g. life time maximum benefit. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of Contract Provision such as specific requirements, purposes for actions, obligations, prohibitions, e.g. life time maximum benefit.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Subtype of this Contract Provision, e.g. life time maximum payment for a contract term for specific valued item, e.g. disability payment. (defined for API consistency)
    property subType : TFhirCodeableConcept read FSubType write SetSubType;
    // Subtype of this Contract Provision, e.g. life time maximum payment for a contract term for specific valued item, e.g. disability payment.
    property subTypeElement : TFhirCodeableConcept read FSubType write SetSubType;

    // Typed access to Who or what this Contract Provision is about. (defined for API consistency)
    property subject : TFhirReference{TFhirReference} read FSubject write SetSubject;
    // Who or what this Contract Provision is about.
    property subjectElement : TFhirReference{TFhirReference} read FSubject write SetSubject;

    // Action stipulated by this Contract Provision.
    property actionList : TFhirCodeableConceptList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

    // Reason or purpose for the action stipulated by this Contract Provision.
    property actionReasonList : TFhirCodeableConceptList read GetActionReasonList;
    property hasActionReasonList : boolean read GetHasActionReasonList;

    // List of actors participating in this Contract Provision.
    property actorList : TFhirContractTermActorList read GetActorList;
    property hasActorList : boolean read GetHasActorList;

    // Typed access to Human readable form of this Contract Provision.
    property text : String read GetTextST write SetTextST;
    // Human readable form of this Contract Provision.
    property textElement : TFhirString read FText write SetText;

    // Contract Provision Valued Item List.
    property valuedItemList : TFhirContractTermValuedItemList read GetValuedItemList;
    property hasValuedItemList : boolean read GetHasValuedItemList;

    // Nested group of Contract Provisions.
    property groupList : TFhirContractTermList read GetGroupList;
    property hasGroupList : boolean read GetHasGroupList;

  end;

  TFhirContractTermListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractTermList;
    function GetCurrent : TFhirContractTerm;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirContractTermList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractTerm read GetCurrent;
  end;

  TFhirContractTermList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirContractTerm;
    procedure SetItemN(index : Integer; value : TFhirContractTerm);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirContractTermList; Overload;
    function Clone : TFhirContractTermList; Overload;
    function GetEnumerator : TFhirContractTermListEnumerator;

    //  Add a FhirContractTerm to the end of the list.
    function Append : TFhirContractTerm;

    // Add an already existing FhirContractTerm to the end of the list.
    procedure AddItem(value : TFhirContractTerm); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractTerm) : Integer;

    // Insert FhirContractTerm before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractTerm;

    // Insert an existing FhirContractTerm before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractTerm);

    // Get the iIndexth FhirContractTerm. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractTerm);

    // The number of items in the collection
    function Item(index : Integer) : TFhirContractTerm;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirContractTerms[index : Integer] : TFhirContractTerm read GetItemN write SetItemN; default;
  End;

  // List of actors participating in this Contract Provision.
  TFhirContractTermActor = class (TFhirBackboneElement)
  protected
    FEntity : TFhirReference{Resource};
    FroleList : TFhirCodeableConceptList;
    Procedure SetEntity(value : TFhirReference{Resource});
    function GetRoleList : TFhirCodeableConceptList;
    function GetHasRoleList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractTermActor; overload;
    function Clone : TFhirContractTermActor; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The actor assigned a role in this Contract Provision. (defined for API consistency)
    property entity : TFhirReference{Resource} read FEntity write SetEntity;
    // The actor assigned a role in this Contract Provision.
    property entityElement : TFhirReference{Resource} read FEntity write SetEntity;

    // Role played by the actor assigned this role in this Contract Provision.
    property roleList : TFhirCodeableConceptList read GetRoleList;
    property hasRoleList : boolean read GetHasRoleList;

  end;

  TFhirContractTermActorListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractTermActorList;
    function GetCurrent : TFhirContractTermActor;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirContractTermActorList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractTermActor read GetCurrent;
  end;

  TFhirContractTermActorList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirContractTermActor;
    procedure SetItemN(index : Integer; value : TFhirContractTermActor);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirContractTermActorList; Overload;
    function Clone : TFhirContractTermActorList; Overload;
    function GetEnumerator : TFhirContractTermActorListEnumerator;

    //  Add a FhirContractTermActor to the end of the list.
    function Append : TFhirContractTermActor;

    // Add an already existing FhirContractTermActor to the end of the list.
    procedure AddItem(value : TFhirContractTermActor); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractTermActor) : Integer;

    // Insert FhirContractTermActor before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractTermActor;

    // Insert an existing FhirContractTermActor before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractTermActor);

    // Get the iIndexth FhirContractTermActor. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractTermActor);

    // The number of items in the collection
    function Item(index : Integer) : TFhirContractTermActor;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirContractTermActors[index : Integer] : TFhirContractTermActor read GetItemN write SetItemN; default;
  End;

  // Contract Provision Valued Item List.
  TFhirContractTermValuedItem = class (TFhirBackboneElement)
  protected
    FEntity : TFhirType;
    FIdentifier : TFhirIdentifier;
    FEffectiveTime : TFhirDateTime;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirQuantity;
    FFactor : TFhirDecimal;
    FPoints : TFhirDecimal;
    FNet : TFhirQuantity;
    Procedure SetEntity(value : TFhirType);
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetEffectiveTime(value : TFhirDateTime);
    Function GetEffectiveTimeST : TFslDateTime;
    Procedure SetEffectiveTimeST(value : TFslDateTime);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetUnitPrice(value : TFhirQuantity);
    Procedure SetFactor(value : TFhirDecimal);
    Function GetFactorST : String;
    Procedure SetFactorST(value : String);
    Procedure SetPoints(value : TFhirDecimal);
    Function GetPointsST : String;
    Procedure SetPointsST(value : String);
    Procedure SetNet(value : TFhirQuantity);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractTermValuedItem; overload;
    function Clone : TFhirContractTermValuedItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Specific type of Contract Provision Valued Item that may be priced. (defined for API consistency)
    property entity : TFhirType read FEntity write SetEntity;
    // Specific type of Contract Provision Valued Item that may be priced.
    property entityElement : TFhirType read FEntity write SetEntity;

    // Typed access to Identifies a Contract Provision Valued Item instance. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Identifies a Contract Provision Valued Item instance.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to Indicates the time during which this Contract Term ValuedItem information is effective.
    property effectiveTime : TFslDateTime read GetEffectiveTimeST write SetEffectiveTimeST;
    // Indicates the time during which this Contract Term ValuedItem information is effective.
    property effectiveTimeElement : TFhirDateTime read FEffectiveTime write SetEffectiveTime;

    // Typed access to Specifies the units by which the Contract Provision Valued Item is measured or counted, and quantifies the countable or measurable Contract Term Valued Item instances. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // Specifies the units by which the Contract Provision Valued Item is measured or counted, and quantifies the countable or measurable Contract Term Valued Item instances.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to A Contract Provision Valued Item unit valuation measure. (defined for API consistency)
    property unitPrice : TFhirQuantity read FUnitPrice write SetUnitPrice;
    // A Contract Provision Valued Item unit valuation measure.
    property unitPriceElement : TFhirQuantity read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of the Contract Provision Valued Item delivered. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of the Contract Provision Valued Item delivered. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to An amount that expresses the weighting (based on difficulty, cost and/or resource intensiveness) associated with the Contract Provision Valued Item delivered. The concept of Points allows for assignment of point values for a Contract ProvisionValued Item, such that a monetary amount can be assigned to each point.
    property points : String read GetPointsST write SetPointsST;
    // An amount that expresses the weighting (based on difficulty, cost and/or resource intensiveness) associated with the Contract Provision Valued Item delivered. The concept of Points allows for assignment of point values for a Contract ProvisionValued Item, such that a monetary amount can be assigned to each point.
    property pointsElement : TFhirDecimal read FPoints write SetPoints;

    // Typed access to Expresses the product of the Contract Provision Valued Item unitQuantity and the unitPriceAmt. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied. (defined for API consistency)
    property net : TFhirQuantity read FNet write SetNet;
    // Expresses the product of the Contract Provision Valued Item unitQuantity and the unitPriceAmt. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied.
    property netElement : TFhirQuantity read FNet write SetNet;

  end;

  TFhirContractTermValuedItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractTermValuedItemList;
    function GetCurrent : TFhirContractTermValuedItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirContractTermValuedItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractTermValuedItem read GetCurrent;
  end;

  TFhirContractTermValuedItemList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirContractTermValuedItem;
    procedure SetItemN(index : Integer; value : TFhirContractTermValuedItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirContractTermValuedItemList; Overload;
    function Clone : TFhirContractTermValuedItemList; Overload;
    function GetEnumerator : TFhirContractTermValuedItemListEnumerator;

    //  Add a FhirContractTermValuedItem to the end of the list.
    function Append : TFhirContractTermValuedItem;

    // Add an already existing FhirContractTermValuedItem to the end of the list.
    procedure AddItem(value : TFhirContractTermValuedItem); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractTermValuedItem) : Integer;

    // Insert FhirContractTermValuedItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractTermValuedItem;

    // Insert an existing FhirContractTermValuedItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractTermValuedItem);

    // Get the iIndexth FhirContractTermValuedItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractTermValuedItem);

    // The number of items in the collection
    function Item(index : Integer) : TFhirContractTermValuedItem;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirContractTermValuedItems[index : Integer] : TFhirContractTermValuedItem read GetItemN write SetItemN; default;
  End;

  // The "patient friendly language" versionof the Contract in whole or in parts. "Patient friendly language" means the representation of the Contract and Contract Provisions in a manner that is readily accessible and understandable by a layperson in accordance with best practices for communication styles that ensure that those agreeing to or signing the Contract understand the roles, actions, obligations, responsibilities, and implication of the agreement.
  TFhirContractFriendly = class (TFhirBackboneElement)
  protected
    FContent : TFhirType;
    Procedure SetContent(value : TFhirType);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractFriendly; overload;
    function Clone : TFhirContractFriendly; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Human readable rendering of this Contract in a format and representation intended to enhance comprehension and ensure understandability. (defined for API consistency)
    property content : TFhirType read FContent write SetContent;
    // Human readable rendering of this Contract in a format and representation intended to enhance comprehension and ensure understandability.
    property contentElement : TFhirType read FContent write SetContent;

  end;

  TFhirContractFriendlyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractFriendlyList;
    function GetCurrent : TFhirContractFriendly;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirContractFriendlyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractFriendly read GetCurrent;
  end;

  TFhirContractFriendlyList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirContractFriendly;
    procedure SetItemN(index : Integer; value : TFhirContractFriendly);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirContractFriendlyList; Overload;
    function Clone : TFhirContractFriendlyList; Overload;
    function GetEnumerator : TFhirContractFriendlyListEnumerator;

    //  Add a FhirContractFriendly to the end of the list.
    function Append : TFhirContractFriendly;

    // Add an already existing FhirContractFriendly to the end of the list.
    procedure AddItem(value : TFhirContractFriendly); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractFriendly) : Integer;

    // Insert FhirContractFriendly before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractFriendly;

    // Insert an existing FhirContractFriendly before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractFriendly);

    // Get the iIndexth FhirContractFriendly. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractFriendly);

    // The number of items in the collection
    function Item(index : Integer) : TFhirContractFriendly;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirContractFriendlies[index : Integer] : TFhirContractFriendly read GetItemN write SetItemN; default;
  End;

  // List of Legal expressions or representations of this Contract.
  TFhirContractLegal = class (TFhirBackboneElement)
  protected
    FContent : TFhirType;
    Procedure SetContent(value : TFhirType);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractLegal; overload;
    function Clone : TFhirContractLegal; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Contract legal text in human renderable form. (defined for API consistency)
    property content : TFhirType read FContent write SetContent;
    // Contract legal text in human renderable form.
    property contentElement : TFhirType read FContent write SetContent;

  end;

  TFhirContractLegalListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractLegalList;
    function GetCurrent : TFhirContractLegal;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirContractLegalList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractLegal read GetCurrent;
  end;

  TFhirContractLegalList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirContractLegal;
    procedure SetItemN(index : Integer; value : TFhirContractLegal);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirContractLegalList; Overload;
    function Clone : TFhirContractLegalList; Overload;
    function GetEnumerator : TFhirContractLegalListEnumerator;

    //  Add a FhirContractLegal to the end of the list.
    function Append : TFhirContractLegal;

    // Add an already existing FhirContractLegal to the end of the list.
    procedure AddItem(value : TFhirContractLegal); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractLegal) : Integer;

    // Insert FhirContractLegal before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractLegal;

    // Insert an existing FhirContractLegal before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractLegal);

    // Get the iIndexth FhirContractLegal. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractLegal);

    // The number of items in the collection
    function Item(index : Integer) : TFhirContractLegal;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirContractLegals[index : Integer] : TFhirContractLegal read GetItemN write SetItemN; default;
  End;

  // List of Computable Policy Rule Language Representations of this Contract.
  TFhirContractRule = class (TFhirBackboneElement)
  protected
    FContent : TFhirType;
    Procedure SetContent(value : TFhirType);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractRule; overload;
    function Clone : TFhirContractRule; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Computable Contract conveyed using a policy rule language (e.g. XACML, DKAL, SecPal). (defined for API consistency)
    property content : TFhirType read FContent write SetContent;
    // Computable Contract conveyed using a policy rule language (e.g. XACML, DKAL, SecPal).
    property contentElement : TFhirType read FContent write SetContent;

  end;

  TFhirContractRuleListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractRuleList;
    function GetCurrent : TFhirContractRule;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirContractRuleList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractRule read GetCurrent;
  end;

  TFhirContractRuleList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirContractRule;
    procedure SetItemN(index : Integer; value : TFhirContractRule);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirContractRuleList; Overload;
    function Clone : TFhirContractRuleList; Overload;
    function GetEnumerator : TFhirContractRuleListEnumerator;

    //  Add a FhirContractRule to the end of the list.
    function Append : TFhirContractRule;

    // Add an already existing FhirContractRule to the end of the list.
    procedure AddItem(value : TFhirContractRule); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractRule) : Integer;

    // Insert FhirContractRule before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractRule;

    // Insert an existing FhirContractRule before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractRule);

    // Get the iIndexth FhirContractRule. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractRule);

    // The number of items in the collection
    function Item(index : Integer) : TFhirContractRule;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirContractRules[index : Integer] : TFhirContractRule read GetItemN write SetItemN; default;
  End;

  // A formal agreement between parties regarding the conduct of business, exchange of information or other matters.
  TFhirContract = class (TFhirDomainResource)
  protected
    FIdentifier : TFhirIdentifier;
    FIssued : TFhirDateTime;
    FApplies : TFhirPeriod;
    FsubjectList : TFhirReferenceList{TFhirReference};
    FauthorityList : TFhirReferenceList{TFhirOrganization};
    FdomainList : TFhirReferenceList{TFhirLocation};
    FType_ : TFhirCodeableConcept;
    FsubTypeList : TFhirCodeableConceptList;
    FactionList : TFhirCodeableConceptList;
    FactionReasonList : TFhirCodeableConceptList;
    FactorList : TFhirContractActorList;
    FvaluedItemList : TFhirContractValuedItemList;
    FsignerList : TFhirContractSignerList;
    FtermList : TFhirContractTermList;
    FBinding : TFhirType;
    FfriendlyList : TFhirContractFriendlyList;
    FlegalList : TFhirContractLegalList;
    FruleList : TFhirContractRuleList;
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetIssued(value : TFhirDateTime);
    Function GetIssuedST : TFslDateTime;
    Procedure SetIssuedST(value : TFslDateTime);
    Procedure SetApplies(value : TFhirPeriod);
    function GetSubjectList : TFhirReferenceList{TFhirReference};
    function GetHasSubjectList : Boolean;
    function GetAuthorityList : TFhirReferenceList{TFhirOrganization};
    function GetHasAuthorityList : Boolean;
    function GetDomainList : TFhirReferenceList{TFhirLocation};
    function GetHasDomainList : Boolean;
    Procedure SetType_(value : TFhirCodeableConcept);
    function GetSubTypeList : TFhirCodeableConceptList;
    function GetHasSubTypeList : Boolean;
    function GetActionList : TFhirCodeableConceptList;
    function GetHasActionList : Boolean;
    function GetActionReasonList : TFhirCodeableConceptList;
    function GetHasActionReasonList : Boolean;
    function GetActorList : TFhirContractActorList;
    function GetHasActorList : Boolean;
    function GetValuedItemList : TFhirContractValuedItemList;
    function GetHasValuedItemList : Boolean;
    function GetSignerList : TFhirContractSignerList;
    function GetHasSignerList : Boolean;
    function GetTermList : TFhirContractTermList;
    function GetHasTermList : Boolean;
    Procedure SetBinding(value : TFhirType);
    function GetFriendlyList : TFhirContractFriendlyList;
    function GetHasFriendlyList : Boolean;
    function GetLegalList : TFhirContractLegalList;
    function GetHasLegalList : Boolean;
    function GetRuleList : TFhirContractRuleList;
    function GetHasRuleList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContract; overload;
    function Clone : TFhirContract; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Unique identifier for this Contract. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Unique identifier for this Contract.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to When this  Contract was issued.
    property issued : TFslDateTime read GetIssuedST write SetIssuedST;
    // When this  Contract was issued.
    property issuedElement : TFhirDateTime read FIssued write SetIssued;

    // Typed access to Relevant time or time-period when this Contract is applicable. (defined for API consistency)
    property applies : TFhirPeriod read FApplies write SetApplies;
    // Relevant time or time-period when this Contract is applicable.
    property appliesElement : TFhirPeriod read FApplies write SetApplies;

    // Who and/or what this Contract is about: typically a Patient, Organization, or valued items such as goods and services.
    property subjectList : TFhirReferenceList{TFhirReference} read GetSubjectList;
    property hasSubjectList : boolean read GetHasSubjectList;

    // A formally or informally recognized grouping of people, principals, organizations, or jurisdictions formed for the purpose of achieving some form of collective action such as the promulgation, administration and enforcement of contracts and policies.
    property authorityList : TFhirReferenceList{TFhirOrganization} read GetAuthorityList;
    property hasAuthorityList : boolean read GetHasAuthorityList;

    // Recognized governance framework or system operating with a circumscribed scope in accordance with specified principles, policies, processes or procedures for managing rights, actions, or behaviors of parties or principals relative to resources.
    property domainList : TFhirReferenceList{TFhirLocation} read GetDomainList;
    property hasDomainList : boolean read GetHasDomainList;

    // Typed access to Type of Contract such as an insurance policy, real estate contract, a will, power of attorny, Privacy or Security policy , trust framework agreement, etc. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of Contract such as an insurance policy, real estate contract, a will, power of attorny, Privacy or Security policy , trust framework agreement, etc.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // More specific type or specialization of an overarching or more general contract such as auto insurance, home owner  insurance, prenupial agreement, Advanced-Directive, or privacy consent.
    property subTypeList : TFhirCodeableConceptList read GetSubTypeList;
    property hasSubTypeList : boolean read GetHasSubTypeList;

    // Action stipulated by this Contract.
    property actionList : TFhirCodeableConceptList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

    // Reason for action stipulated by this Contract.
    property actionReasonList : TFhirCodeableConceptList read GetActionReasonList;
    property hasActionReasonList : boolean read GetHasActionReasonList;

    // List of Contract actors.
    property actorList : TFhirContractActorList read GetActorList;
    property hasActorList : boolean read GetHasActorList;

    // Contract Valued Item List.
    property valuedItemList : TFhirContractValuedItemList read GetValuedItemList;
    property hasValuedItemList : boolean read GetHasValuedItemList;

    // Party signing this Contract.
    property signerList : TFhirContractSignerList read GetSignerList;
    property hasSignerList : boolean read GetHasSignerList;

    // One or more Contract Provisions, which may be related and conveyed as a group, and may contain nested groups.
    property termList : TFhirContractTermList read GetTermList;
    property hasTermList : boolean read GetHasTermList;

    // Typed access to Legally binding Contract: This is the signed and legally recognized representation of the Contract, which is considered the "source of truth" and which would be the basis for legal action related to enforcement of this Contract. (defined for API consistency)
    property binding : TFhirType read FBinding write SetBinding;
    // Legally binding Contract: This is the signed and legally recognized representation of the Contract, which is considered the "source of truth" and which would be the basis for legal action related to enforcement of this Contract.
    property bindingElement : TFhirType read FBinding write SetBinding;

    // The "patient friendly language" versionof the Contract in whole or in parts. "Patient friendly language" means the representation of the Contract and Contract Provisions in a manner that is readily accessible and understandable by a layperson in accordance with best practices for communication styles that ensure that those agreeing to or signing the Contract understand the roles, actions, obligations, responsibilities, and implication of the agreement.
    property friendlyList : TFhirContractFriendlyList read GetFriendlyList;
    property hasFriendlyList : boolean read GetHasFriendlyList;

    // List of Legal expressions or representations of this Contract.
    property legalList : TFhirContractLegalList read GetLegalList;
    property hasLegalList : boolean read GetHasLegalList;

    // List of Computable Policy Rule Language Representations of this Contract.
    property ruleList : TFhirContractRuleList read GetRuleList;
    property hasRuleList : boolean read GetHasRuleList;

  end;

  TFhirContractListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractList;
    function GetCurrent : TFhirContract;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirContractList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContract read GetCurrent;
  end;

  TFhirContractList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirContract;
    procedure SetItemN(index : Integer; value : TFhirContract);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirContractList; Overload;
    function Clone : TFhirContractList; Overload;
    function GetEnumerator : TFhirContractListEnumerator;

    //  Add a FhirContract to the end of the list.
    function Append : TFhirContract;

    // Add an already existing FhirContract to the end of the list.
    procedure AddItem(value : TFhirContract); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContract) : Integer;

    // Insert FhirContract before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContract;

    // Insert an existing FhirContract before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContract);

    // Get the iIndexth FhirContract. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContract);

    // The number of items in the collection
    function Item(index : Integer) : TFhirContract;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirContracts[index : Integer] : TFhirContract read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CONTRACT}

{$IFDEF FHIR_ELIGIBILITYREQUEST}

  // This resource provides the insurance eligibility details from the insurer regarding a specified coverage and optionally some class of service.
  TFhirEligibilityRequest = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FRuleset : TFhirCoding;
    FOriginalRuleset : TFhirCoding;
    FCreated : TFhirDateTime;
    FTarget : TFhirReference{TFhirOrganization};
    FProvider : TFhirReference{TFhirPractitioner};
    FOrganization : TFhirReference{TFhirOrganization};
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetRuleset(value : TFhirCoding);
    Procedure SetOriginalRuleset(value : TFhirCoding);
    Procedure SetCreated(value : TFhirDateTime);
    Function GetCreatedST : TFslDateTime;
    Procedure SetCreatedST(value : TFslDateTime);
    Procedure SetTarget(value : TFhirReference{TFhirOrganization});
    Procedure SetProvider(value : TFhirReference{TFhirPractitioner});
    Procedure SetOrganization(value : TFhirReference{TFhirOrganization});

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEligibilityRequest; overload;
    function Clone : TFhirEligibilityRequest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The Response business identifier.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The version of the style of resource contents. This should be mapped to the allowable profiles for this and supporting resources. (defined for API consistency)
    property ruleset : TFhirCoding read FRuleset write SetRuleset;
    // The version of the style of resource contents. This should be mapped to the allowable profiles for this and supporting resources.
    property rulesetElement : TFhirCoding read FRuleset write SetRuleset;

    // Typed access to The style (standard) and version of the original material which was converted into this resource. (defined for API consistency)
    property originalRuleset : TFhirCoding read FOriginalRuleset write SetOriginalRuleset;
    // The style (standard) and version of the original material which was converted into this resource.
    property originalRulesetElement : TFhirCoding read FOriginalRuleset write SetOriginalRuleset;

    // Typed access to The date when this resource was created.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date when this resource was created.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to The Insurer who is target  of the request. (defined for API consistency)
    property target : TFhirReference{TFhirOrganization} read FTarget write SetTarget;
    // The Insurer who is target  of the request.
    property targetElement : TFhirReference{TFhirOrganization} read FTarget write SetTarget;

    // Typed access to The practitioner who is responsible for the services rendered to the patient. (defined for API consistency)
    property provider : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;
    // The practitioner who is responsible for the services rendered to the patient.
    property providerElement : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;

    // Typed access to The organization which is responsible for the services rendered to the patient. (defined for API consistency)
    property organization : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;
    // The organization which is responsible for the services rendered to the patient.
    property organizationElement : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;

  end;

  TFhirEligibilityRequestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEligibilityRequestList;
    function GetCurrent : TFhirEligibilityRequest;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirEligibilityRequestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEligibilityRequest read GetCurrent;
  end;

  TFhirEligibilityRequestList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirEligibilityRequest;
    procedure SetItemN(index : Integer; value : TFhirEligibilityRequest);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirEligibilityRequestList; Overload;
    function Clone : TFhirEligibilityRequestList; Overload;
    function GetEnumerator : TFhirEligibilityRequestListEnumerator;

    //  Add a FhirEligibilityRequest to the end of the list.
    function Append : TFhirEligibilityRequest;

    // Add an already existing FhirEligibilityRequest to the end of the list.
    procedure AddItem(value : TFhirEligibilityRequest); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEligibilityRequest) : Integer;

    // Insert FhirEligibilityRequest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEligibilityRequest;

    // Insert an existing FhirEligibilityRequest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEligibilityRequest);

    // Get the iIndexth FhirEligibilityRequest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEligibilityRequest);

    // The number of items in the collection
    function Item(index : Integer) : TFhirEligibilityRequest;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirEligibilityRequests[index : Integer] : TFhirEligibilityRequest read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ELIGIBILITYREQUEST}

{$IFDEF FHIR_ELIGIBILITYRESPONSE}

  // This resource provides eligibility and plan details from the processing of an Eligibility resource.
  TFhirEligibilityResponse = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FRequest : TFhirReference{TFhirEligibilityRequest};
    FOutcome : TFhirEnum;
    FDisposition : TFhirString;
    FRuleset : TFhirCoding;
    FOriginalRuleset : TFhirCoding;
    FCreated : TFhirDateTime;
    FOrganization : TFhirReference{TFhirOrganization};
    FRequestProvider : TFhirReference{TFhirPractitioner};
    FRequestOrganization : TFhirReference{TFhirOrganization};
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetRequest(value : TFhirReference{TFhirEligibilityRequest});
    Procedure SetOutcome(value : TFhirEnum);
    Function GetOutcomeST : TFhirRemittanceOutcomeEnum;
    Procedure SetOutcomeST(value : TFhirRemittanceOutcomeEnum);
    Procedure SetDisposition(value : TFhirString);
    Function GetDispositionST : String;
    Procedure SetDispositionST(value : String);
    Procedure SetRuleset(value : TFhirCoding);
    Procedure SetOriginalRuleset(value : TFhirCoding);
    Procedure SetCreated(value : TFhirDateTime);
    Function GetCreatedST : TFslDateTime;
    Procedure SetCreatedST(value : TFslDateTime);
    Procedure SetOrganization(value : TFhirReference{TFhirOrganization});
    Procedure SetRequestProvider(value : TFhirReference{TFhirPractitioner});
    Procedure SetRequestOrganization(value : TFhirReference{TFhirOrganization});

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEligibilityResponse; overload;
    function Clone : TFhirEligibilityResponse; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The Response business identifier.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Original request resource reference. (defined for API consistency)
    property request : TFhirReference{TFhirEligibilityRequest} read FRequest write SetRequest;
    // Original request resource reference.
    property requestElement : TFhirReference{TFhirEligibilityRequest} read FRequest write SetRequest;

    // Transaction status: error, complete.
    property outcome : TFhirRemittanceOutcomeEnum read GetOutcomeST write SetOutcomeST;
    property outcomeElement : TFhirEnum read FOutcome write SetOutcome;

    // Typed access to A description of the status of the adjudication.
    property disposition : String read GetDispositionST write SetDispositionST;
    // A description of the status of the adjudication.
    property dispositionElement : TFhirString read FDisposition write SetDisposition;

    // Typed access to The version of the style of resource contents. This should be mapped to the allowable profiles for this and supporting resources. (defined for API consistency)
    property ruleset : TFhirCoding read FRuleset write SetRuleset;
    // The version of the style of resource contents. This should be mapped to the allowable profiles for this and supporting resources.
    property rulesetElement : TFhirCoding read FRuleset write SetRuleset;

    // Typed access to The style (standard) and version of the original material which was converted into this resource. (defined for API consistency)
    property originalRuleset : TFhirCoding read FOriginalRuleset write SetOriginalRuleset;
    // The style (standard) and version of the original material which was converted into this resource.
    property originalRulesetElement : TFhirCoding read FOriginalRuleset write SetOriginalRuleset;

    // Typed access to The date when the enclosed suite of services were performed or completed.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date when the enclosed suite of services were performed or completed.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to The Insurer who produced this adjudicated response. (defined for API consistency)
    property organization : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;
    // The Insurer who produced this adjudicated response.
    property organizationElement : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;

    // Typed access to The practitioner who is responsible for the services rendered to the patient. (defined for API consistency)
    property requestProvider : TFhirReference{TFhirPractitioner} read FRequestProvider write SetRequestProvider;
    // The practitioner who is responsible for the services rendered to the patient.
    property requestProviderElement : TFhirReference{TFhirPractitioner} read FRequestProvider write SetRequestProvider;

    // Typed access to The organization which is responsible for the services rendered to the patient. (defined for API consistency)
    property requestOrganization : TFhirReference{TFhirOrganization} read FRequestOrganization write SetRequestOrganization;
    // The organization which is responsible for the services rendered to the patient.
    property requestOrganizationElement : TFhirReference{TFhirOrganization} read FRequestOrganization write SetRequestOrganization;

  end;

  TFhirEligibilityResponseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEligibilityResponseList;
    function GetCurrent : TFhirEligibilityResponse;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirEligibilityResponseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEligibilityResponse read GetCurrent;
  end;

  TFhirEligibilityResponseList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirEligibilityResponse;
    procedure SetItemN(index : Integer; value : TFhirEligibilityResponse);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirEligibilityResponseList; Overload;
    function Clone : TFhirEligibilityResponseList; Overload;
    function GetEnumerator : TFhirEligibilityResponseListEnumerator;

    //  Add a FhirEligibilityResponse to the end of the list.
    function Append : TFhirEligibilityResponse;

    // Add an already existing FhirEligibilityResponse to the end of the list.
    procedure AddItem(value : TFhirEligibilityResponse); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEligibilityResponse) : Integer;

    // Insert FhirEligibilityResponse before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEligibilityResponse;

    // Insert an existing FhirEligibilityResponse before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEligibilityResponse);

    // Get the iIndexth FhirEligibilityResponse. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEligibilityResponse);

    // The number of items in the collection
    function Item(index : Integer) : TFhirEligibilityResponse;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirEligibilityResponses[index : Integer] : TFhirEligibilityResponse read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ELIGIBILITYRESPONSE}

{$IFDEF FHIR_ENROLLMENTREQUEST}

  // This resource provides the insurance enrollment details to the insurer regarding a specified coverage.
  TFhirEnrollmentRequest = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FRuleset : TFhirCoding;
    FOriginalRuleset : TFhirCoding;
    FCreated : TFhirDateTime;
    FTarget : TFhirReference{TFhirOrganization};
    FProvider : TFhirReference{TFhirPractitioner};
    FOrganization : TFhirReference{TFhirOrganization};
    FSubject : TFhirReference{TFhirPatient};
    FCoverage : TFhirReference{TFhirCoverage};
    FRelationship : TFhirCoding;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetRuleset(value : TFhirCoding);
    Procedure SetOriginalRuleset(value : TFhirCoding);
    Procedure SetCreated(value : TFhirDateTime);
    Function GetCreatedST : TFslDateTime;
    Procedure SetCreatedST(value : TFslDateTime);
    Procedure SetTarget(value : TFhirReference{TFhirOrganization});
    Procedure SetProvider(value : TFhirReference{TFhirPractitioner});
    Procedure SetOrganization(value : TFhirReference{TFhirOrganization});
    Procedure SetSubject(value : TFhirReference{TFhirPatient});
    Procedure SetCoverage(value : TFhirReference{TFhirCoverage});
    Procedure SetRelationship(value : TFhirCoding);

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEnrollmentRequest; overload;
    function Clone : TFhirEnrollmentRequest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The Response business identifier.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The version of the style of resource contents. This should be mapped to the allowable profiles for this and supporting resources. (defined for API consistency)
    property ruleset : TFhirCoding read FRuleset write SetRuleset;
    // The version of the style of resource contents. This should be mapped to the allowable profiles for this and supporting resources.
    property rulesetElement : TFhirCoding read FRuleset write SetRuleset;

    // Typed access to The style (standard) and version of the original material which was converted into this resource. (defined for API consistency)
    property originalRuleset : TFhirCoding read FOriginalRuleset write SetOriginalRuleset;
    // The style (standard) and version of the original material which was converted into this resource.
    property originalRulesetElement : TFhirCoding read FOriginalRuleset write SetOriginalRuleset;

    // Typed access to The date when this resource was created.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date when this resource was created.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to The Insurer who is target  of the request. (defined for API consistency)
    property target : TFhirReference{TFhirOrganization} read FTarget write SetTarget;
    // The Insurer who is target  of the request.
    property targetElement : TFhirReference{TFhirOrganization} read FTarget write SetTarget;

    // Typed access to The practitioner who is responsible for the services rendered to the patient. (defined for API consistency)
    property provider : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;
    // The practitioner who is responsible for the services rendered to the patient.
    property providerElement : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;

    // Typed access to The organization which is responsible for the services rendered to the patient. (defined for API consistency)
    property organization : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;
    // The organization which is responsible for the services rendered to the patient.
    property organizationElement : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;

    // Typed access to Patient Resource. (defined for API consistency)
    property subject : TFhirReference{TFhirPatient} read FSubject write SetSubject;
    // Patient Resource.
    property subjectElement : TFhirReference{TFhirPatient} read FSubject write SetSubject;

    // Typed access to Reference to the program or plan identification, underwriter or payor. (defined for API consistency)
    property coverage : TFhirReference{TFhirCoverage} read FCoverage write SetCoverage;
    // Reference to the program or plan identification, underwriter or payor.
    property coverageElement : TFhirReference{TFhirCoverage} read FCoverage write SetCoverage;

    // Typed access to The relationship of the patient to the subscriber. (defined for API consistency)
    property relationship : TFhirCoding read FRelationship write SetRelationship;
    // The relationship of the patient to the subscriber.
    property relationshipElement : TFhirCoding read FRelationship write SetRelationship;

  end;

  TFhirEnrollmentRequestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEnrollmentRequestList;
    function GetCurrent : TFhirEnrollmentRequest;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirEnrollmentRequestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEnrollmentRequest read GetCurrent;
  end;

  TFhirEnrollmentRequestList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirEnrollmentRequest;
    procedure SetItemN(index : Integer; value : TFhirEnrollmentRequest);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirEnrollmentRequestList; Overload;
    function Clone : TFhirEnrollmentRequestList; Overload;
    function GetEnumerator : TFhirEnrollmentRequestListEnumerator;

    //  Add a FhirEnrollmentRequest to the end of the list.
    function Append : TFhirEnrollmentRequest;

    // Add an already existing FhirEnrollmentRequest to the end of the list.
    procedure AddItem(value : TFhirEnrollmentRequest); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEnrollmentRequest) : Integer;

    // Insert FhirEnrollmentRequest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEnrollmentRequest;

    // Insert an existing FhirEnrollmentRequest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEnrollmentRequest);

    // Get the iIndexth FhirEnrollmentRequest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEnrollmentRequest);

    // The number of items in the collection
    function Item(index : Integer) : TFhirEnrollmentRequest;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirEnrollmentRequests[index : Integer] : TFhirEnrollmentRequest read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ENROLLMENTREQUEST}

{$IFDEF FHIR_ENROLLMENTRESPONSE}

  // This resource provides enrollment and plan details from the processing of an Enrollment resource.
  TFhirEnrollmentResponse = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FRequest : TFhirReference{TFhirEnrollmentRequest};
    FOutcome : TFhirEnum;
    FDisposition : TFhirString;
    FRuleset : TFhirCoding;
    FOriginalRuleset : TFhirCoding;
    FCreated : TFhirDateTime;
    FOrganization : TFhirReference{TFhirOrganization};
    FRequestProvider : TFhirReference{TFhirPractitioner};
    FRequestOrganization : TFhirReference{TFhirOrganization};
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetRequest(value : TFhirReference{TFhirEnrollmentRequest});
    Procedure SetOutcome(value : TFhirEnum);
    Function GetOutcomeST : TFhirRemittanceOutcomeEnum;
    Procedure SetOutcomeST(value : TFhirRemittanceOutcomeEnum);
    Procedure SetDisposition(value : TFhirString);
    Function GetDispositionST : String;
    Procedure SetDispositionST(value : String);
    Procedure SetRuleset(value : TFhirCoding);
    Procedure SetOriginalRuleset(value : TFhirCoding);
    Procedure SetCreated(value : TFhirDateTime);
    Function GetCreatedST : TFslDateTime;
    Procedure SetCreatedST(value : TFslDateTime);
    Procedure SetOrganization(value : TFhirReference{TFhirOrganization});
    Procedure SetRequestProvider(value : TFhirReference{TFhirPractitioner});
    Procedure SetRequestOrganization(value : TFhirReference{TFhirOrganization});

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEnrollmentResponse; overload;
    function Clone : TFhirEnrollmentResponse; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The Response business identifier.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Original request resource reference. (defined for API consistency)
    property request : TFhirReference{TFhirEnrollmentRequest} read FRequest write SetRequest;
    // Original request resource reference.
    property requestElement : TFhirReference{TFhirEnrollmentRequest} read FRequest write SetRequest;

    // Transaction status: error, complete.
    property outcome : TFhirRemittanceOutcomeEnum read GetOutcomeST write SetOutcomeST;
    property outcomeElement : TFhirEnum read FOutcome write SetOutcome;

    // Typed access to A description of the status of the adjudication.
    property disposition : String read GetDispositionST write SetDispositionST;
    // A description of the status of the adjudication.
    property dispositionElement : TFhirString read FDisposition write SetDisposition;

    // Typed access to The version of the style of resource contents. This should be mapped to the allowable profiles for this and supporting resources. (defined for API consistency)
    property ruleset : TFhirCoding read FRuleset write SetRuleset;
    // The version of the style of resource contents. This should be mapped to the allowable profiles for this and supporting resources.
    property rulesetElement : TFhirCoding read FRuleset write SetRuleset;

    // Typed access to The style (standard) and version of the original material which was converted into this resource. (defined for API consistency)
    property originalRuleset : TFhirCoding read FOriginalRuleset write SetOriginalRuleset;
    // The style (standard) and version of the original material which was converted into this resource.
    property originalRulesetElement : TFhirCoding read FOriginalRuleset write SetOriginalRuleset;

    // Typed access to The date when the enclosed suite of services were performed or completed.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date when the enclosed suite of services were performed or completed.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to The Insurer who produced this adjudicated response. (defined for API consistency)
    property organization : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;
    // The Insurer who produced this adjudicated response.
    property organizationElement : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;

    // Typed access to The practitioner who is responsible for the services rendered to the patient. (defined for API consistency)
    property requestProvider : TFhirReference{TFhirPractitioner} read FRequestProvider write SetRequestProvider;
    // The practitioner who is responsible for the services rendered to the patient.
    property requestProviderElement : TFhirReference{TFhirPractitioner} read FRequestProvider write SetRequestProvider;

    // Typed access to The organization which is responsible for the services rendered to the patient. (defined for API consistency)
    property requestOrganization : TFhirReference{TFhirOrganization} read FRequestOrganization write SetRequestOrganization;
    // The organization which is responsible for the services rendered to the patient.
    property requestOrganizationElement : TFhirReference{TFhirOrganization} read FRequestOrganization write SetRequestOrganization;

  end;

  TFhirEnrollmentResponseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEnrollmentResponseList;
    function GetCurrent : TFhirEnrollmentResponse;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirEnrollmentResponseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEnrollmentResponse read GetCurrent;
  end;

  TFhirEnrollmentResponseList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirEnrollmentResponse;
    procedure SetItemN(index : Integer; value : TFhirEnrollmentResponse);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirEnrollmentResponseList; Overload;
    function Clone : TFhirEnrollmentResponseList; Overload;
    function GetEnumerator : TFhirEnrollmentResponseListEnumerator;

    //  Add a FhirEnrollmentResponse to the end of the list.
    function Append : TFhirEnrollmentResponse;

    // Add an already existing FhirEnrollmentResponse to the end of the list.
    procedure AddItem(value : TFhirEnrollmentResponse); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEnrollmentResponse) : Integer;

    // Insert FhirEnrollmentResponse before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEnrollmentResponse;

    // Insert an existing FhirEnrollmentResponse before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEnrollmentResponse);

    // Get the iIndexth FhirEnrollmentResponse. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEnrollmentResponse);

    // The number of items in the collection
    function Item(index : Integer) : TFhirEnrollmentResponse;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirEnrollmentResponses[index : Integer] : TFhirEnrollmentResponse read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ENROLLMENTRESPONSE}

{$IFDEF FHIR_EXPLANATIONOFBENEFIT}

  // This resource provides: the claim details; adjudication details from the processing of a Claim; and optionally account balance information, for informing the subscriber of the benefits provided.
  TFhirExplanationOfBenefit = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FRequest : TFhirReference{TFhirClaim};
    FOutcome : TFhirEnum;
    FDisposition : TFhirString;
    FRuleset : TFhirCoding;
    FOriginalRuleset : TFhirCoding;
    FCreated : TFhirDateTime;
    FOrganization : TFhirReference{TFhirOrganization};
    FRequestProvider : TFhirReference{TFhirPractitioner};
    FRequestOrganization : TFhirReference{TFhirOrganization};
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetRequest(value : TFhirReference{TFhirClaim});
    Procedure SetOutcome(value : TFhirEnum);
    Function GetOutcomeST : TFhirRemittanceOutcomeEnum;
    Procedure SetOutcomeST(value : TFhirRemittanceOutcomeEnum);
    Procedure SetDisposition(value : TFhirString);
    Function GetDispositionST : String;
    Procedure SetDispositionST(value : String);
    Procedure SetRuleset(value : TFhirCoding);
    Procedure SetOriginalRuleset(value : TFhirCoding);
    Procedure SetCreated(value : TFhirDateTime);
    Function GetCreatedST : TFslDateTime;
    Procedure SetCreatedST(value : TFslDateTime);
    Procedure SetOrganization(value : TFhirReference{TFhirOrganization});
    Procedure SetRequestProvider(value : TFhirReference{TFhirPractitioner});
    Procedure SetRequestOrganization(value : TFhirReference{TFhirOrganization});

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefit; overload;
    function Clone : TFhirExplanationOfBenefit; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The Response business identifier.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Original request resource reference. (defined for API consistency)
    property request : TFhirReference{TFhirClaim} read FRequest write SetRequest;
    // Original request resource reference.
    property requestElement : TFhirReference{TFhirClaim} read FRequest write SetRequest;

    // Transaction status: error, complete.
    property outcome : TFhirRemittanceOutcomeEnum read GetOutcomeST write SetOutcomeST;
    property outcomeElement : TFhirEnum read FOutcome write SetOutcome;

    // Typed access to A description of the status of the adjudication.
    property disposition : String read GetDispositionST write SetDispositionST;
    // A description of the status of the adjudication.
    property dispositionElement : TFhirString read FDisposition write SetDisposition;

    // Typed access to The version of the style of resource contents. This should be mapped to the allowable profiles for this and supporting resources. (defined for API consistency)
    property ruleset : TFhirCoding read FRuleset write SetRuleset;
    // The version of the style of resource contents. This should be mapped to the allowable profiles for this and supporting resources.
    property rulesetElement : TFhirCoding read FRuleset write SetRuleset;

    // Typed access to The style (standard) and version of the original material which was converted into this resource. (defined for API consistency)
    property originalRuleset : TFhirCoding read FOriginalRuleset write SetOriginalRuleset;
    // The style (standard) and version of the original material which was converted into this resource.
    property originalRulesetElement : TFhirCoding read FOriginalRuleset write SetOriginalRuleset;

    // Typed access to The date when the enclosed suite of services were performed or completed.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date when the enclosed suite of services were performed or completed.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to The Insurer who produced this adjudicated response. (defined for API consistency)
    property organization : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;
    // The Insurer who produced this adjudicated response.
    property organizationElement : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;

    // Typed access to The practitioner who is responsible for the services rendered to the patient. (defined for API consistency)
    property requestProvider : TFhirReference{TFhirPractitioner} read FRequestProvider write SetRequestProvider;
    // The practitioner who is responsible for the services rendered to the patient.
    property requestProviderElement : TFhirReference{TFhirPractitioner} read FRequestProvider write SetRequestProvider;

    // Typed access to The organization which is responsible for the services rendered to the patient. (defined for API consistency)
    property requestOrganization : TFhirReference{TFhirOrganization} read FRequestOrganization write SetRequestOrganization;
    // The organization which is responsible for the services rendered to the patient.
    property requestOrganizationElement : TFhirReference{TFhirOrganization} read FRequestOrganization write SetRequestOrganization;

  end;

  TFhirExplanationOfBenefitListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitList;
    function GetCurrent : TFhirExplanationOfBenefit;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefit read GetCurrent;
  end;

  TFhirExplanationOfBenefitList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExplanationOfBenefit;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefit);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExplanationOfBenefitList; Overload;
    function Clone : TFhirExplanationOfBenefitList; Overload;
    function GetEnumerator : TFhirExplanationOfBenefitListEnumerator;

    //  Add a FhirExplanationOfBenefit to the end of the list.
    function Append : TFhirExplanationOfBenefit;

    // Add an already existing FhirExplanationOfBenefit to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefit); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefit) : Integer;

    // Insert FhirExplanationOfBenefit before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefit;

    // Insert an existing FhirExplanationOfBenefit before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefit);

    // Get the iIndexth FhirExplanationOfBenefit. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefit);

    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefit;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirExplanationOfBenefits[index : Integer] : TFhirExplanationOfBenefit read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_EXPLANATIONOFBENEFIT}

{$IFDEF FHIR_LIST}

  // Entries in this list.
  TFhirListEntry = class (TFhirBackboneElement)
  protected
    FFlag : TFhirCodeableConcept;
    FDeleted : TFhirBoolean;
    FDate : TFhirDateTime;
    FItem : TFhirReference{TFhirReference};
    Procedure SetFlag(value : TFhirCodeableConcept);
    Procedure SetDeleted(value : TFhirBoolean);
    Function GetDeletedST : Boolean;
    Procedure SetDeletedST(value : Boolean);
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetItem(value : TFhirReference{TFhirReference});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirListEntry; overload;
    function Clone : TFhirListEntry; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The flag allows the system constructing the list to indicate the role and significance of the item in the list. (defined for API consistency)
    property flag : TFhirCodeableConcept read FFlag write SetFlag;
    // The flag allows the system constructing the list to indicate the role and significance of the item in the list.
    property flagElement : TFhirCodeableConcept read FFlag write SetFlag;

    // Typed access to True if this item is marked as deleted in the list.
    property deleted : Boolean read GetDeletedST write SetDeletedST;
    // True if this item is marked as deleted in the list.
    property deletedElement : TFhirBoolean read FDeleted write SetDeleted;

    // Typed access to When this item was added to the list.
    property date : TFslDateTime read GetDateST write SetDateST;
    // When this item was added to the list.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to A reference to the actual resource from which data was derived. (defined for API consistency)
    property item : TFhirReference{TFhirReference} read FItem write SetItem;
    // A reference to the actual resource from which data was derived.
    property itemElement : TFhirReference{TFhirReference} read FItem write SetItem;

  end;

  TFhirListEntryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirListEntryList;
    function GetCurrent : TFhirListEntry;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirListEntryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirListEntry read GetCurrent;
  end;

  TFhirListEntryList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirListEntry;
    procedure SetItemN(index : Integer; value : TFhirListEntry);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirListEntryList; Overload;
    function Clone : TFhirListEntryList; Overload;
    function GetEnumerator : TFhirListEntryListEnumerator;

    //  Add a FhirListEntry to the end of the list.
    function Append : TFhirListEntry;

    // Add an already existing FhirListEntry to the end of the list.
    procedure AddItem(value : TFhirListEntry); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirListEntry) : Integer;

    // Insert FhirListEntry before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirListEntry;

    // Insert an existing FhirListEntry before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirListEntry);

    // Get the iIndexth FhirListEntry. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirListEntry);

    // The number of items in the collection
    function Item(index : Integer) : TFhirListEntry;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirListEntries[index : Integer] : TFhirListEntry read GetItemN write SetItemN; default;
  End;

  // A set of information summarized from a list of other resources.
  TFhirList = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FTitle : TFhirString;
    FCode : TFhirCodeableConcept;
    FSubject : TFhirReference{Resource};
    FSource : TFhirReference{Resource};
    FEncounter : TFhirReference{TFhirEncounter};
    FStatus : TFhirEnum;
    FDate : TFhirDateTime;
    FOrderedBy : TFhirCodeableConcept;
    FMode : TFhirEnum;
    FNote : TFhirString;
    FentryList : TFhirListEntryList;
    FEmptyReason : TFhirCodeableConcept;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetTitle(value : TFhirString);
    Function GetTitleST : String;
    Procedure SetTitleST(value : String);
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetSubject(value : TFhirReference{Resource});
    Procedure SetSource(value : TFhirReference{Resource});
    Procedure SetEncounter(value : TFhirReference{TFhirEncounter});
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirListStatusEnum;
    Procedure SetStatusST(value : TFhirListStatusEnum);
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetOrderedBy(value : TFhirCodeableConcept);
    Procedure SetMode(value : TFhirEnum);
    Function GetModeST : TFhirListModeEnum;
    Procedure SetModeST(value : TFhirListModeEnum);
    Procedure SetNote(value : TFhirString);
    Function GetNoteST : String;
    Procedure SetNoteST(value : String);
    function GetEntryList : TFhirListEntryList;
    function GetHasEntryList : Boolean;
    Procedure SetEmptyReason(value : TFhirCodeableConcept);

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirList; overload;
    function Clone : TFhirList; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifier for the List assigned for business purposes outside the context of FHIR.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to A label for the list assigned by the author.
    property title : String read GetTitleST write SetTitleST;
    // A label for the list assigned by the author.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to This code defines the purpose of the list - why it was created. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // This code defines the purpose of the list - why it was created.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The common subject (or patient) of the resources that are in the list, if there is one. (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // The common subject (or patient) of the resources that are in the list, if there is one.
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // Typed access to The entity responsible for deciding what the contents of the list were. Where the list was created by a human, this is the same as the author of the list. (defined for API consistency)
    property source : TFhirReference{Resource} read FSource write SetSource;
    // The entity responsible for deciding what the contents of the list were. Where the list was created by a human, this is the same as the author of the list.
    property sourceElement : TFhirReference{Resource} read FSource write SetSource;

    // Typed access to The encounter that is the context in which this list was created. (defined for API consistency)
    property encounter : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;
    // The encounter that is the context in which this list was created.
    property encounterElement : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;

    // Indicates the current state of this list.
    property status : TFhirListStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The date that the list was prepared.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date that the list was prepared.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to What order applies to the items in the list. (defined for API consistency)
    property orderedBy : TFhirCodeableConcept read FOrderedBy write SetOrderedBy;
    // What order applies to the items in the list.
    property orderedByElement : TFhirCodeableConcept read FOrderedBy write SetOrderedBy;

    // How this list was prepared - whether it is a working list that is suitable for being maintained on an ongoing basis, or if it represents a snapshot of a list of items from another source, or whether it is a prepared list where items may be marked as added, modified or deleted.
    property mode : TFhirListModeEnum read GetModeST write SetModeST;
    property modeElement : TFhirEnum read FMode write SetMode;

    // Typed access to Comments that apply to the overall list.
    property note : String read GetNoteST write SetNoteST;
    // Comments that apply to the overall list.
    property noteElement : TFhirString read FNote write SetNote;

    // Entries in this list.
    property entryList : TFhirListEntryList read GetEntryList;
    property hasEntryList : boolean read GetHasEntryList;

    // Typed access to If the list is empty, why the list is empty. (defined for API consistency)
    property emptyReason : TFhirCodeableConcept read FEmptyReason write SetEmptyReason;
    // If the list is empty, why the list is empty.
    property emptyReasonElement : TFhirCodeableConcept read FEmptyReason write SetEmptyReason;

  end;

  TFhirListListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirListList;
    function GetCurrent : TFhirList;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirListList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirList read GetCurrent;
  end;

  TFhirListList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirList;
    procedure SetItemN(index : Integer; value : TFhirList);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirListList; Overload;
    function Clone : TFhirListList; Overload;
    function GetEnumerator : TFhirListListEnumerator;

    //  Add a FhirList to the end of the list.
    function Append : TFhirList;

    // Add an already existing FhirList to the end of the list.
    procedure AddItem(value : TFhirList); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirList) : Integer;

    // Insert FhirList before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirList;

    // Insert an existing FhirList before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirList);

    // Get the iIndexth FhirList. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirList);

    // The number of items in the collection
    function Item(index : Integer) : TFhirList;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirLists[index : Integer] : TFhirList read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_LIST}

{$IFDEF FHIR_MEDICATION}

  // Information that only applies to products (not packages).
  TFhirMedicationProduct = class (TFhirBackboneElement)
  protected
    FForm : TFhirCodeableConcept;
    FingredientList : TFhirMedicationProductIngredientList;
    FbatchList : TFhirMedicationProductBatchList;
    Procedure SetForm(value : TFhirCodeableConcept);
    function GetIngredientList : TFhirMedicationProductIngredientList;
    function GetHasIngredientList : Boolean;
    function GetBatchList : TFhirMedicationProductBatchList;
    function GetHasBatchList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationProduct; overload;
    function Clone : TFhirMedicationProduct; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Describes the form of the item.  Powder; tablets; carton. (defined for API consistency)
    property form : TFhirCodeableConcept read FForm write SetForm;
    // Describes the form of the item.  Powder; tablets; carton.
    property formElement : TFhirCodeableConcept read FForm write SetForm;

    // Identifies a particular constituent of interest in the product.
    property ingredientList : TFhirMedicationProductIngredientList read GetIngredientList;
    property hasIngredientList : boolean read GetHasIngredientList;

    // Information about a group of medication produced or packaged from one production run.
    property batchList : TFhirMedicationProductBatchList read GetBatchList;
    property hasBatchList : boolean read GetHasBatchList;

  end;

  TFhirMedicationProductListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationProductList;
    function GetCurrent : TFhirMedicationProduct;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationProductList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationProduct read GetCurrent;
  end;

  TFhirMedicationProductList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationProduct;
    procedure SetItemN(index : Integer; value : TFhirMedicationProduct);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationProductList; Overload;
    function Clone : TFhirMedicationProductList; Overload;
    function GetEnumerator : TFhirMedicationProductListEnumerator;

    //  Add a FhirMedicationProduct to the end of the list.
    function Append : TFhirMedicationProduct;

    // Add an already existing FhirMedicationProduct to the end of the list.
    procedure AddItem(value : TFhirMedicationProduct); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationProduct) : Integer;

    // Insert FhirMedicationProduct before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationProduct;

    // Insert an existing FhirMedicationProduct before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationProduct);

    // Get the iIndexth FhirMedicationProduct. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationProduct);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationProduct;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMedicationProducts[index : Integer] : TFhirMedicationProduct read GetItemN write SetItemN; default;
  End;

  // Identifies a particular constituent of interest in the product.
  TFhirMedicationProductIngredient = class (TFhirBackboneElement)
  protected
    FItem : TFhirReference{Resource};
    FAmount : TFhirRatio;
    Procedure SetItem(value : TFhirReference{Resource});
    Procedure SetAmount(value : TFhirRatio);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationProductIngredient; overload;
    function Clone : TFhirMedicationProductIngredient; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The actual ingredient - either a substance (simple ingredient) or another medication. (defined for API consistency)
    property item : TFhirReference{Resource} read FItem write SetItem;
    // The actual ingredient - either a substance (simple ingredient) or another medication.
    property itemElement : TFhirReference{Resource} read FItem write SetItem;

    // Typed access to Specifies how many (or how much) of the items there are in this Medication.  For example, 250 mg per tablet. (defined for API consistency)
    property amount : TFhirRatio read FAmount write SetAmount;
    // Specifies how many (or how much) of the items there are in this Medication.  For example, 250 mg per tablet.
    property amountElement : TFhirRatio read FAmount write SetAmount;

  end;

  TFhirMedicationProductIngredientListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationProductIngredientList;
    function GetCurrent : TFhirMedicationProductIngredient;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationProductIngredientList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationProductIngredient read GetCurrent;
  end;

  TFhirMedicationProductIngredientList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationProductIngredient;
    procedure SetItemN(index : Integer; value : TFhirMedicationProductIngredient);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationProductIngredientList; Overload;
    function Clone : TFhirMedicationProductIngredientList; Overload;
    function GetEnumerator : TFhirMedicationProductIngredientListEnumerator;

    //  Add a FhirMedicationProductIngredient to the end of the list.
    function Append : TFhirMedicationProductIngredient;

    // Add an already existing FhirMedicationProductIngredient to the end of the list.
    procedure AddItem(value : TFhirMedicationProductIngredient); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationProductIngredient) : Integer;

    // Insert FhirMedicationProductIngredient before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationProductIngredient;

    // Insert an existing FhirMedicationProductIngredient before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationProductIngredient);

    // Get the iIndexth FhirMedicationProductIngredient. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationProductIngredient);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationProductIngredient;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMedicationProductIngredients[index : Integer] : TFhirMedicationProductIngredient read GetItemN write SetItemN; default;
  End;

  // Information about a group of medication produced or packaged from one production run.
  TFhirMedicationProductBatch = class (TFhirBackboneElement)
  protected
    FLotNumber : TFhirString;
    FExpirationDate : TFhirDateTime;
    Procedure SetLotNumber(value : TFhirString);
    Function GetLotNumberST : String;
    Procedure SetLotNumberST(value : String);
    Procedure SetExpirationDate(value : TFhirDateTime);
    Function GetExpirationDateST : TFslDateTime;
    Procedure SetExpirationDateST(value : TFslDateTime);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationProductBatch; overload;
    function Clone : TFhirMedicationProductBatch; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The assigned lot number of a batch of the specified product.
    property lotNumber : String read GetLotNumberST write SetLotNumberST;
    // The assigned lot number of a batch of the specified product.
    property lotNumberElement : TFhirString read FLotNumber write SetLotNumber;

    // Typed access to When this specific batch of product will expire.
    property expirationDate : TFslDateTime read GetExpirationDateST write SetExpirationDateST;
    // When this specific batch of product will expire.
    property expirationDateElement : TFhirDateTime read FExpirationDate write SetExpirationDate;

  end;

  TFhirMedicationProductBatchListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationProductBatchList;
    function GetCurrent : TFhirMedicationProductBatch;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationProductBatchList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationProductBatch read GetCurrent;
  end;

  TFhirMedicationProductBatchList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationProductBatch;
    procedure SetItemN(index : Integer; value : TFhirMedicationProductBatch);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationProductBatchList; Overload;
    function Clone : TFhirMedicationProductBatchList; Overload;
    function GetEnumerator : TFhirMedicationProductBatchListEnumerator;

    //  Add a FhirMedicationProductBatch to the end of the list.
    function Append : TFhirMedicationProductBatch;

    // Add an already existing FhirMedicationProductBatch to the end of the list.
    procedure AddItem(value : TFhirMedicationProductBatch); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationProductBatch) : Integer;

    // Insert FhirMedicationProductBatch before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationProductBatch;

    // Insert an existing FhirMedicationProductBatch before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationProductBatch);

    // Get the iIndexth FhirMedicationProductBatch. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationProductBatch);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationProductBatch;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMedicationProductBatches[index : Integer] : TFhirMedicationProductBatch read GetItemN write SetItemN; default;
  End;

  // Information that only applies to packages (not products).
  TFhirMedicationPackage = class (TFhirBackboneElement)
  protected
    FContainer : TFhirCodeableConcept;
    FcontentList : TFhirMedicationPackageContentList;
    Procedure SetContainer(value : TFhirCodeableConcept);
    function GetContentList : TFhirMedicationPackageContentList;
    function GetHasContentList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationPackage; overload;
    function Clone : TFhirMedicationPackage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The kind of container that this package comes as. (defined for API consistency)
    property container : TFhirCodeableConcept read FContainer write SetContainer;
    // The kind of container that this package comes as.
    property containerElement : TFhirCodeableConcept read FContainer write SetContainer;

    // A set of components that go to make up the described item.
    property contentList : TFhirMedicationPackageContentList read GetContentList;
    property hasContentList : boolean read GetHasContentList;

  end;

  TFhirMedicationPackageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationPackageList;
    function GetCurrent : TFhirMedicationPackage;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationPackageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationPackage read GetCurrent;
  end;

  TFhirMedicationPackageList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationPackage;
    procedure SetItemN(index : Integer; value : TFhirMedicationPackage);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationPackageList; Overload;
    function Clone : TFhirMedicationPackageList; Overload;
    function GetEnumerator : TFhirMedicationPackageListEnumerator;

    //  Add a FhirMedicationPackage to the end of the list.
    function Append : TFhirMedicationPackage;

    // Add an already existing FhirMedicationPackage to the end of the list.
    procedure AddItem(value : TFhirMedicationPackage); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationPackage) : Integer;

    // Insert FhirMedicationPackage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationPackage;

    // Insert an existing FhirMedicationPackage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationPackage);

    // Get the iIndexth FhirMedicationPackage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationPackage);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationPackage;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMedicationPackages[index : Integer] : TFhirMedicationPackage read GetItemN write SetItemN; default;
  End;

  // A set of components that go to make up the described item.
  TFhirMedicationPackageContent = class (TFhirBackboneElement)
  protected
    FItem : TFhirReference{TFhirMedication};
    FAmount : TFhirQuantity;
    Procedure SetItem(value : TFhirReference{TFhirMedication});
    Procedure SetAmount(value : TFhirQuantity);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationPackageContent; overload;
    function Clone : TFhirMedicationPackageContent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Identifies one of the items in the package. (defined for API consistency)
    property item : TFhirReference{TFhirMedication} read FItem write SetItem;
    // Identifies one of the items in the package.
    property itemElement : TFhirReference{TFhirMedication} read FItem write SetItem;

    // Typed access to The amount of the product that is in the package. (defined for API consistency)
    property amount : TFhirQuantity read FAmount write SetAmount;
    // The amount of the product that is in the package.
    property amountElement : TFhirQuantity read FAmount write SetAmount;

  end;

  TFhirMedicationPackageContentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationPackageContentList;
    function GetCurrent : TFhirMedicationPackageContent;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationPackageContentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationPackageContent read GetCurrent;
  end;

  TFhirMedicationPackageContentList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationPackageContent;
    procedure SetItemN(index : Integer; value : TFhirMedicationPackageContent);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationPackageContentList; Overload;
    function Clone : TFhirMedicationPackageContentList; Overload;
    function GetEnumerator : TFhirMedicationPackageContentListEnumerator;

    //  Add a FhirMedicationPackageContent to the end of the list.
    function Append : TFhirMedicationPackageContent;

    // Add an already existing FhirMedicationPackageContent to the end of the list.
    procedure AddItem(value : TFhirMedicationPackageContent); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationPackageContent) : Integer;

    // Insert FhirMedicationPackageContent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationPackageContent;

    // Insert an existing FhirMedicationPackageContent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationPackageContent);

    // Get the iIndexth FhirMedicationPackageContent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationPackageContent);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationPackageContent;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMedicationPackageContents[index : Integer] : TFhirMedicationPackageContent read GetItemN write SetItemN; default;
  End;

  // This resource is primarily used for the identification and definition of a medication. It covers the ingredients and the packaging for a medication.
  TFhirMedication = class (TFhirDomainResource)
  protected
    FCode : TFhirCodeableConcept;
    FIsBrand : TFhirBoolean;
    FManufacturer : TFhirReference{TFhirOrganization};
    FProduct : TFhirMedicationProduct;
    FPackage : TFhirMedicationPackage;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetIsBrand(value : TFhirBoolean);
    Function GetIsBrandST : Boolean;
    Procedure SetIsBrandST(value : Boolean);
    Procedure SetManufacturer(value : TFhirReference{TFhirOrganization});
    Procedure SetProduct(value : TFhirMedicationProduct);
    Procedure SetPackage(value : TFhirMedicationPackage);

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedication; overload;
    function Clone : TFhirMedication; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code (or set of codes) that specify this medication, or a textual description if no code is available. Usage note: This could be a standard medication code such as a code from RxNorm, SNOMED CT, IDMP etc. It could also be a national or local formulary code, optionally with translations to other code systems. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code (or set of codes) that specify this medication, or a textual description if no code is available. Usage note: This could be a standard medication code such as a code from RxNorm, SNOMED CT, IDMP etc. It could also be a national or local formulary code, optionally with translations to other code systems.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to Set to true if the item is attributable to a specific manufacturer.
    property isBrand : Boolean read GetIsBrandST write SetIsBrandST;
    // Set to true if the item is attributable to a specific manufacturer.
    property isBrandElement : TFhirBoolean read FIsBrand write SetIsBrand;

    // Typed access to Describes the details of the manufacturer. (defined for API consistency)
    property manufacturer : TFhirReference{TFhirOrganization} read FManufacturer write SetManufacturer;
    // Describes the details of the manufacturer.
    property manufacturerElement : TFhirReference{TFhirOrganization} read FManufacturer write SetManufacturer;

    // Typed access to Information that only applies to products (not packages). (defined for API consistency)
    property product : TFhirMedicationProduct read FProduct write SetProduct;
    // Information that only applies to products (not packages).
    property productElement : TFhirMedicationProduct read FProduct write SetProduct;

    // Typed access to Information that only applies to packages (not products). (defined for API consistency)
    property package : TFhirMedicationPackage read FPackage write SetPackage;
    // Information that only applies to packages (not products).
    property packageElement : TFhirMedicationPackage read FPackage write SetPackage;

  end;

  TFhirMedicationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationList;
    function GetCurrent : TFhirMedication;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedication read GetCurrent;
  end;

  TFhirMedicationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedication;
    procedure SetItemN(index : Integer; value : TFhirMedication);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationList; Overload;
    function Clone : TFhirMedicationList; Overload;
    function GetEnumerator : TFhirMedicationListEnumerator;

    //  Add a FhirMedication to the end of the list.
    function Append : TFhirMedication;

    // Add an already existing FhirMedication to the end of the list.
    procedure AddItem(value : TFhirMedication); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedication) : Integer;

    // Insert FhirMedication before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedication;

    // Insert an existing FhirMedication before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedication);

    // Get the iIndexth FhirMedication. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedication);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMedication;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMedications[index : Integer] : TFhirMedication read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEDICATION}

{$IFDEF FHIR_MESSAGEHEADER}

  // Information about the message that this message is a response to.  Only present if this message is a response.
  TFhirMessageHeaderResponse = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirId;
    FCode : TFhirEnum;
    FDetails : TFhirReference{TFhirOperationOutcome};
    Procedure SetIdentifier(value : TFhirId);
    Function GetIdentifierST : String;
    Procedure SetIdentifierST(value : String);
    Procedure SetCode(value : TFhirEnum);
    Function GetCodeST : TFhirResponseCodeEnum;
    Procedure SetCodeST(value : TFhirResponseCodeEnum);
    Procedure SetDetails(value : TFhirReference{TFhirOperationOutcome});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMessageHeaderResponse; overload;
    function Clone : TFhirMessageHeaderResponse; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The id of the message that this message is a response to.
    property identifier : String read GetIdentifierST write SetIdentifierST;
    // The id of the message that this message is a response to.
    property identifierElement : TFhirId read FIdentifier write SetIdentifier;

    // Code that identifies the type of response to the message - whether it was successful or not, and whether it should be resent or not.
    property code : TFhirResponseCodeEnum read GetCodeST write SetCodeST;
    property codeElement : TFhirEnum read FCode write SetCode;

    // Typed access to Full details of any issues found in the message. (defined for API consistency)
    property details : TFhirReference{TFhirOperationOutcome} read FDetails write SetDetails;
    // Full details of any issues found in the message.
    property detailsElement : TFhirReference{TFhirOperationOutcome} read FDetails write SetDetails;

  end;

  TFhirMessageHeaderResponseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMessageHeaderResponseList;
    function GetCurrent : TFhirMessageHeaderResponse;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMessageHeaderResponseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMessageHeaderResponse read GetCurrent;
  end;

  TFhirMessageHeaderResponseList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMessageHeaderResponse;
    procedure SetItemN(index : Integer; value : TFhirMessageHeaderResponse);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMessageHeaderResponseList; Overload;
    function Clone : TFhirMessageHeaderResponseList; Overload;
    function GetEnumerator : TFhirMessageHeaderResponseListEnumerator;

    //  Add a FhirMessageHeaderResponse to the end of the list.
    function Append : TFhirMessageHeaderResponse;

    // Add an already existing FhirMessageHeaderResponse to the end of the list.
    procedure AddItem(value : TFhirMessageHeaderResponse); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMessageHeaderResponse) : Integer;

    // Insert FhirMessageHeaderResponse before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMessageHeaderResponse;

    // Insert an existing FhirMessageHeaderResponse before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMessageHeaderResponse);

    // Get the iIndexth FhirMessageHeaderResponse. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMessageHeaderResponse);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMessageHeaderResponse;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMessageHeaderResponses[index : Integer] : TFhirMessageHeaderResponse read GetItemN write SetItemN; default;
  End;

  // The source application from which this message originated.
  TFhirMessageHeaderSource = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FSoftware : TFhirString;
    FVersion : TFhirString;
    FContact : TFhirContactPoint;
    FEndpoint : TFhirUri;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetSoftware(value : TFhirString);
    Function GetSoftwareST : String;
    Procedure SetSoftwareST(value : String);
    Procedure SetVersion(value : TFhirString);
    Function GetVersionST : String;
    Procedure SetVersionST(value : String);
    Procedure SetContact(value : TFhirContactPoint);
    Procedure SetEndpoint(value : TFhirUri);
    Function GetEndpointST : String;
    Procedure SetEndpointST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMessageHeaderSource; overload;
    function Clone : TFhirMessageHeaderSource; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Human-readable name for the source system.
    property name : String read GetNameST write SetNameST;
    // Human-readable name for the source system.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to May include configuration or other information useful in debugging.
    property software : String read GetSoftwareST write SetSoftwareST;
    // May include configuration or other information useful in debugging.
    property softwareElement : TFhirString read FSoftware write SetSoftware;

    // Typed access to Can convey versions of multiple systems in situations where a message passes through multiple hands.
    property version : String read GetVersionST write SetVersionST;
    // Can convey versions of multiple systems in situations where a message passes through multiple hands.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to An e-mail, phone, website or other contact point to use to resolve issues with message communications. (defined for API consistency)
    property contact : TFhirContactPoint read FContact write SetContact;
    // An e-mail, phone, website or other contact point to use to resolve issues with message communications.
    property contactElement : TFhirContactPoint read FContact write SetContact;

    // Typed access to Identifies the routing target to send acknowledgements to.
    property endpoint : String read GetEndpointST write SetEndpointST;
    // Identifies the routing target to send acknowledgements to.
    property endpointElement : TFhirUri read FEndpoint write SetEndpoint;

  end;

  TFhirMessageHeaderSourceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMessageHeaderSourceList;
    function GetCurrent : TFhirMessageHeaderSource;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMessageHeaderSourceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMessageHeaderSource read GetCurrent;
  end;

  TFhirMessageHeaderSourceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMessageHeaderSource;
    procedure SetItemN(index : Integer; value : TFhirMessageHeaderSource);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMessageHeaderSourceList; Overload;
    function Clone : TFhirMessageHeaderSourceList; Overload;
    function GetEnumerator : TFhirMessageHeaderSourceListEnumerator;

    //  Add a FhirMessageHeaderSource to the end of the list.
    function Append : TFhirMessageHeaderSource;

    // Add an already existing FhirMessageHeaderSource to the end of the list.
    procedure AddItem(value : TFhirMessageHeaderSource); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMessageHeaderSource) : Integer;

    // Insert FhirMessageHeaderSource before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMessageHeaderSource;

    // Insert an existing FhirMessageHeaderSource before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMessageHeaderSource);

    // Get the iIndexth FhirMessageHeaderSource. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMessageHeaderSource);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMessageHeaderSource;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMessageHeaderSources[index : Integer] : TFhirMessageHeaderSource read GetItemN write SetItemN; default;
  End;

  // The destination application which the message is intended for.
  TFhirMessageHeaderDestination = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FTarget : TFhirReference{TFhirDevice};
    FEndpoint : TFhirUri;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetTarget(value : TFhirReference{TFhirDevice});
    Procedure SetEndpoint(value : TFhirUri);
    Function GetEndpointST : String;
    Procedure SetEndpointST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMessageHeaderDestination; overload;
    function Clone : TFhirMessageHeaderDestination; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Human-readable name for the target system.
    property name : String read GetNameST write SetNameST;
    // Human-readable name for the target system.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Identifies the target end system in situations where the initial message transmission is to an intermediary system. (defined for API consistency)
    property target : TFhirReference{TFhirDevice} read FTarget write SetTarget;
    // Identifies the target end system in situations where the initial message transmission is to an intermediary system.
    property targetElement : TFhirReference{TFhirDevice} read FTarget write SetTarget;

    // Typed access to Indicates where the message should be routed to.
    property endpoint : String read GetEndpointST write SetEndpointST;
    // Indicates where the message should be routed to.
    property endpointElement : TFhirUri read FEndpoint write SetEndpoint;

  end;

  TFhirMessageHeaderDestinationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMessageHeaderDestinationList;
    function GetCurrent : TFhirMessageHeaderDestination;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMessageHeaderDestinationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMessageHeaderDestination read GetCurrent;
  end;

  TFhirMessageHeaderDestinationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMessageHeaderDestination;
    procedure SetItemN(index : Integer; value : TFhirMessageHeaderDestination);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMessageHeaderDestinationList; Overload;
    function Clone : TFhirMessageHeaderDestinationList; Overload;
    function GetEnumerator : TFhirMessageHeaderDestinationListEnumerator;

    //  Add a FhirMessageHeaderDestination to the end of the list.
    function Append : TFhirMessageHeaderDestination;

    // Add an already existing FhirMessageHeaderDestination to the end of the list.
    procedure AddItem(value : TFhirMessageHeaderDestination); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMessageHeaderDestination) : Integer;

    // Insert FhirMessageHeaderDestination before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMessageHeaderDestination;

    // Insert an existing FhirMessageHeaderDestination before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMessageHeaderDestination);

    // Get the iIndexth FhirMessageHeaderDestination. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMessageHeaderDestination);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMessageHeaderDestination;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMessageHeaderDestinations[index : Integer] : TFhirMessageHeaderDestination read GetItemN write SetItemN; default;
  End;

  // The header for a message exchange that is either requesting or responding to an action.  The reference(s) that are the subject of the action as well as other information related to the action are typically transmitted in a bundle in which the MessageHeader resource instance is the first resource in the bundle.
  TFhirMessageHeader = class (TFhirDomainResource)
  protected
    FTimestamp : TFhirInstant;
    FEvent : TFhirCoding;
    FResponse : TFhirMessageHeaderResponse;
    FSource : TFhirMessageHeaderSource;
    FdestinationList : TFhirMessageHeaderDestinationList;
    FEnterer : TFhirReference{TFhirPractitioner};
    FAuthor : TFhirReference{TFhirPractitioner};
    FReceiver : TFhirReference{Resource};
    FResponsible : TFhirReference{Resource};
    FReason : TFhirCodeableConcept;
    FdataList : TFhirReferenceList{TFhirReference};
    Procedure SetTimestamp(value : TFhirInstant);
    Function GetTimestampST : TFslDateTime;
    Procedure SetTimestampST(value : TFslDateTime);
    Procedure SetEvent(value : TFhirCoding);
    Procedure SetResponse(value : TFhirMessageHeaderResponse);
    Procedure SetSource(value : TFhirMessageHeaderSource);
    function GetDestinationList : TFhirMessageHeaderDestinationList;
    function GetHasDestinationList : Boolean;
    Procedure SetEnterer(value : TFhirReference{TFhirPractitioner});
    Procedure SetAuthor(value : TFhirReference{TFhirPractitioner});
    Procedure SetReceiver(value : TFhirReference{Resource});
    Procedure SetResponsible(value : TFhirReference{Resource});
    Procedure SetReason(value : TFhirCodeableConcept);
    function GetDataList : TFhirReferenceList{TFhirReference};
    function GetHasDataList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMessageHeader; overload;
    function Clone : TFhirMessageHeader; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The time that the message was sent.
    property timestamp : TFslDateTime read GetTimestampST write SetTimestampST;
    // The time that the message was sent.
    property timestampElement : TFhirInstant read FTimestamp write SetTimestamp;

    // Typed access to Code that identifies the event this message represents and connects it with its definition. Events defined as part of the FHIR specification have the system value "http://hl7.org/fhir/message-events". (defined for API consistency)
    property event : TFhirCoding read FEvent write SetEvent;
    // Code that identifies the event this message represents and connects it with its definition. Events defined as part of the FHIR specification have the system value "http://hl7.org/fhir/message-events".
    property eventElement : TFhirCoding read FEvent write SetEvent;

    // Typed access to Information about the message that this message is a response to.  Only present if this message is a response. (defined for API consistency)
    property response : TFhirMessageHeaderResponse read FResponse write SetResponse;
    // Information about the message that this message is a response to.  Only present if this message is a response.
    property responseElement : TFhirMessageHeaderResponse read FResponse write SetResponse;

    // Typed access to The source application from which this message originated. (defined for API consistency)
    property source : TFhirMessageHeaderSource read FSource write SetSource;
    // The source application from which this message originated.
    property sourceElement : TFhirMessageHeaderSource read FSource write SetSource;

    // The destination application which the message is intended for.
    property destinationList : TFhirMessageHeaderDestinationList read GetDestinationList;
    property hasDestinationList : boolean read GetHasDestinationList;

    // Typed access to The person or device that performed the data entry leading to this message. Where there is more than one candidate, pick the most proximal to the message. Can provide other enterers in extensions. (defined for API consistency)
    property enterer : TFhirReference{TFhirPractitioner} read FEnterer write SetEnterer;
    // The person or device that performed the data entry leading to this message. Where there is more than one candidate, pick the most proximal to the message. Can provide other enterers in extensions.
    property entererElement : TFhirReference{TFhirPractitioner} read FEnterer write SetEnterer;

    // Typed access to The logical author of the message - the person or device that decided the described event should happen. Where there is more than one candidate, pick the most proximal to the MessageHeader. Can provide other authors in extensions. (defined for API consistency)
    property author : TFhirReference{TFhirPractitioner} read FAuthor write SetAuthor;
    // The logical author of the message - the person or device that decided the described event should happen. Where there is more than one candidate, pick the most proximal to the MessageHeader. Can provide other authors in extensions.
    property authorElement : TFhirReference{TFhirPractitioner} read FAuthor write SetAuthor;

    // Typed access to Allows data conveyed by a message to be addressed to a particular person or department when routing to a specific application isn't sufficient. (defined for API consistency)
    property receiver : TFhirReference{Resource} read FReceiver write SetReceiver;
    // Allows data conveyed by a message to be addressed to a particular person or department when routing to a specific application isn't sufficient.
    property receiverElement : TFhirReference{Resource} read FReceiver write SetReceiver;

    // Typed access to The person or organization that accepts overall responsibility for the contents of the message. The implication is that the message event happened under the policies of the responsible party. (defined for API consistency)
    property responsible : TFhirReference{Resource} read FResponsible write SetResponsible;
    // The person or organization that accepts overall responsibility for the contents of the message. The implication is that the message event happened under the policies of the responsible party.
    property responsibleElement : TFhirReference{Resource} read FResponsible write SetResponsible;

    // Typed access to Coded indication of the cause for the event - indicates  a reason for the occurrence of the event that is a focus of this message. (defined for API consistency)
    property reason : TFhirCodeableConcept read FReason write SetReason;
    // Coded indication of the cause for the event - indicates  a reason for the occurrence of the event that is a focus of this message.
    property reasonElement : TFhirCodeableConcept read FReason write SetReason;

    // The actual data of the message - a reference to the root/focus class of the event.
    property dataList : TFhirReferenceList{TFhirReference} read GetDataList;
    property hasDataList : boolean read GetHasDataList;

  end;

  TFhirMessageHeaderListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMessageHeaderList;
    function GetCurrent : TFhirMessageHeader;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMessageHeaderList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMessageHeader read GetCurrent;
  end;

  TFhirMessageHeaderList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMessageHeader;
    procedure SetItemN(index : Integer; value : TFhirMessageHeader);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMessageHeaderList; Overload;
    function Clone : TFhirMessageHeaderList; Overload;
    function GetEnumerator : TFhirMessageHeaderListEnumerator;

    //  Add a FhirMessageHeader to the end of the list.
    function Append : TFhirMessageHeader;

    // Add an already existing FhirMessageHeader to the end of the list.
    procedure AddItem(value : TFhirMessageHeader); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMessageHeader) : Integer;

    // Insert FhirMessageHeader before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMessageHeader;

    // Insert an existing FhirMessageHeader before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMessageHeader);

    // Get the iIndexth FhirMessageHeader. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMessageHeader);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMessageHeader;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMessageHeaders[index : Integer] : TFhirMessageHeader read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MESSAGEHEADER}

{$IFDEF FHIR_OPERATIONOUTCOME}

  // An error, warning or information message that results from a system action.
  TFhirOperationOutcomeIssue = class (TFhirBackboneElement)
  protected
    FSeverity : TFhirEnum;
    FCode : TFhirEnum;
    FDetails : TFhirCodeableConcept;
    FDiagnostics : TFhirString;
    FlocationList : TFhirStringList;
    Procedure SetSeverity(value : TFhirEnum);
    Function GetSeverityST : TFhirIssueSeverityEnum;
    Procedure SetSeverityST(value : TFhirIssueSeverityEnum);
    Procedure SetCode(value : TFhirEnum);
    Function GetCodeST : TFhirIssueTypeEnum;
    Procedure SetCodeST(value : TFhirIssueTypeEnum);
    Procedure SetDetails(value : TFhirCodeableConcept);
    Procedure SetDiagnostics(value : TFhirString);
    Function GetDiagnosticsST : String;
    Procedure SetDiagnosticsST(value : String);
    function GetLocationList : TFhirStringList;
    function GetHasLocationList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirOperationOutcomeIssue; overload;
    function Clone : TFhirOperationOutcomeIssue; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Indicates whether the issue indicates a variation from successful processing.
    property severity : TFhirIssueSeverityEnum read GetSeverityST write SetSeverityST;
    property severityElement : TFhirEnum read FSeverity write SetSeverity;

    // Describes the type of the issue. The system that creates an OperationOutcome SHALL choose the most applicable code from the IssueType value set, and may additional provide its own code for the error in the details element.
    property code : TFhirIssueTypeEnum read GetCodeST write SetCodeST;
    property codeElement : TFhirEnum read FCode write SetCode;

    // Typed access to Additional details about the error. This may be a text description of the error, or a system code that identifies the error. (defined for API consistency)
    property details : TFhirCodeableConcept read FDetails write SetDetails;
    // Additional details about the error. This may be a text description of the error, or a system code that identifies the error.
    property detailsElement : TFhirCodeableConcept read FDetails write SetDetails;

    // Typed access to Additional diagnostic information about the issue.  Typically, this may be a description of how a value is erroneous, or a stack dump to help trace the issue.
    property diagnostics : String read GetDiagnosticsST write SetDiagnosticsST;
    // Additional diagnostic information about the issue.  Typically, this may be a description of how a value is erroneous, or a stack dump to help trace the issue.
    property diagnosticsElement : TFhirString read FDiagnostics write SetDiagnostics;

    // A simple XPath limited to element names, repetition indicators and the default child access that identifies one of the elements in the resource that caused this issue to be raised.
    property locationList : TFhirStringList read GetLocationList;
    property hasLocationList : boolean read GetHasLocationList;

  end;

  TFhirOperationOutcomeIssueListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirOperationOutcomeIssueList;
    function GetCurrent : TFhirOperationOutcomeIssue;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirOperationOutcomeIssueList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirOperationOutcomeIssue read GetCurrent;
  end;

  TFhirOperationOutcomeIssueList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirOperationOutcomeIssue;
    procedure SetItemN(index : Integer; value : TFhirOperationOutcomeIssue);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirOperationOutcomeIssueList; Overload;
    function Clone : TFhirOperationOutcomeIssueList; Overload;
    function GetEnumerator : TFhirOperationOutcomeIssueListEnumerator;

    //  Add a FhirOperationOutcomeIssue to the end of the list.
    function Append : TFhirOperationOutcomeIssue;

    // Add an already existing FhirOperationOutcomeIssue to the end of the list.
    procedure AddItem(value : TFhirOperationOutcomeIssue); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirOperationOutcomeIssue) : Integer;

    // Insert FhirOperationOutcomeIssue before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirOperationOutcomeIssue;

    // Insert an existing FhirOperationOutcomeIssue before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirOperationOutcomeIssue);

    // Get the iIndexth FhirOperationOutcomeIssue. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirOperationOutcomeIssue);

    // The number of items in the collection
    function Item(index : Integer) : TFhirOperationOutcomeIssue;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirOperationOutcomeIssues[index : Integer] : TFhirOperationOutcomeIssue read GetItemN write SetItemN; default;
  End;

  // A collection of error, warning or information messages that result from a system action.
  TFhirOperationOutcome = class (TFhirDomainResource)
  protected
    FissueList : TFhirOperationOutcomeIssueList;
    function GetIssueList : TFhirOperationOutcomeIssueList;
    function GetHasIssueList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirOperationOutcome; overload;
    function Clone : TFhirOperationOutcome; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // An error, warning or information message that results from a system action.
    property issueList : TFhirOperationOutcomeIssueList read GetIssueList;
    property hasIssueList : boolean read GetHasIssueList;

  end;

  TFhirOperationOutcomeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirOperationOutcomeList;
    function GetCurrent : TFhirOperationOutcome;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirOperationOutcomeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirOperationOutcome read GetCurrent;
  end;

  TFhirOperationOutcomeList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirOperationOutcome;
    procedure SetItemN(index : Integer; value : TFhirOperationOutcome);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirOperationOutcomeList; Overload;
    function Clone : TFhirOperationOutcomeList; Overload;
    function GetEnumerator : TFhirOperationOutcomeListEnumerator;

    //  Add a FhirOperationOutcome to the end of the list.
    function Append : TFhirOperationOutcome;

    // Add an already existing FhirOperationOutcome to the end of the list.
    procedure AddItem(value : TFhirOperationOutcome); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirOperationOutcome) : Integer;

    // Insert FhirOperationOutcome before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirOperationOutcome;

    // Insert an existing FhirOperationOutcome before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirOperationOutcome);

    // Get the iIndexth FhirOperationOutcome. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirOperationOutcome);

    // The number of items in the collection
    function Item(index : Integer) : TFhirOperationOutcome;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirOperationOutcomes[index : Integer] : TFhirOperationOutcome read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_OPERATIONOUTCOME}

{$IFDEF FHIR_ORDER}

  // When order should be fulfilled.
  TFhirOrderWhen = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FSchedule : TFhirTiming;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetSchedule(value : TFhirTiming);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirOrderWhen; overload;
    function Clone : TFhirOrderWhen; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Code specifies when request should be done. The code may simply be a priority code. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Code specifies when request should be done. The code may simply be a priority code.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to A formal schedule. (defined for API consistency)
    property schedule : TFhirTiming read FSchedule write SetSchedule;
    // A formal schedule.
    property scheduleElement : TFhirTiming read FSchedule write SetSchedule;

  end;

  TFhirOrderWhenListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirOrderWhenList;
    function GetCurrent : TFhirOrderWhen;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirOrderWhenList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirOrderWhen read GetCurrent;
  end;

  TFhirOrderWhenList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirOrderWhen;
    procedure SetItemN(index : Integer; value : TFhirOrderWhen);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirOrderWhenList; Overload;
    function Clone : TFhirOrderWhenList; Overload;
    function GetEnumerator : TFhirOrderWhenListEnumerator;

    //  Add a FhirOrderWhen to the end of the list.
    function Append : TFhirOrderWhen;

    // Add an already existing FhirOrderWhen to the end of the list.
    procedure AddItem(value : TFhirOrderWhen); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirOrderWhen) : Integer;

    // Insert FhirOrderWhen before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirOrderWhen;

    // Insert an existing FhirOrderWhen before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirOrderWhen);

    // Get the iIndexth FhirOrderWhen. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirOrderWhen);

    // The number of items in the collection
    function Item(index : Integer) : TFhirOrderWhen;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirOrderWhens[index : Integer] : TFhirOrderWhen read GetItemN write SetItemN; default;
  End;

  // A request to perform an action.
  TFhirOrder = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FDate : TFhirDateTime;
    FSubject : TFhirReference{Resource};
    FSource : TFhirReference{Resource};
    FTarget : TFhirReference{Resource};
    FReason : TFhirType;
    FWhen : TFhirOrderWhen;
    FdetailList : TFhirReferenceList{TFhirReference};
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetSubject(value : TFhirReference{Resource});
    Procedure SetSource(value : TFhirReference{Resource});
    Procedure SetTarget(value : TFhirReference{Resource});
    Procedure SetReason(value : TFhirType);
    Procedure SetWhen(value : TFhirOrderWhen);
    function GetDetailList : TFhirReferenceList{TFhirReference};
    function GetHasDetailList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirOrder; overload;
    function Clone : TFhirOrder; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifiers assigned to this order by the orderer or by the receiver.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to When the order was made.
    property date : TFslDateTime read GetDateST write SetDateST;
    // When the order was made.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to Patient this order is about. (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // Patient this order is about.
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // Typed access to Who initiated the order. (defined for API consistency)
    property source : TFhirReference{Resource} read FSource write SetSource;
    // Who initiated the order.
    property sourceElement : TFhirReference{Resource} read FSource write SetSource;

    // Typed access to Who is intended to fulfill the order. (defined for API consistency)
    property target : TFhirReference{Resource} read FTarget write SetTarget;
    // Who is intended to fulfill the order.
    property targetElement : TFhirReference{Resource} read FTarget write SetTarget;

    // Typed access to Text - why the order was made. (defined for API consistency)
    property reason : TFhirType read FReason write SetReason;
    // Text - why the order was made.
    property reasonElement : TFhirType read FReason write SetReason;

    // Typed access to When order should be fulfilled. (defined for API consistency)
    property when : TFhirOrderWhen read FWhen write SetWhen;
    // When order should be fulfilled.
    property whenElement : TFhirOrderWhen read FWhen write SetWhen;

    // What action is being ordered.
    property detailList : TFhirReferenceList{TFhirReference} read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

  end;

  TFhirOrderListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirOrderList;
    function GetCurrent : TFhirOrder;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirOrderList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirOrder read GetCurrent;
  end;

  TFhirOrderList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirOrder;
    procedure SetItemN(index : Integer; value : TFhirOrder);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirOrderList; Overload;
    function Clone : TFhirOrderList; Overload;
    function GetEnumerator : TFhirOrderListEnumerator;

    //  Add a FhirOrder to the end of the list.
    function Append : TFhirOrder;

    // Add an already existing FhirOrder to the end of the list.
    procedure AddItem(value : TFhirOrder); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirOrder) : Integer;

    // Insert FhirOrder before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirOrder;

    // Insert an existing FhirOrder before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirOrder);

    // Get the iIndexth FhirOrder. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirOrder);

    // The number of items in the collection
    function Item(index : Integer) : TFhirOrder;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirOrders[index : Integer] : TFhirOrder read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ORDER}

{$IFDEF FHIR_ORDERRESPONSE}

  // A response to an order.
  TFhirOrderResponse = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FRequest : TFhirReference{TFhirOrder};
    FDate : TFhirDateTime;
    FWho : TFhirReference{Resource};
    FOrderStatus : TFhirEnum;
    FDescription : TFhirString;
    FfulfillmentList : TFhirReferenceList{TFhirReference};
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetRequest(value : TFhirReference{TFhirOrder});
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetWho(value : TFhirReference{Resource});
    Procedure SetOrderStatus(value : TFhirEnum);
    Function GetOrderStatusST : TFhirOrderStatusEnum;
    Procedure SetOrderStatusST(value : TFhirOrderStatusEnum);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    function GetFulfillmentList : TFhirReferenceList{TFhirReference};
    function GetHasFulfillmentList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirOrderResponse; overload;
    function Clone : TFhirOrderResponse; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifiers assigned to this order. The identifiers are usually assigned by the system responding to the order, but they may be provided or added to by other systems.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to A reference to the order that this is in response to. (defined for API consistency)
    property request : TFhirReference{TFhirOrder} read FRequest write SetRequest;
    // A reference to the order that this is in response to.
    property requestElement : TFhirReference{TFhirOrder} read FRequest write SetRequest;

    // Typed access to The date and time at which this order response was made (created/posted).
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date and time at which this order response was made (created/posted).
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The person, organization, or device credited with making the response. (defined for API consistency)
    property who : TFhirReference{Resource} read FWho write SetWho;
    // The person, organization, or device credited with making the response.
    property whoElement : TFhirReference{Resource} read FWho write SetWho;

    // What this response says about the status of the original order.
    property orderStatus : TFhirOrderStatusEnum read GetOrderStatusST write SetOrderStatusST;
    property orderStatusElement : TFhirEnum read FOrderStatus write SetOrderStatus;

    // Typed access to Additional description about the response - e.g. a text description provided by a human user when making decisions about the order.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Additional description about the response - e.g. a text description provided by a human user when making decisions about the order.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Links to resources that provide details of the outcome of performing the order; e.g. Diagnostic Reports in a response that is made to an order that referenced a diagnostic order.
    property fulfillmentList : TFhirReferenceList{TFhirReference} read GetFulfillmentList;
    property hasFulfillmentList : boolean read GetHasFulfillmentList;

  end;

  TFhirOrderResponseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirOrderResponseList;
    function GetCurrent : TFhirOrderResponse;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirOrderResponseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirOrderResponse read GetCurrent;
  end;

  TFhirOrderResponseList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirOrderResponse;
    procedure SetItemN(index : Integer; value : TFhirOrderResponse);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirOrderResponseList; Overload;
    function Clone : TFhirOrderResponseList; Overload;
    function GetEnumerator : TFhirOrderResponseListEnumerator;

    //  Add a FhirOrderResponse to the end of the list.
    function Append : TFhirOrderResponse;

    // Add an already existing FhirOrderResponse to the end of the list.
    procedure AddItem(value : TFhirOrderResponse); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirOrderResponse) : Integer;

    // Insert FhirOrderResponse before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirOrderResponse;

    // Insert an existing FhirOrderResponse before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirOrderResponse);

    // Get the iIndexth FhirOrderResponse. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirOrderResponse);

    // The number of items in the collection
    function Item(index : Integer) : TFhirOrderResponse;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirOrderResponses[index : Integer] : TFhirOrderResponse read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ORDERRESPONSE}

{$IFDEF FHIR_PAYMENTNOTICE}

  // This resource provides the status of the payment for goods and services rendered, and the request and response resource references.
  TFhirPaymentNotice = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FRuleset : TFhirCoding;
    FOriginalRuleset : TFhirCoding;
    FCreated : TFhirDateTime;
    FTarget : TFhirReference{TFhirOrganization};
    FProvider : TFhirReference{TFhirPractitioner};
    FOrganization : TFhirReference{TFhirOrganization};
    FRequest : TFhirReference{TFhirReference};
    FResponse : TFhirReference{TFhirReference};
    FPaymentStatus : TFhirCoding;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetRuleset(value : TFhirCoding);
    Procedure SetOriginalRuleset(value : TFhirCoding);
    Procedure SetCreated(value : TFhirDateTime);
    Function GetCreatedST : TFslDateTime;
    Procedure SetCreatedST(value : TFslDateTime);
    Procedure SetTarget(value : TFhirReference{TFhirOrganization});
    Procedure SetProvider(value : TFhirReference{TFhirPractitioner});
    Procedure SetOrganization(value : TFhirReference{TFhirOrganization});
    Procedure SetRequest(value : TFhirReference{TFhirReference});
    Procedure SetResponse(value : TFhirReference{TFhirReference});
    Procedure SetPaymentStatus(value : TFhirCoding);

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPaymentNotice; overload;
    function Clone : TFhirPaymentNotice; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The Response business identifier.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The version of the style of resource contents. This should be mapped to the allowable profiles for this and supporting resources. (defined for API consistency)
    property ruleset : TFhirCoding read FRuleset write SetRuleset;
    // The version of the style of resource contents. This should be mapped to the allowable profiles for this and supporting resources.
    property rulesetElement : TFhirCoding read FRuleset write SetRuleset;

    // Typed access to The style (standard) and version of the original material which was converted into this resource. (defined for API consistency)
    property originalRuleset : TFhirCoding read FOriginalRuleset write SetOriginalRuleset;
    // The style (standard) and version of the original material which was converted into this resource.
    property originalRulesetElement : TFhirCoding read FOriginalRuleset write SetOriginalRuleset;

    // Typed access to The date when this resource was created.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date when this resource was created.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to The Insurer who is target  of the request. (defined for API consistency)
    property target : TFhirReference{TFhirOrganization} read FTarget write SetTarget;
    // The Insurer who is target  of the request.
    property targetElement : TFhirReference{TFhirOrganization} read FTarget write SetTarget;

    // Typed access to The practitioner who is responsible for the services rendered to the patient. (defined for API consistency)
    property provider : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;
    // The practitioner who is responsible for the services rendered to the patient.
    property providerElement : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;

    // Typed access to The organization which is responsible for the services rendered to the patient. (defined for API consistency)
    property organization : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;
    // The organization which is responsible for the services rendered to the patient.
    property organizationElement : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;

    // Typed access to Reference of resource to reverse. (defined for API consistency)
    property request : TFhirReference{TFhirReference} read FRequest write SetRequest;
    // Reference of resource to reverse.
    property requestElement : TFhirReference{TFhirReference} read FRequest write SetRequest;

    // Typed access to Reference of response to resource to reverse. (defined for API consistency)
    property response : TFhirReference{TFhirReference} read FResponse write SetResponse;
    // Reference of response to resource to reverse.
    property responseElement : TFhirReference{TFhirReference} read FResponse write SetResponse;

    // Typed access to The payment status, typically paid: payment sent, cleared: payment received. (defined for API consistency)
    property paymentStatus : TFhirCoding read FPaymentStatus write SetPaymentStatus;
    // The payment status, typically paid: payment sent, cleared: payment received.
    property paymentStatusElement : TFhirCoding read FPaymentStatus write SetPaymentStatus;

  end;

  TFhirPaymentNoticeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPaymentNoticeList;
    function GetCurrent : TFhirPaymentNotice;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirPaymentNoticeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPaymentNotice read GetCurrent;
  end;

  TFhirPaymentNoticeList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirPaymentNotice;
    procedure SetItemN(index : Integer; value : TFhirPaymentNotice);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirPaymentNoticeList; Overload;
    function Clone : TFhirPaymentNoticeList; Overload;
    function GetEnumerator : TFhirPaymentNoticeListEnumerator;

    //  Add a FhirPaymentNotice to the end of the list.
    function Append : TFhirPaymentNotice;

    // Add an already existing FhirPaymentNotice to the end of the list.
    procedure AddItem(value : TFhirPaymentNotice); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPaymentNotice) : Integer;

    // Insert FhirPaymentNotice before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPaymentNotice;

    // Insert an existing FhirPaymentNotice before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPaymentNotice);

    // Get the iIndexth FhirPaymentNotice. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPaymentNotice);

    // The number of items in the collection
    function Item(index : Integer) : TFhirPaymentNotice;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirPaymentNotices[index : Integer] : TFhirPaymentNotice read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PAYMENTNOTICE}

{$IFDEF FHIR_PAYMENTRECONCILIATION}

  // List of individual settlement amounts and the corresponding transaction.
  TFhirPaymentReconciliationDetail = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCoding;
    FRequest : TFhirReference{TFhirReference};
    FResponce : TFhirReference{TFhirReference};
    FSubmitter : TFhirReference{TFhirOrganization};
    FPayee : TFhirReference{TFhirOrganization};
    FDate : TFhirDate;
    FAmount : TFhirQuantity;
    Procedure SetType_(value : TFhirCoding);
    Procedure SetRequest(value : TFhirReference{TFhirReference});
    Procedure SetResponce(value : TFhirReference{TFhirReference});
    Procedure SetSubmitter(value : TFhirReference{TFhirOrganization});
    Procedure SetPayee(value : TFhirReference{TFhirOrganization});
    Procedure SetDate(value : TFhirDate);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetAmount(value : TFhirQuantity);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPaymentReconciliationDetail; overload;
    function Clone : TFhirPaymentReconciliationDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Code to indicate the nature of the payment, adjustment, funds advance, etc. (defined for API consistency)
    property type_ : TFhirCoding read FType_ write SetType_;
    // Code to indicate the nature of the payment, adjustment, funds advance, etc.
    property type_Element : TFhirCoding read FType_ write SetType_;

    // Typed access to The claim or financial resource. (defined for API consistency)
    property request : TFhirReference{TFhirReference} read FRequest write SetRequest;
    // The claim or financial resource.
    property requestElement : TFhirReference{TFhirReference} read FRequest write SetRequest;

    // Typed access to The claim response resource. (defined for API consistency)
    property responce : TFhirReference{TFhirReference} read FResponce write SetResponce;
    // The claim response resource.
    property responceElement : TFhirReference{TFhirReference} read FResponce write SetResponce;

    // Typed access to The Organization which submitted the invoice or financial transaction. (defined for API consistency)
    property submitter : TFhirReference{TFhirOrganization} read FSubmitter write SetSubmitter;
    // The Organization which submitted the invoice or financial transaction.
    property submitterElement : TFhirReference{TFhirOrganization} read FSubmitter write SetSubmitter;

    // Typed access to The organization which is receiving the payment. (defined for API consistency)
    property payee : TFhirReference{TFhirOrganization} read FPayee write SetPayee;
    // The organization which is receiving the payment.
    property payeeElement : TFhirReference{TFhirOrganization} read FPayee write SetPayee;

    // Typed access to The date of the invoice or financial resource.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date of the invoice or financial resource.
    property dateElement : TFhirDate read FDate write SetDate;

    // Typed access to Amount paid for this detail. (defined for API consistency)
    property amount : TFhirQuantity read FAmount write SetAmount;
    // Amount paid for this detail.
    property amountElement : TFhirQuantity read FAmount write SetAmount;

  end;

  TFhirPaymentReconciliationDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPaymentReconciliationDetailList;
    function GetCurrent : TFhirPaymentReconciliationDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirPaymentReconciliationDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPaymentReconciliationDetail read GetCurrent;
  end;

  TFhirPaymentReconciliationDetailList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirPaymentReconciliationDetail;
    procedure SetItemN(index : Integer; value : TFhirPaymentReconciliationDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirPaymentReconciliationDetailList; Overload;
    function Clone : TFhirPaymentReconciliationDetailList; Overload;
    function GetEnumerator : TFhirPaymentReconciliationDetailListEnumerator;

    //  Add a FhirPaymentReconciliationDetail to the end of the list.
    function Append : TFhirPaymentReconciliationDetail;

    // Add an already existing FhirPaymentReconciliationDetail to the end of the list.
    procedure AddItem(value : TFhirPaymentReconciliationDetail); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPaymentReconciliationDetail) : Integer;

    // Insert FhirPaymentReconciliationDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPaymentReconciliationDetail;

    // Insert an existing FhirPaymentReconciliationDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPaymentReconciliationDetail);

    // Get the iIndexth FhirPaymentReconciliationDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPaymentReconciliationDetail);

    // The number of items in the collection
    function Item(index : Integer) : TFhirPaymentReconciliationDetail;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirPaymentReconciliationDetails[index : Integer] : TFhirPaymentReconciliationDetail read GetItemN write SetItemN; default;
  End;

  // Suite of notes.
  TFhirPaymentReconciliationNote = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCoding;
    FText : TFhirString;
    Procedure SetType_(value : TFhirCoding);
    Procedure SetText(value : TFhirString);
    Function GetTextST : String;
    Procedure SetTextST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPaymentReconciliationNote; overload;
    function Clone : TFhirPaymentReconciliationNote; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The note purpose: Print/Display. (defined for API consistency)
    property type_ : TFhirCoding read FType_ write SetType_;
    // The note purpose: Print/Display.
    property type_Element : TFhirCoding read FType_ write SetType_;

    // Typed access to The note text.
    property text : String read GetTextST write SetTextST;
    // The note text.
    property textElement : TFhirString read FText write SetText;

  end;

  TFhirPaymentReconciliationNoteListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPaymentReconciliationNoteList;
    function GetCurrent : TFhirPaymentReconciliationNote;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirPaymentReconciliationNoteList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPaymentReconciliationNote read GetCurrent;
  end;

  TFhirPaymentReconciliationNoteList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirPaymentReconciliationNote;
    procedure SetItemN(index : Integer; value : TFhirPaymentReconciliationNote);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirPaymentReconciliationNoteList; Overload;
    function Clone : TFhirPaymentReconciliationNoteList; Overload;
    function GetEnumerator : TFhirPaymentReconciliationNoteListEnumerator;

    //  Add a FhirPaymentReconciliationNote to the end of the list.
    function Append : TFhirPaymentReconciliationNote;

    // Add an already existing FhirPaymentReconciliationNote to the end of the list.
    procedure AddItem(value : TFhirPaymentReconciliationNote); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPaymentReconciliationNote) : Integer;

    // Insert FhirPaymentReconciliationNote before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPaymentReconciliationNote;

    // Insert an existing FhirPaymentReconciliationNote before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPaymentReconciliationNote);

    // Get the iIndexth FhirPaymentReconciliationNote. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPaymentReconciliationNote);

    // The number of items in the collection
    function Item(index : Integer) : TFhirPaymentReconciliationNote;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirPaymentReconciliationNotes[index : Integer] : TFhirPaymentReconciliationNote read GetItemN write SetItemN; default;
  End;

  // This resource provides payment details and claim references supporting a bulk payment.
  TFhirPaymentReconciliation = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FRequest : TFhirReference{TFhirProcessRequest};
    FOutcome : TFhirEnum;
    FDisposition : TFhirString;
    FRuleset : TFhirCoding;
    FOriginalRuleset : TFhirCoding;
    FCreated : TFhirDateTime;
    FPeriod : TFhirPeriod;
    FOrganization : TFhirReference{TFhirOrganization};
    FRequestProvider : TFhirReference{TFhirPractitioner};
    FRequestOrganization : TFhirReference{TFhirOrganization};
    FdetailList : TFhirPaymentReconciliationDetailList;
    FForm : TFhirCoding;
    FTotal : TFhirQuantity;
    FnoteList : TFhirPaymentReconciliationNoteList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetRequest(value : TFhirReference{TFhirProcessRequest});
    Procedure SetOutcome(value : TFhirEnum);
    Function GetOutcomeST : TFhirRemittanceOutcomeEnum;
    Procedure SetOutcomeST(value : TFhirRemittanceOutcomeEnum);
    Procedure SetDisposition(value : TFhirString);
    Function GetDispositionST : String;
    Procedure SetDispositionST(value : String);
    Procedure SetRuleset(value : TFhirCoding);
    Procedure SetOriginalRuleset(value : TFhirCoding);
    Procedure SetCreated(value : TFhirDateTime);
    Function GetCreatedST : TFslDateTime;
    Procedure SetCreatedST(value : TFslDateTime);
    Procedure SetPeriod(value : TFhirPeriod);
    Procedure SetOrganization(value : TFhirReference{TFhirOrganization});
    Procedure SetRequestProvider(value : TFhirReference{TFhirPractitioner});
    Procedure SetRequestOrganization(value : TFhirReference{TFhirOrganization});
    function GetDetailList : TFhirPaymentReconciliationDetailList;
    function GetHasDetailList : Boolean;
    Procedure SetForm(value : TFhirCoding);
    Procedure SetTotal(value : TFhirQuantity);
    function GetNoteList : TFhirPaymentReconciliationNoteList;
    function GetHasNoteList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPaymentReconciliation; overload;
    function Clone : TFhirPaymentReconciliation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The Response business identifier.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Original request resource reference. (defined for API consistency)
    property request : TFhirReference{TFhirProcessRequest} read FRequest write SetRequest;
    // Original request resource reference.
    property requestElement : TFhirReference{TFhirProcessRequest} read FRequest write SetRequest;

    // Transaction status: error, complete.
    property outcome : TFhirRemittanceOutcomeEnum read GetOutcomeST write SetOutcomeST;
    property outcomeElement : TFhirEnum read FOutcome write SetOutcome;

    // Typed access to A description of the status of the adjudication.
    property disposition : String read GetDispositionST write SetDispositionST;
    // A description of the status of the adjudication.
    property dispositionElement : TFhirString read FDisposition write SetDisposition;

    // Typed access to The version of the style of resource contents. This should be mapped to the allowable profiles for this and supporting resources. (defined for API consistency)
    property ruleset : TFhirCoding read FRuleset write SetRuleset;
    // The version of the style of resource contents. This should be mapped to the allowable profiles for this and supporting resources.
    property rulesetElement : TFhirCoding read FRuleset write SetRuleset;

    // Typed access to The style (standard) and version of the original material which was converted into this resource. (defined for API consistency)
    property originalRuleset : TFhirCoding read FOriginalRuleset write SetOriginalRuleset;
    // The style (standard) and version of the original material which was converted into this resource.
    property originalRulesetElement : TFhirCoding read FOriginalRuleset write SetOriginalRuleset;

    // Typed access to The date when the enclosed suite of services were performed or completed.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date when the enclosed suite of services were performed or completed.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to The period of time for which payments have been gathered into this bulk payment for settlement. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period of time for which payments have been gathered into this bulk payment for settlement.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to The Insurer who produced this adjudicated response. (defined for API consistency)
    property organization : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;
    // The Insurer who produced this adjudicated response.
    property organizationElement : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;

    // Typed access to The practitioner who is responsible for the services rendered to the patient. (defined for API consistency)
    property requestProvider : TFhirReference{TFhirPractitioner} read FRequestProvider write SetRequestProvider;
    // The practitioner who is responsible for the services rendered to the patient.
    property requestProviderElement : TFhirReference{TFhirPractitioner} read FRequestProvider write SetRequestProvider;

    // Typed access to The organization which is responsible for the services rendered to the patient. (defined for API consistency)
    property requestOrganization : TFhirReference{TFhirOrganization} read FRequestOrganization write SetRequestOrganization;
    // The organization which is responsible for the services rendered to the patient.
    property requestOrganizationElement : TFhirReference{TFhirOrganization} read FRequestOrganization write SetRequestOrganization;

    // List of individual settlement amounts and the corresponding transaction.
    property detailList : TFhirPaymentReconciliationDetailList read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

    // Typed access to The form to be used for printing the content. (defined for API consistency)
    property form : TFhirCoding read FForm write SetForm;
    // The form to be used for printing the content.
    property formElement : TFhirCoding read FForm write SetForm;

    // Typed access to Total payment amount. (defined for API consistency)
    property total : TFhirQuantity read FTotal write SetTotal;
    // Total payment amount.
    property totalElement : TFhirQuantity read FTotal write SetTotal;

    // Suite of notes.
    property noteList : TFhirPaymentReconciliationNoteList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirPaymentReconciliationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPaymentReconciliationList;
    function GetCurrent : TFhirPaymentReconciliation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirPaymentReconciliationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPaymentReconciliation read GetCurrent;
  end;

  TFhirPaymentReconciliationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirPaymentReconciliation;
    procedure SetItemN(index : Integer; value : TFhirPaymentReconciliation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirPaymentReconciliationList; Overload;
    function Clone : TFhirPaymentReconciliationList; Overload;
    function GetEnumerator : TFhirPaymentReconciliationListEnumerator;

    //  Add a FhirPaymentReconciliation to the end of the list.
    function Append : TFhirPaymentReconciliation;

    // Add an already existing FhirPaymentReconciliation to the end of the list.
    procedure AddItem(value : TFhirPaymentReconciliation); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPaymentReconciliation) : Integer;

    // Insert FhirPaymentReconciliation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPaymentReconciliation;

    // Insert an existing FhirPaymentReconciliation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPaymentReconciliation);

    // Get the iIndexth FhirPaymentReconciliation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPaymentReconciliation);

    // The number of items in the collection
    function Item(index : Integer) : TFhirPaymentReconciliation;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirPaymentReconciliations[index : Integer] : TFhirPaymentReconciliation read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PAYMENTRECONCILIATION}

{$IFDEF FHIR_PROCESSREQUEST}

  // List of top level items to be re-adjudicated, if none specified then the entire submission is re-adjudicated.
  TFhirProcessRequestItem = class (TFhirBackboneElement)
  protected
    FSequenceLinkId : TFhirInteger;
    Procedure SetSequenceLinkId(value : TFhirInteger);
    Function GetSequenceLinkIdST : String;
    Procedure SetSequenceLinkIdST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirProcessRequestItem; overload;
    function Clone : TFhirProcessRequestItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A service line number.
    property sequenceLinkId : String read GetSequenceLinkIdST write SetSequenceLinkIdST;
    // A service line number.
    property sequenceLinkIdElement : TFhirInteger read FSequenceLinkId write SetSequenceLinkId;

  end;

  TFhirProcessRequestItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirProcessRequestItemList;
    function GetCurrent : TFhirProcessRequestItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirProcessRequestItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProcessRequestItem read GetCurrent;
  end;

  TFhirProcessRequestItemList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirProcessRequestItem;
    procedure SetItemN(index : Integer; value : TFhirProcessRequestItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirProcessRequestItemList; Overload;
    function Clone : TFhirProcessRequestItemList; Overload;
    function GetEnumerator : TFhirProcessRequestItemListEnumerator;

    //  Add a FhirProcessRequestItem to the end of the list.
    function Append : TFhirProcessRequestItem;

    // Add an already existing FhirProcessRequestItem to the end of the list.
    procedure AddItem(value : TFhirProcessRequestItem); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirProcessRequestItem) : Integer;

    // Insert FhirProcessRequestItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirProcessRequestItem;

    // Insert an existing FhirProcessRequestItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirProcessRequestItem);

    // Get the iIndexth FhirProcessRequestItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirProcessRequestItem);

    // The number of items in the collection
    function Item(index : Integer) : TFhirProcessRequestItem;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirProcessRequestItems[index : Integer] : TFhirProcessRequestItem read GetItemN write SetItemN; default;
  End;

  // This resource provides the target, request and response, and action details for an action to be performed by the target on or about existing resources.
  TFhirProcessRequest = class (TFhirDomainResource)
  protected
    FAction : TFhirEnum;
    FidentifierList : TFhirIdentifierList;
    FRuleset : TFhirCoding;
    FOriginalRuleset : TFhirCoding;
    FCreated : TFhirDateTime;
    FTarget : TFhirReference{TFhirOrganization};
    FProvider : TFhirReference{TFhirPractitioner};
    FOrganization : TFhirReference{TFhirOrganization};
    FRequest : TFhirReference{TFhirReference};
    FResponse : TFhirReference{TFhirReference};
    FNullify : TFhirBoolean;
    FReference : TFhirString;
    FitemList : TFhirProcessRequestItemList;
    FincludeList : TFhirStringList;
    FexcludeList : TFhirStringList;
    FPeriod : TFhirPeriod;
    Procedure SetAction(value : TFhirEnum);
    Function GetActionST : TFhirActionlistEnum;
    Procedure SetActionST(value : TFhirActionlistEnum);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetRuleset(value : TFhirCoding);
    Procedure SetOriginalRuleset(value : TFhirCoding);
    Procedure SetCreated(value : TFhirDateTime);
    Function GetCreatedST : TFslDateTime;
    Procedure SetCreatedST(value : TFslDateTime);
    Procedure SetTarget(value : TFhirReference{TFhirOrganization});
    Procedure SetProvider(value : TFhirReference{TFhirPractitioner});
    Procedure SetOrganization(value : TFhirReference{TFhirOrganization});
    Procedure SetRequest(value : TFhirReference{TFhirReference});
    Procedure SetResponse(value : TFhirReference{TFhirReference});
    Procedure SetNullify(value : TFhirBoolean);
    Function GetNullifyST : Boolean;
    Procedure SetNullifyST(value : Boolean);
    Procedure SetReference(value : TFhirString);
    Function GetReferenceST : String;
    Procedure SetReferenceST(value : String);
    function GetItemList : TFhirProcessRequestItemList;
    function GetHasItemList : Boolean;
    function GetIncludeList : TFhirStringList;
    function GetHasIncludeList : Boolean;
    function GetExcludeList : TFhirStringList;
    function GetHasExcludeList : Boolean;
    Procedure SetPeriod(value : TFhirPeriod);

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirProcessRequest; overload;
    function Clone : TFhirProcessRequest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The type of processing action being requested, for example Reversal, Readjudication, StatusRequest,PendedRequest.
    property action : TFhirActionlistEnum read GetActionST write SetActionST;
    property actionElement : TFhirEnum read FAction write SetAction;

    // The ProcessRequest business identifier.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The version of the style of resource contents. This should be mapped to the allowable profiles for this and supporting resources. (defined for API consistency)
    property ruleset : TFhirCoding read FRuleset write SetRuleset;
    // The version of the style of resource contents. This should be mapped to the allowable profiles for this and supporting resources.
    property rulesetElement : TFhirCoding read FRuleset write SetRuleset;

    // Typed access to The style (standard) and version of the original material which was converted into this resource. (defined for API consistency)
    property originalRuleset : TFhirCoding read FOriginalRuleset write SetOriginalRuleset;
    // The style (standard) and version of the original material which was converted into this resource.
    property originalRulesetElement : TFhirCoding read FOriginalRuleset write SetOriginalRuleset;

    // Typed access to The date when this resource was created.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date when this resource was created.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to The organization which is the target of the request. (defined for API consistency)
    property target : TFhirReference{TFhirOrganization} read FTarget write SetTarget;
    // The organization which is the target of the request.
    property targetElement : TFhirReference{TFhirOrganization} read FTarget write SetTarget;

    // Typed access to The practitioner who is responsible for the action specified in thise request. (defined for API consistency)
    property provider : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;
    // The practitioner who is responsible for the action specified in thise request.
    property providerElement : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;

    // Typed access to The organization which is responsible for the action speccified in thise request. (defined for API consistency)
    property organization : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;
    // The organization which is responsible for the action speccified in thise request.
    property organizationElement : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;

    // Typed access to Reference of resource which is the target or subject of this action. (defined for API consistency)
    property request : TFhirReference{TFhirReference} read FRequest write SetRequest;
    // Reference of resource which is the target or subject of this action.
    property requestElement : TFhirReference{TFhirReference} read FRequest write SetRequest;

    // Typed access to Reference of a prior response to resource which is the target or subject of this action. (defined for API consistency)
    property response : TFhirReference{TFhirReference} read FResponse write SetResponse;
    // Reference of a prior response to resource which is the target or subject of this action.
    property responseElement : TFhirReference{TFhirReference} read FResponse write SetResponse;

    // Typed access to If true remove all history excluding audit.
    property nullify : Boolean read GetNullifyST write SetNullifyST;
    // If true remove all history excluding audit.
    property nullifyElement : TFhirBoolean read FNullify write SetNullify;

    // Typed access to A reference to supply which authenticates the process.
    property reference : String read GetReferenceST write SetReferenceST;
    // A reference to supply which authenticates the process.
    property referenceElement : TFhirString read FReference write SetReference;

    // List of top level items to be re-adjudicated, if none specified then the entire submission is re-adjudicated.
    property itemList : TFhirProcessRequestItemList read GetItemList;
    property hasItemList : boolean read GetHasItemList;

    // Names of resource types to include.
    property includeList : TFhirStringList read GetIncludeList;
    property hasIncludeList : boolean read GetHasIncludeList;

    // Names of resource types to exclude.
    property excludeList : TFhirStringList read GetExcludeList;
    property hasExcludeList : boolean read GetHasExcludeList;

    // Typed access to A period of time during which the fulfilling resources would have been created. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // A period of time during which the fulfilling resources would have been created.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirProcessRequestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirProcessRequestList;
    function GetCurrent : TFhirProcessRequest;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirProcessRequestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProcessRequest read GetCurrent;
  end;

  TFhirProcessRequestList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirProcessRequest;
    procedure SetItemN(index : Integer; value : TFhirProcessRequest);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirProcessRequestList; Overload;
    function Clone : TFhirProcessRequestList; Overload;
    function GetEnumerator : TFhirProcessRequestListEnumerator;

    //  Add a FhirProcessRequest to the end of the list.
    function Append : TFhirProcessRequest;

    // Add an already existing FhirProcessRequest to the end of the list.
    procedure AddItem(value : TFhirProcessRequest); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirProcessRequest) : Integer;

    // Insert FhirProcessRequest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirProcessRequest;

    // Insert an existing FhirProcessRequest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirProcessRequest);

    // Get the iIndexth FhirProcessRequest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirProcessRequest);

    // The number of items in the collection
    function Item(index : Integer) : TFhirProcessRequest;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirProcessRequests[index : Integer] : TFhirProcessRequest read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PROCESSREQUEST}

{$IFDEF FHIR_PROCESSRESPONSE}

  // Suite of processing note or additional requirements is the processing has been held.
  TFhirProcessResponseNotes = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCoding;
    FText : TFhirString;
    Procedure SetType_(value : TFhirCoding);
    Procedure SetText(value : TFhirString);
    Function GetTextST : String;
    Procedure SetTextST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirProcessResponseNotes; overload;
    function Clone : TFhirProcessResponseNotes; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The note purpose: Print/Display. (defined for API consistency)
    property type_ : TFhirCoding read FType_ write SetType_;
    // The note purpose: Print/Display.
    property type_Element : TFhirCoding read FType_ write SetType_;

    // Typed access to The note text.
    property text : String read GetTextST write SetTextST;
    // The note text.
    property textElement : TFhirString read FText write SetText;

  end;

  TFhirProcessResponseNotesListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirProcessResponseNotesList;
    function GetCurrent : TFhirProcessResponseNotes;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirProcessResponseNotesList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProcessResponseNotes read GetCurrent;
  end;

  TFhirProcessResponseNotesList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirProcessResponseNotes;
    procedure SetItemN(index : Integer; value : TFhirProcessResponseNotes);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirProcessResponseNotesList; Overload;
    function Clone : TFhirProcessResponseNotesList; Overload;
    function GetEnumerator : TFhirProcessResponseNotesListEnumerator;

    //  Add a FhirProcessResponseNotes to the end of the list.
    function Append : TFhirProcessResponseNotes;

    // Add an already existing FhirProcessResponseNotes to the end of the list.
    procedure AddItem(value : TFhirProcessResponseNotes); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirProcessResponseNotes) : Integer;

    // Insert FhirProcessResponseNotes before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirProcessResponseNotes;

    // Insert an existing FhirProcessResponseNotes before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirProcessResponseNotes);

    // Get the iIndexth FhirProcessResponseNotes. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirProcessResponseNotes);

    // The number of items in the collection
    function Item(index : Integer) : TFhirProcessResponseNotes;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirProcessResponseNotes[index : Integer] : TFhirProcessResponseNotes read GetItemN write SetItemN; default;
  End;

  // This resource provides processing status, errors and notes from the processing of a resource.
  TFhirProcessResponse = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FRequest : TFhirReference{TFhirReference};
    FOutcome : TFhirCoding;
    FDisposition : TFhirString;
    FRuleset : TFhirCoding;
    FOriginalRuleset : TFhirCoding;
    FCreated : TFhirDateTime;
    FOrganization : TFhirReference{TFhirOrganization};
    FRequestProvider : TFhirReference{TFhirPractitioner};
    FRequestOrganization : TFhirReference{TFhirOrganization};
    FForm : TFhirCoding;
    FnotesList : TFhirProcessResponseNotesList;
    FerrorList : TFhirCodingList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetRequest(value : TFhirReference{TFhirReference});
    Procedure SetOutcome(value : TFhirCoding);
    Procedure SetDisposition(value : TFhirString);
    Function GetDispositionST : String;
    Procedure SetDispositionST(value : String);
    Procedure SetRuleset(value : TFhirCoding);
    Procedure SetOriginalRuleset(value : TFhirCoding);
    Procedure SetCreated(value : TFhirDateTime);
    Function GetCreatedST : TFslDateTime;
    Procedure SetCreatedST(value : TFslDateTime);
    Procedure SetOrganization(value : TFhirReference{TFhirOrganization});
    Procedure SetRequestProvider(value : TFhirReference{TFhirPractitioner});
    Procedure SetRequestOrganization(value : TFhirReference{TFhirOrganization});
    Procedure SetForm(value : TFhirCoding);
    function GetNotesList : TFhirProcessResponseNotesList;
    function GetHasNotesList : Boolean;
    function GetErrorList : TFhirCodingList;
    function GetHasErrorList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirProcessResponse; overload;
    function Clone : TFhirProcessResponse; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The Response business identifier.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Original request resource reference. (defined for API consistency)
    property request : TFhirReference{TFhirReference} read FRequest write SetRequest;
    // Original request resource reference.
    property requestElement : TFhirReference{TFhirReference} read FRequest write SetRequest;

    // Typed access to Transaction status: error, complete, held. (defined for API consistency)
    property outcome : TFhirCoding read FOutcome write SetOutcome;
    // Transaction status: error, complete, held.
    property outcomeElement : TFhirCoding read FOutcome write SetOutcome;

    // Typed access to A description of the status of the adjudication or processing.
    property disposition : String read GetDispositionST write SetDispositionST;
    // A description of the status of the adjudication or processing.
    property dispositionElement : TFhirString read FDisposition write SetDisposition;

    // Typed access to The version of the style of resource contents. This should be mapped to the allowable profiles for this and supporting resources. (defined for API consistency)
    property ruleset : TFhirCoding read FRuleset write SetRuleset;
    // The version of the style of resource contents. This should be mapped to the allowable profiles for this and supporting resources.
    property rulesetElement : TFhirCoding read FRuleset write SetRuleset;

    // Typed access to The style (standard) and version of the original material which was converted into this resource. (defined for API consistency)
    property originalRuleset : TFhirCoding read FOriginalRuleset write SetOriginalRuleset;
    // The style (standard) and version of the original material which was converted into this resource.
    property originalRulesetElement : TFhirCoding read FOriginalRuleset write SetOriginalRuleset;

    // Typed access to The date when the enclosed suite of services were performed or completed.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date when the enclosed suite of services were performed or completed.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to The organization who produced this adjudicated response. (defined for API consistency)
    property organization : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;
    // The organization who produced this adjudicated response.
    property organizationElement : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;

    // Typed access to The practitioner who is responsible for the services rendered to the patient. (defined for API consistency)
    property requestProvider : TFhirReference{TFhirPractitioner} read FRequestProvider write SetRequestProvider;
    // The practitioner who is responsible for the services rendered to the patient.
    property requestProviderElement : TFhirReference{TFhirPractitioner} read FRequestProvider write SetRequestProvider;

    // Typed access to The organization which is responsible for the services rendered to the patient. (defined for API consistency)
    property requestOrganization : TFhirReference{TFhirOrganization} read FRequestOrganization write SetRequestOrganization;
    // The organization which is responsible for the services rendered to the patient.
    property requestOrganizationElement : TFhirReference{TFhirOrganization} read FRequestOrganization write SetRequestOrganization;

    // Typed access to The form to be used for printing the content. (defined for API consistency)
    property form : TFhirCoding read FForm write SetForm;
    // The form to be used for printing the content.
    property formElement : TFhirCoding read FForm write SetForm;

    // Suite of processing note or additional requirements is the processing has been held.
    property notesList : TFhirProcessResponseNotesList read GetNotesList;
    property hasNotesList : boolean read GetHasNotesList;

    // Processing errors.
    property errorList : TFhirCodingList read GetErrorList;
    property hasErrorList : boolean read GetHasErrorList;

  end;

  TFhirProcessResponseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirProcessResponseList;
    function GetCurrent : TFhirProcessResponse;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirProcessResponseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProcessResponse read GetCurrent;
  end;

  TFhirProcessResponseList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirProcessResponse;
    procedure SetItemN(index : Integer; value : TFhirProcessResponse);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirProcessResponseList; Overload;
    function Clone : TFhirProcessResponseList; Overload;
    function GetEnumerator : TFhirProcessResponseListEnumerator;

    //  Add a FhirProcessResponse to the end of the list.
    function Append : TFhirProcessResponse;

    // Add an already existing FhirProcessResponse to the end of the list.
    procedure AddItem(value : TFhirProcessResponse); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirProcessResponse) : Integer;

    // Insert FhirProcessResponse before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirProcessResponse;

    // Insert an existing FhirProcessResponse before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirProcessResponse);

    // Get the iIndexth FhirProcessResponse. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirProcessResponse);

    // The number of items in the collection
    function Item(index : Integer) : TFhirProcessResponse;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirProcessResponses[index : Integer] : TFhirProcessResponse read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PROCESSRESPONSE}

{$IFDEF FHIR_PROVENANCE}

  // An agent takes a role in an activity such that the agent can be assigned some degree of responsibility for the activity taking place. An agent can be a person, an organization, software, or other entities that may be ascribed responsibility.
  TFhirProvenanceAgent = class (TFhirBackboneElement)
  protected
    FRole : TFhirCoding;
    FActor : TFhirReference{Resource};
    FUserId : TFhirIdentifier;
    FrelatedAgentList : TFhirProvenanceAgentRelatedAgentList;
    Procedure SetRole(value : TFhirCoding);
    Procedure SetActor(value : TFhirReference{Resource});
    Procedure SetUserId(value : TFhirIdentifier);
    function GetRelatedAgentList : TFhirProvenanceAgentRelatedAgentList;
    function GetHasRelatedAgentList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirProvenanceAgent; overload;
    function Clone : TFhirProvenanceAgent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The function of the agent with respect to the activity. (defined for API consistency)
    property role : TFhirCoding read FRole write SetRole;
    // The function of the agent with respect to the activity.
    property roleElement : TFhirCoding read FRole write SetRole;

    // Typed access to The individual, device or organization that participated in the event. (defined for API consistency)
    property actor : TFhirReference{Resource} read FActor write SetActor;
    // The individual, device or organization that participated in the event.
    property actorElement : TFhirReference{Resource} read FActor write SetActor;

    // Typed access to The identity of the agent as known by the authorization system. (defined for API consistency)
    property userId : TFhirIdentifier read FUserId write SetUserId;
    // The identity of the agent as known by the authorization system.
    property userIdElement : TFhirIdentifier read FUserId write SetUserId;

    // A relationship between two the agents referenced in this resource. This is defined to allow for explicit description of the delegation between agents.  For example, this human author used this device, or one person acted on another's behest.
    property relatedAgentList : TFhirProvenanceAgentRelatedAgentList read GetRelatedAgentList;
    property hasRelatedAgentList : boolean read GetHasRelatedAgentList;

  end;

  TFhirProvenanceAgentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirProvenanceAgentList;
    function GetCurrent : TFhirProvenanceAgent;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirProvenanceAgentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProvenanceAgent read GetCurrent;
  end;

  TFhirProvenanceAgentList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirProvenanceAgent;
    procedure SetItemN(index : Integer; value : TFhirProvenanceAgent);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirProvenanceAgentList; Overload;
    function Clone : TFhirProvenanceAgentList; Overload;
    function GetEnumerator : TFhirProvenanceAgentListEnumerator;

    //  Add a FhirProvenanceAgent to the end of the list.
    function Append : TFhirProvenanceAgent;

    // Add an already existing FhirProvenanceAgent to the end of the list.
    procedure AddItem(value : TFhirProvenanceAgent); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirProvenanceAgent) : Integer;

    // Insert FhirProvenanceAgent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirProvenanceAgent;

    // Insert an existing FhirProvenanceAgent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirProvenanceAgent);

    // Get the iIndexth FhirProvenanceAgent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirProvenanceAgent);

    // The number of items in the collection
    function Item(index : Integer) : TFhirProvenanceAgent;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirProvenanceAgents[index : Integer] : TFhirProvenanceAgent read GetItemN write SetItemN; default;
  End;

  // A relationship between two the agents referenced in this resource. This is defined to allow for explicit description of the delegation between agents.  For example, this human author used this device, or one person acted on another's behest.
  TFhirProvenanceAgentRelatedAgent = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FTarget : TFhirUri;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetTarget(value : TFhirUri);
    Function GetTargetST : String;
    Procedure SetTargetST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirProvenanceAgentRelatedAgent; overload;
    function Clone : TFhirProvenanceAgentRelatedAgent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The type of relationship between agents. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of relationship between agents.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to An internal reference to another agent listed in this provenance by its identifier.
    property target : String read GetTargetST write SetTargetST;
    // An internal reference to another agent listed in this provenance by its identifier.
    property targetElement : TFhirUri read FTarget write SetTarget;

  end;

  TFhirProvenanceAgentRelatedAgentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirProvenanceAgentRelatedAgentList;
    function GetCurrent : TFhirProvenanceAgentRelatedAgent;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirProvenanceAgentRelatedAgentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProvenanceAgentRelatedAgent read GetCurrent;
  end;

  TFhirProvenanceAgentRelatedAgentList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirProvenanceAgentRelatedAgent;
    procedure SetItemN(index : Integer; value : TFhirProvenanceAgentRelatedAgent);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirProvenanceAgentRelatedAgentList; Overload;
    function Clone : TFhirProvenanceAgentRelatedAgentList; Overload;
    function GetEnumerator : TFhirProvenanceAgentRelatedAgentListEnumerator;

    //  Add a FhirProvenanceAgentRelatedAgent to the end of the list.
    function Append : TFhirProvenanceAgentRelatedAgent;

    // Add an already existing FhirProvenanceAgentRelatedAgent to the end of the list.
    procedure AddItem(value : TFhirProvenanceAgentRelatedAgent); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirProvenanceAgentRelatedAgent) : Integer;

    // Insert FhirProvenanceAgentRelatedAgent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirProvenanceAgentRelatedAgent;

    // Insert an existing FhirProvenanceAgentRelatedAgent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirProvenanceAgentRelatedAgent);

    // Get the iIndexth FhirProvenanceAgentRelatedAgent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirProvenanceAgentRelatedAgent);

    // The number of items in the collection
    function Item(index : Integer) : TFhirProvenanceAgentRelatedAgent;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirProvenanceAgentRelatedAgents[index : Integer] : TFhirProvenanceAgentRelatedAgent read GetItemN write SetItemN; default;
  End;

  // An entity used in this activity.
  TFhirProvenanceEntity = class (TFhirBackboneElement)
  protected
    FRole : TFhirEnum;
    FType_ : TFhirCoding;
    FReference : TFhirUri;
    FDisplay : TFhirString;
    FAgent : TFhirProvenanceAgent;
    Procedure SetRole(value : TFhirEnum);
    Function GetRoleST : TFhirProvenanceEntityRoleEnum;
    Procedure SetRoleST(value : TFhirProvenanceEntityRoleEnum);
    Procedure SetType_(value : TFhirCoding);
    Procedure SetReference(value : TFhirUri);
    Function GetReferenceST : String;
    Procedure SetReferenceST(value : String);
    Procedure SetDisplay(value : TFhirString);
    Function GetDisplayST : String;
    Procedure SetDisplayST(value : String);
    Procedure SetAgent(value : TFhirProvenanceAgent);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirProvenanceEntity; overload;
    function Clone : TFhirProvenanceEntity; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // How the entity was used during the activity.
    property role : TFhirProvenanceEntityRoleEnum read GetRoleST write SetRoleST;
    property roleElement : TFhirEnum read FRole write SetRole;

    // Typed access to The type of the entity. If the entity is a resource, then this is a resource type. (defined for API consistency)
    property type_ : TFhirCoding read FType_ write SetType_;
    // The type of the entity. If the entity is a resource, then this is a resource type.
    property type_Element : TFhirCoding read FType_ write SetType_;

    // Typed access to Identity of the  Entity used. May be a logical or physical uri and maybe absolute or relative.
    property reference : String read GetReferenceST write SetReferenceST;
    // Identity of the  Entity used. May be a logical or physical uri and maybe absolute or relative.
    property referenceElement : TFhirUri read FReference write SetReference;

    // Typed access to Human-readable description of the entity.
    property display : String read GetDisplayST write SetDisplayST;
    // Human-readable description of the entity.
    property displayElement : TFhirString read FDisplay write SetDisplay;

    // Typed access to The entity is attributed to an agent to express the agent's responsibility for that entity, possibly along with other agents. This description can be understood as shorthand for saying that the agent was responsible for the activity which generated the entity. (defined for API consistency)
    property agent : TFhirProvenanceAgent read FAgent write SetAgent;
    // The entity is attributed to an agent to express the agent's responsibility for that entity, possibly along with other agents. This description can be understood as shorthand for saying that the agent was responsible for the activity which generated the entity.
    property agentElement : TFhirProvenanceAgent read FAgent write SetAgent;

  end;

  TFhirProvenanceEntityListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirProvenanceEntityList;
    function GetCurrent : TFhirProvenanceEntity;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirProvenanceEntityList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProvenanceEntity read GetCurrent;
  end;

  TFhirProvenanceEntityList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirProvenanceEntity;
    procedure SetItemN(index : Integer; value : TFhirProvenanceEntity);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirProvenanceEntityList; Overload;
    function Clone : TFhirProvenanceEntityList; Overload;
    function GetEnumerator : TFhirProvenanceEntityListEnumerator;

    //  Add a FhirProvenanceEntity to the end of the list.
    function Append : TFhirProvenanceEntity;

    // Add an already existing FhirProvenanceEntity to the end of the list.
    procedure AddItem(value : TFhirProvenanceEntity); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirProvenanceEntity) : Integer;

    // Insert FhirProvenanceEntity before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirProvenanceEntity;

    // Insert an existing FhirProvenanceEntity before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirProvenanceEntity);

    // Get the iIndexth FhirProvenanceEntity. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirProvenanceEntity);

    // The number of items in the collection
    function Item(index : Integer) : TFhirProvenanceEntity;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirProvenanceEntities[index : Integer] : TFhirProvenanceEntity read GetItemN write SetItemN; default;
  End;

  // Provenance of a resource is a record that describes entities and processes involved in producing and delivering or otherwise influencing that resource. Provenance provides a critical foundation for assessing authenticity, enabling trust, and allowing reproducibility. Provenance assertions are a form of contextual metadata and can themselves become important records with their own provenance. Provenance statement indicates clinical significance in terms of confidence in authenticity, reliability, and trustworthiness, integrity, and stage in lifecycle (e.g. Document Completion - has the artifact been legally authenticated), all of which may impact security, privacy, and trust policies.
  TFhirProvenance = class (TFhirDomainResource)
  protected
    FtargetList : TFhirReferenceList{TFhirReference};
    FPeriod : TFhirPeriod;
    FRecorded : TFhirInstant;
    FreasonList : TFhirCodeableConceptList;
    FActivity : TFhirCodeableConcept;
    FLocation : TFhirReference{TFhirLocation};
    FpolicyList : TFhirUriList;
    FagentList : TFhirProvenanceAgentList;
    FentityList : TFhirProvenanceEntityList;
    FsignatureList : TFhirSignatureList;
    function GetTargetList : TFhirReferenceList{TFhirReference};
    function GetHasTargetList : Boolean;
    Procedure SetPeriod(value : TFhirPeriod);
    Procedure SetRecorded(value : TFhirInstant);
    Function GetRecordedST : TFslDateTime;
    Procedure SetRecordedST(value : TFslDateTime);
    function GetReasonList : TFhirCodeableConceptList;
    function GetHasReasonList : Boolean;
    Procedure SetActivity(value : TFhirCodeableConcept);
    Procedure SetLocation(value : TFhirReference{TFhirLocation});
    function GetPolicyList : TFhirUriList;
    function GetHasPolicyList : Boolean;
    function GetAgentList : TFhirProvenanceAgentList;
    function GetHasAgentList : Boolean;
    function GetEntityList : TFhirProvenanceEntityList;
    function GetHasEntityList : Boolean;
    function GetSignatureList : TFhirSignatureList;
    function GetHasSignatureList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirProvenance; overload;
    function Clone : TFhirProvenance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The Reference(s) that were generated or updated by  the activity described in this resource. A provenance can point to more than one target if multiple resources were created/updated by the same activity.
    property targetList : TFhirReferenceList{TFhirReference} read GetTargetList;
    property hasTargetList : boolean read GetHasTargetList;

    // Typed access to The period during which the activity occurred. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period during which the activity occurred.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to The instant of time at which the activity was recorded.
    property recorded : TFslDateTime read GetRecordedST write SetRecordedST;
    // The instant of time at which the activity was recorded.
    property recordedElement : TFhirInstant read FRecorded write SetRecorded;

    // The reason that the activity was taking place.
    property reasonList : TFhirCodeableConceptList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // Typed access to An activity is something that occurs over a period of time and acts upon or with entities; it may include consuming, processing, transforming, modifying, relocating, using, or generating entities. (defined for API consistency)
    property activity : TFhirCodeableConcept read FActivity write SetActivity;
    // An activity is something that occurs over a period of time and acts upon or with entities; it may include consuming, processing, transforming, modifying, relocating, using, or generating entities.
    property activityElement : TFhirCodeableConcept read FActivity write SetActivity;

    // Typed access to Where the activity occurred, if relevant. (defined for API consistency)
    property location : TFhirReference{TFhirLocation} read FLocation write SetLocation;
    // Where the activity occurred, if relevant.
    property locationElement : TFhirReference{TFhirLocation} read FLocation write SetLocation;

    // Policy or plan the activity was defined by. Typically, a single activity may have multiple applicable policy documents, such as patient consent, guarantor funding, etc.
    property policyList : TFhirUriList read GetPolicyList;
    property hasPolicyList : boolean read GetHasPolicyList;

    // An agent takes a role in an activity such that the agent can be assigned some degree of responsibility for the activity taking place. An agent can be a person, an organization, software, or other entities that may be ascribed responsibility.
    property agentList : TFhirProvenanceAgentList read GetAgentList;
    property hasAgentList : boolean read GetHasAgentList;

    // An entity used in this activity.
    property entityList : TFhirProvenanceEntityList read GetEntityList;
    property hasEntityList : boolean read GetHasEntityList;

    // A digital signature on the target Reference(s). The signer should match a Provenance.agent. The purpose of the signature is indicated.
    property signatureList : TFhirSignatureList read GetSignatureList;
    property hasSignatureList : boolean read GetHasSignatureList;

  end;

  TFhirProvenanceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirProvenanceList;
    function GetCurrent : TFhirProvenance;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirProvenanceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProvenance read GetCurrent;
  end;

  TFhirProvenanceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirProvenance;
    procedure SetItemN(index : Integer; value : TFhirProvenance);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirProvenanceList; Overload;
    function Clone : TFhirProvenanceList; Overload;
    function GetEnumerator : TFhirProvenanceListEnumerator;

    //  Add a FhirProvenance to the end of the list.
    function Append : TFhirProvenance;

    // Add an already existing FhirProvenance to the end of the list.
    procedure AddItem(value : TFhirProvenance); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirProvenance) : Integer;

    // Insert FhirProvenance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirProvenance;

    // Insert an existing FhirProvenance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirProvenance);

    // Get the iIndexth FhirProvenance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirProvenance);

    // The number of items in the collection
    function Item(index : Integer) : TFhirProvenance;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirProvenances[index : Integer] : TFhirProvenance read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PROVENANCE}

{$IFDEF FHIR_SUBSCRIPTION}

  // Details where to send notifications when resources are received that meet the criteria.
  TFhirSubscriptionChannel = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FEndpoint : TFhirUri;
    FPayload : TFhirString;
    FHeader : TFhirString;
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirSubscriptionChannelTypeEnum;
    Procedure SetType_ST(value : TFhirSubscriptionChannelTypeEnum);
    Procedure SetEndpoint(value : TFhirUri);
    Function GetEndpointST : String;
    Procedure SetEndpointST(value : String);
    Procedure SetPayload(value : TFhirString);
    Function GetPayloadST : String;
    Procedure SetPayloadST(value : String);
    Procedure SetHeader(value : TFhirString);
    Function GetHeaderST : String;
    Procedure SetHeaderST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubscriptionChannel; overload;
    function Clone : TFhirSubscriptionChannel; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The type of channel to send notifications on.
    property type_ : TFhirSubscriptionChannelTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The uri that describes the actual end-point to send messages to.
    property endpoint : String read GetEndpointST write SetEndpointST;
    // The uri that describes the actual end-point to send messages to.
    property endpointElement : TFhirUri read FEndpoint write SetEndpoint;

    // Typed access to The mime type to send the payload in - either application/xml+fhir, or application/json+fhir. If the mime type is blank, then there is no payload in the notification, just a notification.
    property payload : String read GetPayloadST write SetPayloadST;
    // The mime type to send the payload in - either application/xml+fhir, or application/json+fhir. If the mime type is blank, then there is no payload in the notification, just a notification.
    property payloadElement : TFhirString read FPayload write SetPayload;

    // Typed access to Additional headers / information to send as part of the notification.
    property header : String read GetHeaderST write SetHeaderST;
    // Additional headers / information to send as part of the notification.
    property headerElement : TFhirString read FHeader write SetHeader;

  end;

  TFhirSubscriptionChannelListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubscriptionChannelList;
    function GetCurrent : TFhirSubscriptionChannel;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubscriptionChannelList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubscriptionChannel read GetCurrent;
  end;

  TFhirSubscriptionChannelList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubscriptionChannel;
    procedure SetItemN(index : Integer; value : TFhirSubscriptionChannel);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubscriptionChannelList; Overload;
    function Clone : TFhirSubscriptionChannelList; Overload;
    function GetEnumerator : TFhirSubscriptionChannelListEnumerator;

    //  Add a FhirSubscriptionChannel to the end of the list.
    function Append : TFhirSubscriptionChannel;

    // Add an already existing FhirSubscriptionChannel to the end of the list.
    procedure AddItem(value : TFhirSubscriptionChannel); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubscriptionChannel) : Integer;

    // Insert FhirSubscriptionChannel before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubscriptionChannel;

    // Insert an existing FhirSubscriptionChannel before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubscriptionChannel);

    // Get the iIndexth FhirSubscriptionChannel. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubscriptionChannel);

    // The number of items in the collection
    function Item(index : Integer) : TFhirSubscriptionChannel;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirSubscriptionChannels[index : Integer] : TFhirSubscriptionChannel read GetItemN write SetItemN; default;
  End;

  // The subscription resource is used to define a push based subscription from a server to another system. Once a subscription is registered with the server, the server checks every resource that is created or updated, and if the resource matches the given criteria, it sends a message on the defined "channel" so that another system is able to take an appropriate action.
  TFhirSubscription = class (TFhirDomainResource)
  protected
    FCriteria : TFhirString;
    FcontactList : TFhirContactPointList;
    FReason : TFhirString;
    FStatus : TFhirEnum;
    FError : TFhirString;
    FChannel : TFhirSubscriptionChannel;
    FEnd_ : TFhirInstant;
    FtagList : TFhirCodingList;
    Procedure SetCriteria(value : TFhirString);
    Function GetCriteriaST : String;
    Procedure SetCriteriaST(value : String);
    function GetContactList : TFhirContactPointList;
    function GetHasContactList : Boolean;
    Procedure SetReason(value : TFhirString);
    Function GetReasonST : String;
    Procedure SetReasonST(value : String);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirSubscriptionStatusEnum;
    Procedure SetStatusST(value : TFhirSubscriptionStatusEnum);
    Procedure SetError(value : TFhirString);
    Function GetErrorST : String;
    Procedure SetErrorST(value : String);
    Procedure SetChannel(value : TFhirSubscriptionChannel);
    Procedure SetEnd_(value : TFhirInstant);
    Function GetEnd_ST : TFslDateTime;
    Procedure SetEnd_ST(value : TFslDateTime);
    function GetTagList : TFhirCodingList;
    function GetHasTagList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubscription; overload;
    function Clone : TFhirSubscription; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The rules that the server should use to determine when to generate notifications for this subscription.
    property criteria : String read GetCriteriaST write SetCriteriaST;
    // The rules that the server should use to determine when to generate notifications for this subscription.
    property criteriaElement : TFhirString read FCriteria write SetCriteria;

    // Contact details for a human to contact about the subscription. The primary use of this for system administrator troubleshooting.
    property contactList : TFhirContactPointList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A description of why this subscription is defined.
    property reason : String read GetReasonST write SetReasonST;
    // A description of why this subscription is defined.
    property reasonElement : TFhirString read FReason write SetReason;

    // The status of the subscription, which marks the server state for managing the subscription.
    property status : TFhirSubscriptionStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A record of the last error that occurred when the server processed a notification.
    property error : String read GetErrorST write SetErrorST;
    // A record of the last error that occurred when the server processed a notification.
    property errorElement : TFhirString read FError write SetError;

    // Typed access to Details where to send notifications when resources are received that meet the criteria. (defined for API consistency)
    property channel : TFhirSubscriptionChannel read FChannel write SetChannel;
    // Details where to send notifications when resources are received that meet the criteria.
    property channelElement : TFhirSubscriptionChannel read FChannel write SetChannel;

    // Typed access to The time for the server to turn the subscription off.
    property end_ : TFslDateTime read GetEnd_ST write SetEnd_ST;
    // The time for the server to turn the subscription off.
    property end_Element : TFhirInstant read FEnd_ write SetEnd_;

    // A tag to add to any resource that matches the criteria, after the subscription is processed.
    property tagList : TFhirCodingList read GetTagList;
    property hasTagList : boolean read GetHasTagList;

  end;

  TFhirSubscriptionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubscriptionList;
    function GetCurrent : TFhirSubscription;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubscriptionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubscription read GetCurrent;
  end;

  TFhirSubscriptionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubscription;
    procedure SetItemN(index : Integer; value : TFhirSubscription);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubscriptionList; Overload;
    function Clone : TFhirSubscriptionList; Overload;
    function GetEnumerator : TFhirSubscriptionListEnumerator;

    //  Add a FhirSubscription to the end of the list.
    function Append : TFhirSubscription;

    // Add an already existing FhirSubscription to the end of the list.
    procedure AddItem(value : TFhirSubscription); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubscription) : Integer;

    // Insert FhirSubscription before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubscription;

    // Insert an existing FhirSubscription before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubscription);

    // Get the iIndexth FhirSubscription. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubscription);

    // The number of items in the collection
    function Item(index : Integer) : TFhirSubscription;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirSubscriptions[index : Integer] : TFhirSubscription read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SUBSCRIPTION}

implementation

uses
  fhir2_utilities;

{$IFDEF FHIR_PARAMETERS}

{ TFhirParametersParameter }

constructor TFhirParametersParameter.Create;
begin
  inherited;
end;

destructor TFhirParametersParameter.Destroy;
begin
  FName.free;
  FValue.free;
  FResource.free;
  FPartList.Free;
  inherited;
end;

procedure TFhirParametersParameter.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirParametersParameter(oSource).nameElement.Clone;
  value := TFhirParametersParameter(oSource).value.Clone;
  resource := TFhirParametersParameter(oSource).resource.Clone;
  if (TFhirParametersParameter(oSource).FPartList = nil) then
  begin
    FPartList.free;
    FPartList := nil;
  end
  else
  begin
    if FPartList = nil then
      FPartList := TFhirParametersParameterList.Create;
    FPartList.Assign(TFhirParametersParameter(oSource).FPartList);
  end;
end;

procedure TFhirParametersParameter.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
  if (child_name = 'resource') Then
     list.add(self.link, 'resource', FResource.Link);
  if (child_name = 'part') Then
    list.addAll(self, 'part', FPartList);
end;

procedure TFhirParametersParameter.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value[x]', '*', false, TFhirType, FValue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'resource', 'Resource', false, TFhirResource, FResource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'part', '@Parameters.parameter', true, TFhirParametersParameter, FPartList.Link)){3};
end;

function TFhirParametersParameter.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['*'])) then
  begin
    Value := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'resource') then
  begin
    Resource := propValue as TFhirResource{4b};
    result := propValue;
  end
  else if (propName = 'part') then
  begin
    PartList.add(propValue as TFhirParametersParameter){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirParametersParameter.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'part') then PartList.insertItem(index, propValue as TFhirParametersParameter){2a}
  else inherited;
end;

function TFhirParametersParameter.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (isMatchingName(propName, 'value', ['*'])) then raise EFHIRException.create('Cannot make property Value'){4x}
  else if (propName = 'resource') then raise EFHIRException.create('Cannot make property Resource')
  else if (propName = 'part') then result := PartList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirParametersParameter.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'value[x]') then result := '*'
  else if (propName = 'resource') then result := 'Resource'
  else if (propName = 'part') then result := '@Parameters.parameter'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirParametersParameter.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (isMatchingName(propName, 'value', ['*'])) then ValueElement := nil{4x}
  else if (propName = 'resource') then ResourceElement := nil
  else if (propName = 'part') then deletePropertyValue('part', PartList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirParametersParameter.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (isMatchingName(propName, 'value', ['*'])) then ValueElement := new as TFhirType{4x}
  else if (propName = 'resource') then ResourceElement := new as TFhirResource{4}
  else if (propName = 'part') then replacePropertyValue('part', PartList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirParametersParameter.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'part') then PartList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirParametersParameter.fhirType : string;
begin
  result := 'parameter';
end;

function TFhirParametersParameter.Link : TFhirParametersParameter;
begin
  result := TFhirParametersParameter(inherited Link);
end;

function TFhirParametersParameter.Clone : TFhirParametersParameter;
begin
  result := TFhirParametersParameter(inherited Clone);
end;

function TFhirParametersParameter.equals(other : TObject) : boolean;
var
  o : TFhirParametersParameter;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirParametersParameter)) then
    result := false
  else
  begin
    o := TFhirParametersParameter(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(valueElement, o.valueElement, true) and
      compareDeep(resourceElement, o.resourceElement, true) and compareDeep(partList, o.partList, true);
  end;
end;

function TFhirParametersParameter.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FValue) and isEmptyProp(FResource) and isEmptyProp(FpartList);
end;

procedure TFhirParametersParameter.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('value[x]');
  fields.add('resource');
  fields.add('part');
end;

{ TFhirParametersParameter }

Procedure TFhirParametersParameter.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirParametersParameter.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirParametersParameter.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirParametersParameter.SetValue(value : TFhirType);
begin
  FValue.free;
  FValue := value;
end;

Procedure TFhirParametersParameter.SetResource(value : TFhirResource);
begin
  FResource.free;
  FResource := value;
end;

Function TFhirParametersParameter.GetPartList : TFhirParametersParameterList;
begin
  if FPartList = nil then
    FPartList := TFhirParametersParameterList.Create;
  result := FPartList;
end;

Function TFhirParametersParameter.GetHasPartList : boolean;
begin
  result := (FPartList <> nil) and (FPartList.count > 0);
end;

function TFhirParametersParameter.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FValue.sizeInBytes);
  inc(result, FResource.sizeInBytes);
  inc(result, FpartList.sizeInBytes);
end;

{ TFhirParametersParameterListEnumerator }

Constructor TFhirParametersParameterListEnumerator.Create(list : TFhirParametersParameterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirParametersParameterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirParametersParameterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirParametersParameterListEnumerator.GetCurrent : TFhirParametersParameter;
begin
  Result := FList[FIndex];
end;

function TFhirParametersParameterListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirParametersParameterList }
procedure TFhirParametersParameterList.AddItem(value: TFhirParametersParameter);
begin
  assert(value.ClassName = 'TFhirParametersParameter', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirParametersParameter');
  add(value);
end;

function TFhirParametersParameterList.Append: TFhirParametersParameter;
begin
  result := TFhirParametersParameter.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirParametersParameterList.ClearItems;
begin
  Clear;
end;

function TFhirParametersParameterList.GetEnumerator : TFhirParametersParameterListEnumerator;
begin
  result := TFhirParametersParameterListEnumerator.Create(self.link);
end;

function TFhirParametersParameterList.Clone: TFhirParametersParameterList;
begin
  result := TFhirParametersParameterList(inherited Clone);
end;

function TFhirParametersParameterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirParametersParameterList.GetItemN(index: Integer): TFhirParametersParameter;
begin
  result := TFhirParametersParameter(ObjectByIndex[index]);
end;

function TFhirParametersParameterList.ItemClass: TFslObjectClass;
begin
  result := TFhirParametersParameter;
end;
function TFhirParametersParameterList.IndexOf(value: TFhirParametersParameter): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirParametersParameterList.Insert(index: Integer): TFhirParametersParameter;
begin
  result := TFhirParametersParameter.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirParametersParameterList.InsertItem(index: Integer; value: TFhirParametersParameter);
begin
  assert(value is TFhirParametersParameter);
  Inherited Insert(index, value);
end;

function TFhirParametersParameterList.Item(index: Integer): TFhirParametersParameter;
begin
  result := TFhirParametersParameter(ObjectByIndex[index]);
end;

function TFhirParametersParameterList.Link: TFhirParametersParameterList;
begin
  result := TFhirParametersParameterList(inherited Link);
end;

procedure TFhirParametersParameterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirParametersParameterList.SetItemByIndex(index: Integer; value: TFhirParametersParameter);
begin
  assert(value is TFhirParametersParameter);
  FhirParametersParameters[index] := value;
end;

procedure TFhirParametersParameterList.SetItemN(index: Integer; value: TFhirParametersParameter);
begin
  assert(value is TFhirParametersParameter);
  ObjectByIndex[index] := value;
end;

{ TFhirParameters }

constructor TFhirParameters.Create;
begin
  inherited;
end;

destructor TFhirParameters.Destroy;
begin
  FParameterList.Free;
  inherited;
end;

function TFhirParameters.GetResourceType : TFhirResourceType;
begin
  result := frtParameters;
end;

procedure TFhirParameters.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirParameters(oSource).FParameterList = nil) then
  begin
    FParameterList.free;
    FParameterList := nil;
  end
  else
  begin
    if FParameterList = nil then
      FParameterList := TFhirParametersParameterList.Create;
    FParameterList.Assign(TFhirParameters(oSource).FParameterList);
  end;
end;

procedure TFhirParameters.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'parameter') Then
    list.addAll(self, 'parameter', FParameterList);
end;

procedure TFhirParameters.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'parameter', '', true, TFhirParametersParameter, FParameterList.Link)){3};
end;

function TFhirParameters.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'parameter') then
  begin
    ParameterList.add(propValue as TFhirParametersParameter){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirParameters.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'parameter') then ParameterList.insertItem(index, propValue as TFhirParametersParameter){2a}
  else inherited;
end;

function TFhirParameters.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'parameter') then result := ParameterList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirParameters.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'parameter') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirParameters.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'parameter') then deletePropertyValue('parameter', ParameterList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirParameters.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'parameter') then replacePropertyValue('parameter', ParameterList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirParameters.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'parameter') then ParameterList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirParameters.fhirType : string;
begin
  result := 'Parameters';
end;

function TFhirParameters.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FparameterList);
end;

function TFhirParameters.equals(other : TObject) : boolean;
var
  o : TFhirParameters;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirParameters)) then
    result := false
  else
  begin
    o := TFhirParameters(other);
    result := compareDeep(parameterList, o.parameterList, true);
  end;
end;

function TFhirParameters.Link : TFhirParameters;
begin
  result := TFhirParameters(inherited Link);
end;

function TFhirParameters.Clone : TFhirParameters;
begin
  result := TFhirParameters(inherited Clone);
end;

procedure TFhirParameters.listFieldsInOrder(fields : TStringList);
begin
  listResourceFieldsInOrder(fields);
  fields.add('parameter');
end;

{ TFhirParameters }

Function TFhirParameters.GetParameterList : TFhirParametersParameterList;
begin
  if FParameterList = nil then
    FParameterList := TFhirParametersParameterList.Create;
  result := FParameterList;
end;

Function TFhirParameters.GetHasParameterList : boolean;
begin
  result := (FParameterList <> nil) and (FParameterList.count > 0);
end;

function TFhirParameters.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FparameterList.sizeInBytes);
end;

{ TFhirParametersListEnumerator }

Constructor TFhirParametersListEnumerator.Create(list : TFhirParametersList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirParametersListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirParametersListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirParametersListEnumerator.GetCurrent : TFhirParameters;
begin
  Result := FList[FIndex];
end;

function TFhirParametersListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirParametersList }
procedure TFhirParametersList.AddItem(value: TFhirParameters);
begin
  assert(value.ClassName = 'TFhirParameters', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirParameters');
  add(value);
end;

function TFhirParametersList.Append: TFhirParameters;
begin
  result := TFhirParameters.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirParametersList.ClearItems;
begin
  Clear;
end;

function TFhirParametersList.GetEnumerator : TFhirParametersListEnumerator;
begin
  result := TFhirParametersListEnumerator.Create(self.link);
end;

function TFhirParametersList.Clone: TFhirParametersList;
begin
  result := TFhirParametersList(inherited Clone);
end;

function TFhirParametersList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirParametersList.GetItemN(index: Integer): TFhirParameters;
begin
  result := TFhirParameters(ObjectByIndex[index]);
end;

function TFhirParametersList.ItemClass: TFslObjectClass;
begin
  result := TFhirParameters;
end;
function TFhirParametersList.IndexOf(value: TFhirParameters): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirParametersList.Insert(index: Integer): TFhirParameters;
begin
  result := TFhirParameters.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirParametersList.InsertItem(index: Integer; value: TFhirParameters);
begin
  assert(value is TFhirParameters);
  Inherited Insert(index, value);
end;

function TFhirParametersList.Item(index: Integer): TFhirParameters;
begin
  result := TFhirParameters(ObjectByIndex[index]);
end;

function TFhirParametersList.Link: TFhirParametersList;
begin
  result := TFhirParametersList(inherited Link);
end;

procedure TFhirParametersList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirParametersList.SetItemByIndex(index: Integer; value: TFhirParameters);
begin
  assert(value is TFhirParameters);
  FhirParameters[index] := value;
end;

procedure TFhirParametersList.SetItemN(index: Integer; value: TFhirParameters);
begin
  assert(value is TFhirParameters);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PARAMETERS}

{$IFDEF FHIR_AUDITEVENT}

{ TFhirAuditEventEvent }

constructor TFhirAuditEventEvent.Create;
begin
  inherited;
end;

destructor TFhirAuditEventEvent.Destroy;
begin
  FType_.free;
  FSubtypeList.Free;
  FAction.free;
  FDateTime.free;
  FOutcome.free;
  FOutcomeDesc.free;
  FPurposeOfEventList.Free;
  inherited;
end;

procedure TFhirAuditEventEvent.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirAuditEventEvent(oSource).type_.Clone;
  if (TFhirAuditEventEvent(oSource).FSubtypeList = nil) then
  begin
    FSubtypeList.free;
    FSubtypeList := nil;
  end
  else
  begin
    if FSubtypeList = nil then
      FSubtypeList := TFhirCodingList.Create;
    FSubtypeList.Assign(TFhirAuditEventEvent(oSource).FSubtypeList);
  end;
  FAction := TFhirAuditEventEvent(oSource).FAction.Link;
  dateTimeElement := TFhirAuditEventEvent(oSource).dateTimeElement.Clone;
  FOutcome := TFhirAuditEventEvent(oSource).FOutcome.Link;
  outcomeDescElement := TFhirAuditEventEvent(oSource).outcomeDescElement.Clone;
  if (TFhirAuditEventEvent(oSource).FPurposeOfEventList = nil) then
  begin
    FPurposeOfEventList.free;
    FPurposeOfEventList := nil;
  end
  else
  begin
    if FPurposeOfEventList = nil then
      FPurposeOfEventList := TFhirCodingList.Create;
    FPurposeOfEventList.Assign(TFhirAuditEventEvent(oSource).FPurposeOfEventList);
  end;
end;

procedure TFhirAuditEventEvent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subtype') Then
    list.addAll(self, 'subtype', FSubtypeList);
  if (child_name = 'action') Then
     list.add(self.link, 'action', FAction.Link);
  if (child_name = 'dateTime') Then
     list.add(self.link, 'dateTime', FDateTime.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'outcomeDesc') Then
     list.add(self.link, 'outcomeDesc', FOutcomeDesc.Link);
  if (child_name = 'purposeOfEvent') Then
    list.addAll(self, 'purposeOfEvent', FPurposeOfEventList);
end;

procedure TFhirAuditEventEvent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', false, TFhirCoding, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subtype', 'Coding', true, TFhirCoding, FSubtypeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'action', 'code', false, TFHIREnum, FAction.Link));{1}
  oList.add(TFHIRProperty.create(self, 'dateTime', 'instant', false, TFhirInstant, FDateTime.Link));{2}
  oList.add(TFHIRProperty.create(self, 'outcome', 'code', false, TFHIREnum, FOutcome.Link));{1}
  oList.add(TFHIRProperty.create(self, 'outcomeDesc', 'string', false, TFhirString, FOutcomeDesc.Link));{2}
  oList.add(TFHIRProperty.create(self, 'purposeOfEvent', 'Coding', true, TFhirCoding, FPurposeOfEventList.Link)){3};
end;

function TFhirAuditEventEvent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'subtype') then
  begin
    SubtypeList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionElement := asEnum(SYSTEMS_TFhirAuditEventActionEnum, CODES_TFhirAuditEventActionEnum, propValue);
    result := propValue
  end
  else if (propName = 'dateTime') then
  begin
    DateTimeElement := asInstant(propValue){5a};
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    OutcomeElement := asEnum(SYSTEMS_TFhirAuditEventOutcomeEnum, CODES_TFhirAuditEventOutcomeEnum, propValue);
    result := propValue
  end
  else if (propName = 'outcomeDesc') then
  begin
    OutcomeDescElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'purposeOfEvent') then
  begin
    PurposeOfEventList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAuditEventEvent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'subtype') then SubtypeList.insertItem(index, propValue as TFhirCoding){2a}
  else if (propName = 'purposeOfEvent') then PurposeOfEventList.insertItem(index, propValue as TFhirCoding){2a}
  else inherited;
end;

function TFhirAuditEventEvent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCoding.create(){4b}
  else if (propName = 'subtype') then result := SubtypeList.new(){2}
  else if (propName = 'dateTime') then result := TFhirInstant.create() {5b}
  else if (propName = 'outcomeDesc') then result := TFhirString.create() {5b}
  else if (propName = 'purposeOfEvent') then result := PurposeOfEventList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAuditEventEvent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'Coding'
  else if (propName = 'subtype') then result := 'Coding'
  else if (propName = 'action') then result := 'code'
  else if (propName = 'dateTime') then result := 'instant'
  else if (propName = 'outcome') then result := 'code'
  else if (propName = 'outcomeDesc') then result := 'string'
  else if (propName = 'purposeOfEvent') then result := 'Coding'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAuditEventEvent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'subtype') then deletePropertyValue('subtype', SubtypeList, value) {2}
  else if (propName = 'action') then ActionElement := nil
  else if (propName = 'dateTime') then DateTimeElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'outcomeDesc') then OutcomeDescElement := nil
  else if (propName = 'purposeOfEvent') then deletePropertyValue('purposeOfEvent', PurposeOfEventList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAuditEventEvent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCoding{4}
  else if (propName = 'subtype') then replacePropertyValue('subtype', SubtypeList, existing, new) {2}
  else if (propName = 'action') then ActionElement := asEnum(SYSTEMS_TFhirAuditEventActionEnum, CODES_TFhirAuditEventActionEnum, new){4}
  else if (propName = 'dateTime') then DateTimeElement := asInstant(new){5b}
  else if (propName = 'outcome') then OutcomeElement := asEnum(SYSTEMS_TFhirAuditEventOutcomeEnum, CODES_TFhirAuditEventOutcomeEnum, new){4}
  else if (propName = 'outcomeDesc') then OutcomeDescElement := asString(new){5b}
  else if (propName = 'purposeOfEvent') then replacePropertyValue('purposeOfEvent', PurposeOfEventList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAuditEventEvent.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'subtype') then SubtypeList.move(source, destination){2a}
  else if (propName = 'purposeOfEvent') then PurposeOfEventList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAuditEventEvent.fhirType : string;
begin
  result := 'event';
end;

function TFhirAuditEventEvent.Link : TFhirAuditEventEvent;
begin
  result := TFhirAuditEventEvent(inherited Link);
end;

function TFhirAuditEventEvent.Clone : TFhirAuditEventEvent;
begin
  result := TFhirAuditEventEvent(inherited Clone);
end;

function TFhirAuditEventEvent.equals(other : TObject) : boolean;
var
  o : TFhirAuditEventEvent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAuditEventEvent)) then
    result := false
  else
  begin
    o := TFhirAuditEventEvent(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(subtypeList, o.subtypeList, true) and
      compareDeep(actionElement, o.actionElement, true) and compareDeep(dateTimeElement, o.dateTimeElement, true) and
      compareDeep(outcomeElement, o.outcomeElement, true) and compareDeep(outcomeDescElement, o.outcomeDescElement, true) and
      compareDeep(purposeOfEventList, o.purposeOfEventList, true);
  end;
end;

function TFhirAuditEventEvent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FsubtypeList) and isEmptyProp(FAction) and isEmptyProp(FDateTime) and isEmptyProp(FOutcome) and isEmptyProp(FOutcomeDesc) and isEmptyProp(FpurposeOfEventList);
end;

procedure TFhirAuditEventEvent.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('subtype');
  fields.add('action');
  fields.add('dateTime');
  fields.add('outcome');
  fields.add('outcomeDesc');
  fields.add('purposeOfEvent');
end;

{ TFhirAuditEventEvent }

Procedure TFhirAuditEventEvent.SetType_(value : TFhirCoding);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirAuditEventEvent.GetSubtypeList : TFhirCodingList;
begin
  if FSubtypeList = nil then
    FSubtypeList := TFhirCodingList.Create;
  result := FSubtypeList;
end;

Function TFhirAuditEventEvent.GetHasSubtypeList : boolean;
begin
  result := (FSubtypeList <> nil) and (FSubtypeList.count > 0);
end;

Procedure TFhirAuditEventEvent.SetAction(value : TFhirEnum);
begin
  FAction.free;
  FAction := value;
end;

Function TFhirAuditEventEvent.GetActionST : TFhirAuditEventActionEnum;
begin
  if FAction = nil then
    result := TFhirAuditEventActionEnum(0)
  else
    result := TFhirAuditEventActionEnum(StringArrayIndexOfSensitive(CODES_TFhirAuditEventActionEnum, FAction.value));
end;

Procedure TFhirAuditEventEvent.SetActionST(value : TFhirAuditEventActionEnum);
begin
  if ord(value) = 0 then
    ActionElement := nil
  else
    ActionElement := TFhirEnum.create(SYSTEMS_TFhirAuditEventActionEnum[value], CODES_TFhirAuditEventActionEnum[value]);
end;

Procedure TFhirAuditEventEvent.SetDateTime(value : TFhirInstant);
begin
  FDateTime.free;
  FDateTime := value;
end;

Function TFhirAuditEventEvent.GetDateTimeST : TFslDateTime;
begin
  if FDateTime = nil then
    result := TFslDateTime.makeNull
  else
    result := FDateTime.value;
end;

Procedure TFhirAuditEventEvent.SetDateTimeST(value : TFslDateTime);
begin
  if FDateTime = nil then
    FDateTime := TFhirInstant.create;
  FDateTime.value := value
end;

Procedure TFhirAuditEventEvent.SetOutcome(value : TFhirEnum);
begin
  FOutcome.free;
  FOutcome := value;
end;

Function TFhirAuditEventEvent.GetOutcomeST : TFhirAuditEventOutcomeEnum;
begin
  if FOutcome = nil then
    result := TFhirAuditEventOutcomeEnum(0)
  else
    result := TFhirAuditEventOutcomeEnum(StringArrayIndexOfSensitive(CODES_TFhirAuditEventOutcomeEnum, FOutcome.value));
end;

Procedure TFhirAuditEventEvent.SetOutcomeST(value : TFhirAuditEventOutcomeEnum);
begin
  if ord(value) = 0 then
    OutcomeElement := nil
  else
    OutcomeElement := TFhirEnum.create(SYSTEMS_TFhirAuditEventOutcomeEnum[value], CODES_TFhirAuditEventOutcomeEnum[value]);
end;

Procedure TFhirAuditEventEvent.SetOutcomeDesc(value : TFhirString);
begin
  FOutcomeDesc.free;
  FOutcomeDesc := value;
end;

Function TFhirAuditEventEvent.GetOutcomeDescST : String;
begin
  if FOutcomeDesc = nil then
    result := ''
  else
    result := FOutcomeDesc.value;
end;

Procedure TFhirAuditEventEvent.SetOutcomeDescST(value : String);
begin
  if value <> '' then
  begin
    if FOutcomeDesc = nil then
      FOutcomeDesc := TFhirString.create;
    FOutcomeDesc.value := value
  end
  else if FOutcomeDesc <> nil then
    FOutcomeDesc.value := '';
end;

Function TFhirAuditEventEvent.GetPurposeOfEventList : TFhirCodingList;
begin
  if FPurposeOfEventList = nil then
    FPurposeOfEventList := TFhirCodingList.Create;
  result := FPurposeOfEventList;
end;

Function TFhirAuditEventEvent.GetHasPurposeOfEventList : boolean;
begin
  result := (FPurposeOfEventList <> nil) and (FPurposeOfEventList.count > 0);
end;

function TFhirAuditEventEvent.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FsubtypeList.sizeInBytes);
  inc(result, FAction.sizeInBytes);
  inc(result, FDateTime.sizeInBytes);
  inc(result, FOutcome.sizeInBytes);
  inc(result, FOutcomeDesc.sizeInBytes);
  inc(result, FpurposeOfEventList.sizeInBytes);
end;

{ TFhirAuditEventEventListEnumerator }

Constructor TFhirAuditEventEventListEnumerator.Create(list : TFhirAuditEventEventList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAuditEventEventListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAuditEventEventListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAuditEventEventListEnumerator.GetCurrent : TFhirAuditEventEvent;
begin
  Result := FList[FIndex];
end;

function TFhirAuditEventEventListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAuditEventEventList }
procedure TFhirAuditEventEventList.AddItem(value: TFhirAuditEventEvent);
begin
  assert(value.ClassName = 'TFhirAuditEventEvent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAuditEventEvent');
  add(value);
end;

function TFhirAuditEventEventList.Append: TFhirAuditEventEvent;
begin
  result := TFhirAuditEventEvent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventEventList.ClearItems;
begin
  Clear;
end;

function TFhirAuditEventEventList.GetEnumerator : TFhirAuditEventEventListEnumerator;
begin
  result := TFhirAuditEventEventListEnumerator.Create(self.link);
end;

function TFhirAuditEventEventList.Clone: TFhirAuditEventEventList;
begin
  result := TFhirAuditEventEventList(inherited Clone);
end;

function TFhirAuditEventEventList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAuditEventEventList.GetItemN(index: Integer): TFhirAuditEventEvent;
begin
  result := TFhirAuditEventEvent(ObjectByIndex[index]);
end;

function TFhirAuditEventEventList.ItemClass: TFslObjectClass;
begin
  result := TFhirAuditEventEvent;
end;
function TFhirAuditEventEventList.IndexOf(value: TFhirAuditEventEvent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAuditEventEventList.Insert(index: Integer): TFhirAuditEventEvent;
begin
  result := TFhirAuditEventEvent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventEventList.InsertItem(index: Integer; value: TFhirAuditEventEvent);
begin
  assert(value is TFhirAuditEventEvent);
  Inherited Insert(index, value);
end;

function TFhirAuditEventEventList.Item(index: Integer): TFhirAuditEventEvent;
begin
  result := TFhirAuditEventEvent(ObjectByIndex[index]);
end;

function TFhirAuditEventEventList.Link: TFhirAuditEventEventList;
begin
  result := TFhirAuditEventEventList(inherited Link);
end;

procedure TFhirAuditEventEventList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAuditEventEventList.SetItemByIndex(index: Integer; value: TFhirAuditEventEvent);
begin
  assert(value is TFhirAuditEventEvent);
  FhirAuditEventEvents[index] := value;
end;

procedure TFhirAuditEventEventList.SetItemN(index: Integer; value: TFhirAuditEventEvent);
begin
  assert(value is TFhirAuditEventEvent);
  ObjectByIndex[index] := value;
end;

{ TFhirAuditEventParticipant }

constructor TFhirAuditEventParticipant.Create;
begin
  inherited;
end;

destructor TFhirAuditEventParticipant.Destroy;
begin
  FRoleList.Free;
  FReference.free;
  FUserId.free;
  FAltId.free;
  FName.free;
  FRequestor.free;
  FLocation.free;
  FPolicyList.Free;
  FMedia.free;
  FNetwork.free;
  FPurposeOfUseList.Free;
  inherited;
end;

procedure TFhirAuditEventParticipant.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirAuditEventParticipant(oSource).FRoleList = nil) then
  begin
    FRoleList.free;
    FRoleList := nil;
  end
  else
  begin
    if FRoleList = nil then
      FRoleList := TFhirCodeableConceptList.Create;
    FRoleList.Assign(TFhirAuditEventParticipant(oSource).FRoleList);
  end;
  reference := TFhirAuditEventParticipant(oSource).reference.Clone;
  userId := TFhirAuditEventParticipant(oSource).userId.Clone;
  altIdElement := TFhirAuditEventParticipant(oSource).altIdElement.Clone;
  nameElement := TFhirAuditEventParticipant(oSource).nameElement.Clone;
  requestorElement := TFhirAuditEventParticipant(oSource).requestorElement.Clone;
  location := TFhirAuditEventParticipant(oSource).location.Clone;
  if (TFhirAuditEventParticipant(oSource).FPolicyList = nil) then
  begin
    FPolicyList.free;
    FPolicyList := nil;
  end
  else
  begin
    if FPolicyList = nil then
      FPolicyList := TFhirUriList.Create;
    FPolicyList.Assign(TFhirAuditEventParticipant(oSource).FPolicyList);
  end;
  media := TFhirAuditEventParticipant(oSource).media.Clone;
  network := TFhirAuditEventParticipant(oSource).network.Clone;
  if (TFhirAuditEventParticipant(oSource).FPurposeOfUseList = nil) then
  begin
    FPurposeOfUseList.free;
    FPurposeOfUseList := nil;
  end
  else
  begin
    if FPurposeOfUseList = nil then
      FPurposeOfUseList := TFhirCodingList.Create;
    FPurposeOfUseList.Assign(TFhirAuditEventParticipant(oSource).FPurposeOfUseList);
  end;
end;

procedure TFhirAuditEventParticipant.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'role') Then
    list.addAll(self, 'role', FRoleList);
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
  if (child_name = 'userId') Then
     list.add(self.link, 'userId', FUserId.Link);
  if (child_name = 'altId') Then
     list.add(self.link, 'altId', FAltId.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'requestor') Then
     list.add(self.link, 'requestor', FRequestor.Link);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'policy') Then
    list.addAll(self, 'policy', FPolicyList);
  if (child_name = 'media') Then
     list.add(self.link, 'media', FMedia.Link);
  if (child_name = 'network') Then
     list.add(self.link, 'network', FNetwork.Link);
  if (child_name = 'purposeOfUse') Then
    list.addAll(self, 'purposeOfUse', FPurposeOfUseList);
end;

procedure TFhirAuditEventParticipant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', true, TFhirCodeableConcept, FRoleList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reference', 'Reference(Practitioner|Organization|Device|Patient|RelatedPerson)', false, TFhirReference{Resource}, FReference.Link));{2}
  oList.add(TFHIRProperty.create(self, 'userId', 'Identifier', false, TFhirIdentifier, FUserId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'altId', 'string', false, TFhirString, FAltId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requestor', 'boolean', false, TFhirBoolean, FRequestor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'location', 'Reference(Location)', false, TFhirReference{TFhirLocation}, FLocation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'policy', 'uri', true, TFhirUri, FPolicyList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'media', 'Coding', false, TFhirCoding, FMedia.Link));{2}
  oList.add(TFHIRProperty.create(self, 'network', '', false, TFhirAuditEventParticipantNetwork, FNetwork.Link));{2}
  oList.add(TFHIRProperty.create(self, 'purposeOfUse', 'Coding', true, TFhirCoding, FPurposeOfUseList.Link)){3};
end;

function TFhirAuditEventParticipant.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'role') then
  begin
    RoleList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'reference') then
  begin
    Reference := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'userId') then
  begin
    UserId := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'altId') then
  begin
    AltIdElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'requestor') then
  begin
    RequestorElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirReference{TFhirLocation}{4b};
    result := propValue;
  end
  else if (propName = 'policy') then
  begin
    PolicyList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'media') then
  begin
    Media := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'network') then
  begin
    Network := propValue as TFhirAuditEventParticipantNetwork{4b};
    result := propValue;
  end
  else if (propName = 'purposeOfUse') then
  begin
    PurposeOfUseList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAuditEventParticipant.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'role') then RoleList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'policy') then PolicyList.insertItem(index, asUri(propValue)){2}
  else if (propName = 'purposeOfUse') then PurposeOfUseList.insertItem(index, propValue as TFhirCoding){2a}
  else inherited;
end;

function TFhirAuditEventParticipant.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'role') then result := RoleList.new(){2}
  else if (propName = 'reference') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'userId') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'altId') then result := TFhirString.create() {5b}
  else if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'requestor') then result := TFhirBoolean.create() {5b}
  else if (propName = 'location') then result := TFhirReference{TFhirLocation}.create(){4b}
  else if (propName = 'policy') then result := PolicyList.new(){2}
  else if (propName = 'media') then result := TFhirCoding.create(){4b}
  else if (propName = 'network') then result := TFhirAuditEventParticipantNetwork.create(){4b}
  else if (propName = 'purposeOfUse') then result := PurposeOfUseList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAuditEventParticipant.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'reference') then result := 'Reference'
  else if (propName = 'userId') then result := 'Identifier'
  else if (propName = 'altId') then result := 'string'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'requestor') then result := 'boolean'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'policy') then result := 'uri'
  else if (propName = 'media') then result := 'Coding'
  else if (propName = 'network') then result := ''
  else if (propName = 'purposeOfUse') then result := 'Coding'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAuditEventParticipant.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'role') then deletePropertyValue('role', RoleList, value) {2}
  else if (propName = 'reference') then ReferenceElement := nil
  else if (propName = 'userId') then UserIdElement := nil
  else if (propName = 'altId') then AltIdElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'requestor') then RequestorElement := nil
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'policy') then deletePropertyValue('policy', PolicyList, value) {2}
  else if (propName = 'media') then MediaElement := nil
  else if (propName = 'network') then NetworkElement := nil
  else if (propName = 'purposeOfUse') then deletePropertyValue('purposeOfUse', PurposeOfUseList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAuditEventParticipant.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'role') then replacePropertyValue('role', RoleList, existing, new) {2}
  else if (propName = 'reference') then ReferenceElement := new as TFhirReference{Resource}{4}
  else if (propName = 'userId') then UserIdElement := new as TFhirIdentifier{4}
  else if (propName = 'altId') then AltIdElement := asString(new){5b}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'requestor') then RequestorElement := asBoolean(new){5b}
  else if (propName = 'location') then LocationElement := new as TFhirReference{TFhirLocation}{4}
  else if (propName = 'policy') then replacePropertyValue('policy', PolicyList, existing, new) {2}
  else if (propName = 'media') then MediaElement := new as TFhirCoding{4}
  else if (propName = 'network') then NetworkElement := new as TFhirAuditEventParticipantNetwork{4}
  else if (propName = 'purposeOfUse') then replacePropertyValue('purposeOfUse', PurposeOfUseList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAuditEventParticipant.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'role') then RoleList.move(source, destination){2a}
  else if (propName = 'policy') then PolicyList.move(source, destination){2}
  else if (propName = 'purposeOfUse') then PurposeOfUseList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAuditEventParticipant.fhirType : string;
begin
  result := 'participant';
end;

function TFhirAuditEventParticipant.Link : TFhirAuditEventParticipant;
begin
  result := TFhirAuditEventParticipant(inherited Link);
end;

function TFhirAuditEventParticipant.Clone : TFhirAuditEventParticipant;
begin
  result := TFhirAuditEventParticipant(inherited Clone);
end;

function TFhirAuditEventParticipant.equals(other : TObject) : boolean;
var
  o : TFhirAuditEventParticipant;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAuditEventParticipant)) then
    result := false
  else
  begin
    o := TFhirAuditEventParticipant(other);
    result := compareDeep(roleList, o.roleList, true) and compareDeep(referenceElement, o.referenceElement, true) and
      compareDeep(userIdElement, o.userIdElement, true) and compareDeep(altIdElement, o.altIdElement, true) and
      compareDeep(nameElement, o.nameElement, true) and compareDeep(requestorElement, o.requestorElement, true) and
      compareDeep(locationElement, o.locationElement, true) and compareDeep(policyList, o.policyList, true) and
      compareDeep(mediaElement, o.mediaElement, true) and compareDeep(networkElement, o.networkElement, true) and
      compareDeep(purposeOfUseList, o.purposeOfUseList, true);
  end;
end;

function TFhirAuditEventParticipant.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FroleList) and isEmptyProp(FReference) and isEmptyProp(FUserId) and isEmptyProp(FAltId) and isEmptyProp(FName) and isEmptyProp(FRequestor) and isEmptyProp(FLocation) and isEmptyProp(FpolicyList) and isEmptyProp(FMedia) and isEmptyProp(FNetwork) and isEmptyProp(FpurposeOfUseList);
end;

procedure TFhirAuditEventParticipant.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('role');
  fields.add('reference');
  fields.add('userId');
  fields.add('altId');
  fields.add('name');
  fields.add('requestor');
  fields.add('location');
  fields.add('policy');
  fields.add('media');
  fields.add('network');
  fields.add('purposeOfUse');
end;

{ TFhirAuditEventParticipant }

Function TFhirAuditEventParticipant.GetRoleList : TFhirCodeableConceptList;
begin
  if FRoleList = nil then
    FRoleList := TFhirCodeableConceptList.Create;
  result := FRoleList;
end;

Function TFhirAuditEventParticipant.GetHasRoleList : boolean;
begin
  result := (FRoleList <> nil) and (FRoleList.count > 0);
end;

Procedure TFhirAuditEventParticipant.SetReference(value : TFhirReference{Resource});
begin
  FReference.free;
  FReference := value;
end;

Procedure TFhirAuditEventParticipant.SetUserId(value : TFhirIdentifier);
begin
  FUserId.free;
  FUserId := value;
end;

Procedure TFhirAuditEventParticipant.SetAltId(value : TFhirString);
begin
  FAltId.free;
  FAltId := value;
end;

Function TFhirAuditEventParticipant.GetAltIdST : String;
begin
  if FAltId = nil then
    result := ''
  else
    result := FAltId.value;
end;

Procedure TFhirAuditEventParticipant.SetAltIdST(value : String);
begin
  if value <> '' then
  begin
    if FAltId = nil then
      FAltId := TFhirString.create;
    FAltId.value := value
  end
  else if FAltId <> nil then
    FAltId.value := '';
end;

Procedure TFhirAuditEventParticipant.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirAuditEventParticipant.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirAuditEventParticipant.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirAuditEventParticipant.SetRequestor(value : TFhirBoolean);
begin
  FRequestor.free;
  FRequestor := value;
end;

Function TFhirAuditEventParticipant.GetRequestorST : Boolean;
begin
  if FRequestor = nil then
    result := false
  else
    result := FRequestor.value;
end;

Procedure TFhirAuditEventParticipant.SetRequestorST(value : Boolean);
begin
  if FRequestor = nil then
    FRequestor := TFhirBoolean.create;
  FRequestor.value := value
end;

Procedure TFhirAuditEventParticipant.SetLocation(value : TFhirReference{TFhirLocation});
begin
  FLocation.free;
  FLocation := value;
end;

Function TFhirAuditEventParticipant.GetPolicyList : TFhirUriList;
begin
  if FPolicyList = nil then
    FPolicyList := TFhirUriList.Create;
  result := FPolicyList;
end;

Function TFhirAuditEventParticipant.GetHasPolicyList : boolean;
begin
  result := (FPolicyList <> nil) and (FPolicyList.count > 0);
end;

Procedure TFhirAuditEventParticipant.SetMedia(value : TFhirCoding);
begin
  FMedia.free;
  FMedia := value;
end;

Procedure TFhirAuditEventParticipant.SetNetwork(value : TFhirAuditEventParticipantNetwork);
begin
  FNetwork.free;
  FNetwork := value;
end;

Function TFhirAuditEventParticipant.GetPurposeOfUseList : TFhirCodingList;
begin
  if FPurposeOfUseList = nil then
    FPurposeOfUseList := TFhirCodingList.Create;
  result := FPurposeOfUseList;
end;

Function TFhirAuditEventParticipant.GetHasPurposeOfUseList : boolean;
begin
  result := (FPurposeOfUseList <> nil) and (FPurposeOfUseList.count > 0);
end;

function TFhirAuditEventParticipant.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FroleList.sizeInBytes);
  inc(result, FReference.sizeInBytes);
  inc(result, FUserId.sizeInBytes);
  inc(result, FAltId.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FRequestor.sizeInBytes);
  inc(result, FLocation.sizeInBytes);
  inc(result, FpolicyList.sizeInBytes);
  inc(result, FMedia.sizeInBytes);
  inc(result, FNetwork.sizeInBytes);
  inc(result, FpurposeOfUseList.sizeInBytes);
end;

{ TFhirAuditEventParticipantListEnumerator }

Constructor TFhirAuditEventParticipantListEnumerator.Create(list : TFhirAuditEventParticipantList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAuditEventParticipantListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAuditEventParticipantListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAuditEventParticipantListEnumerator.GetCurrent : TFhirAuditEventParticipant;
begin
  Result := FList[FIndex];
end;

function TFhirAuditEventParticipantListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAuditEventParticipantList }
procedure TFhirAuditEventParticipantList.AddItem(value: TFhirAuditEventParticipant);
begin
  assert(value.ClassName = 'TFhirAuditEventParticipant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAuditEventParticipant');
  add(value);
end;

function TFhirAuditEventParticipantList.Append: TFhirAuditEventParticipant;
begin
  result := TFhirAuditEventParticipant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventParticipantList.ClearItems;
begin
  Clear;
end;

function TFhirAuditEventParticipantList.GetEnumerator : TFhirAuditEventParticipantListEnumerator;
begin
  result := TFhirAuditEventParticipantListEnumerator.Create(self.link);
end;

function TFhirAuditEventParticipantList.Clone: TFhirAuditEventParticipantList;
begin
  result := TFhirAuditEventParticipantList(inherited Clone);
end;

function TFhirAuditEventParticipantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAuditEventParticipantList.GetItemN(index: Integer): TFhirAuditEventParticipant;
begin
  result := TFhirAuditEventParticipant(ObjectByIndex[index]);
end;

function TFhirAuditEventParticipantList.ItemClass: TFslObjectClass;
begin
  result := TFhirAuditEventParticipant;
end;
function TFhirAuditEventParticipantList.IndexOf(value: TFhirAuditEventParticipant): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAuditEventParticipantList.Insert(index: Integer): TFhirAuditEventParticipant;
begin
  result := TFhirAuditEventParticipant.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventParticipantList.InsertItem(index: Integer; value: TFhirAuditEventParticipant);
begin
  assert(value is TFhirAuditEventParticipant);
  Inherited Insert(index, value);
end;

function TFhirAuditEventParticipantList.Item(index: Integer): TFhirAuditEventParticipant;
begin
  result := TFhirAuditEventParticipant(ObjectByIndex[index]);
end;

function TFhirAuditEventParticipantList.Link: TFhirAuditEventParticipantList;
begin
  result := TFhirAuditEventParticipantList(inherited Link);
end;

procedure TFhirAuditEventParticipantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAuditEventParticipantList.SetItemByIndex(index: Integer; value: TFhirAuditEventParticipant);
begin
  assert(value is TFhirAuditEventParticipant);
  FhirAuditEventParticipants[index] := value;
end;

procedure TFhirAuditEventParticipantList.SetItemN(index: Integer; value: TFhirAuditEventParticipant);
begin
  assert(value is TFhirAuditEventParticipant);
  ObjectByIndex[index] := value;
end;

{ TFhirAuditEventParticipantNetwork }

constructor TFhirAuditEventParticipantNetwork.Create;
begin
  inherited;
end;

destructor TFhirAuditEventParticipantNetwork.Destroy;
begin
  FAddress.free;
  FType_.free;
  inherited;
end;

procedure TFhirAuditEventParticipantNetwork.Assign(oSource : TFslObject);
begin
  inherited;
  addressElement := TFhirAuditEventParticipantNetwork(oSource).addressElement.Clone;
  FType_ := TFhirAuditEventParticipantNetwork(oSource).FType_.Link;
end;

procedure TFhirAuditEventParticipantNetwork.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'address') Then
     list.add(self.link, 'address', FAddress.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
end;

procedure TFhirAuditEventParticipantNetwork.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'address', 'string', false, TFhirString, FAddress.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
end;

function TFhirAuditEventParticipantNetwork.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'address') then
  begin
    AddressElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirNetworkTypeEnum, CODES_TFhirNetworkTypeEnum, propValue);
    result := propValue
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAuditEventParticipantNetwork.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirAuditEventParticipantNetwork.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'address') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAuditEventParticipantNetwork.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'address') then result := 'string'
  else if (propName = 'type') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAuditEventParticipantNetwork.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'address') then AddressElement := nil
  else if (propName = 'type') then Type_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAuditEventParticipantNetwork.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'address') then AddressElement := asString(new){5b}
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirNetworkTypeEnum, CODES_TFhirNetworkTypeEnum, new){4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAuditEventParticipantNetwork.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirAuditEventParticipantNetwork.fhirType : string;
begin
  result := 'network';
end;

function TFhirAuditEventParticipantNetwork.Link : TFhirAuditEventParticipantNetwork;
begin
  result := TFhirAuditEventParticipantNetwork(inherited Link);
end;

function TFhirAuditEventParticipantNetwork.Clone : TFhirAuditEventParticipantNetwork;
begin
  result := TFhirAuditEventParticipantNetwork(inherited Clone);
end;

function TFhirAuditEventParticipantNetwork.equals(other : TObject) : boolean;
var
  o : TFhirAuditEventParticipantNetwork;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAuditEventParticipantNetwork)) then
    result := false
  else
  begin
    o := TFhirAuditEventParticipantNetwork(other);
    result := compareDeep(addressElement, o.addressElement, true) and compareDeep(type_Element, o.type_Element, true);
  end;
end;

function TFhirAuditEventParticipantNetwork.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAddress) and isEmptyProp(FType_);
end;

procedure TFhirAuditEventParticipantNetwork.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('address');
  fields.add('type');
end;

{ TFhirAuditEventParticipantNetwork }

Procedure TFhirAuditEventParticipantNetwork.SetAddress(value : TFhirString);
begin
  FAddress.free;
  FAddress := value;
end;

Function TFhirAuditEventParticipantNetwork.GetAddressST : String;
begin
  if FAddress = nil then
    result := ''
  else
    result := FAddress.value;
end;

Procedure TFhirAuditEventParticipantNetwork.SetAddressST(value : String);
begin
  if value <> '' then
  begin
    if FAddress = nil then
      FAddress := TFhirString.create;
    FAddress.value := value
  end
  else if FAddress <> nil then
    FAddress.value := '';
end;

Procedure TFhirAuditEventParticipantNetwork.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirAuditEventParticipantNetwork.GetType_ST : TFhirNetworkTypeEnum;
begin
  if FType_ = nil then
    result := TFhirNetworkTypeEnum(0)
  else
    result := TFhirNetworkTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirNetworkTypeEnum, FType_.value));
end;

Procedure TFhirAuditEventParticipantNetwork.SetType_ST(value : TFhirNetworkTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirNetworkTypeEnum[value], CODES_TFhirNetworkTypeEnum[value]);
end;

function TFhirAuditEventParticipantNetwork.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FAddress.sizeInBytes);
  inc(result, FType_.sizeInBytes);
end;

{ TFhirAuditEventParticipantNetworkListEnumerator }

Constructor TFhirAuditEventParticipantNetworkListEnumerator.Create(list : TFhirAuditEventParticipantNetworkList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAuditEventParticipantNetworkListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAuditEventParticipantNetworkListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAuditEventParticipantNetworkListEnumerator.GetCurrent : TFhirAuditEventParticipantNetwork;
begin
  Result := FList[FIndex];
end;

function TFhirAuditEventParticipantNetworkListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAuditEventParticipantNetworkList }
procedure TFhirAuditEventParticipantNetworkList.AddItem(value: TFhirAuditEventParticipantNetwork);
begin
  assert(value.ClassName = 'TFhirAuditEventParticipantNetwork', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAuditEventParticipantNetwork');
  add(value);
end;

function TFhirAuditEventParticipantNetworkList.Append: TFhirAuditEventParticipantNetwork;
begin
  result := TFhirAuditEventParticipantNetwork.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventParticipantNetworkList.ClearItems;
begin
  Clear;
end;

function TFhirAuditEventParticipantNetworkList.GetEnumerator : TFhirAuditEventParticipantNetworkListEnumerator;
begin
  result := TFhirAuditEventParticipantNetworkListEnumerator.Create(self.link);
end;

function TFhirAuditEventParticipantNetworkList.Clone: TFhirAuditEventParticipantNetworkList;
begin
  result := TFhirAuditEventParticipantNetworkList(inherited Clone);
end;

function TFhirAuditEventParticipantNetworkList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAuditEventParticipantNetworkList.GetItemN(index: Integer): TFhirAuditEventParticipantNetwork;
begin
  result := TFhirAuditEventParticipantNetwork(ObjectByIndex[index]);
end;

function TFhirAuditEventParticipantNetworkList.ItemClass: TFslObjectClass;
begin
  result := TFhirAuditEventParticipantNetwork;
end;
function TFhirAuditEventParticipantNetworkList.IndexOf(value: TFhirAuditEventParticipantNetwork): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAuditEventParticipantNetworkList.Insert(index: Integer): TFhirAuditEventParticipantNetwork;
begin
  result := TFhirAuditEventParticipantNetwork.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventParticipantNetworkList.InsertItem(index: Integer; value: TFhirAuditEventParticipantNetwork);
begin
  assert(value is TFhirAuditEventParticipantNetwork);
  Inherited Insert(index, value);
end;

function TFhirAuditEventParticipantNetworkList.Item(index: Integer): TFhirAuditEventParticipantNetwork;
begin
  result := TFhirAuditEventParticipantNetwork(ObjectByIndex[index]);
end;

function TFhirAuditEventParticipantNetworkList.Link: TFhirAuditEventParticipantNetworkList;
begin
  result := TFhirAuditEventParticipantNetworkList(inherited Link);
end;

procedure TFhirAuditEventParticipantNetworkList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAuditEventParticipantNetworkList.SetItemByIndex(index: Integer; value: TFhirAuditEventParticipantNetwork);
begin
  assert(value is TFhirAuditEventParticipantNetwork);
  FhirAuditEventParticipantNetworks[index] := value;
end;

procedure TFhirAuditEventParticipantNetworkList.SetItemN(index: Integer; value: TFhirAuditEventParticipantNetwork);
begin
  assert(value is TFhirAuditEventParticipantNetwork);
  ObjectByIndex[index] := value;
end;

{ TFhirAuditEventSource }

constructor TFhirAuditEventSource.Create;
begin
  inherited;
end;

destructor TFhirAuditEventSource.Destroy;
begin
  FSite.free;
  FIdentifier.free;
  FType_List.Free;
  inherited;
end;

procedure TFhirAuditEventSource.Assign(oSource : TFslObject);
begin
  inherited;
  siteElement := TFhirAuditEventSource(oSource).siteElement.Clone;
  identifier := TFhirAuditEventSource(oSource).identifier.Clone;
  if (TFhirAuditEventSource(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodingList.Create;
    FType_List.Assign(TFhirAuditEventSource(oSource).FType_List);
  end;
end;

procedure TFhirAuditEventSource.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'site') Then
     list.add(self.link, 'site', FSite.Link);
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
end;

procedure TFhirAuditEventSource.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'site', 'string', false, TFhirString, FSite.Link));{2}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', true, TFhirCoding, FType_List.Link)){3};
end;

function TFhirAuditEventSource.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'site') then
  begin
    SiteElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAuditEventSource.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCoding){2a}
  else inherited;
end;

function TFhirAuditEventSource.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'site') then result := TFhirString.create() {5b}
  else if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'type') then result := Type_List.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAuditEventSource.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'site') then result := 'string'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'type') then result := 'Coding'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAuditEventSource.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'site') then SiteElement := nil
  else if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAuditEventSource.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'site') then SiteElement := asString(new){5b}
  else if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAuditEventSource.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'type') then Type_List.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAuditEventSource.fhirType : string;
begin
  result := 'source';
end;

function TFhirAuditEventSource.Link : TFhirAuditEventSource;
begin
  result := TFhirAuditEventSource(inherited Link);
end;

function TFhirAuditEventSource.Clone : TFhirAuditEventSource;
begin
  result := TFhirAuditEventSource(inherited Clone);
end;

function TFhirAuditEventSource.equals(other : TObject) : boolean;
var
  o : TFhirAuditEventSource;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAuditEventSource)) then
    result := false
  else
  begin
    o := TFhirAuditEventSource(other);
    result := compareDeep(siteElement, o.siteElement, true) and compareDeep(identifierElement, o.identifierElement, true) and
      compareDeep(type_List, o.type_List, true);
  end;
end;

function TFhirAuditEventSource.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSite) and isEmptyProp(FIdentifier) and isEmptyProp(Ftype_List);
end;

procedure TFhirAuditEventSource.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('site');
  fields.add('identifier');
  fields.add('type');
end;

{ TFhirAuditEventSource }

Procedure TFhirAuditEventSource.SetSite(value : TFhirString);
begin
  FSite.free;
  FSite := value;
end;

Function TFhirAuditEventSource.GetSiteST : String;
begin
  if FSite = nil then
    result := ''
  else
    result := FSite.value;
end;

Procedure TFhirAuditEventSource.SetSiteST(value : String);
begin
  if value <> '' then
  begin
    if FSite = nil then
      FSite := TFhirString.create;
    FSite.value := value
  end
  else if FSite <> nil then
    FSite.value := '';
end;

Procedure TFhirAuditEventSource.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Function TFhirAuditEventSource.GetType_List : TFhirCodingList;
begin
  if FType_List = nil then
    FType_List := TFhirCodingList.Create;
  result := FType_List;
end;

Function TFhirAuditEventSource.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

function TFhirAuditEventSource.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSite.sizeInBytes);
  inc(result, FIdentifier.sizeInBytes);
  inc(result, Ftype_List.sizeInBytes);
end;

{ TFhirAuditEventSourceListEnumerator }

Constructor TFhirAuditEventSourceListEnumerator.Create(list : TFhirAuditEventSourceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAuditEventSourceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAuditEventSourceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAuditEventSourceListEnumerator.GetCurrent : TFhirAuditEventSource;
begin
  Result := FList[FIndex];
end;

function TFhirAuditEventSourceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAuditEventSourceList }
procedure TFhirAuditEventSourceList.AddItem(value: TFhirAuditEventSource);
begin
  assert(value.ClassName = 'TFhirAuditEventSource', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAuditEventSource');
  add(value);
end;

function TFhirAuditEventSourceList.Append: TFhirAuditEventSource;
begin
  result := TFhirAuditEventSource.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventSourceList.ClearItems;
begin
  Clear;
end;

function TFhirAuditEventSourceList.GetEnumerator : TFhirAuditEventSourceListEnumerator;
begin
  result := TFhirAuditEventSourceListEnumerator.Create(self.link);
end;

function TFhirAuditEventSourceList.Clone: TFhirAuditEventSourceList;
begin
  result := TFhirAuditEventSourceList(inherited Clone);
end;

function TFhirAuditEventSourceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAuditEventSourceList.GetItemN(index: Integer): TFhirAuditEventSource;
begin
  result := TFhirAuditEventSource(ObjectByIndex[index]);
end;

function TFhirAuditEventSourceList.ItemClass: TFslObjectClass;
begin
  result := TFhirAuditEventSource;
end;
function TFhirAuditEventSourceList.IndexOf(value: TFhirAuditEventSource): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAuditEventSourceList.Insert(index: Integer): TFhirAuditEventSource;
begin
  result := TFhirAuditEventSource.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventSourceList.InsertItem(index: Integer; value: TFhirAuditEventSource);
begin
  assert(value is TFhirAuditEventSource);
  Inherited Insert(index, value);
end;

function TFhirAuditEventSourceList.Item(index: Integer): TFhirAuditEventSource;
begin
  result := TFhirAuditEventSource(ObjectByIndex[index]);
end;

function TFhirAuditEventSourceList.Link: TFhirAuditEventSourceList;
begin
  result := TFhirAuditEventSourceList(inherited Link);
end;

procedure TFhirAuditEventSourceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAuditEventSourceList.SetItemByIndex(index: Integer; value: TFhirAuditEventSource);
begin
  assert(value is TFhirAuditEventSource);
  FhirAuditEventSources[index] := value;
end;

procedure TFhirAuditEventSourceList.SetItemN(index: Integer; value: TFhirAuditEventSource);
begin
  assert(value is TFhirAuditEventSource);
  ObjectByIndex[index] := value;
end;

{ TFhirAuditEventObject }

constructor TFhirAuditEventObject.Create;
begin
  inherited;
end;

destructor TFhirAuditEventObject.Destroy;
begin
  FIdentifier.free;
  FReference.free;
  FType_.free;
  FRole.free;
  FLifecycle.free;
  FSecurityLabelList.Free;
  FName.free;
  FDescription.free;
  FQuery.free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirAuditEventObject.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirAuditEventObject(oSource).identifier.Clone;
  reference := TFhirAuditEventObject(oSource).reference.Clone;
  type_ := TFhirAuditEventObject(oSource).type_.Clone;
  role := TFhirAuditEventObject(oSource).role.Clone;
  lifecycle := TFhirAuditEventObject(oSource).lifecycle.Clone;
  if (TFhirAuditEventObject(oSource).FSecurityLabelList = nil) then
  begin
    FSecurityLabelList.free;
    FSecurityLabelList := nil;
  end
  else
  begin
    if FSecurityLabelList = nil then
      FSecurityLabelList := TFhirCodingList.Create;
    FSecurityLabelList.Assign(TFhirAuditEventObject(oSource).FSecurityLabelList);
  end;
  nameElement := TFhirAuditEventObject(oSource).nameElement.Clone;
  descriptionElement := TFhirAuditEventObject(oSource).descriptionElement.Clone;
  queryElement := TFhirAuditEventObject(oSource).queryElement.Clone;
  if (TFhirAuditEventObject(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirAuditEventObjectDetailList.Create;
    FDetailList.Assign(TFhirAuditEventObject(oSource).FDetailList);
  end;
end;

procedure TFhirAuditEventObject.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'lifecycle') Then
     list.add(self.link, 'lifecycle', FLifecycle.Link);
  if (child_name = 'securityLabel') Then
    list.addAll(self, 'securityLabel', FSecurityLabelList);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'query') Then
     list.add(self.link, 'query', FQuery.Link);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
end;

procedure TFhirAuditEventObject.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reference', 'Reference(Any)', false, TFhirReference{TFhirReference}, FReference.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', false, TFhirCoding, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'role', 'Coding', false, TFhirCoding, FRole.Link));{2}
  oList.add(TFHIRProperty.create(self, 'lifecycle', 'Coding', false, TFhirCoding, FLifecycle.Link));{2}
  oList.add(TFHIRProperty.create(self, 'securityLabel', 'Coding', true, TFhirCoding, FSecurityLabelList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'query', 'base64Binary', false, TFhirBase64Binary, FQuery.Link));{2}
  oList.add(TFHIRProperty.create(self, 'detail', '', true, TFhirAuditEventObjectDetail, FDetailList.Link)){3};
end;

function TFhirAuditEventObject.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'reference') then
  begin
    Reference := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    Role := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'lifecycle') then
  begin
    Lifecycle := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'securityLabel') then
  begin
    SecurityLabelList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'query') then
  begin
    QueryElement := asBase64Binary(propValue){5a};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirAuditEventObjectDetail){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAuditEventObject.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'securityLabel') then SecurityLabelList.insertItem(index, propValue as TFhirCoding){2a}
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirAuditEventObjectDetail){2a}
  else inherited;
end;

function TFhirAuditEventObject.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'reference') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'type') then result := TFhirCoding.create(){4b}
  else if (propName = 'role') then result := TFhirCoding.create(){4b}
  else if (propName = 'lifecycle') then result := TFhirCoding.create(){4b}
  else if (propName = 'securityLabel') then result := SecurityLabelList.new(){2}
  else if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'query') then result := TFhirBase64Binary.create() {5b}
  else if (propName = 'detail') then result := DetailList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAuditEventObject.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'reference') then result := 'Reference'
  else if (propName = 'type') then result := 'Coding'
  else if (propName = 'role') then result := 'Coding'
  else if (propName = 'lifecycle') then result := 'Coding'
  else if (propName = 'securityLabel') then result := 'Coding'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'query') then result := 'base64Binary'
  else if (propName = 'detail') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAuditEventObject.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'reference') then ReferenceElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'role') then RoleElement := nil
  else if (propName = 'lifecycle') then LifecycleElement := nil
  else if (propName = 'securityLabel') then deletePropertyValue('securityLabel', SecurityLabelList, value) {2}
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'query') then QueryElement := nil
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAuditEventObject.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'reference') then ReferenceElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'type') then Type_Element := new as TFhirCoding{4}
  else if (propName = 'role') then RoleElement := new as TFhirCoding{4}
  else if (propName = 'lifecycle') then LifecycleElement := new as TFhirCoding{4}
  else if (propName = 'securityLabel') then replacePropertyValue('securityLabel', SecurityLabelList, existing, new) {2}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'query') then QueryElement := asBase64Binary(new){5b}
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAuditEventObject.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'securityLabel') then SecurityLabelList.move(source, destination){2a}
  else if (propName = 'detail') then DetailList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAuditEventObject.fhirType : string;
begin
  result := 'object';
end;

function TFhirAuditEventObject.Link : TFhirAuditEventObject;
begin
  result := TFhirAuditEventObject(inherited Link);
end;

function TFhirAuditEventObject.Clone : TFhirAuditEventObject;
begin
  result := TFhirAuditEventObject(inherited Clone);
end;

function TFhirAuditEventObject.equals(other : TObject) : boolean;
var
  o : TFhirAuditEventObject;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAuditEventObject)) then
    result := false
  else
  begin
    o := TFhirAuditEventObject(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(referenceElement, o.referenceElement, true) and
      compareDeep(type_Element, o.type_Element, true) and compareDeep(roleElement, o.roleElement, true) and
      compareDeep(lifecycleElement, o.lifecycleElement, true) and compareDeep(securityLabelList, o.securityLabelList, true) and
      compareDeep(nameElement, o.nameElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and
      compareDeep(queryElement, o.queryElement, true) and compareDeep(detailList, o.detailList, true);
  end;
end;

function TFhirAuditEventObject.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FReference) and isEmptyProp(FType_) and isEmptyProp(FRole) and isEmptyProp(FLifecycle) and isEmptyProp(FsecurityLabelList) and isEmptyProp(FName) and isEmptyProp(FDescription) and isEmptyProp(FQuery) and isEmptyProp(FdetailList);
end;

procedure TFhirAuditEventObject.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('reference');
  fields.add('type');
  fields.add('role');
  fields.add('lifecycle');
  fields.add('securityLabel');
  fields.add('name');
  fields.add('description');
  fields.add('query');
  fields.add('detail');
end;

{ TFhirAuditEventObject }

Procedure TFhirAuditEventObject.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirAuditEventObject.SetReference(value : TFhirReference{TFhirReference});
begin
  FReference.free;
  FReference := value;
end;

Procedure TFhirAuditEventObject.SetType_(value : TFhirCoding);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirAuditEventObject.SetRole(value : TFhirCoding);
begin
  FRole.free;
  FRole := value;
end;

Procedure TFhirAuditEventObject.SetLifecycle(value : TFhirCoding);
begin
  FLifecycle.free;
  FLifecycle := value;
end;

Function TFhirAuditEventObject.GetSecurityLabelList : TFhirCodingList;
begin
  if FSecurityLabelList = nil then
    FSecurityLabelList := TFhirCodingList.Create;
  result := FSecurityLabelList;
end;

Function TFhirAuditEventObject.GetHasSecurityLabelList : boolean;
begin
  result := (FSecurityLabelList <> nil) and (FSecurityLabelList.count > 0);
end;

Procedure TFhirAuditEventObject.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirAuditEventObject.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirAuditEventObject.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirAuditEventObject.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirAuditEventObject.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirAuditEventObject.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirAuditEventObject.SetQuery(value : TFhirBase64Binary);
begin
  FQuery.free;
  FQuery := value;
end;

Function TFhirAuditEventObject.GetQueryST : TBytes;
begin
  if FQuery = nil then
    result := nil
  else
    result := FQuery.value;
end;

Procedure TFhirAuditEventObject.SetQueryST(value : TBytes);
begin
  if value <> nil then
  begin
    if FQuery = nil then
      FQuery := TFhirBase64Binary.create;
    FQuery.value := value
  end
  else if FQuery <> nil then
    FQuery.value := nil;
end;

Function TFhirAuditEventObject.GetDetailList : TFhirAuditEventObjectDetailList;
begin
  if FDetailList = nil then
    FDetailList := TFhirAuditEventObjectDetailList.Create;
  result := FDetailList;
end;

Function TFhirAuditEventObject.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

function TFhirAuditEventObject.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FReference.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FRole.sizeInBytes);
  inc(result, FLifecycle.sizeInBytes);
  inc(result, FsecurityLabelList.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FQuery.sizeInBytes);
  inc(result, FdetailList.sizeInBytes);
end;

{ TFhirAuditEventObjectListEnumerator }

Constructor TFhirAuditEventObjectListEnumerator.Create(list : TFhirAuditEventObjectList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAuditEventObjectListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAuditEventObjectListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAuditEventObjectListEnumerator.GetCurrent : TFhirAuditEventObject;
begin
  Result := FList[FIndex];
end;

function TFhirAuditEventObjectListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAuditEventObjectList }
procedure TFhirAuditEventObjectList.AddItem(value: TFhirAuditEventObject);
begin
  assert(value.ClassName = 'TFhirAuditEventObject', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAuditEventObject');
  add(value);
end;

function TFhirAuditEventObjectList.Append: TFhirAuditEventObject;
begin
  result := TFhirAuditEventObject.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventObjectList.ClearItems;
begin
  Clear;
end;

function TFhirAuditEventObjectList.GetEnumerator : TFhirAuditEventObjectListEnumerator;
begin
  result := TFhirAuditEventObjectListEnumerator.Create(self.link);
end;

function TFhirAuditEventObjectList.Clone: TFhirAuditEventObjectList;
begin
  result := TFhirAuditEventObjectList(inherited Clone);
end;

function TFhirAuditEventObjectList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAuditEventObjectList.GetItemN(index: Integer): TFhirAuditEventObject;
begin
  result := TFhirAuditEventObject(ObjectByIndex[index]);
end;

function TFhirAuditEventObjectList.ItemClass: TFslObjectClass;
begin
  result := TFhirAuditEventObject;
end;
function TFhirAuditEventObjectList.IndexOf(value: TFhirAuditEventObject): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAuditEventObjectList.Insert(index: Integer): TFhirAuditEventObject;
begin
  result := TFhirAuditEventObject.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventObjectList.InsertItem(index: Integer; value: TFhirAuditEventObject);
begin
  assert(value is TFhirAuditEventObject);
  Inherited Insert(index, value);
end;

function TFhirAuditEventObjectList.Item(index: Integer): TFhirAuditEventObject;
begin
  result := TFhirAuditEventObject(ObjectByIndex[index]);
end;

function TFhirAuditEventObjectList.Link: TFhirAuditEventObjectList;
begin
  result := TFhirAuditEventObjectList(inherited Link);
end;

procedure TFhirAuditEventObjectList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAuditEventObjectList.SetItemByIndex(index: Integer; value: TFhirAuditEventObject);
begin
  assert(value is TFhirAuditEventObject);
  FhirAuditEventObjects[index] := value;
end;

procedure TFhirAuditEventObjectList.SetItemN(index: Integer; value: TFhirAuditEventObject);
begin
  assert(value is TFhirAuditEventObject);
  ObjectByIndex[index] := value;
end;

{ TFhirAuditEventObjectDetail }

constructor TFhirAuditEventObjectDetail.Create;
begin
  inherited;
end;

destructor TFhirAuditEventObjectDetail.Destroy;
begin
  FType_.free;
  FValue.free;
  inherited;
end;

procedure TFhirAuditEventObjectDetail.Assign(oSource : TFslObject);
begin
  inherited;
  type_Element := TFhirAuditEventObjectDetail(oSource).type_Element.Clone;
  valueElement := TFhirAuditEventObjectDetail(oSource).valueElement.Clone;
end;

procedure TFhirAuditEventObjectDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirAuditEventObjectDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'string', false, TFhirString, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value', 'base64Binary', false, TFhirBase64Binary, FValue.Link));{2}
end;

function TFhirAuditEventObjectDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asBase64Binary(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAuditEventObjectDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirAuditEventObjectDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirString.create() {5b}
  else if (propName = 'value') then result := TFhirBase64Binary.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAuditEventObjectDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'string'
  else if (propName = 'value') then result := 'base64Binary'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAuditEventObjectDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAuditEventObjectDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asString(new){5b}
  else if (propName = 'value') then ValueElement := asBase64Binary(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAuditEventObjectDetail.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirAuditEventObjectDetail.fhirType : string;
begin
  result := 'detail';
end;

function TFhirAuditEventObjectDetail.Link : TFhirAuditEventObjectDetail;
begin
  result := TFhirAuditEventObjectDetail(inherited Link);
end;

function TFhirAuditEventObjectDetail.Clone : TFhirAuditEventObjectDetail;
begin
  result := TFhirAuditEventObjectDetail(inherited Clone);
end;

function TFhirAuditEventObjectDetail.equals(other : TObject) : boolean;
var
  o : TFhirAuditEventObjectDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAuditEventObjectDetail)) then
    result := false
  else
  begin
    o := TFhirAuditEventObjectDetail(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirAuditEventObjectDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue);
end;

procedure TFhirAuditEventObjectDetail.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('value');
end;

{ TFhirAuditEventObjectDetail }

Procedure TFhirAuditEventObjectDetail.SetType_(value : TFhirString);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirAuditEventObjectDetail.GetType_ST : String;
begin
  if FType_ = nil then
    result := ''
  else
    result := FType_.value;
end;

Procedure TFhirAuditEventObjectDetail.SetType_ST(value : String);
begin
  if value <> '' then
  begin
    if FType_ = nil then
      FType_ := TFhirString.create;
    FType_.value := value
  end
  else if FType_ <> nil then
    FType_.value := '';
end;

Procedure TFhirAuditEventObjectDetail.SetValue(value : TFhirBase64Binary);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirAuditEventObjectDetail.GetValueST : TBytes;
begin
  if FValue = nil then
    result := nil
  else
    result := FValue.value;
end;

Procedure TFhirAuditEventObjectDetail.SetValueST(value : TBytes);
begin
  if value <> nil then
  begin
    if FValue = nil then
      FValue := TFhirBase64Binary.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := nil;
end;

function TFhirAuditEventObjectDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirAuditEventObjectDetailListEnumerator }

Constructor TFhirAuditEventObjectDetailListEnumerator.Create(list : TFhirAuditEventObjectDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAuditEventObjectDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAuditEventObjectDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAuditEventObjectDetailListEnumerator.GetCurrent : TFhirAuditEventObjectDetail;
begin
  Result := FList[FIndex];
end;

function TFhirAuditEventObjectDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAuditEventObjectDetailList }
procedure TFhirAuditEventObjectDetailList.AddItem(value: TFhirAuditEventObjectDetail);
begin
  assert(value.ClassName = 'TFhirAuditEventObjectDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAuditEventObjectDetail');
  add(value);
end;

function TFhirAuditEventObjectDetailList.Append: TFhirAuditEventObjectDetail;
begin
  result := TFhirAuditEventObjectDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventObjectDetailList.ClearItems;
begin
  Clear;
end;

function TFhirAuditEventObjectDetailList.GetEnumerator : TFhirAuditEventObjectDetailListEnumerator;
begin
  result := TFhirAuditEventObjectDetailListEnumerator.Create(self.link);
end;

function TFhirAuditEventObjectDetailList.Clone: TFhirAuditEventObjectDetailList;
begin
  result := TFhirAuditEventObjectDetailList(inherited Clone);
end;

function TFhirAuditEventObjectDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAuditEventObjectDetailList.GetItemN(index: Integer): TFhirAuditEventObjectDetail;
begin
  result := TFhirAuditEventObjectDetail(ObjectByIndex[index]);
end;

function TFhirAuditEventObjectDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirAuditEventObjectDetail;
end;
function TFhirAuditEventObjectDetailList.IndexOf(value: TFhirAuditEventObjectDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAuditEventObjectDetailList.Insert(index: Integer): TFhirAuditEventObjectDetail;
begin
  result := TFhirAuditEventObjectDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventObjectDetailList.InsertItem(index: Integer; value: TFhirAuditEventObjectDetail);
begin
  assert(value is TFhirAuditEventObjectDetail);
  Inherited Insert(index, value);
end;

function TFhirAuditEventObjectDetailList.Item(index: Integer): TFhirAuditEventObjectDetail;
begin
  result := TFhirAuditEventObjectDetail(ObjectByIndex[index]);
end;

function TFhirAuditEventObjectDetailList.Link: TFhirAuditEventObjectDetailList;
begin
  result := TFhirAuditEventObjectDetailList(inherited Link);
end;

procedure TFhirAuditEventObjectDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAuditEventObjectDetailList.SetItemByIndex(index: Integer; value: TFhirAuditEventObjectDetail);
begin
  assert(value is TFhirAuditEventObjectDetail);
  FhirAuditEventObjectDetails[index] := value;
end;

procedure TFhirAuditEventObjectDetailList.SetItemN(index: Integer; value: TFhirAuditEventObjectDetail);
begin
  assert(value is TFhirAuditEventObjectDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirAuditEvent }

constructor TFhirAuditEvent.Create;
begin
  inherited;
end;

destructor TFhirAuditEvent.Destroy;
begin
  FEvent.free;
  FParticipantList.Free;
  FSource.free;
  FObject_List.Free;
  inherited;
end;

function TFhirAuditEvent.GetResourceType : TFhirResourceType;
begin
  result := frtAuditEvent;
end;

procedure TFhirAuditEvent.Assign(oSource : TFslObject);
begin
  inherited;
  event := TFhirAuditEvent(oSource).event.Clone;
  if (TFhirAuditEvent(oSource).FParticipantList = nil) then
  begin
    FParticipantList.free;
    FParticipantList := nil;
  end
  else
  begin
    if FParticipantList = nil then
      FParticipantList := TFhirAuditEventParticipantList.Create;
    FParticipantList.Assign(TFhirAuditEvent(oSource).FParticipantList);
  end;
  source := TFhirAuditEvent(oSource).source.Clone;
  if (TFhirAuditEvent(oSource).FObject_List = nil) then
  begin
    FObject_List.free;
    FObject_List := nil;
  end
  else
  begin
    if FObject_List = nil then
      FObject_List := TFhirAuditEventObjectList.Create;
    FObject_List.Assign(TFhirAuditEvent(oSource).FObject_List);
  end;
end;

procedure TFhirAuditEvent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'event') Then
     list.add(self.link, 'event', FEvent.Link);
  if (child_name = 'participant') Then
    list.addAll(self, 'participant', FParticipantList);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'object') Then
    list.addAll(self, 'object', FObject_List);
end;

procedure TFhirAuditEvent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'event', '', false, TFhirAuditEventEvent, FEvent.Link));{2}
  oList.add(TFHIRProperty.create(self, 'participant', '', true, TFhirAuditEventParticipant, FParticipantList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'source', '', false, TFhirAuditEventSource, FSource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'object', '', true, TFhirAuditEventObject, FObject_List.Link)){3};
end;

function TFhirAuditEvent.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'event') then
  begin
    Event := propValue as TFhirAuditEventEvent{4b};
    result := propValue;
  end
  else if (propName = 'participant') then
  begin
    ParticipantList.add(propValue as TFhirAuditEventParticipant){2a};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    Source := propValue as TFhirAuditEventSource{4b};
    result := propValue;
  end
  else if (propName = 'object') then
  begin
    Object_List.add(propValue as TFhirAuditEventObject){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirAuditEvent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'participant') then ParticipantList.insertItem(index, propValue as TFhirAuditEventParticipant){2a}
  else if (propName = 'object') then Object_List.insertItem(index, propValue as TFhirAuditEventObject){2a}
  else inherited;
end;

function TFhirAuditEvent.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'event') then result := TFhirAuditEventEvent.create(){4b}
  else if (propName = 'participant') then result := ParticipantList.new(){2}
  else if (propName = 'source') then result := TFhirAuditEventSource.create(){4b}
  else if (propName = 'object') then result := Object_List.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAuditEvent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'event') then result := ''
  else if (propName = 'participant') then result := ''
  else if (propName = 'source') then result := ''
  else if (propName = 'object') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAuditEvent.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'event') then EventElement := nil
  else if (propName = 'participant') then deletePropertyValue('participant', ParticipantList, value) {2}
  else if (propName = 'source') then SourceElement := nil
  else if (propName = 'object') then deletePropertyValue('object', Object_List, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAuditEvent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'event') then EventElement := new as TFhirAuditEventEvent{4}
  else if (propName = 'participant') then replacePropertyValue('participant', ParticipantList, existing, new) {2}
  else if (propName = 'source') then SourceElement := new as TFhirAuditEventSource{4}
  else if (propName = 'object') then replacePropertyValue('object', Object_List, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAuditEvent.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'participant') then ParticipantList.move(source, destination){2a}
  else if (propName = 'object') then Object_List.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAuditEvent.fhirType : string;
begin
  result := 'AuditEvent';
end;

function TFhirAuditEvent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FEvent) and isEmptyProp(FparticipantList) and isEmptyProp(FSource) and isEmptyProp(Fobject_List);
end;

function TFhirAuditEvent.equals(other : TObject) : boolean;
var
  o : TFhirAuditEvent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAuditEvent)) then
    result := false
  else
  begin
    o := TFhirAuditEvent(other);
    result := compareDeep(eventElement, o.eventElement, true) and compareDeep(participantList, o.participantList, true) and
      compareDeep(sourceElement, o.sourceElement, true) and compareDeep(object_List, o.object_List, true);
  end;
end;

function TFhirAuditEvent.Link : TFhirAuditEvent;
begin
  result := TFhirAuditEvent(inherited Link);
end;

function TFhirAuditEvent.Clone : TFhirAuditEvent;
begin
  result := TFhirAuditEvent(inherited Clone);
end;

procedure TFhirAuditEvent.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('event');
  fields.add('participant');
  fields.add('source');
  fields.add('object');
end;

{ TFhirAuditEvent }

Procedure TFhirAuditEvent.SetEvent(value : TFhirAuditEventEvent);
begin
  FEvent.free;
  FEvent := value;
end;

Function TFhirAuditEvent.GetParticipantList : TFhirAuditEventParticipantList;
begin
  if FParticipantList = nil then
    FParticipantList := TFhirAuditEventParticipantList.Create;
  result := FParticipantList;
end;

Function TFhirAuditEvent.GetHasParticipantList : boolean;
begin
  result := (FParticipantList <> nil) and (FParticipantList.count > 0);
end;

Procedure TFhirAuditEvent.SetSource(value : TFhirAuditEventSource);
begin
  FSource.free;
  FSource := value;
end;

Function TFhirAuditEvent.GetObject_List : TFhirAuditEventObjectList;
begin
  if FObject_List = nil then
    FObject_List := TFhirAuditEventObjectList.Create;
  result := FObject_List;
end;

Function TFhirAuditEvent.GetHasObject_List : boolean;
begin
  result := (FObject_List <> nil) and (FObject_List.count > 0);
end;

function TFhirAuditEvent.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FEvent.sizeInBytes);
  inc(result, FparticipantList.sizeInBytes);
  inc(result, FSource.sizeInBytes);
  inc(result, Fobject_List.sizeInBytes);
end;

{ TFhirAuditEventListEnumerator }

Constructor TFhirAuditEventListEnumerator.Create(list : TFhirAuditEventList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAuditEventListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAuditEventListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAuditEventListEnumerator.GetCurrent : TFhirAuditEvent;
begin
  Result := FList[FIndex];
end;

function TFhirAuditEventListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAuditEventList }
procedure TFhirAuditEventList.AddItem(value: TFhirAuditEvent);
begin
  assert(value.ClassName = 'TFhirAuditEvent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAuditEvent');
  add(value);
end;

function TFhirAuditEventList.Append: TFhirAuditEvent;
begin
  result := TFhirAuditEvent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventList.ClearItems;
begin
  Clear;
end;

function TFhirAuditEventList.GetEnumerator : TFhirAuditEventListEnumerator;
begin
  result := TFhirAuditEventListEnumerator.Create(self.link);
end;

function TFhirAuditEventList.Clone: TFhirAuditEventList;
begin
  result := TFhirAuditEventList(inherited Clone);
end;

function TFhirAuditEventList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAuditEventList.GetItemN(index: Integer): TFhirAuditEvent;
begin
  result := TFhirAuditEvent(ObjectByIndex[index]);
end;

function TFhirAuditEventList.ItemClass: TFslObjectClass;
begin
  result := TFhirAuditEvent;
end;
function TFhirAuditEventList.IndexOf(value: TFhirAuditEvent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAuditEventList.Insert(index: Integer): TFhirAuditEvent;
begin
  result := TFhirAuditEvent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventList.InsertItem(index: Integer; value: TFhirAuditEvent);
begin
  assert(value is TFhirAuditEvent);
  Inherited Insert(index, value);
end;

function TFhirAuditEventList.Item(index: Integer): TFhirAuditEvent;
begin
  result := TFhirAuditEvent(ObjectByIndex[index]);
end;

function TFhirAuditEventList.Link: TFhirAuditEventList;
begin
  result := TFhirAuditEventList(inherited Link);
end;

procedure TFhirAuditEventList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAuditEventList.SetItemByIndex(index: Integer; value: TFhirAuditEvent);
begin
  assert(value is TFhirAuditEvent);
  FhirAuditEvents[index] := value;
end;

procedure TFhirAuditEventList.SetItemN(index: Integer; value: TFhirAuditEvent);
begin
  assert(value is TFhirAuditEvent);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_AUDITEVENT}

{$IFDEF FHIR_BINARY}

{ TFhirBinary }

constructor TFhirBinary.Create;
begin
  inherited;
end;

destructor TFhirBinary.Destroy;
begin
  FContentType.free;
  FContent.free;
  inherited;
end;

function TFhirBinary.GetResourceType : TFhirResourceType;
begin
  result := frtBinary;
end;

procedure TFhirBinary.Assign(oSource : TFslObject);
begin
  inherited;
  contentTypeElement := TFhirBinary(oSource).contentTypeElement.Clone;
  contentElement := TFhirBinary(oSource).contentElement.Clone;
end;

procedure TFhirBinary.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'contentType') Then
     list.add(self.link, 'contentType', FContentType.Link);
  if (child_name = 'content') Then
     list.add(self.link, 'content', FContent.Link);
end;

procedure TFhirBinary.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'contentType', 'code', false, TFhirCode, FContentType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'content', 'base64Binary', false, TFhirBase64Binary, FContent.Link));{2}
end;

function TFhirBinary.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'contentType') then
  begin
    ContentTypeElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'content') then
  begin
    ContentElement := asBase64Binary(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirBinary.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirBinary.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'contentType') then result := TFhirCode.create() {5b}
  else if (propName = 'content') then result := TFhirBase64Binary.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirBinary.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'contentType') then result := 'code'
  else if (propName = 'content') then result := 'base64Binary'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBinary.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'contentType') then ContentTypeElement := nil
  else if (propName = 'content') then ContentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBinary.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'contentType') then ContentTypeElement := asCode(new){5b}
  else if (propName = 'content') then ContentElement := asBase64Binary(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBinary.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirBinary.fhirType : string;
begin
  result := 'Binary';
end;

function TFhirBinary.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FContentType) and isEmptyProp(FContent);
end;

function TFhirBinary.equals(other : TObject) : boolean;
var
  o : TFhirBinary;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBinary)) then
    result := false
  else
  begin
    o := TFhirBinary(other);
    result := compareDeep(contentTypeElement, o.contentTypeElement, true) and compareDeep(contentElement, o.contentElement, true);
  end;
end;

function TFhirBinary.Link : TFhirBinary;
begin
  result := TFhirBinary(inherited Link);
end;

function TFhirBinary.Clone : TFhirBinary;
begin
  result := TFhirBinary(inherited Clone);
end;

procedure TFhirBinary.listFieldsInOrder(fields : TStringList);
begin
  listResourceFieldsInOrder(fields);
  fields.add('contentType');
  fields.add('content');
end;

{ TFhirBinary }

Procedure TFhirBinary.SetContentType(value : TFhirCode);
begin
  FContentType.free;
  FContentType := value;
end;

Function TFhirBinary.GetContentTypeST : String;
begin
  if FContentType = nil then
    result := ''
  else
    result := FContentType.value;
end;

Procedure TFhirBinary.SetContentTypeST(value : String);
begin
  if value <> '' then
  begin
    if FContentType = nil then
      FContentType := TFhirCode.create;
    FContentType.value := value
  end
  else if FContentType <> nil then
    FContentType.value := '';
end;

Procedure TFhirBinary.SetContent(value : TFhirBase64Binary);
begin
  FContent.free;
  FContent := value;
end;

Function TFhirBinary.GetContentST : TBytes;
begin
  if FContent = nil then
    result := nil
  else
    result := FContent.value;
end;

Procedure TFhirBinary.SetContentST(value : TBytes);
begin
  if value <> nil then
  begin
    if FContent = nil then
      FContent := TFhirBase64Binary.create;
    FContent.value := value
  end
  else if FContent <> nil then
    FContent.value := nil;
end;

function TFhirBinary.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FContentType.sizeInBytes);
  inc(result, FContent.sizeInBytes);
end;

{ TFhirBinaryListEnumerator }

Constructor TFhirBinaryListEnumerator.Create(list : TFhirBinaryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBinaryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBinaryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBinaryListEnumerator.GetCurrent : TFhirBinary;
begin
  Result := FList[FIndex];
end;

function TFhirBinaryListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirBinaryList }
procedure TFhirBinaryList.AddItem(value: TFhirBinary);
begin
  assert(value.ClassName = 'TFhirBinary', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBinary');
  add(value);
end;

function TFhirBinaryList.Append: TFhirBinary;
begin
  result := TFhirBinary.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBinaryList.ClearItems;
begin
  Clear;
end;

function TFhirBinaryList.GetEnumerator : TFhirBinaryListEnumerator;
begin
  result := TFhirBinaryListEnumerator.Create(self.link);
end;

function TFhirBinaryList.Clone: TFhirBinaryList;
begin
  result := TFhirBinaryList(inherited Clone);
end;

function TFhirBinaryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBinaryList.GetItemN(index: Integer): TFhirBinary;
begin
  result := TFhirBinary(ObjectByIndex[index]);
end;

function TFhirBinaryList.ItemClass: TFslObjectClass;
begin
  result := TFhirBinary;
end;
function TFhirBinaryList.IndexOf(value: TFhirBinary): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBinaryList.Insert(index: Integer): TFhirBinary;
begin
  result := TFhirBinary.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBinaryList.InsertItem(index: Integer; value: TFhirBinary);
begin
  assert(value is TFhirBinary);
  Inherited Insert(index, value);
end;

function TFhirBinaryList.Item(index: Integer): TFhirBinary;
begin
  result := TFhirBinary(ObjectByIndex[index]);
end;

function TFhirBinaryList.Link: TFhirBinaryList;
begin
  result := TFhirBinaryList(inherited Link);
end;

procedure TFhirBinaryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBinaryList.SetItemByIndex(index: Integer; value: TFhirBinary);
begin
  assert(value is TFhirBinary);
  FhirBinaries[index] := value;
end;

procedure TFhirBinaryList.SetItemN(index: Integer; value: TFhirBinary);
begin
  assert(value is TFhirBinary);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_BINARY}

{$IFDEF FHIR_BUNDLE}

{ TFhirBundleLink }

constructor TFhirBundleLink.Create;
begin
  inherited;
end;

destructor TFhirBundleLink.Destroy;
begin
  FRelation.free;
  FUrl.free;
  inherited;
end;

procedure TFhirBundleLink.Assign(oSource : TFslObject);
begin
  inherited;
  relationElement := TFhirBundleLink(oSource).relationElement.Clone;
  urlElement := TFhirBundleLink(oSource).urlElement.Clone;
end;

procedure TFhirBundleLink.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'relation') Then
     list.add(self.link, 'relation', FRelation.Link);
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
end;

procedure TFhirBundleLink.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'relation', 'string', false, TFhirString, FRelation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));{2}
end;

function TFhirBundleLink.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'relation') then
  begin
    RelationElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'url') then
  begin
    UrlElement := asUri(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBundleLink.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirBundleLink.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'relation') then result := TFhirString.create() {5b}
  else if (propName = 'url') then result := TFhirUri.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirBundleLink.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'relation') then result := 'string'
  else if (propName = 'url') then result := 'uri'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBundleLink.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'relation') then RelationElement := nil
  else if (propName = 'url') then UrlElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBundleLink.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'relation') then RelationElement := asString(new){5b}
  else if (propName = 'url') then UrlElement := asUri(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBundleLink.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirBundleLink.fhirType : string;
begin
  result := 'link';
end;

function TFhirBundleLink.Link : TFhirBundleLink;
begin
  result := TFhirBundleLink(inherited Link);
end;

function TFhirBundleLink.Clone : TFhirBundleLink;
begin
  result := TFhirBundleLink(inherited Clone);
end;

function TFhirBundleLink.equals(other : TObject) : boolean;
var
  o : TFhirBundleLink;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBundleLink)) then
    result := false
  else
  begin
    o := TFhirBundleLink(other);
    result := compareDeep(relationElement, o.relationElement, true) and compareDeep(urlElement, o.urlElement, true);
  end;
end;

function TFhirBundleLink.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRelation) and isEmptyProp(FUrl);
end;

procedure TFhirBundleLink.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('relation');
  fields.add('url');
end;

{ TFhirBundleLink }

Procedure TFhirBundleLink.SetRelation(value : TFhirString);
begin
  FRelation.free;
  FRelation := value;
end;

Function TFhirBundleLink.GetRelationST : String;
begin
  if FRelation = nil then
    result := ''
  else
    result := FRelation.value;
end;

Procedure TFhirBundleLink.SetRelationST(value : String);
begin
  if value <> '' then
  begin
    if FRelation = nil then
      FRelation := TFhirString.create;
    FRelation.value := value
  end
  else if FRelation <> nil then
    FRelation.value := '';
end;

Procedure TFhirBundleLink.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirBundleLink.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

Procedure TFhirBundleLink.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

function TFhirBundleLink.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FRelation.sizeInBytes);
  inc(result, FUrl.sizeInBytes);
end;

{ TFhirBundleLinkListEnumerator }

Constructor TFhirBundleLinkListEnumerator.Create(list : TFhirBundleLinkList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBundleLinkListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBundleLinkListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBundleLinkListEnumerator.GetCurrent : TFhirBundleLink;
begin
  Result := FList[FIndex];
end;

function TFhirBundleLinkListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirBundleLinkList }
procedure TFhirBundleLinkList.AddItem(value: TFhirBundleLink);
begin
  assert(value.ClassName = 'TFhirBundleLink', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBundleLink');
  add(value);
end;

function TFhirBundleLinkList.Append: TFhirBundleLink;
begin
  result := TFhirBundleLink.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleLinkList.ClearItems;
begin
  Clear;
end;

function TFhirBundleLinkList.GetEnumerator : TFhirBundleLinkListEnumerator;
begin
  result := TFhirBundleLinkListEnumerator.Create(self.link);
end;

function TFhirBundleLinkList.Clone: TFhirBundleLinkList;
begin
  result := TFhirBundleLinkList(inherited Clone);
end;

function TFhirBundleLinkList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBundleLinkList.GetItemN(index: Integer): TFhirBundleLink;
begin
  result := TFhirBundleLink(ObjectByIndex[index]);
end;

function TFhirBundleLinkList.ItemClass: TFslObjectClass;
begin
  result := TFhirBundleLink;
end;
function TFhirBundleLinkList.IndexOf(value: TFhirBundleLink): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBundleLinkList.Insert(index: Integer): TFhirBundleLink;
begin
  result := TFhirBundleLink.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleLinkList.InsertItem(index: Integer; value: TFhirBundleLink);
begin
  assert(value is TFhirBundleLink);
  Inherited Insert(index, value);
end;

function TFhirBundleLinkList.Item(index: Integer): TFhirBundleLink;
begin
  result := TFhirBundleLink(ObjectByIndex[index]);
end;

function TFhirBundleLinkList.Link: TFhirBundleLinkList;
begin
  result := TFhirBundleLinkList(inherited Link);
end;

procedure TFhirBundleLinkList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBundleLinkList.SetItemByIndex(index: Integer; value: TFhirBundleLink);
begin
  assert(value is TFhirBundleLink);
  FhirBundleLinks[index] := value;
end;

procedure TFhirBundleLinkList.SetItemN(index: Integer; value: TFhirBundleLink);
begin
  assert(value is TFhirBundleLink);
  ObjectByIndex[index] := value;
end;

{ TFhirBundleEntry }

constructor TFhirBundleEntry.Create;
begin
  inherited;
end;

destructor TFhirBundleEntry.Destroy;
begin
  FLink_List.Free;
  FFullUrl.free;
  FResource.free;
  FSearch.free;
  FRequest.free;
  FResponse.free;
  inherited;
end;

procedure TFhirBundleEntry.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirBundleEntry(oSource).FLink_List = nil) then
  begin
    FLink_List.free;
    FLink_List := nil;
  end
  else
  begin
    if FLink_List = nil then
      FLink_List := TFhirBundleLinkList.Create;
    FLink_List.Assign(TFhirBundleEntry(oSource).FLink_List);
  end;
  fullUrlElement := TFhirBundleEntry(oSource).fullUrlElement.Clone;
  resource := TFhirBundleEntry(oSource).resource.Clone;
  search := TFhirBundleEntry(oSource).search.Clone;
  request := TFhirBundleEntry(oSource).request.Clone;
  response := TFhirBundleEntry(oSource).response.Clone;
end;

procedure TFhirBundleEntry.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'link') Then
    list.addAll(self, 'link', FLink_List);
  if (child_name = 'fullUrl') Then
     list.add(self.link, 'fullUrl', FFullUrl.Link);
  if (child_name = 'resource') Then
     list.add(self.link, 'resource', FResource.Link);
  if (child_name = 'search') Then
     list.add(self.link, 'search', FSearch.Link);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'response') Then
     list.add(self.link, 'response', FResponse.Link);
end;

procedure TFhirBundleEntry.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'link', '@Bundle.link', true, TFhirBundleLink, FLink_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'fullUrl', 'uri', false, TFhirUri, FFullUrl.Link));{2}
  oList.add(TFHIRProperty.create(self, 'resource', 'Resource', false, TFhirResource, FResource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'search', '', false, TFhirBundleEntrySearch, FSearch.Link));{2}
  oList.add(TFHIRProperty.create(self, 'request', '', false, TFhirBundleEntryRequest, FRequest.Link));{2}
  oList.add(TFHIRProperty.create(self, 'response', '', false, TFhirBundleEntryResponse, FResponse.Link));{2}
end;

function TFhirBundleEntry.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'link') then
  begin
    Link_List.add(propValue as TFhirBundleLink){2a};
    result := propValue;
  end
  else if (propName = 'fullUrl') then
  begin
    FullUrlElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'resource') then
  begin
    Resource := propValue as TFhirResource{4b};
    result := propValue;
  end
  else if (propName = 'search') then
  begin
    Search := propValue as TFhirBundleEntrySearch{4b};
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirBundleEntryRequest{4b};
    result := propValue;
  end
  else if (propName = 'response') then
  begin
    Response := propValue as TFhirBundleEntryResponse{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBundleEntry.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'link') then Link_List.insertItem(index, propValue as TFhirBundleLink){2a}
  else inherited;
end;

function TFhirBundleEntry.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'link') then result := Link_List.new(){2}
  else if (propName = 'fullUrl') then result := TFhirUri.create() {5b}
  else if (propName = 'resource') then raise EFHIRException.create('Cannot make property Resource')
  else if (propName = 'search') then result := TFhirBundleEntrySearch.create(){4b}
  else if (propName = 'request') then result := TFhirBundleEntryRequest.create(){4b}
  else if (propName = 'response') then result := TFhirBundleEntryResponse.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirBundleEntry.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'link') then result := '@Bundle.link'
  else if (propName = 'fullUrl') then result := 'uri'
  else if (propName = 'resource') then result := 'Resource'
  else if (propName = 'search') then result := ''
  else if (propName = 'request') then result := ''
  else if (propName = 'response') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBundleEntry.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'link') then deletePropertyValue('link', Link_List, value) {2}
  else if (propName = 'fullUrl') then FullUrlElement := nil
  else if (propName = 'resource') then ResourceElement := nil
  else if (propName = 'search') then SearchElement := nil
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'response') then ResponseElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBundleEntry.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'link') then replacePropertyValue('link', Link_List, existing, new) {2}
  else if (propName = 'fullUrl') then FullUrlElement := asUri(new){5b}
  else if (propName = 'resource') then ResourceElement := new as TFhirResource{4}
  else if (propName = 'search') then SearchElement := new as TFhirBundleEntrySearch{4}
  else if (propName = 'request') then RequestElement := new as TFhirBundleEntryRequest{4}
  else if (propName = 'response') then ResponseElement := new as TFhirBundleEntryResponse{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBundleEntry.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'link') then Link_List.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirBundleEntry.fhirType : string;
begin
  result := 'entry';
end;

function TFhirBundleEntry.Link : TFhirBundleEntry;
begin
  result := TFhirBundleEntry(inherited Link);
end;

function TFhirBundleEntry.Clone : TFhirBundleEntry;
begin
  result := TFhirBundleEntry(inherited Clone);
end;

function TFhirBundleEntry.equals(other : TObject) : boolean;
var
  o : TFhirBundleEntry;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBundleEntry)) then
    result := false
  else
  begin
    o := TFhirBundleEntry(other);
    result := compareDeep(link_List, o.link_List, true) and compareDeep(fullUrlElement, o.fullUrlElement, true) and
      compareDeep(resourceElement, o.resourceElement, true) and compareDeep(searchElement, o.searchElement, true) and
      compareDeep(requestElement, o.requestElement, true) and compareDeep(responseElement, o.responseElement, true);
  end;
end;

function TFhirBundleEntry.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(Flink_List) and isEmptyProp(FFullUrl) and isEmptyProp(FResource) and isEmptyProp(FSearch) and isEmptyProp(FRequest) and isEmptyProp(FResponse);
end;

procedure TFhirBundleEntry.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('link');
  fields.add('fullUrl');
  fields.add('resource');
  fields.add('search');
  fields.add('request');
  fields.add('response');
end;

{ TFhirBundleEntry }

Function TFhirBundleEntry.GetLink_List : TFhirBundleLinkList;
begin
  if FLink_List = nil then
    FLink_List := TFhirBundleLinkList.Create;
  result := FLink_List;
end;

Function TFhirBundleEntry.GetHasLink_List : boolean;
begin
  result := (FLink_List <> nil) and (FLink_List.count > 0);
end;

Procedure TFhirBundleEntry.SetFullUrl(value : TFhirUri);
begin
  FFullUrl.free;
  FFullUrl := value;
end;

Function TFhirBundleEntry.GetFullUrlST : String;
begin
  if FFullUrl = nil then
    result := ''
  else
    result := FFullUrl.value;
end;

Procedure TFhirBundleEntry.SetFullUrlST(value : String);
begin
  if value <> '' then
  begin
    if FFullUrl = nil then
      FFullUrl := TFhirUri.create;
    FFullUrl.value := value
  end
  else if FFullUrl <> nil then
    FFullUrl.value := '';
end;

Procedure TFhirBundleEntry.SetResource(value : TFhirResource);
begin
  FResource.free;
  FResource := value;
end;

Procedure TFhirBundleEntry.SetSearch(value : TFhirBundleEntrySearch);
begin
  FSearch.free;
  FSearch := value;
end;

Procedure TFhirBundleEntry.SetRequest(value : TFhirBundleEntryRequest);
begin
  FRequest.free;
  FRequest := value;
end;

Procedure TFhirBundleEntry.SetResponse(value : TFhirBundleEntryResponse);
begin
  FResponse.free;
  FResponse := value;
end;

function TFhirBundleEntry.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, Flink_List.sizeInBytes);
  inc(result, FFullUrl.sizeInBytes);
  inc(result, FResource.sizeInBytes);
  inc(result, FSearch.sizeInBytes);
  inc(result, FRequest.sizeInBytes);
  inc(result, FResponse.sizeInBytes);
end;

{ TFhirBundleEntryListEnumerator }

Constructor TFhirBundleEntryListEnumerator.Create(list : TFhirBundleEntryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBundleEntryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBundleEntryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBundleEntryListEnumerator.GetCurrent : TFhirBundleEntry;
begin
  Result := FList[FIndex];
end;

function TFhirBundleEntryListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirBundleEntryList }
procedure TFhirBundleEntryList.AddItem(value: TFhirBundleEntry);
begin
  assert(value.ClassName = 'TFhirBundleEntry', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBundleEntry');
  add(value);
end;

function TFhirBundleEntryList.Append: TFhirBundleEntry;
begin
  result := TFhirBundleEntry.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleEntryList.ClearItems;
begin
  Clear;
end;

function TFhirBundleEntryList.GetEnumerator : TFhirBundleEntryListEnumerator;
begin
  result := TFhirBundleEntryListEnumerator.Create(self.link);
end;

function TFhirBundleEntryList.Clone: TFhirBundleEntryList;
begin
  result := TFhirBundleEntryList(inherited Clone);
end;

function TFhirBundleEntryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBundleEntryList.GetItemN(index: Integer): TFhirBundleEntry;
begin
  result := TFhirBundleEntry(ObjectByIndex[index]);
end;

function TFhirBundleEntryList.ItemClass: TFslObjectClass;
begin
  result := TFhirBundleEntry;
end;
function TFhirBundleEntryList.IndexOf(value: TFhirBundleEntry): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBundleEntryList.Insert(index: Integer): TFhirBundleEntry;
begin
  result := TFhirBundleEntry.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleEntryList.InsertItem(index: Integer; value: TFhirBundleEntry);
begin
  assert(value is TFhirBundleEntry);
  Inherited Insert(index, value);
end;

function TFhirBundleEntryList.Item(index: Integer): TFhirBundleEntry;
begin
  result := TFhirBundleEntry(ObjectByIndex[index]);
end;

function TFhirBundleEntryList.Link: TFhirBundleEntryList;
begin
  result := TFhirBundleEntryList(inherited Link);
end;

procedure TFhirBundleEntryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBundleEntryList.SetItemByIndex(index: Integer; value: TFhirBundleEntry);
begin
  assert(value is TFhirBundleEntry);
  FhirBundleEntries[index] := value;
end;

procedure TFhirBundleEntryList.SetItemN(index: Integer; value: TFhirBundleEntry);
begin
  assert(value is TFhirBundleEntry);
  ObjectByIndex[index] := value;
end;

{ TFhirBundleEntrySearch }

constructor TFhirBundleEntrySearch.Create;
begin
  inherited;
end;

destructor TFhirBundleEntrySearch.Destroy;
begin
  FMode.free;
  FScore.free;
  inherited;
end;

procedure TFhirBundleEntrySearch.Assign(oSource : TFslObject);
begin
  inherited;
  FMode := TFhirBundleEntrySearch(oSource).FMode.Link;
  scoreElement := TFhirBundleEntrySearch(oSource).scoreElement.Clone;
end;

procedure TFhirBundleEntrySearch.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'mode') Then
     list.add(self.link, 'mode', FMode.Link);
  if (child_name = 'score') Then
     list.add(self.link, 'score', FScore.Link);
end;

procedure TFhirBundleEntrySearch.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'mode', 'code', false, TFHIREnum, FMode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'score', 'decimal', false, TFhirDecimal, FScore.Link));{2}
end;

function TFhirBundleEntrySearch.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'mode') then
  begin
    ModeElement := asEnum(SYSTEMS_TFhirSearchEntryModeEnum, CODES_TFhirSearchEntryModeEnum, propValue);
    result := propValue
  end
  else if (propName = 'score') then
  begin
    ScoreElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBundleEntrySearch.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirBundleEntrySearch.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'score') then result := TFhirDecimal.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirBundleEntrySearch.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'mode') then result := 'code'
  else if (propName = 'score') then result := 'decimal'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBundleEntrySearch.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'mode') then ModeElement := nil
  else if (propName = 'score') then ScoreElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBundleEntrySearch.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'mode') then ModeElement := asEnum(SYSTEMS_TFhirSearchEntryModeEnum, CODES_TFhirSearchEntryModeEnum, new){4}
  else if (propName = 'score') then ScoreElement := asDecimal(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBundleEntrySearch.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirBundleEntrySearch.fhirType : string;
begin
  result := 'search';
end;

function TFhirBundleEntrySearch.Link : TFhirBundleEntrySearch;
begin
  result := TFhirBundleEntrySearch(inherited Link);
end;

function TFhirBundleEntrySearch.Clone : TFhirBundleEntrySearch;
begin
  result := TFhirBundleEntrySearch(inherited Clone);
end;

function TFhirBundleEntrySearch.equals(other : TObject) : boolean;
var
  o : TFhirBundleEntrySearch;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBundleEntrySearch)) then
    result := false
  else
  begin
    o := TFhirBundleEntrySearch(other);
    result := compareDeep(modeElement, o.modeElement, true) and compareDeep(scoreElement, o.scoreElement, true);
  end;
end;

function TFhirBundleEntrySearch.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMode) and isEmptyProp(FScore);
end;

procedure TFhirBundleEntrySearch.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('mode');
  fields.add('score');
end;

{ TFhirBundleEntrySearch }

Procedure TFhirBundleEntrySearch.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

Function TFhirBundleEntrySearch.GetModeST : TFhirSearchEntryModeEnum;
begin
  if FMode = nil then
    result := TFhirSearchEntryModeEnum(0)
  else
    result := TFhirSearchEntryModeEnum(StringArrayIndexOfSensitive(CODES_TFhirSearchEntryModeEnum, FMode.value));
end;

Procedure TFhirBundleEntrySearch.SetModeST(value : TFhirSearchEntryModeEnum);
begin
  if ord(value) = 0 then
    ModeElement := nil
  else
    ModeElement := TFhirEnum.create(SYSTEMS_TFhirSearchEntryModeEnum[value], CODES_TFhirSearchEntryModeEnum[value]);
end;

Procedure TFhirBundleEntrySearch.SetScore(value : TFhirDecimal);
begin
  FScore.free;
  FScore := value;
end;

Function TFhirBundleEntrySearch.GetScoreST : String;
begin
  if FScore = nil then
    result := ''
  else
    result := FScore.value;
end;

Procedure TFhirBundleEntrySearch.SetScoreST(value : String);
begin
  if value <> '' then
  begin
    if FScore = nil then
      FScore := TFhirDecimal.create;
    FScore.value := value
  end
  else if FScore <> nil then
    FScore.value := '';
end;

function TFhirBundleEntrySearch.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FMode.sizeInBytes);
  inc(result, FScore.sizeInBytes);
end;

{ TFhirBundleEntrySearchListEnumerator }

Constructor TFhirBundleEntrySearchListEnumerator.Create(list : TFhirBundleEntrySearchList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBundleEntrySearchListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBundleEntrySearchListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBundleEntrySearchListEnumerator.GetCurrent : TFhirBundleEntrySearch;
begin
  Result := FList[FIndex];
end;

function TFhirBundleEntrySearchListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirBundleEntrySearchList }
procedure TFhirBundleEntrySearchList.AddItem(value: TFhirBundleEntrySearch);
begin
  assert(value.ClassName = 'TFhirBundleEntrySearch', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBundleEntrySearch');
  add(value);
end;

function TFhirBundleEntrySearchList.Append: TFhirBundleEntrySearch;
begin
  result := TFhirBundleEntrySearch.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleEntrySearchList.ClearItems;
begin
  Clear;
end;

function TFhirBundleEntrySearchList.GetEnumerator : TFhirBundleEntrySearchListEnumerator;
begin
  result := TFhirBundleEntrySearchListEnumerator.Create(self.link);
end;

function TFhirBundleEntrySearchList.Clone: TFhirBundleEntrySearchList;
begin
  result := TFhirBundleEntrySearchList(inherited Clone);
end;

function TFhirBundleEntrySearchList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBundleEntrySearchList.GetItemN(index: Integer): TFhirBundleEntrySearch;
begin
  result := TFhirBundleEntrySearch(ObjectByIndex[index]);
end;

function TFhirBundleEntrySearchList.ItemClass: TFslObjectClass;
begin
  result := TFhirBundleEntrySearch;
end;
function TFhirBundleEntrySearchList.IndexOf(value: TFhirBundleEntrySearch): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBundleEntrySearchList.Insert(index: Integer): TFhirBundleEntrySearch;
begin
  result := TFhirBundleEntrySearch.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleEntrySearchList.InsertItem(index: Integer; value: TFhirBundleEntrySearch);
begin
  assert(value is TFhirBundleEntrySearch);
  Inherited Insert(index, value);
end;

function TFhirBundleEntrySearchList.Item(index: Integer): TFhirBundleEntrySearch;
begin
  result := TFhirBundleEntrySearch(ObjectByIndex[index]);
end;

function TFhirBundleEntrySearchList.Link: TFhirBundleEntrySearchList;
begin
  result := TFhirBundleEntrySearchList(inherited Link);
end;

procedure TFhirBundleEntrySearchList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBundleEntrySearchList.SetItemByIndex(index: Integer; value: TFhirBundleEntrySearch);
begin
  assert(value is TFhirBundleEntrySearch);
  FhirBundleEntrySearches[index] := value;
end;

procedure TFhirBundleEntrySearchList.SetItemN(index: Integer; value: TFhirBundleEntrySearch);
begin
  assert(value is TFhirBundleEntrySearch);
  ObjectByIndex[index] := value;
end;

{ TFhirBundleEntryRequest }

constructor TFhirBundleEntryRequest.Create;
begin
  inherited;
end;

destructor TFhirBundleEntryRequest.Destroy;
begin
  FMethod.free;
  FUrl.free;
  FIfNoneMatch.free;
  FIfModifiedSince.free;
  FIfMatch.free;
  FIfNoneExist.free;
  inherited;
end;

procedure TFhirBundleEntryRequest.Assign(oSource : TFslObject);
begin
  inherited;
  FMethod := TFhirBundleEntryRequest(oSource).FMethod.Link;
  urlElement := TFhirBundleEntryRequest(oSource).urlElement.Clone;
  ifNoneMatchElement := TFhirBundleEntryRequest(oSource).ifNoneMatchElement.Clone;
  ifModifiedSinceElement := TFhirBundleEntryRequest(oSource).ifModifiedSinceElement.Clone;
  ifMatchElement := TFhirBundleEntryRequest(oSource).ifMatchElement.Clone;
  ifNoneExistElement := TFhirBundleEntryRequest(oSource).ifNoneExistElement.Clone;
end;

procedure TFhirBundleEntryRequest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'method') Then
     list.add(self.link, 'method', FMethod.Link);
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'ifNoneMatch') Then
     list.add(self.link, 'ifNoneMatch', FIfNoneMatch.Link);
  if (child_name = 'ifModifiedSince') Then
     list.add(self.link, 'ifModifiedSince', FIfModifiedSince.Link);
  if (child_name = 'ifMatch') Then
     list.add(self.link, 'ifMatch', FIfMatch.Link);
  if (child_name = 'ifNoneExist') Then
     list.add(self.link, 'ifNoneExist', FIfNoneExist.Link);
end;

procedure TFhirBundleEntryRequest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'method', 'code', false, TFHIREnum, FMethod.Link));{1}
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));{2}
  oList.add(TFHIRProperty.create(self, 'ifNoneMatch', 'string', false, TFhirString, FIfNoneMatch.Link));{2}
  oList.add(TFHIRProperty.create(self, 'ifModifiedSince', 'instant', false, TFhirInstant, FIfModifiedSince.Link));{2}
  oList.add(TFHIRProperty.create(self, 'ifMatch', 'string', false, TFhirString, FIfMatch.Link));{2}
  oList.add(TFHIRProperty.create(self, 'ifNoneExist', 'string', false, TFhirString, FIfNoneExist.Link));{2}
end;

function TFhirBundleEntryRequest.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'method') then
  begin
    MethodElement := asEnum(SYSTEMS_TFhirHttpVerbEnum, CODES_TFhirHttpVerbEnum, propValue);
    result := propValue
  end
  else if (propName = 'url') then
  begin
    UrlElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'ifNoneMatch') then
  begin
    IfNoneMatchElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'ifModifiedSince') then
  begin
    IfModifiedSinceElement := asInstant(propValue){5a};
    result := propValue;
  end
  else if (propName = 'ifMatch') then
  begin
    IfMatchElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'ifNoneExist') then
  begin
    IfNoneExistElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBundleEntryRequest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirBundleEntryRequest.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create() {5b}
  else if (propName = 'ifNoneMatch') then result := TFhirString.create() {5b}
  else if (propName = 'ifModifiedSince') then result := TFhirInstant.create() {5b}
  else if (propName = 'ifMatch') then result := TFhirString.create() {5b}
  else if (propName = 'ifNoneExist') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirBundleEntryRequest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'method') then result := 'code'
  else if (propName = 'url') then result := 'uri'
  else if (propName = 'ifNoneMatch') then result := 'string'
  else if (propName = 'ifModifiedSince') then result := 'instant'
  else if (propName = 'ifMatch') then result := 'string'
  else if (propName = 'ifNoneExist') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBundleEntryRequest.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'method') then MethodElement := nil
  else if (propName = 'url') then UrlElement := nil
  else if (propName = 'ifNoneMatch') then IfNoneMatchElement := nil
  else if (propName = 'ifModifiedSince') then IfModifiedSinceElement := nil
  else if (propName = 'ifMatch') then IfMatchElement := nil
  else if (propName = 'ifNoneExist') then IfNoneExistElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBundleEntryRequest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'method') then MethodElement := asEnum(SYSTEMS_TFhirHttpVerbEnum, CODES_TFhirHttpVerbEnum, new){4}
  else if (propName = 'url') then UrlElement := asUri(new){5b}
  else if (propName = 'ifNoneMatch') then IfNoneMatchElement := asString(new){5b}
  else if (propName = 'ifModifiedSince') then IfModifiedSinceElement := asInstant(new){5b}
  else if (propName = 'ifMatch') then IfMatchElement := asString(new){5b}
  else if (propName = 'ifNoneExist') then IfNoneExistElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBundleEntryRequest.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirBundleEntryRequest.fhirType : string;
begin
  result := 'request';
end;

function TFhirBundleEntryRequest.Link : TFhirBundleEntryRequest;
begin
  result := TFhirBundleEntryRequest(inherited Link);
end;

function TFhirBundleEntryRequest.Clone : TFhirBundleEntryRequest;
begin
  result := TFhirBundleEntryRequest(inherited Clone);
end;

function TFhirBundleEntryRequest.equals(other : TObject) : boolean;
var
  o : TFhirBundleEntryRequest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBundleEntryRequest)) then
    result := false
  else
  begin
    o := TFhirBundleEntryRequest(other);
    result := compareDeep(methodElement, o.methodElement, true) and compareDeep(urlElement, o.urlElement, true) and
      compareDeep(ifNoneMatchElement, o.ifNoneMatchElement, true) and compareDeep(ifModifiedSinceElement, o.ifModifiedSinceElement, true) and
      compareDeep(ifMatchElement, o.ifMatchElement, true) and compareDeep(ifNoneExistElement, o.ifNoneExistElement, true);
  end;
end;

function TFhirBundleEntryRequest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMethod) and isEmptyProp(FUrl) and isEmptyProp(FIfNoneMatch) and isEmptyProp(FIfModifiedSince) and isEmptyProp(FIfMatch) and isEmptyProp(FIfNoneExist);
end;

procedure TFhirBundleEntryRequest.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('method');
  fields.add('url');
  fields.add('ifNoneMatch');
  fields.add('ifModifiedSince');
  fields.add('ifMatch');
  fields.add('ifNoneExist');
end;

{ TFhirBundleEntryRequest }

Procedure TFhirBundleEntryRequest.SetMethod(value : TFhirEnum);
begin
  FMethod.free;
  FMethod := value;
end;

Function TFhirBundleEntryRequest.GetMethodST : TFhirHttpVerbEnum;
begin
  if FMethod = nil then
    result := TFhirHttpVerbEnum(0)
  else
    result := TFhirHttpVerbEnum(StringArrayIndexOfSensitive(CODES_TFhirHttpVerbEnum, FMethod.value));
end;

Procedure TFhirBundleEntryRequest.SetMethodST(value : TFhirHttpVerbEnum);
begin
  if ord(value) = 0 then
    MethodElement := nil
  else
    MethodElement := TFhirEnum.create(SYSTEMS_TFhirHttpVerbEnum[value], CODES_TFhirHttpVerbEnum[value]);
end;

Procedure TFhirBundleEntryRequest.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirBundleEntryRequest.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

Procedure TFhirBundleEntryRequest.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

Procedure TFhirBundleEntryRequest.SetIfNoneMatch(value : TFhirString);
begin
  FIfNoneMatch.free;
  FIfNoneMatch := value;
end;

Function TFhirBundleEntryRequest.GetIfNoneMatchST : String;
begin
  if FIfNoneMatch = nil then
    result := ''
  else
    result := FIfNoneMatch.value;
end;

Procedure TFhirBundleEntryRequest.SetIfNoneMatchST(value : String);
begin
  if value <> '' then
  begin
    if FIfNoneMatch = nil then
      FIfNoneMatch := TFhirString.create;
    FIfNoneMatch.value := value
  end
  else if FIfNoneMatch <> nil then
    FIfNoneMatch.value := '';
end;

Procedure TFhirBundleEntryRequest.SetIfModifiedSince(value : TFhirInstant);
begin
  FIfModifiedSince.free;
  FIfModifiedSince := value;
end;

Function TFhirBundleEntryRequest.GetIfModifiedSinceST : TFslDateTime;
begin
  if FIfModifiedSince = nil then
    result := TFslDateTime.makeNull
  else
    result := FIfModifiedSince.value;
end;

Procedure TFhirBundleEntryRequest.SetIfModifiedSinceST(value : TFslDateTime);
begin
  if FIfModifiedSince = nil then
    FIfModifiedSince := TFhirInstant.create;
  FIfModifiedSince.value := value
end;

Procedure TFhirBundleEntryRequest.SetIfMatch(value : TFhirString);
begin
  FIfMatch.free;
  FIfMatch := value;
end;

Function TFhirBundleEntryRequest.GetIfMatchST : String;
begin
  if FIfMatch = nil then
    result := ''
  else
    result := FIfMatch.value;
end;

Procedure TFhirBundleEntryRequest.SetIfMatchST(value : String);
begin
  if value <> '' then
  begin
    if FIfMatch = nil then
      FIfMatch := TFhirString.create;
    FIfMatch.value := value
  end
  else if FIfMatch <> nil then
    FIfMatch.value := '';
end;

Procedure TFhirBundleEntryRequest.SetIfNoneExist(value : TFhirString);
begin
  FIfNoneExist.free;
  FIfNoneExist := value;
end;

Function TFhirBundleEntryRequest.GetIfNoneExistST : String;
begin
  if FIfNoneExist = nil then
    result := ''
  else
    result := FIfNoneExist.value;
end;

Procedure TFhirBundleEntryRequest.SetIfNoneExistST(value : String);
begin
  if value <> '' then
  begin
    if FIfNoneExist = nil then
      FIfNoneExist := TFhirString.create;
    FIfNoneExist.value := value
  end
  else if FIfNoneExist <> nil then
    FIfNoneExist.value := '';
end;

function TFhirBundleEntryRequest.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FMethod.sizeInBytes);
  inc(result, FUrl.sizeInBytes);
  inc(result, FIfNoneMatch.sizeInBytes);
  inc(result, FIfModifiedSince.sizeInBytes);
  inc(result, FIfMatch.sizeInBytes);
  inc(result, FIfNoneExist.sizeInBytes);
end;

{ TFhirBundleEntryRequestListEnumerator }

Constructor TFhirBundleEntryRequestListEnumerator.Create(list : TFhirBundleEntryRequestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBundleEntryRequestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBundleEntryRequestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBundleEntryRequestListEnumerator.GetCurrent : TFhirBundleEntryRequest;
begin
  Result := FList[FIndex];
end;

function TFhirBundleEntryRequestListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirBundleEntryRequestList }
procedure TFhirBundleEntryRequestList.AddItem(value: TFhirBundleEntryRequest);
begin
  assert(value.ClassName = 'TFhirBundleEntryRequest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBundleEntryRequest');
  add(value);
end;

function TFhirBundleEntryRequestList.Append: TFhirBundleEntryRequest;
begin
  result := TFhirBundleEntryRequest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleEntryRequestList.ClearItems;
begin
  Clear;
end;

function TFhirBundleEntryRequestList.GetEnumerator : TFhirBundleEntryRequestListEnumerator;
begin
  result := TFhirBundleEntryRequestListEnumerator.Create(self.link);
end;

function TFhirBundleEntryRequestList.Clone: TFhirBundleEntryRequestList;
begin
  result := TFhirBundleEntryRequestList(inherited Clone);
end;

function TFhirBundleEntryRequestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBundleEntryRequestList.GetItemN(index: Integer): TFhirBundleEntryRequest;
begin
  result := TFhirBundleEntryRequest(ObjectByIndex[index]);
end;

function TFhirBundleEntryRequestList.ItemClass: TFslObjectClass;
begin
  result := TFhirBundleEntryRequest;
end;
function TFhirBundleEntryRequestList.IndexOf(value: TFhirBundleEntryRequest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBundleEntryRequestList.Insert(index: Integer): TFhirBundleEntryRequest;
begin
  result := TFhirBundleEntryRequest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleEntryRequestList.InsertItem(index: Integer; value: TFhirBundleEntryRequest);
begin
  assert(value is TFhirBundleEntryRequest);
  Inherited Insert(index, value);
end;

function TFhirBundleEntryRequestList.Item(index: Integer): TFhirBundleEntryRequest;
begin
  result := TFhirBundleEntryRequest(ObjectByIndex[index]);
end;

function TFhirBundleEntryRequestList.Link: TFhirBundleEntryRequestList;
begin
  result := TFhirBundleEntryRequestList(inherited Link);
end;

procedure TFhirBundleEntryRequestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBundleEntryRequestList.SetItemByIndex(index: Integer; value: TFhirBundleEntryRequest);
begin
  assert(value is TFhirBundleEntryRequest);
  FhirBundleEntryRequests[index] := value;
end;

procedure TFhirBundleEntryRequestList.SetItemN(index: Integer; value: TFhirBundleEntryRequest);
begin
  assert(value is TFhirBundleEntryRequest);
  ObjectByIndex[index] := value;
end;

{ TFhirBundleEntryResponse }

constructor TFhirBundleEntryResponse.Create;
begin
  inherited;
end;

destructor TFhirBundleEntryResponse.Destroy;
begin
  FStatus.free;
  FLocation.free;
  FEtag.free;
  FLastModified.free;
  inherited;
end;

procedure TFhirBundleEntryResponse.Assign(oSource : TFslObject);
begin
  inherited;
  statusElement := TFhirBundleEntryResponse(oSource).statusElement.Clone;
  locationElement := TFhirBundleEntryResponse(oSource).locationElement.Clone;
  etagElement := TFhirBundleEntryResponse(oSource).etagElement.Clone;
  lastModifiedElement := TFhirBundleEntryResponse(oSource).lastModifiedElement.Clone;
end;

procedure TFhirBundleEntryResponse.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'etag') Then
     list.add(self.link, 'etag', FEtag.Link);
  if (child_name = 'lastModified') Then
     list.add(self.link, 'lastModified', FLastModified.Link);
end;

procedure TFhirBundleEntryResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'status', 'string', false, TFhirString, FStatus.Link));{2}
  oList.add(TFHIRProperty.create(self, 'location', 'uri', false, TFhirUri, FLocation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'etag', 'string', false, TFhirString, FEtag.Link));{2}
  oList.add(TFHIRProperty.create(self, 'lastModified', 'instant', false, TFhirInstant, FLastModified.Link));{2}
end;

function TFhirBundleEntryResponse.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'status') then
  begin
    StatusElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    LocationElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'etag') then
  begin
    EtagElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'lastModified') then
  begin
    LastModifiedElement := asInstant(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBundleEntryResponse.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirBundleEntryResponse.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'status') then result := TFhirString.create() {5b}
  else if (propName = 'location') then result := TFhirUri.create() {5b}
  else if (propName = 'etag') then result := TFhirString.create() {5b}
  else if (propName = 'lastModified') then result := TFhirInstant.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirBundleEntryResponse.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'status') then result := 'string'
  else if (propName = 'location') then result := 'uri'
  else if (propName = 'etag') then result := 'string'
  else if (propName = 'lastModified') then result := 'instant'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBundleEntryResponse.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := nil
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'etag') then EtagElement := nil
  else if (propName = 'lastModified') then LastModifiedElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBundleEntryResponse.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := asString(new){5b}
  else if (propName = 'location') then LocationElement := asUri(new){5b}
  else if (propName = 'etag') then EtagElement := asString(new){5b}
  else if (propName = 'lastModified') then LastModifiedElement := asInstant(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBundleEntryResponse.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirBundleEntryResponse.fhirType : string;
begin
  result := 'response';
end;

function TFhirBundleEntryResponse.Link : TFhirBundleEntryResponse;
begin
  result := TFhirBundleEntryResponse(inherited Link);
end;

function TFhirBundleEntryResponse.Clone : TFhirBundleEntryResponse;
begin
  result := TFhirBundleEntryResponse(inherited Clone);
end;

function TFhirBundleEntryResponse.equals(other : TObject) : boolean;
var
  o : TFhirBundleEntryResponse;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBundleEntryResponse)) then
    result := false
  else
  begin
    o := TFhirBundleEntryResponse(other);
    result := compareDeep(statusElement, o.statusElement, true) and compareDeep(locationElement, o.locationElement, true) and
      compareDeep(etagElement, o.etagElement, true) and compareDeep(lastModifiedElement, o.lastModifiedElement, true);
  end;
end;

function TFhirBundleEntryResponse.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FStatus) and isEmptyProp(FLocation) and isEmptyProp(FEtag) and isEmptyProp(FLastModified);
end;

procedure TFhirBundleEntryResponse.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('status');
  fields.add('location');
  fields.add('etag');
  fields.add('lastModified');
end;

{ TFhirBundleEntryResponse }

Procedure TFhirBundleEntryResponse.SetStatus(value : TFhirString);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirBundleEntryResponse.GetStatusST : String;
begin
  if FStatus = nil then
    result := ''
  else
    result := FStatus.value;
end;

Procedure TFhirBundleEntryResponse.SetStatusST(value : String);
begin
  if value <> '' then
  begin
    if FStatus = nil then
      FStatus := TFhirString.create;
    FStatus.value := value
  end
  else if FStatus <> nil then
    FStatus.value := '';
end;

Procedure TFhirBundleEntryResponse.SetLocation(value : TFhirUri);
begin
  FLocation.free;
  FLocation := value;
end;

Function TFhirBundleEntryResponse.GetLocationST : String;
begin
  if FLocation = nil then
    result := ''
  else
    result := FLocation.value;
end;

Procedure TFhirBundleEntryResponse.SetLocationST(value : String);
begin
  if value <> '' then
  begin
    if FLocation = nil then
      FLocation := TFhirUri.create;
    FLocation.value := value
  end
  else if FLocation <> nil then
    FLocation.value := '';
end;

Procedure TFhirBundleEntryResponse.SetEtag(value : TFhirString);
begin
  FEtag.free;
  FEtag := value;
end;

Function TFhirBundleEntryResponse.GetEtagST : String;
begin
  if FEtag = nil then
    result := ''
  else
    result := FEtag.value;
end;

Procedure TFhirBundleEntryResponse.SetEtagST(value : String);
begin
  if value <> '' then
  begin
    if FEtag = nil then
      FEtag := TFhirString.create;
    FEtag.value := value
  end
  else if FEtag <> nil then
    FEtag.value := '';
end;

Procedure TFhirBundleEntryResponse.SetLastModified(value : TFhirInstant);
begin
  FLastModified.free;
  FLastModified := value;
end;

Function TFhirBundleEntryResponse.GetLastModifiedST : TFslDateTime;
begin
  if FLastModified = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastModified.value;
end;

Procedure TFhirBundleEntryResponse.SetLastModifiedST(value : TFslDateTime);
begin
  if FLastModified = nil then
    FLastModified := TFhirInstant.create;
  FLastModified.value := value
end;

function TFhirBundleEntryResponse.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FStatus.sizeInBytes);
  inc(result, FLocation.sizeInBytes);
  inc(result, FEtag.sizeInBytes);
  inc(result, FLastModified.sizeInBytes);
end;

{ TFhirBundleEntryResponseListEnumerator }

Constructor TFhirBundleEntryResponseListEnumerator.Create(list : TFhirBundleEntryResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBundleEntryResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBundleEntryResponseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBundleEntryResponseListEnumerator.GetCurrent : TFhirBundleEntryResponse;
begin
  Result := FList[FIndex];
end;

function TFhirBundleEntryResponseListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirBundleEntryResponseList }
procedure TFhirBundleEntryResponseList.AddItem(value: TFhirBundleEntryResponse);
begin
  assert(value.ClassName = 'TFhirBundleEntryResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBundleEntryResponse');
  add(value);
end;

function TFhirBundleEntryResponseList.Append: TFhirBundleEntryResponse;
begin
  result := TFhirBundleEntryResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleEntryResponseList.ClearItems;
begin
  Clear;
end;

function TFhirBundleEntryResponseList.GetEnumerator : TFhirBundleEntryResponseListEnumerator;
begin
  result := TFhirBundleEntryResponseListEnumerator.Create(self.link);
end;

function TFhirBundleEntryResponseList.Clone: TFhirBundleEntryResponseList;
begin
  result := TFhirBundleEntryResponseList(inherited Clone);
end;

function TFhirBundleEntryResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBundleEntryResponseList.GetItemN(index: Integer): TFhirBundleEntryResponse;
begin
  result := TFhirBundleEntryResponse(ObjectByIndex[index]);
end;

function TFhirBundleEntryResponseList.ItemClass: TFslObjectClass;
begin
  result := TFhirBundleEntryResponse;
end;
function TFhirBundleEntryResponseList.IndexOf(value: TFhirBundleEntryResponse): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBundleEntryResponseList.Insert(index: Integer): TFhirBundleEntryResponse;
begin
  result := TFhirBundleEntryResponse.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleEntryResponseList.InsertItem(index: Integer; value: TFhirBundleEntryResponse);
begin
  assert(value is TFhirBundleEntryResponse);
  Inherited Insert(index, value);
end;

function TFhirBundleEntryResponseList.Item(index: Integer): TFhirBundleEntryResponse;
begin
  result := TFhirBundleEntryResponse(ObjectByIndex[index]);
end;

function TFhirBundleEntryResponseList.Link: TFhirBundleEntryResponseList;
begin
  result := TFhirBundleEntryResponseList(inherited Link);
end;

procedure TFhirBundleEntryResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBundleEntryResponseList.SetItemByIndex(index: Integer; value: TFhirBundleEntryResponse);
begin
  assert(value is TFhirBundleEntryResponse);
  FhirBundleEntryResponses[index] := value;
end;

procedure TFhirBundleEntryResponseList.SetItemN(index: Integer; value: TFhirBundleEntryResponse);
begin
  assert(value is TFhirBundleEntryResponse);
  ObjectByIndex[index] := value;
end;

{ TFhirBundle }

constructor TFhirBundle.Create;
begin
  inherited;
end;

destructor TFhirBundle.Destroy;
begin
  FType_.free;
  FTotal.free;
  FLink_List.Free;
  FEntryList.Free;
  FSignature.free;
  inherited;
end;

function TFhirBundle.GetResourceType : TFhirResourceType;
begin
  result := frtBundle;
end;

procedure TFhirBundle.Assign(oSource : TFslObject);
begin
  inherited;
  FType_ := TFhirBundle(oSource).FType_.Link;
  totalElement := TFhirBundle(oSource).totalElement.Clone;
  if (TFhirBundle(oSource).FLink_List = nil) then
  begin
    FLink_List.free;
    FLink_List := nil;
  end
  else
  begin
    if FLink_List = nil then
      FLink_List := TFhirBundleLinkList.Create;
    FLink_List.Assign(TFhirBundle(oSource).FLink_List);
  end;
  if (TFhirBundle(oSource).FEntryList = nil) then
  begin
    FEntryList.free;
    FEntryList := nil;
  end
  else
  begin
    if FEntryList = nil then
      FEntryList := TFhirBundleEntryList.Create;
    FEntryList.Assign(TFhirBundle(oSource).FEntryList);
  end;
  signature := TFhirBundle(oSource).signature.Clone;
end;

procedure TFhirBundle.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'total') Then
     list.add(self.link, 'total', FTotal.Link);
  if (child_name = 'link') Then
    list.addAll(self, 'link', FLink_List);
  if (child_name = 'entry') Then
    list.addAll(self, 'entry', FEntryList);
  if (child_name = 'signature') Then
     list.add(self.link, 'signature', FSignature.Link);
end;

procedure TFhirBundle.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'total', 'unsignedInt', false, TFhirUnsignedInt, FTotal.Link));{2}
  oList.add(TFHIRProperty.create(self, 'link', '', true, TFhirBundleLink, FLink_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'entry', '', true, TFhirBundleEntry, FEntryList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'signature', 'Signature', false, TFhirSignature, FSignature.Link));{2}
end;

function TFhirBundle.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirBundleTypeEnum, CODES_TFhirBundleTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'total') then
  begin
    TotalElement := asUnsignedInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'link') then
  begin
    Link_List.add(propValue as TFhirBundleLink){2a};
    result := propValue;
  end
  else if (propName = 'entry') then
  begin
    EntryList.add(propValue as TFhirBundleEntry){2a};
    result := propValue;
  end
  else if (propName = 'signature') then
  begin
    Signature := propValue as TFhirSignature{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirBundle.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'link') then Link_List.insertItem(index, propValue as TFhirBundleLink){2a}
  else if (propName = 'entry') then EntryList.insertItem(index, propValue as TFhirBundleEntry){2a}
  else inherited;
end;

function TFhirBundle.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'total') then result := TFhirUnsignedInt.create() {5b}
  else if (propName = 'link') then result := Link_List.new(){2}
  else if (propName = 'entry') then result := EntryList.new(){2}
  else if (propName = 'signature') then result := TFhirSignature.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirBundle.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'total') then result := 'unsignedInt'
  else if (propName = 'link') then result := ''
  else if (propName = 'entry') then result := ''
  else if (propName = 'signature') then result := 'Signature'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBundle.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'total') then TotalElement := nil
  else if (propName = 'link') then deletePropertyValue('link', Link_List, value) {2}
  else if (propName = 'entry') then deletePropertyValue('entry', EntryList, value) {2}
  else if (propName = 'signature') then SignatureElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBundle.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirBundleTypeEnum, CODES_TFhirBundleTypeEnum, new){4}
  else if (propName = 'total') then TotalElement := asUnsignedInt(new){5b}
  else if (propName = 'link') then replacePropertyValue('link', Link_List, existing, new) {2}
  else if (propName = 'entry') then replacePropertyValue('entry', EntryList, existing, new) {2}
  else if (propName = 'signature') then SignatureElement := new as TFhirSignature{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBundle.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'link') then Link_List.move(source, destination){2a}
  else if (propName = 'entry') then EntryList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirBundle.fhirType : string;
begin
  result := 'Bundle';
end;

function TFhirBundle.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FTotal) and isEmptyProp(Flink_List) and isEmptyProp(FentryList) and isEmptyProp(FSignature);
end;

function TFhirBundle.equals(other : TObject) : boolean;
var
  o : TFhirBundle;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBundle)) then
    result := false
  else
  begin
    o := TFhirBundle(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(totalElement, o.totalElement, true) and
      compareDeep(link_List, o.link_List, true) and compareDeep(entryList, o.entryList, true) and
      compareDeep(signatureElement, o.signatureElement, true);
  end;
end;

function TFhirBundle.Link : TFhirBundle;
begin
  result := TFhirBundle(inherited Link);
end;

function TFhirBundle.Clone : TFhirBundle;
begin
  result := TFhirBundle(inherited Clone);
end;

procedure TFhirBundle.listFieldsInOrder(fields : TStringList);
begin
  listResourceFieldsInOrder(fields);
  fields.add('type');
  fields.add('total');
  fields.add('link');
  fields.add('entry');
  fields.add('signature');
end;

{ TFhirBundle }

Procedure TFhirBundle.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirBundle.GetType_ST : TFhirBundleTypeEnum;
begin
  if FType_ = nil then
    result := TFhirBundleTypeEnum(0)
  else
    result := TFhirBundleTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirBundleTypeEnum, FType_.value));
end;

Procedure TFhirBundle.SetType_ST(value : TFhirBundleTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirBundleTypeEnum[value], CODES_TFhirBundleTypeEnum[value]);
end;

Procedure TFhirBundle.SetTotal(value : TFhirUnsignedInt);
begin
  FTotal.free;
  FTotal := value;
end;

Function TFhirBundle.GetTotalST : String;
begin
  if FTotal = nil then
    result := ''
  else
    result := FTotal.value;
end;

Procedure TFhirBundle.SetTotalST(value : String);
begin
  if value <> '' then
  begin
    if FTotal = nil then
      FTotal := TFhirUnsignedInt.create;
    FTotal.value := value
  end
  else if FTotal <> nil then
    FTotal.value := '';
end;

Function TFhirBundle.GetLink_List : TFhirBundleLinkList;
begin
  if FLink_List = nil then
    FLink_List := TFhirBundleLinkList.Create;
  result := FLink_List;
end;

Function TFhirBundle.GetHasLink_List : boolean;
begin
  result := (FLink_List <> nil) and (FLink_List.count > 0);
end;

Function TFhirBundle.GetEntryList : TFhirBundleEntryList;
begin
  if FEntryList = nil then
    FEntryList := TFhirBundleEntryList.Create;
  result := FEntryList;
end;

Function TFhirBundle.GetHasEntryList : boolean;
begin
  result := (FEntryList <> nil) and (FEntryList.count > 0);
end;

Procedure TFhirBundle.SetSignature(value : TFhirSignature);
begin
  FSignature.free;
  FSignature := value;
end;

function TFhirBundle.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FTotal.sizeInBytes);
  inc(result, Flink_List.sizeInBytes);
  inc(result, FentryList.sizeInBytes);
  inc(result, FSignature.sizeInBytes);
end;

{ TFhirBundleListEnumerator }

Constructor TFhirBundleListEnumerator.Create(list : TFhirBundleList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBundleListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBundleListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBundleListEnumerator.GetCurrent : TFhirBundle;
begin
  Result := FList[FIndex];
end;

function TFhirBundleListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirBundleList }
procedure TFhirBundleList.AddItem(value: TFhirBundle);
begin
  assert(value.ClassName = 'TFhirBundle', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBundle');
  add(value);
end;

function TFhirBundleList.Append: TFhirBundle;
begin
  result := TFhirBundle.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleList.ClearItems;
begin
  Clear;
end;

function TFhirBundleList.GetEnumerator : TFhirBundleListEnumerator;
begin
  result := TFhirBundleListEnumerator.Create(self.link);
end;

function TFhirBundleList.Clone: TFhirBundleList;
begin
  result := TFhirBundleList(inherited Clone);
end;

function TFhirBundleList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBundleList.GetItemN(index: Integer): TFhirBundle;
begin
  result := TFhirBundle(ObjectByIndex[index]);
end;

function TFhirBundleList.ItemClass: TFslObjectClass;
begin
  result := TFhirBundle;
end;
function TFhirBundleList.IndexOf(value: TFhirBundle): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBundleList.Insert(index: Integer): TFhirBundle;
begin
  result := TFhirBundle.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleList.InsertItem(index: Integer; value: TFhirBundle);
begin
  assert(value is TFhirBundle);
  Inherited Insert(index, value);
end;

function TFhirBundleList.Item(index: Integer): TFhirBundle;
begin
  result := TFhirBundle(ObjectByIndex[index]);
end;

function TFhirBundleList.Link: TFhirBundleList;
begin
  result := TFhirBundleList(inherited Link);
end;

procedure TFhirBundleList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBundleList.SetItemByIndex(index: Integer; value: TFhirBundle);
begin
  assert(value is TFhirBundle);
  FhirBundles[index] := value;
end;

procedure TFhirBundleList.SetItemN(index: Integer; value: TFhirBundle);
begin
  assert(value is TFhirBundle);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_BUNDLE}

{$IFDEF FHIR_CLAIM}

{ TFhirClaimPayee }

constructor TFhirClaimPayee.Create;
begin
  inherited;
end;

destructor TFhirClaimPayee.Destroy;
begin
  FType_.free;
  FProvider.free;
  FOrganization.free;
  FPerson.free;
  inherited;
end;

procedure TFhirClaimPayee.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirClaimPayee(oSource).type_.Clone;
  provider := TFhirClaimPayee(oSource).provider.Clone;
  organization := TFhirClaimPayee(oSource).organization.Clone;
  person := TFhirClaimPayee(oSource).person.Clone;
end;

procedure TFhirClaimPayee.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'provider') Then
     list.add(self.link, 'provider', FProvider.Link);
  if (child_name = 'organization') Then
     list.add(self.link, 'organization', FOrganization.Link);
  if (child_name = 'person') Then
     list.add(self.link, 'person', FPerson.Link);
end;

procedure TFhirClaimPayee.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', false, TFhirCoding, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FProvider.Link));{2}
  oList.add(TFHIRProperty.create(self, 'organization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FOrganization.Link));{2}
  oList.add(TFHIRProperty.create(self, 'person', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPerson.Link));{2}
end;

function TFhirClaimPayee.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'provider') then
  begin
    Provider := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'organization') then
  begin
    Organization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'person') then
  begin
    Person := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimPayee.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimPayee.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCoding.create(){4b}
  else if (propName = 'provider') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'organization') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'person') then result := TFhirReference{TFhirPatient}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimPayee.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'Coding'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'organization') then result := 'Reference'
  else if (propName = 'person') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimPayee.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'provider') then ProviderElement := nil
  else if (propName = 'organization') then OrganizationElement := nil
  else if (propName = 'person') then PersonElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimPayee.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCoding{4}
  else if (propName = 'provider') then ProviderElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'organization') then OrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'person') then PersonElement := new as TFhirReference{TFhirPatient}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimPayee.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimPayee.fhirType : string;
begin
  result := 'payee';
end;

function TFhirClaimPayee.Link : TFhirClaimPayee;
begin
  result := TFhirClaimPayee(inherited Link);
end;

function TFhirClaimPayee.Clone : TFhirClaimPayee;
begin
  result := TFhirClaimPayee(inherited Clone);
end;

function TFhirClaimPayee.equals(other : TObject) : boolean;
var
  o : TFhirClaimPayee;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimPayee)) then
    result := false
  else
  begin
    o := TFhirClaimPayee(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(providerElement, o.providerElement, true) and
      compareDeep(organizationElement, o.organizationElement, true) and compareDeep(personElement, o.personElement, true);
  end;
end;

function TFhirClaimPayee.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FProvider) and isEmptyProp(FOrganization) and isEmptyProp(FPerson);
end;

procedure TFhirClaimPayee.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('provider');
  fields.add('organization');
  fields.add('person');
end;

{ TFhirClaimPayee }

Procedure TFhirClaimPayee.SetType_(value : TFhirCoding);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirClaimPayee.SetProvider(value : TFhirReference{TFhirPractitioner});
begin
  FProvider.free;
  FProvider := value;
end;

Procedure TFhirClaimPayee.SetOrganization(value : TFhirReference{TFhirOrganization});
begin
  FOrganization.free;
  FOrganization := value;
end;

Procedure TFhirClaimPayee.SetPerson(value : TFhirReference{TFhirPatient});
begin
  FPerson.free;
  FPerson := value;
end;

function TFhirClaimPayee.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FProvider.sizeInBytes);
  inc(result, FOrganization.sizeInBytes);
  inc(result, FPerson.sizeInBytes);
end;

{ TFhirClaimPayeeListEnumerator }

Constructor TFhirClaimPayeeListEnumerator.Create(list : TFhirClaimPayeeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimPayeeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimPayeeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimPayeeListEnumerator.GetCurrent : TFhirClaimPayee;
begin
  Result := FList[FIndex];
end;

function TFhirClaimPayeeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimPayeeList }
procedure TFhirClaimPayeeList.AddItem(value: TFhirClaimPayee);
begin
  assert(value.ClassName = 'TFhirClaimPayee', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimPayee');
  add(value);
end;

function TFhirClaimPayeeList.Append: TFhirClaimPayee;
begin
  result := TFhirClaimPayee.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimPayeeList.ClearItems;
begin
  Clear;
end;

function TFhirClaimPayeeList.GetEnumerator : TFhirClaimPayeeListEnumerator;
begin
  result := TFhirClaimPayeeListEnumerator.Create(self.link);
end;

function TFhirClaimPayeeList.Clone: TFhirClaimPayeeList;
begin
  result := TFhirClaimPayeeList(inherited Clone);
end;

function TFhirClaimPayeeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimPayeeList.GetItemN(index: Integer): TFhirClaimPayee;
begin
  result := TFhirClaimPayee(ObjectByIndex[index]);
end;

function TFhirClaimPayeeList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimPayee;
end;
function TFhirClaimPayeeList.IndexOf(value: TFhirClaimPayee): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimPayeeList.Insert(index: Integer): TFhirClaimPayee;
begin
  result := TFhirClaimPayee.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimPayeeList.InsertItem(index: Integer; value: TFhirClaimPayee);
begin
  assert(value is TFhirClaimPayee);
  Inherited Insert(index, value);
end;

function TFhirClaimPayeeList.Item(index: Integer): TFhirClaimPayee;
begin
  result := TFhirClaimPayee(ObjectByIndex[index]);
end;

function TFhirClaimPayeeList.Link: TFhirClaimPayeeList;
begin
  result := TFhirClaimPayeeList(inherited Link);
end;

procedure TFhirClaimPayeeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimPayeeList.SetItemByIndex(index: Integer; value: TFhirClaimPayee);
begin
  assert(value is TFhirClaimPayee);
  FhirClaimPayees[index] := value;
end;

procedure TFhirClaimPayeeList.SetItemN(index: Integer; value: TFhirClaimPayee);
begin
  assert(value is TFhirClaimPayee);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimDiagnosis }

constructor TFhirClaimDiagnosis.Create;
begin
  inherited;
end;

destructor TFhirClaimDiagnosis.Destroy;
begin
  FSequence.free;
  FDiagnosis.free;
  inherited;
end;

procedure TFhirClaimDiagnosis.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirClaimDiagnosis(oSource).sequenceElement.Clone;
  diagnosis := TFhirClaimDiagnosis(oSource).diagnosis.Clone;
end;

procedure TFhirClaimDiagnosis.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'diagnosis') Then
     list.add(self.link, 'diagnosis', FDiagnosis.Link);
end;

procedure TFhirClaimDiagnosis.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'diagnosis', 'Coding', false, TFhirCoding, FDiagnosis.Link));{2}
end;

function TFhirClaimDiagnosis.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'diagnosis') then
  begin
    Diagnosis := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimDiagnosis.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimDiagnosis.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'diagnosis') then result := TFhirCoding.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimDiagnosis.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'diagnosis') then result := 'Coding'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimDiagnosis.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'diagnosis') then DiagnosisElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimDiagnosis.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new){5b}
  else if (propName = 'diagnosis') then DiagnosisElement := new as TFhirCoding{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimDiagnosis.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimDiagnosis.fhirType : string;
begin
  result := 'diagnosis';
end;

function TFhirClaimDiagnosis.Link : TFhirClaimDiagnosis;
begin
  result := TFhirClaimDiagnosis(inherited Link);
end;

function TFhirClaimDiagnosis.Clone : TFhirClaimDiagnosis;
begin
  result := TFhirClaimDiagnosis(inherited Clone);
end;

function TFhirClaimDiagnosis.equals(other : TObject) : boolean;
var
  o : TFhirClaimDiagnosis;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimDiagnosis)) then
    result := false
  else
  begin
    o := TFhirClaimDiagnosis(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(diagnosisElement, o.diagnosisElement, true);
  end;
end;

function TFhirClaimDiagnosis.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FDiagnosis);
end;

procedure TFhirClaimDiagnosis.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('diagnosis');
end;

{ TFhirClaimDiagnosis }

Procedure TFhirClaimDiagnosis.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirClaimDiagnosis.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirClaimDiagnosis.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Procedure TFhirClaimDiagnosis.SetDiagnosis(value : TFhirCoding);
begin
  FDiagnosis.free;
  FDiagnosis := value;
end;

function TFhirClaimDiagnosis.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FDiagnosis.sizeInBytes);
end;

{ TFhirClaimDiagnosisListEnumerator }

Constructor TFhirClaimDiagnosisListEnumerator.Create(list : TFhirClaimDiagnosisList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimDiagnosisListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimDiagnosisListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimDiagnosisListEnumerator.GetCurrent : TFhirClaimDiagnosis;
begin
  Result := FList[FIndex];
end;

function TFhirClaimDiagnosisListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimDiagnosisList }
procedure TFhirClaimDiagnosisList.AddItem(value: TFhirClaimDiagnosis);
begin
  assert(value.ClassName = 'TFhirClaimDiagnosis', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimDiagnosis');
  add(value);
end;

function TFhirClaimDiagnosisList.Append: TFhirClaimDiagnosis;
begin
  result := TFhirClaimDiagnosis.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimDiagnosisList.ClearItems;
begin
  Clear;
end;

function TFhirClaimDiagnosisList.GetEnumerator : TFhirClaimDiagnosisListEnumerator;
begin
  result := TFhirClaimDiagnosisListEnumerator.Create(self.link);
end;

function TFhirClaimDiagnosisList.Clone: TFhirClaimDiagnosisList;
begin
  result := TFhirClaimDiagnosisList(inherited Clone);
end;

function TFhirClaimDiagnosisList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimDiagnosisList.GetItemN(index: Integer): TFhirClaimDiagnosis;
begin
  result := TFhirClaimDiagnosis(ObjectByIndex[index]);
end;

function TFhirClaimDiagnosisList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimDiagnosis;
end;
function TFhirClaimDiagnosisList.IndexOf(value: TFhirClaimDiagnosis): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimDiagnosisList.Insert(index: Integer): TFhirClaimDiagnosis;
begin
  result := TFhirClaimDiagnosis.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimDiagnosisList.InsertItem(index: Integer; value: TFhirClaimDiagnosis);
begin
  assert(value is TFhirClaimDiagnosis);
  Inherited Insert(index, value);
end;

function TFhirClaimDiagnosisList.Item(index: Integer): TFhirClaimDiagnosis;
begin
  result := TFhirClaimDiagnosis(ObjectByIndex[index]);
end;

function TFhirClaimDiagnosisList.Link: TFhirClaimDiagnosisList;
begin
  result := TFhirClaimDiagnosisList(inherited Link);
end;

procedure TFhirClaimDiagnosisList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimDiagnosisList.SetItemByIndex(index: Integer; value: TFhirClaimDiagnosis);
begin
  assert(value is TFhirClaimDiagnosis);
  FhirClaimDiagnoses[index] := value;
end;

procedure TFhirClaimDiagnosisList.SetItemN(index: Integer; value: TFhirClaimDiagnosis);
begin
  assert(value is TFhirClaimDiagnosis);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimCoverage }

constructor TFhirClaimCoverage.Create;
begin
  inherited;
end;

destructor TFhirClaimCoverage.Destroy;
begin
  FSequence.free;
  FFocal.free;
  FCoverage.free;
  FBusinessArrangement.free;
  FRelationship.free;
  FPreAuthRefList.Free;
  FClaimResponse.free;
  FOriginalRuleset.free;
  inherited;
end;

procedure TFhirClaimCoverage.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirClaimCoverage(oSource).sequenceElement.Clone;
  focalElement := TFhirClaimCoverage(oSource).focalElement.Clone;
  coverage := TFhirClaimCoverage(oSource).coverage.Clone;
  businessArrangementElement := TFhirClaimCoverage(oSource).businessArrangementElement.Clone;
  relationship := TFhirClaimCoverage(oSource).relationship.Clone;
  if (TFhirClaimCoverage(oSource).FPreAuthRefList = nil) then
  begin
    FPreAuthRefList.free;
    FPreAuthRefList := nil;
  end
  else
  begin
    if FPreAuthRefList = nil then
      FPreAuthRefList := TFhirStringList.Create;
    FPreAuthRefList.Assign(TFhirClaimCoverage(oSource).FPreAuthRefList);
  end;
  claimResponse := TFhirClaimCoverage(oSource).claimResponse.Clone;
  originalRuleset := TFhirClaimCoverage(oSource).originalRuleset.Clone;
end;

procedure TFhirClaimCoverage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'focal') Then
     list.add(self.link, 'focal', FFocal.Link);
  if (child_name = 'coverage') Then
     list.add(self.link, 'coverage', FCoverage.Link);
  if (child_name = 'businessArrangement') Then
     list.add(self.link, 'businessArrangement', FBusinessArrangement.Link);
  if (child_name = 'relationship') Then
     list.add(self.link, 'relationship', FRelationship.Link);
  if (child_name = 'preAuthRef') Then
    list.addAll(self, 'preAuthRef', FPreAuthRefList);
  if (child_name = 'claimResponse') Then
     list.add(self.link, 'claimResponse', FClaimResponse.Link);
  if (child_name = 'originalRuleset') Then
     list.add(self.link, 'originalRuleset', FOriginalRuleset.Link);
end;

procedure TFhirClaimCoverage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'focal', 'boolean', false, TFhirBoolean, FFocal.Link));{2}
  oList.add(TFHIRProperty.create(self, 'coverage', 'Reference(Coverage)', false, TFhirReference{TFhirCoverage}, FCoverage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'businessArrangement', 'string', false, TFhirString, FBusinessArrangement.Link));{2}
  oList.add(TFHIRProperty.create(self, 'relationship', 'Coding', false, TFhirCoding, FRelationship.Link));{2}
  oList.add(TFHIRProperty.create(self, 'preAuthRef', 'string', true, TFhirString, FPreAuthRefList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'claimResponse', 'Reference(ClaimResponse)', false, TFhirReference{TFhirClaimResponse}, FClaimResponse.Link));{2}
  oList.add(TFHIRProperty.create(self, 'originalRuleset', 'Coding', false, TFhirCoding, FOriginalRuleset.Link));{2}
end;

function TFhirClaimCoverage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'focal') then
  begin
    FocalElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'coverage') then
  begin
    Coverage := propValue as TFhirReference{TFhirCoverage}{4b};
    result := propValue;
  end
  else if (propName = 'businessArrangement') then
  begin
    BusinessArrangementElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'relationship') then
  begin
    Relationship := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'preAuthRef') then
  begin
    PreAuthRefList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'claimResponse') then
  begin
    ClaimResponse := propValue as TFhirReference{TFhirClaimResponse}{4b};
    result := propValue;
  end
  else if (propName = 'originalRuleset') then
  begin
    OriginalRuleset := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimCoverage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'preAuthRef') then PreAuthRefList.insertItem(index, asString(propValue)){2}
  else inherited;
end;

function TFhirClaimCoverage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'focal') then result := TFhirBoolean.create() {5b}
  else if (propName = 'coverage') then result := TFhirReference{TFhirCoverage}.create(){4b}
  else if (propName = 'businessArrangement') then result := TFhirString.create() {5b}
  else if (propName = 'relationship') then result := TFhirCoding.create(){4b}
  else if (propName = 'preAuthRef') then result := PreAuthRefList.new(){2}
  else if (propName = 'claimResponse') then result := TFhirReference{TFhirClaimResponse}.create(){4b}
  else if (propName = 'originalRuleset') then result := TFhirCoding.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimCoverage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'focal') then result := 'boolean'
  else if (propName = 'coverage') then result := 'Reference'
  else if (propName = 'businessArrangement') then result := 'string'
  else if (propName = 'relationship') then result := 'Coding'
  else if (propName = 'preAuthRef') then result := 'string'
  else if (propName = 'claimResponse') then result := 'Reference'
  else if (propName = 'originalRuleset') then result := 'Coding'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimCoverage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'focal') then FocalElement := nil
  else if (propName = 'coverage') then CoverageElement := nil
  else if (propName = 'businessArrangement') then BusinessArrangementElement := nil
  else if (propName = 'relationship') then RelationshipElement := nil
  else if (propName = 'preAuthRef') then deletePropertyValue('preAuthRef', PreAuthRefList, value) {2}
  else if (propName = 'claimResponse') then ClaimResponseElement := nil
  else if (propName = 'originalRuleset') then OriginalRulesetElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimCoverage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new){5b}
  else if (propName = 'focal') then FocalElement := asBoolean(new){5b}
  else if (propName = 'coverage') then CoverageElement := new as TFhirReference{TFhirCoverage}{4}
  else if (propName = 'businessArrangement') then BusinessArrangementElement := asString(new){5b}
  else if (propName = 'relationship') then RelationshipElement := new as TFhirCoding{4}
  else if (propName = 'preAuthRef') then replacePropertyValue('preAuthRef', PreAuthRefList, existing, new) {2}
  else if (propName = 'claimResponse') then ClaimResponseElement := new as TFhirReference{TFhirClaimResponse}{4}
  else if (propName = 'originalRuleset') then OriginalRulesetElement := new as TFhirCoding{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimCoverage.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'preAuthRef') then PreAuthRefList.move(source, destination){2}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimCoverage.fhirType : string;
begin
  result := 'coverage';
end;

function TFhirClaimCoverage.Link : TFhirClaimCoverage;
begin
  result := TFhirClaimCoverage(inherited Link);
end;

function TFhirClaimCoverage.Clone : TFhirClaimCoverage;
begin
  result := TFhirClaimCoverage(inherited Clone);
end;

function TFhirClaimCoverage.equals(other : TObject) : boolean;
var
  o : TFhirClaimCoverage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimCoverage)) then
    result := false
  else
  begin
    o := TFhirClaimCoverage(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(focalElement, o.focalElement, true) and
      compareDeep(coverageElement, o.coverageElement, true) and compareDeep(businessArrangementElement, o.businessArrangementElement, true) and
      compareDeep(relationshipElement, o.relationshipElement, true) and compareDeep(preAuthRefList, o.preAuthRefList, true) and
      compareDeep(claimResponseElement, o.claimResponseElement, true) and compareDeep(originalRulesetElement, o.originalRulesetElement, true);
  end;
end;

function TFhirClaimCoverage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FFocal) and isEmptyProp(FCoverage) and isEmptyProp(FBusinessArrangement) and isEmptyProp(FRelationship) and isEmptyProp(FpreAuthRefList) and isEmptyProp(FClaimResponse) and isEmptyProp(FOriginalRuleset);
end;

procedure TFhirClaimCoverage.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('focal');
  fields.add('coverage');
  fields.add('businessArrangement');
  fields.add('relationship');
  fields.add('preAuthRef');
  fields.add('claimResponse');
  fields.add('originalRuleset');
end;

{ TFhirClaimCoverage }

Procedure TFhirClaimCoverage.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirClaimCoverage.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirClaimCoverage.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Procedure TFhirClaimCoverage.SetFocal(value : TFhirBoolean);
begin
  FFocal.free;
  FFocal := value;
end;

Function TFhirClaimCoverage.GetFocalST : Boolean;
begin
  if FFocal = nil then
    result := false
  else
    result := FFocal.value;
end;

Procedure TFhirClaimCoverage.SetFocalST(value : Boolean);
begin
  if FFocal = nil then
    FFocal := TFhirBoolean.create;
  FFocal.value := value
end;

Procedure TFhirClaimCoverage.SetCoverage(value : TFhirReference{TFhirCoverage});
begin
  FCoverage.free;
  FCoverage := value;
end;

Procedure TFhirClaimCoverage.SetBusinessArrangement(value : TFhirString);
begin
  FBusinessArrangement.free;
  FBusinessArrangement := value;
end;

Function TFhirClaimCoverage.GetBusinessArrangementST : String;
begin
  if FBusinessArrangement = nil then
    result := ''
  else
    result := FBusinessArrangement.value;
end;

Procedure TFhirClaimCoverage.SetBusinessArrangementST(value : String);
begin
  if value <> '' then
  begin
    if FBusinessArrangement = nil then
      FBusinessArrangement := TFhirString.create;
    FBusinessArrangement.value := value
  end
  else if FBusinessArrangement <> nil then
    FBusinessArrangement.value := '';
end;

Procedure TFhirClaimCoverage.SetRelationship(value : TFhirCoding);
begin
  FRelationship.free;
  FRelationship := value;
end;

Function TFhirClaimCoverage.GetPreAuthRefList : TFhirStringList;
begin
  if FPreAuthRefList = nil then
    FPreAuthRefList := TFhirStringList.Create;
  result := FPreAuthRefList;
end;

Function TFhirClaimCoverage.GetHasPreAuthRefList : boolean;
begin
  result := (FPreAuthRefList <> nil) and (FPreAuthRefList.count > 0);
end;

Procedure TFhirClaimCoverage.SetClaimResponse(value : TFhirReference{TFhirClaimResponse});
begin
  FClaimResponse.free;
  FClaimResponse := value;
end;

Procedure TFhirClaimCoverage.SetOriginalRuleset(value : TFhirCoding);
begin
  FOriginalRuleset.free;
  FOriginalRuleset := value;
end;

function TFhirClaimCoverage.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FFocal.sizeInBytes);
  inc(result, FCoverage.sizeInBytes);
  inc(result, FBusinessArrangement.sizeInBytes);
  inc(result, FRelationship.sizeInBytes);
  inc(result, FpreAuthRefList.sizeInBytes);
  inc(result, FClaimResponse.sizeInBytes);
  inc(result, FOriginalRuleset.sizeInBytes);
end;

{ TFhirClaimCoverageListEnumerator }

Constructor TFhirClaimCoverageListEnumerator.Create(list : TFhirClaimCoverageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimCoverageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimCoverageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimCoverageListEnumerator.GetCurrent : TFhirClaimCoverage;
begin
  Result := FList[FIndex];
end;

function TFhirClaimCoverageListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimCoverageList }
procedure TFhirClaimCoverageList.AddItem(value: TFhirClaimCoverage);
begin
  assert(value.ClassName = 'TFhirClaimCoverage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimCoverage');
  add(value);
end;

function TFhirClaimCoverageList.Append: TFhirClaimCoverage;
begin
  result := TFhirClaimCoverage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimCoverageList.ClearItems;
begin
  Clear;
end;

function TFhirClaimCoverageList.GetEnumerator : TFhirClaimCoverageListEnumerator;
begin
  result := TFhirClaimCoverageListEnumerator.Create(self.link);
end;

function TFhirClaimCoverageList.Clone: TFhirClaimCoverageList;
begin
  result := TFhirClaimCoverageList(inherited Clone);
end;

function TFhirClaimCoverageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimCoverageList.GetItemN(index: Integer): TFhirClaimCoverage;
begin
  result := TFhirClaimCoverage(ObjectByIndex[index]);
end;

function TFhirClaimCoverageList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimCoverage;
end;
function TFhirClaimCoverageList.IndexOf(value: TFhirClaimCoverage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimCoverageList.Insert(index: Integer): TFhirClaimCoverage;
begin
  result := TFhirClaimCoverage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimCoverageList.InsertItem(index: Integer; value: TFhirClaimCoverage);
begin
  assert(value is TFhirClaimCoverage);
  Inherited Insert(index, value);
end;

function TFhirClaimCoverageList.Item(index: Integer): TFhirClaimCoverage;
begin
  result := TFhirClaimCoverage(ObjectByIndex[index]);
end;

function TFhirClaimCoverageList.Link: TFhirClaimCoverageList;
begin
  result := TFhirClaimCoverageList(inherited Link);
end;

procedure TFhirClaimCoverageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimCoverageList.SetItemByIndex(index: Integer; value: TFhirClaimCoverage);
begin
  assert(value is TFhirClaimCoverage);
  FhirClaimCoverages[index] := value;
end;

procedure TFhirClaimCoverageList.SetItemN(index: Integer; value: TFhirClaimCoverage);
begin
  assert(value is TFhirClaimCoverage);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimItem }

constructor TFhirClaimItem.Create;
begin
  inherited;
end;

destructor TFhirClaimItem.Destroy;
begin
  FSequence.free;
  FType_.free;
  FProvider.free;
  FDiagnosisLinkIdList.Free;
  FService.free;
  FServiceDate.free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FPoints.free;
  FNet.free;
  FUdi.free;
  FBodySite.free;
  FSubSiteList.Free;
  FModifierList.Free;
  FDetailList.Free;
  FProsthesis.free;
  inherited;
end;

procedure TFhirClaimItem.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirClaimItem(oSource).sequenceElement.Clone;
  type_ := TFhirClaimItem(oSource).type_.Clone;
  provider := TFhirClaimItem(oSource).provider.Clone;
  if (TFhirClaimItem(oSource).FDiagnosisLinkIdList = nil) then
  begin
    FDiagnosisLinkIdList.free;
    FDiagnosisLinkIdList := nil;
  end
  else
  begin
    if FDiagnosisLinkIdList = nil then
      FDiagnosisLinkIdList := TFhirPositiveIntList.Create;
    FDiagnosisLinkIdList.Assign(TFhirClaimItem(oSource).FDiagnosisLinkIdList);
  end;
  service := TFhirClaimItem(oSource).service.Clone;
  serviceDateElement := TFhirClaimItem(oSource).serviceDateElement.Clone;
  quantity := TFhirClaimItem(oSource).quantity.Clone;
  unitPrice := TFhirClaimItem(oSource).unitPrice.Clone;
  factorElement := TFhirClaimItem(oSource).factorElement.Clone;
  pointsElement := TFhirClaimItem(oSource).pointsElement.Clone;
  net := TFhirClaimItem(oSource).net.Clone;
  udi := TFhirClaimItem(oSource).udi.Clone;
  bodySite := TFhirClaimItem(oSource).bodySite.Clone;
  if (TFhirClaimItem(oSource).FSubSiteList = nil) then
  begin
    FSubSiteList.free;
    FSubSiteList := nil;
  end
  else
  begin
    if FSubSiteList = nil then
      FSubSiteList := TFhirCodingList.Create;
    FSubSiteList.Assign(TFhirClaimItem(oSource).FSubSiteList);
  end;
  if (TFhirClaimItem(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodingList.Create;
    FModifierList.Assign(TFhirClaimItem(oSource).FModifierList);
  end;
  if (TFhirClaimItem(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirClaimItemDetailList.Create;
    FDetailList.Assign(TFhirClaimItem(oSource).FDetailList);
  end;
  prosthesis := TFhirClaimItem(oSource).prosthesis.Clone;
end;

procedure TFhirClaimItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'provider') Then
     list.add(self.link, 'provider', FProvider.Link);
  if (child_name = 'diagnosisLinkId') Then
    list.addAll(self, 'diagnosisLinkId', FDiagnosisLinkIdList);
  if (child_name = 'service') Then
     list.add(self.link, 'service', FService.Link);
  if (child_name = 'serviceDate') Then
     list.add(self.link, 'serviceDate', FServiceDate.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'points') Then
     list.add(self.link, 'points', FPoints.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'udi') Then
     list.add(self.link, 'udi', FUdi.Link);
  if (child_name = 'bodySite') Then
     list.add(self.link, 'bodySite', FBodySite.Link);
  if (child_name = 'subSite') Then
    list.addAll(self, 'subSite', FSubSiteList);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
  if (child_name = 'prosthesis') Then
     list.add(self.link, 'prosthesis', FProsthesis.Link);
end;

procedure TFhirClaimItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', false, TFhirCoding, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FProvider.Link));{2}
  oList.add(TFHIRProperty.create(self, 'diagnosisLinkId', 'positiveInt', true, TFhirPositiveInt, FDiagnosisLinkIdList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'service', 'Coding', false, TFhirCoding, FService.Link));{2}
  oList.add(TFHIRProperty.create(self, 'serviceDate', 'date', false, TFhirDate, FServiceDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Quantity', false, TFhirQuantity, FUnitPrice.Link));{2}
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'points', 'decimal', false, TFhirDecimal, FPoints.Link));{2}
  oList.add(TFHIRProperty.create(self, 'net', 'Quantity', false, TFhirQuantity, FNet.Link));{2}
  oList.add(TFHIRProperty.create(self, 'udi', 'Coding', false, TFhirCoding, FUdi.Link));{2}
  oList.add(TFHIRProperty.create(self, 'bodySite', 'Coding', false, TFhirCoding, FBodySite.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subSite', 'Coding', true, TFhirCoding, FSubSiteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'modifier', 'Coding', true, TFhirCoding, FModifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'detail', '', true, TFhirClaimItemDetail, FDetailList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'prosthesis', '', false, TFhirClaimItemProsthesis, FProsthesis.Link));{2}
end;

function TFhirClaimItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'provider') then
  begin
    Provider := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'diagnosisLinkId') then
  begin
    DiagnosisLinkIdList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'service') then
  begin
    Service := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'serviceDate') then
  begin
    ServiceDateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'points') then
  begin
    PointsElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'udi') then
  begin
    Udi := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySite := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'subSite') then
  begin
    SubSiteList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirClaimItemDetail){2a};
    result := propValue;
  end
  else if (propName = 'prosthesis') then
  begin
    Prosthesis := propValue as TFhirClaimItemProsthesis{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'diagnosisLinkId') then DiagnosisLinkIdList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'subSite') then SubSiteList.insertItem(index, propValue as TFhirCoding){2a}
  else if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCoding){2a}
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirClaimItemDetail){2a}
  else inherited;
end;

function TFhirClaimItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'type') then result := TFhirCoding.create(){4b}
  else if (propName = 'provider') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'diagnosisLinkId') then result := DiagnosisLinkIdList.new(){2}
  else if (propName = 'service') then result := TFhirCoding.create(){4b}
  else if (propName = 'serviceDate') then result := TFhirDate.create() {5b}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'unitPrice') then result := TFhirQuantity.create(){4b}
  else if (propName = 'factor') then result := TFhirDecimal.create() {5b}
  else if (propName = 'points') then result := TFhirDecimal.create() {5b}
  else if (propName = 'net') then result := TFhirQuantity.create(){4b}
  else if (propName = 'udi') then result := TFhirCoding.create(){4b}
  else if (propName = 'bodySite') then result := TFhirCoding.create(){4b}
  else if (propName = 'subSite') then result := SubSiteList.new(){2}
  else if (propName = 'modifier') then result := ModifierList.new(){2}
  else if (propName = 'detail') then result := DetailList.new(){2}
  else if (propName = 'prosthesis') then result := TFhirClaimItemProsthesis.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'type') then result := 'Coding'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'diagnosisLinkId') then result := 'positiveInt'
  else if (propName = 'service') then result := 'Coding'
  else if (propName = 'serviceDate') then result := 'date'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Quantity'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'points') then result := 'decimal'
  else if (propName = 'net') then result := 'Quantity'
  else if (propName = 'udi') then result := 'Coding'
  else if (propName = 'bodySite') then result := 'Coding'
  else if (propName = 'subSite') then result := 'Coding'
  else if (propName = 'modifier') then result := 'Coding'
  else if (propName = 'detail') then result := ''
  else if (propName = 'prosthesis') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'provider') then ProviderElement := nil
  else if (propName = 'diagnosisLinkId') then deletePropertyValue('diagnosisLinkId', DiagnosisLinkIdList, value) {2}
  else if (propName = 'service') then ServiceElement := nil
  else if (propName = 'serviceDate') then ServiceDateElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'points') then PointsElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'udi') then UdiElement := nil
  else if (propName = 'bodySite') then BodySiteElement := nil
  else if (propName = 'subSite') then deletePropertyValue('subSite', SubSiteList, value) {2}
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value) {2}
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value) {2}
  else if (propName = 'prosthesis') then ProsthesisElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new){5b}
  else if (propName = 'type') then Type_Element := new as TFhirCoding{4}
  else if (propName = 'provider') then ProviderElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'diagnosisLinkId') then replacePropertyValue('diagnosisLinkId', DiagnosisLinkIdList, existing, new) {2}
  else if (propName = 'service') then ServiceElement := new as TFhirCoding{4}
  else if (propName = 'serviceDate') then ServiceDateElement := asDate(new){5b}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirQuantity{4}
  else if (propName = 'factor') then FactorElement := asDecimal(new){5b}
  else if (propName = 'points') then PointsElement := asDecimal(new){5b}
  else if (propName = 'net') then NetElement := new as TFhirQuantity{4}
  else if (propName = 'udi') then UdiElement := new as TFhirCoding{4}
  else if (propName = 'bodySite') then BodySiteElement := new as TFhirCoding{4}
  else if (propName = 'subSite') then replacePropertyValue('subSite', SubSiteList, existing, new) {2}
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new) {2}
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new) {2}
  else if (propName = 'prosthesis') then ProsthesisElement := new as TFhirClaimItemProsthesis{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'diagnosisLinkId') then DiagnosisLinkIdList.move(source, destination){2}
  else if (propName = 'subSite') then SubSiteList.move(source, destination){2a}
  else if (propName = 'modifier') then ModifierList.move(source, destination){2a}
  else if (propName = 'detail') then DetailList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimItem.fhirType : string;
begin
  result := 'item';
end;

function TFhirClaimItem.Link : TFhirClaimItem;
begin
  result := TFhirClaimItem(inherited Link);
end;

function TFhirClaimItem.Clone : TFhirClaimItem;
begin
  result := TFhirClaimItem(inherited Clone);
end;

function TFhirClaimItem.equals(other : TObject) : boolean;
var
  o : TFhirClaimItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimItem)) then
    result := false
  else
  begin
    o := TFhirClaimItem(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(type_Element, o.type_Element, true) and
      compareDeep(providerElement, o.providerElement, true) and compareDeep(diagnosisLinkIdList, o.diagnosisLinkIdList, true) and
      compareDeep(serviceElement, o.serviceElement, true) and compareDeep(serviceDateElement, o.serviceDateElement, true) and
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(unitPriceElement, o.unitPriceElement, true) and
      compareDeep(factorElement, o.factorElement, true) and compareDeep(pointsElement, o.pointsElement, true) and
      compareDeep(netElement, o.netElement, true) and compareDeep(udiElement, o.udiElement, true) and
      compareDeep(bodySiteElement, o.bodySiteElement, true) and compareDeep(subSiteList, o.subSiteList, true) and
      compareDeep(modifierList, o.modifierList, true) and compareDeep(detailList, o.detailList, true) and
      compareDeep(prosthesisElement, o.prosthesisElement, true);
  end;
end;

function TFhirClaimItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FType_) and isEmptyProp(FProvider) and isEmptyProp(FdiagnosisLinkIdList) and isEmptyProp(FService) and isEmptyProp(FServiceDate) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FPoints) and isEmptyProp(FNet) and isEmptyProp(FUdi) and isEmptyProp(FBodySite) and isEmptyProp(FsubSiteList) and isEmptyProp(FmodifierList) and isEmptyProp(FdetailList) and isEmptyProp(FProsthesis);
end;

procedure TFhirClaimItem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('type');
  fields.add('provider');
  fields.add('diagnosisLinkId');
  fields.add('service');
  fields.add('serviceDate');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('points');
  fields.add('net');
  fields.add('udi');
  fields.add('bodySite');
  fields.add('subSite');
  fields.add('modifier');
  fields.add('detail');
  fields.add('prosthesis');
end;

{ TFhirClaimItem }

Procedure TFhirClaimItem.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirClaimItem.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirClaimItem.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Procedure TFhirClaimItem.SetType_(value : TFhirCoding);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirClaimItem.SetProvider(value : TFhirReference{TFhirPractitioner});
begin
  FProvider.free;
  FProvider := value;
end;

Function TFhirClaimItem.GetDiagnosisLinkIdList : TFhirPositiveIntList;
begin
  if FDiagnosisLinkIdList = nil then
    FDiagnosisLinkIdList := TFhirPositiveIntList.Create;
  result := FDiagnosisLinkIdList;
end;

Function TFhirClaimItem.GetHasDiagnosisLinkIdList : boolean;
begin
  result := (FDiagnosisLinkIdList <> nil) and (FDiagnosisLinkIdList.count > 0);
end;

Procedure TFhirClaimItem.SetService(value : TFhirCoding);
begin
  FService.free;
  FService := value;
end;

Procedure TFhirClaimItem.SetServiceDate(value : TFhirDate);
begin
  FServiceDate.free;
  FServiceDate := value;
end;

Function TFhirClaimItem.GetServiceDateST : TFslDateTime;
begin
  if FServiceDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FServiceDate.value;
end;

Procedure TFhirClaimItem.SetServiceDateST(value : TFslDateTime);
begin
  if FServiceDate = nil then
    FServiceDate := TFhirDate.create;
  FServiceDate.value := value
end;

Procedure TFhirClaimItem.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirClaimItem.SetUnitPrice(value : TFhirQuantity);
begin
  FUnitPrice.free;
  FUnitPrice := value;
end;

Procedure TFhirClaimItem.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

Function TFhirClaimItem.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

Procedure TFhirClaimItem.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

Procedure TFhirClaimItem.SetPoints(value : TFhirDecimal);
begin
  FPoints.free;
  FPoints := value;
end;

Function TFhirClaimItem.GetPointsST : String;
begin
  if FPoints = nil then
    result := ''
  else
    result := FPoints.value;
end;

Procedure TFhirClaimItem.SetPointsST(value : String);
begin
  if value <> '' then
  begin
    if FPoints = nil then
      FPoints := TFhirDecimal.create;
    FPoints.value := value
  end
  else if FPoints <> nil then
    FPoints.value := '';
end;

Procedure TFhirClaimItem.SetNet(value : TFhirQuantity);
begin
  FNet.free;
  FNet := value;
end;

Procedure TFhirClaimItem.SetUdi(value : TFhirCoding);
begin
  FUdi.free;
  FUdi := value;
end;

Procedure TFhirClaimItem.SetBodySite(value : TFhirCoding);
begin
  FBodySite.free;
  FBodySite := value;
end;

Function TFhirClaimItem.GetSubSiteList : TFhirCodingList;
begin
  if FSubSiteList = nil then
    FSubSiteList := TFhirCodingList.Create;
  result := FSubSiteList;
end;

Function TFhirClaimItem.GetHasSubSiteList : boolean;
begin
  result := (FSubSiteList <> nil) and (FSubSiteList.count > 0);
end;

Function TFhirClaimItem.GetModifierList : TFhirCodingList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodingList.Create;
  result := FModifierList;
end;

Function TFhirClaimItem.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

Function TFhirClaimItem.GetDetailList : TFhirClaimItemDetailList;
begin
  if FDetailList = nil then
    FDetailList := TFhirClaimItemDetailList.Create;
  result := FDetailList;
end;

Function TFhirClaimItem.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

Procedure TFhirClaimItem.SetProsthesis(value : TFhirClaimItemProsthesis);
begin
  FProsthesis.free;
  FProsthesis := value;
end;

function TFhirClaimItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FProvider.sizeInBytes);
  inc(result, FdiagnosisLinkIdList.sizeInBytes);
  inc(result, FService.sizeInBytes);
  inc(result, FServiceDate.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FUnitPrice.sizeInBytes);
  inc(result, FFactor.sizeInBytes);
  inc(result, FPoints.sizeInBytes);
  inc(result, FNet.sizeInBytes);
  inc(result, FUdi.sizeInBytes);
  inc(result, FBodySite.sizeInBytes);
  inc(result, FsubSiteList.sizeInBytes);
  inc(result, FmodifierList.sizeInBytes);
  inc(result, FdetailList.sizeInBytes);
  inc(result, FProsthesis.sizeInBytes);
end;

{ TFhirClaimItemListEnumerator }

Constructor TFhirClaimItemListEnumerator.Create(list : TFhirClaimItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimItemListEnumerator.GetCurrent : TFhirClaimItem;
begin
  Result := FList[FIndex];
end;

function TFhirClaimItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimItemList }
procedure TFhirClaimItemList.AddItem(value: TFhirClaimItem);
begin
  assert(value.ClassName = 'TFhirClaimItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimItem');
  add(value);
end;

function TFhirClaimItemList.Append: TFhirClaimItem;
begin
  result := TFhirClaimItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimItemList.ClearItems;
begin
  Clear;
end;

function TFhirClaimItemList.GetEnumerator : TFhirClaimItemListEnumerator;
begin
  result := TFhirClaimItemListEnumerator.Create(self.link);
end;

function TFhirClaimItemList.Clone: TFhirClaimItemList;
begin
  result := TFhirClaimItemList(inherited Clone);
end;

function TFhirClaimItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimItemList.GetItemN(index: Integer): TFhirClaimItem;
begin
  result := TFhirClaimItem(ObjectByIndex[index]);
end;

function TFhirClaimItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimItem;
end;
function TFhirClaimItemList.IndexOf(value: TFhirClaimItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimItemList.Insert(index: Integer): TFhirClaimItem;
begin
  result := TFhirClaimItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimItemList.InsertItem(index: Integer; value: TFhirClaimItem);
begin
  assert(value is TFhirClaimItem);
  Inherited Insert(index, value);
end;

function TFhirClaimItemList.Item(index: Integer): TFhirClaimItem;
begin
  result := TFhirClaimItem(ObjectByIndex[index]);
end;

function TFhirClaimItemList.Link: TFhirClaimItemList;
begin
  result := TFhirClaimItemList(inherited Link);
end;

procedure TFhirClaimItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimItemList.SetItemByIndex(index: Integer; value: TFhirClaimItem);
begin
  assert(value is TFhirClaimItem);
  FhirClaimItems[index] := value;
end;

procedure TFhirClaimItemList.SetItemN(index: Integer; value: TFhirClaimItem);
begin
  assert(value is TFhirClaimItem);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimItemDetail }

constructor TFhirClaimItemDetail.Create;
begin
  inherited;
end;

destructor TFhirClaimItemDetail.Destroy;
begin
  FSequence.free;
  FType_.free;
  FService.free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FPoints.free;
  FNet.free;
  FUdi.free;
  FSubDetailList.Free;
  inherited;
end;

procedure TFhirClaimItemDetail.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirClaimItemDetail(oSource).sequenceElement.Clone;
  type_ := TFhirClaimItemDetail(oSource).type_.Clone;
  service := TFhirClaimItemDetail(oSource).service.Clone;
  quantity := TFhirClaimItemDetail(oSource).quantity.Clone;
  unitPrice := TFhirClaimItemDetail(oSource).unitPrice.Clone;
  factorElement := TFhirClaimItemDetail(oSource).factorElement.Clone;
  pointsElement := TFhirClaimItemDetail(oSource).pointsElement.Clone;
  net := TFhirClaimItemDetail(oSource).net.Clone;
  udi := TFhirClaimItemDetail(oSource).udi.Clone;
  if (TFhirClaimItemDetail(oSource).FSubDetailList = nil) then
  begin
    FSubDetailList.free;
    FSubDetailList := nil;
  end
  else
  begin
    if FSubDetailList = nil then
      FSubDetailList := TFhirClaimItemDetailSubDetailList.Create;
    FSubDetailList.Assign(TFhirClaimItemDetail(oSource).FSubDetailList);
  end;
end;

procedure TFhirClaimItemDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'service') Then
     list.add(self.link, 'service', FService.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'points') Then
     list.add(self.link, 'points', FPoints.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'udi') Then
     list.add(self.link, 'udi', FUdi.Link);
  if (child_name = 'subDetail') Then
    list.addAll(self, 'subDetail', FSubDetailList);
end;

procedure TFhirClaimItemDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', false, TFhirCoding, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'service', 'Coding', false, TFhirCoding, FService.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Quantity', false, TFhirQuantity, FUnitPrice.Link));{2}
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'points', 'decimal', false, TFhirDecimal, FPoints.Link));{2}
  oList.add(TFHIRProperty.create(self, 'net', 'Quantity', false, TFhirQuantity, FNet.Link));{2}
  oList.add(TFHIRProperty.create(self, 'udi', 'Coding', false, TFhirCoding, FUdi.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subDetail', '', true, TFhirClaimItemDetailSubDetail, FSubDetailList.Link)){3};
end;

function TFhirClaimItemDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'service') then
  begin
    Service := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'points') then
  begin
    PointsElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'udi') then
  begin
    Udi := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'subDetail') then
  begin
    SubDetailList.add(propValue as TFhirClaimItemDetailSubDetail){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimItemDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'subDetail') then SubDetailList.insertItem(index, propValue as TFhirClaimItemDetailSubDetail){2a}
  else inherited;
end;

function TFhirClaimItemDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'type') then result := TFhirCoding.create(){4b}
  else if (propName = 'service') then result := TFhirCoding.create(){4b}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'unitPrice') then result := TFhirQuantity.create(){4b}
  else if (propName = 'factor') then result := TFhirDecimal.create() {5b}
  else if (propName = 'points') then result := TFhirDecimal.create() {5b}
  else if (propName = 'net') then result := TFhirQuantity.create(){4b}
  else if (propName = 'udi') then result := TFhirCoding.create(){4b}
  else if (propName = 'subDetail') then result := SubDetailList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimItemDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'type') then result := 'Coding'
  else if (propName = 'service') then result := 'Coding'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Quantity'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'points') then result := 'decimal'
  else if (propName = 'net') then result := 'Quantity'
  else if (propName = 'udi') then result := 'Coding'
  else if (propName = 'subDetail') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimItemDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'service') then ServiceElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'points') then PointsElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'udi') then UdiElement := nil
  else if (propName = 'subDetail') then deletePropertyValue('subDetail', SubDetailList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimItemDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new){5b}
  else if (propName = 'type') then Type_Element := new as TFhirCoding{4}
  else if (propName = 'service') then ServiceElement := new as TFhirCoding{4}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirQuantity{4}
  else if (propName = 'factor') then FactorElement := asDecimal(new){5b}
  else if (propName = 'points') then PointsElement := asDecimal(new){5b}
  else if (propName = 'net') then NetElement := new as TFhirQuantity{4}
  else if (propName = 'udi') then UdiElement := new as TFhirCoding{4}
  else if (propName = 'subDetail') then replacePropertyValue('subDetail', SubDetailList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimItemDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'subDetail') then SubDetailList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimItemDetail.fhirType : string;
begin
  result := 'detail';
end;

function TFhirClaimItemDetail.Link : TFhirClaimItemDetail;
begin
  result := TFhirClaimItemDetail(inherited Link);
end;

function TFhirClaimItemDetail.Clone : TFhirClaimItemDetail;
begin
  result := TFhirClaimItemDetail(inherited Clone);
end;

function TFhirClaimItemDetail.equals(other : TObject) : boolean;
var
  o : TFhirClaimItemDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimItemDetail)) then
    result := false
  else
  begin
    o := TFhirClaimItemDetail(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(type_Element, o.type_Element, true) and
      compareDeep(serviceElement, o.serviceElement, true) and compareDeep(quantityElement, o.quantityElement, true) and
      compareDeep(unitPriceElement, o.unitPriceElement, true) and compareDeep(factorElement, o.factorElement, true) and
      compareDeep(pointsElement, o.pointsElement, true) and compareDeep(netElement, o.netElement, true) and
      compareDeep(udiElement, o.udiElement, true) and compareDeep(subDetailList, o.subDetailList, true);
  end;
end;

function TFhirClaimItemDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FType_) and isEmptyProp(FService) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FPoints) and isEmptyProp(FNet) and isEmptyProp(FUdi) and isEmptyProp(FsubDetailList);
end;

procedure TFhirClaimItemDetail.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('type');
  fields.add('service');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('points');
  fields.add('net');
  fields.add('udi');
  fields.add('subDetail');
end;

{ TFhirClaimItemDetail }

Procedure TFhirClaimItemDetail.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirClaimItemDetail.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirClaimItemDetail.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Procedure TFhirClaimItemDetail.SetType_(value : TFhirCoding);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirClaimItemDetail.SetService(value : TFhirCoding);
begin
  FService.free;
  FService := value;
end;

Procedure TFhirClaimItemDetail.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirClaimItemDetail.SetUnitPrice(value : TFhirQuantity);
begin
  FUnitPrice.free;
  FUnitPrice := value;
end;

Procedure TFhirClaimItemDetail.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

Function TFhirClaimItemDetail.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

Procedure TFhirClaimItemDetail.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

Procedure TFhirClaimItemDetail.SetPoints(value : TFhirDecimal);
begin
  FPoints.free;
  FPoints := value;
end;

Function TFhirClaimItemDetail.GetPointsST : String;
begin
  if FPoints = nil then
    result := ''
  else
    result := FPoints.value;
end;

Procedure TFhirClaimItemDetail.SetPointsST(value : String);
begin
  if value <> '' then
  begin
    if FPoints = nil then
      FPoints := TFhirDecimal.create;
    FPoints.value := value
  end
  else if FPoints <> nil then
    FPoints.value := '';
end;

Procedure TFhirClaimItemDetail.SetNet(value : TFhirQuantity);
begin
  FNet.free;
  FNet := value;
end;

Procedure TFhirClaimItemDetail.SetUdi(value : TFhirCoding);
begin
  FUdi.free;
  FUdi := value;
end;

Function TFhirClaimItemDetail.GetSubDetailList : TFhirClaimItemDetailSubDetailList;
begin
  if FSubDetailList = nil then
    FSubDetailList := TFhirClaimItemDetailSubDetailList.Create;
  result := FSubDetailList;
end;

Function TFhirClaimItemDetail.GetHasSubDetailList : boolean;
begin
  result := (FSubDetailList <> nil) and (FSubDetailList.count > 0);
end;

function TFhirClaimItemDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FService.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FUnitPrice.sizeInBytes);
  inc(result, FFactor.sizeInBytes);
  inc(result, FPoints.sizeInBytes);
  inc(result, FNet.sizeInBytes);
  inc(result, FUdi.sizeInBytes);
  inc(result, FsubDetailList.sizeInBytes);
end;

{ TFhirClaimItemDetailListEnumerator }

Constructor TFhirClaimItemDetailListEnumerator.Create(list : TFhirClaimItemDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimItemDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimItemDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimItemDetailListEnumerator.GetCurrent : TFhirClaimItemDetail;
begin
  Result := FList[FIndex];
end;

function TFhirClaimItemDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimItemDetailList }
procedure TFhirClaimItemDetailList.AddItem(value: TFhirClaimItemDetail);
begin
  assert(value.ClassName = 'TFhirClaimItemDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimItemDetail');
  add(value);
end;

function TFhirClaimItemDetailList.Append: TFhirClaimItemDetail;
begin
  result := TFhirClaimItemDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimItemDetailList.ClearItems;
begin
  Clear;
end;

function TFhirClaimItemDetailList.GetEnumerator : TFhirClaimItemDetailListEnumerator;
begin
  result := TFhirClaimItemDetailListEnumerator.Create(self.link);
end;

function TFhirClaimItemDetailList.Clone: TFhirClaimItemDetailList;
begin
  result := TFhirClaimItemDetailList(inherited Clone);
end;

function TFhirClaimItemDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimItemDetailList.GetItemN(index: Integer): TFhirClaimItemDetail;
begin
  result := TFhirClaimItemDetail(ObjectByIndex[index]);
end;

function TFhirClaimItemDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimItemDetail;
end;
function TFhirClaimItemDetailList.IndexOf(value: TFhirClaimItemDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimItemDetailList.Insert(index: Integer): TFhirClaimItemDetail;
begin
  result := TFhirClaimItemDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimItemDetailList.InsertItem(index: Integer; value: TFhirClaimItemDetail);
begin
  assert(value is TFhirClaimItemDetail);
  Inherited Insert(index, value);
end;

function TFhirClaimItemDetailList.Item(index: Integer): TFhirClaimItemDetail;
begin
  result := TFhirClaimItemDetail(ObjectByIndex[index]);
end;

function TFhirClaimItemDetailList.Link: TFhirClaimItemDetailList;
begin
  result := TFhirClaimItemDetailList(inherited Link);
end;

procedure TFhirClaimItemDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimItemDetailList.SetItemByIndex(index: Integer; value: TFhirClaimItemDetail);
begin
  assert(value is TFhirClaimItemDetail);
  FhirClaimItemDetails[index] := value;
end;

procedure TFhirClaimItemDetailList.SetItemN(index: Integer; value: TFhirClaimItemDetail);
begin
  assert(value is TFhirClaimItemDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimItemDetailSubDetail }

constructor TFhirClaimItemDetailSubDetail.Create;
begin
  inherited;
end;

destructor TFhirClaimItemDetailSubDetail.Destroy;
begin
  FSequence.free;
  FType_.free;
  FService.free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FPoints.free;
  FNet.free;
  FUdi.free;
  inherited;
end;

procedure TFhirClaimItemDetailSubDetail.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirClaimItemDetailSubDetail(oSource).sequenceElement.Clone;
  type_ := TFhirClaimItemDetailSubDetail(oSource).type_.Clone;
  service := TFhirClaimItemDetailSubDetail(oSource).service.Clone;
  quantity := TFhirClaimItemDetailSubDetail(oSource).quantity.Clone;
  unitPrice := TFhirClaimItemDetailSubDetail(oSource).unitPrice.Clone;
  factorElement := TFhirClaimItemDetailSubDetail(oSource).factorElement.Clone;
  pointsElement := TFhirClaimItemDetailSubDetail(oSource).pointsElement.Clone;
  net := TFhirClaimItemDetailSubDetail(oSource).net.Clone;
  udi := TFhirClaimItemDetailSubDetail(oSource).udi.Clone;
end;

procedure TFhirClaimItemDetailSubDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'service') Then
     list.add(self.link, 'service', FService.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'points') Then
     list.add(self.link, 'points', FPoints.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'udi') Then
     list.add(self.link, 'udi', FUdi.Link);
end;

procedure TFhirClaimItemDetailSubDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', false, TFhirCoding, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'service', 'Coding', false, TFhirCoding, FService.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Quantity', false, TFhirQuantity, FUnitPrice.Link));{2}
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'points', 'decimal', false, TFhirDecimal, FPoints.Link));{2}
  oList.add(TFHIRProperty.create(self, 'net', 'Quantity', false, TFhirQuantity, FNet.Link));{2}
  oList.add(TFHIRProperty.create(self, 'udi', 'Coding', false, TFhirCoding, FUdi.Link));{2}
end;

function TFhirClaimItemDetailSubDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'service') then
  begin
    Service := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'points') then
  begin
    PointsElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'udi') then
  begin
    Udi := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimItemDetailSubDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimItemDetailSubDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'type') then result := TFhirCoding.create(){4b}
  else if (propName = 'service') then result := TFhirCoding.create(){4b}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'unitPrice') then result := TFhirQuantity.create(){4b}
  else if (propName = 'factor') then result := TFhirDecimal.create() {5b}
  else if (propName = 'points') then result := TFhirDecimal.create() {5b}
  else if (propName = 'net') then result := TFhirQuantity.create(){4b}
  else if (propName = 'udi') then result := TFhirCoding.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimItemDetailSubDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'type') then result := 'Coding'
  else if (propName = 'service') then result := 'Coding'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Quantity'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'points') then result := 'decimal'
  else if (propName = 'net') then result := 'Quantity'
  else if (propName = 'udi') then result := 'Coding'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimItemDetailSubDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'service') then ServiceElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'points') then PointsElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'udi') then UdiElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimItemDetailSubDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new){5b}
  else if (propName = 'type') then Type_Element := new as TFhirCoding{4}
  else if (propName = 'service') then ServiceElement := new as TFhirCoding{4}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirQuantity{4}
  else if (propName = 'factor') then FactorElement := asDecimal(new){5b}
  else if (propName = 'points') then PointsElement := asDecimal(new){5b}
  else if (propName = 'net') then NetElement := new as TFhirQuantity{4}
  else if (propName = 'udi') then UdiElement := new as TFhirCoding{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimItemDetailSubDetail.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimItemDetailSubDetail.fhirType : string;
begin
  result := 'subDetail';
end;

function TFhirClaimItemDetailSubDetail.Link : TFhirClaimItemDetailSubDetail;
begin
  result := TFhirClaimItemDetailSubDetail(inherited Link);
end;

function TFhirClaimItemDetailSubDetail.Clone : TFhirClaimItemDetailSubDetail;
begin
  result := TFhirClaimItemDetailSubDetail(inherited Clone);
end;

function TFhirClaimItemDetailSubDetail.equals(other : TObject) : boolean;
var
  o : TFhirClaimItemDetailSubDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimItemDetailSubDetail)) then
    result := false
  else
  begin
    o := TFhirClaimItemDetailSubDetail(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(type_Element, o.type_Element, true) and
      compareDeep(serviceElement, o.serviceElement, true) and compareDeep(quantityElement, o.quantityElement, true) and
      compareDeep(unitPriceElement, o.unitPriceElement, true) and compareDeep(factorElement, o.factorElement, true) and
      compareDeep(pointsElement, o.pointsElement, true) and compareDeep(netElement, o.netElement, true) and
      compareDeep(udiElement, o.udiElement, true);
  end;
end;

function TFhirClaimItemDetailSubDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FType_) and isEmptyProp(FService) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FPoints) and isEmptyProp(FNet) and isEmptyProp(FUdi);
end;

procedure TFhirClaimItemDetailSubDetail.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('type');
  fields.add('service');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('points');
  fields.add('net');
  fields.add('udi');
end;

{ TFhirClaimItemDetailSubDetail }

Procedure TFhirClaimItemDetailSubDetail.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirClaimItemDetailSubDetail.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirClaimItemDetailSubDetail.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Procedure TFhirClaimItemDetailSubDetail.SetType_(value : TFhirCoding);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirClaimItemDetailSubDetail.SetService(value : TFhirCoding);
begin
  FService.free;
  FService := value;
end;

Procedure TFhirClaimItemDetailSubDetail.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirClaimItemDetailSubDetail.SetUnitPrice(value : TFhirQuantity);
begin
  FUnitPrice.free;
  FUnitPrice := value;
end;

Procedure TFhirClaimItemDetailSubDetail.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

Function TFhirClaimItemDetailSubDetail.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

Procedure TFhirClaimItemDetailSubDetail.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

Procedure TFhirClaimItemDetailSubDetail.SetPoints(value : TFhirDecimal);
begin
  FPoints.free;
  FPoints := value;
end;

Function TFhirClaimItemDetailSubDetail.GetPointsST : String;
begin
  if FPoints = nil then
    result := ''
  else
    result := FPoints.value;
end;

Procedure TFhirClaimItemDetailSubDetail.SetPointsST(value : String);
begin
  if value <> '' then
  begin
    if FPoints = nil then
      FPoints := TFhirDecimal.create;
    FPoints.value := value
  end
  else if FPoints <> nil then
    FPoints.value := '';
end;

Procedure TFhirClaimItemDetailSubDetail.SetNet(value : TFhirQuantity);
begin
  FNet.free;
  FNet := value;
end;

Procedure TFhirClaimItemDetailSubDetail.SetUdi(value : TFhirCoding);
begin
  FUdi.free;
  FUdi := value;
end;

function TFhirClaimItemDetailSubDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FService.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FUnitPrice.sizeInBytes);
  inc(result, FFactor.sizeInBytes);
  inc(result, FPoints.sizeInBytes);
  inc(result, FNet.sizeInBytes);
  inc(result, FUdi.sizeInBytes);
end;

{ TFhirClaimItemDetailSubDetailListEnumerator }

Constructor TFhirClaimItemDetailSubDetailListEnumerator.Create(list : TFhirClaimItemDetailSubDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimItemDetailSubDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimItemDetailSubDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimItemDetailSubDetailListEnumerator.GetCurrent : TFhirClaimItemDetailSubDetail;
begin
  Result := FList[FIndex];
end;

function TFhirClaimItemDetailSubDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimItemDetailSubDetailList }
procedure TFhirClaimItemDetailSubDetailList.AddItem(value: TFhirClaimItemDetailSubDetail);
begin
  assert(value.ClassName = 'TFhirClaimItemDetailSubDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimItemDetailSubDetail');
  add(value);
end;

function TFhirClaimItemDetailSubDetailList.Append: TFhirClaimItemDetailSubDetail;
begin
  result := TFhirClaimItemDetailSubDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimItemDetailSubDetailList.ClearItems;
begin
  Clear;
end;

function TFhirClaimItemDetailSubDetailList.GetEnumerator : TFhirClaimItemDetailSubDetailListEnumerator;
begin
  result := TFhirClaimItemDetailSubDetailListEnumerator.Create(self.link);
end;

function TFhirClaimItemDetailSubDetailList.Clone: TFhirClaimItemDetailSubDetailList;
begin
  result := TFhirClaimItemDetailSubDetailList(inherited Clone);
end;

function TFhirClaimItemDetailSubDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimItemDetailSubDetailList.GetItemN(index: Integer): TFhirClaimItemDetailSubDetail;
begin
  result := TFhirClaimItemDetailSubDetail(ObjectByIndex[index]);
end;

function TFhirClaimItemDetailSubDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimItemDetailSubDetail;
end;
function TFhirClaimItemDetailSubDetailList.IndexOf(value: TFhirClaimItemDetailSubDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimItemDetailSubDetailList.Insert(index: Integer): TFhirClaimItemDetailSubDetail;
begin
  result := TFhirClaimItemDetailSubDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimItemDetailSubDetailList.InsertItem(index: Integer; value: TFhirClaimItemDetailSubDetail);
begin
  assert(value is TFhirClaimItemDetailSubDetail);
  Inherited Insert(index, value);
end;

function TFhirClaimItemDetailSubDetailList.Item(index: Integer): TFhirClaimItemDetailSubDetail;
begin
  result := TFhirClaimItemDetailSubDetail(ObjectByIndex[index]);
end;

function TFhirClaimItemDetailSubDetailList.Link: TFhirClaimItemDetailSubDetailList;
begin
  result := TFhirClaimItemDetailSubDetailList(inherited Link);
end;

procedure TFhirClaimItemDetailSubDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimItemDetailSubDetailList.SetItemByIndex(index: Integer; value: TFhirClaimItemDetailSubDetail);
begin
  assert(value is TFhirClaimItemDetailSubDetail);
  FhirClaimItemDetailSubDetails[index] := value;
end;

procedure TFhirClaimItemDetailSubDetailList.SetItemN(index: Integer; value: TFhirClaimItemDetailSubDetail);
begin
  assert(value is TFhirClaimItemDetailSubDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimItemProsthesis }

constructor TFhirClaimItemProsthesis.Create;
begin
  inherited;
end;

destructor TFhirClaimItemProsthesis.Destroy;
begin
  FInitial.free;
  FPriorDate.free;
  FPriorMaterial.free;
  inherited;
end;

procedure TFhirClaimItemProsthesis.Assign(oSource : TFslObject);
begin
  inherited;
  initialElement := TFhirClaimItemProsthesis(oSource).initialElement.Clone;
  priorDateElement := TFhirClaimItemProsthesis(oSource).priorDateElement.Clone;
  priorMaterial := TFhirClaimItemProsthesis(oSource).priorMaterial.Clone;
end;

procedure TFhirClaimItemProsthesis.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'initial') Then
     list.add(self.link, 'initial', FInitial.Link);
  if (child_name = 'priorDate') Then
     list.add(self.link, 'priorDate', FPriorDate.Link);
  if (child_name = 'priorMaterial') Then
     list.add(self.link, 'priorMaterial', FPriorMaterial.Link);
end;

procedure TFhirClaimItemProsthesis.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'initial', 'boolean', false, TFhirBoolean, FInitial.Link));{2}
  oList.add(TFHIRProperty.create(self, 'priorDate', 'date', false, TFhirDate, FPriorDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'priorMaterial', 'Coding', false, TFhirCoding, FPriorMaterial.Link));{2}
end;

function TFhirClaimItemProsthesis.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'initial') then
  begin
    InitialElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'priorDate') then
  begin
    PriorDateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'priorMaterial') then
  begin
    PriorMaterial := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimItemProsthesis.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimItemProsthesis.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'initial') then result := TFhirBoolean.create() {5b}
  else if (propName = 'priorDate') then result := TFhirDate.create() {5b}
  else if (propName = 'priorMaterial') then result := TFhirCoding.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimItemProsthesis.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'initial') then result := 'boolean'
  else if (propName = 'priorDate') then result := 'date'
  else if (propName = 'priorMaterial') then result := 'Coding'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimItemProsthesis.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'initial') then InitialElement := nil
  else if (propName = 'priorDate') then PriorDateElement := nil
  else if (propName = 'priorMaterial') then PriorMaterialElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimItemProsthesis.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'initial') then InitialElement := asBoolean(new){5b}
  else if (propName = 'priorDate') then PriorDateElement := asDate(new){5b}
  else if (propName = 'priorMaterial') then PriorMaterialElement := new as TFhirCoding{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimItemProsthesis.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimItemProsthesis.fhirType : string;
begin
  result := 'prosthesis';
end;

function TFhirClaimItemProsthesis.Link : TFhirClaimItemProsthesis;
begin
  result := TFhirClaimItemProsthesis(inherited Link);
end;

function TFhirClaimItemProsthesis.Clone : TFhirClaimItemProsthesis;
begin
  result := TFhirClaimItemProsthesis(inherited Clone);
end;

function TFhirClaimItemProsthesis.equals(other : TObject) : boolean;
var
  o : TFhirClaimItemProsthesis;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimItemProsthesis)) then
    result := false
  else
  begin
    o := TFhirClaimItemProsthesis(other);
    result := compareDeep(initialElement, o.initialElement, true) and compareDeep(priorDateElement, o.priorDateElement, true) and
      compareDeep(priorMaterialElement, o.priorMaterialElement, true);
  end;
end;

function TFhirClaimItemProsthesis.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FInitial) and isEmptyProp(FPriorDate) and isEmptyProp(FPriorMaterial);
end;

procedure TFhirClaimItemProsthesis.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('initial');
  fields.add('priorDate');
  fields.add('priorMaterial');
end;

{ TFhirClaimItemProsthesis }

Procedure TFhirClaimItemProsthesis.SetInitial(value : TFhirBoolean);
begin
  FInitial.free;
  FInitial := value;
end;

Function TFhirClaimItemProsthesis.GetInitialST : Boolean;
begin
  if FInitial = nil then
    result := false
  else
    result := FInitial.value;
end;

Procedure TFhirClaimItemProsthesis.SetInitialST(value : Boolean);
begin
  if FInitial = nil then
    FInitial := TFhirBoolean.create;
  FInitial.value := value
end;

Procedure TFhirClaimItemProsthesis.SetPriorDate(value : TFhirDate);
begin
  FPriorDate.free;
  FPriorDate := value;
end;

Function TFhirClaimItemProsthesis.GetPriorDateST : TFslDateTime;
begin
  if FPriorDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FPriorDate.value;
end;

Procedure TFhirClaimItemProsthesis.SetPriorDateST(value : TFslDateTime);
begin
  if FPriorDate = nil then
    FPriorDate := TFhirDate.create;
  FPriorDate.value := value
end;

Procedure TFhirClaimItemProsthesis.SetPriorMaterial(value : TFhirCoding);
begin
  FPriorMaterial.free;
  FPriorMaterial := value;
end;

function TFhirClaimItemProsthesis.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FInitial.sizeInBytes);
  inc(result, FPriorDate.sizeInBytes);
  inc(result, FPriorMaterial.sizeInBytes);
end;

{ TFhirClaimItemProsthesisListEnumerator }

Constructor TFhirClaimItemProsthesisListEnumerator.Create(list : TFhirClaimItemProsthesisList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimItemProsthesisListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimItemProsthesisListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimItemProsthesisListEnumerator.GetCurrent : TFhirClaimItemProsthesis;
begin
  Result := FList[FIndex];
end;

function TFhirClaimItemProsthesisListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimItemProsthesisList }
procedure TFhirClaimItemProsthesisList.AddItem(value: TFhirClaimItemProsthesis);
begin
  assert(value.ClassName = 'TFhirClaimItemProsthesis', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimItemProsthesis');
  add(value);
end;

function TFhirClaimItemProsthesisList.Append: TFhirClaimItemProsthesis;
begin
  result := TFhirClaimItemProsthesis.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimItemProsthesisList.ClearItems;
begin
  Clear;
end;

function TFhirClaimItemProsthesisList.GetEnumerator : TFhirClaimItemProsthesisListEnumerator;
begin
  result := TFhirClaimItemProsthesisListEnumerator.Create(self.link);
end;

function TFhirClaimItemProsthesisList.Clone: TFhirClaimItemProsthesisList;
begin
  result := TFhirClaimItemProsthesisList(inherited Clone);
end;

function TFhirClaimItemProsthesisList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimItemProsthesisList.GetItemN(index: Integer): TFhirClaimItemProsthesis;
begin
  result := TFhirClaimItemProsthesis(ObjectByIndex[index]);
end;

function TFhirClaimItemProsthesisList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimItemProsthesis;
end;
function TFhirClaimItemProsthesisList.IndexOf(value: TFhirClaimItemProsthesis): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimItemProsthesisList.Insert(index: Integer): TFhirClaimItemProsthesis;
begin
  result := TFhirClaimItemProsthesis.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimItemProsthesisList.InsertItem(index: Integer; value: TFhirClaimItemProsthesis);
begin
  assert(value is TFhirClaimItemProsthesis);
  Inherited Insert(index, value);
end;

function TFhirClaimItemProsthesisList.Item(index: Integer): TFhirClaimItemProsthesis;
begin
  result := TFhirClaimItemProsthesis(ObjectByIndex[index]);
end;

function TFhirClaimItemProsthesisList.Link: TFhirClaimItemProsthesisList;
begin
  result := TFhirClaimItemProsthesisList(inherited Link);
end;

procedure TFhirClaimItemProsthesisList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimItemProsthesisList.SetItemByIndex(index: Integer; value: TFhirClaimItemProsthesis);
begin
  assert(value is TFhirClaimItemProsthesis);
  FhirClaimItemProstheses[index] := value;
end;

procedure TFhirClaimItemProsthesisList.SetItemN(index: Integer; value: TFhirClaimItemProsthesis);
begin
  assert(value is TFhirClaimItemProsthesis);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimMissingTeeth }

constructor TFhirClaimMissingTeeth.Create;
begin
  inherited;
end;

destructor TFhirClaimMissingTeeth.Destroy;
begin
  FTooth.free;
  FReason.free;
  FExtractionDate.free;
  inherited;
end;

procedure TFhirClaimMissingTeeth.Assign(oSource : TFslObject);
begin
  inherited;
  tooth := TFhirClaimMissingTeeth(oSource).tooth.Clone;
  reason := TFhirClaimMissingTeeth(oSource).reason.Clone;
  extractionDateElement := TFhirClaimMissingTeeth(oSource).extractionDateElement.Clone;
end;

procedure TFhirClaimMissingTeeth.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'tooth') Then
     list.add(self.link, 'tooth', FTooth.Link);
  if (child_name = 'reason') Then
     list.add(self.link, 'reason', FReason.Link);
  if (child_name = 'extractionDate') Then
     list.add(self.link, 'extractionDate', FExtractionDate.Link);
end;

procedure TFhirClaimMissingTeeth.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'tooth', 'Coding', false, TFhirCoding, FTooth.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason', 'Coding', false, TFhirCoding, FReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'extractionDate', 'date', false, TFhirDate, FExtractionDate.Link));{2}
end;

function TFhirClaimMissingTeeth.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'tooth') then
  begin
    Tooth := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    Reason := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'extractionDate') then
  begin
    ExtractionDateElement := asDate(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimMissingTeeth.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimMissingTeeth.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'tooth') then result := TFhirCoding.create(){4b}
  else if (propName = 'reason') then result := TFhirCoding.create(){4b}
  else if (propName = 'extractionDate') then result := TFhirDate.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimMissingTeeth.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'tooth') then result := 'Coding'
  else if (propName = 'reason') then result := 'Coding'
  else if (propName = 'extractionDate') then result := 'date'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimMissingTeeth.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'tooth') then ToothElement := nil
  else if (propName = 'reason') then ReasonElement := nil
  else if (propName = 'extractionDate') then ExtractionDateElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimMissingTeeth.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'tooth') then ToothElement := new as TFhirCoding{4}
  else if (propName = 'reason') then ReasonElement := new as TFhirCoding{4}
  else if (propName = 'extractionDate') then ExtractionDateElement := asDate(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimMissingTeeth.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimMissingTeeth.fhirType : string;
begin
  result := 'missingTeeth';
end;

function TFhirClaimMissingTeeth.Link : TFhirClaimMissingTeeth;
begin
  result := TFhirClaimMissingTeeth(inherited Link);
end;

function TFhirClaimMissingTeeth.Clone : TFhirClaimMissingTeeth;
begin
  result := TFhirClaimMissingTeeth(inherited Clone);
end;

function TFhirClaimMissingTeeth.equals(other : TObject) : boolean;
var
  o : TFhirClaimMissingTeeth;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimMissingTeeth)) then
    result := false
  else
  begin
    o := TFhirClaimMissingTeeth(other);
    result := compareDeep(toothElement, o.toothElement, true) and compareDeep(reasonElement, o.reasonElement, true) and
      compareDeep(extractionDateElement, o.extractionDateElement, true);
  end;
end;

function TFhirClaimMissingTeeth.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FTooth) and isEmptyProp(FReason) and isEmptyProp(FExtractionDate);
end;

procedure TFhirClaimMissingTeeth.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('tooth');
  fields.add('reason');
  fields.add('extractionDate');
end;

{ TFhirClaimMissingTeeth }

Procedure TFhirClaimMissingTeeth.SetTooth(value : TFhirCoding);
begin
  FTooth.free;
  FTooth := value;
end;

Procedure TFhirClaimMissingTeeth.SetReason(value : TFhirCoding);
begin
  FReason.free;
  FReason := value;
end;

Procedure TFhirClaimMissingTeeth.SetExtractionDate(value : TFhirDate);
begin
  FExtractionDate.free;
  FExtractionDate := value;
end;

Function TFhirClaimMissingTeeth.GetExtractionDateST : TFslDateTime;
begin
  if FExtractionDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FExtractionDate.value;
end;

Procedure TFhirClaimMissingTeeth.SetExtractionDateST(value : TFslDateTime);
begin
  if FExtractionDate = nil then
    FExtractionDate := TFhirDate.create;
  FExtractionDate.value := value
end;

function TFhirClaimMissingTeeth.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FTooth.sizeInBytes);
  inc(result, FReason.sizeInBytes);
  inc(result, FExtractionDate.sizeInBytes);
end;

{ TFhirClaimMissingTeethListEnumerator }

Constructor TFhirClaimMissingTeethListEnumerator.Create(list : TFhirClaimMissingTeethList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimMissingTeethListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimMissingTeethListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimMissingTeethListEnumerator.GetCurrent : TFhirClaimMissingTeeth;
begin
  Result := FList[FIndex];
end;

function TFhirClaimMissingTeethListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimMissingTeethList }
procedure TFhirClaimMissingTeethList.AddItem(value: TFhirClaimMissingTeeth);
begin
  assert(value.ClassName = 'TFhirClaimMissingTeeth', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimMissingTeeth');
  add(value);
end;

function TFhirClaimMissingTeethList.Append: TFhirClaimMissingTeeth;
begin
  result := TFhirClaimMissingTeeth.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimMissingTeethList.ClearItems;
begin
  Clear;
end;

function TFhirClaimMissingTeethList.GetEnumerator : TFhirClaimMissingTeethListEnumerator;
begin
  result := TFhirClaimMissingTeethListEnumerator.Create(self.link);
end;

function TFhirClaimMissingTeethList.Clone: TFhirClaimMissingTeethList;
begin
  result := TFhirClaimMissingTeethList(inherited Clone);
end;

function TFhirClaimMissingTeethList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimMissingTeethList.GetItemN(index: Integer): TFhirClaimMissingTeeth;
begin
  result := TFhirClaimMissingTeeth(ObjectByIndex[index]);
end;

function TFhirClaimMissingTeethList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimMissingTeeth;
end;
function TFhirClaimMissingTeethList.IndexOf(value: TFhirClaimMissingTeeth): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimMissingTeethList.Insert(index: Integer): TFhirClaimMissingTeeth;
begin
  result := TFhirClaimMissingTeeth.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimMissingTeethList.InsertItem(index: Integer; value: TFhirClaimMissingTeeth);
begin
  assert(value is TFhirClaimMissingTeeth);
  Inherited Insert(index, value);
end;

function TFhirClaimMissingTeethList.Item(index: Integer): TFhirClaimMissingTeeth;
begin
  result := TFhirClaimMissingTeeth(ObjectByIndex[index]);
end;

function TFhirClaimMissingTeethList.Link: TFhirClaimMissingTeethList;
begin
  result := TFhirClaimMissingTeethList(inherited Link);
end;

procedure TFhirClaimMissingTeethList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimMissingTeethList.SetItemByIndex(index: Integer; value: TFhirClaimMissingTeeth);
begin
  assert(value is TFhirClaimMissingTeeth);
  FhirClaimMissingTeeths[index] := value;
end;

procedure TFhirClaimMissingTeethList.SetItemN(index: Integer; value: TFhirClaimMissingTeeth);
begin
  assert(value is TFhirClaimMissingTeeth);
  ObjectByIndex[index] := value;
end;

{ TFhirClaim }

constructor TFhirClaim.Create;
begin
  inherited;
end;

destructor TFhirClaim.Destroy;
begin
  FType_.free;
  FIdentifierList.Free;
  FRuleset.free;
  FOriginalRuleset.free;
  FCreated.free;
  FTarget.free;
  FProvider.free;
  FOrganization.free;
  FUse.free;
  FPriority.free;
  FFundsReserve.free;
  FEnterer.free;
  FFacility.free;
  FPrescription.free;
  FOriginalPrescription.free;
  FPayee.free;
  FReferral.free;
  FDiagnosisList.Free;
  FConditionList.Free;
  FPatient.free;
  FCoverageList.Free;
  FExceptionList.Free;
  FSchool.free;
  FAccident.free;
  FAccidentType.free;
  FInterventionExceptionList.Free;
  FItemList.Free;
  FAdditionalMaterialsList.Free;
  FMissingTeethList.Free;
  inherited;
end;

function TFhirClaim.GetResourceType : TFhirResourceType;
begin
  result := frtClaim;
end;

procedure TFhirClaim.Assign(oSource : TFslObject);
begin
  inherited;
  FType_ := TFhirClaim(oSource).FType_.Link;
  if (TFhirClaim(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirClaim(oSource).FIdentifierList);
  end;
  ruleset := TFhirClaim(oSource).ruleset.Clone;
  originalRuleset := TFhirClaim(oSource).originalRuleset.Clone;
  createdElement := TFhirClaim(oSource).createdElement.Clone;
  target := TFhirClaim(oSource).target.Clone;
  provider := TFhirClaim(oSource).provider.Clone;
  organization := TFhirClaim(oSource).organization.Clone;
  FUse := TFhirClaim(oSource).FUse.Link;
  priority := TFhirClaim(oSource).priority.Clone;
  fundsReserve := TFhirClaim(oSource).fundsReserve.Clone;
  enterer := TFhirClaim(oSource).enterer.Clone;
  facility := TFhirClaim(oSource).facility.Clone;
  prescription := TFhirClaim(oSource).prescription.Clone;
  originalPrescription := TFhirClaim(oSource).originalPrescription.Clone;
  payee := TFhirClaim(oSource).payee.Clone;
  referral := TFhirClaim(oSource).referral.Clone;
  if (TFhirClaim(oSource).FDiagnosisList = nil) then
  begin
    FDiagnosisList.free;
    FDiagnosisList := nil;
  end
  else
  begin
    if FDiagnosisList = nil then
      FDiagnosisList := TFhirClaimDiagnosisList.Create;
    FDiagnosisList.Assign(TFhirClaim(oSource).FDiagnosisList);
  end;
  if (TFhirClaim(oSource).FConditionList = nil) then
  begin
    FConditionList.free;
    FConditionList := nil;
  end
  else
  begin
    if FConditionList = nil then
      FConditionList := TFhirCodingList.Create;
    FConditionList.Assign(TFhirClaim(oSource).FConditionList);
  end;
  patient := TFhirClaim(oSource).patient.Clone;
  if (TFhirClaim(oSource).FCoverageList = nil) then
  begin
    FCoverageList.free;
    FCoverageList := nil;
  end
  else
  begin
    if FCoverageList = nil then
      FCoverageList := TFhirClaimCoverageList.Create;
    FCoverageList.Assign(TFhirClaim(oSource).FCoverageList);
  end;
  if (TFhirClaim(oSource).FExceptionList = nil) then
  begin
    FExceptionList.free;
    FExceptionList := nil;
  end
  else
  begin
    if FExceptionList = nil then
      FExceptionList := TFhirCodingList.Create;
    FExceptionList.Assign(TFhirClaim(oSource).FExceptionList);
  end;
  schoolElement := TFhirClaim(oSource).schoolElement.Clone;
  accidentElement := TFhirClaim(oSource).accidentElement.Clone;
  accidentType := TFhirClaim(oSource).accidentType.Clone;
  if (TFhirClaim(oSource).FInterventionExceptionList = nil) then
  begin
    FInterventionExceptionList.free;
    FInterventionExceptionList := nil;
  end
  else
  begin
    if FInterventionExceptionList = nil then
      FInterventionExceptionList := TFhirCodingList.Create;
    FInterventionExceptionList.Assign(TFhirClaim(oSource).FInterventionExceptionList);
  end;
  if (TFhirClaim(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirClaimItemList.Create;
    FItemList.Assign(TFhirClaim(oSource).FItemList);
  end;
  if (TFhirClaim(oSource).FAdditionalMaterialsList = nil) then
  begin
    FAdditionalMaterialsList.free;
    FAdditionalMaterialsList := nil;
  end
  else
  begin
    if FAdditionalMaterialsList = nil then
      FAdditionalMaterialsList := TFhirCodingList.Create;
    FAdditionalMaterialsList.Assign(TFhirClaim(oSource).FAdditionalMaterialsList);
  end;
  if (TFhirClaim(oSource).FMissingTeethList = nil) then
  begin
    FMissingTeethList.free;
    FMissingTeethList := nil;
  end
  else
  begin
    if FMissingTeethList = nil then
      FMissingTeethList := TFhirClaimMissingTeethList.Create;
    FMissingTeethList.Assign(TFhirClaim(oSource).FMissingTeethList);
  end;
end;

procedure TFhirClaim.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'ruleset') Then
     list.add(self.link, 'ruleset', FRuleset.Link);
  if (child_name = 'originalRuleset') Then
     list.add(self.link, 'originalRuleset', FOriginalRuleset.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'target') Then
     list.add(self.link, 'target', FTarget.Link);
  if (child_name = 'provider') Then
     list.add(self.link, 'provider', FProvider.Link);
  if (child_name = 'organization') Then
     list.add(self.link, 'organization', FOrganization.Link);
  if (child_name = 'use') Then
     list.add(self.link, 'use', FUse.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'fundsReserve') Then
     list.add(self.link, 'fundsReserve', FFundsReserve.Link);
  if (child_name = 'enterer') Then
     list.add(self.link, 'enterer', FEnterer.Link);
  if (child_name = 'facility') Then
     list.add(self.link, 'facility', FFacility.Link);
  if (child_name = 'prescription') Then
     list.add(self.link, 'prescription', FPrescription.Link);
  if (child_name = 'originalPrescription') Then
     list.add(self.link, 'originalPrescription', FOriginalPrescription.Link);
  if (child_name = 'payee') Then
     list.add(self.link, 'payee', FPayee.Link);
  if (child_name = 'referral') Then
     list.add(self.link, 'referral', FReferral.Link);
  if (child_name = 'diagnosis') Then
    list.addAll(self, 'diagnosis', FDiagnosisList);
  if (child_name = 'condition') Then
    list.addAll(self, 'condition', FConditionList);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'coverage') Then
    list.addAll(self, 'coverage', FCoverageList);
  if (child_name = 'exception') Then
    list.addAll(self, 'exception', FExceptionList);
  if (child_name = 'school') Then
     list.add(self.link, 'school', FSchool.Link);
  if (child_name = 'accident') Then
     list.add(self.link, 'accident', FAccident.Link);
  if (child_name = 'accidentType') Then
     list.add(self.link, 'accidentType', FAccidentType.Link);
  if (child_name = 'interventionException') Then
    list.addAll(self, 'interventionException', FInterventionExceptionList);
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
  if (child_name = 'additionalMaterials') Then
    list.addAll(self, 'additionalMaterials', FAdditionalMaterialsList);
  if (child_name = 'missingTeeth') Then
    list.addAll(self, 'missingTeeth', FMissingTeethList);
end;

procedure TFhirClaim.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'ruleset', 'Coding', false, TFhirCoding, FRuleset.Link));{2}
  oList.add(TFHIRProperty.create(self, 'originalRuleset', 'Coding', false, TFhirCoding, FOriginalRuleset.Link));{2}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));{2}
  oList.add(TFHIRProperty.create(self, 'target', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FTarget.Link));{2}
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FProvider.Link));{2}
  oList.add(TFHIRProperty.create(self, 'organization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FOrganization.Link));{2}
  oList.add(TFHIRProperty.create(self, 'use', 'code', false, TFHIREnum, FUse.Link));{1}
  oList.add(TFHIRProperty.create(self, 'priority', 'Coding', false, TFhirCoding, FPriority.Link));{2}
  oList.add(TFHIRProperty.create(self, 'fundsReserve', 'Coding', false, TFhirCoding, FFundsReserve.Link));{2}
  oList.add(TFHIRProperty.create(self, 'enterer', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FEnterer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'facility', 'Reference(Location)', false, TFhirReference{TFhirLocation}, FFacility.Link));{2}
  oList.add(TFHIRProperty.create(self, 'prescription', 'Reference(MedicationOrder|VisionPrescription)', false, TFhirReference{Resource}, FPrescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'originalPrescription', 'Reference(MedicationOrder)', false, TFhirReference{TFhirMedicationOrder}, FOriginalPrescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'payee', '', false, TFhirClaimPayee, FPayee.Link));{2}
  oList.add(TFHIRProperty.create(self, 'referral', 'Reference(ReferralRequest)', false, TFhirReference{TFhirReferralRequest}, FReferral.Link));{2}
  oList.add(TFHIRProperty.create(self, 'diagnosis', '', true, TFhirClaimDiagnosis, FDiagnosisList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'condition', 'Coding', true, TFhirCoding, FConditionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'coverage', '', true, TFhirClaimCoverage, FCoverageList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'exception', 'Coding', true, TFhirCoding, FExceptionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'school', 'string', false, TFhirString, FSchool.Link));{2}
  oList.add(TFHIRProperty.create(self, 'accident', 'date', false, TFhirDate, FAccident.Link));{2}
  oList.add(TFHIRProperty.create(self, 'accidentType', 'Coding', false, TFhirCoding, FAccidentType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'interventionException', 'Coding', true, TFhirCoding, FInterventionExceptionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'item', '', true, TFhirClaimItem, FItemList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'additionalMaterials', 'Coding', true, TFhirCoding, FAdditionalMaterialsList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'missingTeeth', '', true, TFhirClaimMissingTeeth, FMissingTeethList.Link)){3};
end;

function TFhirClaim.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirClaimTypeLinkEnum, CODES_TFhirClaimTypeLinkEnum, propValue);
    result := propValue
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'ruleset') then
  begin
    Ruleset := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'originalRuleset') then
  begin
    OriginalRuleset := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'target') then
  begin
    Target := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'provider') then
  begin
    Provider := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'organization') then
  begin
    Organization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'use') then
  begin
    UseElement := asEnum(SYSTEMS_TFhirClaimUseLinkEnum, CODES_TFhirClaimUseLinkEnum, propValue);
    result := propValue
  end
  else if (propName = 'priority') then
  begin
    Priority := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'fundsReserve') then
  begin
    FundsReserve := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'enterer') then
  begin
    Enterer := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'facility') then
  begin
    Facility := propValue as TFhirReference{TFhirLocation}{4b};
    result := propValue;
  end
  else if (propName = 'prescription') then
  begin
    Prescription := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'originalPrescription') then
  begin
    OriginalPrescription := propValue as TFhirReference{TFhirMedicationOrder}{4b};
    result := propValue;
  end
  else if (propName = 'payee') then
  begin
    Payee := propValue as TFhirClaimPayee{4b};
    result := propValue;
  end
  else if (propName = 'referral') then
  begin
    Referral := propValue as TFhirReference{TFhirReferralRequest}{4b};
    result := propValue;
  end
  else if (propName = 'diagnosis') then
  begin
    DiagnosisList.add(propValue as TFhirClaimDiagnosis){2a};
    result := propValue;
  end
  else if (propName = 'condition') then
  begin
    ConditionList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'coverage') then
  begin
    CoverageList.add(propValue as TFhirClaimCoverage){2a};
    result := propValue;
  end
  else if (propName = 'exception') then
  begin
    ExceptionList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else if (propName = 'school') then
  begin
    SchoolElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'accident') then
  begin
    AccidentElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'accidentType') then
  begin
    AccidentType := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'interventionException') then
  begin
    InterventionExceptionList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirClaimItem){2a};
    result := propValue;
  end
  else if (propName = 'additionalMaterials') then
  begin
    AdditionalMaterialsList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else if (propName = 'missingTeeth') then
  begin
    MissingTeethList.add(propValue as TFhirClaimMissingTeeth){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirClaim.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'diagnosis') then DiagnosisList.insertItem(index, propValue as TFhirClaimDiagnosis){2a}
  else if (propName = 'condition') then ConditionList.insertItem(index, propValue as TFhirCoding){2a}
  else if (propName = 'coverage') then CoverageList.insertItem(index, propValue as TFhirClaimCoverage){2a}
  else if (propName = 'exception') then ExceptionList.insertItem(index, propValue as TFhirCoding){2a}
  else if (propName = 'interventionException') then InterventionExceptionList.insertItem(index, propValue as TFhirCoding){2a}
  else if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirClaimItem){2a}
  else if (propName = 'additionalMaterials') then AdditionalMaterialsList.insertItem(index, propValue as TFhirCoding){2a}
  else if (propName = 'missingTeeth') then MissingTeethList.insertItem(index, propValue as TFhirClaimMissingTeeth){2a}
  else inherited;
end;

function TFhirClaim.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'ruleset') then result := TFhirCoding.create(){4b}
  else if (propName = 'originalRuleset') then result := TFhirCoding.create(){4b}
  else if (propName = 'created') then result := TFhirDateTime.create() {5b}
  else if (propName = 'target') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'provider') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'organization') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'priority') then result := TFhirCoding.create(){4b}
  else if (propName = 'fundsReserve') then result := TFhirCoding.create(){4b}
  else if (propName = 'enterer') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'facility') then result := TFhirReference{TFhirLocation}.create(){4b}
  else if (propName = 'prescription') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'originalPrescription') then result := TFhirReference{TFhirMedicationOrder}.create(){4b}
  else if (propName = 'payee') then result := TFhirClaimPayee.create(){4b}
  else if (propName = 'referral') then result := TFhirReference{TFhirReferralRequest}.create(){4b}
  else if (propName = 'diagnosis') then result := DiagnosisList.new(){2}
  else if (propName = 'condition') then result := ConditionList.new(){2}
  else if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'coverage') then result := CoverageList.new(){2}
  else if (propName = 'exception') then result := ExceptionList.new(){2}
  else if (propName = 'school') then result := TFhirString.create() {5b}
  else if (propName = 'accident') then result := TFhirDate.create() {5b}
  else if (propName = 'accidentType') then result := TFhirCoding.create(){4b}
  else if (propName = 'interventionException') then result := InterventionExceptionList.new(){2}
  else if (propName = 'item') then result := ItemList.new(){2}
  else if (propName = 'additionalMaterials') then result := AdditionalMaterialsList.new(){2}
  else if (propName = 'missingTeeth') then result := MissingTeethList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaim.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'ruleset') then result := 'Coding'
  else if (propName = 'originalRuleset') then result := 'Coding'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'target') then result := 'Reference'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'organization') then result := 'Reference'
  else if (propName = 'use') then result := 'code'
  else if (propName = 'priority') then result := 'Coding'
  else if (propName = 'fundsReserve') then result := 'Coding'
  else if (propName = 'enterer') then result := 'Reference'
  else if (propName = 'facility') then result := 'Reference'
  else if (propName = 'prescription') then result := 'Reference'
  else if (propName = 'originalPrescription') then result := 'Reference'
  else if (propName = 'payee') then result := ''
  else if (propName = 'referral') then result := 'Reference'
  else if (propName = 'diagnosis') then result := ''
  else if (propName = 'condition') then result := 'Coding'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'coverage') then result := ''
  else if (propName = 'exception') then result := 'Coding'
  else if (propName = 'school') then result := 'string'
  else if (propName = 'accident') then result := 'date'
  else if (propName = 'accidentType') then result := 'Coding'
  else if (propName = 'interventionException') then result := 'Coding'
  else if (propName = 'item') then result := ''
  else if (propName = 'additionalMaterials') then result := 'Coding'
  else if (propName = 'missingTeeth') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaim.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'ruleset') then RulesetElement := nil
  else if (propName = 'originalRuleset') then OriginalRulesetElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'target') then TargetElement := nil
  else if (propName = 'provider') then ProviderElement := nil
  else if (propName = 'organization') then OrganizationElement := nil
  else if (propName = 'use') then UseElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'fundsReserve') then FundsReserveElement := nil
  else if (propName = 'enterer') then EntererElement := nil
  else if (propName = 'facility') then FacilityElement := nil
  else if (propName = 'prescription') then PrescriptionElement := nil
  else if (propName = 'originalPrescription') then OriginalPrescriptionElement := nil
  else if (propName = 'payee') then PayeeElement := nil
  else if (propName = 'referral') then ReferralElement := nil
  else if (propName = 'diagnosis') then deletePropertyValue('diagnosis', DiagnosisList, value) {2}
  else if (propName = 'condition') then deletePropertyValue('condition', ConditionList, value) {2}
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'coverage') then deletePropertyValue('coverage', CoverageList, value) {2}
  else if (propName = 'exception') then deletePropertyValue('exception', ExceptionList, value) {2}
  else if (propName = 'school') then SchoolElement := nil
  else if (propName = 'accident') then AccidentElement := nil
  else if (propName = 'accidentType') then AccidentTypeElement := nil
  else if (propName = 'interventionException') then deletePropertyValue('interventionException', InterventionExceptionList, value) {2}
  else if (propName = 'item') then deletePropertyValue('item', ItemList, value) {2}
  else if (propName = 'additionalMaterials') then deletePropertyValue('additionalMaterials', AdditionalMaterialsList, value) {2}
  else if (propName = 'missingTeeth') then deletePropertyValue('missingTeeth', MissingTeethList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaim.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirClaimTypeLinkEnum, CODES_TFhirClaimTypeLinkEnum, new){4}
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'ruleset') then RulesetElement := new as TFhirCoding{4}
  else if (propName = 'originalRuleset') then OriginalRulesetElement := new as TFhirCoding{4}
  else if (propName = 'created') then CreatedElement := asDateTime(new){5b}
  else if (propName = 'target') then TargetElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'provider') then ProviderElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'organization') then OrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'use') then UseElement := asEnum(SYSTEMS_TFhirClaimUseLinkEnum, CODES_TFhirClaimUseLinkEnum, new){4}
  else if (propName = 'priority') then PriorityElement := new as TFhirCoding{4}
  else if (propName = 'fundsReserve') then FundsReserveElement := new as TFhirCoding{4}
  else if (propName = 'enterer') then EntererElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'facility') then FacilityElement := new as TFhirReference{TFhirLocation}{4}
  else if (propName = 'prescription') then PrescriptionElement := new as TFhirReference{Resource}{4}
  else if (propName = 'originalPrescription') then OriginalPrescriptionElement := new as TFhirReference{TFhirMedicationOrder}{4}
  else if (propName = 'payee') then PayeeElement := new as TFhirClaimPayee{4}
  else if (propName = 'referral') then ReferralElement := new as TFhirReference{TFhirReferralRequest}{4}
  else if (propName = 'diagnosis') then replacePropertyValue('diagnosis', DiagnosisList, existing, new) {2}
  else if (propName = 'condition') then replacePropertyValue('condition', ConditionList, existing, new) {2}
  else if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'coverage') then replacePropertyValue('coverage', CoverageList, existing, new) {2}
  else if (propName = 'exception') then replacePropertyValue('exception', ExceptionList, existing, new) {2}
  else if (propName = 'school') then SchoolElement := asString(new){5b}
  else if (propName = 'accident') then AccidentElement := asDate(new){5b}
  else if (propName = 'accidentType') then AccidentTypeElement := new as TFhirCoding{4}
  else if (propName = 'interventionException') then replacePropertyValue('interventionException', InterventionExceptionList, existing, new) {2}
  else if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new) {2}
  else if (propName = 'additionalMaterials') then replacePropertyValue('additionalMaterials', AdditionalMaterialsList, existing, new) {2}
  else if (propName = 'missingTeeth') then replacePropertyValue('missingTeeth', MissingTeethList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaim.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'diagnosis') then DiagnosisList.move(source, destination){2a}
  else if (propName = 'condition') then ConditionList.move(source, destination){2a}
  else if (propName = 'coverage') then CoverageList.move(source, destination){2a}
  else if (propName = 'exception') then ExceptionList.move(source, destination){2a}
  else if (propName = 'interventionException') then InterventionExceptionList.move(source, destination){2a}
  else if (propName = 'item') then ItemList.move(source, destination){2a}
  else if (propName = 'additionalMaterials') then AdditionalMaterialsList.move(source, destination){2a}
  else if (propName = 'missingTeeth') then MissingTeethList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaim.fhirType : string;
begin
  result := 'Claim';
end;

function TFhirClaim.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FidentifierList) and isEmptyProp(FRuleset) and isEmptyProp(FOriginalRuleset) and isEmptyProp(FCreated) and isEmptyProp(FTarget) and isEmptyProp(FProvider) and isEmptyProp(FOrganization) and isEmptyProp(FUse) and isEmptyProp(FPriority) and isEmptyProp(FFundsReserve) and isEmptyProp(FEnterer) and isEmptyProp(FFacility) and isEmptyProp(FPrescription) and isEmptyProp(FOriginalPrescription) and isEmptyProp(FPayee) and isEmptyProp(FReferral) and isEmptyProp(FdiagnosisList) and isEmptyProp(FconditionList) and isEmptyProp(FPatient) and isEmptyProp(FcoverageList) and isEmptyProp(FexceptionList) and isEmptyProp(FSchool) and isEmptyProp(FAccident) and isEmptyProp(FAccidentType) and isEmptyProp(FinterventionExceptionList) and isEmptyProp(FitemList) and isEmptyProp(FadditionalMaterialsList) and isEmptyProp(FmissingTeethList);
end;

function TFhirClaim.equals(other : TObject) : boolean;
var
  o : TFhirClaim;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaim)) then
    result := false
  else
  begin
    o := TFhirClaim(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(identifierList, o.identifierList, true) and
      compareDeep(rulesetElement, o.rulesetElement, true) and compareDeep(originalRulesetElement, o.originalRulesetElement, true) and
      compareDeep(createdElement, o.createdElement, true) and compareDeep(targetElement, o.targetElement, true) and
      compareDeep(providerElement, o.providerElement, true) and compareDeep(organizationElement, o.organizationElement, true) and
      compareDeep(useElement, o.useElement, true) and compareDeep(priorityElement, o.priorityElement, true) and
      compareDeep(fundsReserveElement, o.fundsReserveElement, true) and compareDeep(entererElement, o.entererElement, true) and
      compareDeep(facilityElement, o.facilityElement, true) and compareDeep(prescriptionElement, o.prescriptionElement, true) and
      compareDeep(originalPrescriptionElement, o.originalPrescriptionElement, true) and
      compareDeep(payeeElement, o.payeeElement, true) and compareDeep(referralElement, o.referralElement, true) and
      compareDeep(diagnosisList, o.diagnosisList, true) and compareDeep(conditionList, o.conditionList, true) and
      compareDeep(patientElement, o.patientElement, true) and compareDeep(coverageList, o.coverageList, true) and
      compareDeep(exceptionList, o.exceptionList, true) and compareDeep(schoolElement, o.schoolElement, true) and
      compareDeep(accidentElement, o.accidentElement, true) and compareDeep(accidentTypeElement, o.accidentTypeElement, true) and
      compareDeep(interventionExceptionList, o.interventionExceptionList, true) and
      compareDeep(itemList, o.itemList, true) and compareDeep(additionalMaterialsList, o.additionalMaterialsList, true) and
      compareDeep(missingTeethList, o.missingTeethList, true);
  end;
end;

function TFhirClaim.Link : TFhirClaim;
begin
  result := TFhirClaim(inherited Link);
end;

function TFhirClaim.Clone : TFhirClaim;
begin
  result := TFhirClaim(inherited Clone);
end;

procedure TFhirClaim.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('type');
  fields.add('identifier');
  fields.add('ruleset');
  fields.add('originalRuleset');
  fields.add('created');
  fields.add('target');
  fields.add('provider');
  fields.add('organization');
  fields.add('use');
  fields.add('priority');
  fields.add('fundsReserve');
  fields.add('enterer');
  fields.add('facility');
  fields.add('prescription');
  fields.add('originalPrescription');
  fields.add('payee');
  fields.add('referral');
  fields.add('diagnosis');
  fields.add('condition');
  fields.add('patient');
  fields.add('coverage');
  fields.add('exception');
  fields.add('school');
  fields.add('accident');
  fields.add('accidentType');
  fields.add('interventionException');
  fields.add('item');
  fields.add('additionalMaterials');
  fields.add('missingTeeth');
end;

{ TFhirClaim }

Procedure TFhirClaim.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirClaim.GetType_ST : TFhirClaimTypeLinkEnum;
begin
  if FType_ = nil then
    result := TFhirClaimTypeLinkEnum(0)
  else
    result := TFhirClaimTypeLinkEnum(StringArrayIndexOfSensitive(CODES_TFhirClaimTypeLinkEnum, FType_.value));
end;

Procedure TFhirClaim.SetType_ST(value : TFhirClaimTypeLinkEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirClaimTypeLinkEnum[value], CODES_TFhirClaimTypeLinkEnum[value]);
end;

Function TFhirClaim.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirClaim.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirClaim.SetRuleset(value : TFhirCoding);
begin
  FRuleset.free;
  FRuleset := value;
end;

Procedure TFhirClaim.SetOriginalRuleset(value : TFhirCoding);
begin
  FOriginalRuleset.free;
  FOriginalRuleset := value;
end;

Procedure TFhirClaim.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

Function TFhirClaim.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

Procedure TFhirClaim.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

Procedure TFhirClaim.SetTarget(value : TFhirReference{TFhirOrganization});
begin
  FTarget.free;
  FTarget := value;
end;

Procedure TFhirClaim.SetProvider(value : TFhirReference{TFhirPractitioner});
begin
  FProvider.free;
  FProvider := value;
end;

Procedure TFhirClaim.SetOrganization(value : TFhirReference{TFhirOrganization});
begin
  FOrganization.free;
  FOrganization := value;
end;

Procedure TFhirClaim.SetUse(value : TFhirEnum);
begin
  FUse.free;
  FUse := value;
end;

Function TFhirClaim.GetUseST : TFhirClaimUseLinkEnum;
begin
  if FUse = nil then
    result := TFhirClaimUseLinkEnum(0)
  else
    result := TFhirClaimUseLinkEnum(StringArrayIndexOfSensitive(CODES_TFhirClaimUseLinkEnum, FUse.value));
end;

Procedure TFhirClaim.SetUseST(value : TFhirClaimUseLinkEnum);
begin
  if ord(value) = 0 then
    UseElement := nil
  else
    UseElement := TFhirEnum.create(SYSTEMS_TFhirClaimUseLinkEnum[value], CODES_TFhirClaimUseLinkEnum[value]);
end;

Procedure TFhirClaim.SetPriority(value : TFhirCoding);
begin
  FPriority.free;
  FPriority := value;
end;

Procedure TFhirClaim.SetFundsReserve(value : TFhirCoding);
begin
  FFundsReserve.free;
  FFundsReserve := value;
end;

Procedure TFhirClaim.SetEnterer(value : TFhirReference{TFhirPractitioner});
begin
  FEnterer.free;
  FEnterer := value;
end;

Procedure TFhirClaim.SetFacility(value : TFhirReference{TFhirLocation});
begin
  FFacility.free;
  FFacility := value;
end;

Procedure TFhirClaim.SetPrescription(value : TFhirReference{Resource});
begin
  FPrescription.free;
  FPrescription := value;
end;

Procedure TFhirClaim.SetOriginalPrescription(value : TFhirReference{TFhirMedicationOrder});
begin
  FOriginalPrescription.free;
  FOriginalPrescription := value;
end;

Procedure TFhirClaim.SetPayee(value : TFhirClaimPayee);
begin
  FPayee.free;
  FPayee := value;
end;

Procedure TFhirClaim.SetReferral(value : TFhirReference{TFhirReferralRequest});
begin
  FReferral.free;
  FReferral := value;
end;

Function TFhirClaim.GetDiagnosisList : TFhirClaimDiagnosisList;
begin
  if FDiagnosisList = nil then
    FDiagnosisList := TFhirClaimDiagnosisList.Create;
  result := FDiagnosisList;
end;

Function TFhirClaim.GetHasDiagnosisList : boolean;
begin
  result := (FDiagnosisList <> nil) and (FDiagnosisList.count > 0);
end;

Function TFhirClaim.GetConditionList : TFhirCodingList;
begin
  if FConditionList = nil then
    FConditionList := TFhirCodingList.Create;
  result := FConditionList;
end;

Function TFhirClaim.GetHasConditionList : boolean;
begin
  result := (FConditionList <> nil) and (FConditionList.count > 0);
end;

Procedure TFhirClaim.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Function TFhirClaim.GetCoverageList : TFhirClaimCoverageList;
begin
  if FCoverageList = nil then
    FCoverageList := TFhirClaimCoverageList.Create;
  result := FCoverageList;
end;

Function TFhirClaim.GetHasCoverageList : boolean;
begin
  result := (FCoverageList <> nil) and (FCoverageList.count > 0);
end;

Function TFhirClaim.GetExceptionList : TFhirCodingList;
begin
  if FExceptionList = nil then
    FExceptionList := TFhirCodingList.Create;
  result := FExceptionList;
end;

Function TFhirClaim.GetHasExceptionList : boolean;
begin
  result := (FExceptionList <> nil) and (FExceptionList.count > 0);
end;

Procedure TFhirClaim.SetSchool(value : TFhirString);
begin
  FSchool.free;
  FSchool := value;
end;

Function TFhirClaim.GetSchoolST : String;
begin
  if FSchool = nil then
    result := ''
  else
    result := FSchool.value;
end;

Procedure TFhirClaim.SetSchoolST(value : String);
begin
  if value <> '' then
  begin
    if FSchool = nil then
      FSchool := TFhirString.create;
    FSchool.value := value
  end
  else if FSchool <> nil then
    FSchool.value := '';
end;

Procedure TFhirClaim.SetAccident(value : TFhirDate);
begin
  FAccident.free;
  FAccident := value;
end;

Function TFhirClaim.GetAccidentST : TFslDateTime;
begin
  if FAccident = nil then
    result := TFslDateTime.makeNull
  else
    result := FAccident.value;
end;

Procedure TFhirClaim.SetAccidentST(value : TFslDateTime);
begin
  if FAccident = nil then
    FAccident := TFhirDate.create;
  FAccident.value := value
end;

Procedure TFhirClaim.SetAccidentType(value : TFhirCoding);
begin
  FAccidentType.free;
  FAccidentType := value;
end;

Function TFhirClaim.GetInterventionExceptionList : TFhirCodingList;
begin
  if FInterventionExceptionList = nil then
    FInterventionExceptionList := TFhirCodingList.Create;
  result := FInterventionExceptionList;
end;

Function TFhirClaim.GetHasInterventionExceptionList : boolean;
begin
  result := (FInterventionExceptionList <> nil) and (FInterventionExceptionList.count > 0);
end;

Function TFhirClaim.GetItemList : TFhirClaimItemList;
begin
  if FItemList = nil then
    FItemList := TFhirClaimItemList.Create;
  result := FItemList;
end;

Function TFhirClaim.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

Function TFhirClaim.GetAdditionalMaterialsList : TFhirCodingList;
begin
  if FAdditionalMaterialsList = nil then
    FAdditionalMaterialsList := TFhirCodingList.Create;
  result := FAdditionalMaterialsList;
end;

Function TFhirClaim.GetHasAdditionalMaterialsList : boolean;
begin
  result := (FAdditionalMaterialsList <> nil) and (FAdditionalMaterialsList.count > 0);
end;

Function TFhirClaim.GetMissingTeethList : TFhirClaimMissingTeethList;
begin
  if FMissingTeethList = nil then
    FMissingTeethList := TFhirClaimMissingTeethList.Create;
  result := FMissingTeethList;
end;

Function TFhirClaim.GetHasMissingTeethList : boolean;
begin
  result := (FMissingTeethList <> nil) and (FMissingTeethList.count > 0);
end;

function TFhirClaim.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FRuleset.sizeInBytes);
  inc(result, FOriginalRuleset.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FTarget.sizeInBytes);
  inc(result, FProvider.sizeInBytes);
  inc(result, FOrganization.sizeInBytes);
  inc(result, FUse.sizeInBytes);
  inc(result, FPriority.sizeInBytes);
  inc(result, FFundsReserve.sizeInBytes);
  inc(result, FEnterer.sizeInBytes);
  inc(result, FFacility.sizeInBytes);
  inc(result, FPrescription.sizeInBytes);
  inc(result, FOriginalPrescription.sizeInBytes);
  inc(result, FPayee.sizeInBytes);
  inc(result, FReferral.sizeInBytes);
  inc(result, FdiagnosisList.sizeInBytes);
  inc(result, FconditionList.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FcoverageList.sizeInBytes);
  inc(result, FexceptionList.sizeInBytes);
  inc(result, FSchool.sizeInBytes);
  inc(result, FAccident.sizeInBytes);
  inc(result, FAccidentType.sizeInBytes);
  inc(result, FinterventionExceptionList.sizeInBytes);
  inc(result, FitemList.sizeInBytes);
  inc(result, FadditionalMaterialsList.sizeInBytes);
  inc(result, FmissingTeethList.sizeInBytes);
end;

{ TFhirClaimListEnumerator }

Constructor TFhirClaimListEnumerator.Create(list : TFhirClaimList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimListEnumerator.GetCurrent : TFhirClaim;
begin
  Result := FList[FIndex];
end;

function TFhirClaimListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimList }
procedure TFhirClaimList.AddItem(value: TFhirClaim);
begin
  assert(value.ClassName = 'TFhirClaim', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaim');
  add(value);
end;

function TFhirClaimList.Append: TFhirClaim;
begin
  result := TFhirClaim.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimList.ClearItems;
begin
  Clear;
end;

function TFhirClaimList.GetEnumerator : TFhirClaimListEnumerator;
begin
  result := TFhirClaimListEnumerator.Create(self.link);
end;

function TFhirClaimList.Clone: TFhirClaimList;
begin
  result := TFhirClaimList(inherited Clone);
end;

function TFhirClaimList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimList.GetItemN(index: Integer): TFhirClaim;
begin
  result := TFhirClaim(ObjectByIndex[index]);
end;

function TFhirClaimList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaim;
end;
function TFhirClaimList.IndexOf(value: TFhirClaim): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimList.Insert(index: Integer): TFhirClaim;
begin
  result := TFhirClaim.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimList.InsertItem(index: Integer; value: TFhirClaim);
begin
  assert(value is TFhirClaim);
  Inherited Insert(index, value);
end;

function TFhirClaimList.Item(index: Integer): TFhirClaim;
begin
  result := TFhirClaim(ObjectByIndex[index]);
end;

function TFhirClaimList.Link: TFhirClaimList;
begin
  result := TFhirClaimList(inherited Link);
end;

procedure TFhirClaimList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimList.SetItemByIndex(index: Integer; value: TFhirClaim);
begin
  assert(value is TFhirClaim);
  FhirClaims[index] := value;
end;

procedure TFhirClaimList.SetItemN(index: Integer; value: TFhirClaim);
begin
  assert(value is TFhirClaim);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CLAIM}

{$IFDEF FHIR_CLAIMRESPONSE}

{ TFhirClaimResponseItem }

constructor TFhirClaimResponseItem.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseItem.Destroy;
begin
  FSequenceLinkId.free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirClaimResponseItem.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceLinkIdElement := TFhirClaimResponseItem(oSource).sequenceLinkIdElement.Clone;
  if (TFhirClaimResponseItem(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirClaimResponseItem(oSource).FNoteNumberList);
  end;
  if (TFhirClaimResponseItem(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirClaimResponseItem(oSource).FAdjudicationList);
  end;
  if (TFhirClaimResponseItem(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirClaimResponseItemDetailList.Create;
    FDetailList.Assign(TFhirClaimResponseItem(oSource).FDetailList);
  end;
end;

procedure TFhirClaimResponseItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequenceLinkId') Then
     list.add(self.link, 'sequenceLinkId', FSequenceLinkId.Link);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
end;

procedure TFhirClaimResponseItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequenceLinkId', 'positiveInt', false, TFhirPositiveInt, FSequenceLinkId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'adjudication', '', true, TFhirClaimResponseItemAdjudication, FAdjudicationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'detail', '', true, TFhirClaimResponseItemDetail, FDetailList.Link)){3};
end;

function TFhirClaimResponseItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequenceLinkId') then
  begin
    SequenceLinkIdElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirClaimResponseItemAdjudication){2a};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirClaimResponseItemDetail){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirClaimResponseItemAdjudication){2a}
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirClaimResponseItemDetail){2a}
  else inherited;
end;

function TFhirClaimResponseItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequenceLinkId') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'noteNumber') then result := NoteNumberList.new(){2}
  else if (propName = 'adjudication') then result := AdjudicationList.new(){2}
  else if (propName = 'detail') then result := DetailList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequenceLinkId') then result := 'positiveInt'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := ''
  else if (propName = 'detail') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequenceLinkId') then SequenceLinkIdElement := nil
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value) {2}
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value) {2}
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequenceLinkId') then SequenceLinkIdElement := asPositiveInt(new){5b}
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new) {2}
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new) {2}
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'noteNumber') then NoteNumberList.move(source, destination){2}
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination){2a}
  else if (propName = 'detail') then DetailList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseItem.fhirType : string;
begin
  result := 'item';
end;

function TFhirClaimResponseItem.Link : TFhirClaimResponseItem;
begin
  result := TFhirClaimResponseItem(inherited Link);
end;

function TFhirClaimResponseItem.Clone : TFhirClaimResponseItem;
begin
  result := TFhirClaimResponseItem(inherited Clone);
end;

function TFhirClaimResponseItem.equals(other : TObject) : boolean;
var
  o : TFhirClaimResponseItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseItem)) then
    result := false
  else
  begin
    o := TFhirClaimResponseItem(other);
    result := compareDeep(sequenceLinkIdElement, o.sequenceLinkIdElement, true) and
      compareDeep(noteNumberList, o.noteNumberList, true) and compareDeep(adjudicationList, o.adjudicationList, true) and
      compareDeep(detailList, o.detailList, true);
  end;
end;

function TFhirClaimResponseItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequenceLinkId) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList) and isEmptyProp(FdetailList);
end;

procedure TFhirClaimResponseItem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequenceLinkId');
  fields.add('noteNumber');
  fields.add('adjudication');
  fields.add('detail');
end;

{ TFhirClaimResponseItem }

Procedure TFhirClaimResponseItem.SetSequenceLinkId(value : TFhirPositiveInt);
begin
  FSequenceLinkId.free;
  FSequenceLinkId := value;
end;

Function TFhirClaimResponseItem.GetSequenceLinkIdST : String;
begin
  if FSequenceLinkId = nil then
    result := ''
  else
    result := FSequenceLinkId.value;
end;

Procedure TFhirClaimResponseItem.SetSequenceLinkIdST(value : String);
begin
  if value <> '' then
  begin
    if FSequenceLinkId = nil then
      FSequenceLinkId := TFhirPositiveInt.create;
    FSequenceLinkId.value := value
  end
  else if FSequenceLinkId <> nil then
    FSequenceLinkId.value := '';
end;

Function TFhirClaimResponseItem.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

Function TFhirClaimResponseItem.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

Function TFhirClaimResponseItem.GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

Function TFhirClaimResponseItem.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

Function TFhirClaimResponseItem.GetDetailList : TFhirClaimResponseItemDetailList;
begin
  if FDetailList = nil then
    FDetailList := TFhirClaimResponseItemDetailList.Create;
  result := FDetailList;
end;

Function TFhirClaimResponseItem.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

function TFhirClaimResponseItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequenceLinkId.sizeInBytes);
  inc(result, FnoteNumberList.sizeInBytes);
  inc(result, FadjudicationList.sizeInBytes);
  inc(result, FdetailList.sizeInBytes);
end;

{ TFhirClaimResponseItemListEnumerator }

Constructor TFhirClaimResponseItemListEnumerator.Create(list : TFhirClaimResponseItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseItemListEnumerator.GetCurrent : TFhirClaimResponseItem;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseItemList }
procedure TFhirClaimResponseItemList.AddItem(value: TFhirClaimResponseItem);
begin
  assert(value.ClassName = 'TFhirClaimResponseItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseItem');
  add(value);
end;

function TFhirClaimResponseItemList.Append: TFhirClaimResponseItem;
begin
  result := TFhirClaimResponseItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseItemList.GetEnumerator : TFhirClaimResponseItemListEnumerator;
begin
  result := TFhirClaimResponseItemListEnumerator.Create(self.link);
end;

function TFhirClaimResponseItemList.Clone: TFhirClaimResponseItemList;
begin
  result := TFhirClaimResponseItemList(inherited Clone);
end;

function TFhirClaimResponseItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseItemList.GetItemN(index: Integer): TFhirClaimResponseItem;
begin
  result := TFhirClaimResponseItem(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseItem;
end;
function TFhirClaimResponseItemList.IndexOf(value: TFhirClaimResponseItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseItemList.Insert(index: Integer): TFhirClaimResponseItem;
begin
  result := TFhirClaimResponseItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemList.InsertItem(index: Integer; value: TFhirClaimResponseItem);
begin
  assert(value is TFhirClaimResponseItem);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseItemList.Item(index: Integer): TFhirClaimResponseItem;
begin
  result := TFhirClaimResponseItem(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemList.Link: TFhirClaimResponseItemList;
begin
  result := TFhirClaimResponseItemList(inherited Link);
end;

procedure TFhirClaimResponseItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseItemList.SetItemByIndex(index: Integer; value: TFhirClaimResponseItem);
begin
  assert(value is TFhirClaimResponseItem);
  FhirClaimResponseItems[index] := value;
end;

procedure TFhirClaimResponseItemList.SetItemN(index: Integer; value: TFhirClaimResponseItem);
begin
  assert(value is TFhirClaimResponseItem);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseItemAdjudication }

constructor TFhirClaimResponseItemAdjudication.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseItemAdjudication.Destroy;
begin
  FCode.free;
  FAmount.free;
  FValue.free;
  inherited;
end;

procedure TFhirClaimResponseItemAdjudication.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirClaimResponseItemAdjudication(oSource).code.Clone;
  amount := TFhirClaimResponseItemAdjudication(oSource).amount.Clone;
  valueElement := TFhirClaimResponseItemAdjudication(oSource).valueElement.Clone;
end;

procedure TFhirClaimResponseItemAdjudication.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirClaimResponseItemAdjudication.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'Coding', false, TFhirCoding, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amount', 'Quantity', false, TFhirQuantity, FAmount.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value', 'decimal', false, TFhirDecimal, FValue.Link));{2}
end;

function TFhirClaimResponseItemAdjudication.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseItemAdjudication.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimResponseItemAdjudication.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCoding.create(){4b}
  else if (propName = 'amount') then result := TFhirQuantity.create(){4b}
  else if (propName = 'value') then result := TFhirDecimal.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseItemAdjudication.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'Coding'
  else if (propName = 'amount') then result := 'Quantity'
  else if (propName = 'value') then result := 'decimal'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseItemAdjudication.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseItemAdjudication.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCoding{4}
  else if (propName = 'amount') then AmountElement := new as TFhirQuantity{4}
  else if (propName = 'value') then ValueElement := asDecimal(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseItemAdjudication.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseItemAdjudication.fhirType : string;
begin
  result := 'adjudication';
end;

function TFhirClaimResponseItemAdjudication.Link : TFhirClaimResponseItemAdjudication;
begin
  result := TFhirClaimResponseItemAdjudication(inherited Link);
end;

function TFhirClaimResponseItemAdjudication.Clone : TFhirClaimResponseItemAdjudication;
begin
  result := TFhirClaimResponseItemAdjudication(inherited Clone);
end;

function TFhirClaimResponseItemAdjudication.equals(other : TObject) : boolean;
var
  o : TFhirClaimResponseItemAdjudication;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseItemAdjudication)) then
    result := false
  else
  begin
    o := TFhirClaimResponseItemAdjudication(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(amountElement, o.amountElement, true) and
      compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirClaimResponseItemAdjudication.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FAmount) and isEmptyProp(FValue);
end;

procedure TFhirClaimResponseItemAdjudication.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('amount');
  fields.add('value');
end;

{ TFhirClaimResponseItemAdjudication }

Procedure TFhirClaimResponseItemAdjudication.SetCode(value : TFhirCoding);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirClaimResponseItemAdjudication.SetAmount(value : TFhirQuantity);
begin
  FAmount.free;
  FAmount := value;
end;

Procedure TFhirClaimResponseItemAdjudication.SetValue(value : TFhirDecimal);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirClaimResponseItemAdjudication.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

Procedure TFhirClaimResponseItemAdjudication.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirDecimal.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

function TFhirClaimResponseItemAdjudication.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirClaimResponseItemAdjudicationListEnumerator }

Constructor TFhirClaimResponseItemAdjudicationListEnumerator.Create(list : TFhirClaimResponseItemAdjudicationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseItemAdjudicationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseItemAdjudicationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseItemAdjudicationListEnumerator.GetCurrent : TFhirClaimResponseItemAdjudication;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseItemAdjudicationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseItemAdjudicationList }
procedure TFhirClaimResponseItemAdjudicationList.AddItem(value: TFhirClaimResponseItemAdjudication);
begin
  assert(value.ClassName = 'TFhirClaimResponseItemAdjudication', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseItemAdjudication');
  add(value);
end;

function TFhirClaimResponseItemAdjudicationList.Append: TFhirClaimResponseItemAdjudication;
begin
  result := TFhirClaimResponseItemAdjudication.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemAdjudicationList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseItemAdjudicationList.GetEnumerator : TFhirClaimResponseItemAdjudicationListEnumerator;
begin
  result := TFhirClaimResponseItemAdjudicationListEnumerator.Create(self.link);
end;

function TFhirClaimResponseItemAdjudicationList.Clone: TFhirClaimResponseItemAdjudicationList;
begin
  result := TFhirClaimResponseItemAdjudicationList(inherited Clone);
end;

function TFhirClaimResponseItemAdjudicationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseItemAdjudicationList.GetItemN(index: Integer): TFhirClaimResponseItemAdjudication;
begin
  result := TFhirClaimResponseItemAdjudication(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemAdjudicationList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseItemAdjudication;
end;
function TFhirClaimResponseItemAdjudicationList.IndexOf(value: TFhirClaimResponseItemAdjudication): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseItemAdjudicationList.Insert(index: Integer): TFhirClaimResponseItemAdjudication;
begin
  result := TFhirClaimResponseItemAdjudication.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemAdjudicationList.InsertItem(index: Integer; value: TFhirClaimResponseItemAdjudication);
begin
  assert(value is TFhirClaimResponseItemAdjudication);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseItemAdjudicationList.Item(index: Integer): TFhirClaimResponseItemAdjudication;
begin
  result := TFhirClaimResponseItemAdjudication(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemAdjudicationList.Link: TFhirClaimResponseItemAdjudicationList;
begin
  result := TFhirClaimResponseItemAdjudicationList(inherited Link);
end;

procedure TFhirClaimResponseItemAdjudicationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseItemAdjudicationList.SetItemByIndex(index: Integer; value: TFhirClaimResponseItemAdjudication);
begin
  assert(value is TFhirClaimResponseItemAdjudication);
  FhirClaimResponseItemAdjudications[index] := value;
end;

procedure TFhirClaimResponseItemAdjudicationList.SetItemN(index: Integer; value: TFhirClaimResponseItemAdjudication);
begin
  assert(value is TFhirClaimResponseItemAdjudication);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseItemDetail }

constructor TFhirClaimResponseItemDetail.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseItemDetail.Destroy;
begin
  FSequenceLinkId.free;
  FAdjudicationList.Free;
  FSubDetailList.Free;
  inherited;
end;

procedure TFhirClaimResponseItemDetail.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceLinkIdElement := TFhirClaimResponseItemDetail(oSource).sequenceLinkIdElement.Clone;
  if (TFhirClaimResponseItemDetail(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirClaimResponseItemDetailAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirClaimResponseItemDetail(oSource).FAdjudicationList);
  end;
  if (TFhirClaimResponseItemDetail(oSource).FSubDetailList = nil) then
  begin
    FSubDetailList.free;
    FSubDetailList := nil;
  end
  else
  begin
    if FSubDetailList = nil then
      FSubDetailList := TFhirClaimResponseItemDetailSubDetailList.Create;
    FSubDetailList.Assign(TFhirClaimResponseItemDetail(oSource).FSubDetailList);
  end;
end;

procedure TFhirClaimResponseItemDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequenceLinkId') Then
     list.add(self.link, 'sequenceLinkId', FSequenceLinkId.Link);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
  if (child_name = 'subDetail') Then
    list.addAll(self, 'subDetail', FSubDetailList);
end;

procedure TFhirClaimResponseItemDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequenceLinkId', 'positiveInt', false, TFhirPositiveInt, FSequenceLinkId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'adjudication', '', true, TFhirClaimResponseItemDetailAdjudication, FAdjudicationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'subDetail', '', true, TFhirClaimResponseItemDetailSubDetail, FSubDetailList.Link)){3};
end;

function TFhirClaimResponseItemDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequenceLinkId') then
  begin
    SequenceLinkIdElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirClaimResponseItemDetailAdjudication){2a};
    result := propValue;
  end
  else if (propName = 'subDetail') then
  begin
    SubDetailList.add(propValue as TFhirClaimResponseItemDetailSubDetail){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseItemDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirClaimResponseItemDetailAdjudication){2a}
  else if (propName = 'subDetail') then SubDetailList.insertItem(index, propValue as TFhirClaimResponseItemDetailSubDetail){2a}
  else inherited;
end;

function TFhirClaimResponseItemDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequenceLinkId') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'adjudication') then result := AdjudicationList.new(){2}
  else if (propName = 'subDetail') then result := SubDetailList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseItemDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequenceLinkId') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := ''
  else if (propName = 'subDetail') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseItemDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequenceLinkId') then SequenceLinkIdElement := nil
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value) {2}
  else if (propName = 'subDetail') then deletePropertyValue('subDetail', SubDetailList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseItemDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequenceLinkId') then SequenceLinkIdElement := asPositiveInt(new){5b}
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new) {2}
  else if (propName = 'subDetail') then replacePropertyValue('subDetail', SubDetailList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseItemDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'adjudication') then AdjudicationList.move(source, destination){2a}
  else if (propName = 'subDetail') then SubDetailList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseItemDetail.fhirType : string;
begin
  result := 'detail';
end;

function TFhirClaimResponseItemDetail.Link : TFhirClaimResponseItemDetail;
begin
  result := TFhirClaimResponseItemDetail(inherited Link);
end;

function TFhirClaimResponseItemDetail.Clone : TFhirClaimResponseItemDetail;
begin
  result := TFhirClaimResponseItemDetail(inherited Clone);
end;

function TFhirClaimResponseItemDetail.equals(other : TObject) : boolean;
var
  o : TFhirClaimResponseItemDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseItemDetail)) then
    result := false
  else
  begin
    o := TFhirClaimResponseItemDetail(other);
    result := compareDeep(sequenceLinkIdElement, o.sequenceLinkIdElement, true) and
      compareDeep(adjudicationList, o.adjudicationList, true) and compareDeep(subDetailList, o.subDetailList, true);
  end;
end;

function TFhirClaimResponseItemDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequenceLinkId) and isEmptyProp(FadjudicationList) and isEmptyProp(FsubDetailList);
end;

procedure TFhirClaimResponseItemDetail.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequenceLinkId');
  fields.add('adjudication');
  fields.add('subDetail');
end;

{ TFhirClaimResponseItemDetail }

Procedure TFhirClaimResponseItemDetail.SetSequenceLinkId(value : TFhirPositiveInt);
begin
  FSequenceLinkId.free;
  FSequenceLinkId := value;
end;

Function TFhirClaimResponseItemDetail.GetSequenceLinkIdST : String;
begin
  if FSequenceLinkId = nil then
    result := ''
  else
    result := FSequenceLinkId.value;
end;

Procedure TFhirClaimResponseItemDetail.SetSequenceLinkIdST(value : String);
begin
  if value <> '' then
  begin
    if FSequenceLinkId = nil then
      FSequenceLinkId := TFhirPositiveInt.create;
    FSequenceLinkId.value := value
  end
  else if FSequenceLinkId <> nil then
    FSequenceLinkId.value := '';
end;

Function TFhirClaimResponseItemDetail.GetAdjudicationList : TFhirClaimResponseItemDetailAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirClaimResponseItemDetailAdjudicationList.Create;
  result := FAdjudicationList;
end;

Function TFhirClaimResponseItemDetail.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

Function TFhirClaimResponseItemDetail.GetSubDetailList : TFhirClaimResponseItemDetailSubDetailList;
begin
  if FSubDetailList = nil then
    FSubDetailList := TFhirClaimResponseItemDetailSubDetailList.Create;
  result := FSubDetailList;
end;

Function TFhirClaimResponseItemDetail.GetHasSubDetailList : boolean;
begin
  result := (FSubDetailList <> nil) and (FSubDetailList.count > 0);
end;

function TFhirClaimResponseItemDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequenceLinkId.sizeInBytes);
  inc(result, FadjudicationList.sizeInBytes);
  inc(result, FsubDetailList.sizeInBytes);
end;

{ TFhirClaimResponseItemDetailListEnumerator }

Constructor TFhirClaimResponseItemDetailListEnumerator.Create(list : TFhirClaimResponseItemDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseItemDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseItemDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseItemDetailListEnumerator.GetCurrent : TFhirClaimResponseItemDetail;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseItemDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseItemDetailList }
procedure TFhirClaimResponseItemDetailList.AddItem(value: TFhirClaimResponseItemDetail);
begin
  assert(value.ClassName = 'TFhirClaimResponseItemDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseItemDetail');
  add(value);
end;

function TFhirClaimResponseItemDetailList.Append: TFhirClaimResponseItemDetail;
begin
  result := TFhirClaimResponseItemDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemDetailList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseItemDetailList.GetEnumerator : TFhirClaimResponseItemDetailListEnumerator;
begin
  result := TFhirClaimResponseItemDetailListEnumerator.Create(self.link);
end;

function TFhirClaimResponseItemDetailList.Clone: TFhirClaimResponseItemDetailList;
begin
  result := TFhirClaimResponseItemDetailList(inherited Clone);
end;

function TFhirClaimResponseItemDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseItemDetailList.GetItemN(index: Integer): TFhirClaimResponseItemDetail;
begin
  result := TFhirClaimResponseItemDetail(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseItemDetail;
end;
function TFhirClaimResponseItemDetailList.IndexOf(value: TFhirClaimResponseItemDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseItemDetailList.Insert(index: Integer): TFhirClaimResponseItemDetail;
begin
  result := TFhirClaimResponseItemDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemDetailList.InsertItem(index: Integer; value: TFhirClaimResponseItemDetail);
begin
  assert(value is TFhirClaimResponseItemDetail);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseItemDetailList.Item(index: Integer): TFhirClaimResponseItemDetail;
begin
  result := TFhirClaimResponseItemDetail(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemDetailList.Link: TFhirClaimResponseItemDetailList;
begin
  result := TFhirClaimResponseItemDetailList(inherited Link);
end;

procedure TFhirClaimResponseItemDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseItemDetailList.SetItemByIndex(index: Integer; value: TFhirClaimResponseItemDetail);
begin
  assert(value is TFhirClaimResponseItemDetail);
  FhirClaimResponseItemDetails[index] := value;
end;

procedure TFhirClaimResponseItemDetailList.SetItemN(index: Integer; value: TFhirClaimResponseItemDetail);
begin
  assert(value is TFhirClaimResponseItemDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseItemDetailAdjudication }

constructor TFhirClaimResponseItemDetailAdjudication.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseItemDetailAdjudication.Destroy;
begin
  FCode.free;
  FAmount.free;
  FValue.free;
  inherited;
end;

procedure TFhirClaimResponseItemDetailAdjudication.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirClaimResponseItemDetailAdjudication(oSource).code.Clone;
  amount := TFhirClaimResponseItemDetailAdjudication(oSource).amount.Clone;
  valueElement := TFhirClaimResponseItemDetailAdjudication(oSource).valueElement.Clone;
end;

procedure TFhirClaimResponseItemDetailAdjudication.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirClaimResponseItemDetailAdjudication.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'Coding', false, TFhirCoding, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amount', 'Quantity', false, TFhirQuantity, FAmount.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value', 'decimal', false, TFhirDecimal, FValue.Link));{2}
end;

function TFhirClaimResponseItemDetailAdjudication.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseItemDetailAdjudication.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimResponseItemDetailAdjudication.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCoding.create(){4b}
  else if (propName = 'amount') then result := TFhirQuantity.create(){4b}
  else if (propName = 'value') then result := TFhirDecimal.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseItemDetailAdjudication.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'Coding'
  else if (propName = 'amount') then result := 'Quantity'
  else if (propName = 'value') then result := 'decimal'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseItemDetailAdjudication.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseItemDetailAdjudication.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCoding{4}
  else if (propName = 'amount') then AmountElement := new as TFhirQuantity{4}
  else if (propName = 'value') then ValueElement := asDecimal(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseItemDetailAdjudication.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseItemDetailAdjudication.fhirType : string;
begin
  result := 'adjudication';
end;

function TFhirClaimResponseItemDetailAdjudication.Link : TFhirClaimResponseItemDetailAdjudication;
begin
  result := TFhirClaimResponseItemDetailAdjudication(inherited Link);
end;

function TFhirClaimResponseItemDetailAdjudication.Clone : TFhirClaimResponseItemDetailAdjudication;
begin
  result := TFhirClaimResponseItemDetailAdjudication(inherited Clone);
end;

function TFhirClaimResponseItemDetailAdjudication.equals(other : TObject) : boolean;
var
  o : TFhirClaimResponseItemDetailAdjudication;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseItemDetailAdjudication)) then
    result := false
  else
  begin
    o := TFhirClaimResponseItemDetailAdjudication(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(amountElement, o.amountElement, true) and
      compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirClaimResponseItemDetailAdjudication.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FAmount) and isEmptyProp(FValue);
end;

procedure TFhirClaimResponseItemDetailAdjudication.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('amount');
  fields.add('value');
end;

{ TFhirClaimResponseItemDetailAdjudication }

Procedure TFhirClaimResponseItemDetailAdjudication.SetCode(value : TFhirCoding);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirClaimResponseItemDetailAdjudication.SetAmount(value : TFhirQuantity);
begin
  FAmount.free;
  FAmount := value;
end;

Procedure TFhirClaimResponseItemDetailAdjudication.SetValue(value : TFhirDecimal);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirClaimResponseItemDetailAdjudication.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

Procedure TFhirClaimResponseItemDetailAdjudication.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirDecimal.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

function TFhirClaimResponseItemDetailAdjudication.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirClaimResponseItemDetailAdjudicationListEnumerator }

Constructor TFhirClaimResponseItemDetailAdjudicationListEnumerator.Create(list : TFhirClaimResponseItemDetailAdjudicationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseItemDetailAdjudicationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseItemDetailAdjudicationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseItemDetailAdjudicationListEnumerator.GetCurrent : TFhirClaimResponseItemDetailAdjudication;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseItemDetailAdjudicationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseItemDetailAdjudicationList }
procedure TFhirClaimResponseItemDetailAdjudicationList.AddItem(value: TFhirClaimResponseItemDetailAdjudication);
begin
  assert(value.ClassName = 'TFhirClaimResponseItemDetailAdjudication', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseItemDetailAdjudication');
  add(value);
end;

function TFhirClaimResponseItemDetailAdjudicationList.Append: TFhirClaimResponseItemDetailAdjudication;
begin
  result := TFhirClaimResponseItemDetailAdjudication.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemDetailAdjudicationList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseItemDetailAdjudicationList.GetEnumerator : TFhirClaimResponseItemDetailAdjudicationListEnumerator;
begin
  result := TFhirClaimResponseItemDetailAdjudicationListEnumerator.Create(self.link);
end;

function TFhirClaimResponseItemDetailAdjudicationList.Clone: TFhirClaimResponseItemDetailAdjudicationList;
begin
  result := TFhirClaimResponseItemDetailAdjudicationList(inherited Clone);
end;

function TFhirClaimResponseItemDetailAdjudicationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseItemDetailAdjudicationList.GetItemN(index: Integer): TFhirClaimResponseItemDetailAdjudication;
begin
  result := TFhirClaimResponseItemDetailAdjudication(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemDetailAdjudicationList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseItemDetailAdjudication;
end;
function TFhirClaimResponseItemDetailAdjudicationList.IndexOf(value: TFhirClaimResponseItemDetailAdjudication): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseItemDetailAdjudicationList.Insert(index: Integer): TFhirClaimResponseItemDetailAdjudication;
begin
  result := TFhirClaimResponseItemDetailAdjudication.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemDetailAdjudicationList.InsertItem(index: Integer; value: TFhirClaimResponseItemDetailAdjudication);
begin
  assert(value is TFhirClaimResponseItemDetailAdjudication);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseItemDetailAdjudicationList.Item(index: Integer): TFhirClaimResponseItemDetailAdjudication;
begin
  result := TFhirClaimResponseItemDetailAdjudication(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemDetailAdjudicationList.Link: TFhirClaimResponseItemDetailAdjudicationList;
begin
  result := TFhirClaimResponseItemDetailAdjudicationList(inherited Link);
end;

procedure TFhirClaimResponseItemDetailAdjudicationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseItemDetailAdjudicationList.SetItemByIndex(index: Integer; value: TFhirClaimResponseItemDetailAdjudication);
begin
  assert(value is TFhirClaimResponseItemDetailAdjudication);
  FhirClaimResponseItemDetailAdjudications[index] := value;
end;

procedure TFhirClaimResponseItemDetailAdjudicationList.SetItemN(index: Integer; value: TFhirClaimResponseItemDetailAdjudication);
begin
  assert(value is TFhirClaimResponseItemDetailAdjudication);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseItemDetailSubDetail }

constructor TFhirClaimResponseItemDetailSubDetail.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseItemDetailSubDetail.Destroy;
begin
  FSequenceLinkId.free;
  FAdjudicationList.Free;
  inherited;
end;

procedure TFhirClaimResponseItemDetailSubDetail.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceLinkIdElement := TFhirClaimResponseItemDetailSubDetail(oSource).sequenceLinkIdElement.Clone;
  if (TFhirClaimResponseItemDetailSubDetail(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirClaimResponseItemDetailSubDetailAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirClaimResponseItemDetailSubDetail(oSource).FAdjudicationList);
  end;
end;

procedure TFhirClaimResponseItemDetailSubDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequenceLinkId') Then
     list.add(self.link, 'sequenceLinkId', FSequenceLinkId.Link);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
end;

procedure TFhirClaimResponseItemDetailSubDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequenceLinkId', 'positiveInt', false, TFhirPositiveInt, FSequenceLinkId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'adjudication', '', true, TFhirClaimResponseItemDetailSubDetailAdjudication, FAdjudicationList.Link)){3};
end;

function TFhirClaimResponseItemDetailSubDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequenceLinkId') then
  begin
    SequenceLinkIdElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirClaimResponseItemDetailSubDetailAdjudication){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseItemDetailSubDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirClaimResponseItemDetailSubDetailAdjudication){2a}
  else inherited;
end;

function TFhirClaimResponseItemDetailSubDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequenceLinkId') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'adjudication') then result := AdjudicationList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseItemDetailSubDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequenceLinkId') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseItemDetailSubDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequenceLinkId') then SequenceLinkIdElement := nil
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseItemDetailSubDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequenceLinkId') then SequenceLinkIdElement := asPositiveInt(new){5b}
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseItemDetailSubDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'adjudication') then AdjudicationList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseItemDetailSubDetail.fhirType : string;
begin
  result := 'subDetail';
end;

function TFhirClaimResponseItemDetailSubDetail.Link : TFhirClaimResponseItemDetailSubDetail;
begin
  result := TFhirClaimResponseItemDetailSubDetail(inherited Link);
end;

function TFhirClaimResponseItemDetailSubDetail.Clone : TFhirClaimResponseItemDetailSubDetail;
begin
  result := TFhirClaimResponseItemDetailSubDetail(inherited Clone);
end;

function TFhirClaimResponseItemDetailSubDetail.equals(other : TObject) : boolean;
var
  o : TFhirClaimResponseItemDetailSubDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseItemDetailSubDetail)) then
    result := false
  else
  begin
    o := TFhirClaimResponseItemDetailSubDetail(other);
    result := compareDeep(sequenceLinkIdElement, o.sequenceLinkIdElement, true) and
      compareDeep(adjudicationList, o.adjudicationList, true);
  end;
end;

function TFhirClaimResponseItemDetailSubDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequenceLinkId) and isEmptyProp(FadjudicationList);
end;

procedure TFhirClaimResponseItemDetailSubDetail.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequenceLinkId');
  fields.add('adjudication');
end;

{ TFhirClaimResponseItemDetailSubDetail }

Procedure TFhirClaimResponseItemDetailSubDetail.SetSequenceLinkId(value : TFhirPositiveInt);
begin
  FSequenceLinkId.free;
  FSequenceLinkId := value;
end;

Function TFhirClaimResponseItemDetailSubDetail.GetSequenceLinkIdST : String;
begin
  if FSequenceLinkId = nil then
    result := ''
  else
    result := FSequenceLinkId.value;
end;

Procedure TFhirClaimResponseItemDetailSubDetail.SetSequenceLinkIdST(value : String);
begin
  if value <> '' then
  begin
    if FSequenceLinkId = nil then
      FSequenceLinkId := TFhirPositiveInt.create;
    FSequenceLinkId.value := value
  end
  else if FSequenceLinkId <> nil then
    FSequenceLinkId.value := '';
end;

Function TFhirClaimResponseItemDetailSubDetail.GetAdjudicationList : TFhirClaimResponseItemDetailSubDetailAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirClaimResponseItemDetailSubDetailAdjudicationList.Create;
  result := FAdjudicationList;
end;

Function TFhirClaimResponseItemDetailSubDetail.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

function TFhirClaimResponseItemDetailSubDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequenceLinkId.sizeInBytes);
  inc(result, FadjudicationList.sizeInBytes);
end;

{ TFhirClaimResponseItemDetailSubDetailListEnumerator }

Constructor TFhirClaimResponseItemDetailSubDetailListEnumerator.Create(list : TFhirClaimResponseItemDetailSubDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseItemDetailSubDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseItemDetailSubDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseItemDetailSubDetailListEnumerator.GetCurrent : TFhirClaimResponseItemDetailSubDetail;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseItemDetailSubDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseItemDetailSubDetailList }
procedure TFhirClaimResponseItemDetailSubDetailList.AddItem(value: TFhirClaimResponseItemDetailSubDetail);
begin
  assert(value.ClassName = 'TFhirClaimResponseItemDetailSubDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseItemDetailSubDetail');
  add(value);
end;

function TFhirClaimResponseItemDetailSubDetailList.Append: TFhirClaimResponseItemDetailSubDetail;
begin
  result := TFhirClaimResponseItemDetailSubDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemDetailSubDetailList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseItemDetailSubDetailList.GetEnumerator : TFhirClaimResponseItemDetailSubDetailListEnumerator;
begin
  result := TFhirClaimResponseItemDetailSubDetailListEnumerator.Create(self.link);
end;

function TFhirClaimResponseItemDetailSubDetailList.Clone: TFhirClaimResponseItemDetailSubDetailList;
begin
  result := TFhirClaimResponseItemDetailSubDetailList(inherited Clone);
end;

function TFhirClaimResponseItemDetailSubDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseItemDetailSubDetailList.GetItemN(index: Integer): TFhirClaimResponseItemDetailSubDetail;
begin
  result := TFhirClaimResponseItemDetailSubDetail(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemDetailSubDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseItemDetailSubDetail;
end;
function TFhirClaimResponseItemDetailSubDetailList.IndexOf(value: TFhirClaimResponseItemDetailSubDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseItemDetailSubDetailList.Insert(index: Integer): TFhirClaimResponseItemDetailSubDetail;
begin
  result := TFhirClaimResponseItemDetailSubDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemDetailSubDetailList.InsertItem(index: Integer; value: TFhirClaimResponseItemDetailSubDetail);
begin
  assert(value is TFhirClaimResponseItemDetailSubDetail);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseItemDetailSubDetailList.Item(index: Integer): TFhirClaimResponseItemDetailSubDetail;
begin
  result := TFhirClaimResponseItemDetailSubDetail(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemDetailSubDetailList.Link: TFhirClaimResponseItemDetailSubDetailList;
begin
  result := TFhirClaimResponseItemDetailSubDetailList(inherited Link);
end;

procedure TFhirClaimResponseItemDetailSubDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseItemDetailSubDetailList.SetItemByIndex(index: Integer; value: TFhirClaimResponseItemDetailSubDetail);
begin
  assert(value is TFhirClaimResponseItemDetailSubDetail);
  FhirClaimResponseItemDetailSubDetails[index] := value;
end;

procedure TFhirClaimResponseItemDetailSubDetailList.SetItemN(index: Integer; value: TFhirClaimResponseItemDetailSubDetail);
begin
  assert(value is TFhirClaimResponseItemDetailSubDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseItemDetailSubDetailAdjudication }

constructor TFhirClaimResponseItemDetailSubDetailAdjudication.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseItemDetailSubDetailAdjudication.Destroy;
begin
  FCode.free;
  FAmount.free;
  FValue.free;
  inherited;
end;

procedure TFhirClaimResponseItemDetailSubDetailAdjudication.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirClaimResponseItemDetailSubDetailAdjudication(oSource).code.Clone;
  amount := TFhirClaimResponseItemDetailSubDetailAdjudication(oSource).amount.Clone;
  valueElement := TFhirClaimResponseItemDetailSubDetailAdjudication(oSource).valueElement.Clone;
end;

procedure TFhirClaimResponseItemDetailSubDetailAdjudication.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirClaimResponseItemDetailSubDetailAdjudication.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'Coding', false, TFhirCoding, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amount', 'Quantity', false, TFhirQuantity, FAmount.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value', 'decimal', false, TFhirDecimal, FValue.Link));{2}
end;

function TFhirClaimResponseItemDetailSubDetailAdjudication.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseItemDetailSubDetailAdjudication.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimResponseItemDetailSubDetailAdjudication.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCoding.create(){4b}
  else if (propName = 'amount') then result := TFhirQuantity.create(){4b}
  else if (propName = 'value') then result := TFhirDecimal.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseItemDetailSubDetailAdjudication.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'Coding'
  else if (propName = 'amount') then result := 'Quantity'
  else if (propName = 'value') then result := 'decimal'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseItemDetailSubDetailAdjudication.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseItemDetailSubDetailAdjudication.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCoding{4}
  else if (propName = 'amount') then AmountElement := new as TFhirQuantity{4}
  else if (propName = 'value') then ValueElement := asDecimal(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseItemDetailSubDetailAdjudication.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseItemDetailSubDetailAdjudication.fhirType : string;
begin
  result := 'adjudication';
end;

function TFhirClaimResponseItemDetailSubDetailAdjudication.Link : TFhirClaimResponseItemDetailSubDetailAdjudication;
begin
  result := TFhirClaimResponseItemDetailSubDetailAdjudication(inherited Link);
end;

function TFhirClaimResponseItemDetailSubDetailAdjudication.Clone : TFhirClaimResponseItemDetailSubDetailAdjudication;
begin
  result := TFhirClaimResponseItemDetailSubDetailAdjudication(inherited Clone);
end;

function TFhirClaimResponseItemDetailSubDetailAdjudication.equals(other : TObject) : boolean;
var
  o : TFhirClaimResponseItemDetailSubDetailAdjudication;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseItemDetailSubDetailAdjudication)) then
    result := false
  else
  begin
    o := TFhirClaimResponseItemDetailSubDetailAdjudication(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(amountElement, o.amountElement, true) and
      compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirClaimResponseItemDetailSubDetailAdjudication.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FAmount) and isEmptyProp(FValue);
end;

procedure TFhirClaimResponseItemDetailSubDetailAdjudication.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('amount');
  fields.add('value');
end;

{ TFhirClaimResponseItemDetailSubDetailAdjudication }

Procedure TFhirClaimResponseItemDetailSubDetailAdjudication.SetCode(value : TFhirCoding);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirClaimResponseItemDetailSubDetailAdjudication.SetAmount(value : TFhirQuantity);
begin
  FAmount.free;
  FAmount := value;
end;

Procedure TFhirClaimResponseItemDetailSubDetailAdjudication.SetValue(value : TFhirDecimal);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirClaimResponseItemDetailSubDetailAdjudication.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

Procedure TFhirClaimResponseItemDetailSubDetailAdjudication.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirDecimal.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

function TFhirClaimResponseItemDetailSubDetailAdjudication.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirClaimResponseItemDetailSubDetailAdjudicationListEnumerator }

Constructor TFhirClaimResponseItemDetailSubDetailAdjudicationListEnumerator.Create(list : TFhirClaimResponseItemDetailSubDetailAdjudicationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseItemDetailSubDetailAdjudicationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseItemDetailSubDetailAdjudicationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseItemDetailSubDetailAdjudicationListEnumerator.GetCurrent : TFhirClaimResponseItemDetailSubDetailAdjudication;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseItemDetailSubDetailAdjudicationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseItemDetailSubDetailAdjudicationList }
procedure TFhirClaimResponseItemDetailSubDetailAdjudicationList.AddItem(value: TFhirClaimResponseItemDetailSubDetailAdjudication);
begin
  assert(value.ClassName = 'TFhirClaimResponseItemDetailSubDetailAdjudication', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseItemDetailSubDetailAdjudication');
  add(value);
end;

function TFhirClaimResponseItemDetailSubDetailAdjudicationList.Append: TFhirClaimResponseItemDetailSubDetailAdjudication;
begin
  result := TFhirClaimResponseItemDetailSubDetailAdjudication.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemDetailSubDetailAdjudicationList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseItemDetailSubDetailAdjudicationList.GetEnumerator : TFhirClaimResponseItemDetailSubDetailAdjudicationListEnumerator;
begin
  result := TFhirClaimResponseItemDetailSubDetailAdjudicationListEnumerator.Create(self.link);
end;

function TFhirClaimResponseItemDetailSubDetailAdjudicationList.Clone: TFhirClaimResponseItemDetailSubDetailAdjudicationList;
begin
  result := TFhirClaimResponseItemDetailSubDetailAdjudicationList(inherited Clone);
end;

function TFhirClaimResponseItemDetailSubDetailAdjudicationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseItemDetailSubDetailAdjudicationList.GetItemN(index: Integer): TFhirClaimResponseItemDetailSubDetailAdjudication;
begin
  result := TFhirClaimResponseItemDetailSubDetailAdjudication(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemDetailSubDetailAdjudicationList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseItemDetailSubDetailAdjudication;
end;
function TFhirClaimResponseItemDetailSubDetailAdjudicationList.IndexOf(value: TFhirClaimResponseItemDetailSubDetailAdjudication): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseItemDetailSubDetailAdjudicationList.Insert(index: Integer): TFhirClaimResponseItemDetailSubDetailAdjudication;
begin
  result := TFhirClaimResponseItemDetailSubDetailAdjudication.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemDetailSubDetailAdjudicationList.InsertItem(index: Integer; value: TFhirClaimResponseItemDetailSubDetailAdjudication);
begin
  assert(value is TFhirClaimResponseItemDetailSubDetailAdjudication);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseItemDetailSubDetailAdjudicationList.Item(index: Integer): TFhirClaimResponseItemDetailSubDetailAdjudication;
begin
  result := TFhirClaimResponseItemDetailSubDetailAdjudication(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemDetailSubDetailAdjudicationList.Link: TFhirClaimResponseItemDetailSubDetailAdjudicationList;
begin
  result := TFhirClaimResponseItemDetailSubDetailAdjudicationList(inherited Link);
end;

procedure TFhirClaimResponseItemDetailSubDetailAdjudicationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseItemDetailSubDetailAdjudicationList.SetItemByIndex(index: Integer; value: TFhirClaimResponseItemDetailSubDetailAdjudication);
begin
  assert(value is TFhirClaimResponseItemDetailSubDetailAdjudication);
  FhirClaimResponseItemDetailSubDetailAdjudications[index] := value;
end;

procedure TFhirClaimResponseItemDetailSubDetailAdjudicationList.SetItemN(index: Integer; value: TFhirClaimResponseItemDetailSubDetailAdjudication);
begin
  assert(value is TFhirClaimResponseItemDetailSubDetailAdjudication);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseAddItem }

constructor TFhirClaimResponseAddItem.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseAddItem.Destroy;
begin
  FSequenceLinkIdList.Free;
  FService.free;
  FFee.free;
  FNoteNumberLinkIdList.Free;
  FAdjudicationList.Free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirClaimResponseAddItem.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirClaimResponseAddItem(oSource).FSequenceLinkIdList = nil) then
  begin
    FSequenceLinkIdList.free;
    FSequenceLinkIdList := nil;
  end
  else
  begin
    if FSequenceLinkIdList = nil then
      FSequenceLinkIdList := TFhirPositiveIntList.Create;
    FSequenceLinkIdList.Assign(TFhirClaimResponseAddItem(oSource).FSequenceLinkIdList);
  end;
  service := TFhirClaimResponseAddItem(oSource).service.Clone;
  fee := TFhirClaimResponseAddItem(oSource).fee.Clone;
  if (TFhirClaimResponseAddItem(oSource).FNoteNumberLinkIdList = nil) then
  begin
    FNoteNumberLinkIdList.free;
    FNoteNumberLinkIdList := nil;
  end
  else
  begin
    if FNoteNumberLinkIdList = nil then
      FNoteNumberLinkIdList := TFhirPositiveIntList.Create;
    FNoteNumberLinkIdList.Assign(TFhirClaimResponseAddItem(oSource).FNoteNumberLinkIdList);
  end;
  if (TFhirClaimResponseAddItem(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirClaimResponseAddItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirClaimResponseAddItem(oSource).FAdjudicationList);
  end;
  if (TFhirClaimResponseAddItem(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirClaimResponseAddItemDetailList.Create;
    FDetailList.Assign(TFhirClaimResponseAddItem(oSource).FDetailList);
  end;
end;

procedure TFhirClaimResponseAddItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequenceLinkId') Then
    list.addAll(self, 'sequenceLinkId', FSequenceLinkIdList);
  if (child_name = 'service') Then
     list.add(self.link, 'service', FService.Link);
  if (child_name = 'fee') Then
     list.add(self.link, 'fee', FFee.Link);
  if (child_name = 'noteNumberLinkId') Then
    list.addAll(self, 'noteNumberLinkId', FNoteNumberLinkIdList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
end;

procedure TFhirClaimResponseAddItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequenceLinkId', 'positiveInt', true, TFhirPositiveInt, FSequenceLinkIdList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'service', 'Coding', false, TFhirCoding, FService.Link));{2}
  oList.add(TFHIRProperty.create(self, 'fee', 'Quantity', false, TFhirQuantity, FFee.Link));{2}
  oList.add(TFHIRProperty.create(self, 'noteNumberLinkId', 'positiveInt', true, TFhirPositiveInt, FNoteNumberLinkIdList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'adjudication', '', true, TFhirClaimResponseAddItemAdjudication, FAdjudicationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'detail', '', true, TFhirClaimResponseAddItemDetail, FDetailList.Link)){3};
end;

function TFhirClaimResponseAddItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequenceLinkId') then
  begin
    SequenceLinkIdList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'service') then
  begin
    Service := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'fee') then
  begin
    Fee := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'noteNumberLinkId') then
  begin
    NoteNumberLinkIdList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirClaimResponseAddItemAdjudication){2a};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirClaimResponseAddItemDetail){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseAddItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'sequenceLinkId') then SequenceLinkIdList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'noteNumberLinkId') then NoteNumberLinkIdList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirClaimResponseAddItemAdjudication){2a}
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirClaimResponseAddItemDetail){2a}
  else inherited;
end;

function TFhirClaimResponseAddItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequenceLinkId') then result := SequenceLinkIdList.new(){2}
  else if (propName = 'service') then result := TFhirCoding.create(){4b}
  else if (propName = 'fee') then result := TFhirQuantity.create(){4b}
  else if (propName = 'noteNumberLinkId') then result := NoteNumberLinkIdList.new(){2}
  else if (propName = 'adjudication') then result := AdjudicationList.new(){2}
  else if (propName = 'detail') then result := DetailList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseAddItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequenceLinkId') then result := 'positiveInt'
  else if (propName = 'service') then result := 'Coding'
  else if (propName = 'fee') then result := 'Quantity'
  else if (propName = 'noteNumberLinkId') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := ''
  else if (propName = 'detail') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseAddItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequenceLinkId') then deletePropertyValue('sequenceLinkId', SequenceLinkIdList, value) {2}
  else if (propName = 'service') then ServiceElement := nil
  else if (propName = 'fee') then FeeElement := nil
  else if (propName = 'noteNumberLinkId') then deletePropertyValue('noteNumberLinkId', NoteNumberLinkIdList, value) {2}
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value) {2}
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseAddItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequenceLinkId') then replacePropertyValue('sequenceLinkId', SequenceLinkIdList, existing, new) {2}
  else if (propName = 'service') then ServiceElement := new as TFhirCoding{4}
  else if (propName = 'fee') then FeeElement := new as TFhirQuantity{4}
  else if (propName = 'noteNumberLinkId') then replacePropertyValue('noteNumberLinkId', NoteNumberLinkIdList, existing, new) {2}
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new) {2}
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseAddItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'sequenceLinkId') then SequenceLinkIdList.move(source, destination){2}
  else if (propName = 'noteNumberLinkId') then NoteNumberLinkIdList.move(source, destination){2}
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination){2a}
  else if (propName = 'detail') then DetailList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseAddItem.fhirType : string;
begin
  result := 'addItem';
end;

function TFhirClaimResponseAddItem.Link : TFhirClaimResponseAddItem;
begin
  result := TFhirClaimResponseAddItem(inherited Link);
end;

function TFhirClaimResponseAddItem.Clone : TFhirClaimResponseAddItem;
begin
  result := TFhirClaimResponseAddItem(inherited Clone);
end;

function TFhirClaimResponseAddItem.equals(other : TObject) : boolean;
var
  o : TFhirClaimResponseAddItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseAddItem)) then
    result := false
  else
  begin
    o := TFhirClaimResponseAddItem(other);
    result := compareDeep(sequenceLinkIdList, o.sequenceLinkIdList, true) and compareDeep(serviceElement, o.serviceElement, true) and
      compareDeep(feeElement, o.feeElement, true) and compareDeep(noteNumberLinkIdList, o.noteNumberLinkIdList, true) and
      compareDeep(adjudicationList, o.adjudicationList, true) and compareDeep(detailList, o.detailList, true);
  end;
end;

function TFhirClaimResponseAddItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FsequenceLinkIdList) and isEmptyProp(FService) and isEmptyProp(FFee) and isEmptyProp(FnoteNumberLinkIdList) and isEmptyProp(FadjudicationList) and isEmptyProp(FdetailList);
end;

procedure TFhirClaimResponseAddItem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequenceLinkId');
  fields.add('service');
  fields.add('fee');
  fields.add('noteNumberLinkId');
  fields.add('adjudication');
  fields.add('detail');
end;

{ TFhirClaimResponseAddItem }

Function TFhirClaimResponseAddItem.GetSequenceLinkIdList : TFhirPositiveIntList;
begin
  if FSequenceLinkIdList = nil then
    FSequenceLinkIdList := TFhirPositiveIntList.Create;
  result := FSequenceLinkIdList;
end;

Function TFhirClaimResponseAddItem.GetHasSequenceLinkIdList : boolean;
begin
  result := (FSequenceLinkIdList <> nil) and (FSequenceLinkIdList.count > 0);
end;

Procedure TFhirClaimResponseAddItem.SetService(value : TFhirCoding);
begin
  FService.free;
  FService := value;
end;

Procedure TFhirClaimResponseAddItem.SetFee(value : TFhirQuantity);
begin
  FFee.free;
  FFee := value;
end;

Function TFhirClaimResponseAddItem.GetNoteNumberLinkIdList : TFhirPositiveIntList;
begin
  if FNoteNumberLinkIdList = nil then
    FNoteNumberLinkIdList := TFhirPositiveIntList.Create;
  result := FNoteNumberLinkIdList;
end;

Function TFhirClaimResponseAddItem.GetHasNoteNumberLinkIdList : boolean;
begin
  result := (FNoteNumberLinkIdList <> nil) and (FNoteNumberLinkIdList.count > 0);
end;

Function TFhirClaimResponseAddItem.GetAdjudicationList : TFhirClaimResponseAddItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirClaimResponseAddItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

Function TFhirClaimResponseAddItem.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

Function TFhirClaimResponseAddItem.GetDetailList : TFhirClaimResponseAddItemDetailList;
begin
  if FDetailList = nil then
    FDetailList := TFhirClaimResponseAddItemDetailList.Create;
  result := FDetailList;
end;

Function TFhirClaimResponseAddItem.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

function TFhirClaimResponseAddItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FsequenceLinkIdList.sizeInBytes);
  inc(result, FService.sizeInBytes);
  inc(result, FFee.sizeInBytes);
  inc(result, FnoteNumberLinkIdList.sizeInBytes);
  inc(result, FadjudicationList.sizeInBytes);
  inc(result, FdetailList.sizeInBytes);
end;

{ TFhirClaimResponseAddItemListEnumerator }

Constructor TFhirClaimResponseAddItemListEnumerator.Create(list : TFhirClaimResponseAddItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseAddItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseAddItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseAddItemListEnumerator.GetCurrent : TFhirClaimResponseAddItem;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseAddItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseAddItemList }
procedure TFhirClaimResponseAddItemList.AddItem(value: TFhirClaimResponseAddItem);
begin
  assert(value.ClassName = 'TFhirClaimResponseAddItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseAddItem');
  add(value);
end;

function TFhirClaimResponseAddItemList.Append: TFhirClaimResponseAddItem;
begin
  result := TFhirClaimResponseAddItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseAddItemList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseAddItemList.GetEnumerator : TFhirClaimResponseAddItemListEnumerator;
begin
  result := TFhirClaimResponseAddItemListEnumerator.Create(self.link);
end;

function TFhirClaimResponseAddItemList.Clone: TFhirClaimResponseAddItemList;
begin
  result := TFhirClaimResponseAddItemList(inherited Clone);
end;

function TFhirClaimResponseAddItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseAddItemList.GetItemN(index: Integer): TFhirClaimResponseAddItem;
begin
  result := TFhirClaimResponseAddItem(ObjectByIndex[index]);
end;

function TFhirClaimResponseAddItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseAddItem;
end;
function TFhirClaimResponseAddItemList.IndexOf(value: TFhirClaimResponseAddItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseAddItemList.Insert(index: Integer): TFhirClaimResponseAddItem;
begin
  result := TFhirClaimResponseAddItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseAddItemList.InsertItem(index: Integer; value: TFhirClaimResponseAddItem);
begin
  assert(value is TFhirClaimResponseAddItem);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseAddItemList.Item(index: Integer): TFhirClaimResponseAddItem;
begin
  result := TFhirClaimResponseAddItem(ObjectByIndex[index]);
end;

function TFhirClaimResponseAddItemList.Link: TFhirClaimResponseAddItemList;
begin
  result := TFhirClaimResponseAddItemList(inherited Link);
end;

procedure TFhirClaimResponseAddItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseAddItemList.SetItemByIndex(index: Integer; value: TFhirClaimResponseAddItem);
begin
  assert(value is TFhirClaimResponseAddItem);
  FhirClaimResponseAddItems[index] := value;
end;

procedure TFhirClaimResponseAddItemList.SetItemN(index: Integer; value: TFhirClaimResponseAddItem);
begin
  assert(value is TFhirClaimResponseAddItem);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseAddItemAdjudication }

constructor TFhirClaimResponseAddItemAdjudication.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseAddItemAdjudication.Destroy;
begin
  FCode.free;
  FAmount.free;
  FValue.free;
  inherited;
end;

procedure TFhirClaimResponseAddItemAdjudication.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirClaimResponseAddItemAdjudication(oSource).code.Clone;
  amount := TFhirClaimResponseAddItemAdjudication(oSource).amount.Clone;
  valueElement := TFhirClaimResponseAddItemAdjudication(oSource).valueElement.Clone;
end;

procedure TFhirClaimResponseAddItemAdjudication.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirClaimResponseAddItemAdjudication.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'Coding', false, TFhirCoding, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amount', 'Quantity', false, TFhirQuantity, FAmount.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value', 'decimal', false, TFhirDecimal, FValue.Link));{2}
end;

function TFhirClaimResponseAddItemAdjudication.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseAddItemAdjudication.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimResponseAddItemAdjudication.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCoding.create(){4b}
  else if (propName = 'amount') then result := TFhirQuantity.create(){4b}
  else if (propName = 'value') then result := TFhirDecimal.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseAddItemAdjudication.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'Coding'
  else if (propName = 'amount') then result := 'Quantity'
  else if (propName = 'value') then result := 'decimal'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseAddItemAdjudication.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseAddItemAdjudication.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCoding{4}
  else if (propName = 'amount') then AmountElement := new as TFhirQuantity{4}
  else if (propName = 'value') then ValueElement := asDecimal(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseAddItemAdjudication.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseAddItemAdjudication.fhirType : string;
begin
  result := 'adjudication';
end;

function TFhirClaimResponseAddItemAdjudication.Link : TFhirClaimResponseAddItemAdjudication;
begin
  result := TFhirClaimResponseAddItemAdjudication(inherited Link);
end;

function TFhirClaimResponseAddItemAdjudication.Clone : TFhirClaimResponseAddItemAdjudication;
begin
  result := TFhirClaimResponseAddItemAdjudication(inherited Clone);
end;

function TFhirClaimResponseAddItemAdjudication.equals(other : TObject) : boolean;
var
  o : TFhirClaimResponseAddItemAdjudication;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseAddItemAdjudication)) then
    result := false
  else
  begin
    o := TFhirClaimResponseAddItemAdjudication(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(amountElement, o.amountElement, true) and
      compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirClaimResponseAddItemAdjudication.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FAmount) and isEmptyProp(FValue);
end;

procedure TFhirClaimResponseAddItemAdjudication.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('amount');
  fields.add('value');
end;

{ TFhirClaimResponseAddItemAdjudication }

Procedure TFhirClaimResponseAddItemAdjudication.SetCode(value : TFhirCoding);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirClaimResponseAddItemAdjudication.SetAmount(value : TFhirQuantity);
begin
  FAmount.free;
  FAmount := value;
end;

Procedure TFhirClaimResponseAddItemAdjudication.SetValue(value : TFhirDecimal);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirClaimResponseAddItemAdjudication.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

Procedure TFhirClaimResponseAddItemAdjudication.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirDecimal.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

function TFhirClaimResponseAddItemAdjudication.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirClaimResponseAddItemAdjudicationListEnumerator }

Constructor TFhirClaimResponseAddItemAdjudicationListEnumerator.Create(list : TFhirClaimResponseAddItemAdjudicationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseAddItemAdjudicationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseAddItemAdjudicationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseAddItemAdjudicationListEnumerator.GetCurrent : TFhirClaimResponseAddItemAdjudication;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseAddItemAdjudicationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseAddItemAdjudicationList }
procedure TFhirClaimResponseAddItemAdjudicationList.AddItem(value: TFhirClaimResponseAddItemAdjudication);
begin
  assert(value.ClassName = 'TFhirClaimResponseAddItemAdjudication', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseAddItemAdjudication');
  add(value);
end;

function TFhirClaimResponseAddItemAdjudicationList.Append: TFhirClaimResponseAddItemAdjudication;
begin
  result := TFhirClaimResponseAddItemAdjudication.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseAddItemAdjudicationList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseAddItemAdjudicationList.GetEnumerator : TFhirClaimResponseAddItemAdjudicationListEnumerator;
begin
  result := TFhirClaimResponseAddItemAdjudicationListEnumerator.Create(self.link);
end;

function TFhirClaimResponseAddItemAdjudicationList.Clone: TFhirClaimResponseAddItemAdjudicationList;
begin
  result := TFhirClaimResponseAddItemAdjudicationList(inherited Clone);
end;

function TFhirClaimResponseAddItemAdjudicationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseAddItemAdjudicationList.GetItemN(index: Integer): TFhirClaimResponseAddItemAdjudication;
begin
  result := TFhirClaimResponseAddItemAdjudication(ObjectByIndex[index]);
end;

function TFhirClaimResponseAddItemAdjudicationList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseAddItemAdjudication;
end;
function TFhirClaimResponseAddItemAdjudicationList.IndexOf(value: TFhirClaimResponseAddItemAdjudication): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseAddItemAdjudicationList.Insert(index: Integer): TFhirClaimResponseAddItemAdjudication;
begin
  result := TFhirClaimResponseAddItemAdjudication.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseAddItemAdjudicationList.InsertItem(index: Integer; value: TFhirClaimResponseAddItemAdjudication);
begin
  assert(value is TFhirClaimResponseAddItemAdjudication);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseAddItemAdjudicationList.Item(index: Integer): TFhirClaimResponseAddItemAdjudication;
begin
  result := TFhirClaimResponseAddItemAdjudication(ObjectByIndex[index]);
end;

function TFhirClaimResponseAddItemAdjudicationList.Link: TFhirClaimResponseAddItemAdjudicationList;
begin
  result := TFhirClaimResponseAddItemAdjudicationList(inherited Link);
end;

procedure TFhirClaimResponseAddItemAdjudicationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseAddItemAdjudicationList.SetItemByIndex(index: Integer; value: TFhirClaimResponseAddItemAdjudication);
begin
  assert(value is TFhirClaimResponseAddItemAdjudication);
  FhirClaimResponseAddItemAdjudications[index] := value;
end;

procedure TFhirClaimResponseAddItemAdjudicationList.SetItemN(index: Integer; value: TFhirClaimResponseAddItemAdjudication);
begin
  assert(value is TFhirClaimResponseAddItemAdjudication);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseAddItemDetail }

constructor TFhirClaimResponseAddItemDetail.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseAddItemDetail.Destroy;
begin
  FService.free;
  FFee.free;
  FAdjudicationList.Free;
  inherited;
end;

procedure TFhirClaimResponseAddItemDetail.Assign(oSource : TFslObject);
begin
  inherited;
  service := TFhirClaimResponseAddItemDetail(oSource).service.Clone;
  fee := TFhirClaimResponseAddItemDetail(oSource).fee.Clone;
  if (TFhirClaimResponseAddItemDetail(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirClaimResponseAddItemDetailAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirClaimResponseAddItemDetail(oSource).FAdjudicationList);
  end;
end;

procedure TFhirClaimResponseAddItemDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'service') Then
     list.add(self.link, 'service', FService.Link);
  if (child_name = 'fee') Then
     list.add(self.link, 'fee', FFee.Link);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
end;

procedure TFhirClaimResponseAddItemDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'service', 'Coding', false, TFhirCoding, FService.Link));{2}
  oList.add(TFHIRProperty.create(self, 'fee', 'Quantity', false, TFhirQuantity, FFee.Link));{2}
  oList.add(TFHIRProperty.create(self, 'adjudication', '', true, TFhirClaimResponseAddItemDetailAdjudication, FAdjudicationList.Link)){3};
end;

function TFhirClaimResponseAddItemDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'service') then
  begin
    Service := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'fee') then
  begin
    Fee := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirClaimResponseAddItemDetailAdjudication){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseAddItemDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirClaimResponseAddItemDetailAdjudication){2a}
  else inherited;
end;

function TFhirClaimResponseAddItemDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'service') then result := TFhirCoding.create(){4b}
  else if (propName = 'fee') then result := TFhirQuantity.create(){4b}
  else if (propName = 'adjudication') then result := AdjudicationList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseAddItemDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'service') then result := 'Coding'
  else if (propName = 'fee') then result := 'Quantity'
  else if (propName = 'adjudication') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseAddItemDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'service') then ServiceElement := nil
  else if (propName = 'fee') then FeeElement := nil
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseAddItemDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'service') then ServiceElement := new as TFhirCoding{4}
  else if (propName = 'fee') then FeeElement := new as TFhirQuantity{4}
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseAddItemDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'adjudication') then AdjudicationList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseAddItemDetail.fhirType : string;
begin
  result := 'detail';
end;

function TFhirClaimResponseAddItemDetail.Link : TFhirClaimResponseAddItemDetail;
begin
  result := TFhirClaimResponseAddItemDetail(inherited Link);
end;

function TFhirClaimResponseAddItemDetail.Clone : TFhirClaimResponseAddItemDetail;
begin
  result := TFhirClaimResponseAddItemDetail(inherited Clone);
end;

function TFhirClaimResponseAddItemDetail.equals(other : TObject) : boolean;
var
  o : TFhirClaimResponseAddItemDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseAddItemDetail)) then
    result := false
  else
  begin
    o := TFhirClaimResponseAddItemDetail(other);
    result := compareDeep(serviceElement, o.serviceElement, true) and compareDeep(feeElement, o.feeElement, true) and
      compareDeep(adjudicationList, o.adjudicationList, true);
  end;
end;

function TFhirClaimResponseAddItemDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FService) and isEmptyProp(FFee) and isEmptyProp(FadjudicationList);
end;

procedure TFhirClaimResponseAddItemDetail.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('service');
  fields.add('fee');
  fields.add('adjudication');
end;

{ TFhirClaimResponseAddItemDetail }

Procedure TFhirClaimResponseAddItemDetail.SetService(value : TFhirCoding);
begin
  FService.free;
  FService := value;
end;

Procedure TFhirClaimResponseAddItemDetail.SetFee(value : TFhirQuantity);
begin
  FFee.free;
  FFee := value;
end;

Function TFhirClaimResponseAddItemDetail.GetAdjudicationList : TFhirClaimResponseAddItemDetailAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirClaimResponseAddItemDetailAdjudicationList.Create;
  result := FAdjudicationList;
end;

Function TFhirClaimResponseAddItemDetail.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

function TFhirClaimResponseAddItemDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FService.sizeInBytes);
  inc(result, FFee.sizeInBytes);
  inc(result, FadjudicationList.sizeInBytes);
end;

{ TFhirClaimResponseAddItemDetailListEnumerator }

Constructor TFhirClaimResponseAddItemDetailListEnumerator.Create(list : TFhirClaimResponseAddItemDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseAddItemDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseAddItemDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseAddItemDetailListEnumerator.GetCurrent : TFhirClaimResponseAddItemDetail;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseAddItemDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseAddItemDetailList }
procedure TFhirClaimResponseAddItemDetailList.AddItem(value: TFhirClaimResponseAddItemDetail);
begin
  assert(value.ClassName = 'TFhirClaimResponseAddItemDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseAddItemDetail');
  add(value);
end;

function TFhirClaimResponseAddItemDetailList.Append: TFhirClaimResponseAddItemDetail;
begin
  result := TFhirClaimResponseAddItemDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseAddItemDetailList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseAddItemDetailList.GetEnumerator : TFhirClaimResponseAddItemDetailListEnumerator;
begin
  result := TFhirClaimResponseAddItemDetailListEnumerator.Create(self.link);
end;

function TFhirClaimResponseAddItemDetailList.Clone: TFhirClaimResponseAddItemDetailList;
begin
  result := TFhirClaimResponseAddItemDetailList(inherited Clone);
end;

function TFhirClaimResponseAddItemDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseAddItemDetailList.GetItemN(index: Integer): TFhirClaimResponseAddItemDetail;
begin
  result := TFhirClaimResponseAddItemDetail(ObjectByIndex[index]);
end;

function TFhirClaimResponseAddItemDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseAddItemDetail;
end;
function TFhirClaimResponseAddItemDetailList.IndexOf(value: TFhirClaimResponseAddItemDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseAddItemDetailList.Insert(index: Integer): TFhirClaimResponseAddItemDetail;
begin
  result := TFhirClaimResponseAddItemDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseAddItemDetailList.InsertItem(index: Integer; value: TFhirClaimResponseAddItemDetail);
begin
  assert(value is TFhirClaimResponseAddItemDetail);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseAddItemDetailList.Item(index: Integer): TFhirClaimResponseAddItemDetail;
begin
  result := TFhirClaimResponseAddItemDetail(ObjectByIndex[index]);
end;

function TFhirClaimResponseAddItemDetailList.Link: TFhirClaimResponseAddItemDetailList;
begin
  result := TFhirClaimResponseAddItemDetailList(inherited Link);
end;

procedure TFhirClaimResponseAddItemDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseAddItemDetailList.SetItemByIndex(index: Integer; value: TFhirClaimResponseAddItemDetail);
begin
  assert(value is TFhirClaimResponseAddItemDetail);
  FhirClaimResponseAddItemDetails[index] := value;
end;

procedure TFhirClaimResponseAddItemDetailList.SetItemN(index: Integer; value: TFhirClaimResponseAddItemDetail);
begin
  assert(value is TFhirClaimResponseAddItemDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseAddItemDetailAdjudication }

constructor TFhirClaimResponseAddItemDetailAdjudication.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseAddItemDetailAdjudication.Destroy;
begin
  FCode.free;
  FAmount.free;
  FValue.free;
  inherited;
end;

procedure TFhirClaimResponseAddItemDetailAdjudication.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirClaimResponseAddItemDetailAdjudication(oSource).code.Clone;
  amount := TFhirClaimResponseAddItemDetailAdjudication(oSource).amount.Clone;
  valueElement := TFhirClaimResponseAddItemDetailAdjudication(oSource).valueElement.Clone;
end;

procedure TFhirClaimResponseAddItemDetailAdjudication.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirClaimResponseAddItemDetailAdjudication.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'Coding', false, TFhirCoding, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amount', 'Quantity', false, TFhirQuantity, FAmount.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value', 'decimal', false, TFhirDecimal, FValue.Link));{2}
end;

function TFhirClaimResponseAddItemDetailAdjudication.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseAddItemDetailAdjudication.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimResponseAddItemDetailAdjudication.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCoding.create(){4b}
  else if (propName = 'amount') then result := TFhirQuantity.create(){4b}
  else if (propName = 'value') then result := TFhirDecimal.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseAddItemDetailAdjudication.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'Coding'
  else if (propName = 'amount') then result := 'Quantity'
  else if (propName = 'value') then result := 'decimal'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseAddItemDetailAdjudication.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseAddItemDetailAdjudication.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCoding{4}
  else if (propName = 'amount') then AmountElement := new as TFhirQuantity{4}
  else if (propName = 'value') then ValueElement := asDecimal(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseAddItemDetailAdjudication.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseAddItemDetailAdjudication.fhirType : string;
begin
  result := 'adjudication';
end;

function TFhirClaimResponseAddItemDetailAdjudication.Link : TFhirClaimResponseAddItemDetailAdjudication;
begin
  result := TFhirClaimResponseAddItemDetailAdjudication(inherited Link);
end;

function TFhirClaimResponseAddItemDetailAdjudication.Clone : TFhirClaimResponseAddItemDetailAdjudication;
begin
  result := TFhirClaimResponseAddItemDetailAdjudication(inherited Clone);
end;

function TFhirClaimResponseAddItemDetailAdjudication.equals(other : TObject) : boolean;
var
  o : TFhirClaimResponseAddItemDetailAdjudication;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseAddItemDetailAdjudication)) then
    result := false
  else
  begin
    o := TFhirClaimResponseAddItemDetailAdjudication(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(amountElement, o.amountElement, true) and
      compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirClaimResponseAddItemDetailAdjudication.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FAmount) and isEmptyProp(FValue);
end;

procedure TFhirClaimResponseAddItemDetailAdjudication.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('amount');
  fields.add('value');
end;

{ TFhirClaimResponseAddItemDetailAdjudication }

Procedure TFhirClaimResponseAddItemDetailAdjudication.SetCode(value : TFhirCoding);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirClaimResponseAddItemDetailAdjudication.SetAmount(value : TFhirQuantity);
begin
  FAmount.free;
  FAmount := value;
end;

Procedure TFhirClaimResponseAddItemDetailAdjudication.SetValue(value : TFhirDecimal);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirClaimResponseAddItemDetailAdjudication.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

Procedure TFhirClaimResponseAddItemDetailAdjudication.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirDecimal.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

function TFhirClaimResponseAddItemDetailAdjudication.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirClaimResponseAddItemDetailAdjudicationListEnumerator }

Constructor TFhirClaimResponseAddItemDetailAdjudicationListEnumerator.Create(list : TFhirClaimResponseAddItemDetailAdjudicationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseAddItemDetailAdjudicationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseAddItemDetailAdjudicationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseAddItemDetailAdjudicationListEnumerator.GetCurrent : TFhirClaimResponseAddItemDetailAdjudication;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseAddItemDetailAdjudicationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseAddItemDetailAdjudicationList }
procedure TFhirClaimResponseAddItemDetailAdjudicationList.AddItem(value: TFhirClaimResponseAddItemDetailAdjudication);
begin
  assert(value.ClassName = 'TFhirClaimResponseAddItemDetailAdjudication', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseAddItemDetailAdjudication');
  add(value);
end;

function TFhirClaimResponseAddItemDetailAdjudicationList.Append: TFhirClaimResponseAddItemDetailAdjudication;
begin
  result := TFhirClaimResponseAddItemDetailAdjudication.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseAddItemDetailAdjudicationList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseAddItemDetailAdjudicationList.GetEnumerator : TFhirClaimResponseAddItemDetailAdjudicationListEnumerator;
begin
  result := TFhirClaimResponseAddItemDetailAdjudicationListEnumerator.Create(self.link);
end;

function TFhirClaimResponseAddItemDetailAdjudicationList.Clone: TFhirClaimResponseAddItemDetailAdjudicationList;
begin
  result := TFhirClaimResponseAddItemDetailAdjudicationList(inherited Clone);
end;

function TFhirClaimResponseAddItemDetailAdjudicationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseAddItemDetailAdjudicationList.GetItemN(index: Integer): TFhirClaimResponseAddItemDetailAdjudication;
begin
  result := TFhirClaimResponseAddItemDetailAdjudication(ObjectByIndex[index]);
end;

function TFhirClaimResponseAddItemDetailAdjudicationList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseAddItemDetailAdjudication;
end;
function TFhirClaimResponseAddItemDetailAdjudicationList.IndexOf(value: TFhirClaimResponseAddItemDetailAdjudication): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseAddItemDetailAdjudicationList.Insert(index: Integer): TFhirClaimResponseAddItemDetailAdjudication;
begin
  result := TFhirClaimResponseAddItemDetailAdjudication.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseAddItemDetailAdjudicationList.InsertItem(index: Integer; value: TFhirClaimResponseAddItemDetailAdjudication);
begin
  assert(value is TFhirClaimResponseAddItemDetailAdjudication);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseAddItemDetailAdjudicationList.Item(index: Integer): TFhirClaimResponseAddItemDetailAdjudication;
begin
  result := TFhirClaimResponseAddItemDetailAdjudication(ObjectByIndex[index]);
end;

function TFhirClaimResponseAddItemDetailAdjudicationList.Link: TFhirClaimResponseAddItemDetailAdjudicationList;
begin
  result := TFhirClaimResponseAddItemDetailAdjudicationList(inherited Link);
end;

procedure TFhirClaimResponseAddItemDetailAdjudicationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseAddItemDetailAdjudicationList.SetItemByIndex(index: Integer; value: TFhirClaimResponseAddItemDetailAdjudication);
begin
  assert(value is TFhirClaimResponseAddItemDetailAdjudication);
  FhirClaimResponseAddItemDetailAdjudications[index] := value;
end;

procedure TFhirClaimResponseAddItemDetailAdjudicationList.SetItemN(index: Integer; value: TFhirClaimResponseAddItemDetailAdjudication);
begin
  assert(value is TFhirClaimResponseAddItemDetailAdjudication);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseError }

constructor TFhirClaimResponseError.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseError.Destroy;
begin
  FSequenceLinkId.free;
  FDetailSequenceLinkId.free;
  FSubdetailSequenceLinkId.free;
  FCode.free;
  inherited;
end;

procedure TFhirClaimResponseError.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceLinkIdElement := TFhirClaimResponseError(oSource).sequenceLinkIdElement.Clone;
  detailSequenceLinkIdElement := TFhirClaimResponseError(oSource).detailSequenceLinkIdElement.Clone;
  subdetailSequenceLinkIdElement := TFhirClaimResponseError(oSource).subdetailSequenceLinkIdElement.Clone;
  code := TFhirClaimResponseError(oSource).code.Clone;
end;

procedure TFhirClaimResponseError.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequenceLinkId') Then
     list.add(self.link, 'sequenceLinkId', FSequenceLinkId.Link);
  if (child_name = 'detailSequenceLinkId') Then
     list.add(self.link, 'detailSequenceLinkId', FDetailSequenceLinkId.Link);
  if (child_name = 'subdetailSequenceLinkId') Then
     list.add(self.link, 'subdetailSequenceLinkId', FSubdetailSequenceLinkId.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
end;

procedure TFhirClaimResponseError.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequenceLinkId', 'positiveInt', false, TFhirPositiveInt, FSequenceLinkId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'detailSequenceLinkId', 'positiveInt', false, TFhirPositiveInt, FDetailSequenceLinkId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subdetailSequenceLinkId', 'positiveInt', false, TFhirPositiveInt, FSubdetailSequenceLinkId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'Coding', false, TFhirCoding, FCode.Link));{2}
end;

function TFhirClaimResponseError.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequenceLinkId') then
  begin
    SequenceLinkIdElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'detailSequenceLinkId') then
  begin
    DetailSequenceLinkIdElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'subdetailSequenceLinkId') then
  begin
    SubdetailSequenceLinkIdElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseError.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimResponseError.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequenceLinkId') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'detailSequenceLinkId') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'subdetailSequenceLinkId') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'code') then result := TFhirCoding.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseError.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequenceLinkId') then result := 'positiveInt'
  else if (propName = 'detailSequenceLinkId') then result := 'positiveInt'
  else if (propName = 'subdetailSequenceLinkId') then result := 'positiveInt'
  else if (propName = 'code') then result := 'Coding'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseError.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequenceLinkId') then SequenceLinkIdElement := nil
  else if (propName = 'detailSequenceLinkId') then DetailSequenceLinkIdElement := nil
  else if (propName = 'subdetailSequenceLinkId') then SubdetailSequenceLinkIdElement := nil
  else if (propName = 'code') then CodeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseError.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequenceLinkId') then SequenceLinkIdElement := asPositiveInt(new){5b}
  else if (propName = 'detailSequenceLinkId') then DetailSequenceLinkIdElement := asPositiveInt(new){5b}
  else if (propName = 'subdetailSequenceLinkId') then SubdetailSequenceLinkIdElement := asPositiveInt(new){5b}
  else if (propName = 'code') then CodeElement := new as TFhirCoding{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseError.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseError.fhirType : string;
begin
  result := 'error';
end;

function TFhirClaimResponseError.Link : TFhirClaimResponseError;
begin
  result := TFhirClaimResponseError(inherited Link);
end;

function TFhirClaimResponseError.Clone : TFhirClaimResponseError;
begin
  result := TFhirClaimResponseError(inherited Clone);
end;

function TFhirClaimResponseError.equals(other : TObject) : boolean;
var
  o : TFhirClaimResponseError;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseError)) then
    result := false
  else
  begin
    o := TFhirClaimResponseError(other);
    result := compareDeep(sequenceLinkIdElement, o.sequenceLinkIdElement, true) and
      compareDeep(detailSequenceLinkIdElement, o.detailSequenceLinkIdElement, true) and
      compareDeep(subdetailSequenceLinkIdElement, o.subdetailSequenceLinkIdElement, true) and
      compareDeep(codeElement, o.codeElement, true);
  end;
end;

function TFhirClaimResponseError.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequenceLinkId) and isEmptyProp(FDetailSequenceLinkId) and isEmptyProp(FSubdetailSequenceLinkId) and isEmptyProp(FCode);
end;

procedure TFhirClaimResponseError.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequenceLinkId');
  fields.add('detailSequenceLinkId');
  fields.add('subdetailSequenceLinkId');
  fields.add('code');
end;

{ TFhirClaimResponseError }

Procedure TFhirClaimResponseError.SetSequenceLinkId(value : TFhirPositiveInt);
begin
  FSequenceLinkId.free;
  FSequenceLinkId := value;
end;

Function TFhirClaimResponseError.GetSequenceLinkIdST : String;
begin
  if FSequenceLinkId = nil then
    result := ''
  else
    result := FSequenceLinkId.value;
end;

Procedure TFhirClaimResponseError.SetSequenceLinkIdST(value : String);
begin
  if value <> '' then
  begin
    if FSequenceLinkId = nil then
      FSequenceLinkId := TFhirPositiveInt.create;
    FSequenceLinkId.value := value
  end
  else if FSequenceLinkId <> nil then
    FSequenceLinkId.value := '';
end;

Procedure TFhirClaimResponseError.SetDetailSequenceLinkId(value : TFhirPositiveInt);
begin
  FDetailSequenceLinkId.free;
  FDetailSequenceLinkId := value;
end;

Function TFhirClaimResponseError.GetDetailSequenceLinkIdST : String;
begin
  if FDetailSequenceLinkId = nil then
    result := ''
  else
    result := FDetailSequenceLinkId.value;
end;

Procedure TFhirClaimResponseError.SetDetailSequenceLinkIdST(value : String);
begin
  if value <> '' then
  begin
    if FDetailSequenceLinkId = nil then
      FDetailSequenceLinkId := TFhirPositiveInt.create;
    FDetailSequenceLinkId.value := value
  end
  else if FDetailSequenceLinkId <> nil then
    FDetailSequenceLinkId.value := '';
end;

Procedure TFhirClaimResponseError.SetSubdetailSequenceLinkId(value : TFhirPositiveInt);
begin
  FSubdetailSequenceLinkId.free;
  FSubdetailSequenceLinkId := value;
end;

Function TFhirClaimResponseError.GetSubdetailSequenceLinkIdST : String;
begin
  if FSubdetailSequenceLinkId = nil then
    result := ''
  else
    result := FSubdetailSequenceLinkId.value;
end;

Procedure TFhirClaimResponseError.SetSubdetailSequenceLinkIdST(value : String);
begin
  if value <> '' then
  begin
    if FSubdetailSequenceLinkId = nil then
      FSubdetailSequenceLinkId := TFhirPositiveInt.create;
    FSubdetailSequenceLinkId.value := value
  end
  else if FSubdetailSequenceLinkId <> nil then
    FSubdetailSequenceLinkId.value := '';
end;

Procedure TFhirClaimResponseError.SetCode(value : TFhirCoding);
begin
  FCode.free;
  FCode := value;
end;

function TFhirClaimResponseError.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequenceLinkId.sizeInBytes);
  inc(result, FDetailSequenceLinkId.sizeInBytes);
  inc(result, FSubdetailSequenceLinkId.sizeInBytes);
  inc(result, FCode.sizeInBytes);
end;

{ TFhirClaimResponseErrorListEnumerator }

Constructor TFhirClaimResponseErrorListEnumerator.Create(list : TFhirClaimResponseErrorList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseErrorListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseErrorListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseErrorListEnumerator.GetCurrent : TFhirClaimResponseError;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseErrorListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseErrorList }
procedure TFhirClaimResponseErrorList.AddItem(value: TFhirClaimResponseError);
begin
  assert(value.ClassName = 'TFhirClaimResponseError', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseError');
  add(value);
end;

function TFhirClaimResponseErrorList.Append: TFhirClaimResponseError;
begin
  result := TFhirClaimResponseError.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseErrorList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseErrorList.GetEnumerator : TFhirClaimResponseErrorListEnumerator;
begin
  result := TFhirClaimResponseErrorListEnumerator.Create(self.link);
end;

function TFhirClaimResponseErrorList.Clone: TFhirClaimResponseErrorList;
begin
  result := TFhirClaimResponseErrorList(inherited Clone);
end;

function TFhirClaimResponseErrorList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseErrorList.GetItemN(index: Integer): TFhirClaimResponseError;
begin
  result := TFhirClaimResponseError(ObjectByIndex[index]);
end;

function TFhirClaimResponseErrorList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseError;
end;
function TFhirClaimResponseErrorList.IndexOf(value: TFhirClaimResponseError): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseErrorList.Insert(index: Integer): TFhirClaimResponseError;
begin
  result := TFhirClaimResponseError.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseErrorList.InsertItem(index: Integer; value: TFhirClaimResponseError);
begin
  assert(value is TFhirClaimResponseError);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseErrorList.Item(index: Integer): TFhirClaimResponseError;
begin
  result := TFhirClaimResponseError(ObjectByIndex[index]);
end;

function TFhirClaimResponseErrorList.Link: TFhirClaimResponseErrorList;
begin
  result := TFhirClaimResponseErrorList(inherited Link);
end;

procedure TFhirClaimResponseErrorList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseErrorList.SetItemByIndex(index: Integer; value: TFhirClaimResponseError);
begin
  assert(value is TFhirClaimResponseError);
  FhirClaimResponseErrors[index] := value;
end;

procedure TFhirClaimResponseErrorList.SetItemN(index: Integer; value: TFhirClaimResponseError);
begin
  assert(value is TFhirClaimResponseError);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseNote }

constructor TFhirClaimResponseNote.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseNote.Destroy;
begin
  FNumber.free;
  FType_.free;
  FText.free;
  inherited;
end;

procedure TFhirClaimResponseNote.Assign(oSource : TFslObject);
begin
  inherited;
  numberElement := TFhirClaimResponseNote(oSource).numberElement.Clone;
  type_ := TFhirClaimResponseNote(oSource).type_.Clone;
  textElement := TFhirClaimResponseNote(oSource).textElement.Clone;
end;

procedure TFhirClaimResponseNote.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'number') Then
     list.add(self.link, 'number', FNumber.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
end;

procedure TFhirClaimResponseNote.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'number', 'positiveInt', false, TFhirPositiveInt, FNumber.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', false, TFhirCoding, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));{2}
end;

function TFhirClaimResponseNote.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'number') then
  begin
    NumberElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseNote.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimResponseNote.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'number') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'type') then result := TFhirCoding.create(){4b}
  else if (propName = 'text') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseNote.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'number') then result := 'positiveInt'
  else if (propName = 'type') then result := 'Coding'
  else if (propName = 'text') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseNote.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'number') then NumberElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'text') then TextElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseNote.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'number') then NumberElement := asPositiveInt(new){5b}
  else if (propName = 'type') then Type_Element := new as TFhirCoding{4}
  else if (propName = 'text') then TextElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseNote.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseNote.fhirType : string;
begin
  result := 'note';
end;

function TFhirClaimResponseNote.Link : TFhirClaimResponseNote;
begin
  result := TFhirClaimResponseNote(inherited Link);
end;

function TFhirClaimResponseNote.Clone : TFhirClaimResponseNote;
begin
  result := TFhirClaimResponseNote(inherited Clone);
end;

function TFhirClaimResponseNote.equals(other : TObject) : boolean;
var
  o : TFhirClaimResponseNote;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseNote)) then
    result := false
  else
  begin
    o := TFhirClaimResponseNote(other);
    result := compareDeep(numberElement, o.numberElement, true) and compareDeep(type_Element, o.type_Element, true) and
      compareDeep(textElement, o.textElement, true);
  end;
end;

function TFhirClaimResponseNote.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FNumber) and isEmptyProp(FType_) and isEmptyProp(FText);
end;

procedure TFhirClaimResponseNote.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('number');
  fields.add('type');
  fields.add('text');
end;

{ TFhirClaimResponseNote }

Procedure TFhirClaimResponseNote.SetNumber(value : TFhirPositiveInt);
begin
  FNumber.free;
  FNumber := value;
end;

Function TFhirClaimResponseNote.GetNumberST : String;
begin
  if FNumber = nil then
    result := ''
  else
    result := FNumber.value;
end;

Procedure TFhirClaimResponseNote.SetNumberST(value : String);
begin
  if value <> '' then
  begin
    if FNumber = nil then
      FNumber := TFhirPositiveInt.create;
    FNumber.value := value
  end
  else if FNumber <> nil then
    FNumber.value := '';
end;

Procedure TFhirClaimResponseNote.SetType_(value : TFhirCoding);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirClaimResponseNote.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

Function TFhirClaimResponseNote.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

Procedure TFhirClaimResponseNote.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

function TFhirClaimResponseNote.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FNumber.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FText.sizeInBytes);
end;

{ TFhirClaimResponseNoteListEnumerator }

Constructor TFhirClaimResponseNoteListEnumerator.Create(list : TFhirClaimResponseNoteList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseNoteListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseNoteListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseNoteListEnumerator.GetCurrent : TFhirClaimResponseNote;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseNoteListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseNoteList }
procedure TFhirClaimResponseNoteList.AddItem(value: TFhirClaimResponseNote);
begin
  assert(value.ClassName = 'TFhirClaimResponseNote', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseNote');
  add(value);
end;

function TFhirClaimResponseNoteList.Append: TFhirClaimResponseNote;
begin
  result := TFhirClaimResponseNote.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseNoteList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseNoteList.GetEnumerator : TFhirClaimResponseNoteListEnumerator;
begin
  result := TFhirClaimResponseNoteListEnumerator.Create(self.link);
end;

function TFhirClaimResponseNoteList.Clone: TFhirClaimResponseNoteList;
begin
  result := TFhirClaimResponseNoteList(inherited Clone);
end;

function TFhirClaimResponseNoteList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseNoteList.GetItemN(index: Integer): TFhirClaimResponseNote;
begin
  result := TFhirClaimResponseNote(ObjectByIndex[index]);
end;

function TFhirClaimResponseNoteList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseNote;
end;
function TFhirClaimResponseNoteList.IndexOf(value: TFhirClaimResponseNote): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseNoteList.Insert(index: Integer): TFhirClaimResponseNote;
begin
  result := TFhirClaimResponseNote.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseNoteList.InsertItem(index: Integer; value: TFhirClaimResponseNote);
begin
  assert(value is TFhirClaimResponseNote);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseNoteList.Item(index: Integer): TFhirClaimResponseNote;
begin
  result := TFhirClaimResponseNote(ObjectByIndex[index]);
end;

function TFhirClaimResponseNoteList.Link: TFhirClaimResponseNoteList;
begin
  result := TFhirClaimResponseNoteList(inherited Link);
end;

procedure TFhirClaimResponseNoteList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseNoteList.SetItemByIndex(index: Integer; value: TFhirClaimResponseNote);
begin
  assert(value is TFhirClaimResponseNote);
  FhirClaimResponseNotes[index] := value;
end;

procedure TFhirClaimResponseNoteList.SetItemN(index: Integer; value: TFhirClaimResponseNote);
begin
  assert(value is TFhirClaimResponseNote);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseCoverage }

constructor TFhirClaimResponseCoverage.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseCoverage.Destroy;
begin
  FSequence.free;
  FFocal.free;
  FCoverage.free;
  FBusinessArrangement.free;
  FRelationship.free;
  FPreAuthRefList.Free;
  FClaimResponse.free;
  FOriginalRuleset.free;
  inherited;
end;

procedure TFhirClaimResponseCoverage.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirClaimResponseCoverage(oSource).sequenceElement.Clone;
  focalElement := TFhirClaimResponseCoverage(oSource).focalElement.Clone;
  coverage := TFhirClaimResponseCoverage(oSource).coverage.Clone;
  businessArrangementElement := TFhirClaimResponseCoverage(oSource).businessArrangementElement.Clone;
  relationship := TFhirClaimResponseCoverage(oSource).relationship.Clone;
  if (TFhirClaimResponseCoverage(oSource).FPreAuthRefList = nil) then
  begin
    FPreAuthRefList.free;
    FPreAuthRefList := nil;
  end
  else
  begin
    if FPreAuthRefList = nil then
      FPreAuthRefList := TFhirStringList.Create;
    FPreAuthRefList.Assign(TFhirClaimResponseCoverage(oSource).FPreAuthRefList);
  end;
  claimResponse := TFhirClaimResponseCoverage(oSource).claimResponse.Clone;
  originalRuleset := TFhirClaimResponseCoverage(oSource).originalRuleset.Clone;
end;

procedure TFhirClaimResponseCoverage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'focal') Then
     list.add(self.link, 'focal', FFocal.Link);
  if (child_name = 'coverage') Then
     list.add(self.link, 'coverage', FCoverage.Link);
  if (child_name = 'businessArrangement') Then
     list.add(self.link, 'businessArrangement', FBusinessArrangement.Link);
  if (child_name = 'relationship') Then
     list.add(self.link, 'relationship', FRelationship.Link);
  if (child_name = 'preAuthRef') Then
    list.addAll(self, 'preAuthRef', FPreAuthRefList);
  if (child_name = 'claimResponse') Then
     list.add(self.link, 'claimResponse', FClaimResponse.Link);
  if (child_name = 'originalRuleset') Then
     list.add(self.link, 'originalRuleset', FOriginalRuleset.Link);
end;

procedure TFhirClaimResponseCoverage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'focal', 'boolean', false, TFhirBoolean, FFocal.Link));{2}
  oList.add(TFHIRProperty.create(self, 'coverage', 'Reference(Coverage)', false, TFhirReference{TFhirCoverage}, FCoverage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'businessArrangement', 'string', false, TFhirString, FBusinessArrangement.Link));{2}
  oList.add(TFHIRProperty.create(self, 'relationship', 'Coding', false, TFhirCoding, FRelationship.Link));{2}
  oList.add(TFHIRProperty.create(self, 'preAuthRef', 'string', true, TFhirString, FPreAuthRefList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'claimResponse', 'Reference(ClaimResponse)', false, TFhirReference{TFhirClaimResponse}, FClaimResponse.Link));{2}
  oList.add(TFHIRProperty.create(self, 'originalRuleset', 'Coding', false, TFhirCoding, FOriginalRuleset.Link));{2}
end;

function TFhirClaimResponseCoverage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'focal') then
  begin
    FocalElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'coverage') then
  begin
    Coverage := propValue as TFhirReference{TFhirCoverage}{4b};
    result := propValue;
  end
  else if (propName = 'businessArrangement') then
  begin
    BusinessArrangementElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'relationship') then
  begin
    Relationship := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'preAuthRef') then
  begin
    PreAuthRefList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'claimResponse') then
  begin
    ClaimResponse := propValue as TFhirReference{TFhirClaimResponse}{4b};
    result := propValue;
  end
  else if (propName = 'originalRuleset') then
  begin
    OriginalRuleset := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseCoverage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'preAuthRef') then PreAuthRefList.insertItem(index, asString(propValue)){2}
  else inherited;
end;

function TFhirClaimResponseCoverage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'focal') then result := TFhirBoolean.create() {5b}
  else if (propName = 'coverage') then result := TFhirReference{TFhirCoverage}.create(){4b}
  else if (propName = 'businessArrangement') then result := TFhirString.create() {5b}
  else if (propName = 'relationship') then result := TFhirCoding.create(){4b}
  else if (propName = 'preAuthRef') then result := PreAuthRefList.new(){2}
  else if (propName = 'claimResponse') then result := TFhirReference{TFhirClaimResponse}.create(){4b}
  else if (propName = 'originalRuleset') then result := TFhirCoding.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseCoverage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'focal') then result := 'boolean'
  else if (propName = 'coverage') then result := 'Reference'
  else if (propName = 'businessArrangement') then result := 'string'
  else if (propName = 'relationship') then result := 'Coding'
  else if (propName = 'preAuthRef') then result := 'string'
  else if (propName = 'claimResponse') then result := 'Reference'
  else if (propName = 'originalRuleset') then result := 'Coding'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseCoverage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'focal') then FocalElement := nil
  else if (propName = 'coverage') then CoverageElement := nil
  else if (propName = 'businessArrangement') then BusinessArrangementElement := nil
  else if (propName = 'relationship') then RelationshipElement := nil
  else if (propName = 'preAuthRef') then deletePropertyValue('preAuthRef', PreAuthRefList, value) {2}
  else if (propName = 'claimResponse') then ClaimResponseElement := nil
  else if (propName = 'originalRuleset') then OriginalRulesetElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseCoverage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new){5b}
  else if (propName = 'focal') then FocalElement := asBoolean(new){5b}
  else if (propName = 'coverage') then CoverageElement := new as TFhirReference{TFhirCoverage}{4}
  else if (propName = 'businessArrangement') then BusinessArrangementElement := asString(new){5b}
  else if (propName = 'relationship') then RelationshipElement := new as TFhirCoding{4}
  else if (propName = 'preAuthRef') then replacePropertyValue('preAuthRef', PreAuthRefList, existing, new) {2}
  else if (propName = 'claimResponse') then ClaimResponseElement := new as TFhirReference{TFhirClaimResponse}{4}
  else if (propName = 'originalRuleset') then OriginalRulesetElement := new as TFhirCoding{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseCoverage.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'preAuthRef') then PreAuthRefList.move(source, destination){2}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseCoverage.fhirType : string;
begin
  result := 'coverage';
end;

function TFhirClaimResponseCoverage.Link : TFhirClaimResponseCoverage;
begin
  result := TFhirClaimResponseCoverage(inherited Link);
end;

function TFhirClaimResponseCoverage.Clone : TFhirClaimResponseCoverage;
begin
  result := TFhirClaimResponseCoverage(inherited Clone);
end;

function TFhirClaimResponseCoverage.equals(other : TObject) : boolean;
var
  o : TFhirClaimResponseCoverage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseCoverage)) then
    result := false
  else
  begin
    o := TFhirClaimResponseCoverage(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(focalElement, o.focalElement, true) and
      compareDeep(coverageElement, o.coverageElement, true) and compareDeep(businessArrangementElement, o.businessArrangementElement, true) and
      compareDeep(relationshipElement, o.relationshipElement, true) and compareDeep(preAuthRefList, o.preAuthRefList, true) and
      compareDeep(claimResponseElement, o.claimResponseElement, true) and compareDeep(originalRulesetElement, o.originalRulesetElement, true);
  end;
end;

function TFhirClaimResponseCoverage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FFocal) and isEmptyProp(FCoverage) and isEmptyProp(FBusinessArrangement) and isEmptyProp(FRelationship) and isEmptyProp(FpreAuthRefList) and isEmptyProp(FClaimResponse) and isEmptyProp(FOriginalRuleset);
end;

procedure TFhirClaimResponseCoverage.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('focal');
  fields.add('coverage');
  fields.add('businessArrangement');
  fields.add('relationship');
  fields.add('preAuthRef');
  fields.add('claimResponse');
  fields.add('originalRuleset');
end;

{ TFhirClaimResponseCoverage }

Procedure TFhirClaimResponseCoverage.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirClaimResponseCoverage.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirClaimResponseCoverage.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Procedure TFhirClaimResponseCoverage.SetFocal(value : TFhirBoolean);
begin
  FFocal.free;
  FFocal := value;
end;

Function TFhirClaimResponseCoverage.GetFocalST : Boolean;
begin
  if FFocal = nil then
    result := false
  else
    result := FFocal.value;
end;

Procedure TFhirClaimResponseCoverage.SetFocalST(value : Boolean);
begin
  if FFocal = nil then
    FFocal := TFhirBoolean.create;
  FFocal.value := value
end;

Procedure TFhirClaimResponseCoverage.SetCoverage(value : TFhirReference{TFhirCoverage});
begin
  FCoverage.free;
  FCoverage := value;
end;

Procedure TFhirClaimResponseCoverage.SetBusinessArrangement(value : TFhirString);
begin
  FBusinessArrangement.free;
  FBusinessArrangement := value;
end;

Function TFhirClaimResponseCoverage.GetBusinessArrangementST : String;
begin
  if FBusinessArrangement = nil then
    result := ''
  else
    result := FBusinessArrangement.value;
end;

Procedure TFhirClaimResponseCoverage.SetBusinessArrangementST(value : String);
begin
  if value <> '' then
  begin
    if FBusinessArrangement = nil then
      FBusinessArrangement := TFhirString.create;
    FBusinessArrangement.value := value
  end
  else if FBusinessArrangement <> nil then
    FBusinessArrangement.value := '';
end;

Procedure TFhirClaimResponseCoverage.SetRelationship(value : TFhirCoding);
begin
  FRelationship.free;
  FRelationship := value;
end;

Function TFhirClaimResponseCoverage.GetPreAuthRefList : TFhirStringList;
begin
  if FPreAuthRefList = nil then
    FPreAuthRefList := TFhirStringList.Create;
  result := FPreAuthRefList;
end;

Function TFhirClaimResponseCoverage.GetHasPreAuthRefList : boolean;
begin
  result := (FPreAuthRefList <> nil) and (FPreAuthRefList.count > 0);
end;

Procedure TFhirClaimResponseCoverage.SetClaimResponse(value : TFhirReference{TFhirClaimResponse});
begin
  FClaimResponse.free;
  FClaimResponse := value;
end;

Procedure TFhirClaimResponseCoverage.SetOriginalRuleset(value : TFhirCoding);
begin
  FOriginalRuleset.free;
  FOriginalRuleset := value;
end;

function TFhirClaimResponseCoverage.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FFocal.sizeInBytes);
  inc(result, FCoverage.sizeInBytes);
  inc(result, FBusinessArrangement.sizeInBytes);
  inc(result, FRelationship.sizeInBytes);
  inc(result, FpreAuthRefList.sizeInBytes);
  inc(result, FClaimResponse.sizeInBytes);
  inc(result, FOriginalRuleset.sizeInBytes);
end;

{ TFhirClaimResponseCoverageListEnumerator }

Constructor TFhirClaimResponseCoverageListEnumerator.Create(list : TFhirClaimResponseCoverageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseCoverageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseCoverageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseCoverageListEnumerator.GetCurrent : TFhirClaimResponseCoverage;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseCoverageListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseCoverageList }
procedure TFhirClaimResponseCoverageList.AddItem(value: TFhirClaimResponseCoverage);
begin
  assert(value.ClassName = 'TFhirClaimResponseCoverage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseCoverage');
  add(value);
end;

function TFhirClaimResponseCoverageList.Append: TFhirClaimResponseCoverage;
begin
  result := TFhirClaimResponseCoverage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseCoverageList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseCoverageList.GetEnumerator : TFhirClaimResponseCoverageListEnumerator;
begin
  result := TFhirClaimResponseCoverageListEnumerator.Create(self.link);
end;

function TFhirClaimResponseCoverageList.Clone: TFhirClaimResponseCoverageList;
begin
  result := TFhirClaimResponseCoverageList(inherited Clone);
end;

function TFhirClaimResponseCoverageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseCoverageList.GetItemN(index: Integer): TFhirClaimResponseCoverage;
begin
  result := TFhirClaimResponseCoverage(ObjectByIndex[index]);
end;

function TFhirClaimResponseCoverageList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseCoverage;
end;
function TFhirClaimResponseCoverageList.IndexOf(value: TFhirClaimResponseCoverage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseCoverageList.Insert(index: Integer): TFhirClaimResponseCoverage;
begin
  result := TFhirClaimResponseCoverage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseCoverageList.InsertItem(index: Integer; value: TFhirClaimResponseCoverage);
begin
  assert(value is TFhirClaimResponseCoverage);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseCoverageList.Item(index: Integer): TFhirClaimResponseCoverage;
begin
  result := TFhirClaimResponseCoverage(ObjectByIndex[index]);
end;

function TFhirClaimResponseCoverageList.Link: TFhirClaimResponseCoverageList;
begin
  result := TFhirClaimResponseCoverageList(inherited Link);
end;

procedure TFhirClaimResponseCoverageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseCoverageList.SetItemByIndex(index: Integer; value: TFhirClaimResponseCoverage);
begin
  assert(value is TFhirClaimResponseCoverage);
  FhirClaimResponseCoverages[index] := value;
end;

procedure TFhirClaimResponseCoverageList.SetItemN(index: Integer; value: TFhirClaimResponseCoverage);
begin
  assert(value is TFhirClaimResponseCoverage);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponse }

constructor TFhirClaimResponse.Create;
begin
  inherited;
end;

destructor TFhirClaimResponse.Destroy;
begin
  FIdentifierList.Free;
  FRequest.free;
  FRuleset.free;
  FOriginalRuleset.free;
  FCreated.free;
  FOrganization.free;
  FRequestProvider.free;
  FRequestOrganization.free;
  FOutcome.free;
  FDisposition.free;
  FPayeeType.free;
  FItemList.Free;
  FAddItemList.Free;
  FErrorList.Free;
  FTotalCost.free;
  FUnallocDeductable.free;
  FTotalBenefit.free;
  FPaymentAdjustment.free;
  FPaymentAdjustmentReason.free;
  FPaymentDate.free;
  FPaymentAmount.free;
  FPaymentRef.free;
  FReserved.free;
  FForm.free;
  FNoteList.Free;
  FCoverageList.Free;
  inherited;
end;

function TFhirClaimResponse.GetResourceType : TFhirResourceType;
begin
  result := frtClaimResponse;
end;

procedure TFhirClaimResponse.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirClaimResponse(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirClaimResponse(oSource).FIdentifierList);
  end;
  request := TFhirClaimResponse(oSource).request.Clone;
  ruleset := TFhirClaimResponse(oSource).ruleset.Clone;
  originalRuleset := TFhirClaimResponse(oSource).originalRuleset.Clone;
  createdElement := TFhirClaimResponse(oSource).createdElement.Clone;
  organization := TFhirClaimResponse(oSource).organization.Clone;
  requestProvider := TFhirClaimResponse(oSource).requestProvider.Clone;
  requestOrganization := TFhirClaimResponse(oSource).requestOrganization.Clone;
  FOutcome := TFhirClaimResponse(oSource).FOutcome.Link;
  dispositionElement := TFhirClaimResponse(oSource).dispositionElement.Clone;
  payeeType := TFhirClaimResponse(oSource).payeeType.Clone;
  if (TFhirClaimResponse(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirClaimResponseItemList.Create;
    FItemList.Assign(TFhirClaimResponse(oSource).FItemList);
  end;
  if (TFhirClaimResponse(oSource).FAddItemList = nil) then
  begin
    FAddItemList.free;
    FAddItemList := nil;
  end
  else
  begin
    if FAddItemList = nil then
      FAddItemList := TFhirClaimResponseAddItemList.Create;
    FAddItemList.Assign(TFhirClaimResponse(oSource).FAddItemList);
  end;
  if (TFhirClaimResponse(oSource).FErrorList = nil) then
  begin
    FErrorList.free;
    FErrorList := nil;
  end
  else
  begin
    if FErrorList = nil then
      FErrorList := TFhirClaimResponseErrorList.Create;
    FErrorList.Assign(TFhirClaimResponse(oSource).FErrorList);
  end;
  totalCost := TFhirClaimResponse(oSource).totalCost.Clone;
  unallocDeductable := TFhirClaimResponse(oSource).unallocDeductable.Clone;
  totalBenefit := TFhirClaimResponse(oSource).totalBenefit.Clone;
  paymentAdjustment := TFhirClaimResponse(oSource).paymentAdjustment.Clone;
  paymentAdjustmentReason := TFhirClaimResponse(oSource).paymentAdjustmentReason.Clone;
  paymentDateElement := TFhirClaimResponse(oSource).paymentDateElement.Clone;
  paymentAmount := TFhirClaimResponse(oSource).paymentAmount.Clone;
  paymentRef := TFhirClaimResponse(oSource).paymentRef.Clone;
  reserved := TFhirClaimResponse(oSource).reserved.Clone;
  form := TFhirClaimResponse(oSource).form.Clone;
  if (TFhirClaimResponse(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirClaimResponseNoteList.Create;
    FNoteList.Assign(TFhirClaimResponse(oSource).FNoteList);
  end;
  if (TFhirClaimResponse(oSource).FCoverageList = nil) then
  begin
    FCoverageList.free;
    FCoverageList := nil;
  end
  else
  begin
    if FCoverageList = nil then
      FCoverageList := TFhirClaimResponseCoverageList.Create;
    FCoverageList.Assign(TFhirClaimResponse(oSource).FCoverageList);
  end;
end;

procedure TFhirClaimResponse.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'ruleset') Then
     list.add(self.link, 'ruleset', FRuleset.Link);
  if (child_name = 'originalRuleset') Then
     list.add(self.link, 'originalRuleset', FOriginalRuleset.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'organization') Then
     list.add(self.link, 'organization', FOrganization.Link);
  if (child_name = 'requestProvider') Then
     list.add(self.link, 'requestProvider', FRequestProvider.Link);
  if (child_name = 'requestOrganization') Then
     list.add(self.link, 'requestOrganization', FRequestOrganization.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'disposition') Then
     list.add(self.link, 'disposition', FDisposition.Link);
  if (child_name = 'payeeType') Then
     list.add(self.link, 'payeeType', FPayeeType.Link);
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
  if (child_name = 'addItem') Then
    list.addAll(self, 'addItem', FAddItemList);
  if (child_name = 'error') Then
    list.addAll(self, 'error', FErrorList);
  if (child_name = 'totalCost') Then
     list.add(self.link, 'totalCost', FTotalCost.Link);
  if (child_name = 'unallocDeductable') Then
     list.add(self.link, 'unallocDeductable', FUnallocDeductable.Link);
  if (child_name = 'totalBenefit') Then
     list.add(self.link, 'totalBenefit', FTotalBenefit.Link);
  if (child_name = 'paymentAdjustment') Then
     list.add(self.link, 'paymentAdjustment', FPaymentAdjustment.Link);
  if (child_name = 'paymentAdjustmentReason') Then
     list.add(self.link, 'paymentAdjustmentReason', FPaymentAdjustmentReason.Link);
  if (child_name = 'paymentDate') Then
     list.add(self.link, 'paymentDate', FPaymentDate.Link);
  if (child_name = 'paymentAmount') Then
     list.add(self.link, 'paymentAmount', FPaymentAmount.Link);
  if (child_name = 'paymentRef') Then
     list.add(self.link, 'paymentRef', FPaymentRef.Link);
  if (child_name = 'reserved') Then
     list.add(self.link, 'reserved', FReserved.Link);
  if (child_name = 'form') Then
     list.add(self.link, 'form', FForm.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'coverage') Then
    list.addAll(self, 'coverage', FCoverageList);
end;

procedure TFhirClaimResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'request', 'Reference(Claim)', false, TFhirReference{TFhirClaim}, FRequest.Link));{2}
  oList.add(TFHIRProperty.create(self, 'ruleset', 'Coding', false, TFhirCoding, FRuleset.Link));{2}
  oList.add(TFHIRProperty.create(self, 'originalRuleset', 'Coding', false, TFhirCoding, FOriginalRuleset.Link));{2}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));{2}
  oList.add(TFHIRProperty.create(self, 'organization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FOrganization.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requestProvider', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FRequestProvider.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requestOrganization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FRequestOrganization.Link));{2}
  oList.add(TFHIRProperty.create(self, 'outcome', 'code', false, TFHIREnum, FOutcome.Link));{1}
  oList.add(TFHIRProperty.create(self, 'disposition', 'string', false, TFhirString, FDisposition.Link));{2}
  oList.add(TFHIRProperty.create(self, 'payeeType', 'Coding', false, TFhirCoding, FPayeeType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'item', '', true, TFhirClaimResponseItem, FItemList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'addItem', '', true, TFhirClaimResponseAddItem, FAddItemList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'error', '', true, TFhirClaimResponseError, FErrorList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'totalCost', 'Quantity', false, TFhirQuantity, FTotalCost.Link));{2}
  oList.add(TFHIRProperty.create(self, 'unallocDeductable', 'Quantity', false, TFhirQuantity, FUnallocDeductable.Link));{2}
  oList.add(TFHIRProperty.create(self, 'totalBenefit', 'Quantity', false, TFhirQuantity, FTotalBenefit.Link));{2}
  oList.add(TFHIRProperty.create(self, 'paymentAdjustment', 'Quantity', false, TFhirQuantity, FPaymentAdjustment.Link));{2}
  oList.add(TFHIRProperty.create(self, 'paymentAdjustmentReason', 'Coding', false, TFhirCoding, FPaymentAdjustmentReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'paymentDate', 'date', false, TFhirDate, FPaymentDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'paymentAmount', 'Quantity', false, TFhirQuantity, FPaymentAmount.Link));{2}
  oList.add(TFHIRProperty.create(self, 'paymentRef', 'Identifier', false, TFhirIdentifier, FPaymentRef.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reserved', 'Coding', false, TFhirCoding, FReserved.Link));{2}
  oList.add(TFHIRProperty.create(self, 'form', 'Coding', false, TFhirCoding, FForm.Link));{2}
  oList.add(TFHIRProperty.create(self, 'note', '', true, TFhirClaimResponseNote, FNoteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'coverage', '', true, TFhirClaimResponseCoverage, FCoverageList.Link)){3};
end;

function TFhirClaimResponse.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirReference{TFhirClaim}{4b};
    result := propValue;
  end
  else if (propName = 'ruleset') then
  begin
    Ruleset := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'originalRuleset') then
  begin
    OriginalRuleset := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'organization') then
  begin
    Organization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'requestProvider') then
  begin
    RequestProvider := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'requestOrganization') then
  begin
    RequestOrganization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    OutcomeElement := asEnum(SYSTEMS_TFhirRemittanceOutcomeEnum, CODES_TFhirRemittanceOutcomeEnum, propValue);
    result := propValue
  end
  else if (propName = 'disposition') then
  begin
    DispositionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'payeeType') then
  begin
    PayeeType := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirClaimResponseItem){2a};
    result := propValue;
  end
  else if (propName = 'addItem') then
  begin
    AddItemList.add(propValue as TFhirClaimResponseAddItem){2a};
    result := propValue;
  end
  else if (propName = 'error') then
  begin
    ErrorList.add(propValue as TFhirClaimResponseError){2a};
    result := propValue;
  end
  else if (propName = 'totalCost') then
  begin
    TotalCost := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'unallocDeductable') then
  begin
    UnallocDeductable := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'totalBenefit') then
  begin
    TotalBenefit := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'paymentAdjustment') then
  begin
    PaymentAdjustment := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'paymentAdjustmentReason') then
  begin
    PaymentAdjustmentReason := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'paymentDate') then
  begin
    PaymentDateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'paymentAmount') then
  begin
    PaymentAmount := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'paymentRef') then
  begin
    PaymentRef := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'reserved') then
  begin
    Reserved := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'form') then
  begin
    Form := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirClaimResponseNote){2a};
    result := propValue;
  end
  else if (propName = 'coverage') then
  begin
    CoverageList.add(propValue as TFhirClaimResponseCoverage){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirClaimResponse.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirClaimResponseItem){2a}
  else if (propName = 'addItem') then AddItemList.insertItem(index, propValue as TFhirClaimResponseAddItem){2a}
  else if (propName = 'error') then ErrorList.insertItem(index, propValue as TFhirClaimResponseError){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirClaimResponseNote){2a}
  else if (propName = 'coverage') then CoverageList.insertItem(index, propValue as TFhirClaimResponseCoverage){2a}
  else inherited;
end;

function TFhirClaimResponse.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'request') then result := TFhirReference{TFhirClaim}.create(){4b}
  else if (propName = 'ruleset') then result := TFhirCoding.create(){4b}
  else if (propName = 'originalRuleset') then result := TFhirCoding.create(){4b}
  else if (propName = 'created') then result := TFhirDateTime.create() {5b}
  else if (propName = 'organization') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'requestProvider') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'requestOrganization') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'disposition') then result := TFhirString.create() {5b}
  else if (propName = 'payeeType') then result := TFhirCoding.create(){4b}
  else if (propName = 'item') then result := ItemList.new(){2}
  else if (propName = 'addItem') then result := AddItemList.new(){2}
  else if (propName = 'error') then result := ErrorList.new(){2}
  else if (propName = 'totalCost') then result := TFhirQuantity.create(){4b}
  else if (propName = 'unallocDeductable') then result := TFhirQuantity.create(){4b}
  else if (propName = 'totalBenefit') then result := TFhirQuantity.create(){4b}
  else if (propName = 'paymentAdjustment') then result := TFhirQuantity.create(){4b}
  else if (propName = 'paymentAdjustmentReason') then result := TFhirCoding.create(){4b}
  else if (propName = 'paymentDate') then result := TFhirDate.create() {5b}
  else if (propName = 'paymentAmount') then result := TFhirQuantity.create(){4b}
  else if (propName = 'paymentRef') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'reserved') then result := TFhirCoding.create(){4b}
  else if (propName = 'form') then result := TFhirCoding.create(){4b}
  else if (propName = 'note') then result := NoteList.new(){2}
  else if (propName = 'coverage') then result := CoverageList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponse.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'ruleset') then result := 'Coding'
  else if (propName = 'originalRuleset') then result := 'Coding'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'organization') then result := 'Reference'
  else if (propName = 'requestProvider') then result := 'Reference'
  else if (propName = 'requestOrganization') then result := 'Reference'
  else if (propName = 'outcome') then result := 'code'
  else if (propName = 'disposition') then result := 'string'
  else if (propName = 'payeeType') then result := 'Coding'
  else if (propName = 'item') then result := ''
  else if (propName = 'addItem') then result := ''
  else if (propName = 'error') then result := ''
  else if (propName = 'totalCost') then result := 'Quantity'
  else if (propName = 'unallocDeductable') then result := 'Quantity'
  else if (propName = 'totalBenefit') then result := 'Quantity'
  else if (propName = 'paymentAdjustment') then result := 'Quantity'
  else if (propName = 'paymentAdjustmentReason') then result := 'Coding'
  else if (propName = 'paymentDate') then result := 'date'
  else if (propName = 'paymentAmount') then result := 'Quantity'
  else if (propName = 'paymentRef') then result := 'Identifier'
  else if (propName = 'reserved') then result := 'Coding'
  else if (propName = 'form') then result := 'Coding'
  else if (propName = 'note') then result := ''
  else if (propName = 'coverage') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponse.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'ruleset') then RulesetElement := nil
  else if (propName = 'originalRuleset') then OriginalRulesetElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'organization') then OrganizationElement := nil
  else if (propName = 'requestProvider') then RequestProviderElement := nil
  else if (propName = 'requestOrganization') then RequestOrganizationElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'disposition') then DispositionElement := nil
  else if (propName = 'payeeType') then PayeeTypeElement := nil
  else if (propName = 'item') then deletePropertyValue('item', ItemList, value) {2}
  else if (propName = 'addItem') then deletePropertyValue('addItem', AddItemList, value) {2}
  else if (propName = 'error') then deletePropertyValue('error', ErrorList, value) {2}
  else if (propName = 'totalCost') then TotalCostElement := nil
  else if (propName = 'unallocDeductable') then UnallocDeductableElement := nil
  else if (propName = 'totalBenefit') then TotalBenefitElement := nil
  else if (propName = 'paymentAdjustment') then PaymentAdjustmentElement := nil
  else if (propName = 'paymentAdjustmentReason') then PaymentAdjustmentReasonElement := nil
  else if (propName = 'paymentDate') then PaymentDateElement := nil
  else if (propName = 'paymentAmount') then PaymentAmountElement := nil
  else if (propName = 'paymentRef') then PaymentRefElement := nil
  else if (propName = 'reserved') then ReservedElement := nil
  else if (propName = 'form') then FormElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else if (propName = 'coverage') then deletePropertyValue('coverage', CoverageList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponse.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'request') then RequestElement := new as TFhirReference{TFhirClaim}{4}
  else if (propName = 'ruleset') then RulesetElement := new as TFhirCoding{4}
  else if (propName = 'originalRuleset') then OriginalRulesetElement := new as TFhirCoding{4}
  else if (propName = 'created') then CreatedElement := asDateTime(new){5b}
  else if (propName = 'organization') then OrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'requestProvider') then RequestProviderElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'requestOrganization') then RequestOrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'outcome') then OutcomeElement := asEnum(SYSTEMS_TFhirRemittanceOutcomeEnum, CODES_TFhirRemittanceOutcomeEnum, new){4}
  else if (propName = 'disposition') then DispositionElement := asString(new){5b}
  else if (propName = 'payeeType') then PayeeTypeElement := new as TFhirCoding{4}
  else if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new) {2}
  else if (propName = 'addItem') then replacePropertyValue('addItem', AddItemList, existing, new) {2}
  else if (propName = 'error') then replacePropertyValue('error', ErrorList, existing, new) {2}
  else if (propName = 'totalCost') then TotalCostElement := new as TFhirQuantity{4}
  else if (propName = 'unallocDeductable') then UnallocDeductableElement := new as TFhirQuantity{4}
  else if (propName = 'totalBenefit') then TotalBenefitElement := new as TFhirQuantity{4}
  else if (propName = 'paymentAdjustment') then PaymentAdjustmentElement := new as TFhirQuantity{4}
  else if (propName = 'paymentAdjustmentReason') then PaymentAdjustmentReasonElement := new as TFhirCoding{4}
  else if (propName = 'paymentDate') then PaymentDateElement := asDate(new){5b}
  else if (propName = 'paymentAmount') then PaymentAmountElement := new as TFhirQuantity{4}
  else if (propName = 'paymentRef') then PaymentRefElement := new as TFhirIdentifier{4}
  else if (propName = 'reserved') then ReservedElement := new as TFhirCoding{4}
  else if (propName = 'form') then FormElement := new as TFhirCoding{4}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else if (propName = 'coverage') then replacePropertyValue('coverage', CoverageList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponse.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'item') then ItemList.move(source, destination){2a}
  else if (propName = 'addItem') then AddItemList.move(source, destination){2a}
  else if (propName = 'error') then ErrorList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else if (propName = 'coverage') then CoverageList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponse.fhirType : string;
begin
  result := 'ClaimResponse';
end;

function TFhirClaimResponse.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FRequest) and isEmptyProp(FRuleset) and isEmptyProp(FOriginalRuleset) and isEmptyProp(FCreated) and isEmptyProp(FOrganization) and isEmptyProp(FRequestProvider) and isEmptyProp(FRequestOrganization) and isEmptyProp(FOutcome) and isEmptyProp(FDisposition) and isEmptyProp(FPayeeType) and isEmptyProp(FitemList) and isEmptyProp(FaddItemList) and isEmptyProp(FerrorList) and isEmptyProp(FTotalCost) and isEmptyProp(FUnallocDeductable) and isEmptyProp(FTotalBenefit) and isEmptyProp(FPaymentAdjustment) and isEmptyProp(FPaymentAdjustmentReason) and isEmptyProp(FPaymentDate) and isEmptyProp(FPaymentAmount) and isEmptyProp(FPaymentRef) and isEmptyProp(FReserved) and isEmptyProp(FForm) and isEmptyProp(FnoteList) and isEmptyProp(FcoverageList);
end;

function TFhirClaimResponse.equals(other : TObject) : boolean;
var
  o : TFhirClaimResponse;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponse)) then
    result := false
  else
  begin
    o := TFhirClaimResponse(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(requestElement, o.requestElement, true) and
      compareDeep(rulesetElement, o.rulesetElement, true) and compareDeep(originalRulesetElement, o.originalRulesetElement, true) and
      compareDeep(createdElement, o.createdElement, true) and compareDeep(organizationElement, o.organizationElement, true) and
      compareDeep(requestProviderElement, o.requestProviderElement, true) and compareDeep(requestOrganizationElement, o.requestOrganizationElement, true) and
      compareDeep(outcomeElement, o.outcomeElement, true) and compareDeep(dispositionElement, o.dispositionElement, true) and
      compareDeep(payeeTypeElement, o.payeeTypeElement, true) and compareDeep(itemList, o.itemList, true) and
      compareDeep(addItemList, o.addItemList, true) and compareDeep(errorList, o.errorList, true) and
      compareDeep(totalCostElement, o.totalCostElement, true) and compareDeep(unallocDeductableElement, o.unallocDeductableElement, true) and
      compareDeep(totalBenefitElement, o.totalBenefitElement, true) and compareDeep(paymentAdjustmentElement, o.paymentAdjustmentElement, true) and
      compareDeep(paymentAdjustmentReasonElement, o.paymentAdjustmentReasonElement, true) and
      compareDeep(paymentDateElement, o.paymentDateElement, true) and compareDeep(paymentAmountElement, o.paymentAmountElement, true) and
      compareDeep(paymentRefElement, o.paymentRefElement, true) and compareDeep(reservedElement, o.reservedElement, true) and
      compareDeep(formElement, o.formElement, true) and compareDeep(noteList, o.noteList, true) and
      compareDeep(coverageList, o.coverageList, true);
  end;
end;

function TFhirClaimResponse.Link : TFhirClaimResponse;
begin
  result := TFhirClaimResponse(inherited Link);
end;

function TFhirClaimResponse.Clone : TFhirClaimResponse;
begin
  result := TFhirClaimResponse(inherited Clone);
end;

procedure TFhirClaimResponse.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('request');
  fields.add('ruleset');
  fields.add('originalRuleset');
  fields.add('created');
  fields.add('organization');
  fields.add('requestProvider');
  fields.add('requestOrganization');
  fields.add('outcome');
  fields.add('disposition');
  fields.add('payeeType');
  fields.add('item');
  fields.add('addItem');
  fields.add('error');
  fields.add('totalCost');
  fields.add('unallocDeductable');
  fields.add('totalBenefit');
  fields.add('paymentAdjustment');
  fields.add('paymentAdjustmentReason');
  fields.add('paymentDate');
  fields.add('paymentAmount');
  fields.add('paymentRef');
  fields.add('reserved');
  fields.add('form');
  fields.add('note');
  fields.add('coverage');
end;

{ TFhirClaimResponse }

Function TFhirClaimResponse.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirClaimResponse.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirClaimResponse.SetRequest(value : TFhirReference{TFhirClaim});
begin
  FRequest.free;
  FRequest := value;
end;

Procedure TFhirClaimResponse.SetRuleset(value : TFhirCoding);
begin
  FRuleset.free;
  FRuleset := value;
end;

Procedure TFhirClaimResponse.SetOriginalRuleset(value : TFhirCoding);
begin
  FOriginalRuleset.free;
  FOriginalRuleset := value;
end;

Procedure TFhirClaimResponse.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

Function TFhirClaimResponse.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

Procedure TFhirClaimResponse.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

Procedure TFhirClaimResponse.SetOrganization(value : TFhirReference{TFhirOrganization});
begin
  FOrganization.free;
  FOrganization := value;
end;

Procedure TFhirClaimResponse.SetRequestProvider(value : TFhirReference{TFhirPractitioner});
begin
  FRequestProvider.free;
  FRequestProvider := value;
end;

Procedure TFhirClaimResponse.SetRequestOrganization(value : TFhirReference{TFhirOrganization});
begin
  FRequestOrganization.free;
  FRequestOrganization := value;
end;

Procedure TFhirClaimResponse.SetOutcome(value : TFhirEnum);
begin
  FOutcome.free;
  FOutcome := value;
end;

Function TFhirClaimResponse.GetOutcomeST : TFhirRemittanceOutcomeEnum;
begin
  if FOutcome = nil then
    result := TFhirRemittanceOutcomeEnum(0)
  else
    result := TFhirRemittanceOutcomeEnum(StringArrayIndexOfSensitive(CODES_TFhirRemittanceOutcomeEnum, FOutcome.value));
end;

Procedure TFhirClaimResponse.SetOutcomeST(value : TFhirRemittanceOutcomeEnum);
begin
  if ord(value) = 0 then
    OutcomeElement := nil
  else
    OutcomeElement := TFhirEnum.create(SYSTEMS_TFhirRemittanceOutcomeEnum[value], CODES_TFhirRemittanceOutcomeEnum[value]);
end;

Procedure TFhirClaimResponse.SetDisposition(value : TFhirString);
begin
  FDisposition.free;
  FDisposition := value;
end;

Function TFhirClaimResponse.GetDispositionST : String;
begin
  if FDisposition = nil then
    result := ''
  else
    result := FDisposition.value;
end;

Procedure TFhirClaimResponse.SetDispositionST(value : String);
begin
  if value <> '' then
  begin
    if FDisposition = nil then
      FDisposition := TFhirString.create;
    FDisposition.value := value
  end
  else if FDisposition <> nil then
    FDisposition.value := '';
end;

Procedure TFhirClaimResponse.SetPayeeType(value : TFhirCoding);
begin
  FPayeeType.free;
  FPayeeType := value;
end;

Function TFhirClaimResponse.GetItemList : TFhirClaimResponseItemList;
begin
  if FItemList = nil then
    FItemList := TFhirClaimResponseItemList.Create;
  result := FItemList;
end;

Function TFhirClaimResponse.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

Function TFhirClaimResponse.GetAddItemList : TFhirClaimResponseAddItemList;
begin
  if FAddItemList = nil then
    FAddItemList := TFhirClaimResponseAddItemList.Create;
  result := FAddItemList;
end;

Function TFhirClaimResponse.GetHasAddItemList : boolean;
begin
  result := (FAddItemList <> nil) and (FAddItemList.count > 0);
end;

Function TFhirClaimResponse.GetErrorList : TFhirClaimResponseErrorList;
begin
  if FErrorList = nil then
    FErrorList := TFhirClaimResponseErrorList.Create;
  result := FErrorList;
end;

Function TFhirClaimResponse.GetHasErrorList : boolean;
begin
  result := (FErrorList <> nil) and (FErrorList.count > 0);
end;

Procedure TFhirClaimResponse.SetTotalCost(value : TFhirQuantity);
begin
  FTotalCost.free;
  FTotalCost := value;
end;

Procedure TFhirClaimResponse.SetUnallocDeductable(value : TFhirQuantity);
begin
  FUnallocDeductable.free;
  FUnallocDeductable := value;
end;

Procedure TFhirClaimResponse.SetTotalBenefit(value : TFhirQuantity);
begin
  FTotalBenefit.free;
  FTotalBenefit := value;
end;

Procedure TFhirClaimResponse.SetPaymentAdjustment(value : TFhirQuantity);
begin
  FPaymentAdjustment.free;
  FPaymentAdjustment := value;
end;

Procedure TFhirClaimResponse.SetPaymentAdjustmentReason(value : TFhirCoding);
begin
  FPaymentAdjustmentReason.free;
  FPaymentAdjustmentReason := value;
end;

Procedure TFhirClaimResponse.SetPaymentDate(value : TFhirDate);
begin
  FPaymentDate.free;
  FPaymentDate := value;
end;

Function TFhirClaimResponse.GetPaymentDateST : TFslDateTime;
begin
  if FPaymentDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FPaymentDate.value;
end;

Procedure TFhirClaimResponse.SetPaymentDateST(value : TFslDateTime);
begin
  if FPaymentDate = nil then
    FPaymentDate := TFhirDate.create;
  FPaymentDate.value := value
end;

Procedure TFhirClaimResponse.SetPaymentAmount(value : TFhirQuantity);
begin
  FPaymentAmount.free;
  FPaymentAmount := value;
end;

Procedure TFhirClaimResponse.SetPaymentRef(value : TFhirIdentifier);
begin
  FPaymentRef.free;
  FPaymentRef := value;
end;

Procedure TFhirClaimResponse.SetReserved(value : TFhirCoding);
begin
  FReserved.free;
  FReserved := value;
end;

Procedure TFhirClaimResponse.SetForm(value : TFhirCoding);
begin
  FForm.free;
  FForm := value;
end;

Function TFhirClaimResponse.GetNoteList : TFhirClaimResponseNoteList;
begin
  if FNoteList = nil then
    FNoteList := TFhirClaimResponseNoteList.Create;
  result := FNoteList;
end;

Function TFhirClaimResponse.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

Function TFhirClaimResponse.GetCoverageList : TFhirClaimResponseCoverageList;
begin
  if FCoverageList = nil then
    FCoverageList := TFhirClaimResponseCoverageList.Create;
  result := FCoverageList;
end;

Function TFhirClaimResponse.GetHasCoverageList : boolean;
begin
  result := (FCoverageList <> nil) and (FCoverageList.count > 0);
end;

function TFhirClaimResponse.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FRequest.sizeInBytes);
  inc(result, FRuleset.sizeInBytes);
  inc(result, FOriginalRuleset.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FOrganization.sizeInBytes);
  inc(result, FRequestProvider.sizeInBytes);
  inc(result, FRequestOrganization.sizeInBytes);
  inc(result, FOutcome.sizeInBytes);
  inc(result, FDisposition.sizeInBytes);
  inc(result, FPayeeType.sizeInBytes);
  inc(result, FitemList.sizeInBytes);
  inc(result, FaddItemList.sizeInBytes);
  inc(result, FerrorList.sizeInBytes);
  inc(result, FTotalCost.sizeInBytes);
  inc(result, FUnallocDeductable.sizeInBytes);
  inc(result, FTotalBenefit.sizeInBytes);
  inc(result, FPaymentAdjustment.sizeInBytes);
  inc(result, FPaymentAdjustmentReason.sizeInBytes);
  inc(result, FPaymentDate.sizeInBytes);
  inc(result, FPaymentAmount.sizeInBytes);
  inc(result, FPaymentRef.sizeInBytes);
  inc(result, FReserved.sizeInBytes);
  inc(result, FForm.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FcoverageList.sizeInBytes);
end;

{ TFhirClaimResponseListEnumerator }

Constructor TFhirClaimResponseListEnumerator.Create(list : TFhirClaimResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseListEnumerator.GetCurrent : TFhirClaimResponse;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseList }
procedure TFhirClaimResponseList.AddItem(value: TFhirClaimResponse);
begin
  assert(value.ClassName = 'TFhirClaimResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponse');
  add(value);
end;

function TFhirClaimResponseList.Append: TFhirClaimResponse;
begin
  result := TFhirClaimResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseList.GetEnumerator : TFhirClaimResponseListEnumerator;
begin
  result := TFhirClaimResponseListEnumerator.Create(self.link);
end;

function TFhirClaimResponseList.Clone: TFhirClaimResponseList;
begin
  result := TFhirClaimResponseList(inherited Clone);
end;

function TFhirClaimResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseList.GetItemN(index: Integer): TFhirClaimResponse;
begin
  result := TFhirClaimResponse(ObjectByIndex[index]);
end;

function TFhirClaimResponseList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponse;
end;
function TFhirClaimResponseList.IndexOf(value: TFhirClaimResponse): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseList.Insert(index: Integer): TFhirClaimResponse;
begin
  result := TFhirClaimResponse.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseList.InsertItem(index: Integer; value: TFhirClaimResponse);
begin
  assert(value is TFhirClaimResponse);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseList.Item(index: Integer): TFhirClaimResponse;
begin
  result := TFhirClaimResponse(ObjectByIndex[index]);
end;

function TFhirClaimResponseList.Link: TFhirClaimResponseList;
begin
  result := TFhirClaimResponseList(inherited Link);
end;

procedure TFhirClaimResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseList.SetItemByIndex(index: Integer; value: TFhirClaimResponse);
begin
  assert(value is TFhirClaimResponse);
  FhirClaimResponses[index] := value;
end;

procedure TFhirClaimResponseList.SetItemN(index: Integer; value: TFhirClaimResponse);
begin
  assert(value is TFhirClaimResponse);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CLAIMRESPONSE}

{$IFDEF FHIR_CONTRACT}

{ TFhirContractActor }

constructor TFhirContractActor.Create;
begin
  inherited;
end;

destructor TFhirContractActor.Destroy;
begin
  FEntity.free;
  FRoleList.Free;
  inherited;
end;

procedure TFhirContractActor.Assign(oSource : TFslObject);
begin
  inherited;
  entity := TFhirContractActor(oSource).entity.Clone;
  if (TFhirContractActor(oSource).FRoleList = nil) then
  begin
    FRoleList.free;
    FRoleList := nil;
  end
  else
  begin
    if FRoleList = nil then
      FRoleList := TFhirCodeableConceptList.Create;
    FRoleList.Assign(TFhirContractActor(oSource).FRoleList);
  end;
end;

procedure TFhirContractActor.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'entity') Then
     list.add(self.link, 'entity', FEntity.Link);
  if (child_name = 'role') Then
    list.addAll(self, 'role', FRoleList);
end;

procedure TFhirContractActor.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'entity', 'Reference(Contract|Device|Group|Location|Organization|Patient|Practitioner|RelatedPerson|Substance)', false, TFhirReference{Resource}, FEntity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', true, TFhirCodeableConcept, FRoleList.Link)){3};
end;

function TFhirContractActor.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'entity') then
  begin
    Entity := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    RoleList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractActor.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'role') then RoleList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirContractActor.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'entity') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'role') then result := RoleList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractActor.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'entity') then result := 'Reference'
  else if (propName = 'role') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractActor.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'entity') then EntityElement := nil
  else if (propName = 'role') then deletePropertyValue('role', RoleList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractActor.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'entity') then EntityElement := new as TFhirReference{Resource}{4}
  else if (propName = 'role') then replacePropertyValue('role', RoleList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractActor.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'role') then RoleList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContractActor.fhirType : string;
begin
  result := 'actor';
end;

function TFhirContractActor.Link : TFhirContractActor;
begin
  result := TFhirContractActor(inherited Link);
end;

function TFhirContractActor.Clone : TFhirContractActor;
begin
  result := TFhirContractActor(inherited Clone);
end;

function TFhirContractActor.equals(other : TObject) : boolean;
var
  o : TFhirContractActor;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractActor)) then
    result := false
  else
  begin
    o := TFhirContractActor(other);
    result := compareDeep(entityElement, o.entityElement, true) and compareDeep(roleList, o.roleList, true);
  end;
end;

function TFhirContractActor.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FEntity) and isEmptyProp(FroleList);
end;

procedure TFhirContractActor.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('entity');
  fields.add('role');
end;

{ TFhirContractActor }

Procedure TFhirContractActor.SetEntity(value : TFhirReference{Resource});
begin
  FEntity.free;
  FEntity := value;
end;

Function TFhirContractActor.GetRoleList : TFhirCodeableConceptList;
begin
  if FRoleList = nil then
    FRoleList := TFhirCodeableConceptList.Create;
  result := FRoleList;
end;

Function TFhirContractActor.GetHasRoleList : boolean;
begin
  result := (FRoleList <> nil) and (FRoleList.count > 0);
end;

function TFhirContractActor.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FEntity.sizeInBytes);
  inc(result, FroleList.sizeInBytes);
end;

{ TFhirContractActorListEnumerator }

Constructor TFhirContractActorListEnumerator.Create(list : TFhirContractActorList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractActorListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractActorListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractActorListEnumerator.GetCurrent : TFhirContractActor;
begin
  Result := FList[FIndex];
end;

function TFhirContractActorListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirContractActorList }
procedure TFhirContractActorList.AddItem(value: TFhirContractActor);
begin
  assert(value.ClassName = 'TFhirContractActor', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractActor');
  add(value);
end;

function TFhirContractActorList.Append: TFhirContractActor;
begin
  result := TFhirContractActor.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractActorList.ClearItems;
begin
  Clear;
end;

function TFhirContractActorList.GetEnumerator : TFhirContractActorListEnumerator;
begin
  result := TFhirContractActorListEnumerator.Create(self.link);
end;

function TFhirContractActorList.Clone: TFhirContractActorList;
begin
  result := TFhirContractActorList(inherited Clone);
end;

function TFhirContractActorList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractActorList.GetItemN(index: Integer): TFhirContractActor;
begin
  result := TFhirContractActor(ObjectByIndex[index]);
end;

function TFhirContractActorList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractActor;
end;
function TFhirContractActorList.IndexOf(value: TFhirContractActor): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractActorList.Insert(index: Integer): TFhirContractActor;
begin
  result := TFhirContractActor.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractActorList.InsertItem(index: Integer; value: TFhirContractActor);
begin
  assert(value is TFhirContractActor);
  Inherited Insert(index, value);
end;

function TFhirContractActorList.Item(index: Integer): TFhirContractActor;
begin
  result := TFhirContractActor(ObjectByIndex[index]);
end;

function TFhirContractActorList.Link: TFhirContractActorList;
begin
  result := TFhirContractActorList(inherited Link);
end;

procedure TFhirContractActorList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractActorList.SetItemByIndex(index: Integer; value: TFhirContractActor);
begin
  assert(value is TFhirContractActor);
  FhirContractActors[index] := value;
end;

procedure TFhirContractActorList.SetItemN(index: Integer; value: TFhirContractActor);
begin
  assert(value is TFhirContractActor);
  ObjectByIndex[index] := value;
end;

{ TFhirContractValuedItem }

constructor TFhirContractValuedItem.Create;
begin
  inherited;
end;

destructor TFhirContractValuedItem.Destroy;
begin
  FEntity.free;
  FIdentifier.free;
  FEffectiveTime.free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FPoints.free;
  FNet.free;
  inherited;
end;

procedure TFhirContractValuedItem.Assign(oSource : TFslObject);
begin
  inherited;
  entity := TFhirContractValuedItem(oSource).entity.Clone;
  identifier := TFhirContractValuedItem(oSource).identifier.Clone;
  effectiveTimeElement := TFhirContractValuedItem(oSource).effectiveTimeElement.Clone;
  quantity := TFhirContractValuedItem(oSource).quantity.Clone;
  unitPrice := TFhirContractValuedItem(oSource).unitPrice.Clone;
  factorElement := TFhirContractValuedItem(oSource).factorElement.Clone;
  pointsElement := TFhirContractValuedItem(oSource).pointsElement.Clone;
  net := TFhirContractValuedItem(oSource).net.Clone;
end;

procedure TFhirContractValuedItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'entity[x]') or (child_name = 'entity') Then
     list.add(self.link, 'entity[x]', FEntity.Link);
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'effectiveTime') Then
     list.add(self.link, 'effectiveTime', FEffectiveTime.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'points') Then
     list.add(self.link, 'points', FPoints.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
end;

procedure TFhirContractValuedItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'entity[x]', 'CodeableConcept|Reference(Any)', false, TFhirType, FEntity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'effectiveTime', 'dateTime', false, TFhirDateTime, FEffectiveTime.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Quantity', false, TFhirQuantity, FUnitPrice.Link));{2}
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'points', 'decimal', false, TFhirDecimal, FPoints.Link));{2}
  oList.add(TFHIRProperty.create(self, 'net', 'Quantity', false, TFhirQuantity, FNet.Link));{2}
end;

function TFhirContractValuedItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'entity', ['CodeableConcept', 'Reference'])) then
  begin
    Entity := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'effectiveTime') then
  begin
    EffectiveTimeElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'points') then
  begin
    PointsElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractValuedItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirContractValuedItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'entity', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Entity'){4x}
  else if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'effectiveTime') then result := TFhirDateTime.create() {5b}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'unitPrice') then result := TFhirQuantity.create(){4b}
  else if (propName = 'factor') then result := TFhirDecimal.create() {5b}
  else if (propName = 'points') then result := TFhirDecimal.create() {5b}
  else if (propName = 'net') then result := TFhirQuantity.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractValuedItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'entity[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'effectiveTime') then result := 'dateTime'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Quantity'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'points') then result := 'decimal'
  else if (propName = 'net') then result := 'Quantity'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractValuedItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'entity', ['CodeableConcept', 'Reference'])) then EntityElement := nil{4x}
  else if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'effectiveTime') then EffectiveTimeElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'points') then PointsElement := nil
  else if (propName = 'net') then NetElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractValuedItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'entity', ['CodeableConcept', 'Reference'])) then EntityElement := new as TFhirType{4x}
  else if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'effectiveTime') then EffectiveTimeElement := asDateTime(new){5b}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirQuantity{4}
  else if (propName = 'factor') then FactorElement := asDecimal(new){5b}
  else if (propName = 'points') then PointsElement := asDecimal(new){5b}
  else if (propName = 'net') then NetElement := new as TFhirQuantity{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractValuedItem.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirContractValuedItem.fhirType : string;
begin
  result := 'valuedItem';
end;

function TFhirContractValuedItem.Link : TFhirContractValuedItem;
begin
  result := TFhirContractValuedItem(inherited Link);
end;

function TFhirContractValuedItem.Clone : TFhirContractValuedItem;
begin
  result := TFhirContractValuedItem(inherited Clone);
end;

function TFhirContractValuedItem.equals(other : TObject) : boolean;
var
  o : TFhirContractValuedItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractValuedItem)) then
    result := false
  else
  begin
    o := TFhirContractValuedItem(other);
    result := compareDeep(entityElement, o.entityElement, true) and compareDeep(identifierElement, o.identifierElement, true) and
      compareDeep(effectiveTimeElement, o.effectiveTimeElement, true) and compareDeep(quantityElement, o.quantityElement, true) and
      compareDeep(unitPriceElement, o.unitPriceElement, true) and compareDeep(factorElement, o.factorElement, true) and
      compareDeep(pointsElement, o.pointsElement, true) and compareDeep(netElement, o.netElement, true);
  end;
end;

function TFhirContractValuedItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FEntity) and isEmptyProp(FIdentifier) and isEmptyProp(FEffectiveTime) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FPoints) and isEmptyProp(FNet);
end;

procedure TFhirContractValuedItem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('entity[x]');
  fields.add('identifier');
  fields.add('effectiveTime');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('points');
  fields.add('net');
end;

{ TFhirContractValuedItem }

Procedure TFhirContractValuedItem.SetEntity(value : TFhirType);
begin
  FEntity.free;
  FEntity := value;
end;

Procedure TFhirContractValuedItem.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirContractValuedItem.SetEffectiveTime(value : TFhirDateTime);
begin
  FEffectiveTime.free;
  FEffectiveTime := value;
end;

Function TFhirContractValuedItem.GetEffectiveTimeST : TFslDateTime;
begin
  if FEffectiveTime = nil then
    result := TFslDateTime.makeNull
  else
    result := FEffectiveTime.value;
end;

Procedure TFhirContractValuedItem.SetEffectiveTimeST(value : TFslDateTime);
begin
  if FEffectiveTime = nil then
    FEffectiveTime := TFhirDateTime.create;
  FEffectiveTime.value := value
end;

Procedure TFhirContractValuedItem.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirContractValuedItem.SetUnitPrice(value : TFhirQuantity);
begin
  FUnitPrice.free;
  FUnitPrice := value;
end;

Procedure TFhirContractValuedItem.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

Function TFhirContractValuedItem.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

Procedure TFhirContractValuedItem.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

Procedure TFhirContractValuedItem.SetPoints(value : TFhirDecimal);
begin
  FPoints.free;
  FPoints := value;
end;

Function TFhirContractValuedItem.GetPointsST : String;
begin
  if FPoints = nil then
    result := ''
  else
    result := FPoints.value;
end;

Procedure TFhirContractValuedItem.SetPointsST(value : String);
begin
  if value <> '' then
  begin
    if FPoints = nil then
      FPoints := TFhirDecimal.create;
    FPoints.value := value
  end
  else if FPoints <> nil then
    FPoints.value := '';
end;

Procedure TFhirContractValuedItem.SetNet(value : TFhirQuantity);
begin
  FNet.free;
  FNet := value;
end;

function TFhirContractValuedItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FEntity.sizeInBytes);
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FEffectiveTime.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FUnitPrice.sizeInBytes);
  inc(result, FFactor.sizeInBytes);
  inc(result, FPoints.sizeInBytes);
  inc(result, FNet.sizeInBytes);
end;

{ TFhirContractValuedItemListEnumerator }

Constructor TFhirContractValuedItemListEnumerator.Create(list : TFhirContractValuedItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractValuedItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractValuedItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractValuedItemListEnumerator.GetCurrent : TFhirContractValuedItem;
begin
  Result := FList[FIndex];
end;

function TFhirContractValuedItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirContractValuedItemList }
procedure TFhirContractValuedItemList.AddItem(value: TFhirContractValuedItem);
begin
  assert(value.ClassName = 'TFhirContractValuedItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractValuedItem');
  add(value);
end;

function TFhirContractValuedItemList.Append: TFhirContractValuedItem;
begin
  result := TFhirContractValuedItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractValuedItemList.ClearItems;
begin
  Clear;
end;

function TFhirContractValuedItemList.GetEnumerator : TFhirContractValuedItemListEnumerator;
begin
  result := TFhirContractValuedItemListEnumerator.Create(self.link);
end;

function TFhirContractValuedItemList.Clone: TFhirContractValuedItemList;
begin
  result := TFhirContractValuedItemList(inherited Clone);
end;

function TFhirContractValuedItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractValuedItemList.GetItemN(index: Integer): TFhirContractValuedItem;
begin
  result := TFhirContractValuedItem(ObjectByIndex[index]);
end;

function TFhirContractValuedItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractValuedItem;
end;
function TFhirContractValuedItemList.IndexOf(value: TFhirContractValuedItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractValuedItemList.Insert(index: Integer): TFhirContractValuedItem;
begin
  result := TFhirContractValuedItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractValuedItemList.InsertItem(index: Integer; value: TFhirContractValuedItem);
begin
  assert(value is TFhirContractValuedItem);
  Inherited Insert(index, value);
end;

function TFhirContractValuedItemList.Item(index: Integer): TFhirContractValuedItem;
begin
  result := TFhirContractValuedItem(ObjectByIndex[index]);
end;

function TFhirContractValuedItemList.Link: TFhirContractValuedItemList;
begin
  result := TFhirContractValuedItemList(inherited Link);
end;

procedure TFhirContractValuedItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractValuedItemList.SetItemByIndex(index: Integer; value: TFhirContractValuedItem);
begin
  assert(value is TFhirContractValuedItem);
  FhirContractValuedItems[index] := value;
end;

procedure TFhirContractValuedItemList.SetItemN(index: Integer; value: TFhirContractValuedItem);
begin
  assert(value is TFhirContractValuedItem);
  ObjectByIndex[index] := value;
end;

{ TFhirContractSigner }

constructor TFhirContractSigner.Create;
begin
  inherited;
end;

destructor TFhirContractSigner.Destroy;
begin
  FType_.free;
  FParty.free;
  FSignature.free;
  inherited;
end;

procedure TFhirContractSigner.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirContractSigner(oSource).type_.Clone;
  party := TFhirContractSigner(oSource).party.Clone;
  signatureElement := TFhirContractSigner(oSource).signatureElement.Clone;
end;

procedure TFhirContractSigner.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'party') Then
     list.add(self.link, 'party', FParty.Link);
  if (child_name = 'signature') Then
     list.add(self.link, 'signature', FSignature.Link);
end;

procedure TFhirContractSigner.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', false, TFhirCoding, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'party', 'Reference(Organization|Patient|Practitioner|RelatedPerson)', false, TFhirReference{Resource}, FParty.Link));{2}
  oList.add(TFHIRProperty.create(self, 'signature', 'string', false, TFhirString, FSignature.Link));{2}
end;

function TFhirContractSigner.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'party') then
  begin
    Party := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'signature') then
  begin
    SignatureElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractSigner.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirContractSigner.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCoding.create(){4b}
  else if (propName = 'party') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'signature') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractSigner.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'Coding'
  else if (propName = 'party') then result := 'Reference'
  else if (propName = 'signature') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractSigner.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'party') then PartyElement := nil
  else if (propName = 'signature') then SignatureElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractSigner.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCoding{4}
  else if (propName = 'party') then PartyElement := new as TFhirReference{Resource}{4}
  else if (propName = 'signature') then SignatureElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractSigner.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirContractSigner.fhirType : string;
begin
  result := 'signer';
end;

function TFhirContractSigner.Link : TFhirContractSigner;
begin
  result := TFhirContractSigner(inherited Link);
end;

function TFhirContractSigner.Clone : TFhirContractSigner;
begin
  result := TFhirContractSigner(inherited Clone);
end;

function TFhirContractSigner.equals(other : TObject) : boolean;
var
  o : TFhirContractSigner;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractSigner)) then
    result := false
  else
  begin
    o := TFhirContractSigner(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(partyElement, o.partyElement, true) and
      compareDeep(signatureElement, o.signatureElement, true);
  end;
end;

function TFhirContractSigner.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FParty) and isEmptyProp(FSignature);
end;

procedure TFhirContractSigner.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('party');
  fields.add('signature');
end;

{ TFhirContractSigner }

Procedure TFhirContractSigner.SetType_(value : TFhirCoding);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirContractSigner.SetParty(value : TFhirReference{Resource});
begin
  FParty.free;
  FParty := value;
end;

Procedure TFhirContractSigner.SetSignature(value : TFhirString);
begin
  FSignature.free;
  FSignature := value;
end;

Function TFhirContractSigner.GetSignatureST : String;
begin
  if FSignature = nil then
    result := ''
  else
    result := FSignature.value;
end;

Procedure TFhirContractSigner.SetSignatureST(value : String);
begin
  if value <> '' then
  begin
    if FSignature = nil then
      FSignature := TFhirString.create;
    FSignature.value := value
  end
  else if FSignature <> nil then
    FSignature.value := '';
end;

function TFhirContractSigner.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FParty.sizeInBytes);
  inc(result, FSignature.sizeInBytes);
end;

{ TFhirContractSignerListEnumerator }

Constructor TFhirContractSignerListEnumerator.Create(list : TFhirContractSignerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractSignerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractSignerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractSignerListEnumerator.GetCurrent : TFhirContractSigner;
begin
  Result := FList[FIndex];
end;

function TFhirContractSignerListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirContractSignerList }
procedure TFhirContractSignerList.AddItem(value: TFhirContractSigner);
begin
  assert(value.ClassName = 'TFhirContractSigner', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractSigner');
  add(value);
end;

function TFhirContractSignerList.Append: TFhirContractSigner;
begin
  result := TFhirContractSigner.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractSignerList.ClearItems;
begin
  Clear;
end;

function TFhirContractSignerList.GetEnumerator : TFhirContractSignerListEnumerator;
begin
  result := TFhirContractSignerListEnumerator.Create(self.link);
end;

function TFhirContractSignerList.Clone: TFhirContractSignerList;
begin
  result := TFhirContractSignerList(inherited Clone);
end;

function TFhirContractSignerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractSignerList.GetItemN(index: Integer): TFhirContractSigner;
begin
  result := TFhirContractSigner(ObjectByIndex[index]);
end;

function TFhirContractSignerList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractSigner;
end;
function TFhirContractSignerList.IndexOf(value: TFhirContractSigner): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractSignerList.Insert(index: Integer): TFhirContractSigner;
begin
  result := TFhirContractSigner.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractSignerList.InsertItem(index: Integer; value: TFhirContractSigner);
begin
  assert(value is TFhirContractSigner);
  Inherited Insert(index, value);
end;

function TFhirContractSignerList.Item(index: Integer): TFhirContractSigner;
begin
  result := TFhirContractSigner(ObjectByIndex[index]);
end;

function TFhirContractSignerList.Link: TFhirContractSignerList;
begin
  result := TFhirContractSignerList(inherited Link);
end;

procedure TFhirContractSignerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractSignerList.SetItemByIndex(index: Integer; value: TFhirContractSigner);
begin
  assert(value is TFhirContractSigner);
  FhirContractSigners[index] := value;
end;

procedure TFhirContractSignerList.SetItemN(index: Integer; value: TFhirContractSigner);
begin
  assert(value is TFhirContractSigner);
  ObjectByIndex[index] := value;
end;

{ TFhirContractTerm }

constructor TFhirContractTerm.Create;
begin
  inherited;
end;

destructor TFhirContractTerm.Destroy;
begin
  FIdentifier.free;
  FIssued.free;
  FApplies.free;
  FType_.free;
  FSubType.free;
  FSubject.free;
  FActionList.Free;
  FActionReasonList.Free;
  FActorList.Free;
  FText.free;
  FValuedItemList.Free;
  FGroupList.Free;
  inherited;
end;

procedure TFhirContractTerm.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirContractTerm(oSource).identifier.Clone;
  issuedElement := TFhirContractTerm(oSource).issuedElement.Clone;
  applies := TFhirContractTerm(oSource).applies.Clone;
  type_ := TFhirContractTerm(oSource).type_.Clone;
  subType := TFhirContractTerm(oSource).subType.Clone;
  subject := TFhirContractTerm(oSource).subject.Clone;
  if (TFhirContractTerm(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirCodeableConceptList.Create;
    FActionList.Assign(TFhirContractTerm(oSource).FActionList);
  end;
  if (TFhirContractTerm(oSource).FActionReasonList = nil) then
  begin
    FActionReasonList.free;
    FActionReasonList := nil;
  end
  else
  begin
    if FActionReasonList = nil then
      FActionReasonList := TFhirCodeableConceptList.Create;
    FActionReasonList.Assign(TFhirContractTerm(oSource).FActionReasonList);
  end;
  if (TFhirContractTerm(oSource).FActorList = nil) then
  begin
    FActorList.free;
    FActorList := nil;
  end
  else
  begin
    if FActorList = nil then
      FActorList := TFhirContractTermActorList.Create;
    FActorList.Assign(TFhirContractTerm(oSource).FActorList);
  end;
  textElement := TFhirContractTerm(oSource).textElement.Clone;
  if (TFhirContractTerm(oSource).FValuedItemList = nil) then
  begin
    FValuedItemList.free;
    FValuedItemList := nil;
  end
  else
  begin
    if FValuedItemList = nil then
      FValuedItemList := TFhirContractTermValuedItemList.Create;
    FValuedItemList.Assign(TFhirContractTerm(oSource).FValuedItemList);
  end;
  if (TFhirContractTerm(oSource).FGroupList = nil) then
  begin
    FGroupList.free;
    FGroupList := nil;
  end
  else
  begin
    if FGroupList = nil then
      FGroupList := TFhirContractTermList.Create;
    FGroupList.Assign(TFhirContractTerm(oSource).FGroupList);
  end;
end;

procedure TFhirContractTerm.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'issued') Then
     list.add(self.link, 'issued', FIssued.Link);
  if (child_name = 'applies') Then
     list.add(self.link, 'applies', FApplies.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subType') Then
     list.add(self.link, 'subType', FSubType.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
  if (child_name = 'actionReason') Then
    list.addAll(self, 'actionReason', FActionReasonList);
  if (child_name = 'actor') Then
    list.addAll(self, 'actor', FActorList);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'valuedItem') Then
    list.addAll(self, 'valuedItem', FValuedItemList);
  if (child_name = 'group') Then
    list.addAll(self, 'group', FGroupList);
end;

procedure TFhirContractTerm.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'issued', 'dateTime', false, TFhirDateTime, FIssued.Link));{2}
  oList.add(TFHIRProperty.create(self, 'applies', 'Period', false, TFhirPeriod, FApplies.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subType', 'CodeableConcept', false, TFhirCodeableConcept, FSubType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Any)', false, TFhirReference{TFhirReference}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'action', 'CodeableConcept', true, TFhirCodeableConcept, FActionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'actionReason', 'CodeableConcept', true, TFhirCodeableConcept, FActionReasonList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'actor', '', true, TFhirContractTermActor, FActorList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));{2}
  oList.add(TFHIRProperty.create(self, 'valuedItem', '', true, TFhirContractTermValuedItem, FValuedItemList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'group', '@Contract.term', true, TFhirContractTerm, FGroupList.Link)){3};
end;

function TFhirContractTerm.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'issued') then
  begin
    IssuedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'applies') then
  begin
    Applies := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subType') then
  begin
    SubType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'actionReason') then
  begin
    ActionReasonList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    ActorList.add(propValue as TFhirContractTermActor){2a};
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'valuedItem') then
  begin
    ValuedItemList.add(propValue as TFhirContractTermValuedItem){2a};
    result := propValue;
  end
  else if (propName = 'group') then
  begin
    GroupList.add(propValue as TFhirContractTerm){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractTerm.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'actionReason') then ActionReasonList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'actor') then ActorList.insertItem(index, propValue as TFhirContractTermActor){2a}
  else if (propName = 'valuedItem') then ValuedItemList.insertItem(index, propValue as TFhirContractTermValuedItem){2a}
  else if (propName = 'group') then GroupList.insertItem(index, propValue as TFhirContractTerm){2a}
  else inherited;
end;

function TFhirContractTerm.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'issued') then result := TFhirDateTime.create() {5b}
  else if (propName = 'applies') then result := TFhirPeriod.create(){4b}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subType') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subject') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'action') then result := ActionList.new(){2}
  else if (propName = 'actionReason') then result := ActionReasonList.new(){2}
  else if (propName = 'actor') then result := ActorList.new(){2}
  else if (propName = 'text') then result := TFhirString.create() {5b}
  else if (propName = 'valuedItem') then result := ValuedItemList.new(){2}
  else if (propName = 'group') then result := GroupList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractTerm.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'issued') then result := 'dateTime'
  else if (propName = 'applies') then result := 'Period'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'subType') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'action') then result := 'CodeableConcept'
  else if (propName = 'actionReason') then result := 'CodeableConcept'
  else if (propName = 'actor') then result := ''
  else if (propName = 'text') then result := 'string'
  else if (propName = 'valuedItem') then result := ''
  else if (propName = 'group') then result := '@Contract.term'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractTerm.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'issued') then IssuedElement := nil
  else if (propName = 'applies') then AppliesElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'subType') then SubTypeElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'action') then deletePropertyValue('action', ActionList, value) {2}
  else if (propName = 'actionReason') then deletePropertyValue('actionReason', ActionReasonList, value) {2}
  else if (propName = 'actor') then deletePropertyValue('actor', ActorList, value) {2}
  else if (propName = 'text') then TextElement := nil
  else if (propName = 'valuedItem') then deletePropertyValue('valuedItem', ValuedItemList, value) {2}
  else if (propName = 'group') then deletePropertyValue('group', GroupList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractTerm.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'issued') then IssuedElement := asDateTime(new){5b}
  else if (propName = 'applies') then AppliesElement := new as TFhirPeriod{4}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'subType') then SubTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new) {2}
  else if (propName = 'actionReason') then replacePropertyValue('actionReason', ActionReasonList, existing, new) {2}
  else if (propName = 'actor') then replacePropertyValue('actor', ActorList, existing, new) {2}
  else if (propName = 'text') then TextElement := asString(new){5b}
  else if (propName = 'valuedItem') then replacePropertyValue('valuedItem', ValuedItemList, existing, new) {2}
  else if (propName = 'group') then replacePropertyValue('group', GroupList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractTerm.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'action') then ActionList.move(source, destination){2a}
  else if (propName = 'actionReason') then ActionReasonList.move(source, destination){2a}
  else if (propName = 'actor') then ActorList.move(source, destination){2a}
  else if (propName = 'valuedItem') then ValuedItemList.move(source, destination){2a}
  else if (propName = 'group') then GroupList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContractTerm.fhirType : string;
begin
  result := 'term';
end;

function TFhirContractTerm.Link : TFhirContractTerm;
begin
  result := TFhirContractTerm(inherited Link);
end;

function TFhirContractTerm.Clone : TFhirContractTerm;
begin
  result := TFhirContractTerm(inherited Clone);
end;

function TFhirContractTerm.equals(other : TObject) : boolean;
var
  o : TFhirContractTerm;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractTerm)) then
    result := false
  else
  begin
    o := TFhirContractTerm(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(issuedElement, o.issuedElement, true) and
      compareDeep(appliesElement, o.appliesElement, true) and compareDeep(type_Element, o.type_Element, true) and
      compareDeep(subTypeElement, o.subTypeElement, true) and compareDeep(subjectElement, o.subjectElement, true) and
      compareDeep(actionList, o.actionList, true) and compareDeep(actionReasonList, o.actionReasonList, true) and
      compareDeep(actorList, o.actorList, true) and compareDeep(textElement, o.textElement, true) and
      compareDeep(valuedItemList, o.valuedItemList, true) and compareDeep(groupList, o.groupList, true);
  end;
end;

function TFhirContractTerm.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FIssued) and isEmptyProp(FApplies) and isEmptyProp(FType_) and isEmptyProp(FSubType) and isEmptyProp(FSubject) and isEmptyProp(FactionList) and isEmptyProp(FactionReasonList) and isEmptyProp(FactorList) and isEmptyProp(FText) and isEmptyProp(FvaluedItemList) and isEmptyProp(FgroupList);
end;

procedure TFhirContractTerm.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('issued');
  fields.add('applies');
  fields.add('type');
  fields.add('subType');
  fields.add('subject');
  fields.add('action');
  fields.add('actionReason');
  fields.add('actor');
  fields.add('text');
  fields.add('valuedItem');
  fields.add('group');
end;

{ TFhirContractTerm }

Procedure TFhirContractTerm.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirContractTerm.SetIssued(value : TFhirDateTime);
begin
  FIssued.free;
  FIssued := value;
end;

Function TFhirContractTerm.GetIssuedST : TFslDateTime;
begin
  if FIssued = nil then
    result := TFslDateTime.makeNull
  else
    result := FIssued.value;
end;

Procedure TFhirContractTerm.SetIssuedST(value : TFslDateTime);
begin
  if FIssued = nil then
    FIssued := TFhirDateTime.create;
  FIssued.value := value
end;

Procedure TFhirContractTerm.SetApplies(value : TFhirPeriod);
begin
  FApplies.free;
  FApplies := value;
end;

Procedure TFhirContractTerm.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirContractTerm.SetSubType(value : TFhirCodeableConcept);
begin
  FSubType.free;
  FSubType := value;
end;

Procedure TFhirContractTerm.SetSubject(value : TFhirReference{TFhirReference});
begin
  FSubject.free;
  FSubject := value;
end;

Function TFhirContractTerm.GetActionList : TFhirCodeableConceptList;
begin
  if FActionList = nil then
    FActionList := TFhirCodeableConceptList.Create;
  result := FActionList;
end;

Function TFhirContractTerm.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

Function TFhirContractTerm.GetActionReasonList : TFhirCodeableConceptList;
begin
  if FActionReasonList = nil then
    FActionReasonList := TFhirCodeableConceptList.Create;
  result := FActionReasonList;
end;

Function TFhirContractTerm.GetHasActionReasonList : boolean;
begin
  result := (FActionReasonList <> nil) and (FActionReasonList.count > 0);
end;

Function TFhirContractTerm.GetActorList : TFhirContractTermActorList;
begin
  if FActorList = nil then
    FActorList := TFhirContractTermActorList.Create;
  result := FActorList;
end;

Function TFhirContractTerm.GetHasActorList : boolean;
begin
  result := (FActorList <> nil) and (FActorList.count > 0);
end;

Procedure TFhirContractTerm.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

Function TFhirContractTerm.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

Procedure TFhirContractTerm.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

Function TFhirContractTerm.GetValuedItemList : TFhirContractTermValuedItemList;
begin
  if FValuedItemList = nil then
    FValuedItemList := TFhirContractTermValuedItemList.Create;
  result := FValuedItemList;
end;

Function TFhirContractTerm.GetHasValuedItemList : boolean;
begin
  result := (FValuedItemList <> nil) and (FValuedItemList.count > 0);
end;

Function TFhirContractTerm.GetGroupList : TFhirContractTermList;
begin
  if FGroupList = nil then
    FGroupList := TFhirContractTermList.Create;
  result := FGroupList;
end;

Function TFhirContractTerm.GetHasGroupList : boolean;
begin
  result := (FGroupList <> nil) and (FGroupList.count > 0);
end;

function TFhirContractTerm.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FIssued.sizeInBytes);
  inc(result, FApplies.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FSubType.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FactionList.sizeInBytes);
  inc(result, FactionReasonList.sizeInBytes);
  inc(result, FactorList.sizeInBytes);
  inc(result, FText.sizeInBytes);
  inc(result, FvaluedItemList.sizeInBytes);
  inc(result, FgroupList.sizeInBytes);
end;

{ TFhirContractTermListEnumerator }

Constructor TFhirContractTermListEnumerator.Create(list : TFhirContractTermList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractTermListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractTermListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractTermListEnumerator.GetCurrent : TFhirContractTerm;
begin
  Result := FList[FIndex];
end;

function TFhirContractTermListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirContractTermList }
procedure TFhirContractTermList.AddItem(value: TFhirContractTerm);
begin
  assert(value.ClassName = 'TFhirContractTerm', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractTerm');
  add(value);
end;

function TFhirContractTermList.Append: TFhirContractTerm;
begin
  result := TFhirContractTerm.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermList.ClearItems;
begin
  Clear;
end;

function TFhirContractTermList.GetEnumerator : TFhirContractTermListEnumerator;
begin
  result := TFhirContractTermListEnumerator.Create(self.link);
end;

function TFhirContractTermList.Clone: TFhirContractTermList;
begin
  result := TFhirContractTermList(inherited Clone);
end;

function TFhirContractTermList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractTermList.GetItemN(index: Integer): TFhirContractTerm;
begin
  result := TFhirContractTerm(ObjectByIndex[index]);
end;

function TFhirContractTermList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractTerm;
end;
function TFhirContractTermList.IndexOf(value: TFhirContractTerm): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractTermList.Insert(index: Integer): TFhirContractTerm;
begin
  result := TFhirContractTerm.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermList.InsertItem(index: Integer; value: TFhirContractTerm);
begin
  assert(value is TFhirContractTerm);
  Inherited Insert(index, value);
end;

function TFhirContractTermList.Item(index: Integer): TFhirContractTerm;
begin
  result := TFhirContractTerm(ObjectByIndex[index]);
end;

function TFhirContractTermList.Link: TFhirContractTermList;
begin
  result := TFhirContractTermList(inherited Link);
end;

procedure TFhirContractTermList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractTermList.SetItemByIndex(index: Integer; value: TFhirContractTerm);
begin
  assert(value is TFhirContractTerm);
  FhirContractTerms[index] := value;
end;

procedure TFhirContractTermList.SetItemN(index: Integer; value: TFhirContractTerm);
begin
  assert(value is TFhirContractTerm);
  ObjectByIndex[index] := value;
end;

{ TFhirContractTermActor }

constructor TFhirContractTermActor.Create;
begin
  inherited;
end;

destructor TFhirContractTermActor.Destroy;
begin
  FEntity.free;
  FRoleList.Free;
  inherited;
end;

procedure TFhirContractTermActor.Assign(oSource : TFslObject);
begin
  inherited;
  entity := TFhirContractTermActor(oSource).entity.Clone;
  if (TFhirContractTermActor(oSource).FRoleList = nil) then
  begin
    FRoleList.free;
    FRoleList := nil;
  end
  else
  begin
    if FRoleList = nil then
      FRoleList := TFhirCodeableConceptList.Create;
    FRoleList.Assign(TFhirContractTermActor(oSource).FRoleList);
  end;
end;

procedure TFhirContractTermActor.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'entity') Then
     list.add(self.link, 'entity', FEntity.Link);
  if (child_name = 'role') Then
    list.addAll(self, 'role', FRoleList);
end;

procedure TFhirContractTermActor.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'entity', 'Reference(Contract|Device|Group|Location|Organization|Patient|Practitioner|RelatedPerson|Substance)', false, TFhirReference{Resource}, FEntity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', true, TFhirCodeableConcept, FRoleList.Link)){3};
end;

function TFhirContractTermActor.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'entity') then
  begin
    Entity := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    RoleList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractTermActor.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'role') then RoleList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirContractTermActor.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'entity') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'role') then result := RoleList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractTermActor.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'entity') then result := 'Reference'
  else if (propName = 'role') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractTermActor.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'entity') then EntityElement := nil
  else if (propName = 'role') then deletePropertyValue('role', RoleList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractTermActor.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'entity') then EntityElement := new as TFhirReference{Resource}{4}
  else if (propName = 'role') then replacePropertyValue('role', RoleList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractTermActor.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'role') then RoleList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContractTermActor.fhirType : string;
begin
  result := 'actor';
end;

function TFhirContractTermActor.Link : TFhirContractTermActor;
begin
  result := TFhirContractTermActor(inherited Link);
end;

function TFhirContractTermActor.Clone : TFhirContractTermActor;
begin
  result := TFhirContractTermActor(inherited Clone);
end;

function TFhirContractTermActor.equals(other : TObject) : boolean;
var
  o : TFhirContractTermActor;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractTermActor)) then
    result := false
  else
  begin
    o := TFhirContractTermActor(other);
    result := compareDeep(entityElement, o.entityElement, true) and compareDeep(roleList, o.roleList, true);
  end;
end;

function TFhirContractTermActor.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FEntity) and isEmptyProp(FroleList);
end;

procedure TFhirContractTermActor.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('entity');
  fields.add('role');
end;

{ TFhirContractTermActor }

Procedure TFhirContractTermActor.SetEntity(value : TFhirReference{Resource});
begin
  FEntity.free;
  FEntity := value;
end;

Function TFhirContractTermActor.GetRoleList : TFhirCodeableConceptList;
begin
  if FRoleList = nil then
    FRoleList := TFhirCodeableConceptList.Create;
  result := FRoleList;
end;

Function TFhirContractTermActor.GetHasRoleList : boolean;
begin
  result := (FRoleList <> nil) and (FRoleList.count > 0);
end;

function TFhirContractTermActor.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FEntity.sizeInBytes);
  inc(result, FroleList.sizeInBytes);
end;

{ TFhirContractTermActorListEnumerator }

Constructor TFhirContractTermActorListEnumerator.Create(list : TFhirContractTermActorList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractTermActorListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractTermActorListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractTermActorListEnumerator.GetCurrent : TFhirContractTermActor;
begin
  Result := FList[FIndex];
end;

function TFhirContractTermActorListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirContractTermActorList }
procedure TFhirContractTermActorList.AddItem(value: TFhirContractTermActor);
begin
  assert(value.ClassName = 'TFhirContractTermActor', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractTermActor');
  add(value);
end;

function TFhirContractTermActorList.Append: TFhirContractTermActor;
begin
  result := TFhirContractTermActor.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermActorList.ClearItems;
begin
  Clear;
end;

function TFhirContractTermActorList.GetEnumerator : TFhirContractTermActorListEnumerator;
begin
  result := TFhirContractTermActorListEnumerator.Create(self.link);
end;

function TFhirContractTermActorList.Clone: TFhirContractTermActorList;
begin
  result := TFhirContractTermActorList(inherited Clone);
end;

function TFhirContractTermActorList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractTermActorList.GetItemN(index: Integer): TFhirContractTermActor;
begin
  result := TFhirContractTermActor(ObjectByIndex[index]);
end;

function TFhirContractTermActorList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractTermActor;
end;
function TFhirContractTermActorList.IndexOf(value: TFhirContractTermActor): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractTermActorList.Insert(index: Integer): TFhirContractTermActor;
begin
  result := TFhirContractTermActor.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermActorList.InsertItem(index: Integer; value: TFhirContractTermActor);
begin
  assert(value is TFhirContractTermActor);
  Inherited Insert(index, value);
end;

function TFhirContractTermActorList.Item(index: Integer): TFhirContractTermActor;
begin
  result := TFhirContractTermActor(ObjectByIndex[index]);
end;

function TFhirContractTermActorList.Link: TFhirContractTermActorList;
begin
  result := TFhirContractTermActorList(inherited Link);
end;

procedure TFhirContractTermActorList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractTermActorList.SetItemByIndex(index: Integer; value: TFhirContractTermActor);
begin
  assert(value is TFhirContractTermActor);
  FhirContractTermActors[index] := value;
end;

procedure TFhirContractTermActorList.SetItemN(index: Integer; value: TFhirContractTermActor);
begin
  assert(value is TFhirContractTermActor);
  ObjectByIndex[index] := value;
end;

{ TFhirContractTermValuedItem }

constructor TFhirContractTermValuedItem.Create;
begin
  inherited;
end;

destructor TFhirContractTermValuedItem.Destroy;
begin
  FEntity.free;
  FIdentifier.free;
  FEffectiveTime.free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FPoints.free;
  FNet.free;
  inherited;
end;

procedure TFhirContractTermValuedItem.Assign(oSource : TFslObject);
begin
  inherited;
  entity := TFhirContractTermValuedItem(oSource).entity.Clone;
  identifier := TFhirContractTermValuedItem(oSource).identifier.Clone;
  effectiveTimeElement := TFhirContractTermValuedItem(oSource).effectiveTimeElement.Clone;
  quantity := TFhirContractTermValuedItem(oSource).quantity.Clone;
  unitPrice := TFhirContractTermValuedItem(oSource).unitPrice.Clone;
  factorElement := TFhirContractTermValuedItem(oSource).factorElement.Clone;
  pointsElement := TFhirContractTermValuedItem(oSource).pointsElement.Clone;
  net := TFhirContractTermValuedItem(oSource).net.Clone;
end;

procedure TFhirContractTermValuedItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'entity[x]') or (child_name = 'entity') Then
     list.add(self.link, 'entity[x]', FEntity.Link);
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'effectiveTime') Then
     list.add(self.link, 'effectiveTime', FEffectiveTime.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'points') Then
     list.add(self.link, 'points', FPoints.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
end;

procedure TFhirContractTermValuedItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'entity[x]', 'CodeableConcept|Reference(Any)', false, TFhirType, FEntity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'effectiveTime', 'dateTime', false, TFhirDateTime, FEffectiveTime.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Quantity', false, TFhirQuantity, FUnitPrice.Link));{2}
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'points', 'decimal', false, TFhirDecimal, FPoints.Link));{2}
  oList.add(TFHIRProperty.create(self, 'net', 'Quantity', false, TFhirQuantity, FNet.Link));{2}
end;

function TFhirContractTermValuedItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'entity', ['CodeableConcept', 'Reference'])) then
  begin
    Entity := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'effectiveTime') then
  begin
    EffectiveTimeElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'points') then
  begin
    PointsElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractTermValuedItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirContractTermValuedItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'entity', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Entity'){4x}
  else if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'effectiveTime') then result := TFhirDateTime.create() {5b}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'unitPrice') then result := TFhirQuantity.create(){4b}
  else if (propName = 'factor') then result := TFhirDecimal.create() {5b}
  else if (propName = 'points') then result := TFhirDecimal.create() {5b}
  else if (propName = 'net') then result := TFhirQuantity.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractTermValuedItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'entity[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'effectiveTime') then result := 'dateTime'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Quantity'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'points') then result := 'decimal'
  else if (propName = 'net') then result := 'Quantity'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractTermValuedItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'entity', ['CodeableConcept', 'Reference'])) then EntityElement := nil{4x}
  else if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'effectiveTime') then EffectiveTimeElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'points') then PointsElement := nil
  else if (propName = 'net') then NetElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractTermValuedItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'entity', ['CodeableConcept', 'Reference'])) then EntityElement := new as TFhirType{4x}
  else if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'effectiveTime') then EffectiveTimeElement := asDateTime(new){5b}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirQuantity{4}
  else if (propName = 'factor') then FactorElement := asDecimal(new){5b}
  else if (propName = 'points') then PointsElement := asDecimal(new){5b}
  else if (propName = 'net') then NetElement := new as TFhirQuantity{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractTermValuedItem.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirContractTermValuedItem.fhirType : string;
begin
  result := 'valuedItem';
end;

function TFhirContractTermValuedItem.Link : TFhirContractTermValuedItem;
begin
  result := TFhirContractTermValuedItem(inherited Link);
end;

function TFhirContractTermValuedItem.Clone : TFhirContractTermValuedItem;
begin
  result := TFhirContractTermValuedItem(inherited Clone);
end;

function TFhirContractTermValuedItem.equals(other : TObject) : boolean;
var
  o : TFhirContractTermValuedItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractTermValuedItem)) then
    result := false
  else
  begin
    o := TFhirContractTermValuedItem(other);
    result := compareDeep(entityElement, o.entityElement, true) and compareDeep(identifierElement, o.identifierElement, true) and
      compareDeep(effectiveTimeElement, o.effectiveTimeElement, true) and compareDeep(quantityElement, o.quantityElement, true) and
      compareDeep(unitPriceElement, o.unitPriceElement, true) and compareDeep(factorElement, o.factorElement, true) and
      compareDeep(pointsElement, o.pointsElement, true) and compareDeep(netElement, o.netElement, true);
  end;
end;

function TFhirContractTermValuedItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FEntity) and isEmptyProp(FIdentifier) and isEmptyProp(FEffectiveTime) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FPoints) and isEmptyProp(FNet);
end;

procedure TFhirContractTermValuedItem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('entity[x]');
  fields.add('identifier');
  fields.add('effectiveTime');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('points');
  fields.add('net');
end;

{ TFhirContractTermValuedItem }

Procedure TFhirContractTermValuedItem.SetEntity(value : TFhirType);
begin
  FEntity.free;
  FEntity := value;
end;

Procedure TFhirContractTermValuedItem.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirContractTermValuedItem.SetEffectiveTime(value : TFhirDateTime);
begin
  FEffectiveTime.free;
  FEffectiveTime := value;
end;

Function TFhirContractTermValuedItem.GetEffectiveTimeST : TFslDateTime;
begin
  if FEffectiveTime = nil then
    result := TFslDateTime.makeNull
  else
    result := FEffectiveTime.value;
end;

Procedure TFhirContractTermValuedItem.SetEffectiveTimeST(value : TFslDateTime);
begin
  if FEffectiveTime = nil then
    FEffectiveTime := TFhirDateTime.create;
  FEffectiveTime.value := value
end;

Procedure TFhirContractTermValuedItem.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirContractTermValuedItem.SetUnitPrice(value : TFhirQuantity);
begin
  FUnitPrice.free;
  FUnitPrice := value;
end;

Procedure TFhirContractTermValuedItem.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

Function TFhirContractTermValuedItem.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

Procedure TFhirContractTermValuedItem.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

Procedure TFhirContractTermValuedItem.SetPoints(value : TFhirDecimal);
begin
  FPoints.free;
  FPoints := value;
end;

Function TFhirContractTermValuedItem.GetPointsST : String;
begin
  if FPoints = nil then
    result := ''
  else
    result := FPoints.value;
end;

Procedure TFhirContractTermValuedItem.SetPointsST(value : String);
begin
  if value <> '' then
  begin
    if FPoints = nil then
      FPoints := TFhirDecimal.create;
    FPoints.value := value
  end
  else if FPoints <> nil then
    FPoints.value := '';
end;

Procedure TFhirContractTermValuedItem.SetNet(value : TFhirQuantity);
begin
  FNet.free;
  FNet := value;
end;

function TFhirContractTermValuedItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FEntity.sizeInBytes);
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FEffectiveTime.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FUnitPrice.sizeInBytes);
  inc(result, FFactor.sizeInBytes);
  inc(result, FPoints.sizeInBytes);
  inc(result, FNet.sizeInBytes);
end;

{ TFhirContractTermValuedItemListEnumerator }

Constructor TFhirContractTermValuedItemListEnumerator.Create(list : TFhirContractTermValuedItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractTermValuedItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractTermValuedItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractTermValuedItemListEnumerator.GetCurrent : TFhirContractTermValuedItem;
begin
  Result := FList[FIndex];
end;

function TFhirContractTermValuedItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirContractTermValuedItemList }
procedure TFhirContractTermValuedItemList.AddItem(value: TFhirContractTermValuedItem);
begin
  assert(value.ClassName = 'TFhirContractTermValuedItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractTermValuedItem');
  add(value);
end;

function TFhirContractTermValuedItemList.Append: TFhirContractTermValuedItem;
begin
  result := TFhirContractTermValuedItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermValuedItemList.ClearItems;
begin
  Clear;
end;

function TFhirContractTermValuedItemList.GetEnumerator : TFhirContractTermValuedItemListEnumerator;
begin
  result := TFhirContractTermValuedItemListEnumerator.Create(self.link);
end;

function TFhirContractTermValuedItemList.Clone: TFhirContractTermValuedItemList;
begin
  result := TFhirContractTermValuedItemList(inherited Clone);
end;

function TFhirContractTermValuedItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractTermValuedItemList.GetItemN(index: Integer): TFhirContractTermValuedItem;
begin
  result := TFhirContractTermValuedItem(ObjectByIndex[index]);
end;

function TFhirContractTermValuedItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractTermValuedItem;
end;
function TFhirContractTermValuedItemList.IndexOf(value: TFhirContractTermValuedItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractTermValuedItemList.Insert(index: Integer): TFhirContractTermValuedItem;
begin
  result := TFhirContractTermValuedItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermValuedItemList.InsertItem(index: Integer; value: TFhirContractTermValuedItem);
begin
  assert(value is TFhirContractTermValuedItem);
  Inherited Insert(index, value);
end;

function TFhirContractTermValuedItemList.Item(index: Integer): TFhirContractTermValuedItem;
begin
  result := TFhirContractTermValuedItem(ObjectByIndex[index]);
end;

function TFhirContractTermValuedItemList.Link: TFhirContractTermValuedItemList;
begin
  result := TFhirContractTermValuedItemList(inherited Link);
end;

procedure TFhirContractTermValuedItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractTermValuedItemList.SetItemByIndex(index: Integer; value: TFhirContractTermValuedItem);
begin
  assert(value is TFhirContractTermValuedItem);
  FhirContractTermValuedItems[index] := value;
end;

procedure TFhirContractTermValuedItemList.SetItemN(index: Integer; value: TFhirContractTermValuedItem);
begin
  assert(value is TFhirContractTermValuedItem);
  ObjectByIndex[index] := value;
end;

{ TFhirContractFriendly }

constructor TFhirContractFriendly.Create;
begin
  inherited;
end;

destructor TFhirContractFriendly.Destroy;
begin
  FContent.free;
  inherited;
end;

procedure TFhirContractFriendly.Assign(oSource : TFslObject);
begin
  inherited;
  content := TFhirContractFriendly(oSource).content.Clone;
end;

procedure TFhirContractFriendly.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'content[x]') or (child_name = 'content') Then
     list.add(self.link, 'content[x]', FContent.Link);
end;

procedure TFhirContractFriendly.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'content[x]', 'Attachment|Reference(Composition|DocumentReference|QuestionnaireResponse)', false, TFhirType, FContent.Link));{2}
end;

function TFhirContractFriendly.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then
  begin
    Content := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractFriendly.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirContractFriendly.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then raise EFHIRException.create('Cannot make property Content'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractFriendly.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'content[x]') then result := 'Attachment|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractFriendly.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then ContentElement := nil{4x}
  else
  inherited deleteProperty(propName, value);
end;

procedure TFhirContractFriendly.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then ContentElement := new as TFhirType{4x}
  else
  inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractFriendly.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirContractFriendly.fhirType : string;
begin
  result := 'friendly';
end;

function TFhirContractFriendly.Link : TFhirContractFriendly;
begin
  result := TFhirContractFriendly(inherited Link);
end;

function TFhirContractFriendly.Clone : TFhirContractFriendly;
begin
  result := TFhirContractFriendly(inherited Clone);
end;

function TFhirContractFriendly.equals(other : TObject) : boolean;
var
  o : TFhirContractFriendly;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractFriendly)) then
    result := false
  else
  begin
    o := TFhirContractFriendly(other);
    result := compareDeep(contentElement, o.contentElement, true);
  end;
end;

function TFhirContractFriendly.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FContent);
end;

procedure TFhirContractFriendly.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('content[x]');
end;

{ TFhirContractFriendly }

Procedure TFhirContractFriendly.SetContent(value : TFhirType);
begin
  FContent.free;
  FContent := value;
end;

function TFhirContractFriendly.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FContent.sizeInBytes);
end;

{ TFhirContractFriendlyListEnumerator }

Constructor TFhirContractFriendlyListEnumerator.Create(list : TFhirContractFriendlyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractFriendlyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractFriendlyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractFriendlyListEnumerator.GetCurrent : TFhirContractFriendly;
begin
  Result := FList[FIndex];
end;

function TFhirContractFriendlyListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirContractFriendlyList }
procedure TFhirContractFriendlyList.AddItem(value: TFhirContractFriendly);
begin
  assert(value.ClassName = 'TFhirContractFriendly', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractFriendly');
  add(value);
end;

function TFhirContractFriendlyList.Append: TFhirContractFriendly;
begin
  result := TFhirContractFriendly.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractFriendlyList.ClearItems;
begin
  Clear;
end;

function TFhirContractFriendlyList.GetEnumerator : TFhirContractFriendlyListEnumerator;
begin
  result := TFhirContractFriendlyListEnumerator.Create(self.link);
end;

function TFhirContractFriendlyList.Clone: TFhirContractFriendlyList;
begin
  result := TFhirContractFriendlyList(inherited Clone);
end;

function TFhirContractFriendlyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractFriendlyList.GetItemN(index: Integer): TFhirContractFriendly;
begin
  result := TFhirContractFriendly(ObjectByIndex[index]);
end;

function TFhirContractFriendlyList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractFriendly;
end;
function TFhirContractFriendlyList.IndexOf(value: TFhirContractFriendly): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractFriendlyList.Insert(index: Integer): TFhirContractFriendly;
begin
  result := TFhirContractFriendly.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractFriendlyList.InsertItem(index: Integer; value: TFhirContractFriendly);
begin
  assert(value is TFhirContractFriendly);
  Inherited Insert(index, value);
end;

function TFhirContractFriendlyList.Item(index: Integer): TFhirContractFriendly;
begin
  result := TFhirContractFriendly(ObjectByIndex[index]);
end;

function TFhirContractFriendlyList.Link: TFhirContractFriendlyList;
begin
  result := TFhirContractFriendlyList(inherited Link);
end;

procedure TFhirContractFriendlyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractFriendlyList.SetItemByIndex(index: Integer; value: TFhirContractFriendly);
begin
  assert(value is TFhirContractFriendly);
  FhirContractFriendlies[index] := value;
end;

procedure TFhirContractFriendlyList.SetItemN(index: Integer; value: TFhirContractFriendly);
begin
  assert(value is TFhirContractFriendly);
  ObjectByIndex[index] := value;
end;

{ TFhirContractLegal }

constructor TFhirContractLegal.Create;
begin
  inherited;
end;

destructor TFhirContractLegal.Destroy;
begin
  FContent.free;
  inherited;
end;

procedure TFhirContractLegal.Assign(oSource : TFslObject);
begin
  inherited;
  content := TFhirContractLegal(oSource).content.Clone;
end;

procedure TFhirContractLegal.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'content[x]') or (child_name = 'content') Then
     list.add(self.link, 'content[x]', FContent.Link);
end;

procedure TFhirContractLegal.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'content[x]', 'Attachment|Reference(Composition|DocumentReference|QuestionnaireResponse)', false, TFhirType, FContent.Link));{2}
end;

function TFhirContractLegal.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then
  begin
    Content := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractLegal.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirContractLegal.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then raise EFHIRException.create('Cannot make property Content'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractLegal.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'content[x]') then result := 'Attachment|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractLegal.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then ContentElement := nil{4x}
  else
  inherited deleteProperty(propName, value);
end;

procedure TFhirContractLegal.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then ContentElement := new as TFhirType{4x}
  else
  inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractLegal.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirContractLegal.fhirType : string;
begin
  result := 'legal';
end;

function TFhirContractLegal.Link : TFhirContractLegal;
begin
  result := TFhirContractLegal(inherited Link);
end;

function TFhirContractLegal.Clone : TFhirContractLegal;
begin
  result := TFhirContractLegal(inherited Clone);
end;

function TFhirContractLegal.equals(other : TObject) : boolean;
var
  o : TFhirContractLegal;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractLegal)) then
    result := false
  else
  begin
    o := TFhirContractLegal(other);
    result := compareDeep(contentElement, o.contentElement, true);
  end;
end;

function TFhirContractLegal.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FContent);
end;

procedure TFhirContractLegal.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('content[x]');
end;

{ TFhirContractLegal }

Procedure TFhirContractLegal.SetContent(value : TFhirType);
begin
  FContent.free;
  FContent := value;
end;

function TFhirContractLegal.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FContent.sizeInBytes);
end;

{ TFhirContractLegalListEnumerator }

Constructor TFhirContractLegalListEnumerator.Create(list : TFhirContractLegalList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractLegalListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractLegalListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractLegalListEnumerator.GetCurrent : TFhirContractLegal;
begin
  Result := FList[FIndex];
end;

function TFhirContractLegalListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirContractLegalList }
procedure TFhirContractLegalList.AddItem(value: TFhirContractLegal);
begin
  assert(value.ClassName = 'TFhirContractLegal', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractLegal');
  add(value);
end;

function TFhirContractLegalList.Append: TFhirContractLegal;
begin
  result := TFhirContractLegal.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractLegalList.ClearItems;
begin
  Clear;
end;

function TFhirContractLegalList.GetEnumerator : TFhirContractLegalListEnumerator;
begin
  result := TFhirContractLegalListEnumerator.Create(self.link);
end;

function TFhirContractLegalList.Clone: TFhirContractLegalList;
begin
  result := TFhirContractLegalList(inherited Clone);
end;

function TFhirContractLegalList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractLegalList.GetItemN(index: Integer): TFhirContractLegal;
begin
  result := TFhirContractLegal(ObjectByIndex[index]);
end;

function TFhirContractLegalList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractLegal;
end;
function TFhirContractLegalList.IndexOf(value: TFhirContractLegal): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractLegalList.Insert(index: Integer): TFhirContractLegal;
begin
  result := TFhirContractLegal.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractLegalList.InsertItem(index: Integer; value: TFhirContractLegal);
begin
  assert(value is TFhirContractLegal);
  Inherited Insert(index, value);
end;

function TFhirContractLegalList.Item(index: Integer): TFhirContractLegal;
begin
  result := TFhirContractLegal(ObjectByIndex[index]);
end;

function TFhirContractLegalList.Link: TFhirContractLegalList;
begin
  result := TFhirContractLegalList(inherited Link);
end;

procedure TFhirContractLegalList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractLegalList.SetItemByIndex(index: Integer; value: TFhirContractLegal);
begin
  assert(value is TFhirContractLegal);
  FhirContractLegals[index] := value;
end;

procedure TFhirContractLegalList.SetItemN(index: Integer; value: TFhirContractLegal);
begin
  assert(value is TFhirContractLegal);
  ObjectByIndex[index] := value;
end;

{ TFhirContractRule }

constructor TFhirContractRule.Create;
begin
  inherited;
end;

destructor TFhirContractRule.Destroy;
begin
  FContent.free;
  inherited;
end;

procedure TFhirContractRule.Assign(oSource : TFslObject);
begin
  inherited;
  content := TFhirContractRule(oSource).content.Clone;
end;

procedure TFhirContractRule.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'content[x]') or (child_name = 'content') Then
     list.add(self.link, 'content[x]', FContent.Link);
end;

procedure TFhirContractRule.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'content[x]', 'Attachment|Reference(DocumentReference)', false, TFhirType, FContent.Link));{2}
end;

function TFhirContractRule.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then
  begin
    Content := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractRule.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirContractRule.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then raise EFHIRException.create('Cannot make property Content'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractRule.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'content[x]') then result := 'Attachment|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractRule.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then ContentElement := nil{4x}
  else
  inherited deleteProperty(propName, value);
end;

procedure TFhirContractRule.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then ContentElement := new as TFhirType{4x}
  else
  inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractRule.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirContractRule.fhirType : string;
begin
  result := 'rule';
end;

function TFhirContractRule.Link : TFhirContractRule;
begin
  result := TFhirContractRule(inherited Link);
end;

function TFhirContractRule.Clone : TFhirContractRule;
begin
  result := TFhirContractRule(inherited Clone);
end;

function TFhirContractRule.equals(other : TObject) : boolean;
var
  o : TFhirContractRule;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractRule)) then
    result := false
  else
  begin
    o := TFhirContractRule(other);
    result := compareDeep(contentElement, o.contentElement, true);
  end;
end;

function TFhirContractRule.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FContent);
end;

procedure TFhirContractRule.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('content[x]');
end;

{ TFhirContractRule }

Procedure TFhirContractRule.SetContent(value : TFhirType);
begin
  FContent.free;
  FContent := value;
end;

function TFhirContractRule.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FContent.sizeInBytes);
end;

{ TFhirContractRuleListEnumerator }

Constructor TFhirContractRuleListEnumerator.Create(list : TFhirContractRuleList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractRuleListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractRuleListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractRuleListEnumerator.GetCurrent : TFhirContractRule;
begin
  Result := FList[FIndex];
end;

function TFhirContractRuleListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirContractRuleList }
procedure TFhirContractRuleList.AddItem(value: TFhirContractRule);
begin
  assert(value.ClassName = 'TFhirContractRule', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractRule');
  add(value);
end;

function TFhirContractRuleList.Append: TFhirContractRule;
begin
  result := TFhirContractRule.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractRuleList.ClearItems;
begin
  Clear;
end;

function TFhirContractRuleList.GetEnumerator : TFhirContractRuleListEnumerator;
begin
  result := TFhirContractRuleListEnumerator.Create(self.link);
end;

function TFhirContractRuleList.Clone: TFhirContractRuleList;
begin
  result := TFhirContractRuleList(inherited Clone);
end;

function TFhirContractRuleList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractRuleList.GetItemN(index: Integer): TFhirContractRule;
begin
  result := TFhirContractRule(ObjectByIndex[index]);
end;

function TFhirContractRuleList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractRule;
end;
function TFhirContractRuleList.IndexOf(value: TFhirContractRule): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractRuleList.Insert(index: Integer): TFhirContractRule;
begin
  result := TFhirContractRule.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractRuleList.InsertItem(index: Integer; value: TFhirContractRule);
begin
  assert(value is TFhirContractRule);
  Inherited Insert(index, value);
end;

function TFhirContractRuleList.Item(index: Integer): TFhirContractRule;
begin
  result := TFhirContractRule(ObjectByIndex[index]);
end;

function TFhirContractRuleList.Link: TFhirContractRuleList;
begin
  result := TFhirContractRuleList(inherited Link);
end;

procedure TFhirContractRuleList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractRuleList.SetItemByIndex(index: Integer; value: TFhirContractRule);
begin
  assert(value is TFhirContractRule);
  FhirContractRules[index] := value;
end;

procedure TFhirContractRuleList.SetItemN(index: Integer; value: TFhirContractRule);
begin
  assert(value is TFhirContractRule);
  ObjectByIndex[index] := value;
end;

{ TFhirContract }

constructor TFhirContract.Create;
begin
  inherited;
end;

destructor TFhirContract.Destroy;
begin
  FIdentifier.free;
  FIssued.free;
  FApplies.free;
  FSubjectList.Free;
  FAuthorityList.Free;
  FDomainList.Free;
  FType_.free;
  FSubTypeList.Free;
  FActionList.Free;
  FActionReasonList.Free;
  FActorList.Free;
  FValuedItemList.Free;
  FSignerList.Free;
  FTermList.Free;
  FBinding.free;
  FFriendlyList.Free;
  FLegalList.Free;
  FRuleList.Free;
  inherited;
end;

function TFhirContract.GetResourceType : TFhirResourceType;
begin
  result := frtContract;
end;

procedure TFhirContract.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirContract(oSource).identifier.Clone;
  issuedElement := TFhirContract(oSource).issuedElement.Clone;
  applies := TFhirContract(oSource).applies.Clone;
  if (TFhirContract(oSource).FSubjectList = nil) then
  begin
    FSubjectList.free;
    FSubjectList := nil;
  end
  else
  begin
    if FSubjectList = nil then
      FSubjectList := TFhirReferenceList{TFhirReference}.Create;
    FSubjectList.Assign(TFhirContract(oSource).FSubjectList);
  end;
  if (TFhirContract(oSource).FAuthorityList = nil) then
  begin
    FAuthorityList.free;
    FAuthorityList := nil;
  end
  else
  begin
    if FAuthorityList = nil then
      FAuthorityList := TFhirReferenceList{TFhirOrganization}.Create;
    FAuthorityList.Assign(TFhirContract(oSource).FAuthorityList);
  end;
  if (TFhirContract(oSource).FDomainList = nil) then
  begin
    FDomainList.free;
    FDomainList := nil;
  end
  else
  begin
    if FDomainList = nil then
      FDomainList := TFhirReferenceList{TFhirLocation}.Create;
    FDomainList.Assign(TFhirContract(oSource).FDomainList);
  end;
  type_ := TFhirContract(oSource).type_.Clone;
  if (TFhirContract(oSource).FSubTypeList = nil) then
  begin
    FSubTypeList.free;
    FSubTypeList := nil;
  end
  else
  begin
    if FSubTypeList = nil then
      FSubTypeList := TFhirCodeableConceptList.Create;
    FSubTypeList.Assign(TFhirContract(oSource).FSubTypeList);
  end;
  if (TFhirContract(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirCodeableConceptList.Create;
    FActionList.Assign(TFhirContract(oSource).FActionList);
  end;
  if (TFhirContract(oSource).FActionReasonList = nil) then
  begin
    FActionReasonList.free;
    FActionReasonList := nil;
  end
  else
  begin
    if FActionReasonList = nil then
      FActionReasonList := TFhirCodeableConceptList.Create;
    FActionReasonList.Assign(TFhirContract(oSource).FActionReasonList);
  end;
  if (TFhirContract(oSource).FActorList = nil) then
  begin
    FActorList.free;
    FActorList := nil;
  end
  else
  begin
    if FActorList = nil then
      FActorList := TFhirContractActorList.Create;
    FActorList.Assign(TFhirContract(oSource).FActorList);
  end;
  if (TFhirContract(oSource).FValuedItemList = nil) then
  begin
    FValuedItemList.free;
    FValuedItemList := nil;
  end
  else
  begin
    if FValuedItemList = nil then
      FValuedItemList := TFhirContractValuedItemList.Create;
    FValuedItemList.Assign(TFhirContract(oSource).FValuedItemList);
  end;
  if (TFhirContract(oSource).FSignerList = nil) then
  begin
    FSignerList.free;
    FSignerList := nil;
  end
  else
  begin
    if FSignerList = nil then
      FSignerList := TFhirContractSignerList.Create;
    FSignerList.Assign(TFhirContract(oSource).FSignerList);
  end;
  if (TFhirContract(oSource).FTermList = nil) then
  begin
    FTermList.free;
    FTermList := nil;
  end
  else
  begin
    if FTermList = nil then
      FTermList := TFhirContractTermList.Create;
    FTermList.Assign(TFhirContract(oSource).FTermList);
  end;
  binding := TFhirContract(oSource).binding.Clone;
  if (TFhirContract(oSource).FFriendlyList = nil) then
  begin
    FFriendlyList.free;
    FFriendlyList := nil;
  end
  else
  begin
    if FFriendlyList = nil then
      FFriendlyList := TFhirContractFriendlyList.Create;
    FFriendlyList.Assign(TFhirContract(oSource).FFriendlyList);
  end;
  if (TFhirContract(oSource).FLegalList = nil) then
  begin
    FLegalList.free;
    FLegalList := nil;
  end
  else
  begin
    if FLegalList = nil then
      FLegalList := TFhirContractLegalList.Create;
    FLegalList.Assign(TFhirContract(oSource).FLegalList);
  end;
  if (TFhirContract(oSource).FRuleList = nil) then
  begin
    FRuleList.free;
    FRuleList := nil;
  end
  else
  begin
    if FRuleList = nil then
      FRuleList := TFhirContractRuleList.Create;
    FRuleList.Assign(TFhirContract(oSource).FRuleList);
  end;
end;

procedure TFhirContract.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'issued') Then
     list.add(self.link, 'issued', FIssued.Link);
  if (child_name = 'applies') Then
     list.add(self.link, 'applies', FApplies.Link);
  if (child_name = 'subject') Then
    list.addAll(self, 'subject', FSubjectList);
  if (child_name = 'authority') Then
    list.addAll(self, 'authority', FAuthorityList);
  if (child_name = 'domain') Then
    list.addAll(self, 'domain', FDomainList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subType') Then
    list.addAll(self, 'subType', FSubTypeList);
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
  if (child_name = 'actionReason') Then
    list.addAll(self, 'actionReason', FActionReasonList);
  if (child_name = 'actor') Then
    list.addAll(self, 'actor', FActorList);
  if (child_name = 'valuedItem') Then
    list.addAll(self, 'valuedItem', FValuedItemList);
  if (child_name = 'signer') Then
    list.addAll(self, 'signer', FSignerList);
  if (child_name = 'term') Then
    list.addAll(self, 'term', FTermList);
  if (child_name = 'binding[x]') or (child_name = 'binding') Then
     list.add(self.link, 'binding[x]', FBinding.Link);
  if (child_name = 'friendly') Then
    list.addAll(self, 'friendly', FFriendlyList);
  if (child_name = 'legal') Then
    list.addAll(self, 'legal', FLegalList);
  if (child_name = 'rule') Then
    list.addAll(self, 'rule', FRuleList);
end;

procedure TFhirContract.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'issued', 'dateTime', false, TFhirDateTime, FIssued.Link));{2}
  oList.add(TFHIRProperty.create(self, 'applies', 'Period', false, TFhirPeriod, FApplies.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Any)', true, TFhirReference{TFhirReference}, FSubjectList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'authority', 'Reference(Organization)', true, TFhirReference{TFhirOrganization}, FAuthorityList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'domain', 'Reference(Location)', true, TFhirReference{TFhirLocation}, FDomainList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subType', 'CodeableConcept', true, TFhirCodeableConcept, FSubTypeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'action', 'CodeableConcept', true, TFhirCodeableConcept, FActionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'actionReason', 'CodeableConcept', true, TFhirCodeableConcept, FActionReasonList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'actor', '', true, TFhirContractActor, FActorList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'valuedItem', '', true, TFhirContractValuedItem, FValuedItemList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'signer', '', true, TFhirContractSigner, FSignerList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'term', '', true, TFhirContractTerm, FTermList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'binding[x]', 'Attachment|Reference(Composition|DocumentReference|QuestionnaireResponse)', false, TFhirType, FBinding.Link));{2}
  oList.add(TFHIRProperty.create(self, 'friendly', '', true, TFhirContractFriendly, FFriendlyList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'legal', '', true, TFhirContractLegal, FLegalList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'rule', '', true, TFhirContractRule, FRuleList.Link)){3};
end;

function TFhirContract.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'issued') then
  begin
    IssuedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'applies') then
  begin
    Applies := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    SubjectList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'authority') then
  begin
    AuthorityList.add(propValue as TFhirReference{TFhirOrganization}){2a};
    result := propValue;
  end
  else if (propName = 'domain') then
  begin
    DomainList.add(propValue as TFhirReference{TFhirLocation}){2a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subType') then
  begin
    SubTypeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'actionReason') then
  begin
    ActionReasonList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    ActorList.add(propValue as TFhirContractActor){2a};
    result := propValue;
  end
  else if (propName = 'valuedItem') then
  begin
    ValuedItemList.add(propValue as TFhirContractValuedItem){2a};
    result := propValue;
  end
  else if (propName = 'signer') then
  begin
    SignerList.add(propValue as TFhirContractSigner){2a};
    result := propValue;
  end
  else if (propName = 'term') then
  begin
    TermList.add(propValue as TFhirContractTerm){2a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'binding', ['Attachment', 'Reference'])) then
  begin
    Binding := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'friendly') then
  begin
    FriendlyList.add(propValue as TFhirContractFriendly){2a};
    result := propValue;
  end
  else if (propName = 'legal') then
  begin
    LegalList.add(propValue as TFhirContractLegal){2a};
    result := propValue;
  end
  else if (propName = 'rule') then
  begin
    RuleList.add(propValue as TFhirContractRule){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirContract.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'subject') then SubjectList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'authority') then AuthorityList.insertItem(index, propValue as TFhirReference{TFhirOrganization}){2a}
  else if (propName = 'domain') then DomainList.insertItem(index, propValue as TFhirReference{TFhirLocation}){2a}
  else if (propName = 'subType') then SubTypeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'actionReason') then ActionReasonList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'actor') then ActorList.insertItem(index, propValue as TFhirContractActor){2a}
  else if (propName = 'valuedItem') then ValuedItemList.insertItem(index, propValue as TFhirContractValuedItem){2a}
  else if (propName = 'signer') then SignerList.insertItem(index, propValue as TFhirContractSigner){2a}
  else if (propName = 'term') then TermList.insertItem(index, propValue as TFhirContractTerm){2a}
  else if (propName = 'friendly') then FriendlyList.insertItem(index, propValue as TFhirContractFriendly){2a}
  else if (propName = 'legal') then LegalList.insertItem(index, propValue as TFhirContractLegal){2a}
  else if (propName = 'rule') then RuleList.insertItem(index, propValue as TFhirContractRule){2a}
  else inherited;
end;

function TFhirContract.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'issued') then result := TFhirDateTime.create() {5b}
  else if (propName = 'applies') then result := TFhirPeriod.create(){4b}
  else if (propName = 'subject') then result := SubjectList.new(){2}
  else if (propName = 'authority') then result := AuthorityList.new(){2}
  else if (propName = 'domain') then result := DomainList.new(){2}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subType') then result := SubTypeList.new(){2}
  else if (propName = 'action') then result := ActionList.new(){2}
  else if (propName = 'actionReason') then result := ActionReasonList.new(){2}
  else if (propName = 'actor') then result := ActorList.new(){2}
  else if (propName = 'valuedItem') then result := ValuedItemList.new(){2}
  else if (propName = 'signer') then result := SignerList.new(){2}
  else if (propName = 'term') then result := TermList.new(){2}
  else if (isMatchingName(propName, 'binding', ['Attachment', 'Reference'])) then raise EFHIRException.create('Cannot make property Binding'){4x}
  else if (propName = 'friendly') then result := FriendlyList.new(){2}
  else if (propName = 'legal') then result := LegalList.new(){2}
  else if (propName = 'rule') then result := RuleList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirContract.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'issued') then result := 'dateTime'
  else if (propName = 'applies') then result := 'Period'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'authority') then result := 'Reference'
  else if (propName = 'domain') then result := 'Reference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'subType') then result := 'CodeableConcept'
  else if (propName = 'action') then result := 'CodeableConcept'
  else if (propName = 'actionReason') then result := 'CodeableConcept'
  else if (propName = 'actor') then result := ''
  else if (propName = 'valuedItem') then result := ''
  else if (propName = 'signer') then result := ''
  else if (propName = 'term') then result := ''
  else if (propName = 'binding[x]') then result := 'Attachment|Reference'
  else if (propName = 'friendly') then result := ''
  else if (propName = 'legal') then result := ''
  else if (propName = 'rule') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContract.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'issued') then IssuedElement := nil
  else if (propName = 'applies') then AppliesElement := nil
  else if (propName = 'subject') then deletePropertyValue('subject', SubjectList, value) {2}
  else if (propName = 'authority') then deletePropertyValue('authority', AuthorityList, value) {2}
  else if (propName = 'domain') then deletePropertyValue('domain', DomainList, value) {2}
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'subType') then deletePropertyValue('subType', SubTypeList, value) {2}
  else if (propName = 'action') then deletePropertyValue('action', ActionList, value) {2}
  else if (propName = 'actionReason') then deletePropertyValue('actionReason', ActionReasonList, value) {2}
  else if (propName = 'actor') then deletePropertyValue('actor', ActorList, value) {2}
  else if (propName = 'valuedItem') then deletePropertyValue('valuedItem', ValuedItemList, value) {2}
  else if (propName = 'signer') then deletePropertyValue('signer', SignerList, value) {2}
  else if (propName = 'term') then deletePropertyValue('term', TermList, value) {2}
  else if (isMatchingName(propName, 'binding', ['Attachment', 'Reference'])) then BindingElement := nil{4x}
  else if (propName = 'friendly') then deletePropertyValue('friendly', FriendlyList, value) {2}
  else if (propName = 'legal') then deletePropertyValue('legal', LegalList, value) {2}
  else if (propName = 'rule') then deletePropertyValue('rule', RuleList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContract.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'issued') then IssuedElement := asDateTime(new){5b}
  else if (propName = 'applies') then AppliesElement := new as TFhirPeriod{4}
  else if (propName = 'subject') then replacePropertyValue('subject', SubjectList, existing, new) {2}
  else if (propName = 'authority') then replacePropertyValue('authority', AuthorityList, existing, new) {2}
  else if (propName = 'domain') then replacePropertyValue('domain', DomainList, existing, new) {2}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'subType') then replacePropertyValue('subType', SubTypeList, existing, new) {2}
  else if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new) {2}
  else if (propName = 'actionReason') then replacePropertyValue('actionReason', ActionReasonList, existing, new) {2}
  else if (propName = 'actor') then replacePropertyValue('actor', ActorList, existing, new) {2}
  else if (propName = 'valuedItem') then replacePropertyValue('valuedItem', ValuedItemList, existing, new) {2}
  else if (propName = 'signer') then replacePropertyValue('signer', SignerList, existing, new) {2}
  else if (propName = 'term') then replacePropertyValue('term', TermList, existing, new) {2}
  else if (isMatchingName(propName, 'binding', ['Attachment', 'Reference'])) then BindingElement := new as TFhirType{4x}
  else if (propName = 'friendly') then replacePropertyValue('friendly', FriendlyList, existing, new) {2}
  else if (propName = 'legal') then replacePropertyValue('legal', LegalList, existing, new) {2}
  else if (propName = 'rule') then replacePropertyValue('rule', RuleList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContract.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'subject') then SubjectList.move(source, destination){2a}
  else if (propName = 'authority') then AuthorityList.move(source, destination){2a}
  else if (propName = 'domain') then DomainList.move(source, destination){2a}
  else if (propName = 'subType') then SubTypeList.move(source, destination){2a}
  else if (propName = 'action') then ActionList.move(source, destination){2a}
  else if (propName = 'actionReason') then ActionReasonList.move(source, destination){2a}
  else if (propName = 'actor') then ActorList.move(source, destination){2a}
  else if (propName = 'valuedItem') then ValuedItemList.move(source, destination){2a}
  else if (propName = 'signer') then SignerList.move(source, destination){2a}
  else if (propName = 'term') then TermList.move(source, destination){2a}
  else if (propName = 'friendly') then FriendlyList.move(source, destination){2a}
  else if (propName = 'legal') then LegalList.move(source, destination){2a}
  else if (propName = 'rule') then RuleList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContract.fhirType : string;
begin
  result := 'Contract';
end;

function TFhirContract.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FIssued) and isEmptyProp(FApplies) and isEmptyProp(FsubjectList) and isEmptyProp(FauthorityList) and isEmptyProp(FdomainList) and isEmptyProp(FType_) and isEmptyProp(FsubTypeList) and isEmptyProp(FactionList) and isEmptyProp(FactionReasonList) and isEmptyProp(FactorList) and isEmptyProp(FvaluedItemList) and isEmptyProp(FsignerList) and isEmptyProp(FtermList) and isEmptyProp(FBinding) and isEmptyProp(FfriendlyList) and isEmptyProp(FlegalList) and isEmptyProp(FruleList);
end;

function TFhirContract.equals(other : TObject) : boolean;
var
  o : TFhirContract;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContract)) then
    result := false
  else
  begin
    o := TFhirContract(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(issuedElement, o.issuedElement, true) and
      compareDeep(appliesElement, o.appliesElement, true) and compareDeep(subjectList, o.subjectList, true) and
      compareDeep(authorityList, o.authorityList, true) and compareDeep(domainList, o.domainList, true) and
      compareDeep(type_Element, o.type_Element, true) and compareDeep(subTypeList, o.subTypeList, true) and
      compareDeep(actionList, o.actionList, true) and compareDeep(actionReasonList, o.actionReasonList, true) and
      compareDeep(actorList, o.actorList, true) and compareDeep(valuedItemList, o.valuedItemList, true) and
      compareDeep(signerList, o.signerList, true) and compareDeep(termList, o.termList, true) and
      compareDeep(bindingElement, o.bindingElement, true) and compareDeep(friendlyList, o.friendlyList, true) and
      compareDeep(legalList, o.legalList, true) and compareDeep(ruleList, o.ruleList, true);
  end;
end;

function TFhirContract.Link : TFhirContract;
begin
  result := TFhirContract(inherited Link);
end;

function TFhirContract.Clone : TFhirContract;
begin
  result := TFhirContract(inherited Clone);
end;

procedure TFhirContract.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('issued');
  fields.add('applies');
  fields.add('subject');
  fields.add('authority');
  fields.add('domain');
  fields.add('type');
  fields.add('subType');
  fields.add('action');
  fields.add('actionReason');
  fields.add('actor');
  fields.add('valuedItem');
  fields.add('signer');
  fields.add('term');
  fields.add('binding[x]');
  fields.add('friendly');
  fields.add('legal');
  fields.add('rule');
end;

{ TFhirContract }

Procedure TFhirContract.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirContract.SetIssued(value : TFhirDateTime);
begin
  FIssued.free;
  FIssued := value;
end;

Function TFhirContract.GetIssuedST : TFslDateTime;
begin
  if FIssued = nil then
    result := TFslDateTime.makeNull
  else
    result := FIssued.value;
end;

Procedure TFhirContract.SetIssuedST(value : TFslDateTime);
begin
  if FIssued = nil then
    FIssued := TFhirDateTime.create;
  FIssued.value := value
end;

Procedure TFhirContract.SetApplies(value : TFhirPeriod);
begin
  FApplies.free;
  FApplies := value;
end;

Function TFhirContract.GetSubjectList : TFhirReferenceList{TFhirReference};
begin
  if FSubjectList = nil then
    FSubjectList := TFhirReferenceList{TFhirReference}.Create;
  result := FSubjectList;
end;

Function TFhirContract.GetHasSubjectList : boolean;
begin
  result := (FSubjectList <> nil) and (FSubjectList.count > 0);
end;

Function TFhirContract.GetAuthorityList : TFhirReferenceList{TFhirOrganization};
begin
  if FAuthorityList = nil then
    FAuthorityList := TFhirReferenceList{TFhirOrganization}.Create;
  result := FAuthorityList;
end;

Function TFhirContract.GetHasAuthorityList : boolean;
begin
  result := (FAuthorityList <> nil) and (FAuthorityList.count > 0);
end;

Function TFhirContract.GetDomainList : TFhirReferenceList{TFhirLocation};
begin
  if FDomainList = nil then
    FDomainList := TFhirReferenceList{TFhirLocation}.Create;
  result := FDomainList;
end;

Function TFhirContract.GetHasDomainList : boolean;
begin
  result := (FDomainList <> nil) and (FDomainList.count > 0);
end;

Procedure TFhirContract.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirContract.GetSubTypeList : TFhirCodeableConceptList;
begin
  if FSubTypeList = nil then
    FSubTypeList := TFhirCodeableConceptList.Create;
  result := FSubTypeList;
end;

Function TFhirContract.GetHasSubTypeList : boolean;
begin
  result := (FSubTypeList <> nil) and (FSubTypeList.count > 0);
end;

Function TFhirContract.GetActionList : TFhirCodeableConceptList;
begin
  if FActionList = nil then
    FActionList := TFhirCodeableConceptList.Create;
  result := FActionList;
end;

Function TFhirContract.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

Function TFhirContract.GetActionReasonList : TFhirCodeableConceptList;
begin
  if FActionReasonList = nil then
    FActionReasonList := TFhirCodeableConceptList.Create;
  result := FActionReasonList;
end;

Function TFhirContract.GetHasActionReasonList : boolean;
begin
  result := (FActionReasonList <> nil) and (FActionReasonList.count > 0);
end;

Function TFhirContract.GetActorList : TFhirContractActorList;
begin
  if FActorList = nil then
    FActorList := TFhirContractActorList.Create;
  result := FActorList;
end;

Function TFhirContract.GetHasActorList : boolean;
begin
  result := (FActorList <> nil) and (FActorList.count > 0);
end;

Function TFhirContract.GetValuedItemList : TFhirContractValuedItemList;
begin
  if FValuedItemList = nil then
    FValuedItemList := TFhirContractValuedItemList.Create;
  result := FValuedItemList;
end;

Function TFhirContract.GetHasValuedItemList : boolean;
begin
  result := (FValuedItemList <> nil) and (FValuedItemList.count > 0);
end;

Function TFhirContract.GetSignerList : TFhirContractSignerList;
begin
  if FSignerList = nil then
    FSignerList := TFhirContractSignerList.Create;
  result := FSignerList;
end;

Function TFhirContract.GetHasSignerList : boolean;
begin
  result := (FSignerList <> nil) and (FSignerList.count > 0);
end;

Function TFhirContract.GetTermList : TFhirContractTermList;
begin
  if FTermList = nil then
    FTermList := TFhirContractTermList.Create;
  result := FTermList;
end;

Function TFhirContract.GetHasTermList : boolean;
begin
  result := (FTermList <> nil) and (FTermList.count > 0);
end;

Procedure TFhirContract.SetBinding(value : TFhirType);
begin
  FBinding.free;
  FBinding := value;
end;

Function TFhirContract.GetFriendlyList : TFhirContractFriendlyList;
begin
  if FFriendlyList = nil then
    FFriendlyList := TFhirContractFriendlyList.Create;
  result := FFriendlyList;
end;

Function TFhirContract.GetHasFriendlyList : boolean;
begin
  result := (FFriendlyList <> nil) and (FFriendlyList.count > 0);
end;

Function TFhirContract.GetLegalList : TFhirContractLegalList;
begin
  if FLegalList = nil then
    FLegalList := TFhirContractLegalList.Create;
  result := FLegalList;
end;

Function TFhirContract.GetHasLegalList : boolean;
begin
  result := (FLegalList <> nil) and (FLegalList.count > 0);
end;

Function TFhirContract.GetRuleList : TFhirContractRuleList;
begin
  if FRuleList = nil then
    FRuleList := TFhirContractRuleList.Create;
  result := FRuleList;
end;

Function TFhirContract.GetHasRuleList : boolean;
begin
  result := (FRuleList <> nil) and (FRuleList.count > 0);
end;

function TFhirContract.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FIssued.sizeInBytes);
  inc(result, FApplies.sizeInBytes);
  inc(result, FsubjectList.sizeInBytes);
  inc(result, FauthorityList.sizeInBytes);
  inc(result, FdomainList.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FsubTypeList.sizeInBytes);
  inc(result, FactionList.sizeInBytes);
  inc(result, FactionReasonList.sizeInBytes);
  inc(result, FactorList.sizeInBytes);
  inc(result, FvaluedItemList.sizeInBytes);
  inc(result, FsignerList.sizeInBytes);
  inc(result, FtermList.sizeInBytes);
  inc(result, FBinding.sizeInBytes);
  inc(result, FfriendlyList.sizeInBytes);
  inc(result, FlegalList.sizeInBytes);
  inc(result, FruleList.sizeInBytes);
end;

{ TFhirContractListEnumerator }

Constructor TFhirContractListEnumerator.Create(list : TFhirContractList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractListEnumerator.GetCurrent : TFhirContract;
begin
  Result := FList[FIndex];
end;

function TFhirContractListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirContractList }
procedure TFhirContractList.AddItem(value: TFhirContract);
begin
  assert(value.ClassName = 'TFhirContract', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContract');
  add(value);
end;

function TFhirContractList.Append: TFhirContract;
begin
  result := TFhirContract.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractList.ClearItems;
begin
  Clear;
end;

function TFhirContractList.GetEnumerator : TFhirContractListEnumerator;
begin
  result := TFhirContractListEnumerator.Create(self.link);
end;

function TFhirContractList.Clone: TFhirContractList;
begin
  result := TFhirContractList(inherited Clone);
end;

function TFhirContractList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractList.GetItemN(index: Integer): TFhirContract;
begin
  result := TFhirContract(ObjectByIndex[index]);
end;

function TFhirContractList.ItemClass: TFslObjectClass;
begin
  result := TFhirContract;
end;
function TFhirContractList.IndexOf(value: TFhirContract): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractList.Insert(index: Integer): TFhirContract;
begin
  result := TFhirContract.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractList.InsertItem(index: Integer; value: TFhirContract);
begin
  assert(value is TFhirContract);
  Inherited Insert(index, value);
end;

function TFhirContractList.Item(index: Integer): TFhirContract;
begin
  result := TFhirContract(ObjectByIndex[index]);
end;

function TFhirContractList.Link: TFhirContractList;
begin
  result := TFhirContractList(inherited Link);
end;

procedure TFhirContractList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractList.SetItemByIndex(index: Integer; value: TFhirContract);
begin
  assert(value is TFhirContract);
  FhirContracts[index] := value;
end;

procedure TFhirContractList.SetItemN(index: Integer; value: TFhirContract);
begin
  assert(value is TFhirContract);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CONTRACT}

{$IFDEF FHIR_ELIGIBILITYREQUEST}

{ TFhirEligibilityRequest }

constructor TFhirEligibilityRequest.Create;
begin
  inherited;
end;

destructor TFhirEligibilityRequest.Destroy;
begin
  FIdentifierList.Free;
  FRuleset.free;
  FOriginalRuleset.free;
  FCreated.free;
  FTarget.free;
  FProvider.free;
  FOrganization.free;
  inherited;
end;

function TFhirEligibilityRequest.GetResourceType : TFhirResourceType;
begin
  result := frtEligibilityRequest;
end;

procedure TFhirEligibilityRequest.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirEligibilityRequest(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirEligibilityRequest(oSource).FIdentifierList);
  end;
  ruleset := TFhirEligibilityRequest(oSource).ruleset.Clone;
  originalRuleset := TFhirEligibilityRequest(oSource).originalRuleset.Clone;
  createdElement := TFhirEligibilityRequest(oSource).createdElement.Clone;
  target := TFhirEligibilityRequest(oSource).target.Clone;
  provider := TFhirEligibilityRequest(oSource).provider.Clone;
  organization := TFhirEligibilityRequest(oSource).organization.Clone;
end;

procedure TFhirEligibilityRequest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'ruleset') Then
     list.add(self.link, 'ruleset', FRuleset.Link);
  if (child_name = 'originalRuleset') Then
     list.add(self.link, 'originalRuleset', FOriginalRuleset.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'target') Then
     list.add(self.link, 'target', FTarget.Link);
  if (child_name = 'provider') Then
     list.add(self.link, 'provider', FProvider.Link);
  if (child_name = 'organization') Then
     list.add(self.link, 'organization', FOrganization.Link);
end;

procedure TFhirEligibilityRequest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'ruleset', 'Coding', false, TFhirCoding, FRuleset.Link));{2}
  oList.add(TFHIRProperty.create(self, 'originalRuleset', 'Coding', false, TFhirCoding, FOriginalRuleset.Link));{2}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));{2}
  oList.add(TFHIRProperty.create(self, 'target', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FTarget.Link));{2}
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FProvider.Link));{2}
  oList.add(TFHIRProperty.create(self, 'organization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FOrganization.Link));{2}
end;

function TFhirEligibilityRequest.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'ruleset') then
  begin
    Ruleset := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'originalRuleset') then
  begin
    OriginalRuleset := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'target') then
  begin
    Target := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'provider') then
  begin
    Provider := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'organization') then
  begin
    Organization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirEligibilityRequest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else inherited;
end;

function TFhirEligibilityRequest.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'ruleset') then result := TFhirCoding.create(){4b}
  else if (propName = 'originalRuleset') then result := TFhirCoding.create(){4b}
  else if (propName = 'created') then result := TFhirDateTime.create() {5b}
  else if (propName = 'target') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'provider') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'organization') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEligibilityRequest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'ruleset') then result := 'Coding'
  else if (propName = 'originalRuleset') then result := 'Coding'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'target') then result := 'Reference'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'organization') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEligibilityRequest.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'ruleset') then RulesetElement := nil
  else if (propName = 'originalRuleset') then OriginalRulesetElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'target') then TargetElement := nil
  else if (propName = 'provider') then ProviderElement := nil
  else if (propName = 'organization') then OrganizationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEligibilityRequest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'ruleset') then RulesetElement := new as TFhirCoding{4}
  else if (propName = 'originalRuleset') then OriginalRulesetElement := new as TFhirCoding{4}
  else if (propName = 'created') then CreatedElement := asDateTime(new){5b}
  else if (propName = 'target') then TargetElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'provider') then ProviderElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'organization') then OrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEligibilityRequest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEligibilityRequest.fhirType : string;
begin
  result := 'EligibilityRequest';
end;

function TFhirEligibilityRequest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FRuleset) and isEmptyProp(FOriginalRuleset) and isEmptyProp(FCreated) and isEmptyProp(FTarget) and isEmptyProp(FProvider) and isEmptyProp(FOrganization);
end;

function TFhirEligibilityRequest.equals(other : TObject) : boolean;
var
  o : TFhirEligibilityRequest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEligibilityRequest)) then
    result := false
  else
  begin
    o := TFhirEligibilityRequest(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(rulesetElement, o.rulesetElement, true) and
      compareDeep(originalRulesetElement, o.originalRulesetElement, true) and compareDeep(createdElement, o.createdElement, true) and
      compareDeep(targetElement, o.targetElement, true) and compareDeep(providerElement, o.providerElement, true) and
      compareDeep(organizationElement, o.organizationElement, true);
  end;
end;

function TFhirEligibilityRequest.Link : TFhirEligibilityRequest;
begin
  result := TFhirEligibilityRequest(inherited Link);
end;

function TFhirEligibilityRequest.Clone : TFhirEligibilityRequest;
begin
  result := TFhirEligibilityRequest(inherited Clone);
end;

procedure TFhirEligibilityRequest.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('ruleset');
  fields.add('originalRuleset');
  fields.add('created');
  fields.add('target');
  fields.add('provider');
  fields.add('organization');
end;

{ TFhirEligibilityRequest }

Function TFhirEligibilityRequest.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirEligibilityRequest.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirEligibilityRequest.SetRuleset(value : TFhirCoding);
begin
  FRuleset.free;
  FRuleset := value;
end;

Procedure TFhirEligibilityRequest.SetOriginalRuleset(value : TFhirCoding);
begin
  FOriginalRuleset.free;
  FOriginalRuleset := value;
end;

Procedure TFhirEligibilityRequest.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

Function TFhirEligibilityRequest.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

Procedure TFhirEligibilityRequest.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

Procedure TFhirEligibilityRequest.SetTarget(value : TFhirReference{TFhirOrganization});
begin
  FTarget.free;
  FTarget := value;
end;

Procedure TFhirEligibilityRequest.SetProvider(value : TFhirReference{TFhirPractitioner});
begin
  FProvider.free;
  FProvider := value;
end;

Procedure TFhirEligibilityRequest.SetOrganization(value : TFhirReference{TFhirOrganization});
begin
  FOrganization.free;
  FOrganization := value;
end;

function TFhirEligibilityRequest.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FRuleset.sizeInBytes);
  inc(result, FOriginalRuleset.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FTarget.sizeInBytes);
  inc(result, FProvider.sizeInBytes);
  inc(result, FOrganization.sizeInBytes);
end;

{ TFhirEligibilityRequestListEnumerator }

Constructor TFhirEligibilityRequestListEnumerator.Create(list : TFhirEligibilityRequestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEligibilityRequestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEligibilityRequestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEligibilityRequestListEnumerator.GetCurrent : TFhirEligibilityRequest;
begin
  Result := FList[FIndex];
end;

function TFhirEligibilityRequestListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirEligibilityRequestList }
procedure TFhirEligibilityRequestList.AddItem(value: TFhirEligibilityRequest);
begin
  assert(value.ClassName = 'TFhirEligibilityRequest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEligibilityRequest');
  add(value);
end;

function TFhirEligibilityRequestList.Append: TFhirEligibilityRequest;
begin
  result := TFhirEligibilityRequest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEligibilityRequestList.ClearItems;
begin
  Clear;
end;

function TFhirEligibilityRequestList.GetEnumerator : TFhirEligibilityRequestListEnumerator;
begin
  result := TFhirEligibilityRequestListEnumerator.Create(self.link);
end;

function TFhirEligibilityRequestList.Clone: TFhirEligibilityRequestList;
begin
  result := TFhirEligibilityRequestList(inherited Clone);
end;

function TFhirEligibilityRequestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEligibilityRequestList.GetItemN(index: Integer): TFhirEligibilityRequest;
begin
  result := TFhirEligibilityRequest(ObjectByIndex[index]);
end;

function TFhirEligibilityRequestList.ItemClass: TFslObjectClass;
begin
  result := TFhirEligibilityRequest;
end;
function TFhirEligibilityRequestList.IndexOf(value: TFhirEligibilityRequest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEligibilityRequestList.Insert(index: Integer): TFhirEligibilityRequest;
begin
  result := TFhirEligibilityRequest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEligibilityRequestList.InsertItem(index: Integer; value: TFhirEligibilityRequest);
begin
  assert(value is TFhirEligibilityRequest);
  Inherited Insert(index, value);
end;

function TFhirEligibilityRequestList.Item(index: Integer): TFhirEligibilityRequest;
begin
  result := TFhirEligibilityRequest(ObjectByIndex[index]);
end;

function TFhirEligibilityRequestList.Link: TFhirEligibilityRequestList;
begin
  result := TFhirEligibilityRequestList(inherited Link);
end;

procedure TFhirEligibilityRequestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEligibilityRequestList.SetItemByIndex(index: Integer; value: TFhirEligibilityRequest);
begin
  assert(value is TFhirEligibilityRequest);
  FhirEligibilityRequests[index] := value;
end;

procedure TFhirEligibilityRequestList.SetItemN(index: Integer; value: TFhirEligibilityRequest);
begin
  assert(value is TFhirEligibilityRequest);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ELIGIBILITYREQUEST}

{$IFDEF FHIR_ELIGIBILITYRESPONSE}

{ TFhirEligibilityResponse }

constructor TFhirEligibilityResponse.Create;
begin
  inherited;
end;

destructor TFhirEligibilityResponse.Destroy;
begin
  FIdentifierList.Free;
  FRequest.free;
  FOutcome.free;
  FDisposition.free;
  FRuleset.free;
  FOriginalRuleset.free;
  FCreated.free;
  FOrganization.free;
  FRequestProvider.free;
  FRequestOrganization.free;
  inherited;
end;

function TFhirEligibilityResponse.GetResourceType : TFhirResourceType;
begin
  result := frtEligibilityResponse;
end;

procedure TFhirEligibilityResponse.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirEligibilityResponse(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirEligibilityResponse(oSource).FIdentifierList);
  end;
  request := TFhirEligibilityResponse(oSource).request.Clone;
  FOutcome := TFhirEligibilityResponse(oSource).FOutcome.Link;
  dispositionElement := TFhirEligibilityResponse(oSource).dispositionElement.Clone;
  ruleset := TFhirEligibilityResponse(oSource).ruleset.Clone;
  originalRuleset := TFhirEligibilityResponse(oSource).originalRuleset.Clone;
  createdElement := TFhirEligibilityResponse(oSource).createdElement.Clone;
  organization := TFhirEligibilityResponse(oSource).organization.Clone;
  requestProvider := TFhirEligibilityResponse(oSource).requestProvider.Clone;
  requestOrganization := TFhirEligibilityResponse(oSource).requestOrganization.Clone;
end;

procedure TFhirEligibilityResponse.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'disposition') Then
     list.add(self.link, 'disposition', FDisposition.Link);
  if (child_name = 'ruleset') Then
     list.add(self.link, 'ruleset', FRuleset.Link);
  if (child_name = 'originalRuleset') Then
     list.add(self.link, 'originalRuleset', FOriginalRuleset.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'organization') Then
     list.add(self.link, 'organization', FOrganization.Link);
  if (child_name = 'requestProvider') Then
     list.add(self.link, 'requestProvider', FRequestProvider.Link);
  if (child_name = 'requestOrganization') Then
     list.add(self.link, 'requestOrganization', FRequestOrganization.Link);
end;

procedure TFhirEligibilityResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'request', 'Reference(EligibilityRequest)', false, TFhirReference{TFhirEligibilityRequest}, FRequest.Link));{2}
  oList.add(TFHIRProperty.create(self, 'outcome', 'code', false, TFHIREnum, FOutcome.Link));{1}
  oList.add(TFHIRProperty.create(self, 'disposition', 'string', false, TFhirString, FDisposition.Link));{2}
  oList.add(TFHIRProperty.create(self, 'ruleset', 'Coding', false, TFhirCoding, FRuleset.Link));{2}
  oList.add(TFHIRProperty.create(self, 'originalRuleset', 'Coding', false, TFhirCoding, FOriginalRuleset.Link));{2}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));{2}
  oList.add(TFHIRProperty.create(self, 'organization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FOrganization.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requestProvider', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FRequestProvider.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requestOrganization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FRequestOrganization.Link));{2}
end;

function TFhirEligibilityResponse.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirReference{TFhirEligibilityRequest}{4b};
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    OutcomeElement := asEnum(SYSTEMS_TFhirRemittanceOutcomeEnum, CODES_TFhirRemittanceOutcomeEnum, propValue);
    result := propValue
  end
  else if (propName = 'disposition') then
  begin
    DispositionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'ruleset') then
  begin
    Ruleset := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'originalRuleset') then
  begin
    OriginalRuleset := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'organization') then
  begin
    Organization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'requestProvider') then
  begin
    RequestProvider := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'requestOrganization') then
  begin
    RequestOrganization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirEligibilityResponse.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else inherited;
end;

function TFhirEligibilityResponse.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'request') then result := TFhirReference{TFhirEligibilityRequest}.create(){4b}
  else if (propName = 'disposition') then result := TFhirString.create() {5b}
  else if (propName = 'ruleset') then result := TFhirCoding.create(){4b}
  else if (propName = 'originalRuleset') then result := TFhirCoding.create(){4b}
  else if (propName = 'created') then result := TFhirDateTime.create() {5b}
  else if (propName = 'organization') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'requestProvider') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'requestOrganization') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEligibilityResponse.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'outcome') then result := 'code'
  else if (propName = 'disposition') then result := 'string'
  else if (propName = 'ruleset') then result := 'Coding'
  else if (propName = 'originalRuleset') then result := 'Coding'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'organization') then result := 'Reference'
  else if (propName = 'requestProvider') then result := 'Reference'
  else if (propName = 'requestOrganization') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEligibilityResponse.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'disposition') then DispositionElement := nil
  else if (propName = 'ruleset') then RulesetElement := nil
  else if (propName = 'originalRuleset') then OriginalRulesetElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'organization') then OrganizationElement := nil
  else if (propName = 'requestProvider') then RequestProviderElement := nil
  else if (propName = 'requestOrganization') then RequestOrganizationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEligibilityResponse.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'request') then RequestElement := new as TFhirReference{TFhirEligibilityRequest}{4}
  else if (propName = 'outcome') then OutcomeElement := asEnum(SYSTEMS_TFhirRemittanceOutcomeEnum, CODES_TFhirRemittanceOutcomeEnum, new){4}
  else if (propName = 'disposition') then DispositionElement := asString(new){5b}
  else if (propName = 'ruleset') then RulesetElement := new as TFhirCoding{4}
  else if (propName = 'originalRuleset') then OriginalRulesetElement := new as TFhirCoding{4}
  else if (propName = 'created') then CreatedElement := asDateTime(new){5b}
  else if (propName = 'organization') then OrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'requestProvider') then RequestProviderElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'requestOrganization') then RequestOrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEligibilityResponse.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEligibilityResponse.fhirType : string;
begin
  result := 'EligibilityResponse';
end;

function TFhirEligibilityResponse.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FRequest) and isEmptyProp(FOutcome) and isEmptyProp(FDisposition) and isEmptyProp(FRuleset) and isEmptyProp(FOriginalRuleset) and isEmptyProp(FCreated) and isEmptyProp(FOrganization) and isEmptyProp(FRequestProvider) and isEmptyProp(FRequestOrganization);
end;

function TFhirEligibilityResponse.equals(other : TObject) : boolean;
var
  o : TFhirEligibilityResponse;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEligibilityResponse)) then
    result := false
  else
  begin
    o := TFhirEligibilityResponse(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(requestElement, o.requestElement, true) and
      compareDeep(outcomeElement, o.outcomeElement, true) and compareDeep(dispositionElement, o.dispositionElement, true) and
      compareDeep(rulesetElement, o.rulesetElement, true) and compareDeep(originalRulesetElement, o.originalRulesetElement, true) and
      compareDeep(createdElement, o.createdElement, true) and compareDeep(organizationElement, o.organizationElement, true) and
      compareDeep(requestProviderElement, o.requestProviderElement, true) and compareDeep(requestOrganizationElement, o.requestOrganizationElement, true);
  end;
end;

function TFhirEligibilityResponse.Link : TFhirEligibilityResponse;
begin
  result := TFhirEligibilityResponse(inherited Link);
end;

function TFhirEligibilityResponse.Clone : TFhirEligibilityResponse;
begin
  result := TFhirEligibilityResponse(inherited Clone);
end;

procedure TFhirEligibilityResponse.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('request');
  fields.add('outcome');
  fields.add('disposition');
  fields.add('ruleset');
  fields.add('originalRuleset');
  fields.add('created');
  fields.add('organization');
  fields.add('requestProvider');
  fields.add('requestOrganization');
end;

{ TFhirEligibilityResponse }

Function TFhirEligibilityResponse.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirEligibilityResponse.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirEligibilityResponse.SetRequest(value : TFhirReference{TFhirEligibilityRequest});
begin
  FRequest.free;
  FRequest := value;
end;

Procedure TFhirEligibilityResponse.SetOutcome(value : TFhirEnum);
begin
  FOutcome.free;
  FOutcome := value;
end;

Function TFhirEligibilityResponse.GetOutcomeST : TFhirRemittanceOutcomeEnum;
begin
  if FOutcome = nil then
    result := TFhirRemittanceOutcomeEnum(0)
  else
    result := TFhirRemittanceOutcomeEnum(StringArrayIndexOfSensitive(CODES_TFhirRemittanceOutcomeEnum, FOutcome.value));
end;

Procedure TFhirEligibilityResponse.SetOutcomeST(value : TFhirRemittanceOutcomeEnum);
begin
  if ord(value) = 0 then
    OutcomeElement := nil
  else
    OutcomeElement := TFhirEnum.create(SYSTEMS_TFhirRemittanceOutcomeEnum[value], CODES_TFhirRemittanceOutcomeEnum[value]);
end;

Procedure TFhirEligibilityResponse.SetDisposition(value : TFhirString);
begin
  FDisposition.free;
  FDisposition := value;
end;

Function TFhirEligibilityResponse.GetDispositionST : String;
begin
  if FDisposition = nil then
    result := ''
  else
    result := FDisposition.value;
end;

Procedure TFhirEligibilityResponse.SetDispositionST(value : String);
begin
  if value <> '' then
  begin
    if FDisposition = nil then
      FDisposition := TFhirString.create;
    FDisposition.value := value
  end
  else if FDisposition <> nil then
    FDisposition.value := '';
end;

Procedure TFhirEligibilityResponse.SetRuleset(value : TFhirCoding);
begin
  FRuleset.free;
  FRuleset := value;
end;

Procedure TFhirEligibilityResponse.SetOriginalRuleset(value : TFhirCoding);
begin
  FOriginalRuleset.free;
  FOriginalRuleset := value;
end;

Procedure TFhirEligibilityResponse.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

Function TFhirEligibilityResponse.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

Procedure TFhirEligibilityResponse.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

Procedure TFhirEligibilityResponse.SetOrganization(value : TFhirReference{TFhirOrganization});
begin
  FOrganization.free;
  FOrganization := value;
end;

Procedure TFhirEligibilityResponse.SetRequestProvider(value : TFhirReference{TFhirPractitioner});
begin
  FRequestProvider.free;
  FRequestProvider := value;
end;

Procedure TFhirEligibilityResponse.SetRequestOrganization(value : TFhirReference{TFhirOrganization});
begin
  FRequestOrganization.free;
  FRequestOrganization := value;
end;

function TFhirEligibilityResponse.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FRequest.sizeInBytes);
  inc(result, FOutcome.sizeInBytes);
  inc(result, FDisposition.sizeInBytes);
  inc(result, FRuleset.sizeInBytes);
  inc(result, FOriginalRuleset.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FOrganization.sizeInBytes);
  inc(result, FRequestProvider.sizeInBytes);
  inc(result, FRequestOrganization.sizeInBytes);
end;

{ TFhirEligibilityResponseListEnumerator }

Constructor TFhirEligibilityResponseListEnumerator.Create(list : TFhirEligibilityResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEligibilityResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEligibilityResponseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEligibilityResponseListEnumerator.GetCurrent : TFhirEligibilityResponse;
begin
  Result := FList[FIndex];
end;

function TFhirEligibilityResponseListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirEligibilityResponseList }
procedure TFhirEligibilityResponseList.AddItem(value: TFhirEligibilityResponse);
begin
  assert(value.ClassName = 'TFhirEligibilityResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEligibilityResponse');
  add(value);
end;

function TFhirEligibilityResponseList.Append: TFhirEligibilityResponse;
begin
  result := TFhirEligibilityResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEligibilityResponseList.ClearItems;
begin
  Clear;
end;

function TFhirEligibilityResponseList.GetEnumerator : TFhirEligibilityResponseListEnumerator;
begin
  result := TFhirEligibilityResponseListEnumerator.Create(self.link);
end;

function TFhirEligibilityResponseList.Clone: TFhirEligibilityResponseList;
begin
  result := TFhirEligibilityResponseList(inherited Clone);
end;

function TFhirEligibilityResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEligibilityResponseList.GetItemN(index: Integer): TFhirEligibilityResponse;
begin
  result := TFhirEligibilityResponse(ObjectByIndex[index]);
end;

function TFhirEligibilityResponseList.ItemClass: TFslObjectClass;
begin
  result := TFhirEligibilityResponse;
end;
function TFhirEligibilityResponseList.IndexOf(value: TFhirEligibilityResponse): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEligibilityResponseList.Insert(index: Integer): TFhirEligibilityResponse;
begin
  result := TFhirEligibilityResponse.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEligibilityResponseList.InsertItem(index: Integer; value: TFhirEligibilityResponse);
begin
  assert(value is TFhirEligibilityResponse);
  Inherited Insert(index, value);
end;

function TFhirEligibilityResponseList.Item(index: Integer): TFhirEligibilityResponse;
begin
  result := TFhirEligibilityResponse(ObjectByIndex[index]);
end;

function TFhirEligibilityResponseList.Link: TFhirEligibilityResponseList;
begin
  result := TFhirEligibilityResponseList(inherited Link);
end;

procedure TFhirEligibilityResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEligibilityResponseList.SetItemByIndex(index: Integer; value: TFhirEligibilityResponse);
begin
  assert(value is TFhirEligibilityResponse);
  FhirEligibilityResponses[index] := value;
end;

procedure TFhirEligibilityResponseList.SetItemN(index: Integer; value: TFhirEligibilityResponse);
begin
  assert(value is TFhirEligibilityResponse);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ELIGIBILITYRESPONSE}

{$IFDEF FHIR_ENROLLMENTREQUEST}

{ TFhirEnrollmentRequest }

constructor TFhirEnrollmentRequest.Create;
begin
  inherited;
end;

destructor TFhirEnrollmentRequest.Destroy;
begin
  FIdentifierList.Free;
  FRuleset.free;
  FOriginalRuleset.free;
  FCreated.free;
  FTarget.free;
  FProvider.free;
  FOrganization.free;
  FSubject.free;
  FCoverage.free;
  FRelationship.free;
  inherited;
end;

function TFhirEnrollmentRequest.GetResourceType : TFhirResourceType;
begin
  result := frtEnrollmentRequest;
end;

procedure TFhirEnrollmentRequest.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirEnrollmentRequest(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirEnrollmentRequest(oSource).FIdentifierList);
  end;
  ruleset := TFhirEnrollmentRequest(oSource).ruleset.Clone;
  originalRuleset := TFhirEnrollmentRequest(oSource).originalRuleset.Clone;
  createdElement := TFhirEnrollmentRequest(oSource).createdElement.Clone;
  target := TFhirEnrollmentRequest(oSource).target.Clone;
  provider := TFhirEnrollmentRequest(oSource).provider.Clone;
  organization := TFhirEnrollmentRequest(oSource).organization.Clone;
  subject := TFhirEnrollmentRequest(oSource).subject.Clone;
  coverage := TFhirEnrollmentRequest(oSource).coverage.Clone;
  relationship := TFhirEnrollmentRequest(oSource).relationship.Clone;
end;

procedure TFhirEnrollmentRequest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'ruleset') Then
     list.add(self.link, 'ruleset', FRuleset.Link);
  if (child_name = 'originalRuleset') Then
     list.add(self.link, 'originalRuleset', FOriginalRuleset.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'target') Then
     list.add(self.link, 'target', FTarget.Link);
  if (child_name = 'provider') Then
     list.add(self.link, 'provider', FProvider.Link);
  if (child_name = 'organization') Then
     list.add(self.link, 'organization', FOrganization.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'coverage') Then
     list.add(self.link, 'coverage', FCoverage.Link);
  if (child_name = 'relationship') Then
     list.add(self.link, 'relationship', FRelationship.Link);
end;

procedure TFhirEnrollmentRequest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'ruleset', 'Coding', false, TFhirCoding, FRuleset.Link));{2}
  oList.add(TFHIRProperty.create(self, 'originalRuleset', 'Coding', false, TFhirCoding, FOriginalRuleset.Link));{2}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));{2}
  oList.add(TFHIRProperty.create(self, 'target', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FTarget.Link));{2}
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FProvider.Link));{2}
  oList.add(TFHIRProperty.create(self, 'organization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FOrganization.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'coverage', 'Reference(Coverage)', false, TFhirReference{TFhirCoverage}, FCoverage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'relationship', 'Coding', false, TFhirCoding, FRelationship.Link));{2}
end;

function TFhirEnrollmentRequest.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'ruleset') then
  begin
    Ruleset := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'originalRuleset') then
  begin
    OriginalRuleset := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'target') then
  begin
    Target := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'provider') then
  begin
    Provider := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'organization') then
  begin
    Organization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'coverage') then
  begin
    Coverage := propValue as TFhirReference{TFhirCoverage}{4b};
    result := propValue;
  end
  else if (propName = 'relationship') then
  begin
    Relationship := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirEnrollmentRequest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else inherited;
end;

function TFhirEnrollmentRequest.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'ruleset') then result := TFhirCoding.create(){4b}
  else if (propName = 'originalRuleset') then result := TFhirCoding.create(){4b}
  else if (propName = 'created') then result := TFhirDateTime.create() {5b}
  else if (propName = 'target') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'provider') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'organization') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'subject') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'coverage') then result := TFhirReference{TFhirCoverage}.create(){4b}
  else if (propName = 'relationship') then result := TFhirCoding.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEnrollmentRequest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'ruleset') then result := 'Coding'
  else if (propName = 'originalRuleset') then result := 'Coding'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'target') then result := 'Reference'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'organization') then result := 'Reference'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'coverage') then result := 'Reference'
  else if (propName = 'relationship') then result := 'Coding'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEnrollmentRequest.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'ruleset') then RulesetElement := nil
  else if (propName = 'originalRuleset') then OriginalRulesetElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'target') then TargetElement := nil
  else if (propName = 'provider') then ProviderElement := nil
  else if (propName = 'organization') then OrganizationElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'coverage') then CoverageElement := nil
  else if (propName = 'relationship') then RelationshipElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEnrollmentRequest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'ruleset') then RulesetElement := new as TFhirCoding{4}
  else if (propName = 'originalRuleset') then OriginalRulesetElement := new as TFhirCoding{4}
  else if (propName = 'created') then CreatedElement := asDateTime(new){5b}
  else if (propName = 'target') then TargetElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'provider') then ProviderElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'organization') then OrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'coverage') then CoverageElement := new as TFhirReference{TFhirCoverage}{4}
  else if (propName = 'relationship') then RelationshipElement := new as TFhirCoding{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEnrollmentRequest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEnrollmentRequest.fhirType : string;
begin
  result := 'EnrollmentRequest';
end;

function TFhirEnrollmentRequest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FRuleset) and isEmptyProp(FOriginalRuleset) and isEmptyProp(FCreated) and isEmptyProp(FTarget) and isEmptyProp(FProvider) and isEmptyProp(FOrganization) and isEmptyProp(FSubject) and isEmptyProp(FCoverage) and isEmptyProp(FRelationship);
end;

function TFhirEnrollmentRequest.equals(other : TObject) : boolean;
var
  o : TFhirEnrollmentRequest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEnrollmentRequest)) then
    result := false
  else
  begin
    o := TFhirEnrollmentRequest(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(rulesetElement, o.rulesetElement, true) and
      compareDeep(originalRulesetElement, o.originalRulesetElement, true) and compareDeep(createdElement, o.createdElement, true) and
      compareDeep(targetElement, o.targetElement, true) and compareDeep(providerElement, o.providerElement, true) and
      compareDeep(organizationElement, o.organizationElement, true) and compareDeep(subjectElement, o.subjectElement, true) and
      compareDeep(coverageElement, o.coverageElement, true) and compareDeep(relationshipElement, o.relationshipElement, true);
  end;
end;

function TFhirEnrollmentRequest.Link : TFhirEnrollmentRequest;
begin
  result := TFhirEnrollmentRequest(inherited Link);
end;

function TFhirEnrollmentRequest.Clone : TFhirEnrollmentRequest;
begin
  result := TFhirEnrollmentRequest(inherited Clone);
end;

procedure TFhirEnrollmentRequest.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('ruleset');
  fields.add('originalRuleset');
  fields.add('created');
  fields.add('target');
  fields.add('provider');
  fields.add('organization');
  fields.add('subject');
  fields.add('coverage');
  fields.add('relationship');
end;

{ TFhirEnrollmentRequest }

Function TFhirEnrollmentRequest.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirEnrollmentRequest.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirEnrollmentRequest.SetRuleset(value : TFhirCoding);
begin
  FRuleset.free;
  FRuleset := value;
end;

Procedure TFhirEnrollmentRequest.SetOriginalRuleset(value : TFhirCoding);
begin
  FOriginalRuleset.free;
  FOriginalRuleset := value;
end;

Procedure TFhirEnrollmentRequest.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

Function TFhirEnrollmentRequest.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

Procedure TFhirEnrollmentRequest.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

Procedure TFhirEnrollmentRequest.SetTarget(value : TFhirReference{TFhirOrganization});
begin
  FTarget.free;
  FTarget := value;
end;

Procedure TFhirEnrollmentRequest.SetProvider(value : TFhirReference{TFhirPractitioner});
begin
  FProvider.free;
  FProvider := value;
end;

Procedure TFhirEnrollmentRequest.SetOrganization(value : TFhirReference{TFhirOrganization});
begin
  FOrganization.free;
  FOrganization := value;
end;

Procedure TFhirEnrollmentRequest.SetSubject(value : TFhirReference{TFhirPatient});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirEnrollmentRequest.SetCoverage(value : TFhirReference{TFhirCoverage});
begin
  FCoverage.free;
  FCoverage := value;
end;

Procedure TFhirEnrollmentRequest.SetRelationship(value : TFhirCoding);
begin
  FRelationship.free;
  FRelationship := value;
end;

function TFhirEnrollmentRequest.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FRuleset.sizeInBytes);
  inc(result, FOriginalRuleset.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FTarget.sizeInBytes);
  inc(result, FProvider.sizeInBytes);
  inc(result, FOrganization.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FCoverage.sizeInBytes);
  inc(result, FRelationship.sizeInBytes);
end;

{ TFhirEnrollmentRequestListEnumerator }

Constructor TFhirEnrollmentRequestListEnumerator.Create(list : TFhirEnrollmentRequestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEnrollmentRequestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEnrollmentRequestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEnrollmentRequestListEnumerator.GetCurrent : TFhirEnrollmentRequest;
begin
  Result := FList[FIndex];
end;

function TFhirEnrollmentRequestListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirEnrollmentRequestList }
procedure TFhirEnrollmentRequestList.AddItem(value: TFhirEnrollmentRequest);
begin
  assert(value.ClassName = 'TFhirEnrollmentRequest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEnrollmentRequest');
  add(value);
end;

function TFhirEnrollmentRequestList.Append: TFhirEnrollmentRequest;
begin
  result := TFhirEnrollmentRequest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEnrollmentRequestList.ClearItems;
begin
  Clear;
end;

function TFhirEnrollmentRequestList.GetEnumerator : TFhirEnrollmentRequestListEnumerator;
begin
  result := TFhirEnrollmentRequestListEnumerator.Create(self.link);
end;

function TFhirEnrollmentRequestList.Clone: TFhirEnrollmentRequestList;
begin
  result := TFhirEnrollmentRequestList(inherited Clone);
end;

function TFhirEnrollmentRequestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEnrollmentRequestList.GetItemN(index: Integer): TFhirEnrollmentRequest;
begin
  result := TFhirEnrollmentRequest(ObjectByIndex[index]);
end;

function TFhirEnrollmentRequestList.ItemClass: TFslObjectClass;
begin
  result := TFhirEnrollmentRequest;
end;
function TFhirEnrollmentRequestList.IndexOf(value: TFhirEnrollmentRequest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEnrollmentRequestList.Insert(index: Integer): TFhirEnrollmentRequest;
begin
  result := TFhirEnrollmentRequest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEnrollmentRequestList.InsertItem(index: Integer; value: TFhirEnrollmentRequest);
begin
  assert(value is TFhirEnrollmentRequest);
  Inherited Insert(index, value);
end;

function TFhirEnrollmentRequestList.Item(index: Integer): TFhirEnrollmentRequest;
begin
  result := TFhirEnrollmentRequest(ObjectByIndex[index]);
end;

function TFhirEnrollmentRequestList.Link: TFhirEnrollmentRequestList;
begin
  result := TFhirEnrollmentRequestList(inherited Link);
end;

procedure TFhirEnrollmentRequestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEnrollmentRequestList.SetItemByIndex(index: Integer; value: TFhirEnrollmentRequest);
begin
  assert(value is TFhirEnrollmentRequest);
  FhirEnrollmentRequests[index] := value;
end;

procedure TFhirEnrollmentRequestList.SetItemN(index: Integer; value: TFhirEnrollmentRequest);
begin
  assert(value is TFhirEnrollmentRequest);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ENROLLMENTREQUEST}

{$IFDEF FHIR_ENROLLMENTRESPONSE}

{ TFhirEnrollmentResponse }

constructor TFhirEnrollmentResponse.Create;
begin
  inherited;
end;

destructor TFhirEnrollmentResponse.Destroy;
begin
  FIdentifierList.Free;
  FRequest.free;
  FOutcome.free;
  FDisposition.free;
  FRuleset.free;
  FOriginalRuleset.free;
  FCreated.free;
  FOrganization.free;
  FRequestProvider.free;
  FRequestOrganization.free;
  inherited;
end;

function TFhirEnrollmentResponse.GetResourceType : TFhirResourceType;
begin
  result := frtEnrollmentResponse;
end;

procedure TFhirEnrollmentResponse.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirEnrollmentResponse(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirEnrollmentResponse(oSource).FIdentifierList);
  end;
  request := TFhirEnrollmentResponse(oSource).request.Clone;
  FOutcome := TFhirEnrollmentResponse(oSource).FOutcome.Link;
  dispositionElement := TFhirEnrollmentResponse(oSource).dispositionElement.Clone;
  ruleset := TFhirEnrollmentResponse(oSource).ruleset.Clone;
  originalRuleset := TFhirEnrollmentResponse(oSource).originalRuleset.Clone;
  createdElement := TFhirEnrollmentResponse(oSource).createdElement.Clone;
  organization := TFhirEnrollmentResponse(oSource).organization.Clone;
  requestProvider := TFhirEnrollmentResponse(oSource).requestProvider.Clone;
  requestOrganization := TFhirEnrollmentResponse(oSource).requestOrganization.Clone;
end;

procedure TFhirEnrollmentResponse.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'disposition') Then
     list.add(self.link, 'disposition', FDisposition.Link);
  if (child_name = 'ruleset') Then
     list.add(self.link, 'ruleset', FRuleset.Link);
  if (child_name = 'originalRuleset') Then
     list.add(self.link, 'originalRuleset', FOriginalRuleset.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'organization') Then
     list.add(self.link, 'organization', FOrganization.Link);
  if (child_name = 'requestProvider') Then
     list.add(self.link, 'requestProvider', FRequestProvider.Link);
  if (child_name = 'requestOrganization') Then
     list.add(self.link, 'requestOrganization', FRequestOrganization.Link);
end;

procedure TFhirEnrollmentResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'request', 'Reference(EnrollmentRequest)', false, TFhirReference{TFhirEnrollmentRequest}, FRequest.Link));{2}
  oList.add(TFHIRProperty.create(self, 'outcome', 'code', false, TFHIREnum, FOutcome.Link));{1}
  oList.add(TFHIRProperty.create(self, 'disposition', 'string', false, TFhirString, FDisposition.Link));{2}
  oList.add(TFHIRProperty.create(self, 'ruleset', 'Coding', false, TFhirCoding, FRuleset.Link));{2}
  oList.add(TFHIRProperty.create(self, 'originalRuleset', 'Coding', false, TFhirCoding, FOriginalRuleset.Link));{2}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));{2}
  oList.add(TFHIRProperty.create(self, 'organization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FOrganization.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requestProvider', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FRequestProvider.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requestOrganization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FRequestOrganization.Link));{2}
end;

function TFhirEnrollmentResponse.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirReference{TFhirEnrollmentRequest}{4b};
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    OutcomeElement := asEnum(SYSTEMS_TFhirRemittanceOutcomeEnum, CODES_TFhirRemittanceOutcomeEnum, propValue);
    result := propValue
  end
  else if (propName = 'disposition') then
  begin
    DispositionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'ruleset') then
  begin
    Ruleset := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'originalRuleset') then
  begin
    OriginalRuleset := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'organization') then
  begin
    Organization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'requestProvider') then
  begin
    RequestProvider := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'requestOrganization') then
  begin
    RequestOrganization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirEnrollmentResponse.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else inherited;
end;

function TFhirEnrollmentResponse.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'request') then result := TFhirReference{TFhirEnrollmentRequest}.create(){4b}
  else if (propName = 'disposition') then result := TFhirString.create() {5b}
  else if (propName = 'ruleset') then result := TFhirCoding.create(){4b}
  else if (propName = 'originalRuleset') then result := TFhirCoding.create(){4b}
  else if (propName = 'created') then result := TFhirDateTime.create() {5b}
  else if (propName = 'organization') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'requestProvider') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'requestOrganization') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEnrollmentResponse.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'outcome') then result := 'code'
  else if (propName = 'disposition') then result := 'string'
  else if (propName = 'ruleset') then result := 'Coding'
  else if (propName = 'originalRuleset') then result := 'Coding'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'organization') then result := 'Reference'
  else if (propName = 'requestProvider') then result := 'Reference'
  else if (propName = 'requestOrganization') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEnrollmentResponse.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'disposition') then DispositionElement := nil
  else if (propName = 'ruleset') then RulesetElement := nil
  else if (propName = 'originalRuleset') then OriginalRulesetElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'organization') then OrganizationElement := nil
  else if (propName = 'requestProvider') then RequestProviderElement := nil
  else if (propName = 'requestOrganization') then RequestOrganizationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEnrollmentResponse.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'request') then RequestElement := new as TFhirReference{TFhirEnrollmentRequest}{4}
  else if (propName = 'outcome') then OutcomeElement := asEnum(SYSTEMS_TFhirRemittanceOutcomeEnum, CODES_TFhirRemittanceOutcomeEnum, new){4}
  else if (propName = 'disposition') then DispositionElement := asString(new){5b}
  else if (propName = 'ruleset') then RulesetElement := new as TFhirCoding{4}
  else if (propName = 'originalRuleset') then OriginalRulesetElement := new as TFhirCoding{4}
  else if (propName = 'created') then CreatedElement := asDateTime(new){5b}
  else if (propName = 'organization') then OrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'requestProvider') then RequestProviderElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'requestOrganization') then RequestOrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEnrollmentResponse.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEnrollmentResponse.fhirType : string;
begin
  result := 'EnrollmentResponse';
end;

function TFhirEnrollmentResponse.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FRequest) and isEmptyProp(FOutcome) and isEmptyProp(FDisposition) and isEmptyProp(FRuleset) and isEmptyProp(FOriginalRuleset) and isEmptyProp(FCreated) and isEmptyProp(FOrganization) and isEmptyProp(FRequestProvider) and isEmptyProp(FRequestOrganization);
end;

function TFhirEnrollmentResponse.equals(other : TObject) : boolean;
var
  o : TFhirEnrollmentResponse;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEnrollmentResponse)) then
    result := false
  else
  begin
    o := TFhirEnrollmentResponse(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(requestElement, o.requestElement, true) and
      compareDeep(outcomeElement, o.outcomeElement, true) and compareDeep(dispositionElement, o.dispositionElement, true) and
      compareDeep(rulesetElement, o.rulesetElement, true) and compareDeep(originalRulesetElement, o.originalRulesetElement, true) and
      compareDeep(createdElement, o.createdElement, true) and compareDeep(organizationElement, o.organizationElement, true) and
      compareDeep(requestProviderElement, o.requestProviderElement, true) and compareDeep(requestOrganizationElement, o.requestOrganizationElement, true);
  end;
end;

function TFhirEnrollmentResponse.Link : TFhirEnrollmentResponse;
begin
  result := TFhirEnrollmentResponse(inherited Link);
end;

function TFhirEnrollmentResponse.Clone : TFhirEnrollmentResponse;
begin
  result := TFhirEnrollmentResponse(inherited Clone);
end;

procedure TFhirEnrollmentResponse.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('request');
  fields.add('outcome');
  fields.add('disposition');
  fields.add('ruleset');
  fields.add('originalRuleset');
  fields.add('created');
  fields.add('organization');
  fields.add('requestProvider');
  fields.add('requestOrganization');
end;

{ TFhirEnrollmentResponse }

Function TFhirEnrollmentResponse.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirEnrollmentResponse.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirEnrollmentResponse.SetRequest(value : TFhirReference{TFhirEnrollmentRequest});
begin
  FRequest.free;
  FRequest := value;
end;

Procedure TFhirEnrollmentResponse.SetOutcome(value : TFhirEnum);
begin
  FOutcome.free;
  FOutcome := value;
end;

Function TFhirEnrollmentResponse.GetOutcomeST : TFhirRemittanceOutcomeEnum;
begin
  if FOutcome = nil then
    result := TFhirRemittanceOutcomeEnum(0)
  else
    result := TFhirRemittanceOutcomeEnum(StringArrayIndexOfSensitive(CODES_TFhirRemittanceOutcomeEnum, FOutcome.value));
end;

Procedure TFhirEnrollmentResponse.SetOutcomeST(value : TFhirRemittanceOutcomeEnum);
begin
  if ord(value) = 0 then
    OutcomeElement := nil
  else
    OutcomeElement := TFhirEnum.create(SYSTEMS_TFhirRemittanceOutcomeEnum[value], CODES_TFhirRemittanceOutcomeEnum[value]);
end;

Procedure TFhirEnrollmentResponse.SetDisposition(value : TFhirString);
begin
  FDisposition.free;
  FDisposition := value;
end;

Function TFhirEnrollmentResponse.GetDispositionST : String;
begin
  if FDisposition = nil then
    result := ''
  else
    result := FDisposition.value;
end;

Procedure TFhirEnrollmentResponse.SetDispositionST(value : String);
begin
  if value <> '' then
  begin
    if FDisposition = nil then
      FDisposition := TFhirString.create;
    FDisposition.value := value
  end
  else if FDisposition <> nil then
    FDisposition.value := '';
end;

Procedure TFhirEnrollmentResponse.SetRuleset(value : TFhirCoding);
begin
  FRuleset.free;
  FRuleset := value;
end;

Procedure TFhirEnrollmentResponse.SetOriginalRuleset(value : TFhirCoding);
begin
  FOriginalRuleset.free;
  FOriginalRuleset := value;
end;

Procedure TFhirEnrollmentResponse.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

Function TFhirEnrollmentResponse.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

Procedure TFhirEnrollmentResponse.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

Procedure TFhirEnrollmentResponse.SetOrganization(value : TFhirReference{TFhirOrganization});
begin
  FOrganization.free;
  FOrganization := value;
end;

Procedure TFhirEnrollmentResponse.SetRequestProvider(value : TFhirReference{TFhirPractitioner});
begin
  FRequestProvider.free;
  FRequestProvider := value;
end;

Procedure TFhirEnrollmentResponse.SetRequestOrganization(value : TFhirReference{TFhirOrganization});
begin
  FRequestOrganization.free;
  FRequestOrganization := value;
end;

function TFhirEnrollmentResponse.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FRequest.sizeInBytes);
  inc(result, FOutcome.sizeInBytes);
  inc(result, FDisposition.sizeInBytes);
  inc(result, FRuleset.sizeInBytes);
  inc(result, FOriginalRuleset.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FOrganization.sizeInBytes);
  inc(result, FRequestProvider.sizeInBytes);
  inc(result, FRequestOrganization.sizeInBytes);
end;

{ TFhirEnrollmentResponseListEnumerator }

Constructor TFhirEnrollmentResponseListEnumerator.Create(list : TFhirEnrollmentResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEnrollmentResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEnrollmentResponseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEnrollmentResponseListEnumerator.GetCurrent : TFhirEnrollmentResponse;
begin
  Result := FList[FIndex];
end;

function TFhirEnrollmentResponseListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirEnrollmentResponseList }
procedure TFhirEnrollmentResponseList.AddItem(value: TFhirEnrollmentResponse);
begin
  assert(value.ClassName = 'TFhirEnrollmentResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEnrollmentResponse');
  add(value);
end;

function TFhirEnrollmentResponseList.Append: TFhirEnrollmentResponse;
begin
  result := TFhirEnrollmentResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEnrollmentResponseList.ClearItems;
begin
  Clear;
end;

function TFhirEnrollmentResponseList.GetEnumerator : TFhirEnrollmentResponseListEnumerator;
begin
  result := TFhirEnrollmentResponseListEnumerator.Create(self.link);
end;

function TFhirEnrollmentResponseList.Clone: TFhirEnrollmentResponseList;
begin
  result := TFhirEnrollmentResponseList(inherited Clone);
end;

function TFhirEnrollmentResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEnrollmentResponseList.GetItemN(index: Integer): TFhirEnrollmentResponse;
begin
  result := TFhirEnrollmentResponse(ObjectByIndex[index]);
end;

function TFhirEnrollmentResponseList.ItemClass: TFslObjectClass;
begin
  result := TFhirEnrollmentResponse;
end;
function TFhirEnrollmentResponseList.IndexOf(value: TFhirEnrollmentResponse): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEnrollmentResponseList.Insert(index: Integer): TFhirEnrollmentResponse;
begin
  result := TFhirEnrollmentResponse.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEnrollmentResponseList.InsertItem(index: Integer; value: TFhirEnrollmentResponse);
begin
  assert(value is TFhirEnrollmentResponse);
  Inherited Insert(index, value);
end;

function TFhirEnrollmentResponseList.Item(index: Integer): TFhirEnrollmentResponse;
begin
  result := TFhirEnrollmentResponse(ObjectByIndex[index]);
end;

function TFhirEnrollmentResponseList.Link: TFhirEnrollmentResponseList;
begin
  result := TFhirEnrollmentResponseList(inherited Link);
end;

procedure TFhirEnrollmentResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEnrollmentResponseList.SetItemByIndex(index: Integer; value: TFhirEnrollmentResponse);
begin
  assert(value is TFhirEnrollmentResponse);
  FhirEnrollmentResponses[index] := value;
end;

procedure TFhirEnrollmentResponseList.SetItemN(index: Integer; value: TFhirEnrollmentResponse);
begin
  assert(value is TFhirEnrollmentResponse);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ENROLLMENTRESPONSE}

{$IFDEF FHIR_EXPLANATIONOFBENEFIT}

{ TFhirExplanationOfBenefit }

constructor TFhirExplanationOfBenefit.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefit.Destroy;
begin
  FIdentifierList.Free;
  FRequest.free;
  FOutcome.free;
  FDisposition.free;
  FRuleset.free;
  FOriginalRuleset.free;
  FCreated.free;
  FOrganization.free;
  FRequestProvider.free;
  FRequestOrganization.free;
  inherited;
end;

function TFhirExplanationOfBenefit.GetResourceType : TFhirResourceType;
begin
  result := frtExplanationOfBenefit;
end;

procedure TFhirExplanationOfBenefit.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirExplanationOfBenefit(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirExplanationOfBenefit(oSource).FIdentifierList);
  end;
  request := TFhirExplanationOfBenefit(oSource).request.Clone;
  FOutcome := TFhirExplanationOfBenefit(oSource).FOutcome.Link;
  dispositionElement := TFhirExplanationOfBenefit(oSource).dispositionElement.Clone;
  ruleset := TFhirExplanationOfBenefit(oSource).ruleset.Clone;
  originalRuleset := TFhirExplanationOfBenefit(oSource).originalRuleset.Clone;
  createdElement := TFhirExplanationOfBenefit(oSource).createdElement.Clone;
  organization := TFhirExplanationOfBenefit(oSource).organization.Clone;
  requestProvider := TFhirExplanationOfBenefit(oSource).requestProvider.Clone;
  requestOrganization := TFhirExplanationOfBenefit(oSource).requestOrganization.Clone;
end;

procedure TFhirExplanationOfBenefit.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'disposition') Then
     list.add(self.link, 'disposition', FDisposition.Link);
  if (child_name = 'ruleset') Then
     list.add(self.link, 'ruleset', FRuleset.Link);
  if (child_name = 'originalRuleset') Then
     list.add(self.link, 'originalRuleset', FOriginalRuleset.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'organization') Then
     list.add(self.link, 'organization', FOrganization.Link);
  if (child_name = 'requestProvider') Then
     list.add(self.link, 'requestProvider', FRequestProvider.Link);
  if (child_name = 'requestOrganization') Then
     list.add(self.link, 'requestOrganization', FRequestOrganization.Link);
end;

procedure TFhirExplanationOfBenefit.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'request', 'Reference(Claim)', false, TFhirReference{TFhirClaim}, FRequest.Link));{2}
  oList.add(TFHIRProperty.create(self, 'outcome', 'code', false, TFHIREnum, FOutcome.Link));{1}
  oList.add(TFHIRProperty.create(self, 'disposition', 'string', false, TFhirString, FDisposition.Link));{2}
  oList.add(TFHIRProperty.create(self, 'ruleset', 'Coding', false, TFhirCoding, FRuleset.Link));{2}
  oList.add(TFHIRProperty.create(self, 'originalRuleset', 'Coding', false, TFhirCoding, FOriginalRuleset.Link));{2}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));{2}
  oList.add(TFHIRProperty.create(self, 'organization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FOrganization.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requestProvider', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FRequestProvider.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requestOrganization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FRequestOrganization.Link));{2}
end;

function TFhirExplanationOfBenefit.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirReference{TFhirClaim}{4b};
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    OutcomeElement := asEnum(SYSTEMS_TFhirRemittanceOutcomeEnum, CODES_TFhirRemittanceOutcomeEnum, propValue);
    result := propValue
  end
  else if (propName = 'disposition') then
  begin
    DispositionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'ruleset') then
  begin
    Ruleset := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'originalRuleset') then
  begin
    OriginalRuleset := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'organization') then
  begin
    Organization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'requestProvider') then
  begin
    RequestProvider := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'requestOrganization') then
  begin
    RequestOrganization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirExplanationOfBenefit.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else inherited;
end;

function TFhirExplanationOfBenefit.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'request') then result := TFhirReference{TFhirClaim}.create(){4b}
  else if (propName = 'disposition') then result := TFhirString.create() {5b}
  else if (propName = 'ruleset') then result := TFhirCoding.create(){4b}
  else if (propName = 'originalRuleset') then result := TFhirCoding.create(){4b}
  else if (propName = 'created') then result := TFhirDateTime.create() {5b}
  else if (propName = 'organization') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'requestProvider') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'requestOrganization') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefit.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'outcome') then result := 'code'
  else if (propName = 'disposition') then result := 'string'
  else if (propName = 'ruleset') then result := 'Coding'
  else if (propName = 'originalRuleset') then result := 'Coding'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'organization') then result := 'Reference'
  else if (propName = 'requestProvider') then result := 'Reference'
  else if (propName = 'requestOrganization') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefit.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'disposition') then DispositionElement := nil
  else if (propName = 'ruleset') then RulesetElement := nil
  else if (propName = 'originalRuleset') then OriginalRulesetElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'organization') then OrganizationElement := nil
  else if (propName = 'requestProvider') then RequestProviderElement := nil
  else if (propName = 'requestOrganization') then RequestOrganizationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefit.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'request') then RequestElement := new as TFhirReference{TFhirClaim}{4}
  else if (propName = 'outcome') then OutcomeElement := asEnum(SYSTEMS_TFhirRemittanceOutcomeEnum, CODES_TFhirRemittanceOutcomeEnum, new){4}
  else if (propName = 'disposition') then DispositionElement := asString(new){5b}
  else if (propName = 'ruleset') then RulesetElement := new as TFhirCoding{4}
  else if (propName = 'originalRuleset') then OriginalRulesetElement := new as TFhirCoding{4}
  else if (propName = 'created') then CreatedElement := asDateTime(new){5b}
  else if (propName = 'organization') then OrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'requestProvider') then RequestProviderElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'requestOrganization') then RequestOrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefit.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefit.fhirType : string;
begin
  result := 'ExplanationOfBenefit';
end;

function TFhirExplanationOfBenefit.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FRequest) and isEmptyProp(FOutcome) and isEmptyProp(FDisposition) and isEmptyProp(FRuleset) and isEmptyProp(FOriginalRuleset) and isEmptyProp(FCreated) and isEmptyProp(FOrganization) and isEmptyProp(FRequestProvider) and isEmptyProp(FRequestOrganization);
end;

function TFhirExplanationOfBenefit.equals(other : TObject) : boolean;
var
  o : TFhirExplanationOfBenefit;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefit)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefit(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(requestElement, o.requestElement, true) and
      compareDeep(outcomeElement, o.outcomeElement, true) and compareDeep(dispositionElement, o.dispositionElement, true) and
      compareDeep(rulesetElement, o.rulesetElement, true) and compareDeep(originalRulesetElement, o.originalRulesetElement, true) and
      compareDeep(createdElement, o.createdElement, true) and compareDeep(organizationElement, o.organizationElement, true) and
      compareDeep(requestProviderElement, o.requestProviderElement, true) and compareDeep(requestOrganizationElement, o.requestOrganizationElement, true);
  end;
end;

function TFhirExplanationOfBenefit.Link : TFhirExplanationOfBenefit;
begin
  result := TFhirExplanationOfBenefit(inherited Link);
end;

function TFhirExplanationOfBenefit.Clone : TFhirExplanationOfBenefit;
begin
  result := TFhirExplanationOfBenefit(inherited Clone);
end;

procedure TFhirExplanationOfBenefit.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('request');
  fields.add('outcome');
  fields.add('disposition');
  fields.add('ruleset');
  fields.add('originalRuleset');
  fields.add('created');
  fields.add('organization');
  fields.add('requestProvider');
  fields.add('requestOrganization');
end;

{ TFhirExplanationOfBenefit }

Function TFhirExplanationOfBenefit.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirExplanationOfBenefit.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirExplanationOfBenefit.SetRequest(value : TFhirReference{TFhirClaim});
begin
  FRequest.free;
  FRequest := value;
end;

Procedure TFhirExplanationOfBenefit.SetOutcome(value : TFhirEnum);
begin
  FOutcome.free;
  FOutcome := value;
end;

Function TFhirExplanationOfBenefit.GetOutcomeST : TFhirRemittanceOutcomeEnum;
begin
  if FOutcome = nil then
    result := TFhirRemittanceOutcomeEnum(0)
  else
    result := TFhirRemittanceOutcomeEnum(StringArrayIndexOfSensitive(CODES_TFhirRemittanceOutcomeEnum, FOutcome.value));
end;

Procedure TFhirExplanationOfBenefit.SetOutcomeST(value : TFhirRemittanceOutcomeEnum);
begin
  if ord(value) = 0 then
    OutcomeElement := nil
  else
    OutcomeElement := TFhirEnum.create(SYSTEMS_TFhirRemittanceOutcomeEnum[value], CODES_TFhirRemittanceOutcomeEnum[value]);
end;

Procedure TFhirExplanationOfBenefit.SetDisposition(value : TFhirString);
begin
  FDisposition.free;
  FDisposition := value;
end;

Function TFhirExplanationOfBenefit.GetDispositionST : String;
begin
  if FDisposition = nil then
    result := ''
  else
    result := FDisposition.value;
end;

Procedure TFhirExplanationOfBenefit.SetDispositionST(value : String);
begin
  if value <> '' then
  begin
    if FDisposition = nil then
      FDisposition := TFhirString.create;
    FDisposition.value := value
  end
  else if FDisposition <> nil then
    FDisposition.value := '';
end;

Procedure TFhirExplanationOfBenefit.SetRuleset(value : TFhirCoding);
begin
  FRuleset.free;
  FRuleset := value;
end;

Procedure TFhirExplanationOfBenefit.SetOriginalRuleset(value : TFhirCoding);
begin
  FOriginalRuleset.free;
  FOriginalRuleset := value;
end;

Procedure TFhirExplanationOfBenefit.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

Function TFhirExplanationOfBenefit.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

Procedure TFhirExplanationOfBenefit.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

Procedure TFhirExplanationOfBenefit.SetOrganization(value : TFhirReference{TFhirOrganization});
begin
  FOrganization.free;
  FOrganization := value;
end;

Procedure TFhirExplanationOfBenefit.SetRequestProvider(value : TFhirReference{TFhirPractitioner});
begin
  FRequestProvider.free;
  FRequestProvider := value;
end;

Procedure TFhirExplanationOfBenefit.SetRequestOrganization(value : TFhirReference{TFhirOrganization});
begin
  FRequestOrganization.free;
  FRequestOrganization := value;
end;

function TFhirExplanationOfBenefit.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FRequest.sizeInBytes);
  inc(result, FOutcome.sizeInBytes);
  inc(result, FDisposition.sizeInBytes);
  inc(result, FRuleset.sizeInBytes);
  inc(result, FOriginalRuleset.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FOrganization.sizeInBytes);
  inc(result, FRequestProvider.sizeInBytes);
  inc(result, FRequestOrganization.sizeInBytes);
end;

{ TFhirExplanationOfBenefitListEnumerator }

Constructor TFhirExplanationOfBenefitListEnumerator.Create(list : TFhirExplanationOfBenefitList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitListEnumerator.GetCurrent : TFhirExplanationOfBenefit;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitList }
procedure TFhirExplanationOfBenefitList.AddItem(value: TFhirExplanationOfBenefit);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefit', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefit');
  add(value);
end;

function TFhirExplanationOfBenefitList.Append: TFhirExplanationOfBenefit;
begin
  result := TFhirExplanationOfBenefit.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitList.GetEnumerator : TFhirExplanationOfBenefitListEnumerator;
begin
  result := TFhirExplanationOfBenefitListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitList.Clone: TFhirExplanationOfBenefitList;
begin
  result := TFhirExplanationOfBenefitList(inherited Clone);
end;

function TFhirExplanationOfBenefitList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitList.GetItemN(index: Integer): TFhirExplanationOfBenefit;
begin
  result := TFhirExplanationOfBenefit(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefit;
end;
function TFhirExplanationOfBenefitList.IndexOf(value: TFhirExplanationOfBenefit): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitList.Insert(index: Integer): TFhirExplanationOfBenefit;
begin
  result := TFhirExplanationOfBenefit.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitList.InsertItem(index: Integer; value: TFhirExplanationOfBenefit);
begin
  assert(value is TFhirExplanationOfBenefit);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitList.Item(index: Integer): TFhirExplanationOfBenefit;
begin
  result := TFhirExplanationOfBenefit(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitList.Link: TFhirExplanationOfBenefitList;
begin
  result := TFhirExplanationOfBenefitList(inherited Link);
end;

procedure TFhirExplanationOfBenefitList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefit);
begin
  assert(value is TFhirExplanationOfBenefit);
  FhirExplanationOfBenefits[index] := value;
end;

procedure TFhirExplanationOfBenefitList.SetItemN(index: Integer; value: TFhirExplanationOfBenefit);
begin
  assert(value is TFhirExplanationOfBenefit);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_EXPLANATIONOFBENEFIT}

{$IFDEF FHIR_LIST}

{ TFhirListEntry }

constructor TFhirListEntry.Create;
begin
  inherited;
end;

destructor TFhirListEntry.Destroy;
begin
  FFlag.free;
  FDeleted.free;
  FDate.free;
  FItem.free;
  inherited;
end;

procedure TFhirListEntry.Assign(oSource : TFslObject);
begin
  inherited;
  flag := TFhirListEntry(oSource).flag.Clone;
  deletedElement := TFhirListEntry(oSource).deletedElement.Clone;
  dateElement := TFhirListEntry(oSource).dateElement.Clone;
  item := TFhirListEntry(oSource).item.Clone;
end;

procedure TFhirListEntry.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'flag') Then
     list.add(self.link, 'flag', FFlag.Link);
  if (child_name = 'deleted') Then
     list.add(self.link, 'deleted', FDeleted.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'item') Then
     list.add(self.link, 'item', FItem.Link);
end;

procedure TFhirListEntry.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'flag', 'CodeableConcept', false, TFhirCodeableConcept, FFlag.Link));{2}
  oList.add(TFHIRProperty.create(self, 'deleted', 'boolean', false, TFhirBoolean, FDeleted.Link));{2}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'item', 'Reference(Any)', false, TFhirReference{TFhirReference}, FItem.Link));{2}
end;

function TFhirListEntry.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'flag') then
  begin
    Flag := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'deleted') then
  begin
    DeletedElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    Item := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirListEntry.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirListEntry.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'flag') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'deleted') then result := TFhirBoolean.create() {5b}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'item') then result := TFhirReference{TFhirReference}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirListEntry.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'flag') then result := 'CodeableConcept'
  else if (propName = 'deleted') then result := 'boolean'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'item') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirListEntry.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'flag') then FlagElement := nil
  else if (propName = 'deleted') then DeletedElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'item') then ItemElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirListEntry.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'flag') then FlagElement := new as TFhirCodeableConcept{4}
  else if (propName = 'deleted') then DeletedElement := asBoolean(new){5b}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'item') then ItemElement := new as TFhirReference{TFhirReference}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirListEntry.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirListEntry.fhirType : string;
begin
  result := 'entry';
end;

function TFhirListEntry.Link : TFhirListEntry;
begin
  result := TFhirListEntry(inherited Link);
end;

function TFhirListEntry.Clone : TFhirListEntry;
begin
  result := TFhirListEntry(inherited Clone);
end;

function TFhirListEntry.equals(other : TObject) : boolean;
var
  o : TFhirListEntry;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirListEntry)) then
    result := false
  else
  begin
    o := TFhirListEntry(other);
    result := compareDeep(flagElement, o.flagElement, true) and compareDeep(deletedElement, o.deletedElement, true) and
      compareDeep(dateElement, o.dateElement, true) and compareDeep(itemElement, o.itemElement, true);
  end;
end;

function TFhirListEntry.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FFlag) and isEmptyProp(FDeleted) and isEmptyProp(FDate) and isEmptyProp(FItem);
end;

procedure TFhirListEntry.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('flag');
  fields.add('deleted');
  fields.add('date');
  fields.add('item');
end;

{ TFhirListEntry }

Procedure TFhirListEntry.SetFlag(value : TFhirCodeableConcept);
begin
  FFlag.free;
  FFlag := value;
end;

Procedure TFhirListEntry.SetDeleted(value : TFhirBoolean);
begin
  FDeleted.free;
  FDeleted := value;
end;

Function TFhirListEntry.GetDeletedST : Boolean;
begin
  if FDeleted = nil then
    result := false
  else
    result := FDeleted.value;
end;

Procedure TFhirListEntry.SetDeletedST(value : Boolean);
begin
  if FDeleted = nil then
    FDeleted := TFhirBoolean.create;
  FDeleted.value := value
end;

Procedure TFhirListEntry.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirListEntry.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirListEntry.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirListEntry.SetItem(value : TFhirReference{TFhirReference});
begin
  FItem.free;
  FItem := value;
end;

function TFhirListEntry.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FFlag.sizeInBytes);
  inc(result, FDeleted.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FItem.sizeInBytes);
end;

{ TFhirListEntryListEnumerator }

Constructor TFhirListEntryListEnumerator.Create(list : TFhirListEntryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirListEntryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirListEntryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirListEntryListEnumerator.GetCurrent : TFhirListEntry;
begin
  Result := FList[FIndex];
end;

function TFhirListEntryListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirListEntryList }
procedure TFhirListEntryList.AddItem(value: TFhirListEntry);
begin
  assert(value.ClassName = 'TFhirListEntry', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirListEntry');
  add(value);
end;

function TFhirListEntryList.Append: TFhirListEntry;
begin
  result := TFhirListEntry.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirListEntryList.ClearItems;
begin
  Clear;
end;

function TFhirListEntryList.GetEnumerator : TFhirListEntryListEnumerator;
begin
  result := TFhirListEntryListEnumerator.Create(self.link);
end;

function TFhirListEntryList.Clone: TFhirListEntryList;
begin
  result := TFhirListEntryList(inherited Clone);
end;

function TFhirListEntryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirListEntryList.GetItemN(index: Integer): TFhirListEntry;
begin
  result := TFhirListEntry(ObjectByIndex[index]);
end;

function TFhirListEntryList.ItemClass: TFslObjectClass;
begin
  result := TFhirListEntry;
end;
function TFhirListEntryList.IndexOf(value: TFhirListEntry): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirListEntryList.Insert(index: Integer): TFhirListEntry;
begin
  result := TFhirListEntry.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirListEntryList.InsertItem(index: Integer; value: TFhirListEntry);
begin
  assert(value is TFhirListEntry);
  Inherited Insert(index, value);
end;

function TFhirListEntryList.Item(index: Integer): TFhirListEntry;
begin
  result := TFhirListEntry(ObjectByIndex[index]);
end;

function TFhirListEntryList.Link: TFhirListEntryList;
begin
  result := TFhirListEntryList(inherited Link);
end;

procedure TFhirListEntryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirListEntryList.SetItemByIndex(index: Integer; value: TFhirListEntry);
begin
  assert(value is TFhirListEntry);
  FhirListEntries[index] := value;
end;

procedure TFhirListEntryList.SetItemN(index: Integer; value: TFhirListEntry);
begin
  assert(value is TFhirListEntry);
  ObjectByIndex[index] := value;
end;

{ TFhirList }

constructor TFhirList.Create;
begin
  inherited;
end;

destructor TFhirList.Destroy;
begin
  FIdentifierList.Free;
  FTitle.free;
  FCode.free;
  FSubject.free;
  FSource.free;
  FEncounter.free;
  FStatus.free;
  FDate.free;
  FOrderedBy.free;
  FMode.free;
  FNote.free;
  FEntryList.Free;
  FEmptyReason.free;
  inherited;
end;

function TFhirList.GetResourceType : TFhirResourceType;
begin
  result := frtList;
end;

procedure TFhirList.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirList(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirList(oSource).FIdentifierList);
  end;
  titleElement := TFhirList(oSource).titleElement.Clone;
  code := TFhirList(oSource).code.Clone;
  subject := TFhirList(oSource).subject.Clone;
  source := TFhirList(oSource).source.Clone;
  encounter := TFhirList(oSource).encounter.Clone;
  FStatus := TFhirList(oSource).FStatus.Link;
  dateElement := TFhirList(oSource).dateElement.Clone;
  orderedBy := TFhirList(oSource).orderedBy.Clone;
  FMode := TFhirList(oSource).FMode.Link;
  noteElement := TFhirList(oSource).noteElement.Clone;
  if (TFhirList(oSource).FEntryList = nil) then
  begin
    FEntryList.free;
    FEntryList := nil;
  end
  else
  begin
    if FEntryList = nil then
      FEntryList := TFhirListEntryList.Create;
    FEntryList.Assign(TFhirList(oSource).FEntryList);
  end;
  emptyReason := TFhirList(oSource).emptyReason.Clone;
end;

procedure TFhirList.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'orderedBy') Then
     list.add(self.link, 'orderedBy', FOrderedBy.Link);
  if (child_name = 'mode') Then
     list.add(self.link, 'mode', FMode.Link);
  if (child_name = 'note') Then
     list.add(self.link, 'note', FNote.Link);
  if (child_name = 'entry') Then
    list.addAll(self, 'entry', FEntryList);
  if (child_name = 'emptyReason') Then
     list.add(self.link, 'emptyReason', FEmptyReason.Link);
end;

procedure TFhirList.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Group|Device|Location)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'source', 'Reference(Practitioner|Patient|Device)', false, TFhirReference{Resource}, FSource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference(Encounter)', false, TFhirReference{TFhirEncounter}, FEncounter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'orderedBy', 'CodeableConcept', false, TFhirCodeableConcept, FOrderedBy.Link));{2}
  oList.add(TFHIRProperty.create(self, 'mode', 'code', false, TFHIREnum, FMode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'note', 'string', false, TFhirString, FNote.Link));{2}
  oList.add(TFHIRProperty.create(self, 'entry', '', true, TFhirListEntry, FEntryList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'emptyReason', 'CodeableConcept', false, TFhirCodeableConcept, FEmptyReason.Link));{2}
end;

function TFhirList.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    Source := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference{TFhirEncounter}{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirListStatusEnum, CODES_TFhirListStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'orderedBy') then
  begin
    OrderedBy := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'mode') then
  begin
    ModeElement := asEnum(SYSTEMS_TFhirListModeEnum, CODES_TFhirListModeEnum, propValue);
    result := propValue
  end
  else if (propName = 'note') then
  begin
    NoteElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'entry') then
  begin
    EntryList.add(propValue as TFhirListEntry){2a};
    result := propValue;
  end
  else if (propName = 'emptyReason') then
  begin
    EmptyReason := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirList.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'entry') then EntryList.insertItem(index, propValue as TFhirListEntry){2a}
  else inherited;
end;

function TFhirList.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'title') then result := TFhirString.create() {5b}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'source') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'encounter') then result := TFhirReference{TFhirEncounter}.create(){4b}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'orderedBy') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'note') then result := TFhirString.create() {5b}
  else if (propName = 'entry') then result := EntryList.new(){2}
  else if (propName = 'emptyReason') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirList.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'source') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'orderedBy') then result := 'CodeableConcept'
  else if (propName = 'mode') then result := 'code'
  else if (propName = 'note') then result := 'string'
  else if (propName = 'entry') then result := ''
  else if (propName = 'emptyReason') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirList.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'source') then SourceElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'orderedBy') then OrderedByElement := nil
  else if (propName = 'mode') then ModeElement := nil
  else if (propName = 'note') then NoteElement := nil
  else if (propName = 'entry') then deletePropertyValue('entry', EntryList, value) {2}
  else if (propName = 'emptyReason') then EmptyReasonElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirList.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'title') then TitleElement := asString(new){5b}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'source') then SourceElement := new as TFhirReference{Resource}{4}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference{TFhirEncounter}{4}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirListStatusEnum, CODES_TFhirListStatusEnum, new){4}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'orderedBy') then OrderedByElement := new as TFhirCodeableConcept{4}
  else if (propName = 'mode') then ModeElement := asEnum(SYSTEMS_TFhirListModeEnum, CODES_TFhirListModeEnum, new){4}
  else if (propName = 'note') then NoteElement := asString(new){5b}
  else if (propName = 'entry') then replacePropertyValue('entry', EntryList, existing, new) {2}
  else if (propName = 'emptyReason') then EmptyReasonElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirList.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'entry') then EntryList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirList.fhirType : string;
begin
  result := 'List';
end;

function TFhirList.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FTitle) and isEmptyProp(FCode) and isEmptyProp(FSubject) and isEmptyProp(FSource) and isEmptyProp(FEncounter) and isEmptyProp(FStatus) and isEmptyProp(FDate) and isEmptyProp(FOrderedBy) and isEmptyProp(FMode) and isEmptyProp(FNote) and isEmptyProp(FentryList) and isEmptyProp(FEmptyReason);
end;

function TFhirList.equals(other : TObject) : boolean;
var
  o : TFhirList;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirList)) then
    result := false
  else
  begin
    o := TFhirList(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(titleElement, o.titleElement, true) and
      compareDeep(codeElement, o.codeElement, true) and compareDeep(subjectElement, o.subjectElement, true) and
      compareDeep(sourceElement, o.sourceElement, true) and compareDeep(encounterElement, o.encounterElement, true) and
      compareDeep(statusElement, o.statusElement, true) and compareDeep(dateElement, o.dateElement, true) and
      compareDeep(orderedByElement, o.orderedByElement, true) and compareDeep(modeElement, o.modeElement, true) and
      compareDeep(noteElement, o.noteElement, true) and compareDeep(entryList, o.entryList, true) and
      compareDeep(emptyReasonElement, o.emptyReasonElement, true);
  end;
end;

function TFhirList.Link : TFhirList;
begin
  result := TFhirList(inherited Link);
end;

function TFhirList.Clone : TFhirList;
begin
  result := TFhirList(inherited Clone);
end;

procedure TFhirList.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('title');
  fields.add('code');
  fields.add('subject');
  fields.add('source');
  fields.add('encounter');
  fields.add('status');
  fields.add('date');
  fields.add('orderedBy');
  fields.add('mode');
  fields.add('note');
  fields.add('entry');
  fields.add('emptyReason');
end;

{ TFhirList }

Function TFhirList.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirList.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirList.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

Function TFhirList.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

Procedure TFhirList.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

Procedure TFhirList.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirList.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirList.SetSource(value : TFhirReference{Resource});
begin
  FSource.free;
  FSource := value;
end;

Procedure TFhirList.SetEncounter(value : TFhirReference{TFhirEncounter});
begin
  FEncounter.free;
  FEncounter := value;
end;

Procedure TFhirList.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirList.GetStatusST : TFhirListStatusEnum;
begin
  if FStatus = nil then
    result := TFhirListStatusEnum(0)
  else
    result := TFhirListStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirListStatusEnum, FStatus.value));
end;

Procedure TFhirList.SetStatusST(value : TFhirListStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirListStatusEnum[value], CODES_TFhirListStatusEnum[value]);
end;

Procedure TFhirList.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirList.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirList.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirList.SetOrderedBy(value : TFhirCodeableConcept);
begin
  FOrderedBy.free;
  FOrderedBy := value;
end;

Procedure TFhirList.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

Function TFhirList.GetModeST : TFhirListModeEnum;
begin
  if FMode = nil then
    result := TFhirListModeEnum(0)
  else
    result := TFhirListModeEnum(StringArrayIndexOfSensitive(CODES_TFhirListModeEnum, FMode.value));
end;

Procedure TFhirList.SetModeST(value : TFhirListModeEnum);
begin
  if ord(value) = 0 then
    ModeElement := nil
  else
    ModeElement := TFhirEnum.create(SYSTEMS_TFhirListModeEnum[value], CODES_TFhirListModeEnum[value]);
end;

Procedure TFhirList.SetNote(value : TFhirString);
begin
  FNote.free;
  FNote := value;
end;

Function TFhirList.GetNoteST : String;
begin
  if FNote = nil then
    result := ''
  else
    result := FNote.value;
end;

Procedure TFhirList.SetNoteST(value : String);
begin
  if value <> '' then
  begin
    if FNote = nil then
      FNote := TFhirString.create;
    FNote.value := value
  end
  else if FNote <> nil then
    FNote.value := '';
end;

Function TFhirList.GetEntryList : TFhirListEntryList;
begin
  if FEntryList = nil then
    FEntryList := TFhirListEntryList.Create;
  result := FEntryList;
end;

Function TFhirList.GetHasEntryList : boolean;
begin
  result := (FEntryList <> nil) and (FEntryList.count > 0);
end;

Procedure TFhirList.SetEmptyReason(value : TFhirCodeableConcept);
begin
  FEmptyReason.free;
  FEmptyReason := value;
end;

function TFhirList.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FTitle.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FSource.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FOrderedBy.sizeInBytes);
  inc(result, FMode.sizeInBytes);
  inc(result, FNote.sizeInBytes);
  inc(result, FentryList.sizeInBytes);
  inc(result, FEmptyReason.sizeInBytes);
end;

{ TFhirListListEnumerator }

Constructor TFhirListListEnumerator.Create(list : TFhirListList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirListListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirListListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirListListEnumerator.GetCurrent : TFhirList;
begin
  Result := FList[FIndex];
end;

function TFhirListListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirListList }
procedure TFhirListList.AddItem(value: TFhirList);
begin
  assert(value.ClassName = 'TFhirList', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirList');
  add(value);
end;

function TFhirListList.Append: TFhirList;
begin
  result := TFhirList.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirListList.ClearItems;
begin
  Clear;
end;

function TFhirListList.GetEnumerator : TFhirListListEnumerator;
begin
  result := TFhirListListEnumerator.Create(self.link);
end;

function TFhirListList.Clone: TFhirListList;
begin
  result := TFhirListList(inherited Clone);
end;

function TFhirListList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirListList.GetItemN(index: Integer): TFhirList;
begin
  result := TFhirList(ObjectByIndex[index]);
end;

function TFhirListList.ItemClass: TFslObjectClass;
begin
  result := TFhirList;
end;
function TFhirListList.IndexOf(value: TFhirList): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirListList.Insert(index: Integer): TFhirList;
begin
  result := TFhirList.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirListList.InsertItem(index: Integer; value: TFhirList);
begin
  assert(value is TFhirList);
  Inherited Insert(index, value);
end;

function TFhirListList.Item(index: Integer): TFhirList;
begin
  result := TFhirList(ObjectByIndex[index]);
end;

function TFhirListList.Link: TFhirListList;
begin
  result := TFhirListList(inherited Link);
end;

procedure TFhirListList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirListList.SetItemByIndex(index: Integer; value: TFhirList);
begin
  assert(value is TFhirList);
  FhirLists[index] := value;
end;

procedure TFhirListList.SetItemN(index: Integer; value: TFhirList);
begin
  assert(value is TFhirList);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_LIST}

{$IFDEF FHIR_MEDICATION}

{ TFhirMedicationProduct }

constructor TFhirMedicationProduct.Create;
begin
  inherited;
end;

destructor TFhirMedicationProduct.Destroy;
begin
  FForm.free;
  FIngredientList.Free;
  FBatchList.Free;
  inherited;
end;

procedure TFhirMedicationProduct.Assign(oSource : TFslObject);
begin
  inherited;
  form := TFhirMedicationProduct(oSource).form.Clone;
  if (TFhirMedicationProduct(oSource).FIngredientList = nil) then
  begin
    FIngredientList.free;
    FIngredientList := nil;
  end
  else
  begin
    if FIngredientList = nil then
      FIngredientList := TFhirMedicationProductIngredientList.Create;
    FIngredientList.Assign(TFhirMedicationProduct(oSource).FIngredientList);
  end;
  if (TFhirMedicationProduct(oSource).FBatchList = nil) then
  begin
    FBatchList.free;
    FBatchList := nil;
  end
  else
  begin
    if FBatchList = nil then
      FBatchList := TFhirMedicationProductBatchList.Create;
    FBatchList.Assign(TFhirMedicationProduct(oSource).FBatchList);
  end;
end;

procedure TFhirMedicationProduct.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'form') Then
     list.add(self.link, 'form', FForm.Link);
  if (child_name = 'ingredient') Then
    list.addAll(self, 'ingredient', FIngredientList);
  if (child_name = 'batch') Then
    list.addAll(self, 'batch', FBatchList);
end;

procedure TFhirMedicationProduct.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'form', 'CodeableConcept', false, TFhirCodeableConcept, FForm.Link));{2}
  oList.add(TFHIRProperty.create(self, 'ingredient', '', true, TFhirMedicationProductIngredient, FIngredientList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'batch', '', true, TFhirMedicationProductBatch, FBatchList.Link)){3};
end;

function TFhirMedicationProduct.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'form') then
  begin
    Form := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'ingredient') then
  begin
    IngredientList.add(propValue as TFhirMedicationProductIngredient){2a};
    result := propValue;
  end
  else if (propName = 'batch') then
  begin
    BatchList.add(propValue as TFhirMedicationProductBatch){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationProduct.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'ingredient') then IngredientList.insertItem(index, propValue as TFhirMedicationProductIngredient){2a}
  else if (propName = 'batch') then BatchList.insertItem(index, propValue as TFhirMedicationProductBatch){2a}
  else inherited;
end;

function TFhirMedicationProduct.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'form') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'ingredient') then result := IngredientList.new(){2}
  else if (propName = 'batch') then result := BatchList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationProduct.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'form') then result := 'CodeableConcept'
  else if (propName = 'ingredient') then result := ''
  else if (propName = 'batch') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationProduct.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'form') then FormElement := nil
  else if (propName = 'ingredient') then deletePropertyValue('ingredient', IngredientList, value) {2}
  else if (propName = 'batch') then deletePropertyValue('batch', BatchList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationProduct.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'form') then FormElement := new as TFhirCodeableConcept{4}
  else if (propName = 'ingredient') then replacePropertyValue('ingredient', IngredientList, existing, new) {2}
  else if (propName = 'batch') then replacePropertyValue('batch', BatchList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationProduct.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'ingredient') then IngredientList.move(source, destination){2a}
  else if (propName = 'batch') then BatchList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationProduct.fhirType : string;
begin
  result := 'product';
end;

function TFhirMedicationProduct.Link : TFhirMedicationProduct;
begin
  result := TFhirMedicationProduct(inherited Link);
end;

function TFhirMedicationProduct.Clone : TFhirMedicationProduct;
begin
  result := TFhirMedicationProduct(inherited Clone);
end;

function TFhirMedicationProduct.equals(other : TObject) : boolean;
var
  o : TFhirMedicationProduct;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationProduct)) then
    result := false
  else
  begin
    o := TFhirMedicationProduct(other);
    result := compareDeep(formElement, o.formElement, true) and compareDeep(ingredientList, o.ingredientList, true) and
      compareDeep(batchList, o.batchList, true);
  end;
end;

function TFhirMedicationProduct.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FForm) and isEmptyProp(FingredientList) and isEmptyProp(FbatchList);
end;

procedure TFhirMedicationProduct.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('form');
  fields.add('ingredient');
  fields.add('batch');
end;

{ TFhirMedicationProduct }

Procedure TFhirMedicationProduct.SetForm(value : TFhirCodeableConcept);
begin
  FForm.free;
  FForm := value;
end;

Function TFhirMedicationProduct.GetIngredientList : TFhirMedicationProductIngredientList;
begin
  if FIngredientList = nil then
    FIngredientList := TFhirMedicationProductIngredientList.Create;
  result := FIngredientList;
end;

Function TFhirMedicationProduct.GetHasIngredientList : boolean;
begin
  result := (FIngredientList <> nil) and (FIngredientList.count > 0);
end;

Function TFhirMedicationProduct.GetBatchList : TFhirMedicationProductBatchList;
begin
  if FBatchList = nil then
    FBatchList := TFhirMedicationProductBatchList.Create;
  result := FBatchList;
end;

Function TFhirMedicationProduct.GetHasBatchList : boolean;
begin
  result := (FBatchList <> nil) and (FBatchList.count > 0);
end;

function TFhirMedicationProduct.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FForm.sizeInBytes);
  inc(result, FingredientList.sizeInBytes);
  inc(result, FbatchList.sizeInBytes);
end;

{ TFhirMedicationProductListEnumerator }

Constructor TFhirMedicationProductListEnumerator.Create(list : TFhirMedicationProductList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationProductListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationProductListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationProductListEnumerator.GetCurrent : TFhirMedicationProduct;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationProductListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationProductList }
procedure TFhirMedicationProductList.AddItem(value: TFhirMedicationProduct);
begin
  assert(value.ClassName = 'TFhirMedicationProduct', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationProduct');
  add(value);
end;

function TFhirMedicationProductList.Append: TFhirMedicationProduct;
begin
  result := TFhirMedicationProduct.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationProductList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationProductList.GetEnumerator : TFhirMedicationProductListEnumerator;
begin
  result := TFhirMedicationProductListEnumerator.Create(self.link);
end;

function TFhirMedicationProductList.Clone: TFhirMedicationProductList;
begin
  result := TFhirMedicationProductList(inherited Clone);
end;

function TFhirMedicationProductList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationProductList.GetItemN(index: Integer): TFhirMedicationProduct;
begin
  result := TFhirMedicationProduct(ObjectByIndex[index]);
end;

function TFhirMedicationProductList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationProduct;
end;
function TFhirMedicationProductList.IndexOf(value: TFhirMedicationProduct): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationProductList.Insert(index: Integer): TFhirMedicationProduct;
begin
  result := TFhirMedicationProduct.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationProductList.InsertItem(index: Integer; value: TFhirMedicationProduct);
begin
  assert(value is TFhirMedicationProduct);
  Inherited Insert(index, value);
end;

function TFhirMedicationProductList.Item(index: Integer): TFhirMedicationProduct;
begin
  result := TFhirMedicationProduct(ObjectByIndex[index]);
end;

function TFhirMedicationProductList.Link: TFhirMedicationProductList;
begin
  result := TFhirMedicationProductList(inherited Link);
end;

procedure TFhirMedicationProductList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationProductList.SetItemByIndex(index: Integer; value: TFhirMedicationProduct);
begin
  assert(value is TFhirMedicationProduct);
  FhirMedicationProducts[index] := value;
end;

procedure TFhirMedicationProductList.SetItemN(index: Integer; value: TFhirMedicationProduct);
begin
  assert(value is TFhirMedicationProduct);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationProductIngredient }

constructor TFhirMedicationProductIngredient.Create;
begin
  inherited;
end;

destructor TFhirMedicationProductIngredient.Destroy;
begin
  FItem.free;
  FAmount.free;
  inherited;
end;

procedure TFhirMedicationProductIngredient.Assign(oSource : TFslObject);
begin
  inherited;
  item := TFhirMedicationProductIngredient(oSource).item.Clone;
  amount := TFhirMedicationProductIngredient(oSource).amount.Clone;
end;

procedure TFhirMedicationProductIngredient.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'item') Then
     list.add(self.link, 'item', FItem.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
end;

procedure TFhirMedicationProductIngredient.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'item', 'Reference(Substance|Medication)', false, TFhirReference{Resource}, FItem.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amount', 'Ratio', false, TFhirRatio, FAmount.Link));{2}
end;

function TFhirMedicationProductIngredient.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'item') then
  begin
    Item := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirRatio{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationProductIngredient.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationProductIngredient.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'item') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'amount') then result := TFhirRatio.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationProductIngredient.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'item') then result := 'Reference'
  else if (propName = 'amount') then result := 'Ratio'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationProductIngredient.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'item') then ItemElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationProductIngredient.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'item') then ItemElement := new as TFhirReference{Resource}{4}
  else if (propName = 'amount') then AmountElement := new as TFhirRatio{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationProductIngredient.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationProductIngredient.fhirType : string;
begin
  result := 'ingredient';
end;

function TFhirMedicationProductIngredient.Link : TFhirMedicationProductIngredient;
begin
  result := TFhirMedicationProductIngredient(inherited Link);
end;

function TFhirMedicationProductIngredient.Clone : TFhirMedicationProductIngredient;
begin
  result := TFhirMedicationProductIngredient(inherited Clone);
end;

function TFhirMedicationProductIngredient.equals(other : TObject) : boolean;
var
  o : TFhirMedicationProductIngredient;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationProductIngredient)) then
    result := false
  else
  begin
    o := TFhirMedicationProductIngredient(other);
    result := compareDeep(itemElement, o.itemElement, true) and compareDeep(amountElement, o.amountElement, true);
  end;
end;

function TFhirMedicationProductIngredient.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FItem) and isEmptyProp(FAmount);
end;

procedure TFhirMedicationProductIngredient.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('item');
  fields.add('amount');
end;

{ TFhirMedicationProductIngredient }

Procedure TFhirMedicationProductIngredient.SetItem(value : TFhirReference{Resource});
begin
  FItem.free;
  FItem := value;
end;

Procedure TFhirMedicationProductIngredient.SetAmount(value : TFhirRatio);
begin
  FAmount.free;
  FAmount := value;
end;

function TFhirMedicationProductIngredient.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FItem.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
end;

{ TFhirMedicationProductIngredientListEnumerator }

Constructor TFhirMedicationProductIngredientListEnumerator.Create(list : TFhirMedicationProductIngredientList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationProductIngredientListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationProductIngredientListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationProductIngredientListEnumerator.GetCurrent : TFhirMedicationProductIngredient;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationProductIngredientListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationProductIngredientList }
procedure TFhirMedicationProductIngredientList.AddItem(value: TFhirMedicationProductIngredient);
begin
  assert(value.ClassName = 'TFhirMedicationProductIngredient', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationProductIngredient');
  add(value);
end;

function TFhirMedicationProductIngredientList.Append: TFhirMedicationProductIngredient;
begin
  result := TFhirMedicationProductIngredient.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationProductIngredientList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationProductIngredientList.GetEnumerator : TFhirMedicationProductIngredientListEnumerator;
begin
  result := TFhirMedicationProductIngredientListEnumerator.Create(self.link);
end;

function TFhirMedicationProductIngredientList.Clone: TFhirMedicationProductIngredientList;
begin
  result := TFhirMedicationProductIngredientList(inherited Clone);
end;

function TFhirMedicationProductIngredientList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationProductIngredientList.GetItemN(index: Integer): TFhirMedicationProductIngredient;
begin
  result := TFhirMedicationProductIngredient(ObjectByIndex[index]);
end;

function TFhirMedicationProductIngredientList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationProductIngredient;
end;
function TFhirMedicationProductIngredientList.IndexOf(value: TFhirMedicationProductIngredient): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationProductIngredientList.Insert(index: Integer): TFhirMedicationProductIngredient;
begin
  result := TFhirMedicationProductIngredient.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationProductIngredientList.InsertItem(index: Integer; value: TFhirMedicationProductIngredient);
begin
  assert(value is TFhirMedicationProductIngredient);
  Inherited Insert(index, value);
end;

function TFhirMedicationProductIngredientList.Item(index: Integer): TFhirMedicationProductIngredient;
begin
  result := TFhirMedicationProductIngredient(ObjectByIndex[index]);
end;

function TFhirMedicationProductIngredientList.Link: TFhirMedicationProductIngredientList;
begin
  result := TFhirMedicationProductIngredientList(inherited Link);
end;

procedure TFhirMedicationProductIngredientList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationProductIngredientList.SetItemByIndex(index: Integer; value: TFhirMedicationProductIngredient);
begin
  assert(value is TFhirMedicationProductIngredient);
  FhirMedicationProductIngredients[index] := value;
end;

procedure TFhirMedicationProductIngredientList.SetItemN(index: Integer; value: TFhirMedicationProductIngredient);
begin
  assert(value is TFhirMedicationProductIngredient);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationProductBatch }

constructor TFhirMedicationProductBatch.Create;
begin
  inherited;
end;

destructor TFhirMedicationProductBatch.Destroy;
begin
  FLotNumber.free;
  FExpirationDate.free;
  inherited;
end;

procedure TFhirMedicationProductBatch.Assign(oSource : TFslObject);
begin
  inherited;
  lotNumberElement := TFhirMedicationProductBatch(oSource).lotNumberElement.Clone;
  expirationDateElement := TFhirMedicationProductBatch(oSource).expirationDateElement.Clone;
end;

procedure TFhirMedicationProductBatch.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'lotNumber') Then
     list.add(self.link, 'lotNumber', FLotNumber.Link);
  if (child_name = 'expirationDate') Then
     list.add(self.link, 'expirationDate', FExpirationDate.Link);
end;

procedure TFhirMedicationProductBatch.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'lotNumber', 'string', false, TFhirString, FLotNumber.Link));{2}
  oList.add(TFHIRProperty.create(self, 'expirationDate', 'dateTime', false, TFhirDateTime, FExpirationDate.Link));{2}
end;

function TFhirMedicationProductBatch.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'lotNumber') then
  begin
    LotNumberElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'expirationDate') then
  begin
    ExpirationDateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationProductBatch.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationProductBatch.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'lotNumber') then result := TFhirString.create() {5b}
  else if (propName = 'expirationDate') then result := TFhirDateTime.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationProductBatch.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'lotNumber') then result := 'string'
  else if (propName = 'expirationDate') then result := 'dateTime'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationProductBatch.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'lotNumber') then LotNumberElement := nil
  else if (propName = 'expirationDate') then ExpirationDateElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationProductBatch.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'lotNumber') then LotNumberElement := asString(new){5b}
  else if (propName = 'expirationDate') then ExpirationDateElement := asDateTime(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationProductBatch.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationProductBatch.fhirType : string;
begin
  result := 'batch';
end;

function TFhirMedicationProductBatch.Link : TFhirMedicationProductBatch;
begin
  result := TFhirMedicationProductBatch(inherited Link);
end;

function TFhirMedicationProductBatch.Clone : TFhirMedicationProductBatch;
begin
  result := TFhirMedicationProductBatch(inherited Clone);
end;

function TFhirMedicationProductBatch.equals(other : TObject) : boolean;
var
  o : TFhirMedicationProductBatch;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationProductBatch)) then
    result := false
  else
  begin
    o := TFhirMedicationProductBatch(other);
    result := compareDeep(lotNumberElement, o.lotNumberElement, true) and compareDeep(expirationDateElement, o.expirationDateElement, true);
  end;
end;

function TFhirMedicationProductBatch.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLotNumber) and isEmptyProp(FExpirationDate);
end;

procedure TFhirMedicationProductBatch.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('lotNumber');
  fields.add('expirationDate');
end;

{ TFhirMedicationProductBatch }

Procedure TFhirMedicationProductBatch.SetLotNumber(value : TFhirString);
begin
  FLotNumber.free;
  FLotNumber := value;
end;

Function TFhirMedicationProductBatch.GetLotNumberST : String;
begin
  if FLotNumber = nil then
    result := ''
  else
    result := FLotNumber.value;
end;

Procedure TFhirMedicationProductBatch.SetLotNumberST(value : String);
begin
  if value <> '' then
  begin
    if FLotNumber = nil then
      FLotNumber := TFhirString.create;
    FLotNumber.value := value
  end
  else if FLotNumber <> nil then
    FLotNumber.value := '';
end;

Procedure TFhirMedicationProductBatch.SetExpirationDate(value : TFhirDateTime);
begin
  FExpirationDate.free;
  FExpirationDate := value;
end;

Function TFhirMedicationProductBatch.GetExpirationDateST : TFslDateTime;
begin
  if FExpirationDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FExpirationDate.value;
end;

Procedure TFhirMedicationProductBatch.SetExpirationDateST(value : TFslDateTime);
begin
  if FExpirationDate = nil then
    FExpirationDate := TFhirDateTime.create;
  FExpirationDate.value := value
end;

function TFhirMedicationProductBatch.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FLotNumber.sizeInBytes);
  inc(result, FExpirationDate.sizeInBytes);
end;

{ TFhirMedicationProductBatchListEnumerator }

Constructor TFhirMedicationProductBatchListEnumerator.Create(list : TFhirMedicationProductBatchList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationProductBatchListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationProductBatchListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationProductBatchListEnumerator.GetCurrent : TFhirMedicationProductBatch;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationProductBatchListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationProductBatchList }
procedure TFhirMedicationProductBatchList.AddItem(value: TFhirMedicationProductBatch);
begin
  assert(value.ClassName = 'TFhirMedicationProductBatch', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationProductBatch');
  add(value);
end;

function TFhirMedicationProductBatchList.Append: TFhirMedicationProductBatch;
begin
  result := TFhirMedicationProductBatch.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationProductBatchList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationProductBatchList.GetEnumerator : TFhirMedicationProductBatchListEnumerator;
begin
  result := TFhirMedicationProductBatchListEnumerator.Create(self.link);
end;

function TFhirMedicationProductBatchList.Clone: TFhirMedicationProductBatchList;
begin
  result := TFhirMedicationProductBatchList(inherited Clone);
end;

function TFhirMedicationProductBatchList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationProductBatchList.GetItemN(index: Integer): TFhirMedicationProductBatch;
begin
  result := TFhirMedicationProductBatch(ObjectByIndex[index]);
end;

function TFhirMedicationProductBatchList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationProductBatch;
end;
function TFhirMedicationProductBatchList.IndexOf(value: TFhirMedicationProductBatch): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationProductBatchList.Insert(index: Integer): TFhirMedicationProductBatch;
begin
  result := TFhirMedicationProductBatch.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationProductBatchList.InsertItem(index: Integer; value: TFhirMedicationProductBatch);
begin
  assert(value is TFhirMedicationProductBatch);
  Inherited Insert(index, value);
end;

function TFhirMedicationProductBatchList.Item(index: Integer): TFhirMedicationProductBatch;
begin
  result := TFhirMedicationProductBatch(ObjectByIndex[index]);
end;

function TFhirMedicationProductBatchList.Link: TFhirMedicationProductBatchList;
begin
  result := TFhirMedicationProductBatchList(inherited Link);
end;

procedure TFhirMedicationProductBatchList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationProductBatchList.SetItemByIndex(index: Integer; value: TFhirMedicationProductBatch);
begin
  assert(value is TFhirMedicationProductBatch);
  FhirMedicationProductBatches[index] := value;
end;

procedure TFhirMedicationProductBatchList.SetItemN(index: Integer; value: TFhirMedicationProductBatch);
begin
  assert(value is TFhirMedicationProductBatch);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationPackage }

constructor TFhirMedicationPackage.Create;
begin
  inherited;
end;

destructor TFhirMedicationPackage.Destroy;
begin
  FContainer.free;
  FContentList.Free;
  inherited;
end;

procedure TFhirMedicationPackage.Assign(oSource : TFslObject);
begin
  inherited;
  container := TFhirMedicationPackage(oSource).container.Clone;
  if (TFhirMedicationPackage(oSource).FContentList = nil) then
  begin
    FContentList.free;
    FContentList := nil;
  end
  else
  begin
    if FContentList = nil then
      FContentList := TFhirMedicationPackageContentList.Create;
    FContentList.Assign(TFhirMedicationPackage(oSource).FContentList);
  end;
end;

procedure TFhirMedicationPackage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'container') Then
     list.add(self.link, 'container', FContainer.Link);
  if (child_name = 'content') Then
    list.addAll(self, 'content', FContentList);
end;

procedure TFhirMedicationPackage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'container', 'CodeableConcept', false, TFhirCodeableConcept, FContainer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'content', '', true, TFhirMedicationPackageContent, FContentList.Link)){3};
end;

function TFhirMedicationPackage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'container') then
  begin
    Container := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'content') then
  begin
    ContentList.add(propValue as TFhirMedicationPackageContent){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationPackage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'content') then ContentList.insertItem(index, propValue as TFhirMedicationPackageContent){2a}
  else inherited;
end;

function TFhirMedicationPackage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'container') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'content') then result := ContentList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationPackage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'container') then result := 'CodeableConcept'
  else if (propName = 'content') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationPackage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'container') then ContainerElement := nil
  else if (propName = 'content') then deletePropertyValue('content', ContentList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationPackage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'container') then ContainerElement := new as TFhirCodeableConcept{4}
  else if (propName = 'content') then replacePropertyValue('content', ContentList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationPackage.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'content') then ContentList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationPackage.fhirType : string;
begin
  result := 'package';
end;

function TFhirMedicationPackage.Link : TFhirMedicationPackage;
begin
  result := TFhirMedicationPackage(inherited Link);
end;

function TFhirMedicationPackage.Clone : TFhirMedicationPackage;
begin
  result := TFhirMedicationPackage(inherited Clone);
end;

function TFhirMedicationPackage.equals(other : TObject) : boolean;
var
  o : TFhirMedicationPackage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationPackage)) then
    result := false
  else
  begin
    o := TFhirMedicationPackage(other);
    result := compareDeep(containerElement, o.containerElement, true) and compareDeep(contentList, o.contentList, true);
  end;
end;

function TFhirMedicationPackage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FContainer) and isEmptyProp(FcontentList);
end;

procedure TFhirMedicationPackage.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('container');
  fields.add('content');
end;

{ TFhirMedicationPackage }

Procedure TFhirMedicationPackage.SetContainer(value : TFhirCodeableConcept);
begin
  FContainer.free;
  FContainer := value;
end;

Function TFhirMedicationPackage.GetContentList : TFhirMedicationPackageContentList;
begin
  if FContentList = nil then
    FContentList := TFhirMedicationPackageContentList.Create;
  result := FContentList;
end;

Function TFhirMedicationPackage.GetHasContentList : boolean;
begin
  result := (FContentList <> nil) and (FContentList.count > 0);
end;

function TFhirMedicationPackage.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FContainer.sizeInBytes);
  inc(result, FcontentList.sizeInBytes);
end;

{ TFhirMedicationPackageListEnumerator }

Constructor TFhirMedicationPackageListEnumerator.Create(list : TFhirMedicationPackageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationPackageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationPackageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationPackageListEnumerator.GetCurrent : TFhirMedicationPackage;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationPackageListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationPackageList }
procedure TFhirMedicationPackageList.AddItem(value: TFhirMedicationPackage);
begin
  assert(value.ClassName = 'TFhirMedicationPackage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationPackage');
  add(value);
end;

function TFhirMedicationPackageList.Append: TFhirMedicationPackage;
begin
  result := TFhirMedicationPackage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationPackageList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationPackageList.GetEnumerator : TFhirMedicationPackageListEnumerator;
begin
  result := TFhirMedicationPackageListEnumerator.Create(self.link);
end;

function TFhirMedicationPackageList.Clone: TFhirMedicationPackageList;
begin
  result := TFhirMedicationPackageList(inherited Clone);
end;

function TFhirMedicationPackageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationPackageList.GetItemN(index: Integer): TFhirMedicationPackage;
begin
  result := TFhirMedicationPackage(ObjectByIndex[index]);
end;

function TFhirMedicationPackageList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationPackage;
end;
function TFhirMedicationPackageList.IndexOf(value: TFhirMedicationPackage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationPackageList.Insert(index: Integer): TFhirMedicationPackage;
begin
  result := TFhirMedicationPackage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationPackageList.InsertItem(index: Integer; value: TFhirMedicationPackage);
begin
  assert(value is TFhirMedicationPackage);
  Inherited Insert(index, value);
end;

function TFhirMedicationPackageList.Item(index: Integer): TFhirMedicationPackage;
begin
  result := TFhirMedicationPackage(ObjectByIndex[index]);
end;

function TFhirMedicationPackageList.Link: TFhirMedicationPackageList;
begin
  result := TFhirMedicationPackageList(inherited Link);
end;

procedure TFhirMedicationPackageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationPackageList.SetItemByIndex(index: Integer; value: TFhirMedicationPackage);
begin
  assert(value is TFhirMedicationPackage);
  FhirMedicationPackages[index] := value;
end;

procedure TFhirMedicationPackageList.SetItemN(index: Integer; value: TFhirMedicationPackage);
begin
  assert(value is TFhirMedicationPackage);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationPackageContent }

constructor TFhirMedicationPackageContent.Create;
begin
  inherited;
end;

destructor TFhirMedicationPackageContent.Destroy;
begin
  FItem.free;
  FAmount.free;
  inherited;
end;

procedure TFhirMedicationPackageContent.Assign(oSource : TFslObject);
begin
  inherited;
  item := TFhirMedicationPackageContent(oSource).item.Clone;
  amount := TFhirMedicationPackageContent(oSource).amount.Clone;
end;

procedure TFhirMedicationPackageContent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'item') Then
     list.add(self.link, 'item', FItem.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
end;

procedure TFhirMedicationPackageContent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'item', 'Reference(Medication)', false, TFhirReference{TFhirMedication}, FItem.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amount', 'Quantity', false, TFhirQuantity, FAmount.Link));{2}
end;

function TFhirMedicationPackageContent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'item') then
  begin
    Item := propValue as TFhirReference{TFhirMedication}{4b};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationPackageContent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationPackageContent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'item') then result := TFhirReference{TFhirMedication}.create(){4b}
  else if (propName = 'amount') then result := TFhirQuantity.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationPackageContent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'item') then result := 'Reference'
  else if (propName = 'amount') then result := 'Quantity'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationPackageContent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'item') then ItemElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationPackageContent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'item') then ItemElement := new as TFhirReference{TFhirMedication}{4}
  else if (propName = 'amount') then AmountElement := new as TFhirQuantity{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationPackageContent.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationPackageContent.fhirType : string;
begin
  result := 'content';
end;

function TFhirMedicationPackageContent.Link : TFhirMedicationPackageContent;
begin
  result := TFhirMedicationPackageContent(inherited Link);
end;

function TFhirMedicationPackageContent.Clone : TFhirMedicationPackageContent;
begin
  result := TFhirMedicationPackageContent(inherited Clone);
end;

function TFhirMedicationPackageContent.equals(other : TObject) : boolean;
var
  o : TFhirMedicationPackageContent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationPackageContent)) then
    result := false
  else
  begin
    o := TFhirMedicationPackageContent(other);
    result := compareDeep(itemElement, o.itemElement, true) and compareDeep(amountElement, o.amountElement, true);
  end;
end;

function TFhirMedicationPackageContent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FItem) and isEmptyProp(FAmount);
end;

procedure TFhirMedicationPackageContent.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('item');
  fields.add('amount');
end;

{ TFhirMedicationPackageContent }

Procedure TFhirMedicationPackageContent.SetItem(value : TFhirReference{TFhirMedication});
begin
  FItem.free;
  FItem := value;
end;

Procedure TFhirMedicationPackageContent.SetAmount(value : TFhirQuantity);
begin
  FAmount.free;
  FAmount := value;
end;

function TFhirMedicationPackageContent.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FItem.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
end;

{ TFhirMedicationPackageContentListEnumerator }

Constructor TFhirMedicationPackageContentListEnumerator.Create(list : TFhirMedicationPackageContentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationPackageContentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationPackageContentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationPackageContentListEnumerator.GetCurrent : TFhirMedicationPackageContent;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationPackageContentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationPackageContentList }
procedure TFhirMedicationPackageContentList.AddItem(value: TFhirMedicationPackageContent);
begin
  assert(value.ClassName = 'TFhirMedicationPackageContent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationPackageContent');
  add(value);
end;

function TFhirMedicationPackageContentList.Append: TFhirMedicationPackageContent;
begin
  result := TFhirMedicationPackageContent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationPackageContentList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationPackageContentList.GetEnumerator : TFhirMedicationPackageContentListEnumerator;
begin
  result := TFhirMedicationPackageContentListEnumerator.Create(self.link);
end;

function TFhirMedicationPackageContentList.Clone: TFhirMedicationPackageContentList;
begin
  result := TFhirMedicationPackageContentList(inherited Clone);
end;

function TFhirMedicationPackageContentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationPackageContentList.GetItemN(index: Integer): TFhirMedicationPackageContent;
begin
  result := TFhirMedicationPackageContent(ObjectByIndex[index]);
end;

function TFhirMedicationPackageContentList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationPackageContent;
end;
function TFhirMedicationPackageContentList.IndexOf(value: TFhirMedicationPackageContent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationPackageContentList.Insert(index: Integer): TFhirMedicationPackageContent;
begin
  result := TFhirMedicationPackageContent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationPackageContentList.InsertItem(index: Integer; value: TFhirMedicationPackageContent);
begin
  assert(value is TFhirMedicationPackageContent);
  Inherited Insert(index, value);
end;

function TFhirMedicationPackageContentList.Item(index: Integer): TFhirMedicationPackageContent;
begin
  result := TFhirMedicationPackageContent(ObjectByIndex[index]);
end;

function TFhirMedicationPackageContentList.Link: TFhirMedicationPackageContentList;
begin
  result := TFhirMedicationPackageContentList(inherited Link);
end;

procedure TFhirMedicationPackageContentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationPackageContentList.SetItemByIndex(index: Integer; value: TFhirMedicationPackageContent);
begin
  assert(value is TFhirMedicationPackageContent);
  FhirMedicationPackageContents[index] := value;
end;

procedure TFhirMedicationPackageContentList.SetItemN(index: Integer; value: TFhirMedicationPackageContent);
begin
  assert(value is TFhirMedicationPackageContent);
  ObjectByIndex[index] := value;
end;

{ TFhirMedication }

constructor TFhirMedication.Create;
begin
  inherited;
end;

destructor TFhirMedication.Destroy;
begin
  FCode.free;
  FIsBrand.free;
  FManufacturer.free;
  FProduct.free;
  FPackage.free;
  inherited;
end;

function TFhirMedication.GetResourceType : TFhirResourceType;
begin
  result := frtMedication;
end;

procedure TFhirMedication.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirMedication(oSource).code.Clone;
  isBrandElement := TFhirMedication(oSource).isBrandElement.Clone;
  manufacturer := TFhirMedication(oSource).manufacturer.Clone;
  product := TFhirMedication(oSource).product.Clone;
  package := TFhirMedication(oSource).package.Clone;
end;

procedure TFhirMedication.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'isBrand') Then
     list.add(self.link, 'isBrand', FIsBrand.Link);
  if (child_name = 'manufacturer') Then
     list.add(self.link, 'manufacturer', FManufacturer.Link);
  if (child_name = 'product') Then
     list.add(self.link, 'product', FProduct.Link);
  if (child_name = 'package') Then
     list.add(self.link, 'package', FPackage.Link);
end;

procedure TFhirMedication.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'isBrand', 'boolean', false, TFhirBoolean, FIsBrand.Link));{2}
  oList.add(TFHIRProperty.create(self, 'manufacturer', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FManufacturer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'product', '', false, TFhirMedicationProduct, FProduct.Link));{2}
  oList.add(TFHIRProperty.create(self, 'package', '', false, TFhirMedicationPackage, FPackage.Link));{2}
end;

function TFhirMedication.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'isBrand') then
  begin
    IsBrandElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'manufacturer') then
  begin
    Manufacturer := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'product') then
  begin
    Product := propValue as TFhirMedicationProduct{4b};
    result := propValue;
  end
  else if (propName = 'package') then
  begin
    Package := propValue as TFhirMedicationPackage{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirMedication.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedication.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'isBrand') then result := TFhirBoolean.create() {5b}
  else if (propName = 'manufacturer') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'product') then result := TFhirMedicationProduct.create(){4b}
  else if (propName = 'package') then result := TFhirMedicationPackage.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedication.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'isBrand') then result := 'boolean'
  else if (propName = 'manufacturer') then result := 'Reference'
  else if (propName = 'product') then result := ''
  else if (propName = 'package') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedication.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'isBrand') then IsBrandElement := nil
  else if (propName = 'manufacturer') then ManufacturerElement := nil
  else if (propName = 'product') then ProductElement := nil
  else if (propName = 'package') then PackageElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedication.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'isBrand') then IsBrandElement := asBoolean(new){5b}
  else if (propName = 'manufacturer') then ManufacturerElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'product') then ProductElement := new as TFhirMedicationProduct{4}
  else if (propName = 'package') then PackageElement := new as TFhirMedicationPackage{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedication.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedication.fhirType : string;
begin
  result := 'Medication';
end;

function TFhirMedication.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FIsBrand) and isEmptyProp(FManufacturer) and isEmptyProp(FProduct) and isEmptyProp(FPackage);
end;

function TFhirMedication.equals(other : TObject) : boolean;
var
  o : TFhirMedication;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedication)) then
    result := false
  else
  begin
    o := TFhirMedication(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(isBrandElement, o.isBrandElement, true) and
      compareDeep(manufacturerElement, o.manufacturerElement, true) and compareDeep(productElement, o.productElement, true) and
      compareDeep(packageElement, o.packageElement, true);
  end;
end;

function TFhirMedication.Link : TFhirMedication;
begin
  result := TFhirMedication(inherited Link);
end;

function TFhirMedication.Clone : TFhirMedication;
begin
  result := TFhirMedication(inherited Clone);
end;

procedure TFhirMedication.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('code');
  fields.add('isBrand');
  fields.add('manufacturer');
  fields.add('product');
  fields.add('package');
end;

{ TFhirMedication }

Procedure TFhirMedication.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirMedication.SetIsBrand(value : TFhirBoolean);
begin
  FIsBrand.free;
  FIsBrand := value;
end;

Function TFhirMedication.GetIsBrandST : Boolean;
begin
  if FIsBrand = nil then
    result := false
  else
    result := FIsBrand.value;
end;

Procedure TFhirMedication.SetIsBrandST(value : Boolean);
begin
  if FIsBrand = nil then
    FIsBrand := TFhirBoolean.create;
  FIsBrand.value := value
end;

Procedure TFhirMedication.SetManufacturer(value : TFhirReference{TFhirOrganization});
begin
  FManufacturer.free;
  FManufacturer := value;
end;

Procedure TFhirMedication.SetProduct(value : TFhirMedicationProduct);
begin
  FProduct.free;
  FProduct := value;
end;

Procedure TFhirMedication.SetPackage(value : TFhirMedicationPackage);
begin
  FPackage.free;
  FPackage := value;
end;

function TFhirMedication.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FIsBrand.sizeInBytes);
  inc(result, FManufacturer.sizeInBytes);
  inc(result, FProduct.sizeInBytes);
  inc(result, FPackage.sizeInBytes);
end;

{ TFhirMedicationListEnumerator }

Constructor TFhirMedicationListEnumerator.Create(list : TFhirMedicationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationListEnumerator.GetCurrent : TFhirMedication;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationList }
procedure TFhirMedicationList.AddItem(value: TFhirMedication);
begin
  assert(value.ClassName = 'TFhirMedication', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedication');
  add(value);
end;

function TFhirMedicationList.Append: TFhirMedication;
begin
  result := TFhirMedication.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationList.GetEnumerator : TFhirMedicationListEnumerator;
begin
  result := TFhirMedicationListEnumerator.Create(self.link);
end;

function TFhirMedicationList.Clone: TFhirMedicationList;
begin
  result := TFhirMedicationList(inherited Clone);
end;

function TFhirMedicationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationList.GetItemN(index: Integer): TFhirMedication;
begin
  result := TFhirMedication(ObjectByIndex[index]);
end;

function TFhirMedicationList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedication;
end;
function TFhirMedicationList.IndexOf(value: TFhirMedication): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationList.Insert(index: Integer): TFhirMedication;
begin
  result := TFhirMedication.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationList.InsertItem(index: Integer; value: TFhirMedication);
begin
  assert(value is TFhirMedication);
  Inherited Insert(index, value);
end;

function TFhirMedicationList.Item(index: Integer): TFhirMedication;
begin
  result := TFhirMedication(ObjectByIndex[index]);
end;

function TFhirMedicationList.Link: TFhirMedicationList;
begin
  result := TFhirMedicationList(inherited Link);
end;

procedure TFhirMedicationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationList.SetItemByIndex(index: Integer; value: TFhirMedication);
begin
  assert(value is TFhirMedication);
  FhirMedications[index] := value;
end;

procedure TFhirMedicationList.SetItemN(index: Integer; value: TFhirMedication);
begin
  assert(value is TFhirMedication);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEDICATION}

{$IFDEF FHIR_MESSAGEHEADER}

{ TFhirMessageHeaderResponse }

constructor TFhirMessageHeaderResponse.Create;
begin
  inherited;
end;

destructor TFhirMessageHeaderResponse.Destroy;
begin
  FIdentifier.free;
  FCode.free;
  FDetails.free;
  inherited;
end;

procedure TFhirMessageHeaderResponse.Assign(oSource : TFslObject);
begin
  inherited;
  identifierElement := TFhirMessageHeaderResponse(oSource).identifierElement.Clone;
  FCode := TFhirMessageHeaderResponse(oSource).FCode.Link;
  details := TFhirMessageHeaderResponse(oSource).details.Clone;
end;

procedure TFhirMessageHeaderResponse.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'details') Then
     list.add(self.link, 'details', FDetails.Link);
end;

procedure TFhirMessageHeaderResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'id', false, TFhirId, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFHIREnum, FCode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'details', 'Reference(OperationOutcome)', false, TFhirReference{TFhirOperationOutcome}, FDetails.Link));{2}
end;

function TFhirMessageHeaderResponse.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeElement := asEnum(SYSTEMS_TFhirResponseCodeEnum, CODES_TFhirResponseCodeEnum, propValue);
    result := propValue
  end
  else if (propName = 'details') then
  begin
    Details := propValue as TFhirReference{TFhirOperationOutcome}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMessageHeaderResponse.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMessageHeaderResponse.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirId.create() {5b}
  else if (propName = 'details') then result := TFhirReference{TFhirOperationOutcome}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMessageHeaderResponse.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'id'
  else if (propName = 'code') then result := 'code'
  else if (propName = 'details') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMessageHeaderResponse.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'details') then DetailsElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMessageHeaderResponse.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := asId(new){5b}
  else if (propName = 'code') then CodeElement := asEnum(SYSTEMS_TFhirResponseCodeEnum, CODES_TFhirResponseCodeEnum, new){4}
  else if (propName = 'details') then DetailsElement := new as TFhirReference{TFhirOperationOutcome}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMessageHeaderResponse.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMessageHeaderResponse.fhirType : string;
begin
  result := 'response';
end;

function TFhirMessageHeaderResponse.Link : TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse(inherited Link);
end;

function TFhirMessageHeaderResponse.Clone : TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse(inherited Clone);
end;

function TFhirMessageHeaderResponse.equals(other : TObject) : boolean;
var
  o : TFhirMessageHeaderResponse;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMessageHeaderResponse)) then
    result := false
  else
  begin
    o := TFhirMessageHeaderResponse(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(codeElement, o.codeElement, true) and
      compareDeep(detailsElement, o.detailsElement, true);
  end;
end;

function TFhirMessageHeaderResponse.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FCode) and isEmptyProp(FDetails);
end;

procedure TFhirMessageHeaderResponse.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('code');
  fields.add('details');
end;

{ TFhirMessageHeaderResponse }

Procedure TFhirMessageHeaderResponse.SetIdentifier(value : TFhirId);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Function TFhirMessageHeaderResponse.GetIdentifierST : String;
begin
  if FIdentifier = nil then
    result := ''
  else
    result := FIdentifier.value;
end;

Procedure TFhirMessageHeaderResponse.SetIdentifierST(value : String);
begin
  if value <> '' then
  begin
    if FIdentifier = nil then
      FIdentifier := TFhirId.create;
    FIdentifier.value := value
  end
  else if FIdentifier <> nil then
    FIdentifier.value := '';
end;

Procedure TFhirMessageHeaderResponse.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirMessageHeaderResponse.GetCodeST : TFhirResponseCodeEnum;
begin
  if FCode = nil then
    result := TFhirResponseCodeEnum(0)
  else
    result := TFhirResponseCodeEnum(StringArrayIndexOfSensitive(CODES_TFhirResponseCodeEnum, FCode.value));
end;

Procedure TFhirMessageHeaderResponse.SetCodeST(value : TFhirResponseCodeEnum);
begin
  if ord(value) = 0 then
    CodeElement := nil
  else
    CodeElement := TFhirEnum.create(SYSTEMS_TFhirResponseCodeEnum[value], CODES_TFhirResponseCodeEnum[value]);
end;

Procedure TFhirMessageHeaderResponse.SetDetails(value : TFhirReference{TFhirOperationOutcome});
begin
  FDetails.free;
  FDetails := value;
end;

function TFhirMessageHeaderResponse.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FDetails.sizeInBytes);
end;

{ TFhirMessageHeaderResponseListEnumerator }

Constructor TFhirMessageHeaderResponseListEnumerator.Create(list : TFhirMessageHeaderResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMessageHeaderResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMessageHeaderResponseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMessageHeaderResponseListEnumerator.GetCurrent : TFhirMessageHeaderResponse;
begin
  Result := FList[FIndex];
end;

function TFhirMessageHeaderResponseListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMessageHeaderResponseList }
procedure TFhirMessageHeaderResponseList.AddItem(value: TFhirMessageHeaderResponse);
begin
  assert(value.ClassName = 'TFhirMessageHeaderResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMessageHeaderResponse');
  add(value);
end;

function TFhirMessageHeaderResponseList.Append: TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageHeaderResponseList.ClearItems;
begin
  Clear;
end;

function TFhirMessageHeaderResponseList.GetEnumerator : TFhirMessageHeaderResponseListEnumerator;
begin
  result := TFhirMessageHeaderResponseListEnumerator.Create(self.link);
end;

function TFhirMessageHeaderResponseList.Clone: TFhirMessageHeaderResponseList;
begin
  result := TFhirMessageHeaderResponseList(inherited Clone);
end;

function TFhirMessageHeaderResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMessageHeaderResponseList.GetItemN(index: Integer): TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse(ObjectByIndex[index]);
end;

function TFhirMessageHeaderResponseList.ItemClass: TFslObjectClass;
begin
  result := TFhirMessageHeaderResponse;
end;
function TFhirMessageHeaderResponseList.IndexOf(value: TFhirMessageHeaderResponse): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMessageHeaderResponseList.Insert(index: Integer): TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageHeaderResponseList.InsertItem(index: Integer; value: TFhirMessageHeaderResponse);
begin
  assert(value is TFhirMessageHeaderResponse);
  Inherited Insert(index, value);
end;

function TFhirMessageHeaderResponseList.Item(index: Integer): TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse(ObjectByIndex[index]);
end;

function TFhirMessageHeaderResponseList.Link: TFhirMessageHeaderResponseList;
begin
  result := TFhirMessageHeaderResponseList(inherited Link);
end;

procedure TFhirMessageHeaderResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMessageHeaderResponseList.SetItemByIndex(index: Integer; value: TFhirMessageHeaderResponse);
begin
  assert(value is TFhirMessageHeaderResponse);
  FhirMessageHeaderResponses[index] := value;
end;

procedure TFhirMessageHeaderResponseList.SetItemN(index: Integer; value: TFhirMessageHeaderResponse);
begin
  assert(value is TFhirMessageHeaderResponse);
  ObjectByIndex[index] := value;
end;

{ TFhirMessageHeaderSource }

constructor TFhirMessageHeaderSource.Create;
begin
  inherited;
end;

destructor TFhirMessageHeaderSource.Destroy;
begin
  FName.free;
  FSoftware.free;
  FVersion.free;
  FContact.free;
  FEndpoint.free;
  inherited;
end;

procedure TFhirMessageHeaderSource.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirMessageHeaderSource(oSource).nameElement.Clone;
  softwareElement := TFhirMessageHeaderSource(oSource).softwareElement.Clone;
  versionElement := TFhirMessageHeaderSource(oSource).versionElement.Clone;
  contact := TFhirMessageHeaderSource(oSource).contact.Clone;
  endpointElement := TFhirMessageHeaderSource(oSource).endpointElement.Clone;
end;

procedure TFhirMessageHeaderSource.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'software') Then
     list.add(self.link, 'software', FSoftware.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'contact') Then
     list.add(self.link, 'contact', FContact.Link);
  if (child_name = 'endpoint') Then
     list.add(self.link, 'endpoint', FEndpoint.Link);
end;

procedure TFhirMessageHeaderSource.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'software', 'string', false, TFhirString, FSoftware.Link));{2}
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));{2}
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactPoint', false, TFhirContactPoint, FContact.Link));{2}
  oList.add(TFHIRProperty.create(self, 'endpoint', 'uri', false, TFhirUri, FEndpoint.Link));{2}
end;

function TFhirMessageHeaderSource.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'software') then
  begin
    SoftwareElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    Contact := propValue as TFhirContactPoint{4b};
    result := propValue;
  end
  else if (propName = 'endpoint') then
  begin
    EndpointElement := asUri(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMessageHeaderSource.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMessageHeaderSource.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'software') then result := TFhirString.create() {5b}
  else if (propName = 'version') then result := TFhirString.create() {5b}
  else if (propName = 'contact') then result := TFhirContactPoint.create(){4b}
  else if (propName = 'endpoint') then result := TFhirUri.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMessageHeaderSource.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'software') then result := 'string'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'contact') then result := 'ContactPoint'
  else if (propName = 'endpoint') then result := 'uri'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMessageHeaderSource.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'software') then SoftwareElement := nil
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'contact') then ContactElement := nil
  else if (propName = 'endpoint') then EndpointElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMessageHeaderSource.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'software') then SoftwareElement := asString(new){5b}
  else if (propName = 'version') then VersionElement := asString(new){5b}
  else if (propName = 'contact') then ContactElement := new as TFhirContactPoint{4}
  else if (propName = 'endpoint') then EndpointElement := asUri(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMessageHeaderSource.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMessageHeaderSource.fhirType : string;
begin
  result := 'source';
end;

function TFhirMessageHeaderSource.Link : TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource(inherited Link);
end;

function TFhirMessageHeaderSource.Clone : TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource(inherited Clone);
end;

function TFhirMessageHeaderSource.equals(other : TObject) : boolean;
var
  o : TFhirMessageHeaderSource;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMessageHeaderSource)) then
    result := false
  else
  begin
    o := TFhirMessageHeaderSource(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(softwareElement, o.softwareElement, true) and
      compareDeep(versionElement, o.versionElement, true) and compareDeep(contactElement, o.contactElement, true) and
      compareDeep(endpointElement, o.endpointElement, true);
  end;
end;

function TFhirMessageHeaderSource.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FSoftware) and isEmptyProp(FVersion) and isEmptyProp(FContact) and isEmptyProp(FEndpoint);
end;

procedure TFhirMessageHeaderSource.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('software');
  fields.add('version');
  fields.add('contact');
  fields.add('endpoint');
end;

{ TFhirMessageHeaderSource }

Procedure TFhirMessageHeaderSource.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirMessageHeaderSource.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirMessageHeaderSource.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirMessageHeaderSource.SetSoftware(value : TFhirString);
begin
  FSoftware.free;
  FSoftware := value;
end;

Function TFhirMessageHeaderSource.GetSoftwareST : String;
begin
  if FSoftware = nil then
    result := ''
  else
    result := FSoftware.value;
end;

Procedure TFhirMessageHeaderSource.SetSoftwareST(value : String);
begin
  if value <> '' then
  begin
    if FSoftware = nil then
      FSoftware := TFhirString.create;
    FSoftware.value := value
  end
  else if FSoftware <> nil then
    FSoftware.value := '';
end;

Procedure TFhirMessageHeaderSource.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

Function TFhirMessageHeaderSource.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

Procedure TFhirMessageHeaderSource.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

Procedure TFhirMessageHeaderSource.SetContact(value : TFhirContactPoint);
begin
  FContact.free;
  FContact := value;
end;

Procedure TFhirMessageHeaderSource.SetEndpoint(value : TFhirUri);
begin
  FEndpoint.free;
  FEndpoint := value;
end;

Function TFhirMessageHeaderSource.GetEndpointST : String;
begin
  if FEndpoint = nil then
    result := ''
  else
    result := FEndpoint.value;
end;

Procedure TFhirMessageHeaderSource.SetEndpointST(value : String);
begin
  if value <> '' then
  begin
    if FEndpoint = nil then
      FEndpoint := TFhirUri.create;
    FEndpoint.value := value
  end
  else if FEndpoint <> nil then
    FEndpoint.value := '';
end;

function TFhirMessageHeaderSource.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FSoftware.sizeInBytes);
  inc(result, FVersion.sizeInBytes);
  inc(result, FContact.sizeInBytes);
  inc(result, FEndpoint.sizeInBytes);
end;

{ TFhirMessageHeaderSourceListEnumerator }

Constructor TFhirMessageHeaderSourceListEnumerator.Create(list : TFhirMessageHeaderSourceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMessageHeaderSourceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMessageHeaderSourceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMessageHeaderSourceListEnumerator.GetCurrent : TFhirMessageHeaderSource;
begin
  Result := FList[FIndex];
end;

function TFhirMessageHeaderSourceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMessageHeaderSourceList }
procedure TFhirMessageHeaderSourceList.AddItem(value: TFhirMessageHeaderSource);
begin
  assert(value.ClassName = 'TFhirMessageHeaderSource', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMessageHeaderSource');
  add(value);
end;

function TFhirMessageHeaderSourceList.Append: TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageHeaderSourceList.ClearItems;
begin
  Clear;
end;

function TFhirMessageHeaderSourceList.GetEnumerator : TFhirMessageHeaderSourceListEnumerator;
begin
  result := TFhirMessageHeaderSourceListEnumerator.Create(self.link);
end;

function TFhirMessageHeaderSourceList.Clone: TFhirMessageHeaderSourceList;
begin
  result := TFhirMessageHeaderSourceList(inherited Clone);
end;

function TFhirMessageHeaderSourceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMessageHeaderSourceList.GetItemN(index: Integer): TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource(ObjectByIndex[index]);
end;

function TFhirMessageHeaderSourceList.ItemClass: TFslObjectClass;
begin
  result := TFhirMessageHeaderSource;
end;
function TFhirMessageHeaderSourceList.IndexOf(value: TFhirMessageHeaderSource): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMessageHeaderSourceList.Insert(index: Integer): TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageHeaderSourceList.InsertItem(index: Integer; value: TFhirMessageHeaderSource);
begin
  assert(value is TFhirMessageHeaderSource);
  Inherited Insert(index, value);
end;

function TFhirMessageHeaderSourceList.Item(index: Integer): TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource(ObjectByIndex[index]);
end;

function TFhirMessageHeaderSourceList.Link: TFhirMessageHeaderSourceList;
begin
  result := TFhirMessageHeaderSourceList(inherited Link);
end;

procedure TFhirMessageHeaderSourceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMessageHeaderSourceList.SetItemByIndex(index: Integer; value: TFhirMessageHeaderSource);
begin
  assert(value is TFhirMessageHeaderSource);
  FhirMessageHeaderSources[index] := value;
end;

procedure TFhirMessageHeaderSourceList.SetItemN(index: Integer; value: TFhirMessageHeaderSource);
begin
  assert(value is TFhirMessageHeaderSource);
  ObjectByIndex[index] := value;
end;

{ TFhirMessageHeaderDestination }

constructor TFhirMessageHeaderDestination.Create;
begin
  inherited;
end;

destructor TFhirMessageHeaderDestination.Destroy;
begin
  FName.free;
  FTarget.free;
  FEndpoint.free;
  inherited;
end;

procedure TFhirMessageHeaderDestination.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirMessageHeaderDestination(oSource).nameElement.Clone;
  target := TFhirMessageHeaderDestination(oSource).target.Clone;
  endpointElement := TFhirMessageHeaderDestination(oSource).endpointElement.Clone;
end;

procedure TFhirMessageHeaderDestination.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'target') Then
     list.add(self.link, 'target', FTarget.Link);
  if (child_name = 'endpoint') Then
     list.add(self.link, 'endpoint', FEndpoint.Link);
end;

procedure TFhirMessageHeaderDestination.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'target', 'Reference(Device)', false, TFhirReference{TFhirDevice}, FTarget.Link));{2}
  oList.add(TFHIRProperty.create(self, 'endpoint', 'uri', false, TFhirUri, FEndpoint.Link));{2}
end;

function TFhirMessageHeaderDestination.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'target') then
  begin
    Target := propValue as TFhirReference{TFhirDevice}{4b};
    result := propValue;
  end
  else if (propName = 'endpoint') then
  begin
    EndpointElement := asUri(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMessageHeaderDestination.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMessageHeaderDestination.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'target') then result := TFhirReference{TFhirDevice}.create(){4b}
  else if (propName = 'endpoint') then result := TFhirUri.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMessageHeaderDestination.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'target') then result := 'Reference'
  else if (propName = 'endpoint') then result := 'uri'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMessageHeaderDestination.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'target') then TargetElement := nil
  else if (propName = 'endpoint') then EndpointElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMessageHeaderDestination.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'target') then TargetElement := new as TFhirReference{TFhirDevice}{4}
  else if (propName = 'endpoint') then EndpointElement := asUri(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMessageHeaderDestination.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMessageHeaderDestination.fhirType : string;
begin
  result := 'destination';
end;

function TFhirMessageHeaderDestination.Link : TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination(inherited Link);
end;

function TFhirMessageHeaderDestination.Clone : TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination(inherited Clone);
end;

function TFhirMessageHeaderDestination.equals(other : TObject) : boolean;
var
  o : TFhirMessageHeaderDestination;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMessageHeaderDestination)) then
    result := false
  else
  begin
    o := TFhirMessageHeaderDestination(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(targetElement, o.targetElement, true) and
      compareDeep(endpointElement, o.endpointElement, true);
  end;
end;

function TFhirMessageHeaderDestination.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FTarget) and isEmptyProp(FEndpoint);
end;

procedure TFhirMessageHeaderDestination.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('target');
  fields.add('endpoint');
end;

{ TFhirMessageHeaderDestination }

Procedure TFhirMessageHeaderDestination.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirMessageHeaderDestination.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirMessageHeaderDestination.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirMessageHeaderDestination.SetTarget(value : TFhirReference{TFhirDevice});
begin
  FTarget.free;
  FTarget := value;
end;

Procedure TFhirMessageHeaderDestination.SetEndpoint(value : TFhirUri);
begin
  FEndpoint.free;
  FEndpoint := value;
end;

Function TFhirMessageHeaderDestination.GetEndpointST : String;
begin
  if FEndpoint = nil then
    result := ''
  else
    result := FEndpoint.value;
end;

Procedure TFhirMessageHeaderDestination.SetEndpointST(value : String);
begin
  if value <> '' then
  begin
    if FEndpoint = nil then
      FEndpoint := TFhirUri.create;
    FEndpoint.value := value
  end
  else if FEndpoint <> nil then
    FEndpoint.value := '';
end;

function TFhirMessageHeaderDestination.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FTarget.sizeInBytes);
  inc(result, FEndpoint.sizeInBytes);
end;

{ TFhirMessageHeaderDestinationListEnumerator }

Constructor TFhirMessageHeaderDestinationListEnumerator.Create(list : TFhirMessageHeaderDestinationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMessageHeaderDestinationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMessageHeaderDestinationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMessageHeaderDestinationListEnumerator.GetCurrent : TFhirMessageHeaderDestination;
begin
  Result := FList[FIndex];
end;

function TFhirMessageHeaderDestinationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMessageHeaderDestinationList }
procedure TFhirMessageHeaderDestinationList.AddItem(value: TFhirMessageHeaderDestination);
begin
  assert(value.ClassName = 'TFhirMessageHeaderDestination', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMessageHeaderDestination');
  add(value);
end;

function TFhirMessageHeaderDestinationList.Append: TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageHeaderDestinationList.ClearItems;
begin
  Clear;
end;

function TFhirMessageHeaderDestinationList.GetEnumerator : TFhirMessageHeaderDestinationListEnumerator;
begin
  result := TFhirMessageHeaderDestinationListEnumerator.Create(self.link);
end;

function TFhirMessageHeaderDestinationList.Clone: TFhirMessageHeaderDestinationList;
begin
  result := TFhirMessageHeaderDestinationList(inherited Clone);
end;

function TFhirMessageHeaderDestinationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMessageHeaderDestinationList.GetItemN(index: Integer): TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination(ObjectByIndex[index]);
end;

function TFhirMessageHeaderDestinationList.ItemClass: TFslObjectClass;
begin
  result := TFhirMessageHeaderDestination;
end;
function TFhirMessageHeaderDestinationList.IndexOf(value: TFhirMessageHeaderDestination): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMessageHeaderDestinationList.Insert(index: Integer): TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageHeaderDestinationList.InsertItem(index: Integer; value: TFhirMessageHeaderDestination);
begin
  assert(value is TFhirMessageHeaderDestination);
  Inherited Insert(index, value);
end;

function TFhirMessageHeaderDestinationList.Item(index: Integer): TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination(ObjectByIndex[index]);
end;

function TFhirMessageHeaderDestinationList.Link: TFhirMessageHeaderDestinationList;
begin
  result := TFhirMessageHeaderDestinationList(inherited Link);
end;

procedure TFhirMessageHeaderDestinationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMessageHeaderDestinationList.SetItemByIndex(index: Integer; value: TFhirMessageHeaderDestination);
begin
  assert(value is TFhirMessageHeaderDestination);
  FhirMessageHeaderDestinations[index] := value;
end;

procedure TFhirMessageHeaderDestinationList.SetItemN(index: Integer; value: TFhirMessageHeaderDestination);
begin
  assert(value is TFhirMessageHeaderDestination);
  ObjectByIndex[index] := value;
end;

{ TFhirMessageHeader }

constructor TFhirMessageHeader.Create;
begin
  inherited;
end;

destructor TFhirMessageHeader.Destroy;
begin
  FTimestamp.free;
  FEvent.free;
  FResponse.free;
  FSource.free;
  FDestinationList.Free;
  FEnterer.free;
  FAuthor.free;
  FReceiver.free;
  FResponsible.free;
  FReason.free;
  FDataList.Free;
  inherited;
end;

function TFhirMessageHeader.GetResourceType : TFhirResourceType;
begin
  result := frtMessageHeader;
end;

procedure TFhirMessageHeader.Assign(oSource : TFslObject);
begin
  inherited;
  timestampElement := TFhirMessageHeader(oSource).timestampElement.Clone;
  event := TFhirMessageHeader(oSource).event.Clone;
  response := TFhirMessageHeader(oSource).response.Clone;
  source := TFhirMessageHeader(oSource).source.Clone;
  if (TFhirMessageHeader(oSource).FDestinationList = nil) then
  begin
    FDestinationList.free;
    FDestinationList := nil;
  end
  else
  begin
    if FDestinationList = nil then
      FDestinationList := TFhirMessageHeaderDestinationList.Create;
    FDestinationList.Assign(TFhirMessageHeader(oSource).FDestinationList);
  end;
  enterer := TFhirMessageHeader(oSource).enterer.Clone;
  author := TFhirMessageHeader(oSource).author.Clone;
  receiver := TFhirMessageHeader(oSource).receiver.Clone;
  responsible := TFhirMessageHeader(oSource).responsible.Clone;
  reason := TFhirMessageHeader(oSource).reason.Clone;
  if (TFhirMessageHeader(oSource).FDataList = nil) then
  begin
    FDataList.free;
    FDataList := nil;
  end
  else
  begin
    if FDataList = nil then
      FDataList := TFhirReferenceList{TFhirReference}.Create;
    FDataList.Assign(TFhirMessageHeader(oSource).FDataList);
  end;
end;

procedure TFhirMessageHeader.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'timestamp') Then
     list.add(self.link, 'timestamp', FTimestamp.Link);
  if (child_name = 'event') Then
     list.add(self.link, 'event', FEvent.Link);
  if (child_name = 'response') Then
     list.add(self.link, 'response', FResponse.Link);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'destination') Then
    list.addAll(self, 'destination', FDestinationList);
  if (child_name = 'enterer') Then
     list.add(self.link, 'enterer', FEnterer.Link);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
  if (child_name = 'receiver') Then
     list.add(self.link, 'receiver', FReceiver.Link);
  if (child_name = 'responsible') Then
     list.add(self.link, 'responsible', FResponsible.Link);
  if (child_name = 'reason') Then
     list.add(self.link, 'reason', FReason.Link);
  if (child_name = 'data') Then
    list.addAll(self, 'data', FDataList);
end;

procedure TFhirMessageHeader.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'timestamp', 'instant', false, TFhirInstant, FTimestamp.Link));{2}
  oList.add(TFHIRProperty.create(self, 'event', 'Coding', false, TFhirCoding, FEvent.Link));{2}
  oList.add(TFHIRProperty.create(self, 'response', '', false, TFhirMessageHeaderResponse, FResponse.Link));{2}
  oList.add(TFHIRProperty.create(self, 'source', '', false, TFhirMessageHeaderSource, FSource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'destination', '', true, TFhirMessageHeaderDestination, FDestinationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'enterer', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FEnterer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'author', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FAuthor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'receiver', 'Reference(Practitioner|Organization)', false, TFhirReference{Resource}, FReceiver.Link));{2}
  oList.add(TFHIRProperty.create(self, 'responsible', 'Reference(Practitioner|Organization)', false, TFhirReference{Resource}, FResponsible.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', false, TFhirCodeableConcept, FReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'data', 'Reference(Any)', true, TFhirReference{TFhirReference}, FDataList.Link)){3};
end;

function TFhirMessageHeader.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'timestamp') then
  begin
    TimestampElement := asInstant(propValue){5a};
    result := propValue;
  end
  else if (propName = 'event') then
  begin
    Event := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'response') then
  begin
    Response := propValue as TFhirMessageHeaderResponse{4b};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    Source := propValue as TFhirMessageHeaderSource{4b};
    result := propValue;
  end
  else if (propName = 'destination') then
  begin
    DestinationList.add(propValue as TFhirMessageHeaderDestination){2a};
    result := propValue;
  end
  else if (propName = 'enterer') then
  begin
    Enterer := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'receiver') then
  begin
    Receiver := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'responsible') then
  begin
    Responsible := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    Reason := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'data') then
  begin
    DataList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirMessageHeader.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'destination') then DestinationList.insertItem(index, propValue as TFhirMessageHeaderDestination){2a}
  else if (propName = 'data') then DataList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else inherited;
end;

function TFhirMessageHeader.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'timestamp') then result := TFhirInstant.create() {5b}
  else if (propName = 'event') then result := TFhirCoding.create(){4b}
  else if (propName = 'response') then result := TFhirMessageHeaderResponse.create(){4b}
  else if (propName = 'source') then result := TFhirMessageHeaderSource.create(){4b}
  else if (propName = 'destination') then result := DestinationList.new(){2}
  else if (propName = 'enterer') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'author') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'receiver') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'responsible') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'reason') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'data') then result := DataList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMessageHeader.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'timestamp') then result := 'instant'
  else if (propName = 'event') then result := 'Coding'
  else if (propName = 'response') then result := ''
  else if (propName = 'source') then result := ''
  else if (propName = 'destination') then result := ''
  else if (propName = 'enterer') then result := 'Reference'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'receiver') then result := 'Reference'
  else if (propName = 'responsible') then result := 'Reference'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else if (propName = 'data') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMessageHeader.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'timestamp') then TimestampElement := nil
  else if (propName = 'event') then EventElement := nil
  else if (propName = 'response') then ResponseElement := nil
  else if (propName = 'source') then SourceElement := nil
  else if (propName = 'destination') then deletePropertyValue('destination', DestinationList, value) {2}
  else if (propName = 'enterer') then EntererElement := nil
  else if (propName = 'author') then AuthorElement := nil
  else if (propName = 'receiver') then ReceiverElement := nil
  else if (propName = 'responsible') then ResponsibleElement := nil
  else if (propName = 'reason') then ReasonElement := nil
  else if (propName = 'data') then deletePropertyValue('data', DataList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMessageHeader.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'timestamp') then TimestampElement := asInstant(new){5b}
  else if (propName = 'event') then EventElement := new as TFhirCoding{4}
  else if (propName = 'response') then ResponseElement := new as TFhirMessageHeaderResponse{4}
  else if (propName = 'source') then SourceElement := new as TFhirMessageHeaderSource{4}
  else if (propName = 'destination') then replacePropertyValue('destination', DestinationList, existing, new) {2}
  else if (propName = 'enterer') then EntererElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'author') then AuthorElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'receiver') then ReceiverElement := new as TFhirReference{Resource}{4}
  else if (propName = 'responsible') then ResponsibleElement := new as TFhirReference{Resource}{4}
  else if (propName = 'reason') then ReasonElement := new as TFhirCodeableConcept{4}
  else if (propName = 'data') then replacePropertyValue('data', DataList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMessageHeader.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'destination') then DestinationList.move(source, destination){2a}
  else if (propName = 'data') then DataList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMessageHeader.fhirType : string;
begin
  result := 'MessageHeader';
end;

function TFhirMessageHeader.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FTimestamp) and isEmptyProp(FEvent) and isEmptyProp(FResponse) and isEmptyProp(FSource) and isEmptyProp(FdestinationList) and isEmptyProp(FEnterer) and isEmptyProp(FAuthor) and isEmptyProp(FReceiver) and isEmptyProp(FResponsible) and isEmptyProp(FReason) and isEmptyProp(FdataList);
end;

function TFhirMessageHeader.equals(other : TObject) : boolean;
var
  o : TFhirMessageHeader;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMessageHeader)) then
    result := false
  else
  begin
    o := TFhirMessageHeader(other);
    result := compareDeep(timestampElement, o.timestampElement, true) and compareDeep(eventElement, o.eventElement, true) and
      compareDeep(responseElement, o.responseElement, true) and compareDeep(sourceElement, o.sourceElement, true) and
      compareDeep(destinationList, o.destinationList, true) and compareDeep(entererElement, o.entererElement, true) and
      compareDeep(authorElement, o.authorElement, true) and compareDeep(receiverElement, o.receiverElement, true) and
      compareDeep(responsibleElement, o.responsibleElement, true) and compareDeep(reasonElement, o.reasonElement, true) and
      compareDeep(dataList, o.dataList, true);
  end;
end;

function TFhirMessageHeader.Link : TFhirMessageHeader;
begin
  result := TFhirMessageHeader(inherited Link);
end;

function TFhirMessageHeader.Clone : TFhirMessageHeader;
begin
  result := TFhirMessageHeader(inherited Clone);
end;

procedure TFhirMessageHeader.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('timestamp');
  fields.add('event');
  fields.add('response');
  fields.add('source');
  fields.add('destination');
  fields.add('enterer');
  fields.add('author');
  fields.add('receiver');
  fields.add('responsible');
  fields.add('reason');
  fields.add('data');
end;

{ TFhirMessageHeader }

Procedure TFhirMessageHeader.SetTimestamp(value : TFhirInstant);
begin
  FTimestamp.free;
  FTimestamp := value;
end;

Function TFhirMessageHeader.GetTimestampST : TFslDateTime;
begin
  if FTimestamp = nil then
    result := TFslDateTime.makeNull
  else
    result := FTimestamp.value;
end;

Procedure TFhirMessageHeader.SetTimestampST(value : TFslDateTime);
begin
  if FTimestamp = nil then
    FTimestamp := TFhirInstant.create;
  FTimestamp.value := value
end;

Procedure TFhirMessageHeader.SetEvent(value : TFhirCoding);
begin
  FEvent.free;
  FEvent := value;
end;

Procedure TFhirMessageHeader.SetResponse(value : TFhirMessageHeaderResponse);
begin
  FResponse.free;
  FResponse := value;
end;

Procedure TFhirMessageHeader.SetSource(value : TFhirMessageHeaderSource);
begin
  FSource.free;
  FSource := value;
end;

Function TFhirMessageHeader.GetDestinationList : TFhirMessageHeaderDestinationList;
begin
  if FDestinationList = nil then
    FDestinationList := TFhirMessageHeaderDestinationList.Create;
  result := FDestinationList;
end;

Function TFhirMessageHeader.GetHasDestinationList : boolean;
begin
  result := (FDestinationList <> nil) and (FDestinationList.count > 0);
end;

Procedure TFhirMessageHeader.SetEnterer(value : TFhirReference{TFhirPractitioner});
begin
  FEnterer.free;
  FEnterer := value;
end;

Procedure TFhirMessageHeader.SetAuthor(value : TFhirReference{TFhirPractitioner});
begin
  FAuthor.free;
  FAuthor := value;
end;

Procedure TFhirMessageHeader.SetReceiver(value : TFhirReference{Resource});
begin
  FReceiver.free;
  FReceiver := value;
end;

Procedure TFhirMessageHeader.SetResponsible(value : TFhirReference{Resource});
begin
  FResponsible.free;
  FResponsible := value;
end;

Procedure TFhirMessageHeader.SetReason(value : TFhirCodeableConcept);
begin
  FReason.free;
  FReason := value;
end;

Function TFhirMessageHeader.GetDataList : TFhirReferenceList{TFhirReference};
begin
  if FDataList = nil then
    FDataList := TFhirReferenceList{TFhirReference}.Create;
  result := FDataList;
end;

Function TFhirMessageHeader.GetHasDataList : boolean;
begin
  result := (FDataList <> nil) and (FDataList.count > 0);
end;

function TFhirMessageHeader.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FTimestamp.sizeInBytes);
  inc(result, FEvent.sizeInBytes);
  inc(result, FResponse.sizeInBytes);
  inc(result, FSource.sizeInBytes);
  inc(result, FdestinationList.sizeInBytes);
  inc(result, FEnterer.sizeInBytes);
  inc(result, FAuthor.sizeInBytes);
  inc(result, FReceiver.sizeInBytes);
  inc(result, FResponsible.sizeInBytes);
  inc(result, FReason.sizeInBytes);
  inc(result, FdataList.sizeInBytes);
end;

{ TFhirMessageHeaderListEnumerator }

Constructor TFhirMessageHeaderListEnumerator.Create(list : TFhirMessageHeaderList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMessageHeaderListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMessageHeaderListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMessageHeaderListEnumerator.GetCurrent : TFhirMessageHeader;
begin
  Result := FList[FIndex];
end;

function TFhirMessageHeaderListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMessageHeaderList }
procedure TFhirMessageHeaderList.AddItem(value: TFhirMessageHeader);
begin
  assert(value.ClassName = 'TFhirMessageHeader', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMessageHeader');
  add(value);
end;

function TFhirMessageHeaderList.Append: TFhirMessageHeader;
begin
  result := TFhirMessageHeader.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageHeaderList.ClearItems;
begin
  Clear;
end;

function TFhirMessageHeaderList.GetEnumerator : TFhirMessageHeaderListEnumerator;
begin
  result := TFhirMessageHeaderListEnumerator.Create(self.link);
end;

function TFhirMessageHeaderList.Clone: TFhirMessageHeaderList;
begin
  result := TFhirMessageHeaderList(inherited Clone);
end;

function TFhirMessageHeaderList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMessageHeaderList.GetItemN(index: Integer): TFhirMessageHeader;
begin
  result := TFhirMessageHeader(ObjectByIndex[index]);
end;

function TFhirMessageHeaderList.ItemClass: TFslObjectClass;
begin
  result := TFhirMessageHeader;
end;
function TFhirMessageHeaderList.IndexOf(value: TFhirMessageHeader): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMessageHeaderList.Insert(index: Integer): TFhirMessageHeader;
begin
  result := TFhirMessageHeader.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageHeaderList.InsertItem(index: Integer; value: TFhirMessageHeader);
begin
  assert(value is TFhirMessageHeader);
  Inherited Insert(index, value);
end;

function TFhirMessageHeaderList.Item(index: Integer): TFhirMessageHeader;
begin
  result := TFhirMessageHeader(ObjectByIndex[index]);
end;

function TFhirMessageHeaderList.Link: TFhirMessageHeaderList;
begin
  result := TFhirMessageHeaderList(inherited Link);
end;

procedure TFhirMessageHeaderList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMessageHeaderList.SetItemByIndex(index: Integer; value: TFhirMessageHeader);
begin
  assert(value is TFhirMessageHeader);
  FhirMessageHeaders[index] := value;
end;

procedure TFhirMessageHeaderList.SetItemN(index: Integer; value: TFhirMessageHeader);
begin
  assert(value is TFhirMessageHeader);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MESSAGEHEADER}

{$IFDEF FHIR_OPERATIONOUTCOME}

{ TFhirOperationOutcomeIssue }

constructor TFhirOperationOutcomeIssue.Create;
begin
  inherited;
end;

destructor TFhirOperationOutcomeIssue.Destroy;
begin
  FSeverity.free;
  FCode.free;
  FDetails.free;
  FDiagnostics.free;
  FLocationList.Free;
  inherited;
end;

procedure TFhirOperationOutcomeIssue.Assign(oSource : TFslObject);
begin
  inherited;
  FSeverity := TFhirOperationOutcomeIssue(oSource).FSeverity.Link;
  FCode := TFhirOperationOutcomeIssue(oSource).FCode.Link;
  details := TFhirOperationOutcomeIssue(oSource).details.Clone;
  diagnosticsElement := TFhirOperationOutcomeIssue(oSource).diagnosticsElement.Clone;
  if (TFhirOperationOutcomeIssue(oSource).FLocationList = nil) then
  begin
    FLocationList.free;
    FLocationList := nil;
  end
  else
  begin
    if FLocationList = nil then
      FLocationList := TFhirStringList.Create;
    FLocationList.Assign(TFhirOperationOutcomeIssue(oSource).FLocationList);
  end;
end;

procedure TFhirOperationOutcomeIssue.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'severity') Then
     list.add(self.link, 'severity', FSeverity.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'details') Then
     list.add(self.link, 'details', FDetails.Link);
  if (child_name = 'diagnostics') Then
     list.add(self.link, 'diagnostics', FDiagnostics.Link);
  if (child_name = 'location') Then
    list.addAll(self, 'location', FLocationList);
end;

procedure TFhirOperationOutcomeIssue.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'severity', 'code', false, TFHIREnum, FSeverity.Link));{1}
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFHIREnum, FCode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'details', 'CodeableConcept', false, TFhirCodeableConcept, FDetails.Link));{2}
  oList.add(TFHIRProperty.create(self, 'diagnostics', 'string', false, TFhirString, FDiagnostics.Link));{2}
  oList.add(TFHIRProperty.create(self, 'location', 'string', true, TFhirString, FLocationList.Link)){3};
end;

function TFhirOperationOutcomeIssue.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'severity') then
  begin
    SeverityElement := asEnum(SYSTEMS_TFhirIssueSeverityEnum, CODES_TFhirIssueSeverityEnum, propValue);
    result := propValue
  end
  else if (propName = 'code') then
  begin
    CodeElement := asEnum(SYSTEMS_TFhirIssueTypeEnum, CODES_TFhirIssueTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'details') then
  begin
    Details := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'diagnostics') then
  begin
    DiagnosticsElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    LocationList.add(asString(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirOperationOutcomeIssue.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'location') then LocationList.insertItem(index, asString(propValue)){2}
  else inherited;
end;

function TFhirOperationOutcomeIssue.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'details') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'diagnostics') then result := TFhirString.create() {5b}
  else if (propName = 'location') then result := LocationList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirOperationOutcomeIssue.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'severity') then result := 'code'
  else if (propName = 'code') then result := 'code'
  else if (propName = 'details') then result := 'CodeableConcept'
  else if (propName = 'diagnostics') then result := 'string'
  else if (propName = 'location') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirOperationOutcomeIssue.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'severity') then SeverityElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'details') then DetailsElement := nil
  else if (propName = 'diagnostics') then DiagnosticsElement := nil
  else if (propName = 'location') then deletePropertyValue('location', LocationList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirOperationOutcomeIssue.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'severity') then SeverityElement := asEnum(SYSTEMS_TFhirIssueSeverityEnum, CODES_TFhirIssueSeverityEnum, new){4}
  else if (propName = 'code') then CodeElement := asEnum(SYSTEMS_TFhirIssueTypeEnum, CODES_TFhirIssueTypeEnum, new){4}
  else if (propName = 'details') then DetailsElement := new as TFhirCodeableConcept{4}
  else if (propName = 'diagnostics') then DiagnosticsElement := asString(new){5b}
  else if (propName = 'location') then replacePropertyValue('location', LocationList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirOperationOutcomeIssue.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'location') then LocationList.move(source, destination){2}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirOperationOutcomeIssue.fhirType : string;
begin
  result := 'issue';
end;

function TFhirOperationOutcomeIssue.Link : TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue(inherited Link);
end;

function TFhirOperationOutcomeIssue.Clone : TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue(inherited Clone);
end;

function TFhirOperationOutcomeIssue.equals(other : TObject) : boolean;
var
  o : TFhirOperationOutcomeIssue;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirOperationOutcomeIssue)) then
    result := false
  else
  begin
    o := TFhirOperationOutcomeIssue(other);
    result := compareDeep(severityElement, o.severityElement, true) and compareDeep(codeElement, o.codeElement, true) and
      compareDeep(detailsElement, o.detailsElement, true) and compareDeep(diagnosticsElement, o.diagnosticsElement, true) and
      compareDeep(locationList, o.locationList, true);
  end;
end;

function TFhirOperationOutcomeIssue.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSeverity) and isEmptyProp(FCode) and isEmptyProp(FDetails) and isEmptyProp(FDiagnostics) and isEmptyProp(FlocationList);
end;

procedure TFhirOperationOutcomeIssue.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('severity');
  fields.add('code');
  fields.add('details');
  fields.add('diagnostics');
  fields.add('location');
end;

{ TFhirOperationOutcomeIssue }

Procedure TFhirOperationOutcomeIssue.SetSeverity(value : TFhirEnum);
begin
  FSeverity.free;
  FSeverity := value;
end;

Function TFhirOperationOutcomeIssue.GetSeverityST : TFhirIssueSeverityEnum;
begin
  if FSeverity = nil then
    result := TFhirIssueSeverityEnum(0)
  else
    result := TFhirIssueSeverityEnum(StringArrayIndexOfSensitive(CODES_TFhirIssueSeverityEnum, FSeverity.value));
end;

Procedure TFhirOperationOutcomeIssue.SetSeverityST(value : TFhirIssueSeverityEnum);
begin
  if ord(value) = 0 then
    SeverityElement := nil
  else
    SeverityElement := TFhirEnum.create(SYSTEMS_TFhirIssueSeverityEnum[value], CODES_TFhirIssueSeverityEnum[value]);
end;

Procedure TFhirOperationOutcomeIssue.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirOperationOutcomeIssue.GetCodeST : TFhirIssueTypeEnum;
begin
  if FCode = nil then
    result := TFhirIssueTypeEnum(0)
  else
    result := TFhirIssueTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirIssueTypeEnum, FCode.value));
end;

Procedure TFhirOperationOutcomeIssue.SetCodeST(value : TFhirIssueTypeEnum);
begin
  if ord(value) = 0 then
    CodeElement := nil
  else
    CodeElement := TFhirEnum.create(SYSTEMS_TFhirIssueTypeEnum[value], CODES_TFhirIssueTypeEnum[value]);
end;

Procedure TFhirOperationOutcomeIssue.SetDetails(value : TFhirCodeableConcept);
begin
  FDetails.free;
  FDetails := value;
end;

Procedure TFhirOperationOutcomeIssue.SetDiagnostics(value : TFhirString);
begin
  FDiagnostics.free;
  FDiagnostics := value;
end;

Function TFhirOperationOutcomeIssue.GetDiagnosticsST : String;
begin
  if FDiagnostics = nil then
    result := ''
  else
    result := FDiagnostics.value;
end;

Procedure TFhirOperationOutcomeIssue.SetDiagnosticsST(value : String);
begin
  if value <> '' then
  begin
    if FDiagnostics = nil then
      FDiagnostics := TFhirString.create;
    FDiagnostics.value := value
  end
  else if FDiagnostics <> nil then
    FDiagnostics.value := '';
end;

Function TFhirOperationOutcomeIssue.GetLocationList : TFhirStringList;
begin
  if FLocationList = nil then
    FLocationList := TFhirStringList.Create;
  result := FLocationList;
end;

Function TFhirOperationOutcomeIssue.GetHasLocationList : boolean;
begin
  result := (FLocationList <> nil) and (FLocationList.count > 0);
end;

function TFhirOperationOutcomeIssue.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSeverity.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FDetails.sizeInBytes);
  inc(result, FDiagnostics.sizeInBytes);
  inc(result, FlocationList.sizeInBytes);
end;

{ TFhirOperationOutcomeIssueListEnumerator }

Constructor TFhirOperationOutcomeIssueListEnumerator.Create(list : TFhirOperationOutcomeIssueList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirOperationOutcomeIssueListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirOperationOutcomeIssueListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirOperationOutcomeIssueListEnumerator.GetCurrent : TFhirOperationOutcomeIssue;
begin
  Result := FList[FIndex];
end;

function TFhirOperationOutcomeIssueListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirOperationOutcomeIssueList }
procedure TFhirOperationOutcomeIssueList.AddItem(value: TFhirOperationOutcomeIssue);
begin
  assert(value.ClassName = 'TFhirOperationOutcomeIssue', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOperationOutcomeIssue');
  add(value);
end;

function TFhirOperationOutcomeIssueList.Append: TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationOutcomeIssueList.ClearItems;
begin
  Clear;
end;

function TFhirOperationOutcomeIssueList.GetEnumerator : TFhirOperationOutcomeIssueListEnumerator;
begin
  result := TFhirOperationOutcomeIssueListEnumerator.Create(self.link);
end;

function TFhirOperationOutcomeIssueList.Clone: TFhirOperationOutcomeIssueList;
begin
  result := TFhirOperationOutcomeIssueList(inherited Clone);
end;

function TFhirOperationOutcomeIssueList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOperationOutcomeIssueList.GetItemN(index: Integer): TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue(ObjectByIndex[index]);
end;

function TFhirOperationOutcomeIssueList.ItemClass: TFslObjectClass;
begin
  result := TFhirOperationOutcomeIssue;
end;
function TFhirOperationOutcomeIssueList.IndexOf(value: TFhirOperationOutcomeIssue): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirOperationOutcomeIssueList.Insert(index: Integer): TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationOutcomeIssueList.InsertItem(index: Integer; value: TFhirOperationOutcomeIssue);
begin
  assert(value is TFhirOperationOutcomeIssue);
  Inherited Insert(index, value);
end;

function TFhirOperationOutcomeIssueList.Item(index: Integer): TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue(ObjectByIndex[index]);
end;

function TFhirOperationOutcomeIssueList.Link: TFhirOperationOutcomeIssueList;
begin
  result := TFhirOperationOutcomeIssueList(inherited Link);
end;

procedure TFhirOperationOutcomeIssueList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOperationOutcomeIssueList.SetItemByIndex(index: Integer; value: TFhirOperationOutcomeIssue);
begin
  assert(value is TFhirOperationOutcomeIssue);
  FhirOperationOutcomeIssues[index] := value;
end;

procedure TFhirOperationOutcomeIssueList.SetItemN(index: Integer; value: TFhirOperationOutcomeIssue);
begin
  assert(value is TFhirOperationOutcomeIssue);
  ObjectByIndex[index] := value;
end;

{ TFhirOperationOutcome }

constructor TFhirOperationOutcome.Create;
begin
  inherited;
end;

destructor TFhirOperationOutcome.Destroy;
begin
  FIssueList.Free;
  inherited;
end;

function TFhirOperationOutcome.GetResourceType : TFhirResourceType;
begin
  result := frtOperationOutcome;
end;

procedure TFhirOperationOutcome.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirOperationOutcome(oSource).FIssueList = nil) then
  begin
    FIssueList.free;
    FIssueList := nil;
  end
  else
  begin
    if FIssueList = nil then
      FIssueList := TFhirOperationOutcomeIssueList.Create;
    FIssueList.Assign(TFhirOperationOutcome(oSource).FIssueList);
  end;
end;

procedure TFhirOperationOutcome.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'issue') Then
    list.addAll(self, 'issue', FIssueList);
end;

procedure TFhirOperationOutcome.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'issue', '', true, TFhirOperationOutcomeIssue, FIssueList.Link)){3};
end;

function TFhirOperationOutcome.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'issue') then
  begin
    IssueList.add(propValue as TFhirOperationOutcomeIssue){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirOperationOutcome.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'issue') then IssueList.insertItem(index, propValue as TFhirOperationOutcomeIssue){2a}
  else inherited;
end;

function TFhirOperationOutcome.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'issue') then result := IssueList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirOperationOutcome.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'issue') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirOperationOutcome.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'issue') then deletePropertyValue('issue', IssueList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirOperationOutcome.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'issue') then replacePropertyValue('issue', IssueList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirOperationOutcome.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'issue') then IssueList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirOperationOutcome.fhirType : string;
begin
  result := 'OperationOutcome';
end;

function TFhirOperationOutcome.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FissueList);
end;

function TFhirOperationOutcome.equals(other : TObject) : boolean;
var
  o : TFhirOperationOutcome;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirOperationOutcome)) then
    result := false
  else
  begin
    o := TFhirOperationOutcome(other);
    result := compareDeep(issueList, o.issueList, true);
  end;
end;

function TFhirOperationOutcome.Link : TFhirOperationOutcome;
begin
  result := TFhirOperationOutcome(inherited Link);
end;

function TFhirOperationOutcome.Clone : TFhirOperationOutcome;
begin
  result := TFhirOperationOutcome(inherited Clone);
end;

procedure TFhirOperationOutcome.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('issue');
end;

{ TFhirOperationOutcome }

Function TFhirOperationOutcome.GetIssueList : TFhirOperationOutcomeIssueList;
begin
  if FIssueList = nil then
    FIssueList := TFhirOperationOutcomeIssueList.Create;
  result := FIssueList;
end;

Function TFhirOperationOutcome.GetHasIssueList : boolean;
begin
  result := (FIssueList <> nil) and (FIssueList.count > 0);
end;

function TFhirOperationOutcome.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FissueList.sizeInBytes);
end;

{ TFhirOperationOutcomeListEnumerator }

Constructor TFhirOperationOutcomeListEnumerator.Create(list : TFhirOperationOutcomeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirOperationOutcomeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirOperationOutcomeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirOperationOutcomeListEnumerator.GetCurrent : TFhirOperationOutcome;
begin
  Result := FList[FIndex];
end;

function TFhirOperationOutcomeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirOperationOutcomeList }
procedure TFhirOperationOutcomeList.AddItem(value: TFhirOperationOutcome);
begin
  assert(value.ClassName = 'TFhirOperationOutcome', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOperationOutcome');
  add(value);
end;

function TFhirOperationOutcomeList.Append: TFhirOperationOutcome;
begin
  result := TFhirOperationOutcome.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationOutcomeList.ClearItems;
begin
  Clear;
end;

function TFhirOperationOutcomeList.GetEnumerator : TFhirOperationOutcomeListEnumerator;
begin
  result := TFhirOperationOutcomeListEnumerator.Create(self.link);
end;

function TFhirOperationOutcomeList.Clone: TFhirOperationOutcomeList;
begin
  result := TFhirOperationOutcomeList(inherited Clone);
end;

function TFhirOperationOutcomeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOperationOutcomeList.GetItemN(index: Integer): TFhirOperationOutcome;
begin
  result := TFhirOperationOutcome(ObjectByIndex[index]);
end;

function TFhirOperationOutcomeList.ItemClass: TFslObjectClass;
begin
  result := TFhirOperationOutcome;
end;
function TFhirOperationOutcomeList.IndexOf(value: TFhirOperationOutcome): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirOperationOutcomeList.Insert(index: Integer): TFhirOperationOutcome;
begin
  result := TFhirOperationOutcome.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationOutcomeList.InsertItem(index: Integer; value: TFhirOperationOutcome);
begin
  assert(value is TFhirOperationOutcome);
  Inherited Insert(index, value);
end;

function TFhirOperationOutcomeList.Item(index: Integer): TFhirOperationOutcome;
begin
  result := TFhirOperationOutcome(ObjectByIndex[index]);
end;

function TFhirOperationOutcomeList.Link: TFhirOperationOutcomeList;
begin
  result := TFhirOperationOutcomeList(inherited Link);
end;

procedure TFhirOperationOutcomeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOperationOutcomeList.SetItemByIndex(index: Integer; value: TFhirOperationOutcome);
begin
  assert(value is TFhirOperationOutcome);
  FhirOperationOutcomes[index] := value;
end;

procedure TFhirOperationOutcomeList.SetItemN(index: Integer; value: TFhirOperationOutcome);
begin
  assert(value is TFhirOperationOutcome);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_OPERATIONOUTCOME}

{$IFDEF FHIR_ORDER}

{ TFhirOrderWhen }

constructor TFhirOrderWhen.Create;
begin
  inherited;
end;

destructor TFhirOrderWhen.Destroy;
begin
  FCode.free;
  FSchedule.free;
  inherited;
end;

procedure TFhirOrderWhen.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirOrderWhen(oSource).code.Clone;
  schedule := TFhirOrderWhen(oSource).schedule.Clone;
end;

procedure TFhirOrderWhen.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'schedule') Then
     list.add(self.link, 'schedule', FSchedule.Link);
end;

procedure TFhirOrderWhen.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'schedule', 'Timing', false, TFhirTiming, FSchedule.Link));{2}
end;

function TFhirOrderWhen.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'schedule') then
  begin
    Schedule := propValue as TFhirTiming{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirOrderWhen.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirOrderWhen.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'schedule') then result := TFhirTiming.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirOrderWhen.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'schedule') then result := 'Timing'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirOrderWhen.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'schedule') then ScheduleElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirOrderWhen.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'schedule') then ScheduleElement := new as TFhirTiming{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirOrderWhen.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirOrderWhen.fhirType : string;
begin
  result := 'when';
end;

function TFhirOrderWhen.Link : TFhirOrderWhen;
begin
  result := TFhirOrderWhen(inherited Link);
end;

function TFhirOrderWhen.Clone : TFhirOrderWhen;
begin
  result := TFhirOrderWhen(inherited Clone);
end;

function TFhirOrderWhen.equals(other : TObject) : boolean;
var
  o : TFhirOrderWhen;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirOrderWhen)) then
    result := false
  else
  begin
    o := TFhirOrderWhen(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(scheduleElement, o.scheduleElement, true);
  end;
end;

function TFhirOrderWhen.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FSchedule);
end;

procedure TFhirOrderWhen.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('schedule');
end;

{ TFhirOrderWhen }

Procedure TFhirOrderWhen.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirOrderWhen.SetSchedule(value : TFhirTiming);
begin
  FSchedule.free;
  FSchedule := value;
end;

function TFhirOrderWhen.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FSchedule.sizeInBytes);
end;

{ TFhirOrderWhenListEnumerator }

Constructor TFhirOrderWhenListEnumerator.Create(list : TFhirOrderWhenList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirOrderWhenListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirOrderWhenListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirOrderWhenListEnumerator.GetCurrent : TFhirOrderWhen;
begin
  Result := FList[FIndex];
end;

function TFhirOrderWhenListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirOrderWhenList }
procedure TFhirOrderWhenList.AddItem(value: TFhirOrderWhen);
begin
  assert(value.ClassName = 'TFhirOrderWhen', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOrderWhen');
  add(value);
end;

function TFhirOrderWhenList.Append: TFhirOrderWhen;
begin
  result := TFhirOrderWhen.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOrderWhenList.ClearItems;
begin
  Clear;
end;

function TFhirOrderWhenList.GetEnumerator : TFhirOrderWhenListEnumerator;
begin
  result := TFhirOrderWhenListEnumerator.Create(self.link);
end;

function TFhirOrderWhenList.Clone: TFhirOrderWhenList;
begin
  result := TFhirOrderWhenList(inherited Clone);
end;

function TFhirOrderWhenList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOrderWhenList.GetItemN(index: Integer): TFhirOrderWhen;
begin
  result := TFhirOrderWhen(ObjectByIndex[index]);
end;

function TFhirOrderWhenList.ItemClass: TFslObjectClass;
begin
  result := TFhirOrderWhen;
end;
function TFhirOrderWhenList.IndexOf(value: TFhirOrderWhen): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirOrderWhenList.Insert(index: Integer): TFhirOrderWhen;
begin
  result := TFhirOrderWhen.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOrderWhenList.InsertItem(index: Integer; value: TFhirOrderWhen);
begin
  assert(value is TFhirOrderWhen);
  Inherited Insert(index, value);
end;

function TFhirOrderWhenList.Item(index: Integer): TFhirOrderWhen;
begin
  result := TFhirOrderWhen(ObjectByIndex[index]);
end;

function TFhirOrderWhenList.Link: TFhirOrderWhenList;
begin
  result := TFhirOrderWhenList(inherited Link);
end;

procedure TFhirOrderWhenList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOrderWhenList.SetItemByIndex(index: Integer; value: TFhirOrderWhen);
begin
  assert(value is TFhirOrderWhen);
  FhirOrderWhens[index] := value;
end;

procedure TFhirOrderWhenList.SetItemN(index: Integer; value: TFhirOrderWhen);
begin
  assert(value is TFhirOrderWhen);
  ObjectByIndex[index] := value;
end;

{ TFhirOrder }

constructor TFhirOrder.Create;
begin
  inherited;
end;

destructor TFhirOrder.Destroy;
begin
  FIdentifierList.Free;
  FDate.free;
  FSubject.free;
  FSource.free;
  FTarget.free;
  FReason.free;
  FWhen.free;
  FDetailList.Free;
  inherited;
end;

function TFhirOrder.GetResourceType : TFhirResourceType;
begin
  result := frtOrder;
end;

procedure TFhirOrder.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirOrder(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirOrder(oSource).FIdentifierList);
  end;
  dateElement := TFhirOrder(oSource).dateElement.Clone;
  subject := TFhirOrder(oSource).subject.Clone;
  source := TFhirOrder(oSource).source.Clone;
  target := TFhirOrder(oSource).target.Clone;
  reason := TFhirOrder(oSource).reason.Clone;
  when := TFhirOrder(oSource).when.Clone;
  if (TFhirOrder(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirReferenceList{TFhirReference}.Create;
    FDetailList.Assign(TFhirOrder(oSource).FDetailList);
  end;
end;

procedure TFhirOrder.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'target') Then
     list.add(self.link, 'target', FTarget.Link);
  if (child_name = 'reason[x]') or (child_name = 'reason') Then
     list.add(self.link, 'reason[x]', FReason.Link);
  if (child_name = 'when') Then
     list.add(self.link, 'when', FWhen.Link);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
end;

procedure TFhirOrder.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Group|Device|Substance)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'source', 'Reference(Practitioner|Organization)', false, TFhirReference{Resource}, FSource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'target', 'Reference(Organization|Device|Practitioner)', false, TFhirReference{Resource}, FTarget.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason[x]', 'CodeableConcept|Reference(Any)', false, TFhirType, FReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'when', '', false, TFhirOrderWhen, FWhen.Link));{2}
  oList.add(TFHIRProperty.create(self, 'detail', 'Reference(Any)', true, TFhirReference{TFhirReference}, FDetailList.Link)){3};
end;

function TFhirOrder.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    Source := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'target') then
  begin
    Target := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then
  begin
    Reason := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'when') then
  begin
    When := propValue as TFhirOrderWhen{4b};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirOrder.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else inherited;
end;

function TFhirOrder.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'source') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'target') then result := TFhirReference{Resource}.create(){4b}
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Reason'){4x}
  else if (propName = 'when') then result := TFhirOrderWhen.create(){4b}
  else if (propName = 'detail') then result := DetailList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirOrder.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'source') then result := 'Reference'
  else if (propName = 'target') then result := 'Reference'
  else if (propName = 'reason[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'when') then result := ''
  else if (propName = 'detail') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirOrder.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'source') then SourceElement := nil
  else if (propName = 'target') then TargetElement := nil
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then ReasonElement := nil{4x}
  else if (propName = 'when') then WhenElement := nil
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirOrder.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'source') then SourceElement := new as TFhirReference{Resource}{4}
  else if (propName = 'target') then TargetElement := new as TFhirReference{Resource}{4}
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then ReasonElement := new as TFhirType{4x}
  else if (propName = 'when') then WhenElement := new as TFhirOrderWhen{4}
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirOrder.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'detail') then DetailList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirOrder.fhirType : string;
begin
  result := 'Order';
end;

function TFhirOrder.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FDate) and isEmptyProp(FSubject) and isEmptyProp(FSource) and isEmptyProp(FTarget) and isEmptyProp(FReason) and isEmptyProp(FWhen) and isEmptyProp(FdetailList);
end;

function TFhirOrder.equals(other : TObject) : boolean;
var
  o : TFhirOrder;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirOrder)) then
    result := false
  else
  begin
    o := TFhirOrder(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(dateElement, o.dateElement, true) and
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(sourceElement, o.sourceElement, true) and
      compareDeep(targetElement, o.targetElement, true) and compareDeep(reasonElement, o.reasonElement, true) and
      compareDeep(whenElement, o.whenElement, true) and compareDeep(detailList, o.detailList, true);
  end;
end;

function TFhirOrder.Link : TFhirOrder;
begin
  result := TFhirOrder(inherited Link);
end;

function TFhirOrder.Clone : TFhirOrder;
begin
  result := TFhirOrder(inherited Clone);
end;

procedure TFhirOrder.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('date');
  fields.add('subject');
  fields.add('source');
  fields.add('target');
  fields.add('reason[x]');
  fields.add('when');
  fields.add('detail');
end;

{ TFhirOrder }

Function TFhirOrder.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirOrder.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirOrder.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirOrder.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirOrder.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirOrder.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirOrder.SetSource(value : TFhirReference{Resource});
begin
  FSource.free;
  FSource := value;
end;

Procedure TFhirOrder.SetTarget(value : TFhirReference{Resource});
begin
  FTarget.free;
  FTarget := value;
end;

Procedure TFhirOrder.SetReason(value : TFhirType);
begin
  FReason.free;
  FReason := value;
end;

Procedure TFhirOrder.SetWhen(value : TFhirOrderWhen);
begin
  FWhen.free;
  FWhen := value;
end;

Function TFhirOrder.GetDetailList : TFhirReferenceList{TFhirReference};
begin
  if FDetailList = nil then
    FDetailList := TFhirReferenceList{TFhirReference}.Create;
  result := FDetailList;
end;

Function TFhirOrder.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

function TFhirOrder.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FSource.sizeInBytes);
  inc(result, FTarget.sizeInBytes);
  inc(result, FReason.sizeInBytes);
  inc(result, FWhen.sizeInBytes);
  inc(result, FdetailList.sizeInBytes);
end;

{ TFhirOrderListEnumerator }

Constructor TFhirOrderListEnumerator.Create(list : TFhirOrderList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirOrderListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirOrderListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirOrderListEnumerator.GetCurrent : TFhirOrder;
begin
  Result := FList[FIndex];
end;

function TFhirOrderListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirOrderList }
procedure TFhirOrderList.AddItem(value: TFhirOrder);
begin
  assert(value.ClassName = 'TFhirOrder', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOrder');
  add(value);
end;

function TFhirOrderList.Append: TFhirOrder;
begin
  result := TFhirOrder.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOrderList.ClearItems;
begin
  Clear;
end;

function TFhirOrderList.GetEnumerator : TFhirOrderListEnumerator;
begin
  result := TFhirOrderListEnumerator.Create(self.link);
end;

function TFhirOrderList.Clone: TFhirOrderList;
begin
  result := TFhirOrderList(inherited Clone);
end;

function TFhirOrderList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOrderList.GetItemN(index: Integer): TFhirOrder;
begin
  result := TFhirOrder(ObjectByIndex[index]);
end;

function TFhirOrderList.ItemClass: TFslObjectClass;
begin
  result := TFhirOrder;
end;
function TFhirOrderList.IndexOf(value: TFhirOrder): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirOrderList.Insert(index: Integer): TFhirOrder;
begin
  result := TFhirOrder.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOrderList.InsertItem(index: Integer; value: TFhirOrder);
begin
  assert(value is TFhirOrder);
  Inherited Insert(index, value);
end;

function TFhirOrderList.Item(index: Integer): TFhirOrder;
begin
  result := TFhirOrder(ObjectByIndex[index]);
end;

function TFhirOrderList.Link: TFhirOrderList;
begin
  result := TFhirOrderList(inherited Link);
end;

procedure TFhirOrderList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOrderList.SetItemByIndex(index: Integer; value: TFhirOrder);
begin
  assert(value is TFhirOrder);
  FhirOrders[index] := value;
end;

procedure TFhirOrderList.SetItemN(index: Integer; value: TFhirOrder);
begin
  assert(value is TFhirOrder);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ORDER}

{$IFDEF FHIR_ORDERRESPONSE}

{ TFhirOrderResponse }

constructor TFhirOrderResponse.Create;
begin
  inherited;
end;

destructor TFhirOrderResponse.Destroy;
begin
  FIdentifierList.Free;
  FRequest.free;
  FDate.free;
  FWho.free;
  FOrderStatus.free;
  FDescription.free;
  FFulfillmentList.Free;
  inherited;
end;

function TFhirOrderResponse.GetResourceType : TFhirResourceType;
begin
  result := frtOrderResponse;
end;

procedure TFhirOrderResponse.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirOrderResponse(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirOrderResponse(oSource).FIdentifierList);
  end;
  request := TFhirOrderResponse(oSource).request.Clone;
  dateElement := TFhirOrderResponse(oSource).dateElement.Clone;
  who := TFhirOrderResponse(oSource).who.Clone;
  FOrderStatus := TFhirOrderResponse(oSource).FOrderStatus.Link;
  descriptionElement := TFhirOrderResponse(oSource).descriptionElement.Clone;
  if (TFhirOrderResponse(oSource).FFulfillmentList = nil) then
  begin
    FFulfillmentList.free;
    FFulfillmentList := nil;
  end
  else
  begin
    if FFulfillmentList = nil then
      FFulfillmentList := TFhirReferenceList{TFhirReference}.Create;
    FFulfillmentList.Assign(TFhirOrderResponse(oSource).FFulfillmentList);
  end;
end;

procedure TFhirOrderResponse.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'who') Then
     list.add(self.link, 'who', FWho.Link);
  if (child_name = 'orderStatus') Then
     list.add(self.link, 'orderStatus', FOrderStatus.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'fulfillment') Then
    list.addAll(self, 'fulfillment', FFulfillmentList);
end;

procedure TFhirOrderResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'request', 'Reference(Order)', false, TFhirReference{TFhirOrder}, FRequest.Link));{2}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'who', 'Reference(Practitioner|Organization|Device)', false, TFhirReference{Resource}, FWho.Link));{2}
  oList.add(TFHIRProperty.create(self, 'orderStatus', 'code', false, TFHIREnum, FOrderStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'fulfillment', 'Reference(Any)', true, TFhirReference{TFhirReference}, FFulfillmentList.Link)){3};
end;

function TFhirOrderResponse.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirReference{TFhirOrder}{4b};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'who') then
  begin
    Who := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'orderStatus') then
  begin
    OrderStatusElement := asEnum(SYSTEMS_TFhirOrderStatusEnum, CODES_TFhirOrderStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'fulfillment') then
  begin
    FulfillmentList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirOrderResponse.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'fulfillment') then FulfillmentList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else inherited;
end;

function TFhirOrderResponse.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'request') then result := TFhirReference{TFhirOrder}.create(){4b}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'who') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'fulfillment') then result := FulfillmentList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirOrderResponse.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'who') then result := 'Reference'
  else if (propName = 'orderStatus') then result := 'code'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'fulfillment') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirOrderResponse.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'who') then WhoElement := nil
  else if (propName = 'orderStatus') then OrderStatusElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'fulfillment') then deletePropertyValue('fulfillment', FulfillmentList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirOrderResponse.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'request') then RequestElement := new as TFhirReference{TFhirOrder}{4}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'who') then WhoElement := new as TFhirReference{Resource}{4}
  else if (propName = 'orderStatus') then OrderStatusElement := asEnum(SYSTEMS_TFhirOrderStatusEnum, CODES_TFhirOrderStatusEnum, new){4}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'fulfillment') then replacePropertyValue('fulfillment', FulfillmentList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirOrderResponse.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'fulfillment') then FulfillmentList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirOrderResponse.fhirType : string;
begin
  result := 'OrderResponse';
end;

function TFhirOrderResponse.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FRequest) and isEmptyProp(FDate) and isEmptyProp(FWho) and isEmptyProp(FOrderStatus) and isEmptyProp(FDescription) and isEmptyProp(FfulfillmentList);
end;

function TFhirOrderResponse.equals(other : TObject) : boolean;
var
  o : TFhirOrderResponse;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirOrderResponse)) then
    result := false
  else
  begin
    o := TFhirOrderResponse(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(requestElement, o.requestElement, true) and
      compareDeep(dateElement, o.dateElement, true) and compareDeep(whoElement, o.whoElement, true) and
      compareDeep(orderStatusElement, o.orderStatusElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and
      compareDeep(fulfillmentList, o.fulfillmentList, true);
  end;
end;

function TFhirOrderResponse.Link : TFhirOrderResponse;
begin
  result := TFhirOrderResponse(inherited Link);
end;

function TFhirOrderResponse.Clone : TFhirOrderResponse;
begin
  result := TFhirOrderResponse(inherited Clone);
end;

procedure TFhirOrderResponse.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('request');
  fields.add('date');
  fields.add('who');
  fields.add('orderStatus');
  fields.add('description');
  fields.add('fulfillment');
end;

{ TFhirOrderResponse }

Function TFhirOrderResponse.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirOrderResponse.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirOrderResponse.SetRequest(value : TFhirReference{TFhirOrder});
begin
  FRequest.free;
  FRequest := value;
end;

Procedure TFhirOrderResponse.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirOrderResponse.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirOrderResponse.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirOrderResponse.SetWho(value : TFhirReference{Resource});
begin
  FWho.free;
  FWho := value;
end;

Procedure TFhirOrderResponse.SetOrderStatus(value : TFhirEnum);
begin
  FOrderStatus.free;
  FOrderStatus := value;
end;

Function TFhirOrderResponse.GetOrderStatusST : TFhirOrderStatusEnum;
begin
  if FOrderStatus = nil then
    result := TFhirOrderStatusEnum(0)
  else
    result := TFhirOrderStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirOrderStatusEnum, FOrderStatus.value));
end;

Procedure TFhirOrderResponse.SetOrderStatusST(value : TFhirOrderStatusEnum);
begin
  if ord(value) = 0 then
    OrderStatusElement := nil
  else
    OrderStatusElement := TFhirEnum.create(SYSTEMS_TFhirOrderStatusEnum[value], CODES_TFhirOrderStatusEnum[value]);
end;

Procedure TFhirOrderResponse.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirOrderResponse.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirOrderResponse.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Function TFhirOrderResponse.GetFulfillmentList : TFhirReferenceList{TFhirReference};
begin
  if FFulfillmentList = nil then
    FFulfillmentList := TFhirReferenceList{TFhirReference}.Create;
  result := FFulfillmentList;
end;

Function TFhirOrderResponse.GetHasFulfillmentList : boolean;
begin
  result := (FFulfillmentList <> nil) and (FFulfillmentList.count > 0);
end;

function TFhirOrderResponse.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FRequest.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FWho.sizeInBytes);
  inc(result, FOrderStatus.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FfulfillmentList.sizeInBytes);
end;

{ TFhirOrderResponseListEnumerator }

Constructor TFhirOrderResponseListEnumerator.Create(list : TFhirOrderResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirOrderResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirOrderResponseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirOrderResponseListEnumerator.GetCurrent : TFhirOrderResponse;
begin
  Result := FList[FIndex];
end;

function TFhirOrderResponseListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirOrderResponseList }
procedure TFhirOrderResponseList.AddItem(value: TFhirOrderResponse);
begin
  assert(value.ClassName = 'TFhirOrderResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOrderResponse');
  add(value);
end;

function TFhirOrderResponseList.Append: TFhirOrderResponse;
begin
  result := TFhirOrderResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOrderResponseList.ClearItems;
begin
  Clear;
end;

function TFhirOrderResponseList.GetEnumerator : TFhirOrderResponseListEnumerator;
begin
  result := TFhirOrderResponseListEnumerator.Create(self.link);
end;

function TFhirOrderResponseList.Clone: TFhirOrderResponseList;
begin
  result := TFhirOrderResponseList(inherited Clone);
end;

function TFhirOrderResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOrderResponseList.GetItemN(index: Integer): TFhirOrderResponse;
begin
  result := TFhirOrderResponse(ObjectByIndex[index]);
end;

function TFhirOrderResponseList.ItemClass: TFslObjectClass;
begin
  result := TFhirOrderResponse;
end;
function TFhirOrderResponseList.IndexOf(value: TFhirOrderResponse): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirOrderResponseList.Insert(index: Integer): TFhirOrderResponse;
begin
  result := TFhirOrderResponse.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOrderResponseList.InsertItem(index: Integer; value: TFhirOrderResponse);
begin
  assert(value is TFhirOrderResponse);
  Inherited Insert(index, value);
end;

function TFhirOrderResponseList.Item(index: Integer): TFhirOrderResponse;
begin
  result := TFhirOrderResponse(ObjectByIndex[index]);
end;

function TFhirOrderResponseList.Link: TFhirOrderResponseList;
begin
  result := TFhirOrderResponseList(inherited Link);
end;

procedure TFhirOrderResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOrderResponseList.SetItemByIndex(index: Integer; value: TFhirOrderResponse);
begin
  assert(value is TFhirOrderResponse);
  FhirOrderResponses[index] := value;
end;

procedure TFhirOrderResponseList.SetItemN(index: Integer; value: TFhirOrderResponse);
begin
  assert(value is TFhirOrderResponse);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ORDERRESPONSE}

{$IFDEF FHIR_PAYMENTNOTICE}

{ TFhirPaymentNotice }

constructor TFhirPaymentNotice.Create;
begin
  inherited;
end;

destructor TFhirPaymentNotice.Destroy;
begin
  FIdentifierList.Free;
  FRuleset.free;
  FOriginalRuleset.free;
  FCreated.free;
  FTarget.free;
  FProvider.free;
  FOrganization.free;
  FRequest.free;
  FResponse.free;
  FPaymentStatus.free;
  inherited;
end;

function TFhirPaymentNotice.GetResourceType : TFhirResourceType;
begin
  result := frtPaymentNotice;
end;

procedure TFhirPaymentNotice.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPaymentNotice(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirPaymentNotice(oSource).FIdentifierList);
  end;
  ruleset := TFhirPaymentNotice(oSource).ruleset.Clone;
  originalRuleset := TFhirPaymentNotice(oSource).originalRuleset.Clone;
  createdElement := TFhirPaymentNotice(oSource).createdElement.Clone;
  target := TFhirPaymentNotice(oSource).target.Clone;
  provider := TFhirPaymentNotice(oSource).provider.Clone;
  organization := TFhirPaymentNotice(oSource).organization.Clone;
  request := TFhirPaymentNotice(oSource).request.Clone;
  response := TFhirPaymentNotice(oSource).response.Clone;
  paymentStatus := TFhirPaymentNotice(oSource).paymentStatus.Clone;
end;

procedure TFhirPaymentNotice.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'ruleset') Then
     list.add(self.link, 'ruleset', FRuleset.Link);
  if (child_name = 'originalRuleset') Then
     list.add(self.link, 'originalRuleset', FOriginalRuleset.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'target') Then
     list.add(self.link, 'target', FTarget.Link);
  if (child_name = 'provider') Then
     list.add(self.link, 'provider', FProvider.Link);
  if (child_name = 'organization') Then
     list.add(self.link, 'organization', FOrganization.Link);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'response') Then
     list.add(self.link, 'response', FResponse.Link);
  if (child_name = 'paymentStatus') Then
     list.add(self.link, 'paymentStatus', FPaymentStatus.Link);
end;

procedure TFhirPaymentNotice.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'ruleset', 'Coding', false, TFhirCoding, FRuleset.Link));{2}
  oList.add(TFHIRProperty.create(self, 'originalRuleset', 'Coding', false, TFhirCoding, FOriginalRuleset.Link));{2}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));{2}
  oList.add(TFHIRProperty.create(self, 'target', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FTarget.Link));{2}
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FProvider.Link));{2}
  oList.add(TFHIRProperty.create(self, 'organization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FOrganization.Link));{2}
  oList.add(TFHIRProperty.create(self, 'request', 'Reference(Any)', false, TFhirReference{TFhirReference}, FRequest.Link));{2}
  oList.add(TFHIRProperty.create(self, 'response', 'Reference(Any)', false, TFhirReference{TFhirReference}, FResponse.Link));{2}
  oList.add(TFHIRProperty.create(self, 'paymentStatus', 'Coding', false, TFhirCoding, FPaymentStatus.Link));{2}
end;

function TFhirPaymentNotice.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'ruleset') then
  begin
    Ruleset := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'originalRuleset') then
  begin
    OriginalRuleset := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'target') then
  begin
    Target := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'provider') then
  begin
    Provider := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'organization') then
  begin
    Organization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'response') then
  begin
    Response := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'paymentStatus') then
  begin
    PaymentStatus := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirPaymentNotice.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else inherited;
end;

function TFhirPaymentNotice.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'ruleset') then result := TFhirCoding.create(){4b}
  else if (propName = 'originalRuleset') then result := TFhirCoding.create(){4b}
  else if (propName = 'created') then result := TFhirDateTime.create() {5b}
  else if (propName = 'target') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'provider') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'organization') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'request') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'response') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'paymentStatus') then result := TFhirCoding.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPaymentNotice.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'ruleset') then result := 'Coding'
  else if (propName = 'originalRuleset') then result := 'Coding'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'target') then result := 'Reference'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'organization') then result := 'Reference'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'response') then result := 'Reference'
  else if (propName = 'paymentStatus') then result := 'Coding'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPaymentNotice.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'ruleset') then RulesetElement := nil
  else if (propName = 'originalRuleset') then OriginalRulesetElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'target') then TargetElement := nil
  else if (propName = 'provider') then ProviderElement := nil
  else if (propName = 'organization') then OrganizationElement := nil
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'response') then ResponseElement := nil
  else if (propName = 'paymentStatus') then PaymentStatusElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPaymentNotice.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'ruleset') then RulesetElement := new as TFhirCoding{4}
  else if (propName = 'originalRuleset') then OriginalRulesetElement := new as TFhirCoding{4}
  else if (propName = 'created') then CreatedElement := asDateTime(new){5b}
  else if (propName = 'target') then TargetElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'provider') then ProviderElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'organization') then OrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'request') then RequestElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'response') then ResponseElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'paymentStatus') then PaymentStatusElement := new as TFhirCoding{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPaymentNotice.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPaymentNotice.fhirType : string;
begin
  result := 'PaymentNotice';
end;

function TFhirPaymentNotice.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FRuleset) and isEmptyProp(FOriginalRuleset) and isEmptyProp(FCreated) and isEmptyProp(FTarget) and isEmptyProp(FProvider) and isEmptyProp(FOrganization) and isEmptyProp(FRequest) and isEmptyProp(FResponse) and isEmptyProp(FPaymentStatus);
end;

function TFhirPaymentNotice.equals(other : TObject) : boolean;
var
  o : TFhirPaymentNotice;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPaymentNotice)) then
    result := false
  else
  begin
    o := TFhirPaymentNotice(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(rulesetElement, o.rulesetElement, true) and
      compareDeep(originalRulesetElement, o.originalRulesetElement, true) and compareDeep(createdElement, o.createdElement, true) and
      compareDeep(targetElement, o.targetElement, true) and compareDeep(providerElement, o.providerElement, true) and
      compareDeep(organizationElement, o.organizationElement, true) and compareDeep(requestElement, o.requestElement, true) and
      compareDeep(responseElement, o.responseElement, true) and compareDeep(paymentStatusElement, o.paymentStatusElement, true);
  end;
end;

function TFhirPaymentNotice.Link : TFhirPaymentNotice;
begin
  result := TFhirPaymentNotice(inherited Link);
end;

function TFhirPaymentNotice.Clone : TFhirPaymentNotice;
begin
  result := TFhirPaymentNotice(inherited Clone);
end;

procedure TFhirPaymentNotice.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('ruleset');
  fields.add('originalRuleset');
  fields.add('created');
  fields.add('target');
  fields.add('provider');
  fields.add('organization');
  fields.add('request');
  fields.add('response');
  fields.add('paymentStatus');
end;

{ TFhirPaymentNotice }

Function TFhirPaymentNotice.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirPaymentNotice.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirPaymentNotice.SetRuleset(value : TFhirCoding);
begin
  FRuleset.free;
  FRuleset := value;
end;

Procedure TFhirPaymentNotice.SetOriginalRuleset(value : TFhirCoding);
begin
  FOriginalRuleset.free;
  FOriginalRuleset := value;
end;

Procedure TFhirPaymentNotice.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

Function TFhirPaymentNotice.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

Procedure TFhirPaymentNotice.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

Procedure TFhirPaymentNotice.SetTarget(value : TFhirReference{TFhirOrganization});
begin
  FTarget.free;
  FTarget := value;
end;

Procedure TFhirPaymentNotice.SetProvider(value : TFhirReference{TFhirPractitioner});
begin
  FProvider.free;
  FProvider := value;
end;

Procedure TFhirPaymentNotice.SetOrganization(value : TFhirReference{TFhirOrganization});
begin
  FOrganization.free;
  FOrganization := value;
end;

Procedure TFhirPaymentNotice.SetRequest(value : TFhirReference{TFhirReference});
begin
  FRequest.free;
  FRequest := value;
end;

Procedure TFhirPaymentNotice.SetResponse(value : TFhirReference{TFhirReference});
begin
  FResponse.free;
  FResponse := value;
end;

Procedure TFhirPaymentNotice.SetPaymentStatus(value : TFhirCoding);
begin
  FPaymentStatus.free;
  FPaymentStatus := value;
end;

function TFhirPaymentNotice.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FRuleset.sizeInBytes);
  inc(result, FOriginalRuleset.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FTarget.sizeInBytes);
  inc(result, FProvider.sizeInBytes);
  inc(result, FOrganization.sizeInBytes);
  inc(result, FRequest.sizeInBytes);
  inc(result, FResponse.sizeInBytes);
  inc(result, FPaymentStatus.sizeInBytes);
end;

{ TFhirPaymentNoticeListEnumerator }

Constructor TFhirPaymentNoticeListEnumerator.Create(list : TFhirPaymentNoticeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPaymentNoticeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPaymentNoticeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPaymentNoticeListEnumerator.GetCurrent : TFhirPaymentNotice;
begin
  Result := FList[FIndex];
end;

function TFhirPaymentNoticeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirPaymentNoticeList }
procedure TFhirPaymentNoticeList.AddItem(value: TFhirPaymentNotice);
begin
  assert(value.ClassName = 'TFhirPaymentNotice', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPaymentNotice');
  add(value);
end;

function TFhirPaymentNoticeList.Append: TFhirPaymentNotice;
begin
  result := TFhirPaymentNotice.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPaymentNoticeList.ClearItems;
begin
  Clear;
end;

function TFhirPaymentNoticeList.GetEnumerator : TFhirPaymentNoticeListEnumerator;
begin
  result := TFhirPaymentNoticeListEnumerator.Create(self.link);
end;

function TFhirPaymentNoticeList.Clone: TFhirPaymentNoticeList;
begin
  result := TFhirPaymentNoticeList(inherited Clone);
end;

function TFhirPaymentNoticeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPaymentNoticeList.GetItemN(index: Integer): TFhirPaymentNotice;
begin
  result := TFhirPaymentNotice(ObjectByIndex[index]);
end;

function TFhirPaymentNoticeList.ItemClass: TFslObjectClass;
begin
  result := TFhirPaymentNotice;
end;
function TFhirPaymentNoticeList.IndexOf(value: TFhirPaymentNotice): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPaymentNoticeList.Insert(index: Integer): TFhirPaymentNotice;
begin
  result := TFhirPaymentNotice.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPaymentNoticeList.InsertItem(index: Integer; value: TFhirPaymentNotice);
begin
  assert(value is TFhirPaymentNotice);
  Inherited Insert(index, value);
end;

function TFhirPaymentNoticeList.Item(index: Integer): TFhirPaymentNotice;
begin
  result := TFhirPaymentNotice(ObjectByIndex[index]);
end;

function TFhirPaymentNoticeList.Link: TFhirPaymentNoticeList;
begin
  result := TFhirPaymentNoticeList(inherited Link);
end;

procedure TFhirPaymentNoticeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPaymentNoticeList.SetItemByIndex(index: Integer; value: TFhirPaymentNotice);
begin
  assert(value is TFhirPaymentNotice);
  FhirPaymentNotices[index] := value;
end;

procedure TFhirPaymentNoticeList.SetItemN(index: Integer; value: TFhirPaymentNotice);
begin
  assert(value is TFhirPaymentNotice);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PAYMENTNOTICE}

{$IFDEF FHIR_PAYMENTRECONCILIATION}

{ TFhirPaymentReconciliationDetail }

constructor TFhirPaymentReconciliationDetail.Create;
begin
  inherited;
end;

destructor TFhirPaymentReconciliationDetail.Destroy;
begin
  FType_.free;
  FRequest.free;
  FResponce.free;
  FSubmitter.free;
  FPayee.free;
  FDate.free;
  FAmount.free;
  inherited;
end;

procedure TFhirPaymentReconciliationDetail.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirPaymentReconciliationDetail(oSource).type_.Clone;
  request := TFhirPaymentReconciliationDetail(oSource).request.Clone;
  responce := TFhirPaymentReconciliationDetail(oSource).responce.Clone;
  submitter := TFhirPaymentReconciliationDetail(oSource).submitter.Clone;
  payee := TFhirPaymentReconciliationDetail(oSource).payee.Clone;
  dateElement := TFhirPaymentReconciliationDetail(oSource).dateElement.Clone;
  amount := TFhirPaymentReconciliationDetail(oSource).amount.Clone;
end;

procedure TFhirPaymentReconciliationDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'responce') Then
     list.add(self.link, 'responce', FResponce.Link);
  if (child_name = 'submitter') Then
     list.add(self.link, 'submitter', FSubmitter.Link);
  if (child_name = 'payee') Then
     list.add(self.link, 'payee', FPayee.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
end;

procedure TFhirPaymentReconciliationDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', false, TFhirCoding, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'request', 'Reference(Any)', false, TFhirReference{TFhirReference}, FRequest.Link));{2}
  oList.add(TFHIRProperty.create(self, 'responce', 'Reference(Any)', false, TFhirReference{TFhirReference}, FResponce.Link));{2}
  oList.add(TFHIRProperty.create(self, 'submitter', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FSubmitter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'payee', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FPayee.Link));{2}
  oList.add(TFHIRProperty.create(self, 'date', 'date', false, TFhirDate, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amount', 'Quantity', false, TFhirQuantity, FAmount.Link));{2}
end;

function TFhirPaymentReconciliationDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'responce') then
  begin
    Responce := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'submitter') then
  begin
    Submitter := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'payee') then
  begin
    Payee := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPaymentReconciliationDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPaymentReconciliationDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCoding.create(){4b}
  else if (propName = 'request') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'responce') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'submitter') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'payee') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'date') then result := TFhirDate.create() {5b}
  else if (propName = 'amount') then result := TFhirQuantity.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPaymentReconciliationDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'Coding'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'responce') then result := 'Reference'
  else if (propName = 'submitter') then result := 'Reference'
  else if (propName = 'payee') then result := 'Reference'
  else if (propName = 'date') then result := 'date'
  else if (propName = 'amount') then result := 'Quantity'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPaymentReconciliationDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'responce') then ResponceElement := nil
  else if (propName = 'submitter') then SubmitterElement := nil
  else if (propName = 'payee') then PayeeElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPaymentReconciliationDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCoding{4}
  else if (propName = 'request') then RequestElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'responce') then ResponceElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'submitter') then SubmitterElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'payee') then PayeeElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'date') then DateElement := asDate(new){5b}
  else if (propName = 'amount') then AmountElement := new as TFhirQuantity{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPaymentReconciliationDetail.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPaymentReconciliationDetail.fhirType : string;
begin
  result := 'detail';
end;

function TFhirPaymentReconciliationDetail.Link : TFhirPaymentReconciliationDetail;
begin
  result := TFhirPaymentReconciliationDetail(inherited Link);
end;

function TFhirPaymentReconciliationDetail.Clone : TFhirPaymentReconciliationDetail;
begin
  result := TFhirPaymentReconciliationDetail(inherited Clone);
end;

function TFhirPaymentReconciliationDetail.equals(other : TObject) : boolean;
var
  o : TFhirPaymentReconciliationDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPaymentReconciliationDetail)) then
    result := false
  else
  begin
    o := TFhirPaymentReconciliationDetail(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(requestElement, o.requestElement, true) and
      compareDeep(responceElement, o.responceElement, true) and compareDeep(submitterElement, o.submitterElement, true) and
      compareDeep(payeeElement, o.payeeElement, true) and compareDeep(dateElement, o.dateElement, true) and
      compareDeep(amountElement, o.amountElement, true);
  end;
end;

function TFhirPaymentReconciliationDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FRequest) and isEmptyProp(FResponce) and isEmptyProp(FSubmitter) and isEmptyProp(FPayee) and isEmptyProp(FDate) and isEmptyProp(FAmount);
end;

procedure TFhirPaymentReconciliationDetail.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('request');
  fields.add('responce');
  fields.add('submitter');
  fields.add('payee');
  fields.add('date');
  fields.add('amount');
end;

{ TFhirPaymentReconciliationDetail }

Procedure TFhirPaymentReconciliationDetail.SetType_(value : TFhirCoding);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirPaymentReconciliationDetail.SetRequest(value : TFhirReference{TFhirReference});
begin
  FRequest.free;
  FRequest := value;
end;

Procedure TFhirPaymentReconciliationDetail.SetResponce(value : TFhirReference{TFhirReference});
begin
  FResponce.free;
  FResponce := value;
end;

Procedure TFhirPaymentReconciliationDetail.SetSubmitter(value : TFhirReference{TFhirOrganization});
begin
  FSubmitter.free;
  FSubmitter := value;
end;

Procedure TFhirPaymentReconciliationDetail.SetPayee(value : TFhirReference{TFhirOrganization});
begin
  FPayee.free;
  FPayee := value;
end;

Procedure TFhirPaymentReconciliationDetail.SetDate(value : TFhirDate);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirPaymentReconciliationDetail.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirPaymentReconciliationDetail.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDate.create;
  FDate.value := value
end;

Procedure TFhirPaymentReconciliationDetail.SetAmount(value : TFhirQuantity);
begin
  FAmount.free;
  FAmount := value;
end;

function TFhirPaymentReconciliationDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FRequest.sizeInBytes);
  inc(result, FResponce.sizeInBytes);
  inc(result, FSubmitter.sizeInBytes);
  inc(result, FPayee.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
end;

{ TFhirPaymentReconciliationDetailListEnumerator }

Constructor TFhirPaymentReconciliationDetailListEnumerator.Create(list : TFhirPaymentReconciliationDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPaymentReconciliationDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPaymentReconciliationDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPaymentReconciliationDetailListEnumerator.GetCurrent : TFhirPaymentReconciliationDetail;
begin
  Result := FList[FIndex];
end;

function TFhirPaymentReconciliationDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirPaymentReconciliationDetailList }
procedure TFhirPaymentReconciliationDetailList.AddItem(value: TFhirPaymentReconciliationDetail);
begin
  assert(value.ClassName = 'TFhirPaymentReconciliationDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPaymentReconciliationDetail');
  add(value);
end;

function TFhirPaymentReconciliationDetailList.Append: TFhirPaymentReconciliationDetail;
begin
  result := TFhirPaymentReconciliationDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPaymentReconciliationDetailList.ClearItems;
begin
  Clear;
end;

function TFhirPaymentReconciliationDetailList.GetEnumerator : TFhirPaymentReconciliationDetailListEnumerator;
begin
  result := TFhirPaymentReconciliationDetailListEnumerator.Create(self.link);
end;

function TFhirPaymentReconciliationDetailList.Clone: TFhirPaymentReconciliationDetailList;
begin
  result := TFhirPaymentReconciliationDetailList(inherited Clone);
end;

function TFhirPaymentReconciliationDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPaymentReconciliationDetailList.GetItemN(index: Integer): TFhirPaymentReconciliationDetail;
begin
  result := TFhirPaymentReconciliationDetail(ObjectByIndex[index]);
end;

function TFhirPaymentReconciliationDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirPaymentReconciliationDetail;
end;
function TFhirPaymentReconciliationDetailList.IndexOf(value: TFhirPaymentReconciliationDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPaymentReconciliationDetailList.Insert(index: Integer): TFhirPaymentReconciliationDetail;
begin
  result := TFhirPaymentReconciliationDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPaymentReconciliationDetailList.InsertItem(index: Integer; value: TFhirPaymentReconciliationDetail);
begin
  assert(value is TFhirPaymentReconciliationDetail);
  Inherited Insert(index, value);
end;

function TFhirPaymentReconciliationDetailList.Item(index: Integer): TFhirPaymentReconciliationDetail;
begin
  result := TFhirPaymentReconciliationDetail(ObjectByIndex[index]);
end;

function TFhirPaymentReconciliationDetailList.Link: TFhirPaymentReconciliationDetailList;
begin
  result := TFhirPaymentReconciliationDetailList(inherited Link);
end;

procedure TFhirPaymentReconciliationDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPaymentReconciliationDetailList.SetItemByIndex(index: Integer; value: TFhirPaymentReconciliationDetail);
begin
  assert(value is TFhirPaymentReconciliationDetail);
  FhirPaymentReconciliationDetails[index] := value;
end;

procedure TFhirPaymentReconciliationDetailList.SetItemN(index: Integer; value: TFhirPaymentReconciliationDetail);
begin
  assert(value is TFhirPaymentReconciliationDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirPaymentReconciliationNote }

constructor TFhirPaymentReconciliationNote.Create;
begin
  inherited;
end;

destructor TFhirPaymentReconciliationNote.Destroy;
begin
  FType_.free;
  FText.free;
  inherited;
end;

procedure TFhirPaymentReconciliationNote.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirPaymentReconciliationNote(oSource).type_.Clone;
  textElement := TFhirPaymentReconciliationNote(oSource).textElement.Clone;
end;

procedure TFhirPaymentReconciliationNote.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
end;

procedure TFhirPaymentReconciliationNote.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', false, TFhirCoding, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));{2}
end;

function TFhirPaymentReconciliationNote.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPaymentReconciliationNote.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPaymentReconciliationNote.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCoding.create(){4b}
  else if (propName = 'text') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPaymentReconciliationNote.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'Coding'
  else if (propName = 'text') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPaymentReconciliationNote.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'text') then TextElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPaymentReconciliationNote.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCoding{4}
  else if (propName = 'text') then TextElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPaymentReconciliationNote.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPaymentReconciliationNote.fhirType : string;
begin
  result := 'note';
end;

function TFhirPaymentReconciliationNote.Link : TFhirPaymentReconciliationNote;
begin
  result := TFhirPaymentReconciliationNote(inherited Link);
end;

function TFhirPaymentReconciliationNote.Clone : TFhirPaymentReconciliationNote;
begin
  result := TFhirPaymentReconciliationNote(inherited Clone);
end;

function TFhirPaymentReconciliationNote.equals(other : TObject) : boolean;
var
  o : TFhirPaymentReconciliationNote;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPaymentReconciliationNote)) then
    result := false
  else
  begin
    o := TFhirPaymentReconciliationNote(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(textElement, o.textElement, true);
  end;
end;

function TFhirPaymentReconciliationNote.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FText);
end;

procedure TFhirPaymentReconciliationNote.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('text');
end;

{ TFhirPaymentReconciliationNote }

Procedure TFhirPaymentReconciliationNote.SetType_(value : TFhirCoding);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirPaymentReconciliationNote.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

Function TFhirPaymentReconciliationNote.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

Procedure TFhirPaymentReconciliationNote.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

function TFhirPaymentReconciliationNote.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FText.sizeInBytes);
end;

{ TFhirPaymentReconciliationNoteListEnumerator }

Constructor TFhirPaymentReconciliationNoteListEnumerator.Create(list : TFhirPaymentReconciliationNoteList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPaymentReconciliationNoteListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPaymentReconciliationNoteListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPaymentReconciliationNoteListEnumerator.GetCurrent : TFhirPaymentReconciliationNote;
begin
  Result := FList[FIndex];
end;

function TFhirPaymentReconciliationNoteListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirPaymentReconciliationNoteList }
procedure TFhirPaymentReconciliationNoteList.AddItem(value: TFhirPaymentReconciliationNote);
begin
  assert(value.ClassName = 'TFhirPaymentReconciliationNote', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPaymentReconciliationNote');
  add(value);
end;

function TFhirPaymentReconciliationNoteList.Append: TFhirPaymentReconciliationNote;
begin
  result := TFhirPaymentReconciliationNote.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPaymentReconciliationNoteList.ClearItems;
begin
  Clear;
end;

function TFhirPaymentReconciliationNoteList.GetEnumerator : TFhirPaymentReconciliationNoteListEnumerator;
begin
  result := TFhirPaymentReconciliationNoteListEnumerator.Create(self.link);
end;

function TFhirPaymentReconciliationNoteList.Clone: TFhirPaymentReconciliationNoteList;
begin
  result := TFhirPaymentReconciliationNoteList(inherited Clone);
end;

function TFhirPaymentReconciliationNoteList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPaymentReconciliationNoteList.GetItemN(index: Integer): TFhirPaymentReconciliationNote;
begin
  result := TFhirPaymentReconciliationNote(ObjectByIndex[index]);
end;

function TFhirPaymentReconciliationNoteList.ItemClass: TFslObjectClass;
begin
  result := TFhirPaymentReconciliationNote;
end;
function TFhirPaymentReconciliationNoteList.IndexOf(value: TFhirPaymentReconciliationNote): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPaymentReconciliationNoteList.Insert(index: Integer): TFhirPaymentReconciliationNote;
begin
  result := TFhirPaymentReconciliationNote.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPaymentReconciliationNoteList.InsertItem(index: Integer; value: TFhirPaymentReconciliationNote);
begin
  assert(value is TFhirPaymentReconciliationNote);
  Inherited Insert(index, value);
end;

function TFhirPaymentReconciliationNoteList.Item(index: Integer): TFhirPaymentReconciliationNote;
begin
  result := TFhirPaymentReconciliationNote(ObjectByIndex[index]);
end;

function TFhirPaymentReconciliationNoteList.Link: TFhirPaymentReconciliationNoteList;
begin
  result := TFhirPaymentReconciliationNoteList(inherited Link);
end;

procedure TFhirPaymentReconciliationNoteList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPaymentReconciliationNoteList.SetItemByIndex(index: Integer; value: TFhirPaymentReconciliationNote);
begin
  assert(value is TFhirPaymentReconciliationNote);
  FhirPaymentReconciliationNotes[index] := value;
end;

procedure TFhirPaymentReconciliationNoteList.SetItemN(index: Integer; value: TFhirPaymentReconciliationNote);
begin
  assert(value is TFhirPaymentReconciliationNote);
  ObjectByIndex[index] := value;
end;

{ TFhirPaymentReconciliation }

constructor TFhirPaymentReconciliation.Create;
begin
  inherited;
end;

destructor TFhirPaymentReconciliation.Destroy;
begin
  FIdentifierList.Free;
  FRequest.free;
  FOutcome.free;
  FDisposition.free;
  FRuleset.free;
  FOriginalRuleset.free;
  FCreated.free;
  FPeriod.free;
  FOrganization.free;
  FRequestProvider.free;
  FRequestOrganization.free;
  FDetailList.Free;
  FForm.free;
  FTotal.free;
  FNoteList.Free;
  inherited;
end;

function TFhirPaymentReconciliation.GetResourceType : TFhirResourceType;
begin
  result := frtPaymentReconciliation;
end;

procedure TFhirPaymentReconciliation.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPaymentReconciliation(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirPaymentReconciliation(oSource).FIdentifierList);
  end;
  request := TFhirPaymentReconciliation(oSource).request.Clone;
  FOutcome := TFhirPaymentReconciliation(oSource).FOutcome.Link;
  dispositionElement := TFhirPaymentReconciliation(oSource).dispositionElement.Clone;
  ruleset := TFhirPaymentReconciliation(oSource).ruleset.Clone;
  originalRuleset := TFhirPaymentReconciliation(oSource).originalRuleset.Clone;
  createdElement := TFhirPaymentReconciliation(oSource).createdElement.Clone;
  period := TFhirPaymentReconciliation(oSource).period.Clone;
  organization := TFhirPaymentReconciliation(oSource).organization.Clone;
  requestProvider := TFhirPaymentReconciliation(oSource).requestProvider.Clone;
  requestOrganization := TFhirPaymentReconciliation(oSource).requestOrganization.Clone;
  if (TFhirPaymentReconciliation(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirPaymentReconciliationDetailList.Create;
    FDetailList.Assign(TFhirPaymentReconciliation(oSource).FDetailList);
  end;
  form := TFhirPaymentReconciliation(oSource).form.Clone;
  total := TFhirPaymentReconciliation(oSource).total.Clone;
  if (TFhirPaymentReconciliation(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirPaymentReconciliationNoteList.Create;
    FNoteList.Assign(TFhirPaymentReconciliation(oSource).FNoteList);
  end;
end;

procedure TFhirPaymentReconciliation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'disposition') Then
     list.add(self.link, 'disposition', FDisposition.Link);
  if (child_name = 'ruleset') Then
     list.add(self.link, 'ruleset', FRuleset.Link);
  if (child_name = 'originalRuleset') Then
     list.add(self.link, 'originalRuleset', FOriginalRuleset.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'organization') Then
     list.add(self.link, 'organization', FOrganization.Link);
  if (child_name = 'requestProvider') Then
     list.add(self.link, 'requestProvider', FRequestProvider.Link);
  if (child_name = 'requestOrganization') Then
     list.add(self.link, 'requestOrganization', FRequestOrganization.Link);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
  if (child_name = 'form') Then
     list.add(self.link, 'form', FForm.Link);
  if (child_name = 'total') Then
     list.add(self.link, 'total', FTotal.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirPaymentReconciliation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'request', 'Reference(ProcessRequest)', false, TFhirReference{TFhirProcessRequest}, FRequest.Link));{2}
  oList.add(TFHIRProperty.create(self, 'outcome', 'code', false, TFHIREnum, FOutcome.Link));{1}
  oList.add(TFHIRProperty.create(self, 'disposition', 'string', false, TFhirString, FDisposition.Link));{2}
  oList.add(TFHIRProperty.create(self, 'ruleset', 'Coding', false, TFhirCoding, FRuleset.Link));{2}
  oList.add(TFHIRProperty.create(self, 'originalRuleset', 'Coding', false, TFhirCoding, FOriginalRuleset.Link));{2}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));{2}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'organization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FOrganization.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requestProvider', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FRequestProvider.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requestOrganization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FRequestOrganization.Link));{2}
  oList.add(TFHIRProperty.create(self, 'detail', '', true, TFhirPaymentReconciliationDetail, FDetailList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'form', 'Coding', false, TFhirCoding, FForm.Link));{2}
  oList.add(TFHIRProperty.create(self, 'total', 'Quantity', false, TFhirQuantity, FTotal.Link));{2}
  oList.add(TFHIRProperty.create(self, 'note', '', true, TFhirPaymentReconciliationNote, FNoteList.Link)){3};
end;

function TFhirPaymentReconciliation.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirReference{TFhirProcessRequest}{4b};
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    OutcomeElement := asEnum(SYSTEMS_TFhirRemittanceOutcomeEnum, CODES_TFhirRemittanceOutcomeEnum, propValue);
    result := propValue
  end
  else if (propName = 'disposition') then
  begin
    DispositionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'ruleset') then
  begin
    Ruleset := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'originalRuleset') then
  begin
    OriginalRuleset := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'organization') then
  begin
    Organization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'requestProvider') then
  begin
    RequestProvider := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'requestOrganization') then
  begin
    RequestOrganization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirPaymentReconciliationDetail){2a};
    result := propValue;
  end
  else if (propName = 'form') then
  begin
    Form := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'total') then
  begin
    Total := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirPaymentReconciliationNote){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirPaymentReconciliation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirPaymentReconciliationDetail){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirPaymentReconciliationNote){2a}
  else inherited;
end;

function TFhirPaymentReconciliation.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'request') then result := TFhirReference{TFhirProcessRequest}.create(){4b}
  else if (propName = 'disposition') then result := TFhirString.create() {5b}
  else if (propName = 'ruleset') then result := TFhirCoding.create(){4b}
  else if (propName = 'originalRuleset') then result := TFhirCoding.create(){4b}
  else if (propName = 'created') then result := TFhirDateTime.create() {5b}
  else if (propName = 'period') then result := TFhirPeriod.create(){4b}
  else if (propName = 'organization') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'requestProvider') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'requestOrganization') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'detail') then result := DetailList.new(){2}
  else if (propName = 'form') then result := TFhirCoding.create(){4b}
  else if (propName = 'total') then result := TFhirQuantity.create(){4b}
  else if (propName = 'note') then result := NoteList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPaymentReconciliation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'outcome') then result := 'code'
  else if (propName = 'disposition') then result := 'string'
  else if (propName = 'ruleset') then result := 'Coding'
  else if (propName = 'originalRuleset') then result := 'Coding'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'organization') then result := 'Reference'
  else if (propName = 'requestProvider') then result := 'Reference'
  else if (propName = 'requestOrganization') then result := 'Reference'
  else if (propName = 'detail') then result := ''
  else if (propName = 'form') then result := 'Coding'
  else if (propName = 'total') then result := 'Quantity'
  else if (propName = 'note') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPaymentReconciliation.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'disposition') then DispositionElement := nil
  else if (propName = 'ruleset') then RulesetElement := nil
  else if (propName = 'originalRuleset') then OriginalRulesetElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'organization') then OrganizationElement := nil
  else if (propName = 'requestProvider') then RequestProviderElement := nil
  else if (propName = 'requestOrganization') then RequestOrganizationElement := nil
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value) {2}
  else if (propName = 'form') then FormElement := nil
  else if (propName = 'total') then TotalElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPaymentReconciliation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'request') then RequestElement := new as TFhirReference{TFhirProcessRequest}{4}
  else if (propName = 'outcome') then OutcomeElement := asEnum(SYSTEMS_TFhirRemittanceOutcomeEnum, CODES_TFhirRemittanceOutcomeEnum, new){4}
  else if (propName = 'disposition') then DispositionElement := asString(new){5b}
  else if (propName = 'ruleset') then RulesetElement := new as TFhirCoding{4}
  else if (propName = 'originalRuleset') then OriginalRulesetElement := new as TFhirCoding{4}
  else if (propName = 'created') then CreatedElement := asDateTime(new){5b}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else if (propName = 'organization') then OrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'requestProvider') then RequestProviderElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'requestOrganization') then RequestOrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new) {2}
  else if (propName = 'form') then FormElement := new as TFhirCoding{4}
  else if (propName = 'total') then TotalElement := new as TFhirQuantity{4}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPaymentReconciliation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'detail') then DetailList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPaymentReconciliation.fhirType : string;
begin
  result := 'PaymentReconciliation';
end;

function TFhirPaymentReconciliation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FRequest) and isEmptyProp(FOutcome) and isEmptyProp(FDisposition) and isEmptyProp(FRuleset) and isEmptyProp(FOriginalRuleset) and isEmptyProp(FCreated) and isEmptyProp(FPeriod) and isEmptyProp(FOrganization) and isEmptyProp(FRequestProvider) and isEmptyProp(FRequestOrganization) and isEmptyProp(FdetailList) and isEmptyProp(FForm) and isEmptyProp(FTotal) and isEmptyProp(FnoteList);
end;

function TFhirPaymentReconciliation.equals(other : TObject) : boolean;
var
  o : TFhirPaymentReconciliation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPaymentReconciliation)) then
    result := false
  else
  begin
    o := TFhirPaymentReconciliation(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(requestElement, o.requestElement, true) and
      compareDeep(outcomeElement, o.outcomeElement, true) and compareDeep(dispositionElement, o.dispositionElement, true) and
      compareDeep(rulesetElement, o.rulesetElement, true) and compareDeep(originalRulesetElement, o.originalRulesetElement, true) and
      compareDeep(createdElement, o.createdElement, true) and compareDeep(periodElement, o.periodElement, true) and
      compareDeep(organizationElement, o.organizationElement, true) and compareDeep(requestProviderElement, o.requestProviderElement, true) and
      compareDeep(requestOrganizationElement, o.requestOrganizationElement, true) and
      compareDeep(detailList, o.detailList, true) and compareDeep(formElement, o.formElement, true) and
      compareDeep(totalElement, o.totalElement, true) and compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirPaymentReconciliation.Link : TFhirPaymentReconciliation;
begin
  result := TFhirPaymentReconciliation(inherited Link);
end;

function TFhirPaymentReconciliation.Clone : TFhirPaymentReconciliation;
begin
  result := TFhirPaymentReconciliation(inherited Clone);
end;

procedure TFhirPaymentReconciliation.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('request');
  fields.add('outcome');
  fields.add('disposition');
  fields.add('ruleset');
  fields.add('originalRuleset');
  fields.add('created');
  fields.add('period');
  fields.add('organization');
  fields.add('requestProvider');
  fields.add('requestOrganization');
  fields.add('detail');
  fields.add('form');
  fields.add('total');
  fields.add('note');
end;

{ TFhirPaymentReconciliation }

Function TFhirPaymentReconciliation.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirPaymentReconciliation.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirPaymentReconciliation.SetRequest(value : TFhirReference{TFhirProcessRequest});
begin
  FRequest.free;
  FRequest := value;
end;

Procedure TFhirPaymentReconciliation.SetOutcome(value : TFhirEnum);
begin
  FOutcome.free;
  FOutcome := value;
end;

Function TFhirPaymentReconciliation.GetOutcomeST : TFhirRemittanceOutcomeEnum;
begin
  if FOutcome = nil then
    result := TFhirRemittanceOutcomeEnum(0)
  else
    result := TFhirRemittanceOutcomeEnum(StringArrayIndexOfSensitive(CODES_TFhirRemittanceOutcomeEnum, FOutcome.value));
end;

Procedure TFhirPaymentReconciliation.SetOutcomeST(value : TFhirRemittanceOutcomeEnum);
begin
  if ord(value) = 0 then
    OutcomeElement := nil
  else
    OutcomeElement := TFhirEnum.create(SYSTEMS_TFhirRemittanceOutcomeEnum[value], CODES_TFhirRemittanceOutcomeEnum[value]);
end;

Procedure TFhirPaymentReconciliation.SetDisposition(value : TFhirString);
begin
  FDisposition.free;
  FDisposition := value;
end;

Function TFhirPaymentReconciliation.GetDispositionST : String;
begin
  if FDisposition = nil then
    result := ''
  else
    result := FDisposition.value;
end;

Procedure TFhirPaymentReconciliation.SetDispositionST(value : String);
begin
  if value <> '' then
  begin
    if FDisposition = nil then
      FDisposition := TFhirString.create;
    FDisposition.value := value
  end
  else if FDisposition <> nil then
    FDisposition.value := '';
end;

Procedure TFhirPaymentReconciliation.SetRuleset(value : TFhirCoding);
begin
  FRuleset.free;
  FRuleset := value;
end;

Procedure TFhirPaymentReconciliation.SetOriginalRuleset(value : TFhirCoding);
begin
  FOriginalRuleset.free;
  FOriginalRuleset := value;
end;

Procedure TFhirPaymentReconciliation.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

Function TFhirPaymentReconciliation.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

Procedure TFhirPaymentReconciliation.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

Procedure TFhirPaymentReconciliation.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Procedure TFhirPaymentReconciliation.SetOrganization(value : TFhirReference{TFhirOrganization});
begin
  FOrganization.free;
  FOrganization := value;
end;

Procedure TFhirPaymentReconciliation.SetRequestProvider(value : TFhirReference{TFhirPractitioner});
begin
  FRequestProvider.free;
  FRequestProvider := value;
end;

Procedure TFhirPaymentReconciliation.SetRequestOrganization(value : TFhirReference{TFhirOrganization});
begin
  FRequestOrganization.free;
  FRequestOrganization := value;
end;

Function TFhirPaymentReconciliation.GetDetailList : TFhirPaymentReconciliationDetailList;
begin
  if FDetailList = nil then
    FDetailList := TFhirPaymentReconciliationDetailList.Create;
  result := FDetailList;
end;

Function TFhirPaymentReconciliation.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

Procedure TFhirPaymentReconciliation.SetForm(value : TFhirCoding);
begin
  FForm.free;
  FForm := value;
end;

Procedure TFhirPaymentReconciliation.SetTotal(value : TFhirQuantity);
begin
  FTotal.free;
  FTotal := value;
end;

Function TFhirPaymentReconciliation.GetNoteList : TFhirPaymentReconciliationNoteList;
begin
  if FNoteList = nil then
    FNoteList := TFhirPaymentReconciliationNoteList.Create;
  result := FNoteList;
end;

Function TFhirPaymentReconciliation.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirPaymentReconciliation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FRequest.sizeInBytes);
  inc(result, FOutcome.sizeInBytes);
  inc(result, FDisposition.sizeInBytes);
  inc(result, FRuleset.sizeInBytes);
  inc(result, FOriginalRuleset.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FOrganization.sizeInBytes);
  inc(result, FRequestProvider.sizeInBytes);
  inc(result, FRequestOrganization.sizeInBytes);
  inc(result, FdetailList.sizeInBytes);
  inc(result, FForm.sizeInBytes);
  inc(result, FTotal.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
end;

{ TFhirPaymentReconciliationListEnumerator }

Constructor TFhirPaymentReconciliationListEnumerator.Create(list : TFhirPaymentReconciliationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPaymentReconciliationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPaymentReconciliationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPaymentReconciliationListEnumerator.GetCurrent : TFhirPaymentReconciliation;
begin
  Result := FList[FIndex];
end;

function TFhirPaymentReconciliationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirPaymentReconciliationList }
procedure TFhirPaymentReconciliationList.AddItem(value: TFhirPaymentReconciliation);
begin
  assert(value.ClassName = 'TFhirPaymentReconciliation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPaymentReconciliation');
  add(value);
end;

function TFhirPaymentReconciliationList.Append: TFhirPaymentReconciliation;
begin
  result := TFhirPaymentReconciliation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPaymentReconciliationList.ClearItems;
begin
  Clear;
end;

function TFhirPaymentReconciliationList.GetEnumerator : TFhirPaymentReconciliationListEnumerator;
begin
  result := TFhirPaymentReconciliationListEnumerator.Create(self.link);
end;

function TFhirPaymentReconciliationList.Clone: TFhirPaymentReconciliationList;
begin
  result := TFhirPaymentReconciliationList(inherited Clone);
end;

function TFhirPaymentReconciliationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPaymentReconciliationList.GetItemN(index: Integer): TFhirPaymentReconciliation;
begin
  result := TFhirPaymentReconciliation(ObjectByIndex[index]);
end;

function TFhirPaymentReconciliationList.ItemClass: TFslObjectClass;
begin
  result := TFhirPaymentReconciliation;
end;
function TFhirPaymentReconciliationList.IndexOf(value: TFhirPaymentReconciliation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPaymentReconciliationList.Insert(index: Integer): TFhirPaymentReconciliation;
begin
  result := TFhirPaymentReconciliation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPaymentReconciliationList.InsertItem(index: Integer; value: TFhirPaymentReconciliation);
begin
  assert(value is TFhirPaymentReconciliation);
  Inherited Insert(index, value);
end;

function TFhirPaymentReconciliationList.Item(index: Integer): TFhirPaymentReconciliation;
begin
  result := TFhirPaymentReconciliation(ObjectByIndex[index]);
end;

function TFhirPaymentReconciliationList.Link: TFhirPaymentReconciliationList;
begin
  result := TFhirPaymentReconciliationList(inherited Link);
end;

procedure TFhirPaymentReconciliationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPaymentReconciliationList.SetItemByIndex(index: Integer; value: TFhirPaymentReconciliation);
begin
  assert(value is TFhirPaymentReconciliation);
  FhirPaymentReconciliations[index] := value;
end;

procedure TFhirPaymentReconciliationList.SetItemN(index: Integer; value: TFhirPaymentReconciliation);
begin
  assert(value is TFhirPaymentReconciliation);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PAYMENTRECONCILIATION}

{$IFDEF FHIR_PROCESSREQUEST}

{ TFhirProcessRequestItem }

constructor TFhirProcessRequestItem.Create;
begin
  inherited;
end;

destructor TFhirProcessRequestItem.Destroy;
begin
  FSequenceLinkId.free;
  inherited;
end;

procedure TFhirProcessRequestItem.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceLinkIdElement := TFhirProcessRequestItem(oSource).sequenceLinkIdElement.Clone;
end;

procedure TFhirProcessRequestItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequenceLinkId') Then
     list.add(self.link, 'sequenceLinkId', FSequenceLinkId.Link);
end;

procedure TFhirProcessRequestItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequenceLinkId', 'integer', false, TFhirInteger, FSequenceLinkId.Link));{2}
end;

function TFhirProcessRequestItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequenceLinkId') then
  begin
    SequenceLinkIdElement := asInteger(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirProcessRequestItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirProcessRequestItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequenceLinkId') then result := TFhirInteger.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirProcessRequestItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequenceLinkId') then result := 'integer'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirProcessRequestItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequenceLinkId') then SequenceLinkIdElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirProcessRequestItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequenceLinkId') then SequenceLinkIdElement := asInteger(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirProcessRequestItem.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirProcessRequestItem.fhirType : string;
begin
  result := 'item';
end;

function TFhirProcessRequestItem.Link : TFhirProcessRequestItem;
begin
  result := TFhirProcessRequestItem(inherited Link);
end;

function TFhirProcessRequestItem.Clone : TFhirProcessRequestItem;
begin
  result := TFhirProcessRequestItem(inherited Clone);
end;

function TFhirProcessRequestItem.equals(other : TObject) : boolean;
var
  o : TFhirProcessRequestItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirProcessRequestItem)) then
    result := false
  else
  begin
    o := TFhirProcessRequestItem(other);
    result := compareDeep(sequenceLinkIdElement, o.sequenceLinkIdElement, true);
  end;
end;

function TFhirProcessRequestItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequenceLinkId);
end;

procedure TFhirProcessRequestItem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequenceLinkId');
end;

{ TFhirProcessRequestItem }

Procedure TFhirProcessRequestItem.SetSequenceLinkId(value : TFhirInteger);
begin
  FSequenceLinkId.free;
  FSequenceLinkId := value;
end;

Function TFhirProcessRequestItem.GetSequenceLinkIdST : String;
begin
  if FSequenceLinkId = nil then
    result := ''
  else
    result := FSequenceLinkId.value;
end;

Procedure TFhirProcessRequestItem.SetSequenceLinkIdST(value : String);
begin
  if value <> '' then
  begin
    if FSequenceLinkId = nil then
      FSequenceLinkId := TFhirInteger.create;
    FSequenceLinkId.value := value
  end
  else if FSequenceLinkId <> nil then
    FSequenceLinkId.value := '';
end;

function TFhirProcessRequestItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequenceLinkId.sizeInBytes);
end;

{ TFhirProcessRequestItemListEnumerator }

Constructor TFhirProcessRequestItemListEnumerator.Create(list : TFhirProcessRequestItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirProcessRequestItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProcessRequestItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirProcessRequestItemListEnumerator.GetCurrent : TFhirProcessRequestItem;
begin
  Result := FList[FIndex];
end;

function TFhirProcessRequestItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirProcessRequestItemList }
procedure TFhirProcessRequestItemList.AddItem(value: TFhirProcessRequestItem);
begin
  assert(value.ClassName = 'TFhirProcessRequestItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProcessRequestItem');
  add(value);
end;

function TFhirProcessRequestItemList.Append: TFhirProcessRequestItem;
begin
  result := TFhirProcessRequestItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcessRequestItemList.ClearItems;
begin
  Clear;
end;

function TFhirProcessRequestItemList.GetEnumerator : TFhirProcessRequestItemListEnumerator;
begin
  result := TFhirProcessRequestItemListEnumerator.Create(self.link);
end;

function TFhirProcessRequestItemList.Clone: TFhirProcessRequestItemList;
begin
  result := TFhirProcessRequestItemList(inherited Clone);
end;

function TFhirProcessRequestItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProcessRequestItemList.GetItemN(index: Integer): TFhirProcessRequestItem;
begin
  result := TFhirProcessRequestItem(ObjectByIndex[index]);
end;

function TFhirProcessRequestItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirProcessRequestItem;
end;
function TFhirProcessRequestItemList.IndexOf(value: TFhirProcessRequestItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirProcessRequestItemList.Insert(index: Integer): TFhirProcessRequestItem;
begin
  result := TFhirProcessRequestItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcessRequestItemList.InsertItem(index: Integer; value: TFhirProcessRequestItem);
begin
  assert(value is TFhirProcessRequestItem);
  Inherited Insert(index, value);
end;

function TFhirProcessRequestItemList.Item(index: Integer): TFhirProcessRequestItem;
begin
  result := TFhirProcessRequestItem(ObjectByIndex[index]);
end;

function TFhirProcessRequestItemList.Link: TFhirProcessRequestItemList;
begin
  result := TFhirProcessRequestItemList(inherited Link);
end;

procedure TFhirProcessRequestItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProcessRequestItemList.SetItemByIndex(index: Integer; value: TFhirProcessRequestItem);
begin
  assert(value is TFhirProcessRequestItem);
  FhirProcessRequestItems[index] := value;
end;

procedure TFhirProcessRequestItemList.SetItemN(index: Integer; value: TFhirProcessRequestItem);
begin
  assert(value is TFhirProcessRequestItem);
  ObjectByIndex[index] := value;
end;

{ TFhirProcessRequest }

constructor TFhirProcessRequest.Create;
begin
  inherited;
end;

destructor TFhirProcessRequest.Destroy;
begin
  FAction.free;
  FIdentifierList.Free;
  FRuleset.free;
  FOriginalRuleset.free;
  FCreated.free;
  FTarget.free;
  FProvider.free;
  FOrganization.free;
  FRequest.free;
  FResponse.free;
  FNullify.free;
  FReference.free;
  FItemList.Free;
  FIncludeList.Free;
  FExcludeList.Free;
  FPeriod.free;
  inherited;
end;

function TFhirProcessRequest.GetResourceType : TFhirResourceType;
begin
  result := frtProcessRequest;
end;

procedure TFhirProcessRequest.Assign(oSource : TFslObject);
begin
  inherited;
  FAction := TFhirProcessRequest(oSource).FAction.Link;
  if (TFhirProcessRequest(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirProcessRequest(oSource).FIdentifierList);
  end;
  ruleset := TFhirProcessRequest(oSource).ruleset.Clone;
  originalRuleset := TFhirProcessRequest(oSource).originalRuleset.Clone;
  createdElement := TFhirProcessRequest(oSource).createdElement.Clone;
  target := TFhirProcessRequest(oSource).target.Clone;
  provider := TFhirProcessRequest(oSource).provider.Clone;
  organization := TFhirProcessRequest(oSource).organization.Clone;
  request := TFhirProcessRequest(oSource).request.Clone;
  response := TFhirProcessRequest(oSource).response.Clone;
  nullifyElement := TFhirProcessRequest(oSource).nullifyElement.Clone;
  referenceElement := TFhirProcessRequest(oSource).referenceElement.Clone;
  if (TFhirProcessRequest(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirProcessRequestItemList.Create;
    FItemList.Assign(TFhirProcessRequest(oSource).FItemList);
  end;
  if (TFhirProcessRequest(oSource).FIncludeList = nil) then
  begin
    FIncludeList.free;
    FIncludeList := nil;
  end
  else
  begin
    if FIncludeList = nil then
      FIncludeList := TFhirStringList.Create;
    FIncludeList.Assign(TFhirProcessRequest(oSource).FIncludeList);
  end;
  if (TFhirProcessRequest(oSource).FExcludeList = nil) then
  begin
    FExcludeList.free;
    FExcludeList := nil;
  end
  else
  begin
    if FExcludeList = nil then
      FExcludeList := TFhirStringList.Create;
    FExcludeList.Assign(TFhirProcessRequest(oSource).FExcludeList);
  end;
  period := TFhirProcessRequest(oSource).period.Clone;
end;

procedure TFhirProcessRequest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'action') Then
     list.add(self.link, 'action', FAction.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'ruleset') Then
     list.add(self.link, 'ruleset', FRuleset.Link);
  if (child_name = 'originalRuleset') Then
     list.add(self.link, 'originalRuleset', FOriginalRuleset.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'target') Then
     list.add(self.link, 'target', FTarget.Link);
  if (child_name = 'provider') Then
     list.add(self.link, 'provider', FProvider.Link);
  if (child_name = 'organization') Then
     list.add(self.link, 'organization', FOrganization.Link);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'response') Then
     list.add(self.link, 'response', FResponse.Link);
  if (child_name = 'nullify') Then
     list.add(self.link, 'nullify', FNullify.Link);
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
  if (child_name = 'include') Then
    list.addAll(self, 'include', FIncludeList);
  if (child_name = 'exclude') Then
    list.addAll(self, 'exclude', FExcludeList);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirProcessRequest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'action', 'code', false, TFHIREnum, FAction.Link));{1}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'ruleset', 'Coding', false, TFhirCoding, FRuleset.Link));{2}
  oList.add(TFHIRProperty.create(self, 'originalRuleset', 'Coding', false, TFhirCoding, FOriginalRuleset.Link));{2}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));{2}
  oList.add(TFHIRProperty.create(self, 'target', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FTarget.Link));{2}
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FProvider.Link));{2}
  oList.add(TFHIRProperty.create(self, 'organization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FOrganization.Link));{2}
  oList.add(TFHIRProperty.create(self, 'request', 'Reference(Any)', false, TFhirReference{TFhirReference}, FRequest.Link));{2}
  oList.add(TFHIRProperty.create(self, 'response', 'Reference(Any)', false, TFhirReference{TFhirReference}, FResponse.Link));{2}
  oList.add(TFHIRProperty.create(self, 'nullify', 'boolean', false, TFhirBoolean, FNullify.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reference', 'string', false, TFhirString, FReference.Link));{2}
  oList.add(TFHIRProperty.create(self, 'item', '', true, TFhirProcessRequestItem, FItemList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'include', 'string', true, TFhirString, FIncludeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'exclude', 'string', true, TFhirString, FExcludeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
end;

function TFhirProcessRequest.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'action') then
  begin
    ActionElement := asEnum(SYSTEMS_TFhirActionlistEnum, CODES_TFhirActionlistEnum, propValue);
    result := propValue
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'ruleset') then
  begin
    Ruleset := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'originalRuleset') then
  begin
    OriginalRuleset := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'target') then
  begin
    Target := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'provider') then
  begin
    Provider := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'organization') then
  begin
    Organization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'response') then
  begin
    Response := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'nullify') then
  begin
    NullifyElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'reference') then
  begin
    ReferenceElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirProcessRequestItem){2a};
    result := propValue;
  end
  else if (propName = 'include') then
  begin
    IncludeList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'exclude') then
  begin
    ExcludeList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirProcessRequest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirProcessRequestItem){2a}
  else if (propName = 'include') then IncludeList.insertItem(index, asString(propValue)){2}
  else if (propName = 'exclude') then ExcludeList.insertItem(index, asString(propValue)){2}
  else inherited;
end;

function TFhirProcessRequest.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'ruleset') then result := TFhirCoding.create(){4b}
  else if (propName = 'originalRuleset') then result := TFhirCoding.create(){4b}
  else if (propName = 'created') then result := TFhirDateTime.create() {5b}
  else if (propName = 'target') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'provider') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'organization') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'request') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'response') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'nullify') then result := TFhirBoolean.create() {5b}
  else if (propName = 'reference') then result := TFhirString.create() {5b}
  else if (propName = 'item') then result := ItemList.new(){2}
  else if (propName = 'include') then result := IncludeList.new(){2}
  else if (propName = 'exclude') then result := ExcludeList.new(){2}
  else if (propName = 'period') then result := TFhirPeriod.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirProcessRequest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'action') then result := 'code'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'ruleset') then result := 'Coding'
  else if (propName = 'originalRuleset') then result := 'Coding'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'target') then result := 'Reference'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'organization') then result := 'Reference'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'response') then result := 'Reference'
  else if (propName = 'nullify') then result := 'boolean'
  else if (propName = 'reference') then result := 'string'
  else if (propName = 'item') then result := ''
  else if (propName = 'include') then result := 'string'
  else if (propName = 'exclude') then result := 'string'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirProcessRequest.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'action') then ActionElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'ruleset') then RulesetElement := nil
  else if (propName = 'originalRuleset') then OriginalRulesetElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'target') then TargetElement := nil
  else if (propName = 'provider') then ProviderElement := nil
  else if (propName = 'organization') then OrganizationElement := nil
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'response') then ResponseElement := nil
  else if (propName = 'nullify') then NullifyElement := nil
  else if (propName = 'reference') then ReferenceElement := nil
  else if (propName = 'item') then deletePropertyValue('item', ItemList, value) {2}
  else if (propName = 'include') then deletePropertyValue('include', IncludeList, value) {2}
  else if (propName = 'exclude') then deletePropertyValue('exclude', ExcludeList, value) {2}
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirProcessRequest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'action') then ActionElement := asEnum(SYSTEMS_TFhirActionlistEnum, CODES_TFhirActionlistEnum, new){4}
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'ruleset') then RulesetElement := new as TFhirCoding{4}
  else if (propName = 'originalRuleset') then OriginalRulesetElement := new as TFhirCoding{4}
  else if (propName = 'created') then CreatedElement := asDateTime(new){5b}
  else if (propName = 'target') then TargetElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'provider') then ProviderElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'organization') then OrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'request') then RequestElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'response') then ResponseElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'nullify') then NullifyElement := asBoolean(new){5b}
  else if (propName = 'reference') then ReferenceElement := asString(new){5b}
  else if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new) {2}
  else if (propName = 'include') then replacePropertyValue('include', IncludeList, existing, new) {2}
  else if (propName = 'exclude') then replacePropertyValue('exclude', ExcludeList, existing, new) {2}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirProcessRequest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'item') then ItemList.move(source, destination){2a}
  else if (propName = 'include') then IncludeList.move(source, destination){2}
  else if (propName = 'exclude') then ExcludeList.move(source, destination){2}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirProcessRequest.fhirType : string;
begin
  result := 'ProcessRequest';
end;

function TFhirProcessRequest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAction) and isEmptyProp(FidentifierList) and isEmptyProp(FRuleset) and isEmptyProp(FOriginalRuleset) and isEmptyProp(FCreated) and isEmptyProp(FTarget) and isEmptyProp(FProvider) and isEmptyProp(FOrganization) and isEmptyProp(FRequest) and isEmptyProp(FResponse) and isEmptyProp(FNullify) and isEmptyProp(FReference) and isEmptyProp(FitemList) and isEmptyProp(FincludeList) and isEmptyProp(FexcludeList) and isEmptyProp(FPeriod);
end;

function TFhirProcessRequest.equals(other : TObject) : boolean;
var
  o : TFhirProcessRequest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirProcessRequest)) then
    result := false
  else
  begin
    o := TFhirProcessRequest(other);
    result := compareDeep(actionElement, o.actionElement, true) and compareDeep(identifierList, o.identifierList, true) and
      compareDeep(rulesetElement, o.rulesetElement, true) and compareDeep(originalRulesetElement, o.originalRulesetElement, true) and
      compareDeep(createdElement, o.createdElement, true) and compareDeep(targetElement, o.targetElement, true) and
      compareDeep(providerElement, o.providerElement, true) and compareDeep(organizationElement, o.organizationElement, true) and
      compareDeep(requestElement, o.requestElement, true) and compareDeep(responseElement, o.responseElement, true) and
      compareDeep(nullifyElement, o.nullifyElement, true) and compareDeep(referenceElement, o.referenceElement, true) and
      compareDeep(itemList, o.itemList, true) and compareDeep(includeList, o.includeList, true) and
      compareDeep(excludeList, o.excludeList, true) and compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirProcessRequest.Link : TFhirProcessRequest;
begin
  result := TFhirProcessRequest(inherited Link);
end;

function TFhirProcessRequest.Clone : TFhirProcessRequest;
begin
  result := TFhirProcessRequest(inherited Clone);
end;

procedure TFhirProcessRequest.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('action');
  fields.add('identifier');
  fields.add('ruleset');
  fields.add('originalRuleset');
  fields.add('created');
  fields.add('target');
  fields.add('provider');
  fields.add('organization');
  fields.add('request');
  fields.add('response');
  fields.add('nullify');
  fields.add('reference');
  fields.add('item');
  fields.add('include');
  fields.add('exclude');
  fields.add('period');
end;

{ TFhirProcessRequest }

Procedure TFhirProcessRequest.SetAction(value : TFhirEnum);
begin
  FAction.free;
  FAction := value;
end;

Function TFhirProcessRequest.GetActionST : TFhirActionlistEnum;
begin
  if FAction = nil then
    result := TFhirActionlistEnum(0)
  else
    result := TFhirActionlistEnum(StringArrayIndexOfSensitive(CODES_TFhirActionlistEnum, FAction.value));
end;

Procedure TFhirProcessRequest.SetActionST(value : TFhirActionlistEnum);
begin
  if ord(value) = 0 then
    ActionElement := nil
  else
    ActionElement := TFhirEnum.create(SYSTEMS_TFhirActionlistEnum[value], CODES_TFhirActionlistEnum[value]);
end;

Function TFhirProcessRequest.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirProcessRequest.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirProcessRequest.SetRuleset(value : TFhirCoding);
begin
  FRuleset.free;
  FRuleset := value;
end;

Procedure TFhirProcessRequest.SetOriginalRuleset(value : TFhirCoding);
begin
  FOriginalRuleset.free;
  FOriginalRuleset := value;
end;

Procedure TFhirProcessRequest.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

Function TFhirProcessRequest.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

Procedure TFhirProcessRequest.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

Procedure TFhirProcessRequest.SetTarget(value : TFhirReference{TFhirOrganization});
begin
  FTarget.free;
  FTarget := value;
end;

Procedure TFhirProcessRequest.SetProvider(value : TFhirReference{TFhirPractitioner});
begin
  FProvider.free;
  FProvider := value;
end;

Procedure TFhirProcessRequest.SetOrganization(value : TFhirReference{TFhirOrganization});
begin
  FOrganization.free;
  FOrganization := value;
end;

Procedure TFhirProcessRequest.SetRequest(value : TFhirReference{TFhirReference});
begin
  FRequest.free;
  FRequest := value;
end;

Procedure TFhirProcessRequest.SetResponse(value : TFhirReference{TFhirReference});
begin
  FResponse.free;
  FResponse := value;
end;

Procedure TFhirProcessRequest.SetNullify(value : TFhirBoolean);
begin
  FNullify.free;
  FNullify := value;
end;

Function TFhirProcessRequest.GetNullifyST : Boolean;
begin
  if FNullify = nil then
    result := false
  else
    result := FNullify.value;
end;

Procedure TFhirProcessRequest.SetNullifyST(value : Boolean);
begin
  if FNullify = nil then
    FNullify := TFhirBoolean.create;
  FNullify.value := value
end;

Procedure TFhirProcessRequest.SetReference(value : TFhirString);
begin
  FReference.free;
  FReference := value;
end;

Function TFhirProcessRequest.GetReferenceST : String;
begin
  if FReference = nil then
    result := ''
  else
    result := FReference.value;
end;

Procedure TFhirProcessRequest.SetReferenceST(value : String);
begin
  if value <> '' then
  begin
    if FReference = nil then
      FReference := TFhirString.create;
    FReference.value := value
  end
  else if FReference <> nil then
    FReference.value := '';
end;

Function TFhirProcessRequest.GetItemList : TFhirProcessRequestItemList;
begin
  if FItemList = nil then
    FItemList := TFhirProcessRequestItemList.Create;
  result := FItemList;
end;

Function TFhirProcessRequest.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

Function TFhirProcessRequest.GetIncludeList : TFhirStringList;
begin
  if FIncludeList = nil then
    FIncludeList := TFhirStringList.Create;
  result := FIncludeList;
end;

Function TFhirProcessRequest.GetHasIncludeList : boolean;
begin
  result := (FIncludeList <> nil) and (FIncludeList.count > 0);
end;

Function TFhirProcessRequest.GetExcludeList : TFhirStringList;
begin
  if FExcludeList = nil then
    FExcludeList := TFhirStringList.Create;
  result := FExcludeList;
end;

Function TFhirProcessRequest.GetHasExcludeList : boolean;
begin
  result := (FExcludeList <> nil) and (FExcludeList.count > 0);
end;

Procedure TFhirProcessRequest.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

function TFhirProcessRequest.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FAction.sizeInBytes);
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FRuleset.sizeInBytes);
  inc(result, FOriginalRuleset.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FTarget.sizeInBytes);
  inc(result, FProvider.sizeInBytes);
  inc(result, FOrganization.sizeInBytes);
  inc(result, FRequest.sizeInBytes);
  inc(result, FResponse.sizeInBytes);
  inc(result, FNullify.sizeInBytes);
  inc(result, FReference.sizeInBytes);
  inc(result, FitemList.sizeInBytes);
  inc(result, FincludeList.sizeInBytes);
  inc(result, FexcludeList.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
end;

{ TFhirProcessRequestListEnumerator }

Constructor TFhirProcessRequestListEnumerator.Create(list : TFhirProcessRequestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirProcessRequestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProcessRequestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirProcessRequestListEnumerator.GetCurrent : TFhirProcessRequest;
begin
  Result := FList[FIndex];
end;

function TFhirProcessRequestListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirProcessRequestList }
procedure TFhirProcessRequestList.AddItem(value: TFhirProcessRequest);
begin
  assert(value.ClassName = 'TFhirProcessRequest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProcessRequest');
  add(value);
end;

function TFhirProcessRequestList.Append: TFhirProcessRequest;
begin
  result := TFhirProcessRequest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcessRequestList.ClearItems;
begin
  Clear;
end;

function TFhirProcessRequestList.GetEnumerator : TFhirProcessRequestListEnumerator;
begin
  result := TFhirProcessRequestListEnumerator.Create(self.link);
end;

function TFhirProcessRequestList.Clone: TFhirProcessRequestList;
begin
  result := TFhirProcessRequestList(inherited Clone);
end;

function TFhirProcessRequestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProcessRequestList.GetItemN(index: Integer): TFhirProcessRequest;
begin
  result := TFhirProcessRequest(ObjectByIndex[index]);
end;

function TFhirProcessRequestList.ItemClass: TFslObjectClass;
begin
  result := TFhirProcessRequest;
end;
function TFhirProcessRequestList.IndexOf(value: TFhirProcessRequest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirProcessRequestList.Insert(index: Integer): TFhirProcessRequest;
begin
  result := TFhirProcessRequest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcessRequestList.InsertItem(index: Integer; value: TFhirProcessRequest);
begin
  assert(value is TFhirProcessRequest);
  Inherited Insert(index, value);
end;

function TFhirProcessRequestList.Item(index: Integer): TFhirProcessRequest;
begin
  result := TFhirProcessRequest(ObjectByIndex[index]);
end;

function TFhirProcessRequestList.Link: TFhirProcessRequestList;
begin
  result := TFhirProcessRequestList(inherited Link);
end;

procedure TFhirProcessRequestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProcessRequestList.SetItemByIndex(index: Integer; value: TFhirProcessRequest);
begin
  assert(value is TFhirProcessRequest);
  FhirProcessRequests[index] := value;
end;

procedure TFhirProcessRequestList.SetItemN(index: Integer; value: TFhirProcessRequest);
begin
  assert(value is TFhirProcessRequest);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PROCESSREQUEST}

{$IFDEF FHIR_PROCESSRESPONSE}

{ TFhirProcessResponseNotes }

constructor TFhirProcessResponseNotes.Create;
begin
  inherited;
end;

destructor TFhirProcessResponseNotes.Destroy;
begin
  FType_.free;
  FText.free;
  inherited;
end;

procedure TFhirProcessResponseNotes.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirProcessResponseNotes(oSource).type_.Clone;
  textElement := TFhirProcessResponseNotes(oSource).textElement.Clone;
end;

procedure TFhirProcessResponseNotes.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
end;

procedure TFhirProcessResponseNotes.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', false, TFhirCoding, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));{2}
end;

function TFhirProcessResponseNotes.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirProcessResponseNotes.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirProcessResponseNotes.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCoding.create(){4b}
  else if (propName = 'text') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirProcessResponseNotes.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'Coding'
  else if (propName = 'text') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirProcessResponseNotes.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'text') then TextElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirProcessResponseNotes.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCoding{4}
  else if (propName = 'text') then TextElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirProcessResponseNotes.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirProcessResponseNotes.fhirType : string;
begin
  result := 'notes';
end;

function TFhirProcessResponseNotes.Link : TFhirProcessResponseNotes;
begin
  result := TFhirProcessResponseNotes(inherited Link);
end;

function TFhirProcessResponseNotes.Clone : TFhirProcessResponseNotes;
begin
  result := TFhirProcessResponseNotes(inherited Clone);
end;

function TFhirProcessResponseNotes.equals(other : TObject) : boolean;
var
  o : TFhirProcessResponseNotes;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirProcessResponseNotes)) then
    result := false
  else
  begin
    o := TFhirProcessResponseNotes(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(textElement, o.textElement, true);
  end;
end;

function TFhirProcessResponseNotes.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FText);
end;

procedure TFhirProcessResponseNotes.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('text');
end;

{ TFhirProcessResponseNotes }

Procedure TFhirProcessResponseNotes.SetType_(value : TFhirCoding);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirProcessResponseNotes.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

Function TFhirProcessResponseNotes.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

Procedure TFhirProcessResponseNotes.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

function TFhirProcessResponseNotes.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FText.sizeInBytes);
end;

{ TFhirProcessResponseNotesListEnumerator }

Constructor TFhirProcessResponseNotesListEnumerator.Create(list : TFhirProcessResponseNotesList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirProcessResponseNotesListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProcessResponseNotesListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirProcessResponseNotesListEnumerator.GetCurrent : TFhirProcessResponseNotes;
begin
  Result := FList[FIndex];
end;

function TFhirProcessResponseNotesListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirProcessResponseNotesList }
procedure TFhirProcessResponseNotesList.AddItem(value: TFhirProcessResponseNotes);
begin
  assert(value.ClassName = 'TFhirProcessResponseNotes', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProcessResponseNotes');
  add(value);
end;

function TFhirProcessResponseNotesList.Append: TFhirProcessResponseNotes;
begin
  result := TFhirProcessResponseNotes.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcessResponseNotesList.ClearItems;
begin
  Clear;
end;

function TFhirProcessResponseNotesList.GetEnumerator : TFhirProcessResponseNotesListEnumerator;
begin
  result := TFhirProcessResponseNotesListEnumerator.Create(self.link);
end;

function TFhirProcessResponseNotesList.Clone: TFhirProcessResponseNotesList;
begin
  result := TFhirProcessResponseNotesList(inherited Clone);
end;

function TFhirProcessResponseNotesList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProcessResponseNotesList.GetItemN(index: Integer): TFhirProcessResponseNotes;
begin
  result := TFhirProcessResponseNotes(ObjectByIndex[index]);
end;

function TFhirProcessResponseNotesList.ItemClass: TFslObjectClass;
begin
  result := TFhirProcessResponseNotes;
end;
function TFhirProcessResponseNotesList.IndexOf(value: TFhirProcessResponseNotes): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirProcessResponseNotesList.Insert(index: Integer): TFhirProcessResponseNotes;
begin
  result := TFhirProcessResponseNotes.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcessResponseNotesList.InsertItem(index: Integer; value: TFhirProcessResponseNotes);
begin
  assert(value is TFhirProcessResponseNotes);
  Inherited Insert(index, value);
end;

function TFhirProcessResponseNotesList.Item(index: Integer): TFhirProcessResponseNotes;
begin
  result := TFhirProcessResponseNotes(ObjectByIndex[index]);
end;

function TFhirProcessResponseNotesList.Link: TFhirProcessResponseNotesList;
begin
  result := TFhirProcessResponseNotesList(inherited Link);
end;

procedure TFhirProcessResponseNotesList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProcessResponseNotesList.SetItemByIndex(index: Integer; value: TFhirProcessResponseNotes);
begin
  assert(value is TFhirProcessResponseNotes);
  FhirProcessResponseNotes[index] := value;
end;

procedure TFhirProcessResponseNotesList.SetItemN(index: Integer; value: TFhirProcessResponseNotes);
begin
  assert(value is TFhirProcessResponseNotes);
  ObjectByIndex[index] := value;
end;

{ TFhirProcessResponse }

constructor TFhirProcessResponse.Create;
begin
  inherited;
end;

destructor TFhirProcessResponse.Destroy;
begin
  FIdentifierList.Free;
  FRequest.free;
  FOutcome.free;
  FDisposition.free;
  FRuleset.free;
  FOriginalRuleset.free;
  FCreated.free;
  FOrganization.free;
  FRequestProvider.free;
  FRequestOrganization.free;
  FForm.free;
  FNotesList.Free;
  FErrorList.Free;
  inherited;
end;

function TFhirProcessResponse.GetResourceType : TFhirResourceType;
begin
  result := frtProcessResponse;
end;

procedure TFhirProcessResponse.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirProcessResponse(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirProcessResponse(oSource).FIdentifierList);
  end;
  request := TFhirProcessResponse(oSource).request.Clone;
  outcome := TFhirProcessResponse(oSource).outcome.Clone;
  dispositionElement := TFhirProcessResponse(oSource).dispositionElement.Clone;
  ruleset := TFhirProcessResponse(oSource).ruleset.Clone;
  originalRuleset := TFhirProcessResponse(oSource).originalRuleset.Clone;
  createdElement := TFhirProcessResponse(oSource).createdElement.Clone;
  organization := TFhirProcessResponse(oSource).organization.Clone;
  requestProvider := TFhirProcessResponse(oSource).requestProvider.Clone;
  requestOrganization := TFhirProcessResponse(oSource).requestOrganization.Clone;
  form := TFhirProcessResponse(oSource).form.Clone;
  if (TFhirProcessResponse(oSource).FNotesList = nil) then
  begin
    FNotesList.free;
    FNotesList := nil;
  end
  else
  begin
    if FNotesList = nil then
      FNotesList := TFhirProcessResponseNotesList.Create;
    FNotesList.Assign(TFhirProcessResponse(oSource).FNotesList);
  end;
  if (TFhirProcessResponse(oSource).FErrorList = nil) then
  begin
    FErrorList.free;
    FErrorList := nil;
  end
  else
  begin
    if FErrorList = nil then
      FErrorList := TFhirCodingList.Create;
    FErrorList.Assign(TFhirProcessResponse(oSource).FErrorList);
  end;
end;

procedure TFhirProcessResponse.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'disposition') Then
     list.add(self.link, 'disposition', FDisposition.Link);
  if (child_name = 'ruleset') Then
     list.add(self.link, 'ruleset', FRuleset.Link);
  if (child_name = 'originalRuleset') Then
     list.add(self.link, 'originalRuleset', FOriginalRuleset.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'organization') Then
     list.add(self.link, 'organization', FOrganization.Link);
  if (child_name = 'requestProvider') Then
     list.add(self.link, 'requestProvider', FRequestProvider.Link);
  if (child_name = 'requestOrganization') Then
     list.add(self.link, 'requestOrganization', FRequestOrganization.Link);
  if (child_name = 'form') Then
     list.add(self.link, 'form', FForm.Link);
  if (child_name = 'notes') Then
    list.addAll(self, 'notes', FNotesList);
  if (child_name = 'error') Then
    list.addAll(self, 'error', FErrorList);
end;

procedure TFhirProcessResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'request', 'Reference(Any)', false, TFhirReference{TFhirReference}, FRequest.Link));{2}
  oList.add(TFHIRProperty.create(self, 'outcome', 'Coding', false, TFhirCoding, FOutcome.Link));{2}
  oList.add(TFHIRProperty.create(self, 'disposition', 'string', false, TFhirString, FDisposition.Link));{2}
  oList.add(TFHIRProperty.create(self, 'ruleset', 'Coding', false, TFhirCoding, FRuleset.Link));{2}
  oList.add(TFHIRProperty.create(self, 'originalRuleset', 'Coding', false, TFhirCoding, FOriginalRuleset.Link));{2}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));{2}
  oList.add(TFHIRProperty.create(self, 'organization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FOrganization.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requestProvider', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FRequestProvider.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requestOrganization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FRequestOrganization.Link));{2}
  oList.add(TFHIRProperty.create(self, 'form', 'Coding', false, TFhirCoding, FForm.Link));{2}
  oList.add(TFHIRProperty.create(self, 'notes', '', true, TFhirProcessResponseNotes, FNotesList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'error', 'Coding', true, TFhirCoding, FErrorList.Link)){3};
end;

function TFhirProcessResponse.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    Outcome := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'disposition') then
  begin
    DispositionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'ruleset') then
  begin
    Ruleset := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'originalRuleset') then
  begin
    OriginalRuleset := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'organization') then
  begin
    Organization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'requestProvider') then
  begin
    RequestProvider := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'requestOrganization') then
  begin
    RequestOrganization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'form') then
  begin
    Form := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'notes') then
  begin
    NotesList.add(propValue as TFhirProcessResponseNotes){2a};
    result := propValue;
  end
  else if (propName = 'error') then
  begin
    ErrorList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirProcessResponse.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'notes') then NotesList.insertItem(index, propValue as TFhirProcessResponseNotes){2a}
  else if (propName = 'error') then ErrorList.insertItem(index, propValue as TFhirCoding){2a}
  else inherited;
end;

function TFhirProcessResponse.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'request') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'outcome') then result := TFhirCoding.create(){4b}
  else if (propName = 'disposition') then result := TFhirString.create() {5b}
  else if (propName = 'ruleset') then result := TFhirCoding.create(){4b}
  else if (propName = 'originalRuleset') then result := TFhirCoding.create(){4b}
  else if (propName = 'created') then result := TFhirDateTime.create() {5b}
  else if (propName = 'organization') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'requestProvider') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'requestOrganization') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'form') then result := TFhirCoding.create(){4b}
  else if (propName = 'notes') then result := NotesList.new(){2}
  else if (propName = 'error') then result := ErrorList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirProcessResponse.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'outcome') then result := 'Coding'
  else if (propName = 'disposition') then result := 'string'
  else if (propName = 'ruleset') then result := 'Coding'
  else if (propName = 'originalRuleset') then result := 'Coding'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'organization') then result := 'Reference'
  else if (propName = 'requestProvider') then result := 'Reference'
  else if (propName = 'requestOrganization') then result := 'Reference'
  else if (propName = 'form') then result := 'Coding'
  else if (propName = 'notes') then result := ''
  else if (propName = 'error') then result := 'Coding'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirProcessResponse.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'disposition') then DispositionElement := nil
  else if (propName = 'ruleset') then RulesetElement := nil
  else if (propName = 'originalRuleset') then OriginalRulesetElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'organization') then OrganizationElement := nil
  else if (propName = 'requestProvider') then RequestProviderElement := nil
  else if (propName = 'requestOrganization') then RequestOrganizationElement := nil
  else if (propName = 'form') then FormElement := nil
  else if (propName = 'notes') then deletePropertyValue('notes', NotesList, value) {2}
  else if (propName = 'error') then deletePropertyValue('error', ErrorList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirProcessResponse.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'request') then RequestElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'outcome') then OutcomeElement := new as TFhirCoding{4}
  else if (propName = 'disposition') then DispositionElement := asString(new){5b}
  else if (propName = 'ruleset') then RulesetElement := new as TFhirCoding{4}
  else if (propName = 'originalRuleset') then OriginalRulesetElement := new as TFhirCoding{4}
  else if (propName = 'created') then CreatedElement := asDateTime(new){5b}
  else if (propName = 'organization') then OrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'requestProvider') then RequestProviderElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'requestOrganization') then RequestOrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'form') then FormElement := new as TFhirCoding{4}
  else if (propName = 'notes') then replacePropertyValue('notes', NotesList, existing, new) {2}
  else if (propName = 'error') then replacePropertyValue('error', ErrorList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirProcessResponse.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'notes') then NotesList.move(source, destination){2a}
  else if (propName = 'error') then ErrorList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirProcessResponse.fhirType : string;
begin
  result := 'ProcessResponse';
end;

function TFhirProcessResponse.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FRequest) and isEmptyProp(FOutcome) and isEmptyProp(FDisposition) and isEmptyProp(FRuleset) and isEmptyProp(FOriginalRuleset) and isEmptyProp(FCreated) and isEmptyProp(FOrganization) and isEmptyProp(FRequestProvider) and isEmptyProp(FRequestOrganization) and isEmptyProp(FForm) and isEmptyProp(FnotesList) and isEmptyProp(FerrorList);
end;

function TFhirProcessResponse.equals(other : TObject) : boolean;
var
  o : TFhirProcessResponse;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirProcessResponse)) then
    result := false
  else
  begin
    o := TFhirProcessResponse(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(requestElement, o.requestElement, true) and
      compareDeep(outcomeElement, o.outcomeElement, true) and compareDeep(dispositionElement, o.dispositionElement, true) and
      compareDeep(rulesetElement, o.rulesetElement, true) and compareDeep(originalRulesetElement, o.originalRulesetElement, true) and
      compareDeep(createdElement, o.createdElement, true) and compareDeep(organizationElement, o.organizationElement, true) and
      compareDeep(requestProviderElement, o.requestProviderElement, true) and compareDeep(requestOrganizationElement, o.requestOrganizationElement, true) and
      compareDeep(formElement, o.formElement, true) and compareDeep(notesList, o.notesList, true) and
      compareDeep(errorList, o.errorList, true);
  end;
end;

function TFhirProcessResponse.Link : TFhirProcessResponse;
begin
  result := TFhirProcessResponse(inherited Link);
end;

function TFhirProcessResponse.Clone : TFhirProcessResponse;
begin
  result := TFhirProcessResponse(inherited Clone);
end;

procedure TFhirProcessResponse.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('request');
  fields.add('outcome');
  fields.add('disposition');
  fields.add('ruleset');
  fields.add('originalRuleset');
  fields.add('created');
  fields.add('organization');
  fields.add('requestProvider');
  fields.add('requestOrganization');
  fields.add('form');
  fields.add('notes');
  fields.add('error');
end;

{ TFhirProcessResponse }

Function TFhirProcessResponse.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirProcessResponse.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirProcessResponse.SetRequest(value : TFhirReference{TFhirReference});
begin
  FRequest.free;
  FRequest := value;
end;

Procedure TFhirProcessResponse.SetOutcome(value : TFhirCoding);
begin
  FOutcome.free;
  FOutcome := value;
end;

Procedure TFhirProcessResponse.SetDisposition(value : TFhirString);
begin
  FDisposition.free;
  FDisposition := value;
end;

Function TFhirProcessResponse.GetDispositionST : String;
begin
  if FDisposition = nil then
    result := ''
  else
    result := FDisposition.value;
end;

Procedure TFhirProcessResponse.SetDispositionST(value : String);
begin
  if value <> '' then
  begin
    if FDisposition = nil then
      FDisposition := TFhirString.create;
    FDisposition.value := value
  end
  else if FDisposition <> nil then
    FDisposition.value := '';
end;

Procedure TFhirProcessResponse.SetRuleset(value : TFhirCoding);
begin
  FRuleset.free;
  FRuleset := value;
end;

Procedure TFhirProcessResponse.SetOriginalRuleset(value : TFhirCoding);
begin
  FOriginalRuleset.free;
  FOriginalRuleset := value;
end;

Procedure TFhirProcessResponse.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

Function TFhirProcessResponse.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

Procedure TFhirProcessResponse.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

Procedure TFhirProcessResponse.SetOrganization(value : TFhirReference{TFhirOrganization});
begin
  FOrganization.free;
  FOrganization := value;
end;

Procedure TFhirProcessResponse.SetRequestProvider(value : TFhirReference{TFhirPractitioner});
begin
  FRequestProvider.free;
  FRequestProvider := value;
end;

Procedure TFhirProcessResponse.SetRequestOrganization(value : TFhirReference{TFhirOrganization});
begin
  FRequestOrganization.free;
  FRequestOrganization := value;
end;

Procedure TFhirProcessResponse.SetForm(value : TFhirCoding);
begin
  FForm.free;
  FForm := value;
end;

Function TFhirProcessResponse.GetNotesList : TFhirProcessResponseNotesList;
begin
  if FNotesList = nil then
    FNotesList := TFhirProcessResponseNotesList.Create;
  result := FNotesList;
end;

Function TFhirProcessResponse.GetHasNotesList : boolean;
begin
  result := (FNotesList <> nil) and (FNotesList.count > 0);
end;

Function TFhirProcessResponse.GetErrorList : TFhirCodingList;
begin
  if FErrorList = nil then
    FErrorList := TFhirCodingList.Create;
  result := FErrorList;
end;

Function TFhirProcessResponse.GetHasErrorList : boolean;
begin
  result := (FErrorList <> nil) and (FErrorList.count > 0);
end;

function TFhirProcessResponse.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FRequest.sizeInBytes);
  inc(result, FOutcome.sizeInBytes);
  inc(result, FDisposition.sizeInBytes);
  inc(result, FRuleset.sizeInBytes);
  inc(result, FOriginalRuleset.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FOrganization.sizeInBytes);
  inc(result, FRequestProvider.sizeInBytes);
  inc(result, FRequestOrganization.sizeInBytes);
  inc(result, FForm.sizeInBytes);
  inc(result, FnotesList.sizeInBytes);
  inc(result, FerrorList.sizeInBytes);
end;

{ TFhirProcessResponseListEnumerator }

Constructor TFhirProcessResponseListEnumerator.Create(list : TFhirProcessResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirProcessResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProcessResponseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirProcessResponseListEnumerator.GetCurrent : TFhirProcessResponse;
begin
  Result := FList[FIndex];
end;

function TFhirProcessResponseListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirProcessResponseList }
procedure TFhirProcessResponseList.AddItem(value: TFhirProcessResponse);
begin
  assert(value.ClassName = 'TFhirProcessResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProcessResponse');
  add(value);
end;

function TFhirProcessResponseList.Append: TFhirProcessResponse;
begin
  result := TFhirProcessResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcessResponseList.ClearItems;
begin
  Clear;
end;

function TFhirProcessResponseList.GetEnumerator : TFhirProcessResponseListEnumerator;
begin
  result := TFhirProcessResponseListEnumerator.Create(self.link);
end;

function TFhirProcessResponseList.Clone: TFhirProcessResponseList;
begin
  result := TFhirProcessResponseList(inherited Clone);
end;

function TFhirProcessResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProcessResponseList.GetItemN(index: Integer): TFhirProcessResponse;
begin
  result := TFhirProcessResponse(ObjectByIndex[index]);
end;

function TFhirProcessResponseList.ItemClass: TFslObjectClass;
begin
  result := TFhirProcessResponse;
end;
function TFhirProcessResponseList.IndexOf(value: TFhirProcessResponse): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirProcessResponseList.Insert(index: Integer): TFhirProcessResponse;
begin
  result := TFhirProcessResponse.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcessResponseList.InsertItem(index: Integer; value: TFhirProcessResponse);
begin
  assert(value is TFhirProcessResponse);
  Inherited Insert(index, value);
end;

function TFhirProcessResponseList.Item(index: Integer): TFhirProcessResponse;
begin
  result := TFhirProcessResponse(ObjectByIndex[index]);
end;

function TFhirProcessResponseList.Link: TFhirProcessResponseList;
begin
  result := TFhirProcessResponseList(inherited Link);
end;

procedure TFhirProcessResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProcessResponseList.SetItemByIndex(index: Integer; value: TFhirProcessResponse);
begin
  assert(value is TFhirProcessResponse);
  FhirProcessResponses[index] := value;
end;

procedure TFhirProcessResponseList.SetItemN(index: Integer; value: TFhirProcessResponse);
begin
  assert(value is TFhirProcessResponse);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PROCESSRESPONSE}

{$IFDEF FHIR_PROVENANCE}

{ TFhirProvenanceAgent }

constructor TFhirProvenanceAgent.Create;
begin
  inherited;
end;

destructor TFhirProvenanceAgent.Destroy;
begin
  FRole.free;
  FActor.free;
  FUserId.free;
  FRelatedAgentList.Free;
  inherited;
end;

procedure TFhirProvenanceAgent.Assign(oSource : TFslObject);
begin
  inherited;
  role := TFhirProvenanceAgent(oSource).role.Clone;
  actor := TFhirProvenanceAgent(oSource).actor.Clone;
  userId := TFhirProvenanceAgent(oSource).userId.Clone;
  if (TFhirProvenanceAgent(oSource).FRelatedAgentList = nil) then
  begin
    FRelatedAgentList.free;
    FRelatedAgentList := nil;
  end
  else
  begin
    if FRelatedAgentList = nil then
      FRelatedAgentList := TFhirProvenanceAgentRelatedAgentList.Create;
    FRelatedAgentList.Assign(TFhirProvenanceAgent(oSource).FRelatedAgentList);
  end;
end;

procedure TFhirProvenanceAgent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'actor') Then
     list.add(self.link, 'actor', FActor.Link);
  if (child_name = 'userId') Then
     list.add(self.link, 'userId', FUserId.Link);
  if (child_name = 'relatedAgent') Then
    list.addAll(self, 'relatedAgent', FRelatedAgentList);
end;

procedure TFhirProvenanceAgent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'role', 'Coding', false, TFhirCoding, FRole.Link));{2}
  oList.add(TFHIRProperty.create(self, 'actor', 'Reference(Practitioner|RelatedPerson|Patient|Device|Organization)', false, TFhirReference{Resource}, FActor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'userId', 'Identifier', false, TFhirIdentifier, FUserId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'relatedAgent', '', true, TFhirProvenanceAgentRelatedAgent, FRelatedAgentList.Link)){3};
end;

function TFhirProvenanceAgent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'role') then
  begin
    Role := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    Actor := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'userId') then
  begin
    UserId := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'relatedAgent') then
  begin
    RelatedAgentList.add(propValue as TFhirProvenanceAgentRelatedAgent){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirProvenanceAgent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'relatedAgent') then RelatedAgentList.insertItem(index, propValue as TFhirProvenanceAgentRelatedAgent){2a}
  else inherited;
end;

function TFhirProvenanceAgent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'role') then result := TFhirCoding.create(){4b}
  else if (propName = 'actor') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'userId') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'relatedAgent') then result := RelatedAgentList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirProvenanceAgent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'role') then result := 'Coding'
  else if (propName = 'actor') then result := 'Reference'
  else if (propName = 'userId') then result := 'Identifier'
  else if (propName = 'relatedAgent') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirProvenanceAgent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := nil
  else if (propName = 'actor') then ActorElement := nil
  else if (propName = 'userId') then UserIdElement := nil
  else if (propName = 'relatedAgent') then deletePropertyValue('relatedAgent', RelatedAgentList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirProvenanceAgent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := new as TFhirCoding{4}
  else if (propName = 'actor') then ActorElement := new as TFhirReference{Resource}{4}
  else if (propName = 'userId') then UserIdElement := new as TFhirIdentifier{4}
  else if (propName = 'relatedAgent') then replacePropertyValue('relatedAgent', RelatedAgentList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirProvenanceAgent.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'relatedAgent') then RelatedAgentList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirProvenanceAgent.fhirType : string;
begin
  result := 'agent';
end;

function TFhirProvenanceAgent.Link : TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent(inherited Link);
end;

function TFhirProvenanceAgent.Clone : TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent(inherited Clone);
end;

function TFhirProvenanceAgent.equals(other : TObject) : boolean;
var
  o : TFhirProvenanceAgent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirProvenanceAgent)) then
    result := false
  else
  begin
    o := TFhirProvenanceAgent(other);
    result := compareDeep(roleElement, o.roleElement, true) and compareDeep(actorElement, o.actorElement, true) and
      compareDeep(userIdElement, o.userIdElement, true) and compareDeep(relatedAgentList, o.relatedAgentList, true);
  end;
end;

function TFhirProvenanceAgent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRole) and isEmptyProp(FActor) and isEmptyProp(FUserId) and isEmptyProp(FrelatedAgentList);
end;

procedure TFhirProvenanceAgent.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('role');
  fields.add('actor');
  fields.add('userId');
  fields.add('relatedAgent');
end;

{ TFhirProvenanceAgent }

Procedure TFhirProvenanceAgent.SetRole(value : TFhirCoding);
begin
  FRole.free;
  FRole := value;
end;

Procedure TFhirProvenanceAgent.SetActor(value : TFhirReference{Resource});
begin
  FActor.free;
  FActor := value;
end;

Procedure TFhirProvenanceAgent.SetUserId(value : TFhirIdentifier);
begin
  FUserId.free;
  FUserId := value;
end;

Function TFhirProvenanceAgent.GetRelatedAgentList : TFhirProvenanceAgentRelatedAgentList;
begin
  if FRelatedAgentList = nil then
    FRelatedAgentList := TFhirProvenanceAgentRelatedAgentList.Create;
  result := FRelatedAgentList;
end;

Function TFhirProvenanceAgent.GetHasRelatedAgentList : boolean;
begin
  result := (FRelatedAgentList <> nil) and (FRelatedAgentList.count > 0);
end;

function TFhirProvenanceAgent.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FRole.sizeInBytes);
  inc(result, FActor.sizeInBytes);
  inc(result, FUserId.sizeInBytes);
  inc(result, FrelatedAgentList.sizeInBytes);
end;

{ TFhirProvenanceAgentListEnumerator }

Constructor TFhirProvenanceAgentListEnumerator.Create(list : TFhirProvenanceAgentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirProvenanceAgentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProvenanceAgentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirProvenanceAgentListEnumerator.GetCurrent : TFhirProvenanceAgent;
begin
  Result := FList[FIndex];
end;

function TFhirProvenanceAgentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirProvenanceAgentList }
procedure TFhirProvenanceAgentList.AddItem(value: TFhirProvenanceAgent);
begin
  assert(value.ClassName = 'TFhirProvenanceAgent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProvenanceAgent');
  add(value);
end;

function TFhirProvenanceAgentList.Append: TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProvenanceAgentList.ClearItems;
begin
  Clear;
end;

function TFhirProvenanceAgentList.GetEnumerator : TFhirProvenanceAgentListEnumerator;
begin
  result := TFhirProvenanceAgentListEnumerator.Create(self.link);
end;

function TFhirProvenanceAgentList.Clone: TFhirProvenanceAgentList;
begin
  result := TFhirProvenanceAgentList(inherited Clone);
end;

function TFhirProvenanceAgentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProvenanceAgentList.GetItemN(index: Integer): TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent(ObjectByIndex[index]);
end;

function TFhirProvenanceAgentList.ItemClass: TFslObjectClass;
begin
  result := TFhirProvenanceAgent;
end;
function TFhirProvenanceAgentList.IndexOf(value: TFhirProvenanceAgent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirProvenanceAgentList.Insert(index: Integer): TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProvenanceAgentList.InsertItem(index: Integer; value: TFhirProvenanceAgent);
begin
  assert(value is TFhirProvenanceAgent);
  Inherited Insert(index, value);
end;

function TFhirProvenanceAgentList.Item(index: Integer): TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent(ObjectByIndex[index]);
end;

function TFhirProvenanceAgentList.Link: TFhirProvenanceAgentList;
begin
  result := TFhirProvenanceAgentList(inherited Link);
end;

procedure TFhirProvenanceAgentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProvenanceAgentList.SetItemByIndex(index: Integer; value: TFhirProvenanceAgent);
begin
  assert(value is TFhirProvenanceAgent);
  FhirProvenanceAgents[index] := value;
end;

procedure TFhirProvenanceAgentList.SetItemN(index: Integer; value: TFhirProvenanceAgent);
begin
  assert(value is TFhirProvenanceAgent);
  ObjectByIndex[index] := value;
end;

{ TFhirProvenanceAgentRelatedAgent }

constructor TFhirProvenanceAgentRelatedAgent.Create;
begin
  inherited;
end;

destructor TFhirProvenanceAgentRelatedAgent.Destroy;
begin
  FType_.free;
  FTarget.free;
  inherited;
end;

procedure TFhirProvenanceAgentRelatedAgent.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirProvenanceAgentRelatedAgent(oSource).type_.Clone;
  targetElement := TFhirProvenanceAgentRelatedAgent(oSource).targetElement.Clone;
end;

procedure TFhirProvenanceAgentRelatedAgent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'target') Then
     list.add(self.link, 'target', FTarget.Link);
end;

procedure TFhirProvenanceAgentRelatedAgent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'target', 'uri', false, TFhirUri, FTarget.Link));{2}
end;

function TFhirProvenanceAgentRelatedAgent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'target') then
  begin
    TargetElement := asUri(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirProvenanceAgentRelatedAgent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirProvenanceAgentRelatedAgent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'target') then result := TFhirUri.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirProvenanceAgentRelatedAgent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'target') then result := 'uri'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirProvenanceAgentRelatedAgent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'target') then TargetElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirProvenanceAgentRelatedAgent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'target') then TargetElement := asUri(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirProvenanceAgentRelatedAgent.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirProvenanceAgentRelatedAgent.fhirType : string;
begin
  result := 'relatedAgent';
end;

function TFhirProvenanceAgentRelatedAgent.Link : TFhirProvenanceAgentRelatedAgent;
begin
  result := TFhirProvenanceAgentRelatedAgent(inherited Link);
end;

function TFhirProvenanceAgentRelatedAgent.Clone : TFhirProvenanceAgentRelatedAgent;
begin
  result := TFhirProvenanceAgentRelatedAgent(inherited Clone);
end;

function TFhirProvenanceAgentRelatedAgent.equals(other : TObject) : boolean;
var
  o : TFhirProvenanceAgentRelatedAgent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirProvenanceAgentRelatedAgent)) then
    result := false
  else
  begin
    o := TFhirProvenanceAgentRelatedAgent(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(targetElement, o.targetElement, true);
  end;
end;

function TFhirProvenanceAgentRelatedAgent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FTarget);
end;

procedure TFhirProvenanceAgentRelatedAgent.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('target');
end;

{ TFhirProvenanceAgentRelatedAgent }

Procedure TFhirProvenanceAgentRelatedAgent.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirProvenanceAgentRelatedAgent.SetTarget(value : TFhirUri);
begin
  FTarget.free;
  FTarget := value;
end;

Function TFhirProvenanceAgentRelatedAgent.GetTargetST : String;
begin
  if FTarget = nil then
    result := ''
  else
    result := FTarget.value;
end;

Procedure TFhirProvenanceAgentRelatedAgent.SetTargetST(value : String);
begin
  if value <> '' then
  begin
    if FTarget = nil then
      FTarget := TFhirUri.create;
    FTarget.value := value
  end
  else if FTarget <> nil then
    FTarget.value := '';
end;

function TFhirProvenanceAgentRelatedAgent.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FTarget.sizeInBytes);
end;

{ TFhirProvenanceAgentRelatedAgentListEnumerator }

Constructor TFhirProvenanceAgentRelatedAgentListEnumerator.Create(list : TFhirProvenanceAgentRelatedAgentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirProvenanceAgentRelatedAgentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProvenanceAgentRelatedAgentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirProvenanceAgentRelatedAgentListEnumerator.GetCurrent : TFhirProvenanceAgentRelatedAgent;
begin
  Result := FList[FIndex];
end;

function TFhirProvenanceAgentRelatedAgentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirProvenanceAgentRelatedAgentList }
procedure TFhirProvenanceAgentRelatedAgentList.AddItem(value: TFhirProvenanceAgentRelatedAgent);
begin
  assert(value.ClassName = 'TFhirProvenanceAgentRelatedAgent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProvenanceAgentRelatedAgent');
  add(value);
end;

function TFhirProvenanceAgentRelatedAgentList.Append: TFhirProvenanceAgentRelatedAgent;
begin
  result := TFhirProvenanceAgentRelatedAgent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProvenanceAgentRelatedAgentList.ClearItems;
begin
  Clear;
end;

function TFhirProvenanceAgentRelatedAgentList.GetEnumerator : TFhirProvenanceAgentRelatedAgentListEnumerator;
begin
  result := TFhirProvenanceAgentRelatedAgentListEnumerator.Create(self.link);
end;

function TFhirProvenanceAgentRelatedAgentList.Clone: TFhirProvenanceAgentRelatedAgentList;
begin
  result := TFhirProvenanceAgentRelatedAgentList(inherited Clone);
end;

function TFhirProvenanceAgentRelatedAgentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProvenanceAgentRelatedAgentList.GetItemN(index: Integer): TFhirProvenanceAgentRelatedAgent;
begin
  result := TFhirProvenanceAgentRelatedAgent(ObjectByIndex[index]);
end;

function TFhirProvenanceAgentRelatedAgentList.ItemClass: TFslObjectClass;
begin
  result := TFhirProvenanceAgentRelatedAgent;
end;
function TFhirProvenanceAgentRelatedAgentList.IndexOf(value: TFhirProvenanceAgentRelatedAgent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirProvenanceAgentRelatedAgentList.Insert(index: Integer): TFhirProvenanceAgentRelatedAgent;
begin
  result := TFhirProvenanceAgentRelatedAgent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProvenanceAgentRelatedAgentList.InsertItem(index: Integer; value: TFhirProvenanceAgentRelatedAgent);
begin
  assert(value is TFhirProvenanceAgentRelatedAgent);
  Inherited Insert(index, value);
end;

function TFhirProvenanceAgentRelatedAgentList.Item(index: Integer): TFhirProvenanceAgentRelatedAgent;
begin
  result := TFhirProvenanceAgentRelatedAgent(ObjectByIndex[index]);
end;

function TFhirProvenanceAgentRelatedAgentList.Link: TFhirProvenanceAgentRelatedAgentList;
begin
  result := TFhirProvenanceAgentRelatedAgentList(inherited Link);
end;

procedure TFhirProvenanceAgentRelatedAgentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProvenanceAgentRelatedAgentList.SetItemByIndex(index: Integer; value: TFhirProvenanceAgentRelatedAgent);
begin
  assert(value is TFhirProvenanceAgentRelatedAgent);
  FhirProvenanceAgentRelatedAgents[index] := value;
end;

procedure TFhirProvenanceAgentRelatedAgentList.SetItemN(index: Integer; value: TFhirProvenanceAgentRelatedAgent);
begin
  assert(value is TFhirProvenanceAgentRelatedAgent);
  ObjectByIndex[index] := value;
end;

{ TFhirProvenanceEntity }

constructor TFhirProvenanceEntity.Create;
begin
  inherited;
end;

destructor TFhirProvenanceEntity.Destroy;
begin
  FRole.free;
  FType_.free;
  FReference.free;
  FDisplay.free;
  FAgent.free;
  inherited;
end;

procedure TFhirProvenanceEntity.Assign(oSource : TFslObject);
begin
  inherited;
  FRole := TFhirProvenanceEntity(oSource).FRole.Link;
  type_ := TFhirProvenanceEntity(oSource).type_.Clone;
  referenceElement := TFhirProvenanceEntity(oSource).referenceElement.Clone;
  displayElement := TFhirProvenanceEntity(oSource).displayElement.Clone;
  agent := TFhirProvenanceEntity(oSource).agent.Clone;
end;

procedure TFhirProvenanceEntity.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
  if (child_name = 'display') Then
     list.add(self.link, 'display', FDisplay.Link);
  if (child_name = 'agent') Then
     list.add(self.link, 'agent', FAgent.Link);
end;

procedure TFhirProvenanceEntity.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'role', 'code', false, TFHIREnum, FRole.Link));{1}
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', false, TFhirCoding, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reference', 'uri', false, TFhirUri, FReference.Link));{2}
  oList.add(TFHIRProperty.create(self, 'display', 'string', false, TFhirString, FDisplay.Link));{2}
  oList.add(TFHIRProperty.create(self, 'agent', '@Provenance.agent', false, TFhirProvenanceAgent, FAgent.Link));{2}
end;

function TFhirProvenanceEntity.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'role') then
  begin
    RoleElement := asEnum(SYSTEMS_TFhirProvenanceEntityRoleEnum, CODES_TFhirProvenanceEntityRoleEnum, propValue);
    result := propValue
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'reference') then
  begin
    ReferenceElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'display') then
  begin
    DisplayElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'agent') then
  begin
    Agent := propValue as TFhirProvenanceAgent{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirProvenanceEntity.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirProvenanceEntity.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCoding.create(){4b}
  else if (propName = 'reference') then result := TFhirUri.create() {5b}
  else if (propName = 'display') then result := TFhirString.create() {5b}
  else if (propName = 'agent') then result := TFhirProvenanceAgent.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirProvenanceEntity.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'role') then result := 'code'
  else if (propName = 'type') then result := 'Coding'
  else if (propName = 'reference') then result := 'uri'
  else if (propName = 'display') then result := 'string'
  else if (propName = 'agent') then result := '@Provenance.agent'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirProvenanceEntity.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'reference') then ReferenceElement := nil
  else if (propName = 'display') then DisplayElement := nil
  else if (propName = 'agent') then AgentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirProvenanceEntity.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := asEnum(SYSTEMS_TFhirProvenanceEntityRoleEnum, CODES_TFhirProvenanceEntityRoleEnum, new){4}
  else if (propName = 'type') then Type_Element := new as TFhirCoding{4}
  else if (propName = 'reference') then ReferenceElement := asUri(new){5b}
  else if (propName = 'display') then DisplayElement := asString(new){5b}
  else if (propName = 'agent') then AgentElement := new as TFhirProvenanceAgent{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirProvenanceEntity.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirProvenanceEntity.fhirType : string;
begin
  result := 'entity';
end;

function TFhirProvenanceEntity.Link : TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity(inherited Link);
end;

function TFhirProvenanceEntity.Clone : TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity(inherited Clone);
end;

function TFhirProvenanceEntity.equals(other : TObject) : boolean;
var
  o : TFhirProvenanceEntity;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirProvenanceEntity)) then
    result := false
  else
  begin
    o := TFhirProvenanceEntity(other);
    result := compareDeep(roleElement, o.roleElement, true) and compareDeep(type_Element, o.type_Element, true) and
      compareDeep(referenceElement, o.referenceElement, true) and compareDeep(displayElement, o.displayElement, true) and
      compareDeep(agentElement, o.agentElement, true);
  end;
end;

function TFhirProvenanceEntity.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRole) and isEmptyProp(FType_) and isEmptyProp(FReference) and isEmptyProp(FDisplay) and isEmptyProp(FAgent);
end;

procedure TFhirProvenanceEntity.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('role');
  fields.add('type');
  fields.add('reference');
  fields.add('display');
  fields.add('agent');
end;

{ TFhirProvenanceEntity }

Procedure TFhirProvenanceEntity.SetRole(value : TFhirEnum);
begin
  FRole.free;
  FRole := value;
end;

Function TFhirProvenanceEntity.GetRoleST : TFhirProvenanceEntityRoleEnum;
begin
  if FRole = nil then
    result := TFhirProvenanceEntityRoleEnum(0)
  else
    result := TFhirProvenanceEntityRoleEnum(StringArrayIndexOfSensitive(CODES_TFhirProvenanceEntityRoleEnum, FRole.value));
end;

Procedure TFhirProvenanceEntity.SetRoleST(value : TFhirProvenanceEntityRoleEnum);
begin
  if ord(value) = 0 then
    RoleElement := nil
  else
    RoleElement := TFhirEnum.create(SYSTEMS_TFhirProvenanceEntityRoleEnum[value], CODES_TFhirProvenanceEntityRoleEnum[value]);
end;

Procedure TFhirProvenanceEntity.SetType_(value : TFhirCoding);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirProvenanceEntity.SetReference(value : TFhirUri);
begin
  FReference.free;
  FReference := value;
end;

Function TFhirProvenanceEntity.GetReferenceST : String;
begin
  if FReference = nil then
    result := ''
  else
    result := FReference.value;
end;

Procedure TFhirProvenanceEntity.SetReferenceST(value : String);
begin
  if value <> '' then
  begin
    if FReference = nil then
      FReference := TFhirUri.create;
    FReference.value := value
  end
  else if FReference <> nil then
    FReference.value := '';
end;

Procedure TFhirProvenanceEntity.SetDisplay(value : TFhirString);
begin
  FDisplay.free;
  FDisplay := value;
end;

Function TFhirProvenanceEntity.GetDisplayST : String;
begin
  if FDisplay = nil then
    result := ''
  else
    result := FDisplay.value;
end;

Procedure TFhirProvenanceEntity.SetDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FDisplay = nil then
      FDisplay := TFhirString.create;
    FDisplay.value := value
  end
  else if FDisplay <> nil then
    FDisplay.value := '';
end;

Procedure TFhirProvenanceEntity.SetAgent(value : TFhirProvenanceAgent);
begin
  FAgent.free;
  FAgent := value;
end;

function TFhirProvenanceEntity.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FRole.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FReference.sizeInBytes);
  inc(result, FDisplay.sizeInBytes);
  inc(result, FAgent.sizeInBytes);
end;

{ TFhirProvenanceEntityListEnumerator }

Constructor TFhirProvenanceEntityListEnumerator.Create(list : TFhirProvenanceEntityList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirProvenanceEntityListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProvenanceEntityListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirProvenanceEntityListEnumerator.GetCurrent : TFhirProvenanceEntity;
begin
  Result := FList[FIndex];
end;

function TFhirProvenanceEntityListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirProvenanceEntityList }
procedure TFhirProvenanceEntityList.AddItem(value: TFhirProvenanceEntity);
begin
  assert(value.ClassName = 'TFhirProvenanceEntity', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProvenanceEntity');
  add(value);
end;

function TFhirProvenanceEntityList.Append: TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProvenanceEntityList.ClearItems;
begin
  Clear;
end;

function TFhirProvenanceEntityList.GetEnumerator : TFhirProvenanceEntityListEnumerator;
begin
  result := TFhirProvenanceEntityListEnumerator.Create(self.link);
end;

function TFhirProvenanceEntityList.Clone: TFhirProvenanceEntityList;
begin
  result := TFhirProvenanceEntityList(inherited Clone);
end;

function TFhirProvenanceEntityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProvenanceEntityList.GetItemN(index: Integer): TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity(ObjectByIndex[index]);
end;

function TFhirProvenanceEntityList.ItemClass: TFslObjectClass;
begin
  result := TFhirProvenanceEntity;
end;
function TFhirProvenanceEntityList.IndexOf(value: TFhirProvenanceEntity): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirProvenanceEntityList.Insert(index: Integer): TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProvenanceEntityList.InsertItem(index: Integer; value: TFhirProvenanceEntity);
begin
  assert(value is TFhirProvenanceEntity);
  Inherited Insert(index, value);
end;

function TFhirProvenanceEntityList.Item(index: Integer): TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity(ObjectByIndex[index]);
end;

function TFhirProvenanceEntityList.Link: TFhirProvenanceEntityList;
begin
  result := TFhirProvenanceEntityList(inherited Link);
end;

procedure TFhirProvenanceEntityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProvenanceEntityList.SetItemByIndex(index: Integer; value: TFhirProvenanceEntity);
begin
  assert(value is TFhirProvenanceEntity);
  FhirProvenanceEntities[index] := value;
end;

procedure TFhirProvenanceEntityList.SetItemN(index: Integer; value: TFhirProvenanceEntity);
begin
  assert(value is TFhirProvenanceEntity);
  ObjectByIndex[index] := value;
end;

{ TFhirProvenance }

constructor TFhirProvenance.Create;
begin
  inherited;
end;

destructor TFhirProvenance.Destroy;
begin
  FTargetList.Free;
  FPeriod.free;
  FRecorded.free;
  FReasonList.Free;
  FActivity.free;
  FLocation.free;
  FPolicyList.Free;
  FAgentList.Free;
  FEntityList.Free;
  FSignatureList.Free;
  inherited;
end;

function TFhirProvenance.GetResourceType : TFhirResourceType;
begin
  result := frtProvenance;
end;

procedure TFhirProvenance.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirProvenance(oSource).FTargetList = nil) then
  begin
    FTargetList.free;
    FTargetList := nil;
  end
  else
  begin
    if FTargetList = nil then
      FTargetList := TFhirReferenceList{TFhirReference}.Create;
    FTargetList.Assign(TFhirProvenance(oSource).FTargetList);
  end;
  period := TFhirProvenance(oSource).period.Clone;
  recordedElement := TFhirProvenance(oSource).recordedElement.Clone;
  if (TFhirProvenance(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableConceptList.Create;
    FReasonList.Assign(TFhirProvenance(oSource).FReasonList);
  end;
  activity := TFhirProvenance(oSource).activity.Clone;
  location := TFhirProvenance(oSource).location.Clone;
  if (TFhirProvenance(oSource).FPolicyList = nil) then
  begin
    FPolicyList.free;
    FPolicyList := nil;
  end
  else
  begin
    if FPolicyList = nil then
      FPolicyList := TFhirUriList.Create;
    FPolicyList.Assign(TFhirProvenance(oSource).FPolicyList);
  end;
  if (TFhirProvenance(oSource).FAgentList = nil) then
  begin
    FAgentList.free;
    FAgentList := nil;
  end
  else
  begin
    if FAgentList = nil then
      FAgentList := TFhirProvenanceAgentList.Create;
    FAgentList.Assign(TFhirProvenance(oSource).FAgentList);
  end;
  if (TFhirProvenance(oSource).FEntityList = nil) then
  begin
    FEntityList.free;
    FEntityList := nil;
  end
  else
  begin
    if FEntityList = nil then
      FEntityList := TFhirProvenanceEntityList.Create;
    FEntityList.Assign(TFhirProvenance(oSource).FEntityList);
  end;
  if (TFhirProvenance(oSource).FSignatureList = nil) then
  begin
    FSignatureList.free;
    FSignatureList := nil;
  end
  else
  begin
    if FSignatureList = nil then
      FSignatureList := TFhirSignatureList.Create;
    FSignatureList.Assign(TFhirProvenance(oSource).FSignatureList);
  end;
end;

procedure TFhirProvenance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'target') Then
    list.addAll(self, 'target', FTargetList);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'recorded') Then
     list.add(self.link, 'recorded', FRecorded.Link);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'activity') Then
     list.add(self.link, 'activity', FActivity.Link);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'policy') Then
    list.addAll(self, 'policy', FPolicyList);
  if (child_name = 'agent') Then
    list.addAll(self, 'agent', FAgentList);
  if (child_name = 'entity') Then
    list.addAll(self, 'entity', FEntityList);
  if (child_name = 'signature') Then
    list.addAll(self, 'signature', FSignatureList);
end;

procedure TFhirProvenance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'target', 'Reference(Any)', true, TFhirReference{TFhirReference}, FTargetList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'recorded', 'instant', false, TFhirInstant, FRecorded.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', true, TFhirCodeableConcept, FReasonList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'activity', 'CodeableConcept', false, TFhirCodeableConcept, FActivity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'location', 'Reference(Location)', false, TFhirReference{TFhirLocation}, FLocation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'policy', 'uri', true, TFhirUri, FPolicyList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'agent', '', true, TFhirProvenanceAgent, FAgentList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'entity', '', true, TFhirProvenanceEntity, FEntityList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'signature', 'Signature', true, TFhirSignature, FSignatureList.Link)){3};
end;

function TFhirProvenance.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'target') then
  begin
    TargetList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'recorded') then
  begin
    RecordedElement := asInstant(propValue){5a};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'activity') then
  begin
    Activity := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirReference{TFhirLocation}{4b};
    result := propValue;
  end
  else if (propName = 'policy') then
  begin
    PolicyList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'agent') then
  begin
    AgentList.add(propValue as TFhirProvenanceAgent){2a};
    result := propValue;
  end
  else if (propName = 'entity') then
  begin
    EntityList.add(propValue as TFhirProvenanceEntity){2a};
    result := propValue;
  end
  else if (propName = 'signature') then
  begin
    SignatureList.add(propValue as TFhirSignature){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirProvenance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'target') then TargetList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'policy') then PolicyList.insertItem(index, asUri(propValue)){2}
  else if (propName = 'agent') then AgentList.insertItem(index, propValue as TFhirProvenanceAgent){2a}
  else if (propName = 'entity') then EntityList.insertItem(index, propValue as TFhirProvenanceEntity){2a}
  else if (propName = 'signature') then SignatureList.insertItem(index, propValue as TFhirSignature){2a}
  else inherited;
end;

function TFhirProvenance.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'target') then result := TargetList.new(){2}
  else if (propName = 'period') then result := TFhirPeriod.create(){4b}
  else if (propName = 'recorded') then result := TFhirInstant.create() {5b}
  else if (propName = 'reason') then result := ReasonList.new(){2}
  else if (propName = 'activity') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'location') then result := TFhirReference{TFhirLocation}.create(){4b}
  else if (propName = 'policy') then result := PolicyList.new(){2}
  else if (propName = 'agent') then result := AgentList.new(){2}
  else if (propName = 'entity') then result := EntityList.new(){2}
  else if (propName = 'signature') then result := SignatureList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirProvenance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'target') then result := 'Reference'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'recorded') then result := 'instant'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else if (propName = 'activity') then result := 'CodeableConcept'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'policy') then result := 'uri'
  else if (propName = 'agent') then result := ''
  else if (propName = 'entity') then result := ''
  else if (propName = 'signature') then result := 'Signature'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirProvenance.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'target') then deletePropertyValue('target', TargetList, value) {2}
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'recorded') then RecordedElement := nil
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value) {2}
  else if (propName = 'activity') then ActivityElement := nil
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'policy') then deletePropertyValue('policy', PolicyList, value) {2}
  else if (propName = 'agent') then deletePropertyValue('agent', AgentList, value) {2}
  else if (propName = 'entity') then deletePropertyValue('entity', EntityList, value) {2}
  else if (propName = 'signature') then deletePropertyValue('signature', SignatureList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirProvenance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'target') then replacePropertyValue('target', TargetList, existing, new) {2}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else if (propName = 'recorded') then RecordedElement := asInstant(new){5b}
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new) {2}
  else if (propName = 'activity') then ActivityElement := new as TFhirCodeableConcept{4}
  else if (propName = 'location') then LocationElement := new as TFhirReference{TFhirLocation}{4}
  else if (propName = 'policy') then replacePropertyValue('policy', PolicyList, existing, new) {2}
  else if (propName = 'agent') then replacePropertyValue('agent', AgentList, existing, new) {2}
  else if (propName = 'entity') then replacePropertyValue('entity', EntityList, existing, new) {2}
  else if (propName = 'signature') then replacePropertyValue('signature', SignatureList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirProvenance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'target') then TargetList.move(source, destination){2a}
  else if (propName = 'reason') then ReasonList.move(source, destination){2a}
  else if (propName = 'policy') then PolicyList.move(source, destination){2}
  else if (propName = 'agent') then AgentList.move(source, destination){2a}
  else if (propName = 'entity') then EntityList.move(source, destination){2a}
  else if (propName = 'signature') then SignatureList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirProvenance.fhirType : string;
begin
  result := 'Provenance';
end;

function TFhirProvenance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FtargetList) and isEmptyProp(FPeriod) and isEmptyProp(FRecorded) and isEmptyProp(FreasonList) and isEmptyProp(FActivity) and isEmptyProp(FLocation) and isEmptyProp(FpolicyList) and isEmptyProp(FagentList) and isEmptyProp(FentityList) and isEmptyProp(FsignatureList);
end;

function TFhirProvenance.equals(other : TObject) : boolean;
var
  o : TFhirProvenance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirProvenance)) then
    result := false
  else
  begin
    o := TFhirProvenance(other);
    result := compareDeep(targetList, o.targetList, true) and compareDeep(periodElement, o.periodElement, true) and
      compareDeep(recordedElement, o.recordedElement, true) and compareDeep(reasonList, o.reasonList, true) and
      compareDeep(activityElement, o.activityElement, true) and compareDeep(locationElement, o.locationElement, true) and
      compareDeep(policyList, o.policyList, true) and compareDeep(agentList, o.agentList, true) and
      compareDeep(entityList, o.entityList, true) and compareDeep(signatureList, o.signatureList, true);
  end;
end;

function TFhirProvenance.Link : TFhirProvenance;
begin
  result := TFhirProvenance(inherited Link);
end;

function TFhirProvenance.Clone : TFhirProvenance;
begin
  result := TFhirProvenance(inherited Clone);
end;

procedure TFhirProvenance.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('target');
  fields.add('period');
  fields.add('recorded');
  fields.add('reason');
  fields.add('activity');
  fields.add('location');
  fields.add('policy');
  fields.add('agent');
  fields.add('entity');
  fields.add('signature');
end;

{ TFhirProvenance }

Function TFhirProvenance.GetTargetList : TFhirReferenceList{TFhirReference};
begin
  if FTargetList = nil then
    FTargetList := TFhirReferenceList{TFhirReference}.Create;
  result := FTargetList;
end;

Function TFhirProvenance.GetHasTargetList : boolean;
begin
  result := (FTargetList <> nil) and (FTargetList.count > 0);
end;

Procedure TFhirProvenance.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Procedure TFhirProvenance.SetRecorded(value : TFhirInstant);
begin
  FRecorded.free;
  FRecorded := value;
end;

Function TFhirProvenance.GetRecordedST : TFslDateTime;
begin
  if FRecorded = nil then
    result := TFslDateTime.makeNull
  else
    result := FRecorded.value;
end;

Procedure TFhirProvenance.SetRecordedST(value : TFslDateTime);
begin
  if FRecorded = nil then
    FRecorded := TFhirInstant.create;
  FRecorded.value := value
end;

Function TFhirProvenance.GetReasonList : TFhirCodeableConceptList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableConceptList.Create;
  result := FReasonList;
end;

Function TFhirProvenance.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

Procedure TFhirProvenance.SetActivity(value : TFhirCodeableConcept);
begin
  FActivity.free;
  FActivity := value;
end;

Procedure TFhirProvenance.SetLocation(value : TFhirReference{TFhirLocation});
begin
  FLocation.free;
  FLocation := value;
end;

Function TFhirProvenance.GetPolicyList : TFhirUriList;
begin
  if FPolicyList = nil then
    FPolicyList := TFhirUriList.Create;
  result := FPolicyList;
end;

Function TFhirProvenance.GetHasPolicyList : boolean;
begin
  result := (FPolicyList <> nil) and (FPolicyList.count > 0);
end;

Function TFhirProvenance.GetAgentList : TFhirProvenanceAgentList;
begin
  if FAgentList = nil then
    FAgentList := TFhirProvenanceAgentList.Create;
  result := FAgentList;
end;

Function TFhirProvenance.GetHasAgentList : boolean;
begin
  result := (FAgentList <> nil) and (FAgentList.count > 0);
end;

Function TFhirProvenance.GetEntityList : TFhirProvenanceEntityList;
begin
  if FEntityList = nil then
    FEntityList := TFhirProvenanceEntityList.Create;
  result := FEntityList;
end;

Function TFhirProvenance.GetHasEntityList : boolean;
begin
  result := (FEntityList <> nil) and (FEntityList.count > 0);
end;

Function TFhirProvenance.GetSignatureList : TFhirSignatureList;
begin
  if FSignatureList = nil then
    FSignatureList := TFhirSignatureList.Create;
  result := FSignatureList;
end;

Function TFhirProvenance.GetHasSignatureList : boolean;
begin
  result := (FSignatureList <> nil) and (FSignatureList.count > 0);
end;

function TFhirProvenance.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FtargetList.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FRecorded.sizeInBytes);
  inc(result, FreasonList.sizeInBytes);
  inc(result, FActivity.sizeInBytes);
  inc(result, FLocation.sizeInBytes);
  inc(result, FpolicyList.sizeInBytes);
  inc(result, FagentList.sizeInBytes);
  inc(result, FentityList.sizeInBytes);
  inc(result, FsignatureList.sizeInBytes);
end;

{ TFhirProvenanceListEnumerator }

Constructor TFhirProvenanceListEnumerator.Create(list : TFhirProvenanceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirProvenanceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProvenanceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirProvenanceListEnumerator.GetCurrent : TFhirProvenance;
begin
  Result := FList[FIndex];
end;

function TFhirProvenanceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirProvenanceList }
procedure TFhirProvenanceList.AddItem(value: TFhirProvenance);
begin
  assert(value.ClassName = 'TFhirProvenance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProvenance');
  add(value);
end;

function TFhirProvenanceList.Append: TFhirProvenance;
begin
  result := TFhirProvenance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProvenanceList.ClearItems;
begin
  Clear;
end;

function TFhirProvenanceList.GetEnumerator : TFhirProvenanceListEnumerator;
begin
  result := TFhirProvenanceListEnumerator.Create(self.link);
end;

function TFhirProvenanceList.Clone: TFhirProvenanceList;
begin
  result := TFhirProvenanceList(inherited Clone);
end;

function TFhirProvenanceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProvenanceList.GetItemN(index: Integer): TFhirProvenance;
begin
  result := TFhirProvenance(ObjectByIndex[index]);
end;

function TFhirProvenanceList.ItemClass: TFslObjectClass;
begin
  result := TFhirProvenance;
end;
function TFhirProvenanceList.IndexOf(value: TFhirProvenance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirProvenanceList.Insert(index: Integer): TFhirProvenance;
begin
  result := TFhirProvenance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProvenanceList.InsertItem(index: Integer; value: TFhirProvenance);
begin
  assert(value is TFhirProvenance);
  Inherited Insert(index, value);
end;

function TFhirProvenanceList.Item(index: Integer): TFhirProvenance;
begin
  result := TFhirProvenance(ObjectByIndex[index]);
end;

function TFhirProvenanceList.Link: TFhirProvenanceList;
begin
  result := TFhirProvenanceList(inherited Link);
end;

procedure TFhirProvenanceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProvenanceList.SetItemByIndex(index: Integer; value: TFhirProvenance);
begin
  assert(value is TFhirProvenance);
  FhirProvenances[index] := value;
end;

procedure TFhirProvenanceList.SetItemN(index: Integer; value: TFhirProvenance);
begin
  assert(value is TFhirProvenance);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PROVENANCE}

{$IFDEF FHIR_SUBSCRIPTION}

{ TFhirSubscriptionChannel }

constructor TFhirSubscriptionChannel.Create;
begin
  inherited;
end;

destructor TFhirSubscriptionChannel.Destroy;
begin
  FType_.free;
  FEndpoint.free;
  FPayload.free;
  FHeader.free;
  inherited;
end;

procedure TFhirSubscriptionChannel.Assign(oSource : TFslObject);
begin
  inherited;
  FType_ := TFhirSubscriptionChannel(oSource).FType_.Link;
  endpointElement := TFhirSubscriptionChannel(oSource).endpointElement.Clone;
  payloadElement := TFhirSubscriptionChannel(oSource).payloadElement.Clone;
  headerElement := TFhirSubscriptionChannel(oSource).headerElement.Clone;
end;

procedure TFhirSubscriptionChannel.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'endpoint') Then
     list.add(self.link, 'endpoint', FEndpoint.Link);
  if (child_name = 'payload') Then
     list.add(self.link, 'payload', FPayload.Link);
  if (child_name = 'header') Then
     list.add(self.link, 'header', FHeader.Link);
end;

procedure TFhirSubscriptionChannel.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'endpoint', 'uri', false, TFhirUri, FEndpoint.Link));{2}
  oList.add(TFHIRProperty.create(self, 'payload', 'string', false, TFhirString, FPayload.Link));{2}
  oList.add(TFHIRProperty.create(self, 'header', 'string', false, TFhirString, FHeader.Link));{2}
end;

function TFhirSubscriptionChannel.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirSubscriptionChannelTypeEnum, CODES_TFhirSubscriptionChannelTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'endpoint') then
  begin
    EndpointElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'payload') then
  begin
    PayloadElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'header') then
  begin
    HeaderElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubscriptionChannel.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubscriptionChannel.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'endpoint') then result := TFhirUri.create() {5b}
  else if (propName = 'payload') then result := TFhirString.create() {5b}
  else if (propName = 'header') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubscriptionChannel.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'endpoint') then result := 'uri'
  else if (propName = 'payload') then result := 'string'
  else if (propName = 'header') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubscriptionChannel.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'endpoint') then EndpointElement := nil
  else if (propName = 'payload') then PayloadElement := nil
  else if (propName = 'header') then HeaderElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubscriptionChannel.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirSubscriptionChannelTypeEnum, CODES_TFhirSubscriptionChannelTypeEnum, new){4}
  else if (propName = 'endpoint') then EndpointElement := asUri(new){5b}
  else if (propName = 'payload') then PayloadElement := asString(new){5b}
  else if (propName = 'header') then HeaderElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubscriptionChannel.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubscriptionChannel.fhirType : string;
begin
  result := 'channel';
end;

function TFhirSubscriptionChannel.Link : TFhirSubscriptionChannel;
begin
  result := TFhirSubscriptionChannel(inherited Link);
end;

function TFhirSubscriptionChannel.Clone : TFhirSubscriptionChannel;
begin
  result := TFhirSubscriptionChannel(inherited Clone);
end;

function TFhirSubscriptionChannel.equals(other : TObject) : boolean;
var
  o : TFhirSubscriptionChannel;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubscriptionChannel)) then
    result := false
  else
  begin
    o := TFhirSubscriptionChannel(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(endpointElement, o.endpointElement, true) and
      compareDeep(payloadElement, o.payloadElement, true) and compareDeep(headerElement, o.headerElement, true);
  end;
end;

function TFhirSubscriptionChannel.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FEndpoint) and isEmptyProp(FPayload) and isEmptyProp(FHeader);
end;

procedure TFhirSubscriptionChannel.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('endpoint');
  fields.add('payload');
  fields.add('header');
end;

{ TFhirSubscriptionChannel }

Procedure TFhirSubscriptionChannel.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirSubscriptionChannel.GetType_ST : TFhirSubscriptionChannelTypeEnum;
begin
  if FType_ = nil then
    result := TFhirSubscriptionChannelTypeEnum(0)
  else
    result := TFhirSubscriptionChannelTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirSubscriptionChannelTypeEnum, FType_.value));
end;

Procedure TFhirSubscriptionChannel.SetType_ST(value : TFhirSubscriptionChannelTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirSubscriptionChannelTypeEnum[value], CODES_TFhirSubscriptionChannelTypeEnum[value]);
end;

Procedure TFhirSubscriptionChannel.SetEndpoint(value : TFhirUri);
begin
  FEndpoint.free;
  FEndpoint := value;
end;

Function TFhirSubscriptionChannel.GetEndpointST : String;
begin
  if FEndpoint = nil then
    result := ''
  else
    result := FEndpoint.value;
end;

Procedure TFhirSubscriptionChannel.SetEndpointST(value : String);
begin
  if value <> '' then
  begin
    if FEndpoint = nil then
      FEndpoint := TFhirUri.create;
    FEndpoint.value := value
  end
  else if FEndpoint <> nil then
    FEndpoint.value := '';
end;

Procedure TFhirSubscriptionChannel.SetPayload(value : TFhirString);
begin
  FPayload.free;
  FPayload := value;
end;

Function TFhirSubscriptionChannel.GetPayloadST : String;
begin
  if FPayload = nil then
    result := ''
  else
    result := FPayload.value;
end;

Procedure TFhirSubscriptionChannel.SetPayloadST(value : String);
begin
  if value <> '' then
  begin
    if FPayload = nil then
      FPayload := TFhirString.create;
    FPayload.value := value
  end
  else if FPayload <> nil then
    FPayload.value := '';
end;

Procedure TFhirSubscriptionChannel.SetHeader(value : TFhirString);
begin
  FHeader.free;
  FHeader := value;
end;

Function TFhirSubscriptionChannel.GetHeaderST : String;
begin
  if FHeader = nil then
    result := ''
  else
    result := FHeader.value;
end;

Procedure TFhirSubscriptionChannel.SetHeaderST(value : String);
begin
  if value <> '' then
  begin
    if FHeader = nil then
      FHeader := TFhirString.create;
    FHeader.value := value
  end
  else if FHeader <> nil then
    FHeader.value := '';
end;

function TFhirSubscriptionChannel.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FEndpoint.sizeInBytes);
  inc(result, FPayload.sizeInBytes);
  inc(result, FHeader.sizeInBytes);
end;

{ TFhirSubscriptionChannelListEnumerator }

Constructor TFhirSubscriptionChannelListEnumerator.Create(list : TFhirSubscriptionChannelList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubscriptionChannelListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubscriptionChannelListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubscriptionChannelListEnumerator.GetCurrent : TFhirSubscriptionChannel;
begin
  Result := FList[FIndex];
end;

function TFhirSubscriptionChannelListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubscriptionChannelList }
procedure TFhirSubscriptionChannelList.AddItem(value: TFhirSubscriptionChannel);
begin
  assert(value.ClassName = 'TFhirSubscriptionChannel', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubscriptionChannel');
  add(value);
end;

function TFhirSubscriptionChannelList.Append: TFhirSubscriptionChannel;
begin
  result := TFhirSubscriptionChannel.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionChannelList.ClearItems;
begin
  Clear;
end;

function TFhirSubscriptionChannelList.GetEnumerator : TFhirSubscriptionChannelListEnumerator;
begin
  result := TFhirSubscriptionChannelListEnumerator.Create(self.link);
end;

function TFhirSubscriptionChannelList.Clone: TFhirSubscriptionChannelList;
begin
  result := TFhirSubscriptionChannelList(inherited Clone);
end;

function TFhirSubscriptionChannelList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubscriptionChannelList.GetItemN(index: Integer): TFhirSubscriptionChannel;
begin
  result := TFhirSubscriptionChannel(ObjectByIndex[index]);
end;

function TFhirSubscriptionChannelList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubscriptionChannel;
end;
function TFhirSubscriptionChannelList.IndexOf(value: TFhirSubscriptionChannel): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubscriptionChannelList.Insert(index: Integer): TFhirSubscriptionChannel;
begin
  result := TFhirSubscriptionChannel.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionChannelList.InsertItem(index: Integer; value: TFhirSubscriptionChannel);
begin
  assert(value is TFhirSubscriptionChannel);
  Inherited Insert(index, value);
end;

function TFhirSubscriptionChannelList.Item(index: Integer): TFhirSubscriptionChannel;
begin
  result := TFhirSubscriptionChannel(ObjectByIndex[index]);
end;

function TFhirSubscriptionChannelList.Link: TFhirSubscriptionChannelList;
begin
  result := TFhirSubscriptionChannelList(inherited Link);
end;

procedure TFhirSubscriptionChannelList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubscriptionChannelList.SetItemByIndex(index: Integer; value: TFhirSubscriptionChannel);
begin
  assert(value is TFhirSubscriptionChannel);
  FhirSubscriptionChannels[index] := value;
end;

procedure TFhirSubscriptionChannelList.SetItemN(index: Integer; value: TFhirSubscriptionChannel);
begin
  assert(value is TFhirSubscriptionChannel);
  ObjectByIndex[index] := value;
end;

{ TFhirSubscription }

constructor TFhirSubscription.Create;
begin
  inherited;
end;

destructor TFhirSubscription.Destroy;
begin
  FCriteria.free;
  FContactList.Free;
  FReason.free;
  FStatus.free;
  FError.free;
  FChannel.free;
  FEnd_.free;
  FTagList.Free;
  inherited;
end;

function TFhirSubscription.GetResourceType : TFhirResourceType;
begin
  result := frtSubscription;
end;

procedure TFhirSubscription.Assign(oSource : TFslObject);
begin
  inherited;
  criteriaElement := TFhirSubscription(oSource).criteriaElement.Clone;
  if (TFhirSubscription(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactPointList.Create;
    FContactList.Assign(TFhirSubscription(oSource).FContactList);
  end;
  reasonElement := TFhirSubscription(oSource).reasonElement.Clone;
  FStatus := TFhirSubscription(oSource).FStatus.Link;
  errorElement := TFhirSubscription(oSource).errorElement.Clone;
  channel := TFhirSubscription(oSource).channel.Clone;
  end_Element := TFhirSubscription(oSource).end_Element.Clone;
  if (TFhirSubscription(oSource).FTagList = nil) then
  begin
    FTagList.free;
    FTagList := nil;
  end
  else
  begin
    if FTagList = nil then
      FTagList := TFhirCodingList.Create;
    FTagList.Assign(TFhirSubscription(oSource).FTagList);
  end;
end;

procedure TFhirSubscription.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'criteria') Then
     list.add(self.link, 'criteria', FCriteria.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'reason') Then
     list.add(self.link, 'reason', FReason.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'error') Then
     list.add(self.link, 'error', FError.Link);
  if (child_name = 'channel') Then
     list.add(self.link, 'channel', FChannel.Link);
  if (child_name = 'end') Then
     list.add(self.link, 'end', FEnd_.Link);
  if (child_name = 'tag') Then
    list.addAll(self, 'tag', FTagList);
end;

procedure TFhirSubscription.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'criteria', 'string', false, TFhirString, FCriteria.Link));{2}
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactPoint', true, TFhirContactPoint, FContactList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reason', 'string', false, TFhirString, FReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'error', 'string', false, TFhirString, FError.Link));{2}
  oList.add(TFHIRProperty.create(self, 'channel', '', false, TFhirSubscriptionChannel, FChannel.Link));{2}
  oList.add(TFHIRProperty.create(self, 'end', 'instant', false, TFhirInstant, FEnd_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'tag', 'Coding', true, TFhirCoding, FTagList.Link)){3};
end;

function TFhirSubscription.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'criteria') then
  begin
    CriteriaElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactPoint){2a};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirSubscriptionStatusEnum, CODES_TFhirSubscriptionStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'error') then
  begin
    ErrorElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'channel') then
  begin
    Channel := propValue as TFhirSubscriptionChannel{4b};
    result := propValue;
  end
  else if (propName = 'end') then
  begin
    End_Element := asInstant(propValue){5a};
    result := propValue;
  end
  else if (propName = 'tag') then
  begin
    TagList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirSubscription.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactPoint){2a}
  else if (propName = 'tag') then TagList.insertItem(index, propValue as TFhirCoding){2a}
  else inherited;
end;

function TFhirSubscription.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'criteria') then result := TFhirString.create() {5b}
  else if (propName = 'contact') then result := ContactList.new(){2}
  else if (propName = 'reason') then result := TFhirString.create() {5b}
  else if (propName = 'error') then result := TFhirString.create() {5b}
  else if (propName = 'channel') then result := TFhirSubscriptionChannel.create(){4b}
  else if (propName = 'end') then result := TFhirInstant.create() {5b}
  else if (propName = 'tag') then result := TagList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubscription.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'criteria') then result := 'string'
  else if (propName = 'contact') then result := 'ContactPoint'
  else if (propName = 'reason') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'error') then result := 'string'
  else if (propName = 'channel') then result := ''
  else if (propName = 'end') then result := 'instant'
  else if (propName = 'tag') then result := 'Coding'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubscription.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'criteria') then CriteriaElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value) {2}
  else if (propName = 'reason') then ReasonElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'error') then ErrorElement := nil
  else if (propName = 'channel') then ChannelElement := nil
  else if (propName = 'end') then End_Element := nil
  else if (propName = 'tag') then deletePropertyValue('tag', TagList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubscription.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'criteria') then CriteriaElement := asString(new){5b}
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new) {2}
  else if (propName = 'reason') then ReasonElement := asString(new){5b}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirSubscriptionStatusEnum, CODES_TFhirSubscriptionStatusEnum, new){4}
  else if (propName = 'error') then ErrorElement := asString(new){5b}
  else if (propName = 'channel') then ChannelElement := new as TFhirSubscriptionChannel{4}
  else if (propName = 'end') then End_Element := asInstant(new){5b}
  else if (propName = 'tag') then replacePropertyValue('tag', TagList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubscription.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'contact') then ContactList.move(source, destination){2a}
  else if (propName = 'tag') then TagList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubscription.fhirType : string;
begin
  result := 'Subscription';
end;

function TFhirSubscription.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCriteria) and isEmptyProp(FcontactList) and isEmptyProp(FReason) and isEmptyProp(FStatus) and isEmptyProp(FError) and isEmptyProp(FChannel) and isEmptyProp(FEnd_) and isEmptyProp(FtagList);
end;

function TFhirSubscription.equals(other : TObject) : boolean;
var
  o : TFhirSubscription;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubscription)) then
    result := false
  else
  begin
    o := TFhirSubscription(other);
    result := compareDeep(criteriaElement, o.criteriaElement, true) and compareDeep(contactList, o.contactList, true) and
      compareDeep(reasonElement, o.reasonElement, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(errorElement, o.errorElement, true) and compareDeep(channelElement, o.channelElement, true) and
      compareDeep(end_Element, o.end_Element, true) and compareDeep(tagList, o.tagList, true);
  end;
end;

function TFhirSubscription.Link : TFhirSubscription;
begin
  result := TFhirSubscription(inherited Link);
end;

function TFhirSubscription.Clone : TFhirSubscription;
begin
  result := TFhirSubscription(inherited Clone);
end;

procedure TFhirSubscription.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('criteria');
  fields.add('contact');
  fields.add('reason');
  fields.add('status');
  fields.add('error');
  fields.add('channel');
  fields.add('end');
  fields.add('tag');
end;

{ TFhirSubscription }

Procedure TFhirSubscription.SetCriteria(value : TFhirString);
begin
  FCriteria.free;
  FCriteria := value;
end;

Function TFhirSubscription.GetCriteriaST : String;
begin
  if FCriteria = nil then
    result := ''
  else
    result := FCriteria.value;
end;

Procedure TFhirSubscription.SetCriteriaST(value : String);
begin
  if value <> '' then
  begin
    if FCriteria = nil then
      FCriteria := TFhirString.create;
    FCriteria.value := value
  end
  else if FCriteria <> nil then
    FCriteria.value := '';
end;

Function TFhirSubscription.GetContactList : TFhirContactPointList;
begin
  if FContactList = nil then
    FContactList := TFhirContactPointList.Create;
  result := FContactList;
end;

Function TFhirSubscription.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

Procedure TFhirSubscription.SetReason(value : TFhirString);
begin
  FReason.free;
  FReason := value;
end;

Function TFhirSubscription.GetReasonST : String;
begin
  if FReason = nil then
    result := ''
  else
    result := FReason.value;
end;

Procedure TFhirSubscription.SetReasonST(value : String);
begin
  if value <> '' then
  begin
    if FReason = nil then
      FReason := TFhirString.create;
    FReason.value := value
  end
  else if FReason <> nil then
    FReason.value := '';
end;

Procedure TFhirSubscription.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirSubscription.GetStatusST : TFhirSubscriptionStatusEnum;
begin
  if FStatus = nil then
    result := TFhirSubscriptionStatusEnum(0)
  else
    result := TFhirSubscriptionStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirSubscriptionStatusEnum, FStatus.value));
end;

Procedure TFhirSubscription.SetStatusST(value : TFhirSubscriptionStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirSubscriptionStatusEnum[value], CODES_TFhirSubscriptionStatusEnum[value]);
end;

Procedure TFhirSubscription.SetError(value : TFhirString);
begin
  FError.free;
  FError := value;
end;

Function TFhirSubscription.GetErrorST : String;
begin
  if FError = nil then
    result := ''
  else
    result := FError.value;
end;

Procedure TFhirSubscription.SetErrorST(value : String);
begin
  if value <> '' then
  begin
    if FError = nil then
      FError := TFhirString.create;
    FError.value := value
  end
  else if FError <> nil then
    FError.value := '';
end;

Procedure TFhirSubscription.SetChannel(value : TFhirSubscriptionChannel);
begin
  FChannel.free;
  FChannel := value;
end;

Procedure TFhirSubscription.SetEnd_(value : TFhirInstant);
begin
  FEnd_.free;
  FEnd_ := value;
end;

Function TFhirSubscription.GetEnd_ST : TFslDateTime;
begin
  if FEnd_ = nil then
    result := TFslDateTime.makeNull
  else
    result := FEnd_.value;
end;

Procedure TFhirSubscription.SetEnd_ST(value : TFslDateTime);
begin
  if FEnd_ = nil then
    FEnd_ := TFhirInstant.create;
  FEnd_.value := value
end;

Function TFhirSubscription.GetTagList : TFhirCodingList;
begin
  if FTagList = nil then
    FTagList := TFhirCodingList.Create;
  result := FTagList;
end;

Function TFhirSubscription.GetHasTagList : boolean;
begin
  result := (FTagList <> nil) and (FTagList.count > 0);
end;

function TFhirSubscription.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCriteria.sizeInBytes);
  inc(result, FcontactList.sizeInBytes);
  inc(result, FReason.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FError.sizeInBytes);
  inc(result, FChannel.sizeInBytes);
  inc(result, FEnd_.sizeInBytes);
  inc(result, FtagList.sizeInBytes);
end;

{ TFhirSubscriptionListEnumerator }

Constructor TFhirSubscriptionListEnumerator.Create(list : TFhirSubscriptionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubscriptionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubscriptionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubscriptionListEnumerator.GetCurrent : TFhirSubscription;
begin
  Result := FList[FIndex];
end;

function TFhirSubscriptionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubscriptionList }
procedure TFhirSubscriptionList.AddItem(value: TFhirSubscription);
begin
  assert(value.ClassName = 'TFhirSubscription', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubscription');
  add(value);
end;

function TFhirSubscriptionList.Append: TFhirSubscription;
begin
  result := TFhirSubscription.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionList.ClearItems;
begin
  Clear;
end;

function TFhirSubscriptionList.GetEnumerator : TFhirSubscriptionListEnumerator;
begin
  result := TFhirSubscriptionListEnumerator.Create(self.link);
end;

function TFhirSubscriptionList.Clone: TFhirSubscriptionList;
begin
  result := TFhirSubscriptionList(inherited Clone);
end;

function TFhirSubscriptionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubscriptionList.GetItemN(index: Integer): TFhirSubscription;
begin
  result := TFhirSubscription(ObjectByIndex[index]);
end;

function TFhirSubscriptionList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubscription;
end;
function TFhirSubscriptionList.IndexOf(value: TFhirSubscription): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubscriptionList.Insert(index: Integer): TFhirSubscription;
begin
  result := TFhirSubscription.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionList.InsertItem(index: Integer; value: TFhirSubscription);
begin
  assert(value is TFhirSubscription);
  Inherited Insert(index, value);
end;

function TFhirSubscriptionList.Item(index: Integer): TFhirSubscription;
begin
  result := TFhirSubscription(ObjectByIndex[index]);
end;

function TFhirSubscriptionList.Link: TFhirSubscriptionList;
begin
  result := TFhirSubscriptionList(inherited Link);
end;

procedure TFhirSubscriptionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubscriptionList.SetItemByIndex(index: Integer; value: TFhirSubscription);
begin
  assert(value is TFhirSubscription);
  FhirSubscriptions[index] := value;
end;

procedure TFhirSubscriptionList.SetItemN(index: Integer; value: TFhirSubscription);
begin
  assert(value is TFhirSubscription);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SUBSCRIPTION}

end.

