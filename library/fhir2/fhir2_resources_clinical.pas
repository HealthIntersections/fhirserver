unit fhir2_resources_clinical;

{
  Copyright (c) 2011+, HL7 and Health Intersections Pty Ltd (http://www.healthintersections.com.au)
  All rights reserved.

  Redistribution and use in source and binary forms, with or without modification,
  are permitted provided that the following conditions are met:

   * Redistributions of source code must retain the above copyright notice, this
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice,
     this list of conditions and the following disclaimer in the documentation
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to
     endorse or promote products derived from this software without specific
     prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.

}

{$I fhir.inc}
{$I fhir2.inc}

interface

// FHIR v1.0.2 generated 2015-10-24T07:41:03+11:00

uses
  SysUtils, Classes,
  fsl_base, fsl_utilities, fsl_stream,
  fhir_objects, fhir_utilities, 
  fhir2_base, fhir2_types, fhir2_resources_base;

Type
{$IFDEF FHIR_ACCOUNT}
  TFhirAccount = class;
  TFhirAccountList = class;
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
  TFhirAllergyIntoleranceReaction = class;
  TFhirAllergyIntoleranceReactionList = class;
  TFhirAllergyIntolerance = class;
  TFhirAllergyIntoleranceList = class;
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
  TFhirAppointmentParticipant = class;
  TFhirAppointmentParticipantList = class;
  TFhirAppointment = class;
  TFhirAppointmentList = class;
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
  TFhirAppointmentResponse = class;
  TFhirAppointmentResponseList = class;
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_BASIC}
  TFhirBasic = class;
  TFhirBasicList = class;
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BODYSITE}
  TFhirBodySite = class;
  TFhirBodySiteList = class;
{$ENDIF FHIR_BODYSITE}
{$IFDEF FHIR_CAREPLAN}
  TFhirCarePlanRelatedPlan = class;
  TFhirCarePlanRelatedPlanList = class;
  TFhirCarePlanParticipant = class;
  TFhirCarePlanParticipantList = class;
  TFhirCarePlanActivity = class;
  TFhirCarePlanActivityList = class;
  TFhirCarePlanActivityDetail = class;
  TFhirCarePlanActivityDetailList = class;
  TFhirCarePlan = class;
  TFhirCarePlanList = class;
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CLINICALIMPRESSION}
  TFhirClinicalImpressionInvestigations = class;
  TFhirClinicalImpressionInvestigationsList = class;
  TFhirClinicalImpressionFinding = class;
  TFhirClinicalImpressionFindingList = class;
  TFhirClinicalImpressionRuledOut = class;
  TFhirClinicalImpressionRuledOutList = class;
  TFhirClinicalImpression = class;
  TFhirClinicalImpressionList = class;
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_COMMUNICATION}
  TFhirCommunicationPayload = class;
  TFhirCommunicationPayloadList = class;
  TFhirCommunication = class;
  TFhirCommunicationList = class;
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
  TFhirCommunicationRequestPayload = class;
  TFhirCommunicationRequestPayloadList = class;
  TFhirCommunicationRequest = class;
  TFhirCommunicationRequestList = class;
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPOSITION}
  TFhirCompositionAttester = class;
  TFhirCompositionAttesterList = class;
  TFhirCompositionEvent = class;
  TFhirCompositionEventList = class;
  TFhirCompositionSection = class;
  TFhirCompositionSectionList = class;
  TFhirComposition = class;
  TFhirCompositionList = class;
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONDITION}
  TFhirConditionStage = class;
  TFhirConditionStageList = class;
  TFhirConditionEvidence = class;
  TFhirConditionEvidenceList = class;
  TFhirCondition = class;
  TFhirConditionList = class;
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_COVERAGE}
  TFhirCoverage = class;
  TFhirCoverageList = class;
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_DETECTEDISSUE}
  TFhirDetectedIssueMitigation = class;
  TFhirDetectedIssueMitigationList = class;
  TFhirDetectedIssue = class;
  TFhirDetectedIssueList = class;
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICEUSEREQUEST}
  TFhirDeviceUseRequest = class;
  TFhirDeviceUseRequestList = class;
{$ENDIF FHIR_DEVICEUSEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
  TFhirDeviceUseStatement = class;
  TFhirDeviceUseStatementList = class;
{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICORDER}
  TFhirDiagnosticOrderEvent = class;
  TFhirDiagnosticOrderEventList = class;
  TFhirDiagnosticOrderItem = class;
  TFhirDiagnosticOrderItemList = class;
  TFhirDiagnosticOrder = class;
  TFhirDiagnosticOrderList = class;
{$ENDIF FHIR_DIAGNOSTICORDER}
{$IFDEF FHIR_DIAGNOSTICREPORT}
  TFhirDiagnosticReportImage = class;
  TFhirDiagnosticReportImageList = class;
  TFhirDiagnosticReport = class;
  TFhirDiagnosticReportList = class;
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
  TFhirDocumentManifestContent = class;
  TFhirDocumentManifestContentList = class;
  TFhirDocumentManifestRelated = class;
  TFhirDocumentManifestRelatedList = class;
  TFhirDocumentManifest = class;
  TFhirDocumentManifestList = class;
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
  TFhirDocumentReferenceRelatesTo = class;
  TFhirDocumentReferenceRelatesToList = class;
  TFhirDocumentReferenceContent = class;
  TFhirDocumentReferenceContentList = class;
  TFhirDocumentReferenceContext = class;
  TFhirDocumentReferenceContextList = class;
  TFhirDocumentReferenceContextRelated = class;
  TFhirDocumentReferenceContextRelatedList = class;
  TFhirDocumentReference = class;
  TFhirDocumentReferenceList = class;
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
  TFhirFamilyMemberHistoryCondition = class;
  TFhirFamilyMemberHistoryConditionList = class;
  TFhirFamilyMemberHistory = class;
  TFhirFamilyMemberHistoryList = class;
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
  TFhirFlag = class;
  TFhirFlagList = class;
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
  TFhirGoalOutcome = class;
  TFhirGoalOutcomeList = class;
  TFhirGoal = class;
  TFhirGoalList = class;
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_IMAGINGOBJECTSELECTION}
  TFhirImagingObjectSelectionStudy = class;
  TFhirImagingObjectSelectionStudyList = class;
  TFhirImagingObjectSelectionStudySeries = class;
  TFhirImagingObjectSelectionStudySeriesList = class;
  TFhirImagingObjectSelectionStudySeriesInstance = class;
  TFhirImagingObjectSelectionStudySeriesInstanceList = class;
  TFhirImagingObjectSelectionStudySeriesInstanceFrames = class;
  TFhirImagingObjectSelectionStudySeriesInstanceFramesList = class;
  TFhirImagingObjectSelection = class;
  TFhirImagingObjectSelectionList = class;
{$ENDIF FHIR_IMAGINGOBJECTSELECTION}
{$IFDEF FHIR_IMAGINGSTUDY}
  TFhirImagingStudySeries = class;
  TFhirImagingStudySeriesList = class;
  TFhirImagingStudySeriesInstance = class;
  TFhirImagingStudySeriesInstanceList = class;
  TFhirImagingStudy = class;
  TFhirImagingStudyList = class;
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
  TFhirImmunizationExplanation = class;
  TFhirImmunizationExplanationList = class;
  TFhirImmunizationReaction = class;
  TFhirImmunizationReactionList = class;
  TFhirImmunizationVaccinationProtocol = class;
  TFhirImmunizationVaccinationProtocolList = class;
  TFhirImmunization = class;
  TFhirImmunizationList = class;
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
  TFhirImmunizationRecommendationRecommendation = class;
  TFhirImmunizationRecommendationRecommendationList = class;
  TFhirImmunizationRecommendationRecommendationDateCriterion = class;
  TFhirImmunizationRecommendationRecommendationDateCriterionList = class;
  TFhirImmunizationRecommendationRecommendationProtocol = class;
  TFhirImmunizationRecommendationRecommendationProtocolList = class;
  TFhirImmunizationRecommendation = class;
  TFhirImmunizationRecommendationList = class;
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_MEDIA}
  TFhirMedia = class;
  TFhirMediaList = class;
{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
  TFhirMedicationAdministrationDosage = class;
  TFhirMedicationAdministrationDosageList = class;
  TFhirMedicationAdministration = class;
  TFhirMedicationAdministrationList = class;
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
  TFhirMedicationDispenseDosageInstruction = class;
  TFhirMedicationDispenseDosageInstructionList = class;
  TFhirMedicationDispenseSubstitution = class;
  TFhirMedicationDispenseSubstitutionList = class;
  TFhirMedicationDispense = class;
  TFhirMedicationDispenseList = class;
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONORDER}
  TFhirMedicationOrderDosageInstruction = class;
  TFhirMedicationOrderDosageInstructionList = class;
  TFhirMedicationOrderDispenseRequest = class;
  TFhirMedicationOrderDispenseRequestList = class;
  TFhirMedicationOrderSubstitution = class;
  TFhirMedicationOrderSubstitutionList = class;
  TFhirMedicationOrder = class;
  TFhirMedicationOrderList = class;
{$ENDIF FHIR_MEDICATIONORDER}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
  TFhirMedicationStatementDosage = class;
  TFhirMedicationStatementDosageList = class;
  TFhirMedicationStatement = class;
  TFhirMedicationStatementList = class;
{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_NUTRITIONORDER}
  TFhirNutritionOrderOralDiet = class;
  TFhirNutritionOrderOralDietList = class;
  TFhirNutritionOrderOralDietNutrient = class;
  TFhirNutritionOrderOralDietNutrientList = class;
  TFhirNutritionOrderOralDietTexture = class;
  TFhirNutritionOrderOralDietTextureList = class;
  TFhirNutritionOrderSupplement = class;
  TFhirNutritionOrderSupplementList = class;
  TFhirNutritionOrderEnteralFormula = class;
  TFhirNutritionOrderEnteralFormulaList = class;
  TFhirNutritionOrderEnteralFormulaAdministration = class;
  TFhirNutritionOrderEnteralFormulaAdministrationList = class;
  TFhirNutritionOrder = class;
  TFhirNutritionOrderList = class;
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
  TFhirObservationReferenceRange = class;
  TFhirObservationReferenceRangeList = class;
  TFhirObservationRelated = class;
  TFhirObservationRelatedList = class;
  TFhirObservationComponent = class;
  TFhirObservationComponentList = class;
  TFhirObservation = class;
  TFhirObservationList = class;
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_PROCEDURE}
  TFhirProcedurePerformer = class;
  TFhirProcedurePerformerList = class;
  TFhirProcedureFocalDevice = class;
  TFhirProcedureFocalDeviceList = class;
  TFhirProcedure = class;
  TFhirProcedureList = class;
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROCEDUREREQUEST}
  TFhirProcedureRequest = class;
  TFhirProcedureRequestList = class;
{$ENDIF FHIR_PROCEDUREREQUEST}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
  TFhirQuestionnaireResponseGroup = class;
  TFhirQuestionnaireResponseGroupList = class;
  TFhirQuestionnaireResponseGroupQuestion = class;
  TFhirQuestionnaireResponseGroupQuestionList = class;
  TFhirQuestionnaireResponseGroupQuestionAnswer = class;
  TFhirQuestionnaireResponseGroupQuestionAnswerList = class;
  TFhirQuestionnaireResponse = class;
  TFhirQuestionnaireResponseList = class;
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REFERRALREQUEST}
  TFhirReferralRequest = class;
  TFhirReferralRequestList = class;
{$ENDIF FHIR_REFERRALREQUEST}
{$IFDEF FHIR_RISKASSESSMENT}
  TFhirRiskAssessmentPrediction = class;
  TFhirRiskAssessmentPredictionList = class;
  TFhirRiskAssessment = class;
  TFhirRiskAssessmentList = class;
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SPECIMEN}
  TFhirSpecimenCollection = class;
  TFhirSpecimenCollectionList = class;
  TFhirSpecimenTreatment = class;
  TFhirSpecimenTreatmentList = class;
  TFhirSpecimenContainer = class;
  TFhirSpecimenContainerList = class;
  TFhirSpecimen = class;
  TFhirSpecimenList = class;
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_SUPPLYDELIVERY}
  TFhirSupplyDelivery = class;
  TFhirSupplyDeliveryList = class;
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
  TFhirSupplyRequestWhen = class;
  TFhirSupplyRequestWhenList = class;
  TFhirSupplyRequest = class;
  TFhirSupplyRequestList = class;
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_VISIONPRESCRIPTION}
  TFhirVisionPrescriptionDispense = class;
  TFhirVisionPrescriptionDispenseList = class;
  TFhirVisionPrescription = class;
  TFhirVisionPrescriptionList = class;
{$ENDIF FHIR_VISIONPRESCRIPTION}

{$IFDEF FHIR_ACCOUNT}
  // A financial tool for tracking value accrued for a particular purpose.  In the healthcare field, used to track charges for a patient, cost centres, etc.
  TFhirAccount = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FName : TFhirString;
    FType_ : TFhirCodeableConcept;
    FStatus : TFhirCode;
    FActivePeriod : TFhirPeriod;
    FCurrency : TFhirCoding;
    FBalance : TFhirQuantity;
    FCoveragePeriod : TFhirPeriod;
    FSubject : TFhirReference{Resource};
    FOwner : TFhirReference{TFhirOrganization};
    FDescription : TFhirString;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetStatus(value : TFhirCode);
    Function GetStatusST : String;
    Procedure SetStatusST(value : String);
    Procedure SetActivePeriod(value : TFhirPeriod);
    Procedure SetCurrency(value : TFhirCoding);
    Procedure SetBalance(value : TFhirQuantity);
    Procedure SetCoveragePeriod(value : TFhirPeriod);
    Procedure SetSubject(value : TFhirReference{Resource});
    Procedure SetOwner(value : TFhirReference{TFhirOrganization});
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAccount; overload;
    function Clone : TFhirAccount; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Unique identifier used to reference the account.  May or may not be intended for human use (e.g. credit card number).
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Name used for the account when displaying it to humans in reports, etc.
    property name : String read GetNameST write SetNameST;
    // Name used for the account when displaying it to humans in reports, etc.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Categorizes the account for reporting and searching purposes. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Categorizes the account for reporting and searching purposes.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Indicates whether the account is presently used/useable or not.
    property status : String read GetStatusST write SetStatusST;
    // Indicates whether the account is presently used/useable or not.
    property statusElement : TFhirCode read FStatus write SetStatus;

    // Typed access to Indicates the period of time over which the account is allowed. (defined for API consistency)
    property activePeriod : TFhirPeriod read FActivePeriod write SetActivePeriod;
    // Indicates the period of time over which the account is allowed.
    property activePeriodElement : TFhirPeriod read FActivePeriod write SetActivePeriod;

    // Typed access to Identifies the currency to which transactions must be converted when crediting or debiting the account. (defined for API consistency)
    property currency : TFhirCoding read FCurrency write SetCurrency;
    // Identifies the currency to which transactions must be converted when crediting or debiting the account.
    property currencyElement : TFhirCoding read FCurrency write SetCurrency;

    // Typed access to Represents the sum of all credits less all debits associated with the account.  Might be positive, zero or negative. (defined for API consistency)
    property balance : TFhirQuantity read FBalance write SetBalance;
    // Represents the sum of all credits less all debits associated with the account.  Might be positive, zero or negative.
    property balanceElement : TFhirQuantity read FBalance write SetBalance;

    // Typed access to Identifies the period of time the account applies to; e.g. accounts created per fiscal year, quarter, etc. (defined for API consistency)
    property coveragePeriod : TFhirPeriod read FCoveragePeriod write SetCoveragePeriod;
    // Identifies the period of time the account applies to; e.g. accounts created per fiscal year, quarter, etc.
    property coveragePeriodElement : TFhirPeriod read FCoveragePeriod write SetCoveragePeriod;

    // Typed access to Identifies the patient, device, practitioner, location or other object the account is associated with. (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // Identifies the patient, device, practitioner, location or other object the account is associated with.
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // Typed access to Indicates the organization, department, etc. with responsibility for the account. (defined for API consistency)
    property owner : TFhirReference{TFhirOrganization} read FOwner write SetOwner;
    // Indicates the organization, department, etc. with responsibility for the account.
    property ownerElement : TFhirReference{TFhirOrganization} read FOwner write SetOwner;

    // Typed access to Provides additional information about what the account tracks and how it is used.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Provides additional information about what the account tracks and how it is used.
    property descriptionElement : TFhirString read FDescription write SetDescription;

  end;

  TFhirAccountListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAccountList;
    function GetCurrent : TFhirAccount;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAccountList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAccount read GetCurrent;
  end;

  TFhirAccountList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirAccount;
    procedure SetItemN(index : Integer; value : TFhirAccount);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirAccountList; Overload;
    function Clone : TFhirAccountList; Overload;
    function GetEnumerator : TFhirAccountListEnumerator;

    //  Add a FhirAccount to the end of the list.
    function Append : TFhirAccount;

    // Add an already existing FhirAccount to the end of the list.
    procedure AddItem(value : TFhirAccount); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAccount) : Integer;

    // Insert FhirAccount before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAccount;

    // Insert an existing FhirAccount before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAccount);

    // Get the iIndexth FhirAccount. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAccount);

    // The number of items in the collection
    function Item(index : Integer) : TFhirAccount;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirAccounts[index : Integer] : TFhirAccount read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ACCOUNT}

{$IFDEF FHIR_ALLERGYINTOLERANCE}

  // Details about each adverse reaction event linked to exposure to the identified Substance.
  TFhirAllergyIntoleranceReaction = class (TFhirBackboneElement)
  protected
    FSubstance : TFhirCodeableConcept;
    FCertainty : TFhirEnum;
    FmanifestationList : TFhirCodeableConceptList;
    FDescription : TFhirString;
    FOnset : TFhirDateTime;
    FSeverity : TFhirEnum;
    FExposureRoute : TFhirCodeableConcept;
    FNote : TFhirAnnotation;
    Procedure SetSubstance(value : TFhirCodeableConcept);
    Procedure SetCertainty(value : TFhirEnum);
    Function GetCertaintyST : TFhirReactionEventCertaintyEnum;
    Procedure SetCertaintyST(value : TFhirReactionEventCertaintyEnum);
    function GetManifestationList : TFhirCodeableConceptList;
    function GetHasManifestationList : Boolean;
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetOnset(value : TFhirDateTime);
    Function GetOnsetST : TFslDateTime;
    Procedure SetOnsetST(value : TFslDateTime);
    Procedure SetSeverity(value : TFhirEnum);
    Function GetSeverityST : TFhirReactionEventSeverityEnum;
    Procedure SetSeverityST(value : TFhirReactionEventSeverityEnum);
    Procedure SetExposureRoute(value : TFhirCodeableConcept);
    Procedure SetNote(value : TFhirAnnotation);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAllergyIntoleranceReaction; overload;
    function Clone : TFhirAllergyIntoleranceReaction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Identification of the specific substance considered to be responsible for the Adverse Reaction event. Note: the substance for a specific reaction may be different to the substance identified as the cause of the risk, but must be consistent with it. For instance, it may be a more specific substance (e.g. a brand medication) or a composite substance that includes the identified substance. It must be clinically safe to only process the AllergyIntolerance.substance and ignore the AllergyIntolerance.event.substance. (defined for API consistency)
    property substance : TFhirCodeableConcept read FSubstance write SetSubstance;
    // Identification of the specific substance considered to be responsible for the Adverse Reaction event. Note: the substance for a specific reaction may be different to the substance identified as the cause of the risk, but must be consistent with it. For instance, it may be a more specific substance (e.g. a brand medication) or a composite substance that includes the identified substance. It must be clinically safe to only process the AllergyIntolerance.substance and ignore the AllergyIntolerance.event.substance.
    property substanceElement : TFhirCodeableConcept read FSubstance write SetSubstance;

    // Statement about the degree of clinical certainty that the specific substance was the cause of the manifestation in this reaction event.
    property certainty : TFhirReactionEventCertaintyEnum read GetCertaintyST write SetCertaintyST;
    property certaintyElement : TFhirEnum read FCertainty write SetCertainty;

    // Clinical symptoms and/or signs that are observed or associated with the adverse reaction event.
    property manifestationList : TFhirCodeableConceptList read GetManifestationList;
    property hasManifestationList : boolean read GetHasManifestationList;

    // Typed access to Text description about the reaction as a whole, including details of the manifestation if required.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Text description about the reaction as a whole, including details of the manifestation if required.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Record of the date and/or time of the onset of the Reaction.
    property onset : TFslDateTime read GetOnsetST write SetOnsetST;
    // Record of the date and/or time of the onset of the Reaction.
    property onsetElement : TFhirDateTime read FOnset write SetOnset;

    // Clinical assessment of the severity of the reaction event as a whole, potentially considering multiple different manifestations.
    property severity : TFhirReactionEventSeverityEnum read GetSeverityST write SetSeverityST;
    property severityElement : TFhirEnum read FSeverity write SetSeverity;

    // Typed access to Identification of the route by which the subject was exposed to the substance. (defined for API consistency)
    property exposureRoute : TFhirCodeableConcept read FExposureRoute write SetExposureRoute;
    // Identification of the route by which the subject was exposed to the substance.
    property exposureRouteElement : TFhirCodeableConcept read FExposureRoute write SetExposureRoute;

    // Typed access to Additional text about the adverse reaction event not captured in other fields. (defined for API consistency)
    property note : TFhirAnnotation read FNote write SetNote;
    // Additional text about the adverse reaction event not captured in other fields.
    property noteElement : TFhirAnnotation read FNote write SetNote;

  end;

  TFhirAllergyIntoleranceReactionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAllergyIntoleranceReactionList;
    function GetCurrent : TFhirAllergyIntoleranceReaction;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAllergyIntoleranceReactionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAllergyIntoleranceReaction read GetCurrent;
  end;

  TFhirAllergyIntoleranceReactionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirAllergyIntoleranceReaction;
    procedure SetItemN(index : Integer; value : TFhirAllergyIntoleranceReaction);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirAllergyIntoleranceReactionList; Overload;
    function Clone : TFhirAllergyIntoleranceReactionList; Overload;
    function GetEnumerator : TFhirAllergyIntoleranceReactionListEnumerator;

    //  Add a FhirAllergyIntoleranceReaction to the end of the list.
    function Append : TFhirAllergyIntoleranceReaction;

    // Add an already existing FhirAllergyIntoleranceReaction to the end of the list.
    procedure AddItem(value : TFhirAllergyIntoleranceReaction); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAllergyIntoleranceReaction) : Integer;

    // Insert FhirAllergyIntoleranceReaction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAllergyIntoleranceReaction;

    // Insert an existing FhirAllergyIntoleranceReaction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAllergyIntoleranceReaction);

    // Get the iIndexth FhirAllergyIntoleranceReaction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAllergyIntoleranceReaction);

    // The number of items in the collection
    function Item(index : Integer) : TFhirAllergyIntoleranceReaction;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirAllergyIntoleranceReactions[index : Integer] : TFhirAllergyIntoleranceReaction read GetItemN write SetItemN; default;
  End;

  // Risk of harmful or undesirable, physiological response which is unique to an individual and associated with exposure to a substance.
  TFhirAllergyIntolerance = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FOnset : TFhirDateTime;
    FRecordedDate : TFhirDateTime;
    FRecorder : TFhirReference{Resource};
    FPatient : TFhirReference{TFhirPatient};
    FReporter : TFhirReference{Resource};
    FSubstance : TFhirCodeableConcept;
    FStatus : TFhirEnum;
    FCriticality : TFhirEnum;
    FType_ : TFhirEnum;
    FCategory : TFhirEnum;
    FLastOccurence : TFhirDateTime;
    FNote : TFhirAnnotation;
    FreactionList : TFhirAllergyIntoleranceReactionList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetOnset(value : TFhirDateTime);
    Function GetOnsetST : TFslDateTime;
    Procedure SetOnsetST(value : TFslDateTime);
    Procedure SetRecordedDate(value : TFhirDateTime);
    Function GetRecordedDateST : TFslDateTime;
    Procedure SetRecordedDateST(value : TFslDateTime);
    Procedure SetRecorder(value : TFhirReference{Resource});
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    Procedure SetReporter(value : TFhirReference{Resource});
    Procedure SetSubstance(value : TFhirCodeableConcept);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirAllergyIntoleranceStatusEnum;
    Procedure SetStatusST(value : TFhirAllergyIntoleranceStatusEnum);
    Procedure SetCriticality(value : TFhirEnum);
    Function GetCriticalityST : TFhirAllergyIntoleranceCriticalityEnum;
    Procedure SetCriticalityST(value : TFhirAllergyIntoleranceCriticalityEnum);
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirAllergyIntoleranceTypeEnum;
    Procedure SetType_ST(value : TFhirAllergyIntoleranceTypeEnum);
    Procedure SetCategory(value : TFhirEnum);
    Function GetCategoryST : TFhirAllergyIntoleranceCategoryEnum;
    Procedure SetCategoryST(value : TFhirAllergyIntoleranceCategoryEnum);
    Procedure SetLastOccurence(value : TFhirDateTime);
    Function GetLastOccurenceST : TFslDateTime;
    Procedure SetLastOccurenceST(value : TFslDateTime);
    Procedure SetNote(value : TFhirAnnotation);
    function GetReactionList : TFhirAllergyIntoleranceReactionList;
    function GetHasReactionList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAllergyIntolerance; overload;
    function Clone : TFhirAllergyIntolerance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // This records identifiers associated with this allergy/intolerance concern that are defined by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate (e.g. in CDA documents, or in written / printed documentation).
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Record of the date and/or time of the onset of the Allergy or Intolerance.
    property onset : TFslDateTime read GetOnsetST write SetOnsetST;
    // Record of the date and/or time of the onset of the Allergy or Intolerance.
    property onsetElement : TFhirDateTime read FOnset write SetOnset;

    // Typed access to Date when the sensitivity was recorded.
    property recordedDate : TFslDateTime read GetRecordedDateST write SetRecordedDateST;
    // Date when the sensitivity was recorded.
    property recordedDateElement : TFhirDateTime read FRecordedDate write SetRecordedDate;

    // Typed access to Individual who recorded the record and takes responsibility for its conten. (defined for API consistency)
    property recorder : TFhirReference{Resource} read FRecorder write SetRecorder;
    // Individual who recorded the record and takes responsibility for its conten.
    property recorderElement : TFhirReference{Resource} read FRecorder write SetRecorder;

    // Typed access to The patient who has the allergy or intolerance. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // The patient who has the allergy or intolerance.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Typed access to The source of the information about the allergy that is recorded. (defined for API consistency)
    property reporter : TFhirReference{Resource} read FReporter write SetReporter;
    // The source of the information about the allergy that is recorded.
    property reporterElement : TFhirReference{Resource} read FReporter write SetReporter;

    // Typed access to Identification of a substance, or a class of substances, that is considered to be responsible for the adverse reaction risk. (defined for API consistency)
    property substance : TFhirCodeableConcept read FSubstance write SetSubstance;
    // Identification of a substance, or a class of substances, that is considered to be responsible for the adverse reaction risk.
    property substanceElement : TFhirCodeableConcept read FSubstance write SetSubstance;

    // Assertion about certainty associated with the propensity, or potential risk, of a reaction to the identified Substance.
    property status : TFhirAllergyIntoleranceStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Estimate of the potential clinical harm, or seriousness, of the reaction to the identified Substance.
    property criticality : TFhirAllergyIntoleranceCriticalityEnum read GetCriticalityST write SetCriticalityST;
    property criticalityElement : TFhirEnum read FCriticality write SetCriticality;

    // Identification of the underlying physiological mechanism for the reaction risk.
    property type_ : TFhirAllergyIntoleranceTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Category of the identified Substance.
    property category : TFhirAllergyIntoleranceCategoryEnum read GetCategoryST write SetCategoryST;
    property categoryElement : TFhirEnum read FCategory write SetCategory;

    // Typed access to Represents the date and/or time of the last known occurrence of a reaction event.
    property lastOccurence : TFslDateTime read GetLastOccurenceST write SetLastOccurenceST;
    // Represents the date and/or time of the last known occurrence of a reaction event.
    property lastOccurenceElement : TFhirDateTime read FLastOccurence write SetLastOccurence;

    // Typed access to Additional narrative about the propensity for the Adverse Reaction, not captured in other fields. (defined for API consistency)
    property note : TFhirAnnotation read FNote write SetNote;
    // Additional narrative about the propensity for the Adverse Reaction, not captured in other fields.
    property noteElement : TFhirAnnotation read FNote write SetNote;

    // Details about each adverse reaction event linked to exposure to the identified Substance.
    property reactionList : TFhirAllergyIntoleranceReactionList read GetReactionList;
    property hasReactionList : boolean read GetHasReactionList;

  end;

  TFhirAllergyIntoleranceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAllergyIntoleranceList;
    function GetCurrent : TFhirAllergyIntolerance;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAllergyIntoleranceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAllergyIntolerance read GetCurrent;
  end;

  TFhirAllergyIntoleranceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirAllergyIntolerance;
    procedure SetItemN(index : Integer; value : TFhirAllergyIntolerance);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirAllergyIntoleranceList; Overload;
    function Clone : TFhirAllergyIntoleranceList; Overload;
    function GetEnumerator : TFhirAllergyIntoleranceListEnumerator;

    //  Add a FhirAllergyIntolerance to the end of the list.
    function Append : TFhirAllergyIntolerance;

    // Add an already existing FhirAllergyIntolerance to the end of the list.
    procedure AddItem(value : TFhirAllergyIntolerance); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAllergyIntolerance) : Integer;

    // Insert FhirAllergyIntolerance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAllergyIntolerance;

    // Insert an existing FhirAllergyIntolerance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAllergyIntolerance);

    // Get the iIndexth FhirAllergyIntolerance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAllergyIntolerance);

    // The number of items in the collection
    function Item(index : Integer) : TFhirAllergyIntolerance;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirAllergyIntolerances[index : Integer] : TFhirAllergyIntolerance read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ALLERGYINTOLERANCE}

{$IFDEF FHIR_APPOINTMENT}

  // List of participants involved in the appointment.
  TFhirAppointmentParticipant = class (TFhirBackboneElement)
  protected
    Ftype_List : TFhirCodeableConceptList;
    FActor : TFhirReference{Resource};
    FRequired : TFhirEnum;
    FStatus : TFhirEnum;
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    Procedure SetActor(value : TFhirReference{Resource});
    Procedure SetRequired(value : TFhirEnum);
    Function GetRequiredST : TFhirParticipantrequiredEnum;
    Procedure SetRequiredST(value : TFhirParticipantrequiredEnum);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirParticipationstatusEnum;
    Procedure SetStatusST(value : TFhirParticipationstatusEnum);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAppointmentParticipant; overload;
    function Clone : TFhirAppointmentParticipant; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Role of participant in the appointment.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Typed access to A Person, Location/HealthcareService or Device that is participating in the appointment. (defined for API consistency)
    property actor : TFhirReference{Resource} read FActor write SetActor;
    // A Person, Location/HealthcareService or Device that is participating in the appointment.
    property actorElement : TFhirReference{Resource} read FActor write SetActor;

    // Is this participant required to be present at the meeting. This covers a use-case where 2 doctors need to meet to discuss the results for a specific patient, and the patient is not required to be present.
    property required : TFhirParticipantrequiredEnum read GetRequiredST write SetRequiredST;
    property requiredElement : TFhirEnum read FRequired write SetRequired;

    // Participation status of the Patient.
    property status : TFhirParticipationstatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

  end;

  TFhirAppointmentParticipantListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAppointmentParticipantList;
    function GetCurrent : TFhirAppointmentParticipant;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAppointmentParticipantList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAppointmentParticipant read GetCurrent;
  end;

  TFhirAppointmentParticipantList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirAppointmentParticipant;
    procedure SetItemN(index : Integer; value : TFhirAppointmentParticipant);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirAppointmentParticipantList; Overload;
    function Clone : TFhirAppointmentParticipantList; Overload;
    function GetEnumerator : TFhirAppointmentParticipantListEnumerator;

    //  Add a FhirAppointmentParticipant to the end of the list.
    function Append : TFhirAppointmentParticipant;

    // Add an already existing FhirAppointmentParticipant to the end of the list.
    procedure AddItem(value : TFhirAppointmentParticipant); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAppointmentParticipant) : Integer;

    // Insert FhirAppointmentParticipant before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAppointmentParticipant;

    // Insert an existing FhirAppointmentParticipant before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAppointmentParticipant);

    // Get the iIndexth FhirAppointmentParticipant. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAppointmentParticipant);

    // The number of items in the collection
    function Item(index : Integer) : TFhirAppointmentParticipant;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirAppointmentParticipants[index : Integer] : TFhirAppointmentParticipant read GetItemN write SetItemN; default;
  End;

  // A booking of a healthcare event among patient(s), practitioner(s), related person(s) and/or device(s) for a specific date/time. This may result in one or more Encounter(s).
  TFhirAppointment = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FType_ : TFhirCodeableConcept;
    FReason : TFhirCodeableConcept;
    FPriority : TFhirUnsignedInt;
    FDescription : TFhirString;
    FStart : TFhirInstant;
    FEnd_ : TFhirInstant;
    FMinutesDuration : TFhirPositiveInt;
    FslotList : TFhirReferenceList{TFhirSlot};
    FComment : TFhirString;
    FparticipantList : TFhirAppointmentParticipantList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirAppointmentstatusEnum;
    Procedure SetStatusST(value : TFhirAppointmentstatusEnum);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetReason(value : TFhirCodeableConcept);
    Procedure SetPriority(value : TFhirUnsignedInt);
    Function GetPriorityST : String;
    Procedure SetPriorityST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetStart(value : TFhirInstant);
    Function GetStartST : TFslDateTime;
    Procedure SetStartST(value : TFslDateTime);
    Procedure SetEnd_(value : TFhirInstant);
    Function GetEnd_ST : TFslDateTime;
    Procedure SetEnd_ST(value : TFslDateTime);
    Procedure SetMinutesDuration(value : TFhirPositiveInt);
    Function GetMinutesDurationST : String;
    Procedure SetMinutesDurationST(value : String);
    function GetSlotList : TFhirReferenceList{TFhirSlot};
    function GetHasSlotList : Boolean;
    Procedure SetComment(value : TFhirString);
    Function GetCommentST : String;
    Procedure SetCommentST(value : String);
    function GetParticipantList : TFhirAppointmentParticipantList;
    function GetHasParticipantList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAppointment; overload;
    function Clone : TFhirAppointment; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // This records identifiers associated with this appointment concern that are defined by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate (e.g. in CDA documents, or in written / printed documentation).
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The overall status of the Appointment. Each of the participants has their own participation status which indicates their involvement in the process, however this status indicates the shared status.
    property status : TFhirAppointmentstatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The type of appointment that is being booked (This may also be associated with participants for location, and/or a HealthcareService). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of appointment that is being booked (This may also be associated with participants for location, and/or a HealthcareService).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The reason that this appointment is being scheduled. This is more clinical than administrative. (defined for API consistency)
    property reason : TFhirCodeableConcept read FReason write SetReason;
    // The reason that this appointment is being scheduled. This is more clinical than administrative.
    property reasonElement : TFhirCodeableConcept read FReason write SetReason;

    // Typed access to The priority of the appointment. Can be used to make informed decisions if needing to re-prioritize appointments. (The iCal Standard specifies 0 as undefined, 1 as highest, 9 as lowest priority).
    property priority : String read GetPriorityST write SetPriorityST;
    // The priority of the appointment. Can be used to make informed decisions if needing to re-prioritize appointments. (The iCal Standard specifies 0 as undefined, 1 as highest, 9 as lowest priority).
    property priorityElement : TFhirUnsignedInt read FPriority write SetPriority;

    // Typed access to The brief description of the appointment as would be shown on a subject line in a meeting request, or appointment list. Detailed or expanded information should be put in the comment field.
    property description : String read GetDescriptionST write SetDescriptionST;
    // The brief description of the appointment as would be shown on a subject line in a meeting request, or appointment list. Detailed or expanded information should be put in the comment field.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Date/Time that the appointment is to take place.
    property start : TFslDateTime read GetStartST write SetStartST;
    // Date/Time that the appointment is to take place.
    property startElement : TFhirInstant read FStart write SetStart;

    // Typed access to Date/Time that the appointment is to conclude.
    property end_ : TFslDateTime read GetEnd_ST write SetEnd_ST;
    // Date/Time that the appointment is to conclude.
    property end_Element : TFhirInstant read FEnd_ write SetEnd_;

    // Typed access to Number of minutes that the appointment is to take. This can be less than the duration between the start and end times (where actual time of appointment is only an estimate or is a planned appointment request).
    property minutesDuration : String read GetMinutesDurationST write SetMinutesDurationST;
    // Number of minutes that the appointment is to take. This can be less than the duration between the start and end times (where actual time of appointment is only an estimate or is a planned appointment request).
    property minutesDurationElement : TFhirPositiveInt read FMinutesDuration write SetMinutesDuration;

    // The slot that this appointment is filling. If provided then the schedule will not be provided as slots are not recursive, and the start/end values MUST be the same as from the slot.
    property slotList : TFhirReferenceList{TFhirSlot} read GetSlotList;
    property hasSlotList : boolean read GetHasSlotList;

    // Typed access to Additional comments about the appointment.
    property comment : String read GetCommentST write SetCommentST;
    // Additional comments about the appointment.
    property commentElement : TFhirString read FComment write SetComment;

    // List of participants involved in the appointment.
    property participantList : TFhirAppointmentParticipantList read GetParticipantList;
    property hasParticipantList : boolean read GetHasParticipantList;

  end;

  TFhirAppointmentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAppointmentList;
    function GetCurrent : TFhirAppointment;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAppointmentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAppointment read GetCurrent;
  end;

  TFhirAppointmentList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirAppointment;
    procedure SetItemN(index : Integer; value : TFhirAppointment);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirAppointmentList; Overload;
    function Clone : TFhirAppointmentList; Overload;
    function GetEnumerator : TFhirAppointmentListEnumerator;

    //  Add a FhirAppointment to the end of the list.
    function Append : TFhirAppointment;

    // Add an already existing FhirAppointment to the end of the list.
    procedure AddItem(value : TFhirAppointment); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAppointment) : Integer;

    // Insert FhirAppointment before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAppointment;

    // Insert an existing FhirAppointment before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAppointment);

    // Get the iIndexth FhirAppointment. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAppointment);

    // The number of items in the collection
    function Item(index : Integer) : TFhirAppointment;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirAppointments[index : Integer] : TFhirAppointment read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_APPOINTMENT}

{$IFDEF FHIR_APPOINTMENTRESPONSE}

  // A reply to an appointment request for a patient and/or practitioner(s), such as a confirmation or rejection.
  TFhirAppointmentResponse = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FAppointment : TFhirReference{TFhirAppointment};
    FStart : TFhirInstant;
    FEnd_ : TFhirInstant;
    FparticipantTypeList : TFhirCodeableConceptList;
    FActor : TFhirReference{Resource};
    FParticipantStatus : TFhirEnum;
    FComment : TFhirString;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetAppointment(value : TFhirReference{TFhirAppointment});
    Procedure SetStart(value : TFhirInstant);
    Function GetStartST : TFslDateTime;
    Procedure SetStartST(value : TFslDateTime);
    Procedure SetEnd_(value : TFhirInstant);
    Function GetEnd_ST : TFslDateTime;
    Procedure SetEnd_ST(value : TFslDateTime);
    function GetParticipantTypeList : TFhirCodeableConceptList;
    function GetHasParticipantTypeList : Boolean;
    Procedure SetActor(value : TFhirReference{Resource});
    Procedure SetParticipantStatus(value : TFhirEnum);
    Function GetParticipantStatusST : TFhirParticipantstatusEnum;
    Procedure SetParticipantStatusST(value : TFhirParticipantstatusEnum);
    Procedure SetComment(value : TFhirString);
    Function GetCommentST : String;
    Procedure SetCommentST(value : String);

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAppointmentResponse; overload;
    function Clone : TFhirAppointmentResponse; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // This records identifiers associated with this appointment response concern that are defined by business processes and/ or used to refer to it when a direct URL reference to the resource itself is not appropriate.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Appointment that this response is replying to. (defined for API consistency)
    property appointment : TFhirReference{TFhirAppointment} read FAppointment write SetAppointment;
    // Appointment that this response is replying to.
    property appointmentElement : TFhirReference{TFhirAppointment} read FAppointment write SetAppointment;

    // Typed access to Date/Time that the appointment is to take place, or requested new start time.
    property start : TFslDateTime read GetStartST write SetStartST;
    // Date/Time that the appointment is to take place, or requested new start time.
    property startElement : TFhirInstant read FStart write SetStart;

    // Typed access to This may be either the same as the appointment request to confirm the details of the appointment, or alternately a new time to request a re-negotiation of the end time.
    property end_ : TFslDateTime read GetEnd_ST write SetEnd_ST;
    // This may be either the same as the appointment request to confirm the details of the appointment, or alternately a new time to request a re-negotiation of the end time.
    property end_Element : TFhirInstant read FEnd_ write SetEnd_;

    // Role of participant in the appointment.
    property participantTypeList : TFhirCodeableConceptList read GetParticipantTypeList;
    property hasParticipantTypeList : boolean read GetHasParticipantTypeList;

    // Typed access to A Person, Location/HealthcareService or Device that is participating in the appointment. (defined for API consistency)
    property actor : TFhirReference{Resource} read FActor write SetActor;
    // A Person, Location/HealthcareService or Device that is participating in the appointment.
    property actorElement : TFhirReference{Resource} read FActor write SetActor;

    // Participation status of the participant. When the status is declined or tentative if the start/end times are different to the appointment, then these times should be interpreted as a requested time change. When the status is accepted, the times can either be the time of the appointment (as a confirmation of the time) or can be empty.
    property participantStatus : TFhirParticipantstatusEnum read GetParticipantStatusST write SetParticipantStatusST;
    property participantStatusElement : TFhirEnum read FParticipantStatus write SetParticipantStatus;

    // Typed access to Additional comments about the appointment.
    property comment : String read GetCommentST write SetCommentST;
    // Additional comments about the appointment.
    property commentElement : TFhirString read FComment write SetComment;

  end;

  TFhirAppointmentResponseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAppointmentResponseList;
    function GetCurrent : TFhirAppointmentResponse;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAppointmentResponseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAppointmentResponse read GetCurrent;
  end;

  TFhirAppointmentResponseList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirAppointmentResponse;
    procedure SetItemN(index : Integer; value : TFhirAppointmentResponse);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirAppointmentResponseList; Overload;
    function Clone : TFhirAppointmentResponseList; Overload;
    function GetEnumerator : TFhirAppointmentResponseListEnumerator;

    //  Add a FhirAppointmentResponse to the end of the list.
    function Append : TFhirAppointmentResponse;

    // Add an already existing FhirAppointmentResponse to the end of the list.
    procedure AddItem(value : TFhirAppointmentResponse); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAppointmentResponse) : Integer;

    // Insert FhirAppointmentResponse before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAppointmentResponse;

    // Insert an existing FhirAppointmentResponse before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAppointmentResponse);

    // Get the iIndexth FhirAppointmentResponse. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAppointmentResponse);

    // The number of items in the collection
    function Item(index : Integer) : TFhirAppointmentResponse;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirAppointmentResponses[index : Integer] : TFhirAppointmentResponse read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_APPOINTMENTRESPONSE}

{$IFDEF FHIR_BASIC}

  // Basic is used for handling concepts not yet defined in FHIR, narrative-only resources that don't map to an existing resource, and custom resources not appropriate for inclusion in the FHIR specification.
  TFhirBasic = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FCode : TFhirCodeableConcept;
    FSubject : TFhirReference{TFhirReference};
    FAuthor : TFhirReference{Resource};
    FCreated : TFhirDate;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetSubject(value : TFhirReference{TFhirReference});
    Procedure SetAuthor(value : TFhirReference{Resource});
    Procedure SetCreated(value : TFhirDate);
    Function GetCreatedST : TFslDateTime;
    Procedure SetCreatedST(value : TFslDateTime);

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBasic; overload;
    function Clone : TFhirBasic; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifier assigned to the resource for business purposes, outside the context of FHIR.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Identifies the 'type' of resource - equivalent to the resource name for other resources. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Identifies the 'type' of resource - equivalent to the resource name for other resources.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to Identifies the patient, practitioner, device or any other resource that is the "focus" of this resource. (defined for API consistency)
    property subject : TFhirReference{TFhirReference} read FSubject write SetSubject;
    // Identifies the patient, practitioner, device or any other resource that is the "focus" of this resource.
    property subjectElement : TFhirReference{TFhirReference} read FSubject write SetSubject;

    // Typed access to Indicates who was responsible for creating the resource instance. (defined for API consistency)
    property author : TFhirReference{Resource} read FAuthor write SetAuthor;
    // Indicates who was responsible for creating the resource instance.
    property authorElement : TFhirReference{Resource} read FAuthor write SetAuthor;

    // Typed access to Identifies when the resource was first created.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // Identifies when the resource was first created.
    property createdElement : TFhirDate read FCreated write SetCreated;

  end;

  TFhirBasicListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBasicList;
    function GetCurrent : TFhirBasic;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirBasicList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBasic read GetCurrent;
  end;

  TFhirBasicList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirBasic;
    procedure SetItemN(index : Integer; value : TFhirBasic);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirBasicList; Overload;
    function Clone : TFhirBasicList; Overload;
    function GetEnumerator : TFhirBasicListEnumerator;

    //  Add a FhirBasic to the end of the list.
    function Append : TFhirBasic;

    // Add an already existing FhirBasic to the end of the list.
    procedure AddItem(value : TFhirBasic); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBasic) : Integer;

    // Insert FhirBasic before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBasic;

    // Insert an existing FhirBasic before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBasic);

    // Get the iIndexth FhirBasic. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBasic);

    // The number of items in the collection
    function Item(index : Integer) : TFhirBasic;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirBasics[index : Integer] : TFhirBasic read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_BASIC}

{$IFDEF FHIR_BODYSITE}

  // Record details about the anatomical location of a specimen or body part.  This resource may be used when a coded concept does not provide the necessary detail needed for the use case.
  TFhirBodySite = class (TFhirDomainResource)
  protected
    FPatient : TFhirReference{TFhirPatient};
    FidentifierList : TFhirIdentifierList;
    FCode : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FDescription : TFhirString;
    FimageList : TFhirAttachmentList;
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetCode(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    function GetImageList : TFhirAttachmentList;
    function GetHasImageList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBodySite; overload;
    function Clone : TFhirBodySite; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The person to which the body site belongs. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // The person to which the body site belongs.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Identifier for this instance of the anatomical location.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Named anatomical location - ideally coded where possible. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Named anatomical location - ideally coded where possible.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Modifier to refine the anatomical location.  These include modifiers for laterality, relative location, directionality, number, and plane.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Typed access to Description of anatomical location.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Description of anatomical location.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Image or images used to identify a location.
    property imageList : TFhirAttachmentList read GetImageList;
    property hasImageList : boolean read GetHasImageList;

  end;

  TFhirBodySiteListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBodySiteList;
    function GetCurrent : TFhirBodySite;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirBodySiteList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBodySite read GetCurrent;
  end;

  TFhirBodySiteList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirBodySite;
    procedure SetItemN(index : Integer; value : TFhirBodySite);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirBodySiteList; Overload;
    function Clone : TFhirBodySiteList; Overload;
    function GetEnumerator : TFhirBodySiteListEnumerator;

    //  Add a FhirBodySite to the end of the list.
    function Append : TFhirBodySite;

    // Add an already existing FhirBodySite to the end of the list.
    procedure AddItem(value : TFhirBodySite); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBodySite) : Integer;

    // Insert FhirBodySite before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBodySite;

    // Insert an existing FhirBodySite before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBodySite);

    // Get the iIndexth FhirBodySite. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBodySite);

    // The number of items in the collection
    function Item(index : Integer) : TFhirBodySite;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirBodySites[index : Integer] : TFhirBodySite read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_BODYSITE}

{$IFDEF FHIR_CAREPLAN}

  // Identifies CarePlans with some sort of formal relationship to the current plan.
  TFhirCarePlanRelatedPlan = class (TFhirBackboneElement)
  protected
    FCode : TFhirEnum;
    FPlan : TFhirReference{TFhirCarePlan};
    Procedure SetCode(value : TFhirEnum);
    Function GetCodeST : TFhirCarePlanRelationshipEnum;
    Procedure SetCodeST(value : TFhirCarePlanRelationshipEnum);
    Procedure SetPlan(value : TFhirReference{TFhirCarePlan});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCarePlanRelatedPlan; overload;
    function Clone : TFhirCarePlanRelatedPlan; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifies the type of relationship this plan has to the target plan.
    property code : TFhirCarePlanRelationshipEnum read GetCodeST write SetCodeST;
    property codeElement : TFhirEnum read FCode write SetCode;

    // Typed access to A reference to the plan to which a relationship is asserted. (defined for API consistency)
    property plan : TFhirReference{TFhirCarePlan} read FPlan write SetPlan;
    // A reference to the plan to which a relationship is asserted.
    property planElement : TFhirReference{TFhirCarePlan} read FPlan write SetPlan;

  end;

  TFhirCarePlanRelatedPlanListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCarePlanRelatedPlanList;
    function GetCurrent : TFhirCarePlanRelatedPlan;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCarePlanRelatedPlanList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCarePlanRelatedPlan read GetCurrent;
  end;

  TFhirCarePlanRelatedPlanList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCarePlanRelatedPlan;
    procedure SetItemN(index : Integer; value : TFhirCarePlanRelatedPlan);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCarePlanRelatedPlanList; Overload;
    function Clone : TFhirCarePlanRelatedPlanList; Overload;
    function GetEnumerator : TFhirCarePlanRelatedPlanListEnumerator;

    //  Add a FhirCarePlanRelatedPlan to the end of the list.
    function Append : TFhirCarePlanRelatedPlan;

    // Add an already existing FhirCarePlanRelatedPlan to the end of the list.
    procedure AddItem(value : TFhirCarePlanRelatedPlan); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCarePlanRelatedPlan) : Integer;

    // Insert FhirCarePlanRelatedPlan before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCarePlanRelatedPlan;

    // Insert an existing FhirCarePlanRelatedPlan before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCarePlanRelatedPlan);

    // Get the iIndexth FhirCarePlanRelatedPlan. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCarePlanRelatedPlan);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCarePlanRelatedPlan;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCarePlanRelatedPlans[index : Integer] : TFhirCarePlanRelatedPlan read GetItemN write SetItemN; default;
  End;

  // Identifies all people and organizations who are expected to be involved in the care envisioned by this plan.
  TFhirCarePlanParticipant = class (TFhirBackboneElement)
  protected
    FRole : TFhirCodeableConcept;
    FMember : TFhirReference{Resource};
    Procedure SetRole(value : TFhirCodeableConcept);
    Procedure SetMember(value : TFhirReference{Resource});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCarePlanParticipant; overload;
    function Clone : TFhirCarePlanParticipant; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Indicates specific responsibility of an individual within the care plan; e.g. "Primary physician", "Team coordinator", "Caregiver", etc. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // Indicates specific responsibility of an individual within the care plan; e.g. "Primary physician", "Team coordinator", "Caregiver", etc.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

    // Typed access to The specific person or organization who is participating/expected to participate in the care plan. (defined for API consistency)
    property member : TFhirReference{Resource} read FMember write SetMember;
    // The specific person or organization who is participating/expected to participate in the care plan.
    property memberElement : TFhirReference{Resource} read FMember write SetMember;

  end;

  TFhirCarePlanParticipantListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCarePlanParticipantList;
    function GetCurrent : TFhirCarePlanParticipant;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCarePlanParticipantList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCarePlanParticipant read GetCurrent;
  end;

  TFhirCarePlanParticipantList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCarePlanParticipant;
    procedure SetItemN(index : Integer; value : TFhirCarePlanParticipant);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCarePlanParticipantList; Overload;
    function Clone : TFhirCarePlanParticipantList; Overload;
    function GetEnumerator : TFhirCarePlanParticipantListEnumerator;

    //  Add a FhirCarePlanParticipant to the end of the list.
    function Append : TFhirCarePlanParticipant;

    // Add an already existing FhirCarePlanParticipant to the end of the list.
    procedure AddItem(value : TFhirCarePlanParticipant); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCarePlanParticipant) : Integer;

    // Insert FhirCarePlanParticipant before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCarePlanParticipant;

    // Insert an existing FhirCarePlanParticipant before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCarePlanParticipant);

    // Get the iIndexth FhirCarePlanParticipant. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCarePlanParticipant);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCarePlanParticipant;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCarePlanParticipants[index : Integer] : TFhirCarePlanParticipant read GetItemN write SetItemN; default;
  End;

  // Identifies a planned action to occur as part of the plan.  For example, a medication to be used, lab tests to perform, self-monitoring, education, etc.
  TFhirCarePlanActivity = class (TFhirBackboneElement)
  protected
    FactionResultingList : TFhirReferenceList{TFhirReference};
    FprogressList : TFhirAnnotationList;
    FReference : TFhirReference{Resource};
    FDetail : TFhirCarePlanActivityDetail;
    function GetActionResultingList : TFhirReferenceList{TFhirReference};
    function GetHasActionResultingList : Boolean;
    function GetProgressList : TFhirAnnotationList;
    function GetHasProgressList : Boolean;
    Procedure SetReference(value : TFhirReference{Resource});
    Procedure SetDetail(value : TFhirCarePlanActivityDetail);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCarePlanActivity; overload;
    function Clone : TFhirCarePlanActivity; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Resources that describe follow-on actions resulting from the plan, such as drug prescriptions, encounter records, appointments, etc.
    property actionResultingList : TFhirReferenceList{TFhirReference} read GetActionResultingList;
    property hasActionResultingList : boolean read GetHasActionResultingList;

    // Notes about the adherence/status/progress of the activity.
    property progressList : TFhirAnnotationList read GetProgressList;
    property hasProgressList : boolean read GetHasProgressList;

    // Typed access to The details of the proposed activity represented in a specific resource. (defined for API consistency)
    property reference : TFhirReference{Resource} read FReference write SetReference;
    // The details of the proposed activity represented in a specific resource.
    property referenceElement : TFhirReference{Resource} read FReference write SetReference;

    // Typed access to A simple summary of a planned activity suitable for a general care plan system (e.g. form driven) that doesn't know about specific resources such as procedure etc. (defined for API consistency)
    property detail : TFhirCarePlanActivityDetail read FDetail write SetDetail;
    // A simple summary of a planned activity suitable for a general care plan system (e.g. form driven) that doesn't know about specific resources such as procedure etc.
    property detailElement : TFhirCarePlanActivityDetail read FDetail write SetDetail;

  end;

  TFhirCarePlanActivityListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCarePlanActivityList;
    function GetCurrent : TFhirCarePlanActivity;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCarePlanActivityList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCarePlanActivity read GetCurrent;
  end;

  TFhirCarePlanActivityList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCarePlanActivity;
    procedure SetItemN(index : Integer; value : TFhirCarePlanActivity);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCarePlanActivityList; Overload;
    function Clone : TFhirCarePlanActivityList; Overload;
    function GetEnumerator : TFhirCarePlanActivityListEnumerator;

    //  Add a FhirCarePlanActivity to the end of the list.
    function Append : TFhirCarePlanActivity;

    // Add an already existing FhirCarePlanActivity to the end of the list.
    procedure AddItem(value : TFhirCarePlanActivity); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCarePlanActivity) : Integer;

    // Insert FhirCarePlanActivity before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCarePlanActivity;

    // Insert an existing FhirCarePlanActivity before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCarePlanActivity);

    // Get the iIndexth FhirCarePlanActivity. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCarePlanActivity);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCarePlanActivity;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCarePlanActivities[index : Integer] : TFhirCarePlanActivity read GetItemN write SetItemN; default;
  End;

  // A simple summary of a planned activity suitable for a general care plan system (e.g. form driven) that doesn't know about specific resources such as procedure etc.
  TFhirCarePlanActivityDetail = class (TFhirBackboneElement)
  protected
    FCategory : TFhirCodeableConcept;
    FCode : TFhirCodeableConcept;
    FreasonCodeList : TFhirCodeableConceptList;
    FreasonReferenceList : TFhirReferenceList{TFhirCondition};
    FgoalList : TFhirReferenceList{TFhirGoal};
    FStatus : TFhirEnum;
    FStatusReason : TFhirCodeableConcept;
    FProhibited : TFhirBoolean;
    FScheduled : TFhirType;
    FLocation : TFhirReference{TFhirLocation};
    FperformerList : TFhirReferenceList{Resource};
    FProduct : TFhirType;
    FDailyAmount : TFhirQuantity;
    FQuantity : TFhirQuantity;
    FDescription : TFhirString;
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetCode(value : TFhirCodeableConcept);
    function GetReasonCodeList : TFhirCodeableConceptList;
    function GetHasReasonCodeList : Boolean;
    function GetReasonReferenceList : TFhirReferenceList{TFhirCondition};
    function GetHasReasonReferenceList : Boolean;
    function GetGoalList : TFhirReferenceList{TFhirGoal};
    function GetHasGoalList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirCarePlanActivityStatusEnum;
    Procedure SetStatusST(value : TFhirCarePlanActivityStatusEnum);
    Procedure SetStatusReason(value : TFhirCodeableConcept);
    Procedure SetProhibited(value : TFhirBoolean);
    Function GetProhibitedST : Boolean;
    Procedure SetProhibitedST(value : Boolean);
    Procedure SetScheduled(value : TFhirType);
    Procedure SetLocation(value : TFhirReference{TFhirLocation});
    function GetPerformerList : TFhirReferenceList{Resource};
    function GetHasPerformerList : Boolean;
    Procedure SetProduct(value : TFhirType);
    Procedure SetDailyAmount(value : TFhirQuantity);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCarePlanActivityDetail; overload;
    function Clone : TFhirCarePlanActivityDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to High-level categorization of the type of activity in a care plan. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // High-level categorization of the type of activity in a care plan.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to Detailed description of the type of planned activity; e.g. What lab test, what procedure, what kind of encounter. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Detailed description of the type of planned activity; e.g. What lab test, what procedure, what kind of encounter.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Provides the rationale that drove the inclusion of this particular activity as part of the plan.
    property reasonCodeList : TFhirCodeableConceptList read GetReasonCodeList;
    property hasReasonCodeList : boolean read GetHasReasonCodeList;

    // Provides the health condition(s) that drove the inclusion of this particular activity as part of the plan.
    property reasonReferenceList : TFhirReferenceList{TFhirCondition} read GetReasonReferenceList;
    property hasReasonReferenceList : boolean read GetHasReasonReferenceList;

    // Internal reference that identifies the goals that this activity is intended to contribute towards meeting.
    property goalList : TFhirReferenceList{TFhirGoal} read GetGoalList;
    property hasGoalList : boolean read GetHasGoalList;

    // Identifies what progress is being made for the specific activity.
    property status : TFhirCarePlanActivityStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Provides reason why the activity isn't yet started, is on hold, was cancelled, etc. (defined for API consistency)
    property statusReason : TFhirCodeableConcept read FStatusReason write SetStatusReason;
    // Provides reason why the activity isn't yet started, is on hold, was cancelled, etc.
    property statusReasonElement : TFhirCodeableConcept read FStatusReason write SetStatusReason;

    // Typed access to If true, indicates that the described activity is one that must NOT be engaged in when following the plan.
    property prohibited : Boolean read GetProhibitedST write SetProhibitedST;
    // If true, indicates that the described activity is one that must NOT be engaged in when following the plan.
    property prohibitedElement : TFhirBoolean read FProhibited write SetProhibited;

    // Typed access to The period, timing or frequency upon which the described activity is to occur. (defined for API consistency)
    property scheduled : TFhirType read FScheduled write SetScheduled;
    // The period, timing or frequency upon which the described activity is to occur.
    property scheduledElement : TFhirType read FScheduled write SetScheduled;

    // Typed access to Identifies the facility where the activity will occur; e.g. home, hospital, specific clinic, etc. (defined for API consistency)
    property location : TFhirReference{TFhirLocation} read FLocation write SetLocation;
    // Identifies the facility where the activity will occur; e.g. home, hospital, specific clinic, etc.
    property locationElement : TFhirReference{TFhirLocation} read FLocation write SetLocation;

    // Identifies who's expected to be involved in the activity.
    property performerList : TFhirReferenceList{Resource} read GetPerformerList;
    property hasPerformerList : boolean read GetHasPerformerList;

    // Typed access to Identifies the food, drug or other product to be consumed or supplied in the activity. (defined for API consistency)
    property product : TFhirType read FProduct write SetProduct;
    // Identifies the food, drug or other product to be consumed or supplied in the activity.
    property productElement : TFhirType read FProduct write SetProduct;

    // Typed access to Identifies the quantity expected to be consumed in a given day. (defined for API consistency)
    property dailyAmount : TFhirQuantity read FDailyAmount write SetDailyAmount;
    // Identifies the quantity expected to be consumed in a given day.
    property dailyAmountElement : TFhirQuantity read FDailyAmount write SetDailyAmount;

    // Typed access to Identifies the quantity expected to be supplied, administered or consumed by the subject. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // Identifies the quantity expected to be supplied, administered or consumed by the subject.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to This provides a textual description of constraints on the intended activity occurrence, including relation to other activities.  It may also include objectives, pre-conditions and end-conditions.  Finally, it may convey specifics about the activity such as body site, method, route, etc.
    property description : String read GetDescriptionST write SetDescriptionST;
    // This provides a textual description of constraints on the intended activity occurrence, including relation to other activities.  It may also include objectives, pre-conditions and end-conditions.  Finally, it may convey specifics about the activity such as body site, method, route, etc.
    property descriptionElement : TFhirString read FDescription write SetDescription;

  end;

  TFhirCarePlanActivityDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCarePlanActivityDetailList;
    function GetCurrent : TFhirCarePlanActivityDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCarePlanActivityDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCarePlanActivityDetail read GetCurrent;
  end;

  TFhirCarePlanActivityDetailList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCarePlanActivityDetail;
    procedure SetItemN(index : Integer; value : TFhirCarePlanActivityDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCarePlanActivityDetailList; Overload;
    function Clone : TFhirCarePlanActivityDetailList; Overload;
    function GetEnumerator : TFhirCarePlanActivityDetailListEnumerator;

    //  Add a FhirCarePlanActivityDetail to the end of the list.
    function Append : TFhirCarePlanActivityDetail;

    // Add an already existing FhirCarePlanActivityDetail to the end of the list.
    procedure AddItem(value : TFhirCarePlanActivityDetail); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCarePlanActivityDetail) : Integer;

    // Insert FhirCarePlanActivityDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCarePlanActivityDetail;

    // Insert an existing FhirCarePlanActivityDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCarePlanActivityDetail);

    // Get the iIndexth FhirCarePlanActivityDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCarePlanActivityDetail);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCarePlanActivityDetail;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCarePlanActivityDetails[index : Integer] : TFhirCarePlanActivityDetail read GetItemN write SetItemN; default;
  End;

  // Describes the intention of how one or more practitioners intend to deliver care for a particular patient, group or community for a period of time, possibly limited to care for a specific condition or set of conditions.
  TFhirCarePlan = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FSubject : TFhirReference{Resource};
    FStatus : TFhirEnum;
    FContext : TFhirReference{Resource};
    FPeriod : TFhirPeriod;
    FauthorList : TFhirReferenceList{Resource};
    FModified : TFhirDateTime;
    FcategoryList : TFhirCodeableConceptList;
    FDescription : TFhirString;
    FaddressesList : TFhirReferenceList{TFhirCondition};
    FsupportList : TFhirReferenceList{TFhirReference};
    FrelatedPlanList : TFhirCarePlanRelatedPlanList;
    FparticipantList : TFhirCarePlanParticipantList;
    FgoalList : TFhirReferenceList{TFhirGoal};
    FactivityList : TFhirCarePlanActivityList;
    FNote : TFhirAnnotation;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetSubject(value : TFhirReference{Resource});
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirCarePlanStatusEnum;
    Procedure SetStatusST(value : TFhirCarePlanStatusEnum);
    Procedure SetContext(value : TFhirReference{Resource});
    Procedure SetPeriod(value : TFhirPeriod);
    function GetAuthorList : TFhirReferenceList{Resource};
    function GetHasAuthorList : Boolean;
    Procedure SetModified(value : TFhirDateTime);
    Function GetModifiedST : TFslDateTime;
    Procedure SetModifiedST(value : TFslDateTime);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    function GetAddressesList : TFhirReferenceList{TFhirCondition};
    function GetHasAddressesList : Boolean;
    function GetSupportList : TFhirReferenceList{TFhirReference};
    function GetHasSupportList : Boolean;
    function GetRelatedPlanList : TFhirCarePlanRelatedPlanList;
    function GetHasRelatedPlanList : Boolean;
    function GetParticipantList : TFhirCarePlanParticipantList;
    function GetHasParticipantList : Boolean;
    function GetGoalList : TFhirReferenceList{TFhirGoal};
    function GetHasGoalList : Boolean;
    function GetActivityList : TFhirCarePlanActivityList;
    function GetHasActivityList : Boolean;
    Procedure SetNote(value : TFhirAnnotation);

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCarePlan; overload;
    function Clone : TFhirCarePlan; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // This records identifiers associated with this care plan that are defined by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate (e.g. in CDA documents, or in written / printed documentation).
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Identifies the patient or group whose intended care is described by the plan. (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // Identifies the patient or group whose intended care is described by the plan.
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // Indicates whether the plan is currently being acted upon, represents future intentions or is now a historical record.
    property status : TFhirCarePlanStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Identifies the context in which this particular CarePlan is defined. (defined for API consistency)
    property context : TFhirReference{Resource} read FContext write SetContext;
    // Identifies the context in which this particular CarePlan is defined.
    property contextElement : TFhirReference{Resource} read FContext write SetContext;

    // Typed access to Indicates when the plan did (or is intended to) come into effect and end. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Indicates when the plan did (or is intended to) come into effect and end.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Identifies the individual(s) or ogranization who is responsible for the content of the care plan.
    property authorList : TFhirReferenceList{Resource} read GetAuthorList;
    property hasAuthorList : boolean read GetHasAuthorList;

    // Typed access to Identifies the most recent date on which the plan has been revised.
    property modified : TFslDateTime read GetModifiedST write SetModifiedST;
    // Identifies the most recent date on which the plan has been revised.
    property modifiedElement : TFhirDateTime read FModified write SetModified;

    // Identifies what "kind" of plan this is to support differentiation between multiple co-existing plans; e.g. "Home health", "psychiatric", "asthma", "disease management", "wellness plan", etc.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to A description of the scope and nature of the plan.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A description of the scope and nature of the plan.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Identifies the conditions/problems/concerns/diagnoses/etc. whose management and/or mitigation are handled by this plan.
    property addressesList : TFhirReferenceList{TFhirCondition} read GetAddressesList;
    property hasAddressesList : boolean read GetHasAddressesList;

    // Identifies portions of the patient's record that specifically influenced the formation of the plan.  These might include co-morbidities, recent procedures, limitations, recent assessments, etc.
    property supportList : TFhirReferenceList{TFhirReference} read GetSupportList;
    property hasSupportList : boolean read GetHasSupportList;

    // Identifies CarePlans with some sort of formal relationship to the current plan.
    property relatedPlanList : TFhirCarePlanRelatedPlanList read GetRelatedPlanList;
    property hasRelatedPlanList : boolean read GetHasRelatedPlanList;

    // Identifies all people and organizations who are expected to be involved in the care envisioned by this plan.
    property participantList : TFhirCarePlanParticipantList read GetParticipantList;
    property hasParticipantList : boolean read GetHasParticipantList;

    // Describes the intended objective(s) of carrying out the care plan.
    property goalList : TFhirReferenceList{TFhirGoal} read GetGoalList;
    property hasGoalList : boolean read GetHasGoalList;

    // Identifies a planned action to occur as part of the plan.  For example, a medication to be used, lab tests to perform, self-monitoring, education, etc.
    property activityList : TFhirCarePlanActivityList read GetActivityList;
    property hasActivityList : boolean read GetHasActivityList;

    // Typed access to General notes about the care plan not covered elsewhere. (defined for API consistency)
    property note : TFhirAnnotation read FNote write SetNote;
    // General notes about the care plan not covered elsewhere.
    property noteElement : TFhirAnnotation read FNote write SetNote;

  end;

  TFhirCarePlanListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCarePlanList;
    function GetCurrent : TFhirCarePlan;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCarePlanList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCarePlan read GetCurrent;
  end;

  TFhirCarePlanList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCarePlan;
    procedure SetItemN(index : Integer; value : TFhirCarePlan);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCarePlanList; Overload;
    function Clone : TFhirCarePlanList; Overload;
    function GetEnumerator : TFhirCarePlanListEnumerator;

    //  Add a FhirCarePlan to the end of the list.
    function Append : TFhirCarePlan;

    // Add an already existing FhirCarePlan to the end of the list.
    procedure AddItem(value : TFhirCarePlan); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCarePlan) : Integer;

    // Insert FhirCarePlan before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCarePlan;

    // Insert an existing FhirCarePlan before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCarePlan);

    // Get the iIndexth FhirCarePlan. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCarePlan);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCarePlan;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCarePlans[index : Integer] : TFhirCarePlan read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CAREPLAN}

{$IFDEF FHIR_CLINICALIMPRESSION}

  // One or more sets of investigations (signs, symptions, etc.). The actual grouping of investigations vary greatly depending on the type and context of the assessment. These investigations may include data generated during the assessment process, or data previously generated and recorded that is pertinent to the outcomes.
  TFhirClinicalImpressionInvestigations = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FitemList : TFhirReferenceList{Resource};
    Procedure SetCode(value : TFhirCodeableConcept);
    function GetItemList : TFhirReferenceList{Resource};
    function GetHasItemList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClinicalImpressionInvestigations; overload;
    function Clone : TFhirClinicalImpressionInvestigations; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A name/code for the group ("set") of investigations. Typically, this will be something like "signs", "symptoms", "clinical", "diagnostic", but the list is not constrained, and others such groups such as (exposure|family|travel|nutitirional) history may be used. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A name/code for the group ("set") of investigations. Typically, this will be something like "signs", "symptoms", "clinical", "diagnostic", but the list is not constrained, and others such groups such as (exposure|family|travel|nutitirional) history may be used.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // A record of a specific investigation that was undertaken.
    property itemList : TFhirReferenceList{Resource} read GetItemList;
    property hasItemList : boolean read GetHasItemList;

  end;

  TFhirClinicalImpressionInvestigationsListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClinicalImpressionInvestigationsList;
    function GetCurrent : TFhirClinicalImpressionInvestigations;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClinicalImpressionInvestigationsList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClinicalImpressionInvestigations read GetCurrent;
  end;

  TFhirClinicalImpressionInvestigationsList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClinicalImpressionInvestigations;
    procedure SetItemN(index : Integer; value : TFhirClinicalImpressionInvestigations);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClinicalImpressionInvestigationsList; Overload;
    function Clone : TFhirClinicalImpressionInvestigationsList; Overload;
    function GetEnumerator : TFhirClinicalImpressionInvestigationsListEnumerator;

    //  Add a FhirClinicalImpressionInvestigations to the end of the list.
    function Append : TFhirClinicalImpressionInvestigations;

    // Add an already existing FhirClinicalImpressionInvestigations to the end of the list.
    procedure AddItem(value : TFhirClinicalImpressionInvestigations); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClinicalImpressionInvestigations) : Integer;

    // Insert FhirClinicalImpressionInvestigations before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClinicalImpressionInvestigations;

    // Insert an existing FhirClinicalImpressionInvestigations before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClinicalImpressionInvestigations);

    // Get the iIndexth FhirClinicalImpressionInvestigations. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClinicalImpressionInvestigations);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClinicalImpressionInvestigations;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClinicalImpressionInvestigations[index : Integer] : TFhirClinicalImpressionInvestigations read GetItemN write SetItemN; default;
  End;

  // Specific findings or diagnoses that was considered likely or relevant to ongoing treatment.
  TFhirClinicalImpressionFinding = class (TFhirBackboneElement)
  protected
    FItem : TFhirCodeableConcept;
    FCause : TFhirString;
    Procedure SetItem(value : TFhirCodeableConcept);
    Procedure SetCause(value : TFhirString);
    Function GetCauseST : String;
    Procedure SetCauseST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClinicalImpressionFinding; overload;
    function Clone : TFhirClinicalImpressionFinding; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Specific text of code for finding or diagnosis. (defined for API consistency)
    property item : TFhirCodeableConcept read FItem write SetItem;
    // Specific text of code for finding or diagnosis.
    property itemElement : TFhirCodeableConcept read FItem write SetItem;

    // Typed access to Which investigations support finding or diagnosis.
    property cause : String read GetCauseST write SetCauseST;
    // Which investigations support finding or diagnosis.
    property causeElement : TFhirString read FCause write SetCause;

  end;

  TFhirClinicalImpressionFindingListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClinicalImpressionFindingList;
    function GetCurrent : TFhirClinicalImpressionFinding;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClinicalImpressionFindingList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClinicalImpressionFinding read GetCurrent;
  end;

  TFhirClinicalImpressionFindingList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClinicalImpressionFinding;
    procedure SetItemN(index : Integer; value : TFhirClinicalImpressionFinding);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClinicalImpressionFindingList; Overload;
    function Clone : TFhirClinicalImpressionFindingList; Overload;
    function GetEnumerator : TFhirClinicalImpressionFindingListEnumerator;

    //  Add a FhirClinicalImpressionFinding to the end of the list.
    function Append : TFhirClinicalImpressionFinding;

    // Add an already existing FhirClinicalImpressionFinding to the end of the list.
    procedure AddItem(value : TFhirClinicalImpressionFinding); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClinicalImpressionFinding) : Integer;

    // Insert FhirClinicalImpressionFinding before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClinicalImpressionFinding;

    // Insert an existing FhirClinicalImpressionFinding before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClinicalImpressionFinding);

    // Get the iIndexth FhirClinicalImpressionFinding. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClinicalImpressionFinding);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClinicalImpressionFinding;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClinicalImpressionFindings[index : Integer] : TFhirClinicalImpressionFinding read GetItemN write SetItemN; default;
  End;

  // Diagnosis considered not possible.
  TFhirClinicalImpressionRuledOut = class (TFhirBackboneElement)
  protected
    FItem : TFhirCodeableConcept;
    FReason : TFhirString;
    Procedure SetItem(value : TFhirCodeableConcept);
    Procedure SetReason(value : TFhirString);
    Function GetReasonST : String;
    Procedure SetReasonST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClinicalImpressionRuledOut; overload;
    function Clone : TFhirClinicalImpressionRuledOut; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Specific text of code for diagnosis. (defined for API consistency)
    property item : TFhirCodeableConcept read FItem write SetItem;
    // Specific text of code for diagnosis.
    property itemElement : TFhirCodeableConcept read FItem write SetItem;

    // Typed access to Grounds for elimination.
    property reason : String read GetReasonST write SetReasonST;
    // Grounds for elimination.
    property reasonElement : TFhirString read FReason write SetReason;

  end;

  TFhirClinicalImpressionRuledOutListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClinicalImpressionRuledOutList;
    function GetCurrent : TFhirClinicalImpressionRuledOut;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClinicalImpressionRuledOutList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClinicalImpressionRuledOut read GetCurrent;
  end;

  TFhirClinicalImpressionRuledOutList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClinicalImpressionRuledOut;
    procedure SetItemN(index : Integer; value : TFhirClinicalImpressionRuledOut);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClinicalImpressionRuledOutList; Overload;
    function Clone : TFhirClinicalImpressionRuledOutList; Overload;
    function GetEnumerator : TFhirClinicalImpressionRuledOutListEnumerator;

    //  Add a FhirClinicalImpressionRuledOut to the end of the list.
    function Append : TFhirClinicalImpressionRuledOut;

    // Add an already existing FhirClinicalImpressionRuledOut to the end of the list.
    procedure AddItem(value : TFhirClinicalImpressionRuledOut); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClinicalImpressionRuledOut) : Integer;

    // Insert FhirClinicalImpressionRuledOut before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClinicalImpressionRuledOut;

    // Insert an existing FhirClinicalImpressionRuledOut before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClinicalImpressionRuledOut);

    // Get the iIndexth FhirClinicalImpressionRuledOut. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClinicalImpressionRuledOut);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClinicalImpressionRuledOut;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClinicalImpressionRuledOuts[index : Integer] : TFhirClinicalImpressionRuledOut read GetItemN write SetItemN; default;
  End;

  // A record of a clinical assessment performed to determine what problem(s) may affect the patient and before planning the treatments or management strategies that are best to manage a patient's condition. Assessments are often 1:1 with a clinical consultation / encounter,  but this varies greatly depending on the clinical workflow. This resource is called "ClinicalImpression" rather than "ClinicalAssessment" to avoid confusion with the recording of assessment tools such as Apgar score.
  TFhirClinicalImpression = class (TFhirDomainResource)
  protected
    FPatient : TFhirReference{TFhirPatient};
    FAssessor : TFhirReference{TFhirPractitioner};
    FStatus : TFhirEnum;
    FDate : TFhirDateTime;
    FDescription : TFhirString;
    FPrevious : TFhirReference{TFhirClinicalImpression};
    FproblemList : TFhirReferenceList{Resource};
    FTrigger : TFhirType;
    FinvestigationsList : TFhirClinicalImpressionInvestigationsList;
    FProtocol : TFhirUri;
    FSummary : TFhirString;
    FfindingList : TFhirClinicalImpressionFindingList;
    FresolvedList : TFhirCodeableConceptList;
    FruledOutList : TFhirClinicalImpressionRuledOutList;
    FPrognosis : TFhirString;
    FplanList : TFhirReferenceList{Resource};
    FactionList : TFhirReferenceList{Resource};
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    Procedure SetAssessor(value : TFhirReference{TFhirPractitioner});
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirClinicalImpressionStatusEnum;
    Procedure SetStatusST(value : TFhirClinicalImpressionStatusEnum);
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetPrevious(value : TFhirReference{TFhirClinicalImpression});
    function GetProblemList : TFhirReferenceList{Resource};
    function GetHasProblemList : Boolean;
    Procedure SetTrigger(value : TFhirType);
    function GetInvestigationsList : TFhirClinicalImpressionInvestigationsList;
    function GetHasInvestigationsList : Boolean;
    Procedure SetProtocol(value : TFhirUri);
    Function GetProtocolST : String;
    Procedure SetProtocolST(value : String);
    Procedure SetSummary(value : TFhirString);
    Function GetSummaryST : String;
    Procedure SetSummaryST(value : String);
    function GetFindingList : TFhirClinicalImpressionFindingList;
    function GetHasFindingList : Boolean;
    function GetResolvedList : TFhirCodeableConceptList;
    function GetHasResolvedList : Boolean;
    function GetRuledOutList : TFhirClinicalImpressionRuledOutList;
    function GetHasRuledOutList : Boolean;
    Procedure SetPrognosis(value : TFhirString);
    Function GetPrognosisST : String;
    Procedure SetPrognosisST(value : String);
    function GetPlanList : TFhirReferenceList{Resource};
    function GetHasPlanList : Boolean;
    function GetActionList : TFhirReferenceList{Resource};
    function GetHasActionList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClinicalImpression; overload;
    function Clone : TFhirClinicalImpression; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The patient being assessed. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // The patient being assessed.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Typed access to The clinician performing the assessment. (defined for API consistency)
    property assessor : TFhirReference{TFhirPractitioner} read FAssessor write SetAssessor;
    // The clinician performing the assessment.
    property assessorElement : TFhirReference{TFhirPractitioner} read FAssessor write SetAssessor;

    // Identifies the workflow status of the assessment.
    property status : TFhirClinicalImpressionStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The point in time at which the assessment was concluded (not when it was recorded).
    property date : TFslDateTime read GetDateST write SetDateST;
    // The point in time at which the assessment was concluded (not when it was recorded).
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to A summary of the context and/or cause of the assessment - why / where was it peformed, and what patient events/sstatus prompted it.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A summary of the context and/or cause of the assessment - why / where was it peformed, and what patient events/sstatus prompted it.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to A reference to the last assesment that was conducted bon this patient. Assessments are often/usually ongoing in nature; a care provider (practitioner or team) will make new assessments on an ongoing basis as new data arises or the patient's conditions changes. (defined for API consistency)
    property previous : TFhirReference{TFhirClinicalImpression} read FPrevious write SetPrevious;
    // A reference to the last assesment that was conducted bon this patient. Assessments are often/usually ongoing in nature; a care provider (practitioner or team) will make new assessments on an ongoing basis as new data arises or the patient's conditions changes.
    property previousElement : TFhirReference{TFhirClinicalImpression} read FPrevious write SetPrevious;

    // This a list of the general problems/conditions for a patient.
    property problemList : TFhirReferenceList{Resource} read GetProblemList;
    property hasProblemList : boolean read GetHasProblemList;

    // Typed access to The request or event that necessitated this assessment. This may be a diagnosis, a Care Plan, a Request Referral, or some other resource. (defined for API consistency)
    property trigger : TFhirType read FTrigger write SetTrigger;
    // The request or event that necessitated this assessment. This may be a diagnosis, a Care Plan, a Request Referral, or some other resource.
    property triggerElement : TFhirType read FTrigger write SetTrigger;

    // One or more sets of investigations (signs, symptions, etc.). The actual grouping of investigations vary greatly depending on the type and context of the assessment. These investigations may include data generated during the assessment process, or data previously generated and recorded that is pertinent to the outcomes.
    property investigationsList : TFhirClinicalImpressionInvestigationsList read GetInvestigationsList;
    property hasInvestigationsList : boolean read GetHasInvestigationsList;

    // Typed access to Reference to a specific {$IFNDEF FPC}published{$ENDIF} clinical protocol that was followed during this assessment, and/or that provides evidence in support of the diagnosis.
    property protocol : String read GetProtocolST write SetProtocolST;
    // Reference to a specific {$IFNDEF FPC}published{$ENDIF} clinical protocol that was followed during this assessment, and/or that provides evidence in support of the diagnosis.
    property protocolElement : TFhirUri read FProtocol write SetProtocol;

    // Typed access to A text summary of the investigations and the diagnosis.
    property summary : String read GetSummaryST write SetSummaryST;
    // A text summary of the investigations and the diagnosis.
    property summaryElement : TFhirString read FSummary write SetSummary;

    // Specific findings or diagnoses that was considered likely or relevant to ongoing treatment.
    property findingList : TFhirClinicalImpressionFindingList read GetFindingList;
    property hasFindingList : boolean read GetHasFindingList;

    // Diagnoses/conditions resolved since the last assessment.
    property resolvedList : TFhirCodeableConceptList read GetResolvedList;
    property hasResolvedList : boolean read GetHasResolvedList;

    // Diagnosis considered not possible.
    property ruledOutList : TFhirClinicalImpressionRuledOutList read GetRuledOutList;
    property hasRuledOutList : boolean read GetHasRuledOutList;

    // Typed access to Estimate of likely outcome.
    property prognosis : String read GetPrognosisST write SetPrognosisST;
    // Estimate of likely outcome.
    property prognosisElement : TFhirString read FPrognosis write SetPrognosis;

    // Plan of action after assessment.
    property planList : TFhirReferenceList{Resource} read GetPlanList;
    property hasPlanList : boolean read GetHasPlanList;

    // Actions taken during assessment.
    property actionList : TFhirReferenceList{Resource} read GetActionList;
    property hasActionList : boolean read GetHasActionList;

  end;

  TFhirClinicalImpressionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClinicalImpressionList;
    function GetCurrent : TFhirClinicalImpression;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClinicalImpressionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClinicalImpression read GetCurrent;
  end;

  TFhirClinicalImpressionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClinicalImpression;
    procedure SetItemN(index : Integer; value : TFhirClinicalImpression);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClinicalImpressionList; Overload;
    function Clone : TFhirClinicalImpressionList; Overload;
    function GetEnumerator : TFhirClinicalImpressionListEnumerator;

    //  Add a FhirClinicalImpression to the end of the list.
    function Append : TFhirClinicalImpression;

    // Add an already existing FhirClinicalImpression to the end of the list.
    procedure AddItem(value : TFhirClinicalImpression); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClinicalImpression) : Integer;

    // Insert FhirClinicalImpression before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClinicalImpression;

    // Insert an existing FhirClinicalImpression before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClinicalImpression);

    // Get the iIndexth FhirClinicalImpression. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClinicalImpression);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClinicalImpression;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClinicalImpressions[index : Integer] : TFhirClinicalImpression read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CLINICALIMPRESSION}

{$IFDEF FHIR_COMMUNICATION}

  // Text, attachment(s), or resource(s) that was communicated to the recipient.
  TFhirCommunicationPayload = class (TFhirBackboneElement)
  protected
    FContent : TFhirType;
    Procedure SetContent(value : TFhirType);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCommunicationPayload; overload;
    function Clone : TFhirCommunicationPayload; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A communicated content (or for multi-part communications, one portion of the communication). (defined for API consistency)
    property content : TFhirType read FContent write SetContent;
    // A communicated content (or for multi-part communications, one portion of the communication).
    property contentElement : TFhirType read FContent write SetContent;

  end;

  TFhirCommunicationPayloadListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCommunicationPayloadList;
    function GetCurrent : TFhirCommunicationPayload;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCommunicationPayloadList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCommunicationPayload read GetCurrent;
  end;

  TFhirCommunicationPayloadList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCommunicationPayload;
    procedure SetItemN(index : Integer; value : TFhirCommunicationPayload);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCommunicationPayloadList; Overload;
    function Clone : TFhirCommunicationPayloadList; Overload;
    function GetEnumerator : TFhirCommunicationPayloadListEnumerator;

    //  Add a FhirCommunicationPayload to the end of the list.
    function Append : TFhirCommunicationPayload;

    // Add an already existing FhirCommunicationPayload to the end of the list.
    procedure AddItem(value : TFhirCommunicationPayload); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCommunicationPayload) : Integer;

    // Insert FhirCommunicationPayload before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCommunicationPayload;

    // Insert an existing FhirCommunicationPayload before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCommunicationPayload);

    // Get the iIndexth FhirCommunicationPayload. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCommunicationPayload);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCommunicationPayload;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCommunicationPayloads[index : Integer] : TFhirCommunicationPayload read GetItemN write SetItemN; default;
  End;

  // An occurrence of information being transmitted; e.g. an alert that was sent to a responsible provider, a public health agency was notified about a reportable condition.
  TFhirCommunication = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FCategory : TFhirCodeableConcept;
    FSender : TFhirReference{Resource};
    FrecipientList : TFhirReferenceList{Resource};
    FpayloadList : TFhirCommunicationPayloadList;
    FmediumList : TFhirCodeableConceptList;
    FStatus : TFhirEnum;
    FEncounter : TFhirReference{TFhirEncounter};
    FSent : TFhirDateTime;
    FReceived : TFhirDateTime;
    FreasonList : TFhirCodeableConceptList;
    FSubject : TFhirReference{TFhirPatient};
    FRequestDetail : TFhirReference{TFhirCommunicationRequest};
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetSender(value : TFhirReference{Resource});
    function GetRecipientList : TFhirReferenceList{Resource};
    function GetHasRecipientList : Boolean;
    function GetPayloadList : TFhirCommunicationPayloadList;
    function GetHasPayloadList : Boolean;
    function GetMediumList : TFhirCodeableConceptList;
    function GetHasMediumList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirCommunicationStatusEnum;
    Procedure SetStatusST(value : TFhirCommunicationStatusEnum);
    Procedure SetEncounter(value : TFhirReference{TFhirEncounter});
    Procedure SetSent(value : TFhirDateTime);
    Function GetSentST : TFslDateTime;
    Procedure SetSentST(value : TFslDateTime);
    Procedure SetReceived(value : TFhirDateTime);
    Function GetReceivedST : TFslDateTime;
    Procedure SetReceivedST(value : TFslDateTime);
    function GetReasonList : TFhirCodeableConceptList;
    function GetHasReasonList : Boolean;
    Procedure SetSubject(value : TFhirReference{TFhirPatient});
    Procedure SetRequestDetail(value : TFhirReference{TFhirCommunicationRequest});

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCommunication; overload;
    function Clone : TFhirCommunication; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifiers associated with this Communication that are defined by business processes and/ or used to refer to it when a direct URL reference to the resource itself is not appropriate (e.g. in CDA documents, or in written / printed documentation).
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The type of message conveyed such as alert, notification, reminder, instruction, etc. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // The type of message conveyed such as alert, notification, reminder, instruction, etc.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to The entity (e.g. person, organization, clinical information system, or device) which was the source of the communication. (defined for API consistency)
    property sender : TFhirReference{Resource} read FSender write SetSender;
    // The entity (e.g. person, organization, clinical information system, or device) which was the source of the communication.
    property senderElement : TFhirReference{Resource} read FSender write SetSender;

    // The entity (e.g. person, organization, clinical information system, or device) which was the target of the communication. If receipts need to be tracked by individual, a separate resource instance will need to be created for each recipient. ?Multiple recipient communications are intended where either a receipt(s) is not tracked (e.g. a mass mail-out) or is captured in aggregate (all emails confirmed received by a particular time).
    property recipientList : TFhirReferenceList{Resource} read GetRecipientList;
    property hasRecipientList : boolean read GetHasRecipientList;

    // Text, attachment(s), or resource(s) that was communicated to the recipient.
    property payloadList : TFhirCommunicationPayloadList read GetPayloadList;
    property hasPayloadList : boolean read GetHasPayloadList;

    // A channel that was used for this communication (e.g. email, fax).
    property mediumList : TFhirCodeableConceptList read GetMediumList;
    property hasMediumList : boolean read GetHasMediumList;

    // The status of the transmission.
    property status : TFhirCommunicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The encounter within which the communication was sent. (defined for API consistency)
    property encounter : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;
    // The encounter within which the communication was sent.
    property encounterElement : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;

    // Typed access to The time when this communication was sent.
    property sent : TFslDateTime read GetSentST write SetSentST;
    // The time when this communication was sent.
    property sentElement : TFhirDateTime read FSent write SetSent;

    // Typed access to The time when this communication arrived at the destination.
    property received : TFslDateTime read GetReceivedST write SetReceivedST;
    // The time when this communication arrived at the destination.
    property receivedElement : TFhirDateTime read FReceived write SetReceived;

    // The reason or justification for the communication.
    property reasonList : TFhirCodeableConceptList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // Typed access to The patient who was the focus of this communication. (defined for API consistency)
    property subject : TFhirReference{TFhirPatient} read FSubject write SetSubject;
    // The patient who was the focus of this communication.
    property subjectElement : TFhirReference{TFhirPatient} read FSubject write SetSubject;

    // Typed access to The communication request that was responsible for producing this communication. (defined for API consistency)
    property requestDetail : TFhirReference{TFhirCommunicationRequest} read FRequestDetail write SetRequestDetail;
    // The communication request that was responsible for producing this communication.
    property requestDetailElement : TFhirReference{TFhirCommunicationRequest} read FRequestDetail write SetRequestDetail;

  end;

  TFhirCommunicationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCommunicationList;
    function GetCurrent : TFhirCommunication;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCommunicationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCommunication read GetCurrent;
  end;

  TFhirCommunicationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCommunication;
    procedure SetItemN(index : Integer; value : TFhirCommunication);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCommunicationList; Overload;
    function Clone : TFhirCommunicationList; Overload;
    function GetEnumerator : TFhirCommunicationListEnumerator;

    //  Add a FhirCommunication to the end of the list.
    function Append : TFhirCommunication;

    // Add an already existing FhirCommunication to the end of the list.
    procedure AddItem(value : TFhirCommunication); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCommunication) : Integer;

    // Insert FhirCommunication before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCommunication;

    // Insert an existing FhirCommunication before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCommunication);

    // Get the iIndexth FhirCommunication. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCommunication);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCommunication;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCommunications[index : Integer] : TFhirCommunication read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_COMMUNICATION}

{$IFDEF FHIR_COMMUNICATIONREQUEST}

  // Text, attachment(s), or resource(s) to be communicated to the recipient.
  TFhirCommunicationRequestPayload = class (TFhirBackboneElement)
  protected
    FContent : TFhirType;
    Procedure SetContent(value : TFhirType);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCommunicationRequestPayload; overload;
    function Clone : TFhirCommunicationRequestPayload; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The communicated content (or for multi-part communications, one portion of the communication). (defined for API consistency)
    property content : TFhirType read FContent write SetContent;
    // The communicated content (or for multi-part communications, one portion of the communication).
    property contentElement : TFhirType read FContent write SetContent;

  end;

  TFhirCommunicationRequestPayloadListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCommunicationRequestPayloadList;
    function GetCurrent : TFhirCommunicationRequestPayload;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCommunicationRequestPayloadList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCommunicationRequestPayload read GetCurrent;
  end;

  TFhirCommunicationRequestPayloadList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCommunicationRequestPayload;
    procedure SetItemN(index : Integer; value : TFhirCommunicationRequestPayload);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCommunicationRequestPayloadList; Overload;
    function Clone : TFhirCommunicationRequestPayloadList; Overload;
    function GetEnumerator : TFhirCommunicationRequestPayloadListEnumerator;

    //  Add a FhirCommunicationRequestPayload to the end of the list.
    function Append : TFhirCommunicationRequestPayload;

    // Add an already existing FhirCommunicationRequestPayload to the end of the list.
    procedure AddItem(value : TFhirCommunicationRequestPayload); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCommunicationRequestPayload) : Integer;

    // Insert FhirCommunicationRequestPayload before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCommunicationRequestPayload;

    // Insert an existing FhirCommunicationRequestPayload before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCommunicationRequestPayload);

    // Get the iIndexth FhirCommunicationRequestPayload. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCommunicationRequestPayload);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCommunicationRequestPayload;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCommunicationRequestPayloads[index : Integer] : TFhirCommunicationRequestPayload read GetItemN write SetItemN; default;
  End;

  // A request to convey information; e.g. the CDS system proposes that an alert be sent to a responsible provider, the CDS system proposes that the public health agency be notified about a reportable condition.
  TFhirCommunicationRequest = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FCategory : TFhirCodeableConcept;
    FSender : TFhirReference{Resource};
    FrecipientList : TFhirReferenceList{Resource};
    FpayloadList : TFhirCommunicationRequestPayloadList;
    FmediumList : TFhirCodeableConceptList;
    FRequester : TFhirReference{Resource};
    FStatus : TFhirEnum;
    FEncounter : TFhirReference{TFhirEncounter};
    FScheduled : TFhirType;
    FreasonList : TFhirCodeableConceptList;
    FRequestedOn : TFhirDateTime;
    FSubject : TFhirReference{TFhirPatient};
    FPriority : TFhirCodeableConcept;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetSender(value : TFhirReference{Resource});
    function GetRecipientList : TFhirReferenceList{Resource};
    function GetHasRecipientList : Boolean;
    function GetPayloadList : TFhirCommunicationRequestPayloadList;
    function GetHasPayloadList : Boolean;
    function GetMediumList : TFhirCodeableConceptList;
    function GetHasMediumList : Boolean;
    Procedure SetRequester(value : TFhirReference{Resource});
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirCommunicationRequestStatusEnum;
    Procedure SetStatusST(value : TFhirCommunicationRequestStatusEnum);
    Procedure SetEncounter(value : TFhirReference{TFhirEncounter});
    Procedure SetScheduled(value : TFhirType);
    function GetReasonList : TFhirCodeableConceptList;
    function GetHasReasonList : Boolean;
    Procedure SetRequestedOn(value : TFhirDateTime);
    Function GetRequestedOnST : TFslDateTime;
    Procedure SetRequestedOnST(value : TFslDateTime);
    Procedure SetSubject(value : TFhirReference{TFhirPatient});
    Procedure SetPriority(value : TFhirCodeableConcept);

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCommunicationRequest; overload;
    function Clone : TFhirCommunicationRequest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A unique ID of this request for reference purposes. It must be provided if user wants it returned as part of any output, otherwise it will be autogenerated, if needed, by CDS system. Does not need to be the actual ID of the source system.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The type of message to be sent such as alert, notification, reminder, instruction, etc. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // The type of message to be sent such as alert, notification, reminder, instruction, etc.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to The entity (e.g. person, organization, clinical information system, or device) which is to be the source of the communication. (defined for API consistency)
    property sender : TFhirReference{Resource} read FSender write SetSender;
    // The entity (e.g. person, organization, clinical information system, or device) which is to be the source of the communication.
    property senderElement : TFhirReference{Resource} read FSender write SetSender;

    // The entity (e.g. person, organization, clinical information system, or device) which is the intended target of the communication.
    property recipientList : TFhirReferenceList{Resource} read GetRecipientList;
    property hasRecipientList : boolean read GetHasRecipientList;

    // Text, attachment(s), or resource(s) to be communicated to the recipient.
    property payloadList : TFhirCommunicationRequestPayloadList read GetPayloadList;
    property hasPayloadList : boolean read GetHasPayloadList;

    // A channel that was used for this communication (e.g. email, fax).
    property mediumList : TFhirCodeableConceptList read GetMediumList;
    property hasMediumList : boolean read GetHasMediumList;

    // Typed access to The responsible person who authorizes this order, e.g. physician. This may be different than the author of the order statement, e.g. clerk, who may have entered the statement into the order entry application. (defined for API consistency)
    property requester : TFhirReference{Resource} read FRequester write SetRequester;
    // The responsible person who authorizes this order, e.g. physician. This may be different than the author of the order statement, e.g. clerk, who may have entered the statement into the order entry application.
    property requesterElement : TFhirReference{Resource} read FRequester write SetRequester;

    // The status of the proposal or order.
    property status : TFhirCommunicationRequestStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The encounter within which the communication request was created. (defined for API consistency)
    property encounter : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;
    // The encounter within which the communication request was created.
    property encounterElement : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;

    // Typed access to The time when this communication is to occur. (defined for API consistency)
    property scheduled : TFhirType read FScheduled write SetScheduled;
    // The time when this communication is to occur.
    property scheduledElement : TFhirType read FScheduled write SetScheduled;

    // The reason or justification for the communication request.
    property reasonList : TFhirCodeableConceptList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // Typed access to The time when the request was made.
    property requestedOn : TFslDateTime read GetRequestedOnST write SetRequestedOnST;
    // The time when the request was made.
    property requestedOnElement : TFhirDateTime read FRequestedOn write SetRequestedOn;

    // Typed access to The patient who is the focus of this communication request. (defined for API consistency)
    property subject : TFhirReference{TFhirPatient} read FSubject write SetSubject;
    // The patient who is the focus of this communication request.
    property subjectElement : TFhirReference{TFhirPatient} read FSubject write SetSubject;

    // Typed access to Characterizes how quickly the proposed act must be initiated. Includes concepts such as stat, urgent, routine. (defined for API consistency)
    property priority : TFhirCodeableConcept read FPriority write SetPriority;
    // Characterizes how quickly the proposed act must be initiated. Includes concepts such as stat, urgent, routine.
    property priorityElement : TFhirCodeableConcept read FPriority write SetPriority;

  end;

  TFhirCommunicationRequestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCommunicationRequestList;
    function GetCurrent : TFhirCommunicationRequest;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCommunicationRequestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCommunicationRequest read GetCurrent;
  end;

  TFhirCommunicationRequestList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCommunicationRequest;
    procedure SetItemN(index : Integer; value : TFhirCommunicationRequest);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCommunicationRequestList; Overload;
    function Clone : TFhirCommunicationRequestList; Overload;
    function GetEnumerator : TFhirCommunicationRequestListEnumerator;

    //  Add a FhirCommunicationRequest to the end of the list.
    function Append : TFhirCommunicationRequest;

    // Add an already existing FhirCommunicationRequest to the end of the list.
    procedure AddItem(value : TFhirCommunicationRequest); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCommunicationRequest) : Integer;

    // Insert FhirCommunicationRequest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCommunicationRequest;

    // Insert an existing FhirCommunicationRequest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCommunicationRequest);

    // Get the iIndexth FhirCommunicationRequest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCommunicationRequest);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCommunicationRequest;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCommunicationRequests[index : Integer] : TFhirCommunicationRequest read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_COMMUNICATIONREQUEST}

{$IFDEF FHIR_COMPOSITION}

  // A participant who has attested to the accuracy of the composition/document.
  TFhirCompositionAttester = class (TFhirBackboneElement)
  protected
    FMode : TFhirEnumList;
    FTime : TFhirDateTime;
    FParty : TFhirReference{Resource};
    function GetMode : TFhirEnumList;
    function GetHasMode : Boolean;
    Function GetModeST : TFhirCompositionAttestationModeEnumList;
    Procedure SetModeST(value : TFhirCompositionAttestationModeEnumList);
    Procedure SetTime(value : TFhirDateTime);
    Function GetTimeST : TFslDateTime;
    Procedure SetTimeST(value : TFslDateTime);
    Procedure SetParty(value : TFhirReference{Resource});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCompositionAttester; overload;
    function Clone : TFhirCompositionAttester; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The type of attestation the authenticator offers.
    property mode : TFhirCompositionAttestationModeEnumList read GetModeST write SetModeST;
    property modeList : TFhirEnumList read GetMode;
    property hasMode : boolean read GetHasMode;
    // Typed access to When composition was attested by the party.
    property time : TFslDateTime read GetTimeST write SetTimeST;
    // When composition was attested by the party.
    property timeElement : TFhirDateTime read FTime write SetTime;

    // Typed access to Who attested the composition in the specified way. (defined for API consistency)
    property party : TFhirReference{Resource} read FParty write SetParty;
    // Who attested the composition in the specified way.
    property partyElement : TFhirReference{Resource} read FParty write SetParty;

  end;

  TFhirCompositionAttesterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCompositionAttesterList;
    function GetCurrent : TFhirCompositionAttester;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCompositionAttesterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCompositionAttester read GetCurrent;
  end;

  TFhirCompositionAttesterList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCompositionAttester;
    procedure SetItemN(index : Integer; value : TFhirCompositionAttester);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCompositionAttesterList; Overload;
    function Clone : TFhirCompositionAttesterList; Overload;
    function GetEnumerator : TFhirCompositionAttesterListEnumerator;

    //  Add a FhirCompositionAttester to the end of the list.
    function Append : TFhirCompositionAttester;

    // Add an already existing FhirCompositionAttester to the end of the list.
    procedure AddItem(value : TFhirCompositionAttester); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCompositionAttester) : Integer;

    // Insert FhirCompositionAttester before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCompositionAttester;

    // Insert an existing FhirCompositionAttester before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCompositionAttester);

    // Get the iIndexth FhirCompositionAttester. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCompositionAttester);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCompositionAttester;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCompositionAttesters[index : Integer] : TFhirCompositionAttester read GetItemN write SetItemN; default;
  End;

  // The clinical service, such as a colonoscopy or an appendectomy, being documented.
  TFhirCompositionEvent = class (TFhirBackboneElement)
  protected
    FcodeList : TFhirCodeableConceptList;
    FPeriod : TFhirPeriod;
    FdetailList : TFhirReferenceList{TFhirReference};
    function GetCodeList : TFhirCodeableConceptList;
    function GetHasCodeList : Boolean;
    Procedure SetPeriod(value : TFhirPeriod);
    function GetDetailList : TFhirReferenceList{TFhirReference};
    function GetHasDetailList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCompositionEvent; overload;
    function Clone : TFhirCompositionEvent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // This list of codes represents the main clinical acts, such as a colonoscopy or an appendectomy, being documented. In some cases, the event is inherent in the typeCode, such as a "History and Physical Report" in which the procedure being documented is necessarily a "History and Physical" act.
    property codeList : TFhirCodeableConceptList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // Typed access to The period of time covered by the documentation. There is no assertion that the documentation is a complete representation for this period, only that it documents events during this time. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period of time covered by the documentation. There is no assertion that the documentation is a complete representation for this period, only that it documents events during this time.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // The description and/or reference of the event(s) being documented. For example, this could be used to document such a colonoscopy or an appendectomy.
    property detailList : TFhirReferenceList{TFhirReference} read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

  end;

  TFhirCompositionEventListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCompositionEventList;
    function GetCurrent : TFhirCompositionEvent;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCompositionEventList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCompositionEvent read GetCurrent;
  end;

  TFhirCompositionEventList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCompositionEvent;
    procedure SetItemN(index : Integer; value : TFhirCompositionEvent);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCompositionEventList; Overload;
    function Clone : TFhirCompositionEventList; Overload;
    function GetEnumerator : TFhirCompositionEventListEnumerator;

    //  Add a FhirCompositionEvent to the end of the list.
    function Append : TFhirCompositionEvent;

    // Add an already existing FhirCompositionEvent to the end of the list.
    procedure AddItem(value : TFhirCompositionEvent); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCompositionEvent) : Integer;

    // Insert FhirCompositionEvent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCompositionEvent;

    // Insert an existing FhirCompositionEvent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCompositionEvent);

    // Get the iIndexth FhirCompositionEvent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCompositionEvent);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCompositionEvent;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCompositionEvents[index : Integer] : TFhirCompositionEvent read GetItemN write SetItemN; default;
  End;

  // The root of the sections that make up the composition.
  TFhirCompositionSection = class (TFhirBackboneElement)
  protected
    FTitle : TFhirString;
    FCode : TFhirCodeableConcept;
    FText : TFhirNarrative;
    FMode : TFhirEnum;
    FOrderedBy : TFhirCodeableConcept;
    FentryList : TFhirReferenceList{TFhirReference};
    FEmptyReason : TFhirCodeableConcept;
    FsectionList : TFhirCompositionSectionList;
    Procedure SetTitle(value : TFhirString);
    Function GetTitleST : String;
    Procedure SetTitleST(value : String);
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetText(value : TFhirNarrative);
    Procedure SetMode(value : TFhirEnum);
    Function GetModeST : TFhirListModeEnum;
    Procedure SetModeST(value : TFhirListModeEnum);
    Procedure SetOrderedBy(value : TFhirCodeableConcept);
    function GetEntryList : TFhirReferenceList{TFhirReference};
    function GetHasEntryList : Boolean;
    Procedure SetEmptyReason(value : TFhirCodeableConcept);
    function GetSectionList : TFhirCompositionSectionList;
    function GetHasSectionList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCompositionSection; overload;
    function Clone : TFhirCompositionSection; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The label for this particular section.  This will be part of the rendered content for the document, and is often used to build a table of contents.
    property title : String read GetTitleST write SetTitleST;
    // The label for this particular section.  This will be part of the rendered content for the document, and is often used to build a table of contents.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to A code identifying the kind of content contained within the section. This must be consistent with the section title. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code identifying the kind of content contained within the section. This must be consistent with the section title.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to A human-readable narrative that contains the attested content of the section, used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. (defined for API consistency)
    property text : TFhirNarrative read FText write SetText;
    // A human-readable narrative that contains the attested content of the section, used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative.
    property textElement : TFhirNarrative read FText write SetText;

    // How the entry list was prepared - whether it is a working list that is suitable for being maintained on an ongoing basis, or if it represents a snapshot of a list of items from another source, or whether it is a prepared list where items may be marked as added, modified or deleted.
    property mode : TFhirListModeEnum read GetModeST write SetModeST;
    property modeElement : TFhirEnum read FMode write SetMode;

    // Typed access to Specifies the order applied to the items in the section entries. (defined for API consistency)
    property orderedBy : TFhirCodeableConcept read FOrderedBy write SetOrderedBy;
    // Specifies the order applied to the items in the section entries.
    property orderedByElement : TFhirCodeableConcept read FOrderedBy write SetOrderedBy;

    // A reference to the actual resource from which the narrative in the section is derived.
    property entryList : TFhirReferenceList{TFhirReference} read GetEntryList;
    property hasEntryList : boolean read GetHasEntryList;

    // Typed access to If the section is empty, why the list is empty. An empty section typically has some text explaining the empty reason. (defined for API consistency)
    property emptyReason : TFhirCodeableConcept read FEmptyReason write SetEmptyReason;
    // If the section is empty, why the list is empty. An empty section typically has some text explaining the empty reason.
    property emptyReasonElement : TFhirCodeableConcept read FEmptyReason write SetEmptyReason;

    // A nested sub-section within this section.
    property sectionList : TFhirCompositionSectionList read GetSectionList;
    property hasSectionList : boolean read GetHasSectionList;

  end;

  TFhirCompositionSectionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCompositionSectionList;
    function GetCurrent : TFhirCompositionSection;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCompositionSectionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCompositionSection read GetCurrent;
  end;

  TFhirCompositionSectionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCompositionSection;
    procedure SetItemN(index : Integer; value : TFhirCompositionSection);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCompositionSectionList; Overload;
    function Clone : TFhirCompositionSectionList; Overload;
    function GetEnumerator : TFhirCompositionSectionListEnumerator;

    //  Add a FhirCompositionSection to the end of the list.
    function Append : TFhirCompositionSection;

    // Add an already existing FhirCompositionSection to the end of the list.
    procedure AddItem(value : TFhirCompositionSection); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCompositionSection) : Integer;

    // Insert FhirCompositionSection before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCompositionSection;

    // Insert an existing FhirCompositionSection before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCompositionSection);

    // Get the iIndexth FhirCompositionSection. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCompositionSection);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCompositionSection;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCompositionSections[index : Integer] : TFhirCompositionSection read GetItemN write SetItemN; default;
  End;

  // A set of healthcare-related information that is assembled together into a single logical document that provides a single coherent statement of meaning, establishes its own context and that has clinical attestation with regard to who is making the statement. While a Composition defines the structure, it does not actually contain the content: rather the full content of a document is contained in a Bundle, of which the Composition is the first resource contained.
  TFhirComposition = class (TFhirDomainResource)
  protected
    FIdentifier : TFhirIdentifier;
    FDate : TFhirDateTime;
    FType_ : TFhirCodeableConcept;
    FClass_ : TFhirCodeableConcept;
    FTitle : TFhirString;
    FStatus : TFhirEnum;
    FConfidentiality : TFhirEnum;
    FSubject : TFhirReference{TFhirReference};
    FauthorList : TFhirReferenceList{Resource};
    FattesterList : TFhirCompositionAttesterList;
    FCustodian : TFhirReference{TFhirOrganization};
    FeventList : TFhirCompositionEventList;
    FEncounter : TFhirReference{TFhirEncounter};
    FsectionList : TFhirCompositionSectionList;
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetClass_(value : TFhirCodeableConcept);
    Procedure SetTitle(value : TFhirString);
    Function GetTitleST : String;
    Procedure SetTitleST(value : String);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirCompositionStatusEnum;
    Procedure SetStatusST(value : TFhirCompositionStatusEnum);
    Procedure SetConfidentiality(value : TFhirEnum);
    Function GetConfidentialityST : TFhirV3ConfidentialityEnum;
    Procedure SetConfidentialityST(value : TFhirV3ConfidentialityEnum);
    Procedure SetSubject(value : TFhirReference{TFhirReference});
    function GetAuthorList : TFhirReferenceList{Resource};
    function GetHasAuthorList : Boolean;
    function GetAttesterList : TFhirCompositionAttesterList;
    function GetHasAttesterList : Boolean;
    Procedure SetCustodian(value : TFhirReference{TFhirOrganization});
    function GetEventList : TFhirCompositionEventList;
    function GetHasEventList : Boolean;
    Procedure SetEncounter(value : TFhirReference{TFhirEncounter});
    function GetSectionList : TFhirCompositionSectionList;
    function GetHasSectionList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirComposition; overload;
    function Clone : TFhirComposition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Logical identifier for the composition, assigned when created. This identifier stays constant as the composition is changed over time. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Logical identifier for the composition, assigned when created. This identifier stays constant as the composition is changed over time.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to The composition editing time, when the composition was last logically changed by the author.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The composition editing time, when the composition was last logically changed by the author.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to Specifies the particular kind of composition (e.g. History and Physical, Discharge Summary, Progress Note). This usually equates to the purpose of making the composition. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Specifies the particular kind of composition (e.g. History and Physical, Discharge Summary, Progress Note). This usually equates to the purpose of making the composition.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to A categorization for the type of the composition - helps for indexing and searching. This may be implied by or derived from the code specified in the Composition Type. (defined for API consistency)
    property class_ : TFhirCodeableConcept read FClass_ write SetClass_;
    // A categorization for the type of the composition - helps for indexing and searching. This may be implied by or derived from the code specified in the Composition Type.
    property class_Element : TFhirCodeableConcept read FClass_ write SetClass_;

    // Typed access to Official human-readable label for the composition.
    property title : String read GetTitleST write SetTitleST;
    // Official human-readable label for the composition.
    property titleElement : TFhirString read FTitle write SetTitle;

    // The workflow/clinical status of this composition. The status is a marker for the clinical standing of the document.
    property status : TFhirCompositionStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // The code specifying the level of confidentiality of the Composition.
    property confidentiality : TFhirV3ConfidentialityEnum read GetConfidentialityST write SetConfidentialityST;
    property confidentialityElement : TFhirEnum read FConfidentiality write SetConfidentiality;

    // Typed access to Who or what the composition is about. The composition can be about a person, (patient or healthcare practitioner), a device (e.g. a machine) or even a group of subjects (such as a document about a herd of livestock, or a set of patients that share a common exposure). (defined for API consistency)
    property subject : TFhirReference{TFhirReference} read FSubject write SetSubject;
    // Who or what the composition is about. The composition can be about a person, (patient or healthcare practitioner), a device (e.g. a machine) or even a group of subjects (such as a document about a herd of livestock, or a set of patients that share a common exposure).
    property subjectElement : TFhirReference{TFhirReference} read FSubject write SetSubject;

    // Identifies who is responsible for the information in the composition, not necessarily who typed it in.
    property authorList : TFhirReferenceList{Resource} read GetAuthorList;
    property hasAuthorList : boolean read GetHasAuthorList;

    // A participant who has attested to the accuracy of the composition/document.
    property attesterList : TFhirCompositionAttesterList read GetAttesterList;
    property hasAttesterList : boolean read GetHasAttesterList;

    // Typed access to Identifies the organization or group who is responsible for ongoing maintenance of and access to the composition/document information. (defined for API consistency)
    property custodian : TFhirReference{TFhirOrganization} read FCustodian write SetCustodian;
    // Identifies the organization or group who is responsible for ongoing maintenance of and access to the composition/document information.
    property custodianElement : TFhirReference{TFhirOrganization} read FCustodian write SetCustodian;

    // The clinical service, such as a colonoscopy or an appendectomy, being documented.
    property eventList : TFhirCompositionEventList read GetEventList;
    property hasEventList : boolean read GetHasEventList;

    // Typed access to Describes the clinical encounter or type of care this documentation is associated with. (defined for API consistency)
    property encounter : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;
    // Describes the clinical encounter or type of care this documentation is associated with.
    property encounterElement : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;

    // The root of the sections that make up the composition.
    property sectionList : TFhirCompositionSectionList read GetSectionList;
    property hasSectionList : boolean read GetHasSectionList;

  end;

  TFhirCompositionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCompositionList;
    function GetCurrent : TFhirComposition;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCompositionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirComposition read GetCurrent;
  end;

  TFhirCompositionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirComposition;
    procedure SetItemN(index : Integer; value : TFhirComposition);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCompositionList; Overload;
    function Clone : TFhirCompositionList; Overload;
    function GetEnumerator : TFhirCompositionListEnumerator;

    //  Add a FhirComposition to the end of the list.
    function Append : TFhirComposition;

    // Add an already existing FhirComposition to the end of the list.
    procedure AddItem(value : TFhirComposition); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirComposition) : Integer;

    // Insert FhirComposition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirComposition;

    // Insert an existing FhirComposition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirComposition);

    // Get the iIndexth FhirComposition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirComposition);

    // The number of items in the collection
    function Item(index : Integer) : TFhirComposition;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCompositions[index : Integer] : TFhirComposition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_COMPOSITION}

{$IFDEF FHIR_CONDITION}

  // Clinical stage or grade of a condition. May include formal severity assessments.
  TFhirConditionStage = class (TFhirBackboneElement)
  protected
    FSummary : TFhirCodeableConcept;
    FassessmentList : TFhirReferenceList{Resource};
    Procedure SetSummary(value : TFhirCodeableConcept);
    function GetAssessmentList : TFhirReferenceList{Resource};
    function GetHasAssessmentList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConditionStage; overload;
    function Clone : TFhirConditionStage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A simple summary of the stage such as "Stage 3". The determination of the stage is disease-specific. (defined for API consistency)
    property summary : TFhirCodeableConcept read FSummary write SetSummary;
    // A simple summary of the stage such as "Stage 3". The determination of the stage is disease-specific.
    property summaryElement : TFhirCodeableConcept read FSummary write SetSummary;

    // Reference to a formal record of the evidence on which the staging assessment is based.
    property assessmentList : TFhirReferenceList{Resource} read GetAssessmentList;
    property hasAssessmentList : boolean read GetHasAssessmentList;

  end;

  TFhirConditionStageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConditionStageList;
    function GetCurrent : TFhirConditionStage;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConditionStageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConditionStage read GetCurrent;
  end;

  TFhirConditionStageList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConditionStage;
    procedure SetItemN(index : Integer; value : TFhirConditionStage);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConditionStageList; Overload;
    function Clone : TFhirConditionStageList; Overload;
    function GetEnumerator : TFhirConditionStageListEnumerator;

    //  Add a FhirConditionStage to the end of the list.
    function Append : TFhirConditionStage;

    // Add an already existing FhirConditionStage to the end of the list.
    procedure AddItem(value : TFhirConditionStage); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConditionStage) : Integer;

    // Insert FhirConditionStage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConditionStage;

    // Insert an existing FhirConditionStage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConditionStage);

    // Get the iIndexth FhirConditionStage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConditionStage);

    // The number of items in the collection
    function Item(index : Integer) : TFhirConditionStage;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirConditionStages[index : Integer] : TFhirConditionStage read GetItemN write SetItemN; default;
  End;

  // Supporting Evidence / manifestations that are the basis on which this condition is suspected or confirmed.
  TFhirConditionEvidence = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FdetailList : TFhirReferenceList{TFhirReference};
    Procedure SetCode(value : TFhirCodeableConcept);
    function GetDetailList : TFhirReferenceList{TFhirReference};
    function GetHasDetailList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConditionEvidence; overload;
    function Clone : TFhirConditionEvidence; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A manifestation or symptom that led to the recording of this condition. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A manifestation or symptom that led to the recording of this condition.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Links to other relevant information, including pathology reports.
    property detailList : TFhirReferenceList{TFhirReference} read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

  end;

  TFhirConditionEvidenceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConditionEvidenceList;
    function GetCurrent : TFhirConditionEvidence;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConditionEvidenceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConditionEvidence read GetCurrent;
  end;

  TFhirConditionEvidenceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConditionEvidence;
    procedure SetItemN(index : Integer; value : TFhirConditionEvidence);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConditionEvidenceList; Overload;
    function Clone : TFhirConditionEvidenceList; Overload;
    function GetEnumerator : TFhirConditionEvidenceListEnumerator;

    //  Add a FhirConditionEvidence to the end of the list.
    function Append : TFhirConditionEvidence;

    // Add an already existing FhirConditionEvidence to the end of the list.
    procedure AddItem(value : TFhirConditionEvidence); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConditionEvidence) : Integer;

    // Insert FhirConditionEvidence before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConditionEvidence;

    // Insert an existing FhirConditionEvidence before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConditionEvidence);

    // Get the iIndexth FhirConditionEvidence. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConditionEvidence);

    // The number of items in the collection
    function Item(index : Integer) : TFhirConditionEvidence;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirConditionEvidences[index : Integer] : TFhirConditionEvidence read GetItemN write SetItemN; default;
  End;

  // Use to record detailed information about conditions, problems or diagnoses recognized by a clinician. There are many uses including: recording a diagnosis during an encounter; populating a problem list or a summary statement, such as a discharge summary.
  TFhirCondition = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FPatient : TFhirReference{TFhirPatient};
    FEncounter : TFhirReference{TFhirEncounter};
    FAsserter : TFhirReference{Resource};
    FDateRecorded : TFhirDate;
    FCode : TFhirCodeableConcept;
    FCategory : TFhirCodeableConcept;
    FClinicalStatus : TFhirCode;
    FVerificationStatus : TFhirEnum;
    FSeverity : TFhirCodeableConcept;
    FOnset : TFhirType;
    FAbatement : TFhirType;
    FStage : TFhirConditionStage;
    FevidenceList : TFhirConditionEvidenceList;
    FbodySiteList : TFhirCodeableConceptList;
    FNotes : TFhirString;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    Procedure SetEncounter(value : TFhirReference{TFhirEncounter});
    Procedure SetAsserter(value : TFhirReference{Resource});
    Procedure SetDateRecorded(value : TFhirDate);
    Function GetDateRecordedST : TFslDateTime;
    Procedure SetDateRecordedST(value : TFslDateTime);
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetClinicalStatus(value : TFhirCode);
    Function GetClinicalStatusST : String;
    Procedure SetClinicalStatusST(value : String);
    Procedure SetVerificationStatus(value : TFhirEnum);
    Function GetVerificationStatusST : TFhirConditionVerStatusEnum;
    Procedure SetVerificationStatusST(value : TFhirConditionVerStatusEnum);
    Procedure SetSeverity(value : TFhirCodeableConcept);
    Procedure SetOnset(value : TFhirType);
    Procedure SetAbatement(value : TFhirType);
    Procedure SetStage(value : TFhirConditionStage);
    function GetEvidenceList : TFhirConditionEvidenceList;
    function GetHasEvidenceList : Boolean;
    function GetBodySiteList : TFhirCodeableConceptList;
    function GetHasBodySiteList : Boolean;
    Procedure SetNotes(value : TFhirString);
    Function GetNotesST : String;
    Procedure SetNotesST(value : String);

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCondition; overload;
    function Clone : TFhirCondition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // This records identifiers associated with this condition that are defined by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate (e.g. in CDA documents, or in written / printed documentation).
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Indicates the patient who the condition record is associated with. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // Indicates the patient who the condition record is associated with.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Typed access to Encounter during which the condition was first asserted. (defined for API consistency)
    property encounter : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;
    // Encounter during which the condition was first asserted.
    property encounterElement : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;

    // Typed access to Individual who is making the condition statement. (defined for API consistency)
    property asserter : TFhirReference{Resource} read FAsserter write SetAsserter;
    // Individual who is making the condition statement.
    property asserterElement : TFhirReference{Resource} read FAsserter write SetAsserter;

    // Typed access to A date, when  the Condition statement was documented.
    property dateRecorded : TFslDateTime read GetDateRecordedST write SetDateRecordedST;
    // A date, when  the Condition statement was documented.
    property dateRecordedElement : TFhirDate read FDateRecorded write SetDateRecorded;

    // Typed access to Identification of the condition, problem or diagnosis. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Identification of the condition, problem or diagnosis.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to A category assigned to the condition. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // A category assigned to the condition.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to The clinical status of the condition.
    property clinicalStatus : String read GetClinicalStatusST write SetClinicalStatusST;
    // The clinical status of the condition.
    property clinicalStatusElement : TFhirCode read FClinicalStatus write SetClinicalStatus;

    // The verification status to support the clinical status of the condition.
    property verificationStatus : TFhirConditionVerStatusEnum read GetVerificationStatusST write SetVerificationStatusST;
    property verificationStatusElement : TFhirEnum read FVerificationStatus write SetVerificationStatus;

    // Typed access to A subjective assessment of the severity of the condition as evaluated by the clinician. (defined for API consistency)
    property severity : TFhirCodeableConcept read FSeverity write SetSeverity;
    // A subjective assessment of the severity of the condition as evaluated by the clinician.
    property severityElement : TFhirCodeableConcept read FSeverity write SetSeverity;

    // Typed access to Estimated or actual date or date-time  the condition began, in the opinion of the clinician. (defined for API consistency)
    property onset : TFhirType read FOnset write SetOnset;
    // Estimated or actual date or date-time  the condition began, in the opinion of the clinician.
    property onsetElement : TFhirType read FOnset write SetOnset;

    // Typed access to The date or estimated date that the condition resolved or went into remission. This is called "abatement" because of the many overloaded connotations associated with "remission" or "resolution" - Conditions are never really resolved, but they can abate. (defined for API consistency)
    property abatement : TFhirType read FAbatement write SetAbatement;
    // The date or estimated date that the condition resolved or went into remission. This is called "abatement" because of the many overloaded connotations associated with "remission" or "resolution" - Conditions are never really resolved, but they can abate.
    property abatementElement : TFhirType read FAbatement write SetAbatement;

    // Typed access to Clinical stage or grade of a condition. May include formal severity assessments. (defined for API consistency)
    property stage : TFhirConditionStage read FStage write SetStage;
    // Clinical stage or grade of a condition. May include formal severity assessments.
    property stageElement : TFhirConditionStage read FStage write SetStage;

    // Supporting Evidence / manifestations that are the basis on which this condition is suspected or confirmed.
    property evidenceList : TFhirConditionEvidenceList read GetEvidenceList;
    property hasEvidenceList : boolean read GetHasEvidenceList;

    // The anatomical location where this condition manifests itself.
    property bodySiteList : TFhirCodeableConceptList read GetBodySiteList;
    property hasBodySiteList : boolean read GetHasBodySiteList;

    // Typed access to Additional information about the Condition. This is a general notes/comments entry  for description of the Condition, its diagnosis and prognosis.
    property notes : String read GetNotesST write SetNotesST;
    // Additional information about the Condition. This is a general notes/comments entry  for description of the Condition, its diagnosis and prognosis.
    property notesElement : TFhirString read FNotes write SetNotes;

  end;

  TFhirConditionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConditionList;
    function GetCurrent : TFhirCondition;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConditionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCondition read GetCurrent;
  end;

  TFhirConditionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCondition;
    procedure SetItemN(index : Integer; value : TFhirCondition);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConditionList; Overload;
    function Clone : TFhirConditionList; Overload;
    function GetEnumerator : TFhirConditionListEnumerator;

    //  Add a FhirCondition to the end of the list.
    function Append : TFhirCondition;

    // Add an already existing FhirCondition to the end of the list.
    procedure AddItem(value : TFhirCondition); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCondition) : Integer;

    // Insert FhirCondition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCondition;

    // Insert an existing FhirCondition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCondition);

    // Get the iIndexth FhirCondition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCondition);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCondition;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirConditions[index : Integer] : TFhirCondition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CONDITION}

{$IFDEF FHIR_COVERAGE}

  // Financial instrument which may be used to pay for or reimburse health care products and services.
  TFhirCoverage = class (TFhirDomainResource)
  protected
    FIssuer : TFhirReference{TFhirOrganization};
    FBin : TFhirIdentifier;
    FPeriod : TFhirPeriod;
    FType_ : TFhirCoding;
    FSubscriberId : TFhirIdentifier;
    FidentifierList : TFhirIdentifierList;
    FGroup : TFhirString;
    FPlan : TFhirString;
    FSubPlan : TFhirString;
    FDependent : TFhirPositiveInt;
    FSequence : TFhirPositiveInt;
    FSubscriber : TFhirReference{TFhirPatient};
    FNetwork : TFhirIdentifier;
    FcontractList : TFhirReferenceList{TFhirContract};
    Procedure SetIssuer(value : TFhirReference{TFhirOrganization});
    Procedure SetBin(value : TFhirIdentifier);
    Procedure SetPeriod(value : TFhirPeriod);
    Procedure SetType_(value : TFhirCoding);
    Procedure SetSubscriberId(value : TFhirIdentifier);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetGroup(value : TFhirString);
    Function GetGroupST : String;
    Procedure SetGroupST(value : String);
    Procedure SetPlan(value : TFhirString);
    Function GetPlanST : String;
    Procedure SetPlanST(value : String);
    Procedure SetSubPlan(value : TFhirString);
    Function GetSubPlanST : String;
    Procedure SetSubPlanST(value : String);
    Procedure SetDependent(value : TFhirPositiveInt);
    Function GetDependentST : String;
    Procedure SetDependentST(value : String);
    Procedure SetSequence(value : TFhirPositiveInt);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    Procedure SetSubscriber(value : TFhirReference{TFhirPatient});
    Procedure SetNetwork(value : TFhirIdentifier);
    function GetContractList : TFhirReferenceList{TFhirContract};
    function GetHasContractList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverage; overload;
    function Clone : TFhirCoverage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The program or plan underwriter or payor. (defined for API consistency)
    property issuer : TFhirReference{TFhirOrganization} read FIssuer write SetIssuer;
    // The program or plan underwriter or payor.
    property issuerElement : TFhirReference{TFhirOrganization} read FIssuer write SetIssuer;

    // Typed access to Business Identification Number (BIN number) used to identify the routing  of eclaims if the insurer themselves don't have a BIN number for all of their business. (defined for API consistency)
    property bin : TFhirIdentifier read FBin write SetBin;
    // Business Identification Number (BIN number) used to identify the routing  of eclaims if the insurer themselves don't have a BIN number for all of their business.
    property binElement : TFhirIdentifier read FBin write SetBin;

    // Typed access to Time period during which the coverage is in force. A missing start date indicates the start date isn't known, a missing end date means the coverage is continuing to be in force. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Time period during which the coverage is in force. A missing start date indicates the start date isn't known, a missing end date means the coverage is continuing to be in force.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to The type of coverage: social program, medical plan, accident coverage (workers compensation, auto), group health. (defined for API consistency)
    property type_ : TFhirCoding read FType_ write SetType_;
    // The type of coverage: social program, medical plan, accident coverage (workers compensation, auto), group health.
    property type_Element : TFhirCoding read FType_ write SetType_;

    // Typed access to The id issued to the subscriber. (defined for API consistency)
    property subscriberId : TFhirIdentifier read FSubscriberId write SetSubscriberId;
    // The id issued to the subscriber.
    property subscriberIdElement : TFhirIdentifier read FSubscriberId write SetSubscriberId;

    // The main (and possibly only) identifier for the coverage - often referred to as a Member Id, Subscriber Id, Certificate number or Personal Health Number or Case ID.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Identifies a style or collective of coverage issues by the underwriter, for example may be used to identify a class of coverage or employer group. May also be referred to as a Policy or Group ID.
    property group : String read GetGroupST write SetGroupST;
    // Identifies a style or collective of coverage issues by the underwriter, for example may be used to identify a class of coverage or employer group. May also be referred to as a Policy or Group ID.
    property groupElement : TFhirString read FGroup write SetGroup;

    // Typed access to Identifies a style or collective of coverage issues by the underwriter, for example may be used to identify a class of coverage or employer group. May also be referred to as a Policy or Group ID.
    property plan : String read GetPlanST write SetPlanST;
    // Identifies a style or collective of coverage issues by the underwriter, for example may be used to identify a class of coverage or employer group. May also be referred to as a Policy or Group ID.
    property planElement : TFhirString read FPlan write SetPlan;

    // Typed access to Identifies a sub-style or sub-collective of coverage issues by the underwriter, for example may be used to identify a specific employer group within a class of employers. May be referred to as a Section or Division ID.
    property subPlan : String read GetSubPlanST write SetSubPlanST;
    // Identifies a sub-style or sub-collective of coverage issues by the underwriter, for example may be used to identify a specific employer group within a class of employers. May be referred to as a Section or Division ID.
    property subPlanElement : TFhirString read FSubPlan write SetSubPlan;

    // Typed access to A unique identifier for a dependent under the coverage.
    property dependent : String read GetDependentST write SetDependentST;
    // A unique identifier for a dependent under the coverage.
    property dependentElement : TFhirPositiveInt read FDependent write SetDependent;

    // Typed access to An optional counter for a particular instance of the identified coverage which increments upon each renewal.
    property sequence : String read GetSequenceST write SetSequenceST;
    // An optional counter for a particular instance of the identified coverage which increments upon each renewal.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The party who 'owns' the insurance contractual relationship to the policy or to whom the benefit of the policy is due. (defined for API consistency)
    property subscriber : TFhirReference{TFhirPatient} read FSubscriber write SetSubscriber;
    // The party who 'owns' the insurance contractual relationship to the policy or to whom the benefit of the policy is due.
    property subscriberElement : TFhirReference{TFhirPatient} read FSubscriber write SetSubscriber;

    // Typed access to The identifier for a community of providers. (defined for API consistency)
    property network : TFhirIdentifier read FNetwork write SetNetwork;
    // The identifier for a community of providers.
    property networkElement : TFhirIdentifier read FNetwork write SetNetwork;

    // The policy(s) which constitute this insurance coverage.
    property contractList : TFhirReferenceList{TFhirContract} read GetContractList;
    property hasContractList : boolean read GetHasContractList;

  end;

  TFhirCoverageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageList;
    function GetCurrent : TFhirCoverage;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCoverageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverage read GetCurrent;
  end;

  TFhirCoverageList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCoverage;
    procedure SetItemN(index : Integer; value : TFhirCoverage);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCoverageList; Overload;
    function Clone : TFhirCoverageList; Overload;
    function GetEnumerator : TFhirCoverageListEnumerator;

    //  Add a FhirCoverage to the end of the list.
    function Append : TFhirCoverage;

    // Add an already existing FhirCoverage to the end of the list.
    procedure AddItem(value : TFhirCoverage); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverage) : Integer;

    // Insert FhirCoverage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverage;

    // Insert an existing FhirCoverage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverage);

    // Get the iIndexth FhirCoverage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverage);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverage;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCoverages[index : Integer] : TFhirCoverage read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_COVERAGE}

{$IFDEF FHIR_DETECTEDISSUE}

  // Indicates an action that has been taken or is committed to to reduce or eliminate the likelihood of the risk identified by the detected issue from manifesting.  Can also reflect an observation of known mitigating factors that may reduce/eliminate the need for any action.
  TFhirDetectedIssueMitigation = class (TFhirBackboneElement)
  protected
    FAction : TFhirCodeableConcept;
    FDate : TFhirDateTime;
    FAuthor : TFhirReference{TFhirPractitioner};
    Procedure SetAction(value : TFhirCodeableConcept);
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetAuthor(value : TFhirReference{TFhirPractitioner});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDetectedIssueMitigation; overload;
    function Clone : TFhirDetectedIssueMitigation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Describes the action that was taken or the observation that was made that reduces/eliminates the risk associated with the identified issue. (defined for API consistency)
    property action : TFhirCodeableConcept read FAction write SetAction;
    // Describes the action that was taken or the observation that was made that reduces/eliminates the risk associated with the identified issue.
    property actionElement : TFhirCodeableConcept read FAction write SetAction;

    // Typed access to Indicates when the mitigating action was documented.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Indicates when the mitigating action was documented.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to Identifies the practitioner who determined the mitigation and takes responsibility for the mitigation step occurring. (defined for API consistency)
    property author : TFhirReference{TFhirPractitioner} read FAuthor write SetAuthor;
    // Identifies the practitioner who determined the mitigation and takes responsibility for the mitigation step occurring.
    property authorElement : TFhirReference{TFhirPractitioner} read FAuthor write SetAuthor;

  end;

  TFhirDetectedIssueMitigationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDetectedIssueMitigationList;
    function GetCurrent : TFhirDetectedIssueMitigation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDetectedIssueMitigationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDetectedIssueMitigation read GetCurrent;
  end;

  TFhirDetectedIssueMitigationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDetectedIssueMitigation;
    procedure SetItemN(index : Integer; value : TFhirDetectedIssueMitigation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDetectedIssueMitigationList; Overload;
    function Clone : TFhirDetectedIssueMitigationList; Overload;
    function GetEnumerator : TFhirDetectedIssueMitigationListEnumerator;

    //  Add a FhirDetectedIssueMitigation to the end of the list.
    function Append : TFhirDetectedIssueMitigation;

    // Add an already existing FhirDetectedIssueMitigation to the end of the list.
    procedure AddItem(value : TFhirDetectedIssueMitigation); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDetectedIssueMitigation) : Integer;

    // Insert FhirDetectedIssueMitigation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDetectedIssueMitigation;

    // Insert an existing FhirDetectedIssueMitigation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDetectedIssueMitigation);

    // Get the iIndexth FhirDetectedIssueMitigation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDetectedIssueMitigation);

    // The number of items in the collection
    function Item(index : Integer) : TFhirDetectedIssueMitigation;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirDetectedIssueMitigations[index : Integer] : TFhirDetectedIssueMitigation read GetItemN write SetItemN; default;
  End;

  // Indicates an actual or potential clinical issue with or between one or more active or proposed clinical actions for a patient; e.g. Drug-drug interaction, Ineffective treatment frequency, Procedure-condition conflict, etc.
  TFhirDetectedIssue = class (TFhirDomainResource)
  protected
    FPatient : TFhirReference{TFhirPatient};
    FCategory : TFhirCodeableConcept;
    FSeverity : TFhirEnum;
    FimplicatedList : TFhirReferenceList{TFhirReference};
    FDetail : TFhirString;
    FDate : TFhirDateTime;
    FAuthor : TFhirReference{Resource};
    FIdentifier : TFhirIdentifier;
    FReference : TFhirUri;
    FmitigationList : TFhirDetectedIssueMitigationList;
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetSeverity(value : TFhirEnum);
    Function GetSeverityST : TFhirDetectedissueSeverityEnum;
    Procedure SetSeverityST(value : TFhirDetectedissueSeverityEnum);
    function GetImplicatedList : TFhirReferenceList{TFhirReference};
    function GetHasImplicatedList : Boolean;
    Procedure SetDetail(value : TFhirString);
    Function GetDetailST : String;
    Procedure SetDetailST(value : String);
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetAuthor(value : TFhirReference{Resource});
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetReference(value : TFhirUri);
    Function GetReferenceST : String;
    Procedure SetReferenceST(value : String);
    function GetMitigationList : TFhirDetectedIssueMitigationList;
    function GetHasMitigationList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDetectedIssue; overload;
    function Clone : TFhirDetectedIssue; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Indicates the patient whose record the detected issue is associated with. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // Indicates the patient whose record the detected issue is associated with.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Typed access to Identifies the general type of issue identified. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Identifies the general type of issue identified.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Indicates the degree of importance associated with the identified issue based on the potential impact on the patient.
    property severity : TFhirDetectedissueSeverityEnum read GetSeverityST write SetSeverityST;
    property severityElement : TFhirEnum read FSeverity write SetSeverity;

    // Indicates the resource representing the current activity or proposed activity that is potentially problematic.
    property implicatedList : TFhirReferenceList{TFhirReference} read GetImplicatedList;
    property hasImplicatedList : boolean read GetHasImplicatedList;

    // Typed access to A textual explanation of the detected issue.
    property detail : String read GetDetailST write SetDetailST;
    // A textual explanation of the detected issue.
    property detailElement : TFhirString read FDetail write SetDetail;

    // Typed access to The date or date-time when the detected issue was initially identified.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date or date-time when the detected issue was initially identified.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to Individual or device responsible for the issue being raised.  For example, a decision support application or a pharmacist conducting a medication review. (defined for API consistency)
    property author : TFhirReference{Resource} read FAuthor write SetAuthor;
    // Individual or device responsible for the issue being raised.  For example, a decision support application or a pharmacist conducting a medication review.
    property authorElement : TFhirReference{Resource} read FAuthor write SetAuthor;

    // Typed access to Business identifier associated with the detected issue record. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Business identifier associated with the detected issue record.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to The literature, knowledge-base or similar reference that describes the propensity for the detected issue identified.
    property reference : String read GetReferenceST write SetReferenceST;
    // The literature, knowledge-base or similar reference that describes the propensity for the detected issue identified.
    property referenceElement : TFhirUri read FReference write SetReference;

    // Indicates an action that has been taken or is committed to to reduce or eliminate the likelihood of the risk identified by the detected issue from manifesting.  Can also reflect an observation of known mitigating factors that may reduce/eliminate the need for any action.
    property mitigationList : TFhirDetectedIssueMitigationList read GetMitigationList;
    property hasMitigationList : boolean read GetHasMitigationList;

  end;

  TFhirDetectedIssueListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDetectedIssueList;
    function GetCurrent : TFhirDetectedIssue;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDetectedIssueList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDetectedIssue read GetCurrent;
  end;

  TFhirDetectedIssueList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDetectedIssue;
    procedure SetItemN(index : Integer; value : TFhirDetectedIssue);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDetectedIssueList; Overload;
    function Clone : TFhirDetectedIssueList; Overload;
    function GetEnumerator : TFhirDetectedIssueListEnumerator;

    //  Add a FhirDetectedIssue to the end of the list.
    function Append : TFhirDetectedIssue;

    // Add an already existing FhirDetectedIssue to the end of the list.
    procedure AddItem(value : TFhirDetectedIssue); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDetectedIssue) : Integer;

    // Insert FhirDetectedIssue before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDetectedIssue;

    // Insert an existing FhirDetectedIssue before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDetectedIssue);

    // Get the iIndexth FhirDetectedIssue. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDetectedIssue);

    // The number of items in the collection
    function Item(index : Integer) : TFhirDetectedIssue;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirDetectedIssues[index : Integer] : TFhirDetectedIssue read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_DETECTEDISSUE}

{$IFDEF FHIR_DEVICEUSEREQUEST}

  // Represents a request for a patient to employ a medical device. The device may be an implantable device, or an external assistive device, such as a walker.
  TFhirDeviceUseRequest = class (TFhirDomainResource)
  protected
    FBodySite : TFhirType;
    FStatus : TFhirEnum;
    FDevice : TFhirReference{TFhirDevice};
    FEncounter : TFhirReference{TFhirEncounter};
    FidentifierList : TFhirIdentifierList;
    FindicationList : TFhirCodeableConceptList;
    FnotesList : TFhirStringList;
    FprnReasonList : TFhirCodeableConceptList;
    FOrderedOn : TFhirDateTime;
    FRecordedOn : TFhirDateTime;
    FSubject : TFhirReference{TFhirPatient};
    FTiming : TFhirType;
    FPriority : TFhirEnum;
    Procedure SetBodySite(value : TFhirType);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirDeviceUseRequestStatusEnum;
    Procedure SetStatusST(value : TFhirDeviceUseRequestStatusEnum);
    Procedure SetDevice(value : TFhirReference{TFhirDevice});
    Procedure SetEncounter(value : TFhirReference{TFhirEncounter});
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetIndicationList : TFhirCodeableConceptList;
    function GetHasIndicationList : Boolean;
    function GetNotesList : TFhirStringList;
    function GetHasNotesList : Boolean;
    function GetPrnReasonList : TFhirCodeableConceptList;
    function GetHasPrnReasonList : Boolean;
    Procedure SetOrderedOn(value : TFhirDateTime);
    Function GetOrderedOnST : TFslDateTime;
    Procedure SetOrderedOnST(value : TFslDateTime);
    Procedure SetRecordedOn(value : TFhirDateTime);
    Function GetRecordedOnST : TFslDateTime;
    Procedure SetRecordedOnST(value : TFslDateTime);
    Procedure SetSubject(value : TFhirReference{TFhirPatient});
    Procedure SetTiming(value : TFhirType);
    Procedure SetPriority(value : TFhirEnum);
    Function GetPriorityST : TFhirDeviceUseRequestPriorityEnum;
    Procedure SetPriorityST(value : TFhirDeviceUseRequestPriorityEnum);

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceUseRequest; overload;
    function Clone : TFhirDeviceUseRequest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Indicates the site on the subject's body where the device should be used ( i.e. the target site). (defined for API consistency)
    property bodySite : TFhirType read FBodySite write SetBodySite;
    // Indicates the site on the subject's body where the device should be used ( i.e. the target site).
    property bodySiteElement : TFhirType read FBodySite write SetBodySite;

    // The status of the request.
    property status : TFhirDeviceUseRequestStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The details of the device  to be used. (defined for API consistency)
    property device : TFhirReference{TFhirDevice} read FDevice write SetDevice;
    // The details of the device  to be used.
    property deviceElement : TFhirReference{TFhirDevice} read FDevice write SetDevice;

    // Typed access to An encounter that provides additional context in which this request is made. (defined for API consistency)
    property encounter : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;
    // An encounter that provides additional context in which this request is made.
    property encounterElement : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;

    // Identifiers assigned to this order by the orderer or by the receiver.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Reason or justification for the use of this device.
    property indicationList : TFhirCodeableConceptList read GetIndicationList;
    property hasIndicationList : boolean read GetHasIndicationList;

    // Details about this request that were not represented at all or sufficiently in one of the attributes provided in a class. These may include for example a comment, an instruction, or a note associated with the statement.
    property notesList : TFhirStringList read GetNotesList;
    property hasNotesList : boolean read GetHasNotesList;

    // The proposed act must be performed if the indicated conditions occur, e.g.., shortness of breath, SpO2 less than x%.
    property prnReasonList : TFhirCodeableConceptList read GetPrnReasonList;
    property hasPrnReasonList : boolean read GetHasPrnReasonList;

    // Typed access to The time when the request was made.
    property orderedOn : TFslDateTime read GetOrderedOnST write SetOrderedOnST;
    // The time when the request was made.
    property orderedOnElement : TFhirDateTime read FOrderedOn write SetOrderedOn;

    // Typed access to The time at which the request was made/recorded.
    property recordedOn : TFslDateTime read GetRecordedOnST write SetRecordedOnST;
    // The time at which the request was made/recorded.
    property recordedOnElement : TFhirDateTime read FRecordedOn write SetRecordedOn;

    // Typed access to The patient who will use the device. (defined for API consistency)
    property subject : TFhirReference{TFhirPatient} read FSubject write SetSubject;
    // The patient who will use the device.
    property subjectElement : TFhirReference{TFhirPatient} read FSubject write SetSubject;

    // Typed access to The timing schedule for the use of the device The Schedule data type allows many different expressions, for example. "Every 8 hours"; "Three times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec 2011:"; "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013". (defined for API consistency)
    property timing : TFhirType read FTiming write SetTiming;
    // The timing schedule for the use of the device The Schedule data type allows many different expressions, for example. "Every 8 hours"; "Three times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec 2011:"; "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013".
    property timingElement : TFhirType read FTiming write SetTiming;

    // Characterizes how quickly the  use of device must be initiated. Includes concepts such as stat, urgent, routine.
    property priority : TFhirDeviceUseRequestPriorityEnum read GetPriorityST write SetPriorityST;
    property priorityElement : TFhirEnum read FPriority write SetPriority;

  end;

  TFhirDeviceUseRequestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceUseRequestList;
    function GetCurrent : TFhirDeviceUseRequest;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDeviceUseRequestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceUseRequest read GetCurrent;
  end;

  TFhirDeviceUseRequestList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDeviceUseRequest;
    procedure SetItemN(index : Integer; value : TFhirDeviceUseRequest);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDeviceUseRequestList; Overload;
    function Clone : TFhirDeviceUseRequestList; Overload;
    function GetEnumerator : TFhirDeviceUseRequestListEnumerator;

    //  Add a FhirDeviceUseRequest to the end of the list.
    function Append : TFhirDeviceUseRequest;

    // Add an already existing FhirDeviceUseRequest to the end of the list.
    procedure AddItem(value : TFhirDeviceUseRequest); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceUseRequest) : Integer;

    // Insert FhirDeviceUseRequest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceUseRequest;

    // Insert an existing FhirDeviceUseRequest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceUseRequest);

    // Get the iIndexth FhirDeviceUseRequest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceUseRequest);

    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceUseRequest;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirDeviceUseRequests[index : Integer] : TFhirDeviceUseRequest read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_DEVICEUSEREQUEST}

{$IFDEF FHIR_DEVICEUSESTATEMENT}

  // A record of a device being used by a patient where the record is the result of a report from the patient or another clinician.
  TFhirDeviceUseStatement = class (TFhirDomainResource)
  protected
    FBodySite : TFhirType;
    FWhenUsed : TFhirPeriod;
    FDevice : TFhirReference{TFhirDevice};
    FidentifierList : TFhirIdentifierList;
    FindicationList : TFhirCodeableConceptList;
    FnotesList : TFhirStringList;
    FRecordedOn : TFhirDateTime;
    FSubject : TFhirReference{TFhirPatient};
    FTiming : TFhirType;
    Procedure SetBodySite(value : TFhirType);
    Procedure SetWhenUsed(value : TFhirPeriod);
    Procedure SetDevice(value : TFhirReference{TFhirDevice});
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetIndicationList : TFhirCodeableConceptList;
    function GetHasIndicationList : Boolean;
    function GetNotesList : TFhirStringList;
    function GetHasNotesList : Boolean;
    Procedure SetRecordedOn(value : TFhirDateTime);
    Function GetRecordedOnST : TFslDateTime;
    Procedure SetRecordedOnST(value : TFslDateTime);
    Procedure SetSubject(value : TFhirReference{TFhirPatient});
    Procedure SetTiming(value : TFhirType);

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceUseStatement; overload;
    function Clone : TFhirDeviceUseStatement; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Indicates the site on the subject's body where the device was used ( i.e. the target site). (defined for API consistency)
    property bodySite : TFhirType read FBodySite write SetBodySite;
    // Indicates the site on the subject's body where the device was used ( i.e. the target site).
    property bodySiteElement : TFhirType read FBodySite write SetBodySite;

    // Typed access to The time period over which the device was used. (defined for API consistency)
    property whenUsed : TFhirPeriod read FWhenUsed write SetWhenUsed;
    // The time period over which the device was used.
    property whenUsedElement : TFhirPeriod read FWhenUsed write SetWhenUsed;

    // Typed access to The details of the device used. (defined for API consistency)
    property device : TFhirReference{TFhirDevice} read FDevice write SetDevice;
    // The details of the device used.
    property deviceElement : TFhirReference{TFhirDevice} read FDevice write SetDevice;

    // An external identifier for this statement such as an IRI.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Reason or justification for the use of the device.
    property indicationList : TFhirCodeableConceptList read GetIndicationList;
    property hasIndicationList : boolean read GetHasIndicationList;

    // Details about the device statement that were not represented at all or sufficiently in one of the attributes provided in a class. These may include for example a comment, an instruction, or a note associated with the statement.
    property notesList : TFhirStringList read GetNotesList;
    property hasNotesList : boolean read GetHasNotesList;

    // Typed access to The time at which the statement was made/recorded.
    property recordedOn : TFslDateTime read GetRecordedOnST write SetRecordedOnST;
    // The time at which the statement was made/recorded.
    property recordedOnElement : TFhirDateTime read FRecordedOn write SetRecordedOn;

    // Typed access to The patient who used the device. (defined for API consistency)
    property subject : TFhirReference{TFhirPatient} read FSubject write SetSubject;
    // The patient who used the device.
    property subjectElement : TFhirReference{TFhirPatient} read FSubject write SetSubject;

    // Typed access to How often the device was used. (defined for API consistency)
    property timing : TFhirType read FTiming write SetTiming;
    // How often the device was used.
    property timingElement : TFhirType read FTiming write SetTiming;

  end;

  TFhirDeviceUseStatementListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceUseStatementList;
    function GetCurrent : TFhirDeviceUseStatement;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDeviceUseStatementList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceUseStatement read GetCurrent;
  end;

  TFhirDeviceUseStatementList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDeviceUseStatement;
    procedure SetItemN(index : Integer; value : TFhirDeviceUseStatement);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDeviceUseStatementList; Overload;
    function Clone : TFhirDeviceUseStatementList; Overload;
    function GetEnumerator : TFhirDeviceUseStatementListEnumerator;

    //  Add a FhirDeviceUseStatement to the end of the list.
    function Append : TFhirDeviceUseStatement;

    // Add an already existing FhirDeviceUseStatement to the end of the list.
    procedure AddItem(value : TFhirDeviceUseStatement); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceUseStatement) : Integer;

    // Insert FhirDeviceUseStatement before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceUseStatement;

    // Insert an existing FhirDeviceUseStatement before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceUseStatement);

    // Get the iIndexth FhirDeviceUseStatement. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceUseStatement);

    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceUseStatement;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirDeviceUseStatements[index : Integer] : TFhirDeviceUseStatement read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_DEVICEUSESTATEMENT}

{$IFDEF FHIR_DIAGNOSTICORDER}

  // A summary of the events of interest that have occurred as the request is processed; e.g. when the order was made, various processing steps (specimens received), when it was completed.
  TFhirDiagnosticOrderEvent = class (TFhirBackboneElement)
  protected
    FStatus : TFhirEnum;
    FDescription : TFhirCodeableConcept;
    FDateTime : TFhirDateTime;
    FActor : TFhirReference{Resource};
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirDiagnosticOrderStatusEnum;
    Procedure SetStatusST(value : TFhirDiagnosticOrderStatusEnum);
    Procedure SetDescription(value : TFhirCodeableConcept);
    Procedure SetDateTime(value : TFhirDateTime);
    Function GetDateTimeST : TFslDateTime;
    Procedure SetDateTimeST(value : TFslDateTime);
    Procedure SetActor(value : TFhirReference{Resource});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDiagnosticOrderEvent; overload;
    function Clone : TFhirDiagnosticOrderEvent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The status for the event.
    property status : TFhirDiagnosticOrderStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Additional information about the event that occurred - e.g. if the status remained unchanged. (defined for API consistency)
    property description : TFhirCodeableConcept read FDescription write SetDescription;
    // Additional information about the event that occurred - e.g. if the status remained unchanged.
    property descriptionElement : TFhirCodeableConcept read FDescription write SetDescription;

    // Typed access to The date/time at which the event occurred.
    property dateTime : TFslDateTime read GetDateTimeST write SetDateTimeST;
    // The date/time at which the event occurred.
    property dateTimeElement : TFhirDateTime read FDateTime write SetDateTime;

    // Typed access to The person responsible for performing or recording the action. (defined for API consistency)
    property actor : TFhirReference{Resource} read FActor write SetActor;
    // The person responsible for performing or recording the action.
    property actorElement : TFhirReference{Resource} read FActor write SetActor;

  end;

  TFhirDiagnosticOrderEventListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDiagnosticOrderEventList;
    function GetCurrent : TFhirDiagnosticOrderEvent;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDiagnosticOrderEventList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDiagnosticOrderEvent read GetCurrent;
  end;

  TFhirDiagnosticOrderEventList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDiagnosticOrderEvent;
    procedure SetItemN(index : Integer; value : TFhirDiagnosticOrderEvent);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDiagnosticOrderEventList; Overload;
    function Clone : TFhirDiagnosticOrderEventList; Overload;
    function GetEnumerator : TFhirDiagnosticOrderEventListEnumerator;

    //  Add a FhirDiagnosticOrderEvent to the end of the list.
    function Append : TFhirDiagnosticOrderEvent;

    // Add an already existing FhirDiagnosticOrderEvent to the end of the list.
    procedure AddItem(value : TFhirDiagnosticOrderEvent); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDiagnosticOrderEvent) : Integer;

    // Insert FhirDiagnosticOrderEvent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDiagnosticOrderEvent;

    // Insert an existing FhirDiagnosticOrderEvent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDiagnosticOrderEvent);

    // Get the iIndexth FhirDiagnosticOrderEvent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDiagnosticOrderEvent);

    // The number of items in the collection
    function Item(index : Integer) : TFhirDiagnosticOrderEvent;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirDiagnosticOrderEvents[index : Integer] : TFhirDiagnosticOrderEvent read GetItemN write SetItemN; default;
  End;

  // The specific diagnostic investigations that are requested as part of this request. Sometimes, there can only be one item per request, but in most contexts, more than one investigation can be requested.
  TFhirDiagnosticOrderItem = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FspecimenList : TFhirReferenceList{TFhirSpecimen};
    FBodySite : TFhirCodeableConcept;
    FStatus : TFhirEnum;
    FeventList : TFhirDiagnosticOrderEventList;
    Procedure SetCode(value : TFhirCodeableConcept);
    function GetSpecimenList : TFhirReferenceList{TFhirSpecimen};
    function GetHasSpecimenList : Boolean;
    Procedure SetBodySite(value : TFhirCodeableConcept);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirDiagnosticOrderStatusEnum;
    Procedure SetStatusST(value : TFhirDiagnosticOrderStatusEnum);
    function GetEventList : TFhirDiagnosticOrderEventList;
    function GetHasEventList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDiagnosticOrderItem; overload;
    function Clone : TFhirDiagnosticOrderItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code that identifies a particular diagnostic investigation, or panel of investigations, that have been requested. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code that identifies a particular diagnostic investigation, or panel of investigations, that have been requested.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // If the item is related to a specific specimen.
    property specimenList : TFhirReferenceList{TFhirSpecimen} read GetSpecimenList;
    property hasSpecimenList : boolean read GetHasSpecimenList;

    // Typed access to Anatomical location where the request test should be performed.  This is the target site. (defined for API consistency)
    property bodySite : TFhirCodeableConcept read FBodySite write SetBodySite;
    // Anatomical location where the request test should be performed.  This is the target site.
    property bodySiteElement : TFhirCodeableConcept read FBodySite write SetBodySite;

    // The status of this individual item within the order.
    property status : TFhirDiagnosticOrderStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // A summary of the events of interest that have occurred as this item of the request is processed.
    property eventList : TFhirDiagnosticOrderEventList read GetEventList;
    property hasEventList : boolean read GetHasEventList;

  end;

  TFhirDiagnosticOrderItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDiagnosticOrderItemList;
    function GetCurrent : TFhirDiagnosticOrderItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDiagnosticOrderItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDiagnosticOrderItem read GetCurrent;
  end;

  TFhirDiagnosticOrderItemList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDiagnosticOrderItem;
    procedure SetItemN(index : Integer; value : TFhirDiagnosticOrderItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDiagnosticOrderItemList; Overload;
    function Clone : TFhirDiagnosticOrderItemList; Overload;
    function GetEnumerator : TFhirDiagnosticOrderItemListEnumerator;

    //  Add a FhirDiagnosticOrderItem to the end of the list.
    function Append : TFhirDiagnosticOrderItem;

    // Add an already existing FhirDiagnosticOrderItem to the end of the list.
    procedure AddItem(value : TFhirDiagnosticOrderItem); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDiagnosticOrderItem) : Integer;

    // Insert FhirDiagnosticOrderItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDiagnosticOrderItem;

    // Insert an existing FhirDiagnosticOrderItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDiagnosticOrderItem);

    // Get the iIndexth FhirDiagnosticOrderItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDiagnosticOrderItem);

    // The number of items in the collection
    function Item(index : Integer) : TFhirDiagnosticOrderItem;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirDiagnosticOrderItems[index : Integer] : TFhirDiagnosticOrderItem read GetItemN write SetItemN; default;
  End;

  // A record of a request for a diagnostic investigation service to be performed.
  TFhirDiagnosticOrder = class (TFhirDomainResource)
  protected
    FSubject : TFhirReference{Resource};
    FOrderer : TFhirReference{TFhirPractitioner};
    FidentifierList : TFhirIdentifierList;
    FEncounter : TFhirReference{TFhirEncounter};
    FreasonList : TFhirCodeableConceptList;
    FsupportingInformationList : TFhirReferenceList{Resource};
    FspecimenList : TFhirReferenceList{TFhirSpecimen};
    FStatus : TFhirEnum;
    FPriority : TFhirEnum;
    FeventList : TFhirDiagnosticOrderEventList;
    FitemList : TFhirDiagnosticOrderItemList;
    FnoteList : TFhirAnnotationList;
    Procedure SetSubject(value : TFhirReference{Resource});
    Procedure SetOrderer(value : TFhirReference{TFhirPractitioner});
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetEncounter(value : TFhirReference{TFhirEncounter});
    function GetReasonList : TFhirCodeableConceptList;
    function GetHasReasonList : Boolean;
    function GetSupportingInformationList : TFhirReferenceList{Resource};
    function GetHasSupportingInformationList : Boolean;
    function GetSpecimenList : TFhirReferenceList{TFhirSpecimen};
    function GetHasSpecimenList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirDiagnosticOrderStatusEnum;
    Procedure SetStatusST(value : TFhirDiagnosticOrderStatusEnum);
    Procedure SetPriority(value : TFhirEnum);
    Function GetPriorityST : TFhirDiagnosticOrderPriorityEnum;
    Procedure SetPriorityST(value : TFhirDiagnosticOrderPriorityEnum);
    function GetEventList : TFhirDiagnosticOrderEventList;
    function GetHasEventList : Boolean;
    function GetItemList : TFhirDiagnosticOrderItemList;
    function GetHasItemList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDiagnosticOrder; overload;
    function Clone : TFhirDiagnosticOrder; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Who or what the investigation is to be performed on. This is usually a human patient, but diagnostic tests can also be requested on animals, groups of humans or animals, devices such as dialysis machines, or even locations (typically for environmental scans). (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // Who or what the investigation is to be performed on. This is usually a human patient, but diagnostic tests can also be requested on animals, groups of humans or animals, devices such as dialysis machines, or even locations (typically for environmental scans).
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // Typed access to The practitioner that holds legal responsibility for ordering the investigation. (defined for API consistency)
    property orderer : TFhirReference{TFhirPractitioner} read FOrderer write SetOrderer;
    // The practitioner that holds legal responsibility for ordering the investigation.
    property ordererElement : TFhirReference{TFhirPractitioner} read FOrderer write SetOrderer;

    // Identifiers assigned to this order instance by the orderer and/or  the receiver and/or order fulfiller.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to An encounter that provides additional information about the healthcare context in which this request is made. (defined for API consistency)
    property encounter : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;
    // An encounter that provides additional information about the healthcare context in which this request is made.
    property encounterElement : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;

    // An explanation or justification for why this diagnostic investigation is being requested.   This is often for billing purposes.  May relate to the resources referred to in supportingInformation.
    property reasonList : TFhirCodeableConceptList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // Additional clinical information about the patient or specimen that may influence test interpretations.  This includes observations explicitly requested by the producer(filler) to provide context or supporting information needed to complete the order.
    property supportingInformationList : TFhirReferenceList{Resource} read GetSupportingInformationList;
    property hasSupportingInformationList : boolean read GetHasSupportingInformationList;

    // One or more specimens that the diagnostic investigation is about.
    property specimenList : TFhirReferenceList{TFhirSpecimen} read GetSpecimenList;
    property hasSpecimenList : boolean read GetHasSpecimenList;

    // The status of the order.
    property status : TFhirDiagnosticOrderStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // The clinical priority associated with this order.
    property priority : TFhirDiagnosticOrderPriorityEnum read GetPriorityST write SetPriorityST;
    property priorityElement : TFhirEnum read FPriority write SetPriority;

    // A summary of the events of interest that have occurred as the request is processed; e.g. when the order was made, various processing steps (specimens received), when it was completed.
    property eventList : TFhirDiagnosticOrderEventList read GetEventList;
    property hasEventList : boolean read GetHasEventList;

    // The specific diagnostic investigations that are requested as part of this request. Sometimes, there can only be one item per request, but in most contexts, more than one investigation can be requested.
    property itemList : TFhirDiagnosticOrderItemList read GetItemList;
    property hasItemList : boolean read GetHasItemList;

    // Any other notes associated with this patient, specimen or order (e.g. "patient hates needles").
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirDiagnosticOrderListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDiagnosticOrderList;
    function GetCurrent : TFhirDiagnosticOrder;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDiagnosticOrderList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDiagnosticOrder read GetCurrent;
  end;

  TFhirDiagnosticOrderList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDiagnosticOrder;
    procedure SetItemN(index : Integer; value : TFhirDiagnosticOrder);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDiagnosticOrderList; Overload;
    function Clone : TFhirDiagnosticOrderList; Overload;
    function GetEnumerator : TFhirDiagnosticOrderListEnumerator;

    //  Add a FhirDiagnosticOrder to the end of the list.
    function Append : TFhirDiagnosticOrder;

    // Add an already existing FhirDiagnosticOrder to the end of the list.
    procedure AddItem(value : TFhirDiagnosticOrder); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDiagnosticOrder) : Integer;

    // Insert FhirDiagnosticOrder before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDiagnosticOrder;

    // Insert an existing FhirDiagnosticOrder before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDiagnosticOrder);

    // Get the iIndexth FhirDiagnosticOrder. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDiagnosticOrder);

    // The number of items in the collection
    function Item(index : Integer) : TFhirDiagnosticOrder;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirDiagnosticOrders[index : Integer] : TFhirDiagnosticOrder read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_DIAGNOSTICORDER}

{$IFDEF FHIR_DIAGNOSTICREPORT}

  // A list of key images associated with this report. The images are generally created during the diagnostic process, and may be directly of the patient, or of treated specimens (i.e. slides of interest).
  TFhirDiagnosticReportImage = class (TFhirBackboneElement)
  protected
    FComment : TFhirString;
    FLink_ : TFhirReference{TFhirMedia};
    Procedure SetComment(value : TFhirString);
    Function GetCommentST : String;
    Procedure SetCommentST(value : String);
    Procedure SetLink_(value : TFhirReference{TFhirMedia});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDiagnosticReportImage; overload;
    function Clone : TFhirDiagnosticReportImage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A comment about the image. Typically, this is used to provide an explanation for why the image is included, or to draw the viewer's attention to important features.
    property comment : String read GetCommentST write SetCommentST;
    // A comment about the image. Typically, this is used to provide an explanation for why the image is included, or to draw the viewer's attention to important features.
    property commentElement : TFhirString read FComment write SetComment;

    // Typed access to Reference to the image source. (defined for API consistency)
    property link_ : TFhirReference{TFhirMedia} read FLink_ write SetLink_;
    // Reference to the image source.
    property link_Element : TFhirReference{TFhirMedia} read FLink_ write SetLink_;

  end;

  TFhirDiagnosticReportImageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDiagnosticReportImageList;
    function GetCurrent : TFhirDiagnosticReportImage;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDiagnosticReportImageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDiagnosticReportImage read GetCurrent;
  end;

  TFhirDiagnosticReportImageList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDiagnosticReportImage;
    procedure SetItemN(index : Integer; value : TFhirDiagnosticReportImage);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDiagnosticReportImageList; Overload;
    function Clone : TFhirDiagnosticReportImageList; Overload;
    function GetEnumerator : TFhirDiagnosticReportImageListEnumerator;

    //  Add a FhirDiagnosticReportImage to the end of the list.
    function Append : TFhirDiagnosticReportImage;

    // Add an already existing FhirDiagnosticReportImage to the end of the list.
    procedure AddItem(value : TFhirDiagnosticReportImage); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDiagnosticReportImage) : Integer;

    // Insert FhirDiagnosticReportImage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDiagnosticReportImage;

    // Insert an existing FhirDiagnosticReportImage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDiagnosticReportImage);

    // Get the iIndexth FhirDiagnosticReportImage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDiagnosticReportImage);

    // The number of items in the collection
    function Item(index : Integer) : TFhirDiagnosticReportImage;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirDiagnosticReportImages[index : Integer] : TFhirDiagnosticReportImage read GetItemN write SetItemN; default;
  End;

  // The findings and interpretation of diagnostic  tests performed on patients, groups of patients, devices, and locations, and/or specimens derived from these. The report includes clinical context such as requesting and provider information, and some mix of atomic results, images, textual and coded interpretations, and formatted representation of diagnostic reports.
  TFhirDiagnosticReport = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FCategory : TFhirCodeableConcept;
    FCode : TFhirCodeableConcept;
    FSubject : TFhirReference{Resource};
    FEncounter : TFhirReference{TFhirEncounter};
    FEffective : TFhirType;
    FIssued : TFhirInstant;
    FPerformer : TFhirReference{Resource};
    FrequestList : TFhirReferenceList{Resource};
    FspecimenList : TFhirReferenceList{TFhirSpecimen};
    FresultList : TFhirReferenceList{TFhirObservation};
    FimagingStudyList : TFhirReferenceList{Resource};
    FimageList : TFhirDiagnosticReportImageList;
    FConclusion : TFhirString;
    FcodedDiagnosisList : TFhirCodeableConceptList;
    FpresentedFormList : TFhirAttachmentList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirDiagnosticReportStatusEnum;
    Procedure SetStatusST(value : TFhirDiagnosticReportStatusEnum);
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetSubject(value : TFhirReference{Resource});
    Procedure SetEncounter(value : TFhirReference{TFhirEncounter});
    Procedure SetEffective(value : TFhirType);
    Procedure SetIssued(value : TFhirInstant);
    Function GetIssuedST : TFslDateTime;
    Procedure SetIssuedST(value : TFslDateTime);
    Procedure SetPerformer(value : TFhirReference{Resource});
    function GetRequestList : TFhirReferenceList{Resource};
    function GetHasRequestList : Boolean;
    function GetSpecimenList : TFhirReferenceList{TFhirSpecimen};
    function GetHasSpecimenList : Boolean;
    function GetResultList : TFhirReferenceList{TFhirObservation};
    function GetHasResultList : Boolean;
    function GetImagingStudyList : TFhirReferenceList{Resource};
    function GetHasImagingStudyList : Boolean;
    function GetImageList : TFhirDiagnosticReportImageList;
    function GetHasImageList : Boolean;
    Procedure SetConclusion(value : TFhirString);
    Function GetConclusionST : String;
    Procedure SetConclusionST(value : String);
    function GetCodedDiagnosisList : TFhirCodeableConceptList;
    function GetHasCodedDiagnosisList : Boolean;
    function GetPresentedFormList : TFhirAttachmentList;
    function GetHasPresentedFormList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDiagnosticReport; overload;
    function Clone : TFhirDiagnosticReport; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The local ID assigned to the report by the order filler, usually by the Information System of the diagnostic service provider.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the diagnostic report as a whole.
    property status : TFhirDiagnosticReportStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A code that classifies the clinical discipline, department or diagnostic service that created the report (e.g. cardiology, biochemistry, hematology, MRI). This is used for searching, sorting and display purposes. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // A code that classifies the clinical discipline, department or diagnostic service that created the report (e.g. cardiology, biochemistry, hematology, MRI). This is used for searching, sorting and display purposes.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to A code or name that describes this diagnostic report. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code or name that describes this diagnostic report.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The subject of the report. Usually, but not always, this is a patient. However diagnostic services also perform analyses on specimens collected from a variety of other sources. (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // The subject of the report. Usually, but not always, this is a patient. However diagnostic services also perform analyses on specimens collected from a variety of other sources.
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // Typed access to The link to the health care event (encounter) when the order was made. (defined for API consistency)
    property encounter : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;
    // The link to the health care event (encounter) when the order was made.
    property encounterElement : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;

    // Typed access to The time or time-period the observed values are related to. When the subject of the report is a patient, this is usually either the time of the procedure or of specimen collection(s), but very often the source of the date/time is not known, only the date/time itself. (defined for API consistency)
    property effective : TFhirType read FEffective write SetEffective;
    // The time or time-period the observed values are related to. When the subject of the report is a patient, this is usually either the time of the procedure or of specimen collection(s), but very often the source of the date/time is not known, only the date/time itself.
    property effectiveElement : TFhirType read FEffective write SetEffective;

    // Typed access to The date and time that this version of the report was released from the source diagnostic service.
    property issued : TFslDateTime read GetIssuedST write SetIssuedST;
    // The date and time that this version of the report was released from the source diagnostic service.
    property issuedElement : TFhirInstant read FIssued write SetIssued;

    // Typed access to The diagnostic service that is responsible for issuing the report. (defined for API consistency)
    property performer : TFhirReference{Resource} read FPerformer write SetPerformer;
    // The diagnostic service that is responsible for issuing the report.
    property performerElement : TFhirReference{Resource} read FPerformer write SetPerformer;

    // Details concerning a test or procedure requested.
    property requestList : TFhirReferenceList{Resource} read GetRequestList;
    property hasRequestList : boolean read GetHasRequestList;

    // Details about the specimens on which this diagnostic report is based.
    property specimenList : TFhirReferenceList{TFhirSpecimen} read GetSpecimenList;
    property hasSpecimenList : boolean read GetHasSpecimenList;

    // Observations that are part of this diagnostic report. Observations can be simple name/value pairs (e.g. "atomic" results), or they can be grouping observations that include references to other members of the group (e.g. "panels").
    property resultList : TFhirReferenceList{TFhirObservation} read GetResultList;
    property hasResultList : boolean read GetHasResultList;

    // One or more links to full details of any imaging performed during the diagnostic investigation. Typically, this is imaging performed by DICOM enabled modalities, but this is not required. A fully enabled PACS viewer can use this information to provide views of the source images.
    property imagingStudyList : TFhirReferenceList{Resource} read GetImagingStudyList;
    property hasImagingStudyList : boolean read GetHasImagingStudyList;

    // A list of key images associated with this report. The images are generally created during the diagnostic process, and may be directly of the patient, or of treated specimens (i.e. slides of interest).
    property imageList : TFhirDiagnosticReportImageList read GetImageList;
    property hasImageList : boolean read GetHasImageList;

    // Typed access to Concise and clinically contextualized narrative interpretation of the diagnostic report.
    property conclusion : String read GetConclusionST write SetConclusionST;
    // Concise and clinically contextualized narrative interpretation of the diagnostic report.
    property conclusionElement : TFhirString read FConclusion write SetConclusion;

    // Codes for the conclusion.
    property codedDiagnosisList : TFhirCodeableConceptList read GetCodedDiagnosisList;
    property hasCodedDiagnosisList : boolean read GetHasCodedDiagnosisList;

    // Rich text representation of the entire result as issued by the diagnostic service. Multiple formats are allowed but they SHALL be semantically equivalent.
    property presentedFormList : TFhirAttachmentList read GetPresentedFormList;
    property hasPresentedFormList : boolean read GetHasPresentedFormList;

  end;

  TFhirDiagnosticReportListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDiagnosticReportList;
    function GetCurrent : TFhirDiagnosticReport;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDiagnosticReportList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDiagnosticReport read GetCurrent;
  end;

  TFhirDiagnosticReportList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDiagnosticReport;
    procedure SetItemN(index : Integer; value : TFhirDiagnosticReport);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDiagnosticReportList; Overload;
    function Clone : TFhirDiagnosticReportList; Overload;
    function GetEnumerator : TFhirDiagnosticReportListEnumerator;

    //  Add a FhirDiagnosticReport to the end of the list.
    function Append : TFhirDiagnosticReport;

    // Add an already existing FhirDiagnosticReport to the end of the list.
    procedure AddItem(value : TFhirDiagnosticReport); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDiagnosticReport) : Integer;

    // Insert FhirDiagnosticReport before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDiagnosticReport;

    // Insert an existing FhirDiagnosticReport before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDiagnosticReport);

    // Get the iIndexth FhirDiagnosticReport. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDiagnosticReport);

    // The number of items in the collection
    function Item(index : Integer) : TFhirDiagnosticReport;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirDiagnosticReports[index : Integer] : TFhirDiagnosticReport read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_DIAGNOSTICREPORT}

{$IFDEF FHIR_DOCUMENTMANIFEST}

  // The list of Documents included in the manifest.
  TFhirDocumentManifestContent = class (TFhirBackboneElement)
  protected
    FP : TFhirType;
    Procedure SetP(value : TFhirType);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDocumentManifestContent; overload;
    function Clone : TFhirDocumentManifestContent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The list of references to document content, or Attachment that consist of the parts of this document manifest. Usually, these would be document references, but direct references to Media or Attachments are also allowed. (defined for API consistency)
    property p : TFhirType read FP write SetP;
    // The list of references to document content, or Attachment that consist of the parts of this document manifest. Usually, these would be document references, but direct references to Media or Attachments are also allowed.
    property pElement : TFhirType read FP write SetP;

  end;

  TFhirDocumentManifestContentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDocumentManifestContentList;
    function GetCurrent : TFhirDocumentManifestContent;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDocumentManifestContentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDocumentManifestContent read GetCurrent;
  end;

  TFhirDocumentManifestContentList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDocumentManifestContent;
    procedure SetItemN(index : Integer; value : TFhirDocumentManifestContent);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDocumentManifestContentList; Overload;
    function Clone : TFhirDocumentManifestContentList; Overload;
    function GetEnumerator : TFhirDocumentManifestContentListEnumerator;

    //  Add a FhirDocumentManifestContent to the end of the list.
    function Append : TFhirDocumentManifestContent;

    // Add an already existing FhirDocumentManifestContent to the end of the list.
    procedure AddItem(value : TFhirDocumentManifestContent); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDocumentManifestContent) : Integer;

    // Insert FhirDocumentManifestContent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDocumentManifestContent;

    // Insert an existing FhirDocumentManifestContent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDocumentManifestContent);

    // Get the iIndexth FhirDocumentManifestContent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDocumentManifestContent);

    // The number of items in the collection
    function Item(index : Integer) : TFhirDocumentManifestContent;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirDocumentManifestContents[index : Integer] : TFhirDocumentManifestContent read GetItemN write SetItemN; default;
  End;

  // Related identifiers or resources associated with the DocumentManifest.
  TFhirDocumentManifestRelated = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirIdentifier;
    FRef : TFhirReference{TFhirReference};
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetRef(value : TFhirReference{TFhirReference});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDocumentManifestRelated; overload;
    function Clone : TFhirDocumentManifestRelated; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Related identifier to this DocumentManifest.  For example, Order numbers, accession numbers, XDW workflow numbers. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Related identifier to this DocumentManifest.  For example, Order numbers, accession numbers, XDW workflow numbers.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to Related Resource to this DocumentManifest. For example, Order, DiagnosticOrder,  Procedure, EligibilityRequest, etc. (defined for API consistency)
    property ref : TFhirReference{TFhirReference} read FRef write SetRef;
    // Related Resource to this DocumentManifest. For example, Order, DiagnosticOrder,  Procedure, EligibilityRequest, etc.
    property refElement : TFhirReference{TFhirReference} read FRef write SetRef;

  end;

  TFhirDocumentManifestRelatedListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDocumentManifestRelatedList;
    function GetCurrent : TFhirDocumentManifestRelated;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDocumentManifestRelatedList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDocumentManifestRelated read GetCurrent;
  end;

  TFhirDocumentManifestRelatedList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDocumentManifestRelated;
    procedure SetItemN(index : Integer; value : TFhirDocumentManifestRelated);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDocumentManifestRelatedList; Overload;
    function Clone : TFhirDocumentManifestRelatedList; Overload;
    function GetEnumerator : TFhirDocumentManifestRelatedListEnumerator;

    //  Add a FhirDocumentManifestRelated to the end of the list.
    function Append : TFhirDocumentManifestRelated;

    // Add an already existing FhirDocumentManifestRelated to the end of the list.
    procedure AddItem(value : TFhirDocumentManifestRelated); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDocumentManifestRelated) : Integer;

    // Insert FhirDocumentManifestRelated before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDocumentManifestRelated;

    // Insert an existing FhirDocumentManifestRelated before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDocumentManifestRelated);

    // Get the iIndexth FhirDocumentManifestRelated. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDocumentManifestRelated);

    // The number of items in the collection
    function Item(index : Integer) : TFhirDocumentManifestRelated;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirDocumentManifestRelateds[index : Integer] : TFhirDocumentManifestRelated read GetItemN write SetItemN; default;
  End;

  // A manifest that defines a set of documents.
  TFhirDocumentManifest = class (TFhirDomainResource)
  protected
    FMasterIdentifier : TFhirIdentifier;
    FidentifierList : TFhirIdentifierList;
    FSubject : TFhirReference{Resource};
    FrecipientList : TFhirReferenceList{Resource};
    FType_ : TFhirCodeableConcept;
    FauthorList : TFhirReferenceList{Resource};
    FCreated : TFhirDateTime;
    FSource : TFhirUri;
    FStatus : TFhirEnum;
    FDescription : TFhirString;
    FcontentList : TFhirDocumentManifestContentList;
    FrelatedList : TFhirDocumentManifestRelatedList;
    Procedure SetMasterIdentifier(value : TFhirIdentifier);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetSubject(value : TFhirReference{Resource});
    function GetRecipientList : TFhirReferenceList{Resource};
    function GetHasRecipientList : Boolean;
    Procedure SetType_(value : TFhirCodeableConcept);
    function GetAuthorList : TFhirReferenceList{Resource};
    function GetHasAuthorList : Boolean;
    Procedure SetCreated(value : TFhirDateTime);
    Function GetCreatedST : TFslDateTime;
    Procedure SetCreatedST(value : TFslDateTime);
    Procedure SetSource(value : TFhirUri);
    Function GetSourceST : String;
    Procedure SetSourceST(value : String);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirDocumentReferenceStatusEnum;
    Procedure SetStatusST(value : TFhirDocumentReferenceStatusEnum);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    function GetContentList : TFhirDocumentManifestContentList;
    function GetHasContentList : Boolean;
    function GetRelatedList : TFhirDocumentManifestRelatedList;
    function GetHasRelatedList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDocumentManifest; overload;
    function Clone : TFhirDocumentManifest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A single identifier that uniquely identifies this manifest. Principally used to refer to the manifest in non-FHIR contexts. (defined for API consistency)
    property masterIdentifier : TFhirIdentifier read FMasterIdentifier write SetMasterIdentifier;
    // A single identifier that uniquely identifies this manifest. Principally used to refer to the manifest in non-FHIR contexts.
    property masterIdentifierElement : TFhirIdentifier read FMasterIdentifier write SetMasterIdentifier;

    // Other identifiers associated with the document manifest, including version independent  identifiers.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Who or what the set of documents is about. The documents can be about a person, (patient or healthcare practitioner), a device (i.e. machine) or even a group of subjects (such as a document about a herd of farm animals, or a set of patients that share a common exposure). If the documents cross more than one subject, then more than one subject is allowed here (unusual use case). (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // Who or what the set of documents is about. The documents can be about a person, (patient or healthcare practitioner), a device (i.e. machine) or even a group of subjects (such as a document about a herd of farm animals, or a set of patients that share a common exposure). If the documents cross more than one subject, then more than one subject is allowed here (unusual use case).
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // A patient, practitioner, or organization for which this set of documents is intended.
    property recipientList : TFhirReferenceList{Resource} read GetRecipientList;
    property hasRecipientList : boolean read GetHasRecipientList;

    // Typed access to Specifies the kind of this set of documents (e.g. Patient Summary, Discharge Summary, Prescription, etc.). The type of a set of documents may be the same as one of the documents in it - especially if there is only one - but it may be wider. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Specifies the kind of this set of documents (e.g. Patient Summary, Discharge Summary, Prescription, etc.). The type of a set of documents may be the same as one of the documents in it - especially if there is only one - but it may be wider.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Identifies who is responsible for creating the manifest, and adding  documents to it.
    property authorList : TFhirReferenceList{Resource} read GetAuthorList;
    property hasAuthorList : boolean read GetHasAuthorList;

    // Typed access to When the document manifest was created for submission to the server (not necessarily the same thing as the actual resource last modified time, since it may be modified, replicated, etc.).
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // When the document manifest was created for submission to the server (not necessarily the same thing as the actual resource last modified time, since it may be modified, replicated, etc.).
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to Identifies the source system, application, or software that produced the document manifest.
    property source : String read GetSourceST write SetSourceST;
    // Identifies the source system, application, or software that produced the document manifest.
    property sourceElement : TFhirUri read FSource write SetSource;

    // The status of this document manifest.
    property status : TFhirDocumentReferenceStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Human-readable description of the source document. This is sometimes known as the "title".
    property description : String read GetDescriptionST write SetDescriptionST;
    // Human-readable description of the source document. This is sometimes known as the "title".
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // The list of Documents included in the manifest.
    property contentList : TFhirDocumentManifestContentList read GetContentList;
    property hasContentList : boolean read GetHasContentList;

    // Related identifiers or resources associated with the DocumentManifest.
    property relatedList : TFhirDocumentManifestRelatedList read GetRelatedList;
    property hasRelatedList : boolean read GetHasRelatedList;

  end;

  TFhirDocumentManifestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDocumentManifestList;
    function GetCurrent : TFhirDocumentManifest;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDocumentManifestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDocumentManifest read GetCurrent;
  end;

  TFhirDocumentManifestList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDocumentManifest;
    procedure SetItemN(index : Integer; value : TFhirDocumentManifest);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDocumentManifestList; Overload;
    function Clone : TFhirDocumentManifestList; Overload;
    function GetEnumerator : TFhirDocumentManifestListEnumerator;

    //  Add a FhirDocumentManifest to the end of the list.
    function Append : TFhirDocumentManifest;

    // Add an already existing FhirDocumentManifest to the end of the list.
    procedure AddItem(value : TFhirDocumentManifest); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDocumentManifest) : Integer;

    // Insert FhirDocumentManifest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDocumentManifest;

    // Insert an existing FhirDocumentManifest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDocumentManifest);

    // Get the iIndexth FhirDocumentManifest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDocumentManifest);

    // The number of items in the collection
    function Item(index : Integer) : TFhirDocumentManifest;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirDocumentManifests[index : Integer] : TFhirDocumentManifest read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_DOCUMENTMANIFEST}

{$IFDEF FHIR_DOCUMENTREFERENCE}

  // Relationships that this document has with other document references that already exist.
  TFhirDocumentReferenceRelatesTo = class (TFhirBackboneElement)
  protected
    FCode : TFhirEnum;
    FTarget : TFhirReference{TFhirDocumentReference};
    Procedure SetCode(value : TFhirEnum);
    Function GetCodeST : TFhirDocumentRelationshipTypeEnum;
    Procedure SetCodeST(value : TFhirDocumentRelationshipTypeEnum);
    Procedure SetTarget(value : TFhirReference{TFhirDocumentReference});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDocumentReferenceRelatesTo; overload;
    function Clone : TFhirDocumentReferenceRelatesTo; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The type of relationship that this document has with anther document.
    property code : TFhirDocumentRelationshipTypeEnum read GetCodeST write SetCodeST;
    property codeElement : TFhirEnum read FCode write SetCode;

    // Typed access to The target document of this relationship. (defined for API consistency)
    property target : TFhirReference{TFhirDocumentReference} read FTarget write SetTarget;
    // The target document of this relationship.
    property targetElement : TFhirReference{TFhirDocumentReference} read FTarget write SetTarget;

  end;

  TFhirDocumentReferenceRelatesToListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDocumentReferenceRelatesToList;
    function GetCurrent : TFhirDocumentReferenceRelatesTo;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDocumentReferenceRelatesToList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDocumentReferenceRelatesTo read GetCurrent;
  end;

  TFhirDocumentReferenceRelatesToList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDocumentReferenceRelatesTo;
    procedure SetItemN(index : Integer; value : TFhirDocumentReferenceRelatesTo);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDocumentReferenceRelatesToList; Overload;
    function Clone : TFhirDocumentReferenceRelatesToList; Overload;
    function GetEnumerator : TFhirDocumentReferenceRelatesToListEnumerator;

    //  Add a FhirDocumentReferenceRelatesTo to the end of the list.
    function Append : TFhirDocumentReferenceRelatesTo;

    // Add an already existing FhirDocumentReferenceRelatesTo to the end of the list.
    procedure AddItem(value : TFhirDocumentReferenceRelatesTo); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDocumentReferenceRelatesTo) : Integer;

    // Insert FhirDocumentReferenceRelatesTo before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDocumentReferenceRelatesTo;

    // Insert an existing FhirDocumentReferenceRelatesTo before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDocumentReferenceRelatesTo);

    // Get the iIndexth FhirDocumentReferenceRelatesTo. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDocumentReferenceRelatesTo);

    // The number of items in the collection
    function Item(index : Integer) : TFhirDocumentReferenceRelatesTo;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirDocumentReferenceRelatesTos[index : Integer] : TFhirDocumentReferenceRelatesTo read GetItemN write SetItemN; default;
  End;

  // The document and format referenced. There may be multiple content element repetitions, each with a different format.
  TFhirDocumentReferenceContent = class (TFhirBackboneElement)
  protected
    FAttachment : TFhirAttachment;
    FformatList : TFhirCodingList;
    Procedure SetAttachment(value : TFhirAttachment);
    function GetFormatList : TFhirCodingList;
    function GetHasFormatList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDocumentReferenceContent; overload;
    function Clone : TFhirDocumentReferenceContent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The document or url of the document along with critical metadata to prove content has integrity. (defined for API consistency)
    property attachment : TFhirAttachment read FAttachment write SetAttachment;
    // The document or url of the document along with critical metadata to prove content has integrity.
    property attachmentElement : TFhirAttachment read FAttachment write SetAttachment;

    // An identifier of the document encoding, structure, and template that the document conforms to beyond the base format indicated in the mimeType.
    property formatList : TFhirCodingList read GetFormatList;
    property hasFormatList : boolean read GetHasFormatList;

  end;

  TFhirDocumentReferenceContentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDocumentReferenceContentList;
    function GetCurrent : TFhirDocumentReferenceContent;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDocumentReferenceContentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDocumentReferenceContent read GetCurrent;
  end;

  TFhirDocumentReferenceContentList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDocumentReferenceContent;
    procedure SetItemN(index : Integer; value : TFhirDocumentReferenceContent);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDocumentReferenceContentList; Overload;
    function Clone : TFhirDocumentReferenceContentList; Overload;
    function GetEnumerator : TFhirDocumentReferenceContentListEnumerator;

    //  Add a FhirDocumentReferenceContent to the end of the list.
    function Append : TFhirDocumentReferenceContent;

    // Add an already existing FhirDocumentReferenceContent to the end of the list.
    procedure AddItem(value : TFhirDocumentReferenceContent); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDocumentReferenceContent) : Integer;

    // Insert FhirDocumentReferenceContent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDocumentReferenceContent;

    // Insert an existing FhirDocumentReferenceContent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDocumentReferenceContent);

    // Get the iIndexth FhirDocumentReferenceContent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDocumentReferenceContent);

    // The number of items in the collection
    function Item(index : Integer) : TFhirDocumentReferenceContent;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirDocumentReferenceContents[index : Integer] : TFhirDocumentReferenceContent read GetItemN write SetItemN; default;
  End;

  // The clinical context in which the document was prepared.
  TFhirDocumentReferenceContext = class (TFhirBackboneElement)
  protected
    FEncounter : TFhirReference{TFhirEncounter};
    FeventList : TFhirCodeableConceptList;
    FPeriod : TFhirPeriod;
    FFacilityType : TFhirCodeableConcept;
    FPracticeSetting : TFhirCodeableConcept;
    FSourcePatientInfo : TFhirReference{TFhirPatient};
    FrelatedList : TFhirDocumentReferenceContextRelatedList;
    Procedure SetEncounter(value : TFhirReference{TFhirEncounter});
    function GetEventList : TFhirCodeableConceptList;
    function GetHasEventList : Boolean;
    Procedure SetPeriod(value : TFhirPeriod);
    Procedure SetFacilityType(value : TFhirCodeableConcept);
    Procedure SetPracticeSetting(value : TFhirCodeableConcept);
    Procedure SetSourcePatientInfo(value : TFhirReference{TFhirPatient});
    function GetRelatedList : TFhirDocumentReferenceContextRelatedList;
    function GetHasRelatedList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDocumentReferenceContext; overload;
    function Clone : TFhirDocumentReferenceContext; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Describes the clinical encounter or type of care that the document content is associated with. (defined for API consistency)
    property encounter : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;
    // Describes the clinical encounter or type of care that the document content is associated with.
    property encounterElement : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;

    // This list of codes represents the main clinical acts, such as a colonoscopy or an appendectomy, being documented. In some cases, the event is inherent in the typeCode, such as a "History and Physical Report" in which the procedure being documented is necessarily a "History and Physical" act.
    property eventList : TFhirCodeableConceptList read GetEventList;
    property hasEventList : boolean read GetHasEventList;

    // Typed access to The time period over which the service that is described by the document was provided. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The time period over which the service that is described by the document was provided.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to The kind of facility where the patient was seen. (defined for API consistency)
    property facilityType : TFhirCodeableConcept read FFacilityType write SetFacilityType;
    // The kind of facility where the patient was seen.
    property facilityTypeElement : TFhirCodeableConcept read FFacilityType write SetFacilityType;

    // Typed access to This property may convey specifics about the practice setting where the content was created, often reflecting the clinical specialty. (defined for API consistency)
    property practiceSetting : TFhirCodeableConcept read FPracticeSetting write SetPracticeSetting;
    // This property may convey specifics about the practice setting where the content was created, often reflecting the clinical specialty.
    property practiceSettingElement : TFhirCodeableConcept read FPracticeSetting write SetPracticeSetting;

    // Typed access to The Patient Information as known when the document was {$IFNDEF FPC}published{$ENDIF}. May be a reference to a version specific, or contained. (defined for API consistency)
    property sourcePatientInfo : TFhirReference{TFhirPatient} read FSourcePatientInfo write SetSourcePatientInfo;
    // The Patient Information as known when the document was {$IFNDEF FPC}published{$ENDIF}. May be a reference to a version specific, or contained.
    property sourcePatientInfoElement : TFhirReference{TFhirPatient} read FSourcePatientInfo write SetSourcePatientInfo;

    // Related identifiers or resources associated with the DocumentReference.
    property relatedList : TFhirDocumentReferenceContextRelatedList read GetRelatedList;
    property hasRelatedList : boolean read GetHasRelatedList;

  end;

  TFhirDocumentReferenceContextListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDocumentReferenceContextList;
    function GetCurrent : TFhirDocumentReferenceContext;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDocumentReferenceContextList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDocumentReferenceContext read GetCurrent;
  end;

  TFhirDocumentReferenceContextList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDocumentReferenceContext;
    procedure SetItemN(index : Integer; value : TFhirDocumentReferenceContext);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDocumentReferenceContextList; Overload;
    function Clone : TFhirDocumentReferenceContextList; Overload;
    function GetEnumerator : TFhirDocumentReferenceContextListEnumerator;

    //  Add a FhirDocumentReferenceContext to the end of the list.
    function Append : TFhirDocumentReferenceContext;

    // Add an already existing FhirDocumentReferenceContext to the end of the list.
    procedure AddItem(value : TFhirDocumentReferenceContext); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDocumentReferenceContext) : Integer;

    // Insert FhirDocumentReferenceContext before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDocumentReferenceContext;

    // Insert an existing FhirDocumentReferenceContext before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDocumentReferenceContext);

    // Get the iIndexth FhirDocumentReferenceContext. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDocumentReferenceContext);

    // The number of items in the collection
    function Item(index : Integer) : TFhirDocumentReferenceContext;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirDocumentReferenceContexts[index : Integer] : TFhirDocumentReferenceContext read GetItemN write SetItemN; default;
  End;

  // Related identifiers or resources associated with the DocumentReference.
  TFhirDocumentReferenceContextRelated = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirIdentifier;
    FRef : TFhirReference{TFhirReference};
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetRef(value : TFhirReference{TFhirReference});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDocumentReferenceContextRelated; overload;
    function Clone : TFhirDocumentReferenceContextRelated; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Related identifier to this DocumentReference. If both id and ref are present they shall refer to the same thing. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Related identifier to this DocumentReference. If both id and ref are present they shall refer to the same thing.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to Related Resource to this DocumentReference. If both id and ref are present they shall refer to the same thing. (defined for API consistency)
    property ref : TFhirReference{TFhirReference} read FRef write SetRef;
    // Related Resource to this DocumentReference. If both id and ref are present they shall refer to the same thing.
    property refElement : TFhirReference{TFhirReference} read FRef write SetRef;

  end;

  TFhirDocumentReferenceContextRelatedListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDocumentReferenceContextRelatedList;
    function GetCurrent : TFhirDocumentReferenceContextRelated;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDocumentReferenceContextRelatedList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDocumentReferenceContextRelated read GetCurrent;
  end;

  TFhirDocumentReferenceContextRelatedList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDocumentReferenceContextRelated;
    procedure SetItemN(index : Integer; value : TFhirDocumentReferenceContextRelated);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDocumentReferenceContextRelatedList; Overload;
    function Clone : TFhirDocumentReferenceContextRelatedList; Overload;
    function GetEnumerator : TFhirDocumentReferenceContextRelatedListEnumerator;

    //  Add a FhirDocumentReferenceContextRelated to the end of the list.
    function Append : TFhirDocumentReferenceContextRelated;

    // Add an already existing FhirDocumentReferenceContextRelated to the end of the list.
    procedure AddItem(value : TFhirDocumentReferenceContextRelated); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDocumentReferenceContextRelated) : Integer;

    // Insert FhirDocumentReferenceContextRelated before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDocumentReferenceContextRelated;

    // Insert an existing FhirDocumentReferenceContextRelated before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDocumentReferenceContextRelated);

    // Get the iIndexth FhirDocumentReferenceContextRelated. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDocumentReferenceContextRelated);

    // The number of items in the collection
    function Item(index : Integer) : TFhirDocumentReferenceContextRelated;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirDocumentReferenceContextRelateds[index : Integer] : TFhirDocumentReferenceContextRelated read GetItemN write SetItemN; default;
  End;

  // A reference to a document .
  TFhirDocumentReference = class (TFhirDomainResource)
  protected
    FMasterIdentifier : TFhirIdentifier;
    FidentifierList : TFhirIdentifierList;
    FSubject : TFhirReference{Resource};
    FType_ : TFhirCodeableConcept;
    FClass_ : TFhirCodeableConcept;
    FauthorList : TFhirReferenceList{Resource};
    FCustodian : TFhirReference{TFhirOrganization};
    FAuthenticator : TFhirReference{Resource};
    FCreated : TFhirDateTime;
    FIndexed : TFhirInstant;
    FStatus : TFhirEnum;
    FDocStatus : TFhirCodeableConcept;
    FrelatesToList : TFhirDocumentReferenceRelatesToList;
    FDescription : TFhirString;
    FsecurityLabelList : TFhirCodeableConceptList;
    FcontentList : TFhirDocumentReferenceContentList;
    FContext : TFhirDocumentReferenceContext;
    Procedure SetMasterIdentifier(value : TFhirIdentifier);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetSubject(value : TFhirReference{Resource});
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetClass_(value : TFhirCodeableConcept);
    function GetAuthorList : TFhirReferenceList{Resource};
    function GetHasAuthorList : Boolean;
    Procedure SetCustodian(value : TFhirReference{TFhirOrganization});
    Procedure SetAuthenticator(value : TFhirReference{Resource});
    Procedure SetCreated(value : TFhirDateTime);
    Function GetCreatedST : TFslDateTime;
    Procedure SetCreatedST(value : TFslDateTime);
    Procedure SetIndexed(value : TFhirInstant);
    Function GetIndexedST : TFslDateTime;
    Procedure SetIndexedST(value : TFslDateTime);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirDocumentReferenceStatusEnum;
    Procedure SetStatusST(value : TFhirDocumentReferenceStatusEnum);
    Procedure SetDocStatus(value : TFhirCodeableConcept);
    function GetRelatesToList : TFhirDocumentReferenceRelatesToList;
    function GetHasRelatesToList : Boolean;
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    function GetSecurityLabelList : TFhirCodeableConceptList;
    function GetHasSecurityLabelList : Boolean;
    function GetContentList : TFhirDocumentReferenceContentList;
    function GetHasContentList : Boolean;
    Procedure SetContext(value : TFhirDocumentReferenceContext);

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDocumentReference; overload;
    function Clone : TFhirDocumentReference; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Document identifier as assigned by the source of the document. This identifier is specific to this version of the document. This unique identifier may be used elsewhere to identify this version of the document. (defined for API consistency)
    property masterIdentifier : TFhirIdentifier read FMasterIdentifier write SetMasterIdentifier;
    // Document identifier as assigned by the source of the document. This identifier is specific to this version of the document. This unique identifier may be used elsewhere to identify this version of the document.
    property masterIdentifierElement : TFhirIdentifier read FMasterIdentifier write SetMasterIdentifier;

    // Other identifiers associated with the document, including version independent identifiers.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Who or what the document is about. The document can be about a person, (patient or healthcare practitioner), a device (e.g. a machine) or even a group of subjects (such as a document about a herd of farm animals, or a set of patients that share a common exposure). (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // Who or what the document is about. The document can be about a person, (patient or healthcare practitioner), a device (e.g. a machine) or even a group of subjects (such as a document about a herd of farm animals, or a set of patients that share a common exposure).
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // Typed access to Specifies the particular kind of document referenced  (e.g. History and Physical, Discharge Summary, Progress Note). This usually equates to the purpose of making the document referenced. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Specifies the particular kind of document referenced  (e.g. History and Physical, Discharge Summary, Progress Note). This usually equates to the purpose of making the document referenced.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to A categorization for the type of document referenced - helps for indexing and searching. This may be implied by or derived from the code specified in the DocumentReference.type. (defined for API consistency)
    property class_ : TFhirCodeableConcept read FClass_ write SetClass_;
    // A categorization for the type of document referenced - helps for indexing and searching. This may be implied by or derived from the code specified in the DocumentReference.type.
    property class_Element : TFhirCodeableConcept read FClass_ write SetClass_;

    // Identifies who is responsible for adding the information to the document.
    property authorList : TFhirReferenceList{Resource} read GetAuthorList;
    property hasAuthorList : boolean read GetHasAuthorList;

    // Typed access to Identifies the organization or group who is responsible for ongoing maintenance of and access to the document. (defined for API consistency)
    property custodian : TFhirReference{TFhirOrganization} read FCustodian write SetCustodian;
    // Identifies the organization or group who is responsible for ongoing maintenance of and access to the document.
    property custodianElement : TFhirReference{TFhirOrganization} read FCustodian write SetCustodian;

    // Typed access to Which person or organization authenticates that this document is valid. (defined for API consistency)
    property authenticator : TFhirReference{Resource} read FAuthenticator write SetAuthenticator;
    // Which person or organization authenticates that this document is valid.
    property authenticatorElement : TFhirReference{Resource} read FAuthenticator write SetAuthenticator;

    // Typed access to When the document was created.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // When the document was created.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to When the document reference was created.
    property indexed : TFslDateTime read GetIndexedST write SetIndexedST;
    // When the document reference was created.
    property indexedElement : TFhirInstant read FIndexed write SetIndexed;

    // The status of this document reference.
    property status : TFhirDocumentReferenceStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The status of the underlying document. (defined for API consistency)
    property docStatus : TFhirCodeableConcept read FDocStatus write SetDocStatus;
    // The status of the underlying document.
    property docStatusElement : TFhirCodeableConcept read FDocStatus write SetDocStatus;

    // Relationships that this document has with other document references that already exist.
    property relatesToList : TFhirDocumentReferenceRelatesToList read GetRelatesToList;
    property hasRelatesToList : boolean read GetHasRelatesToList;

    // Typed access to Human-readable description of the source document. This is sometimes known as the "title".
    property description : String read GetDescriptionST write SetDescriptionST;
    // Human-readable description of the source document. This is sometimes known as the "title".
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // A set of Security-Tag codes specifying the level of privacy/security of the Document. Note that DocumentReference.meta.security contains the security labels of the "reference" to the document, while DocumentReference.securityLabel contains a snapshot of the security labels on the document the reference refers to.
    property securityLabelList : TFhirCodeableConceptList read GetSecurityLabelList;
    property hasSecurityLabelList : boolean read GetHasSecurityLabelList;

    // The document and format referenced. There may be multiple content element repetitions, each with a different format.
    property contentList : TFhirDocumentReferenceContentList read GetContentList;
    property hasContentList : boolean read GetHasContentList;

    // Typed access to The clinical context in which the document was prepared. (defined for API consistency)
    property context : TFhirDocumentReferenceContext read FContext write SetContext;
    // The clinical context in which the document was prepared.
    property contextElement : TFhirDocumentReferenceContext read FContext write SetContext;

  end;

  TFhirDocumentReferenceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDocumentReferenceList;
    function GetCurrent : TFhirDocumentReference;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDocumentReferenceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDocumentReference read GetCurrent;
  end;

  TFhirDocumentReferenceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDocumentReference;
    procedure SetItemN(index : Integer; value : TFhirDocumentReference);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDocumentReferenceList; Overload;
    function Clone : TFhirDocumentReferenceList; Overload;
    function GetEnumerator : TFhirDocumentReferenceListEnumerator;

    //  Add a FhirDocumentReference to the end of the list.
    function Append : TFhirDocumentReference;

    // Add an already existing FhirDocumentReference to the end of the list.
    procedure AddItem(value : TFhirDocumentReference); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDocumentReference) : Integer;

    // Insert FhirDocumentReference before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDocumentReference;

    // Insert an existing FhirDocumentReference before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDocumentReference);

    // Get the iIndexth FhirDocumentReference. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDocumentReference);

    // The number of items in the collection
    function Item(index : Integer) : TFhirDocumentReference;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirDocumentReferences[index : Integer] : TFhirDocumentReference read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_DOCUMENTREFERENCE}

{$IFDEF FHIR_FAMILYMEMBERHISTORY}

  // The significant Conditions (or condition) that the family member had. This is a repeating section to allow a system to represent more than one condition per resource, though there is nothing stopping multiple resources - one per condition.
  TFhirFamilyMemberHistoryCondition = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FOutcome : TFhirCodeableConcept;
    FOnset : TFhirType;
    FNote : TFhirAnnotation;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetOutcome(value : TFhirCodeableConcept);
    Procedure SetOnset(value : TFhirType);
    Procedure SetNote(value : TFhirAnnotation);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirFamilyMemberHistoryCondition; overload;
    function Clone : TFhirFamilyMemberHistoryCondition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The actual condition specified. Could be a coded condition (like MI or Diabetes) or a less specific string like 'cancer' depending on how much is known about the condition and the capabilities of the creating system. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The actual condition specified. Could be a coded condition (like MI or Diabetes) or a less specific string like 'cancer' depending on how much is known about the condition and the capabilities of the creating system.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to Indicates what happened as a result of this condition.  If the condition resulted in death, deceased date is captured on the relation. (defined for API consistency)
    property outcome : TFhirCodeableConcept read FOutcome write SetOutcome;
    // Indicates what happened as a result of this condition.  If the condition resulted in death, deceased date is captured on the relation.
    property outcomeElement : TFhirCodeableConcept read FOutcome write SetOutcome;

    // Typed access to Either the age of onset, range of approximate age or descriptive string can be recorded.  For conditions with multiple occurrences, this describes the first known occurrence. (defined for API consistency)
    property onset : TFhirType read FOnset write SetOnset;
    // Either the age of onset, range of approximate age or descriptive string can be recorded.  For conditions with multiple occurrences, this describes the first known occurrence.
    property onsetElement : TFhirType read FOnset write SetOnset;

    // Typed access to An area where general notes can be placed about this specific condition. (defined for API consistency)
    property note : TFhirAnnotation read FNote write SetNote;
    // An area where general notes can be placed about this specific condition.
    property noteElement : TFhirAnnotation read FNote write SetNote;

  end;

  TFhirFamilyMemberHistoryConditionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirFamilyMemberHistoryConditionList;
    function GetCurrent : TFhirFamilyMemberHistoryCondition;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirFamilyMemberHistoryConditionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirFamilyMemberHistoryCondition read GetCurrent;
  end;

  TFhirFamilyMemberHistoryConditionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirFamilyMemberHistoryCondition;
    procedure SetItemN(index : Integer; value : TFhirFamilyMemberHistoryCondition);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirFamilyMemberHistoryConditionList; Overload;
    function Clone : TFhirFamilyMemberHistoryConditionList; Overload;
    function GetEnumerator : TFhirFamilyMemberHistoryConditionListEnumerator;

    //  Add a FhirFamilyMemberHistoryCondition to the end of the list.
    function Append : TFhirFamilyMemberHistoryCondition;

    // Add an already existing FhirFamilyMemberHistoryCondition to the end of the list.
    procedure AddItem(value : TFhirFamilyMemberHistoryCondition); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirFamilyMemberHistoryCondition) : Integer;

    // Insert FhirFamilyMemberHistoryCondition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirFamilyMemberHistoryCondition;

    // Insert an existing FhirFamilyMemberHistoryCondition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirFamilyMemberHistoryCondition);

    // Get the iIndexth FhirFamilyMemberHistoryCondition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirFamilyMemberHistoryCondition);

    // The number of items in the collection
    function Item(index : Integer) : TFhirFamilyMemberHistoryCondition;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirFamilyMemberHistoryConditions[index : Integer] : TFhirFamilyMemberHistoryCondition read GetItemN write SetItemN; default;
  End;

  // Significant health events and conditions for a person related to the patient relevant in the context of care for the patient.
  TFhirFamilyMemberHistory = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FPatient : TFhirReference{TFhirPatient};
    FDate : TFhirDateTime;
    FStatus : TFhirEnum;
    FName : TFhirString;
    FRelationship : TFhirCodeableConcept;
    FGender : TFhirEnum;
    FBorn : TFhirType;
    FAge : TFhirType;
    FDeceased : TFhirType;
    FNote : TFhirAnnotation;
    FconditionList : TFhirFamilyMemberHistoryConditionList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirHistoryStatusEnum;
    Procedure SetStatusST(value : TFhirHistoryStatusEnum);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetRelationship(value : TFhirCodeableConcept);
    Procedure SetGender(value : TFhirEnum);
    Function GetGenderST : TFhirAdministrativeGenderEnum;
    Procedure SetGenderST(value : TFhirAdministrativeGenderEnum);
    Procedure SetBorn(value : TFhirType);
    Procedure SetAge(value : TFhirType);
    Procedure SetDeceased(value : TFhirType);
    Procedure SetNote(value : TFhirAnnotation);
    function GetConditionList : TFhirFamilyMemberHistoryConditionList;
    function GetHasConditionList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirFamilyMemberHistory; overload;
    function Clone : TFhirFamilyMemberHistory; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // This records identifiers associated with this family member history record that are defined by business processes and/ or used to refer to it when a direct URL reference to the resource itself is not appropriate (e.g. in CDA documents, or in written / printed documentation).
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The person who this history concerns. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // The person who this history concerns.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Typed access to The date (and possibly time) when the family member history was taken.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date (and possibly time) when the family member history was taken.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // A code specifying a state of a Family Member History record.
    property status : TFhirHistoryStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to This will either be a name or a description; e.g. "Aunt Susan", "my cousin with the red hair".
    property name : String read GetNameST write SetNameST;
    // This will either be a name or a description; e.g. "Aunt Susan", "my cousin with the red hair".
    property nameElement : TFhirString read FName write SetName;

    // Typed access to The type of relationship this person has to the patient (father, mother, brother etc.). (defined for API consistency)
    property relationship : TFhirCodeableConcept read FRelationship write SetRelationship;
    // The type of relationship this person has to the patient (father, mother, brother etc.).
    property relationshipElement : TFhirCodeableConcept read FRelationship write SetRelationship;

    // Administrative Gender - the gender that the relative is considered to have for administration and record keeping purposes.
    property gender : TFhirAdministrativeGenderEnum read GetGenderST write SetGenderST;
    property genderElement : TFhirEnum read FGender write SetGender;

    // Typed access to The actual or approximate date of birth of the relative. (defined for API consistency)
    property born : TFhirType read FBorn write SetBorn;
    // The actual or approximate date of birth of the relative.
    property bornElement : TFhirType read FBorn write SetBorn;

    // Typed access to The actual or approximate age of the relative at the time the family member history is recorded. (defined for API consistency)
    property age : TFhirType read FAge write SetAge;
    // The actual or approximate age of the relative at the time the family member history is recorded.
    property ageElement : TFhirType read FAge write SetAge;

    // Typed access to Deceased flag or the actual or approximate age of the relative at the time of death for the family member history record. (defined for API consistency)
    property deceased : TFhirType read FDeceased write SetDeceased;
    // Deceased flag or the actual or approximate age of the relative at the time of death for the family member history record.
    property deceasedElement : TFhirType read FDeceased write SetDeceased;

    // Typed access to This property allows a non condition-specific note to the made about the related person. Ideally, the note would be in the condition property, but this is not always possible. (defined for API consistency)
    property note : TFhirAnnotation read FNote write SetNote;
    // This property allows a non condition-specific note to the made about the related person. Ideally, the note would be in the condition property, but this is not always possible.
    property noteElement : TFhirAnnotation read FNote write SetNote;

    // The significant Conditions (or condition) that the family member had. This is a repeating section to allow a system to represent more than one condition per resource, though there is nothing stopping multiple resources - one per condition.
    property conditionList : TFhirFamilyMemberHistoryConditionList read GetConditionList;
    property hasConditionList : boolean read GetHasConditionList;

  end;

  TFhirFamilyMemberHistoryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirFamilyMemberHistoryList;
    function GetCurrent : TFhirFamilyMemberHistory;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirFamilyMemberHistoryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirFamilyMemberHistory read GetCurrent;
  end;

  TFhirFamilyMemberHistoryList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirFamilyMemberHistory;
    procedure SetItemN(index : Integer; value : TFhirFamilyMemberHistory);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirFamilyMemberHistoryList; Overload;
    function Clone : TFhirFamilyMemberHistoryList; Overload;
    function GetEnumerator : TFhirFamilyMemberHistoryListEnumerator;

    //  Add a FhirFamilyMemberHistory to the end of the list.
    function Append : TFhirFamilyMemberHistory;

    // Add an already existing FhirFamilyMemberHistory to the end of the list.
    procedure AddItem(value : TFhirFamilyMemberHistory); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirFamilyMemberHistory) : Integer;

    // Insert FhirFamilyMemberHistory before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirFamilyMemberHistory;

    // Insert an existing FhirFamilyMemberHistory before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirFamilyMemberHistory);

    // Get the iIndexth FhirFamilyMemberHistory. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirFamilyMemberHistory);

    // The number of items in the collection
    function Item(index : Integer) : TFhirFamilyMemberHistory;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirFamilyMemberHistories[index : Integer] : TFhirFamilyMemberHistory read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_FAMILYMEMBERHISTORY}

{$IFDEF FHIR_FLAG}

  // Prospective warnings of potential issues when providing care to the patient.
  TFhirFlag = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FCategory : TFhirCodeableConcept;
    FStatus : TFhirEnum;
    FPeriod : TFhirPeriod;
    FSubject : TFhirReference{Resource};
    FEncounter : TFhirReference{TFhirEncounter};
    FAuthor : TFhirReference{Resource};
    FCode : TFhirCodeableConcept;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirFlagStatusEnum;
    Procedure SetStatusST(value : TFhirFlagStatusEnum);
    Procedure SetPeriod(value : TFhirPeriod);
    Procedure SetSubject(value : TFhirReference{Resource});
    Procedure SetEncounter(value : TFhirReference{TFhirEncounter});
    Procedure SetAuthor(value : TFhirReference{Resource});
    Procedure SetCode(value : TFhirCodeableConcept);

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirFlag; overload;
    function Clone : TFhirFlag; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifier assigned to the flag for external use (outside the FHIR environment).
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Allows an flag to be divided into different categories like clinical, administrative etc. Intended to be used as a means of filtering which flags are displayed to particular user or in a given context. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Allows an flag to be divided into different categories like clinical, administrative etc. Intended to be used as a means of filtering which flags are displayed to particular user or in a given context.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Supports basic workflow.
    property status : TFhirFlagStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The period of time from the activation of the flag to inactivation of the flag. If the flag is active, the end of the period should be unspecified. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period of time from the activation of the flag to inactivation of the flag. If the flag is active, the end of the period should be unspecified.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to The patient, location, group , organization , or practitioner this is about record this flag is associated with. (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // The patient, location, group , organization , or practitioner this is about record this flag is associated with.
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // Typed access to This alert is only relevant during the encounter. (defined for API consistency)
    property encounter : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;
    // This alert is only relevant during the encounter.
    property encounterElement : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;

    // Typed access to The person, organization or device that created the flag. (defined for API consistency)
    property author : TFhirReference{Resource} read FAuthor write SetAuthor;
    // The person, organization or device that created the flag.
    property authorElement : TFhirReference{Resource} read FAuthor write SetAuthor;

    // Typed access to The coded value or textual component of the flag to display to the user. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The coded value or textual component of the flag to display to the user.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

  end;

  TFhirFlagListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirFlagList;
    function GetCurrent : TFhirFlag;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirFlagList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirFlag read GetCurrent;
  end;

  TFhirFlagList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirFlag;
    procedure SetItemN(index : Integer; value : TFhirFlag);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirFlagList; Overload;
    function Clone : TFhirFlagList; Overload;
    function GetEnumerator : TFhirFlagListEnumerator;

    //  Add a FhirFlag to the end of the list.
    function Append : TFhirFlag;

    // Add an already existing FhirFlag to the end of the list.
    procedure AddItem(value : TFhirFlag); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirFlag) : Integer;

    // Insert FhirFlag before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirFlag;

    // Insert an existing FhirFlag before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirFlag);

    // Get the iIndexth FhirFlag. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirFlag);

    // The number of items in the collection
    function Item(index : Integer) : TFhirFlag;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirFlags[index : Integer] : TFhirFlag read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_FLAG}

{$IFDEF FHIR_GOAL}

  // Identifies the change (or lack of change) at the point where the goal was deepmed to be cancelled or achieved.
  TFhirGoalOutcome = class (TFhirBackboneElement)
  protected
    FResult : TFhirType;
    Procedure SetResult(value : TFhirType);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirGoalOutcome; overload;
    function Clone : TFhirGoalOutcome; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Details of what's changed (or not changed). (defined for API consistency)
    property result : TFhirType read FResult write SetResult;
    // Details of what's changed (or not changed).
    property resultElement : TFhirType read FResult write SetResult;

  end;

  TFhirGoalOutcomeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirGoalOutcomeList;
    function GetCurrent : TFhirGoalOutcome;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirGoalOutcomeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirGoalOutcome read GetCurrent;
  end;

  TFhirGoalOutcomeList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirGoalOutcome;
    procedure SetItemN(index : Integer; value : TFhirGoalOutcome);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirGoalOutcomeList; Overload;
    function Clone : TFhirGoalOutcomeList; Overload;
    function GetEnumerator : TFhirGoalOutcomeListEnumerator;

    //  Add a FhirGoalOutcome to the end of the list.
    function Append : TFhirGoalOutcome;

    // Add an already existing FhirGoalOutcome to the end of the list.
    procedure AddItem(value : TFhirGoalOutcome); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirGoalOutcome) : Integer;

    // Insert FhirGoalOutcome before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirGoalOutcome;

    // Insert an existing FhirGoalOutcome before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirGoalOutcome);

    // Get the iIndexth FhirGoalOutcome. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirGoalOutcome);

    // The number of items in the collection
    function Item(index : Integer) : TFhirGoalOutcome;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirGoalOutcomes[index : Integer] : TFhirGoalOutcome read GetItemN write SetItemN; default;
  End;

  // Describes the intended objective(s) for a patient, group or organization care, for example, weight loss, restoring an activity of daily living, obtaining herd immunity via immunization, meeting a process improvement objective, etc.
  TFhirGoal = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FSubject : TFhirReference{Resource};
    FStart : TFhirType;
    FTarget : TFhirType;
    FcategoryList : TFhirCodeableConceptList;
    FDescription : TFhirString;
    FStatus : TFhirEnum;
    FStatusDate : TFhirDate;
    FStatusReason : TFhirCodeableConcept;
    FAuthor : TFhirReference{Resource};
    FPriority : TFhirCodeableConcept;
    FaddressesList : TFhirReferenceList{Resource};
    FnoteList : TFhirAnnotationList;
    FoutcomeList : TFhirGoalOutcomeList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetSubject(value : TFhirReference{Resource});
    Procedure SetStart(value : TFhirType);
    Procedure SetTarget(value : TFhirType);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirGoalStatusEnum;
    Procedure SetStatusST(value : TFhirGoalStatusEnum);
    Procedure SetStatusDate(value : TFhirDate);
    Function GetStatusDateST : TFslDateTime;
    Procedure SetStatusDateST(value : TFslDateTime);
    Procedure SetStatusReason(value : TFhirCodeableConcept);
    Procedure SetAuthor(value : TFhirReference{Resource});
    Procedure SetPriority(value : TFhirCodeableConcept);
    function GetAddressesList : TFhirReferenceList{Resource};
    function GetHasAddressesList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetOutcomeList : TFhirGoalOutcomeList;
    function GetHasOutcomeList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirGoal; overload;
    function Clone : TFhirGoal; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // This records identifiers associated with this care plan that are defined by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate (e.g. in CDA documents, or in written / printed documentation).
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Identifies the patient, group or organization for whom the goal is being established. (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // Identifies the patient, group or organization for whom the goal is being established.
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // Typed access to The date or event after which the goal should begin being pursued. (defined for API consistency)
    property start : TFhirType read FStart write SetStart;
    // The date or event after which the goal should begin being pursued.
    property startElement : TFhirType read FStart write SetStart;

    // Typed access to Indicates either the date or the duration after start by which the goal should be met. (defined for API consistency)
    property target : TFhirType read FTarget write SetTarget;
    // Indicates either the date or the duration after start by which the goal should be met.
    property targetElement : TFhirType read FTarget write SetTarget;

    // Indicates a category the goal falls within.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to Human-readable description of a specific desired objective of care.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Human-readable description of a specific desired objective of care.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Indicates whether the goal has been reached and is still considered relevant.
    property status : TFhirGoalStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Identifies when the current status.  I.e. When initially created, when achieved, when cancelled, etc.
    property statusDate : TFslDateTime read GetStatusDateST write SetStatusDateST;
    // Identifies when the current status.  I.e. When initially created, when achieved, when cancelled, etc.
    property statusDateElement : TFhirDate read FStatusDate write SetStatusDate;

    // Typed access to Captures the reason for the current status. (defined for API consistency)
    property statusReason : TFhirCodeableConcept read FStatusReason write SetStatusReason;
    // Captures the reason for the current status.
    property statusReasonElement : TFhirCodeableConcept read FStatusReason write SetStatusReason;

    // Typed access to Indicates whose goal this is - patient goal, practitioner goal, etc. (defined for API consistency)
    property author : TFhirReference{Resource} read FAuthor write SetAuthor;
    // Indicates whose goal this is - patient goal, practitioner goal, etc.
    property authorElement : TFhirReference{Resource} read FAuthor write SetAuthor;

    // Typed access to Identifies the mutually agreed level of importance associated with reaching/sustaining the goal. (defined for API consistency)
    property priority : TFhirCodeableConcept read FPriority write SetPriority;
    // Identifies the mutually agreed level of importance associated with reaching/sustaining the goal.
    property priorityElement : TFhirCodeableConcept read FPriority write SetPriority;

    // The identified conditions and other health record elements that are intended to be addressed by the goal.
    property addressesList : TFhirReferenceList{Resource} read GetAddressesList;
    property hasAddressesList : boolean read GetHasAddressesList;

    // Any comments related to the goal.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Identifies the change (or lack of change) at the point where the goal was deepmed to be cancelled or achieved.
    property outcomeList : TFhirGoalOutcomeList read GetOutcomeList;
    property hasOutcomeList : boolean read GetHasOutcomeList;

  end;

  TFhirGoalListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirGoalList;
    function GetCurrent : TFhirGoal;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirGoalList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirGoal read GetCurrent;
  end;

  TFhirGoalList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirGoal;
    procedure SetItemN(index : Integer; value : TFhirGoal);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirGoalList; Overload;
    function Clone : TFhirGoalList; Overload;
    function GetEnumerator : TFhirGoalListEnumerator;

    //  Add a FhirGoal to the end of the list.
    function Append : TFhirGoal;

    // Add an already existing FhirGoal to the end of the list.
    procedure AddItem(value : TFhirGoal); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirGoal) : Integer;

    // Insert FhirGoal before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirGoal;

    // Insert an existing FhirGoal before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirGoal);

    // Get the iIndexth FhirGoal. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirGoal);

    // The number of items in the collection
    function Item(index : Integer) : TFhirGoal;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirGoals[index : Integer] : TFhirGoal read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_GOAL}

{$IFDEF FHIR_IMAGINGOBJECTSELECTION}

  // Study identity and locating information of the DICOM SOP instances in the selection.
  TFhirImagingObjectSelectionStudy = class (TFhirBackboneElement)
  protected
    FUid : TFhirOid;
    FUrl : TFhirUri;
    FImagingStudy : TFhirReference{TFhirImagingStudy};
    FseriesList : TFhirImagingObjectSelectionStudySeriesList;
    Procedure SetUid(value : TFhirOid);
    Function GetUidST : String;
    Procedure SetUidST(value : String);
    Procedure SetUrl(value : TFhirUri);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);
    Procedure SetImagingStudy(value : TFhirReference{TFhirImagingStudy});
    function GetSeriesList : TFhirImagingObjectSelectionStudySeriesList;
    function GetHasSeriesList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImagingObjectSelectionStudy; overload;
    function Clone : TFhirImagingObjectSelectionStudy; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Study instance UID of the SOP instances in the selection.
    property uid : String read GetUidST write SetUidST;
    // Study instance UID of the SOP instances in the selection.
    property uidElement : TFhirOid read FUid write SetUid;

    // Typed access to WADO-RS URL to retrieve the study. Note that this URL retrieves all SOP instances of the study, not only those in the selection.
    property url : String read GetUrlST write SetUrlST;
    // WADO-RS URL to retrieve the study. Note that this URL retrieves all SOP instances of the study, not only those in the selection.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to Reference to the Imaging Study in FHIR form. (defined for API consistency)
    property imagingStudy : TFhirReference{TFhirImagingStudy} read FImagingStudy write SetImagingStudy;
    // Reference to the Imaging Study in FHIR form.
    property imagingStudyElement : TFhirReference{TFhirImagingStudy} read FImagingStudy write SetImagingStudy;

    // Series identity and locating information of the DICOM SOP instances in the selection.
    property seriesList : TFhirImagingObjectSelectionStudySeriesList read GetSeriesList;
    property hasSeriesList : boolean read GetHasSeriesList;

  end;

  TFhirImagingObjectSelectionStudyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImagingObjectSelectionStudyList;
    function GetCurrent : TFhirImagingObjectSelectionStudy;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImagingObjectSelectionStudyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImagingObjectSelectionStudy read GetCurrent;
  end;

  TFhirImagingObjectSelectionStudyList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImagingObjectSelectionStudy;
    procedure SetItemN(index : Integer; value : TFhirImagingObjectSelectionStudy);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImagingObjectSelectionStudyList; Overload;
    function Clone : TFhirImagingObjectSelectionStudyList; Overload;
    function GetEnumerator : TFhirImagingObjectSelectionStudyListEnumerator;

    //  Add a FhirImagingObjectSelectionStudy to the end of the list.
    function Append : TFhirImagingObjectSelectionStudy;

    // Add an already existing FhirImagingObjectSelectionStudy to the end of the list.
    procedure AddItem(value : TFhirImagingObjectSelectionStudy); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImagingObjectSelectionStudy) : Integer;

    // Insert FhirImagingObjectSelectionStudy before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImagingObjectSelectionStudy;

    // Insert an existing FhirImagingObjectSelectionStudy before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImagingObjectSelectionStudy);

    // Get the iIndexth FhirImagingObjectSelectionStudy. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImagingObjectSelectionStudy);

    // The number of items in the collection
    function Item(index : Integer) : TFhirImagingObjectSelectionStudy;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirImagingObjectSelectionStudies[index : Integer] : TFhirImagingObjectSelectionStudy read GetItemN write SetItemN; default;
  End;

  // Series identity and locating information of the DICOM SOP instances in the selection.
  TFhirImagingObjectSelectionStudySeries = class (TFhirBackboneElement)
  protected
    FUid : TFhirOid;
    FUrl : TFhirUri;
    FinstanceList : TFhirImagingObjectSelectionStudySeriesInstanceList;
    Procedure SetUid(value : TFhirOid);
    Function GetUidST : String;
    Procedure SetUidST(value : String);
    Procedure SetUrl(value : TFhirUri);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);
    function GetInstanceList : TFhirImagingObjectSelectionStudySeriesInstanceList;
    function GetHasInstanceList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImagingObjectSelectionStudySeries; overload;
    function Clone : TFhirImagingObjectSelectionStudySeries; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Series instance UID of the SOP instances in the selection.
    property uid : String read GetUidST write SetUidST;
    // Series instance UID of the SOP instances in the selection.
    property uidElement : TFhirOid read FUid write SetUid;

    // Typed access to WADO-RS URL to retrieve the series. Note that this URL retrieves all SOP instances of the series not only those in the selection.
    property url : String read GetUrlST write SetUrlST;
    // WADO-RS URL to retrieve the series. Note that this URL retrieves all SOP instances of the series not only those in the selection.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Identity and locating information of the selected DICOM SOP instances.
    property instanceList : TFhirImagingObjectSelectionStudySeriesInstanceList read GetInstanceList;
    property hasInstanceList : boolean read GetHasInstanceList;

  end;

  TFhirImagingObjectSelectionStudySeriesListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImagingObjectSelectionStudySeriesList;
    function GetCurrent : TFhirImagingObjectSelectionStudySeries;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImagingObjectSelectionStudySeriesList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImagingObjectSelectionStudySeries read GetCurrent;
  end;

  TFhirImagingObjectSelectionStudySeriesList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImagingObjectSelectionStudySeries;
    procedure SetItemN(index : Integer; value : TFhirImagingObjectSelectionStudySeries);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImagingObjectSelectionStudySeriesList; Overload;
    function Clone : TFhirImagingObjectSelectionStudySeriesList; Overload;
    function GetEnumerator : TFhirImagingObjectSelectionStudySeriesListEnumerator;

    //  Add a FhirImagingObjectSelectionStudySeries to the end of the list.
    function Append : TFhirImagingObjectSelectionStudySeries;

    // Add an already existing FhirImagingObjectSelectionStudySeries to the end of the list.
    procedure AddItem(value : TFhirImagingObjectSelectionStudySeries); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImagingObjectSelectionStudySeries) : Integer;

    // Insert FhirImagingObjectSelectionStudySeries before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImagingObjectSelectionStudySeries;

    // Insert an existing FhirImagingObjectSelectionStudySeries before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImagingObjectSelectionStudySeries);

    // Get the iIndexth FhirImagingObjectSelectionStudySeries. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImagingObjectSelectionStudySeries);

    // The number of items in the collection
    function Item(index : Integer) : TFhirImagingObjectSelectionStudySeries;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirImagingObjectSelectionStudySeries[index : Integer] : TFhirImagingObjectSelectionStudySeries read GetItemN write SetItemN; default;
  End;

  // Identity and locating information of the selected DICOM SOP instances.
  TFhirImagingObjectSelectionStudySeriesInstance = class (TFhirBackboneElement)
  protected
    FSopClass : TFhirOid;
    FUid : TFhirOid;
    FUrl : TFhirUri;
    FframesList : TFhirImagingObjectSelectionStudySeriesInstanceFramesList;
    Procedure SetSopClass(value : TFhirOid);
    Function GetSopClassST : String;
    Procedure SetSopClassST(value : String);
    Procedure SetUid(value : TFhirOid);
    Function GetUidST : String;
    Procedure SetUidST(value : String);
    Procedure SetUrl(value : TFhirUri);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);
    function GetFramesList : TFhirImagingObjectSelectionStudySeriesInstanceFramesList;
    function GetHasFramesList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImagingObjectSelectionStudySeriesInstance; overload;
    function Clone : TFhirImagingObjectSelectionStudySeriesInstance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to SOP class UID of the selected instance.
    property sopClass : String read GetSopClassST write SetSopClassST;
    // SOP class UID of the selected instance.
    property sopClassElement : TFhirOid read FSopClass write SetSopClass;

    // Typed access to SOP Instance UID of the selected instance.
    property uid : String read GetUidST write SetUidST;
    // SOP Instance UID of the selected instance.
    property uidElement : TFhirOid read FUid write SetUid;

    // Typed access to WADO-RS URL to retrieve the DICOM SOP Instance.
    property url : String read GetUrlST write SetUrlST;
    // WADO-RS URL to retrieve the DICOM SOP Instance.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Identity and location information of the frames in the selected instance.
    property framesList : TFhirImagingObjectSelectionStudySeriesInstanceFramesList read GetFramesList;
    property hasFramesList : boolean read GetHasFramesList;

  end;

  TFhirImagingObjectSelectionStudySeriesInstanceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImagingObjectSelectionStudySeriesInstanceList;
    function GetCurrent : TFhirImagingObjectSelectionStudySeriesInstance;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImagingObjectSelectionStudySeriesInstanceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImagingObjectSelectionStudySeriesInstance read GetCurrent;
  end;

  TFhirImagingObjectSelectionStudySeriesInstanceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImagingObjectSelectionStudySeriesInstance;
    procedure SetItemN(index : Integer; value : TFhirImagingObjectSelectionStudySeriesInstance);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImagingObjectSelectionStudySeriesInstanceList; Overload;
    function Clone : TFhirImagingObjectSelectionStudySeriesInstanceList; Overload;
    function GetEnumerator : TFhirImagingObjectSelectionStudySeriesInstanceListEnumerator;

    //  Add a FhirImagingObjectSelectionStudySeriesInstance to the end of the list.
    function Append : TFhirImagingObjectSelectionStudySeriesInstance;

    // Add an already existing FhirImagingObjectSelectionStudySeriesInstance to the end of the list.
    procedure AddItem(value : TFhirImagingObjectSelectionStudySeriesInstance); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImagingObjectSelectionStudySeriesInstance) : Integer;

    // Insert FhirImagingObjectSelectionStudySeriesInstance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImagingObjectSelectionStudySeriesInstance;

    // Insert an existing FhirImagingObjectSelectionStudySeriesInstance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImagingObjectSelectionStudySeriesInstance);

    // Get the iIndexth FhirImagingObjectSelectionStudySeriesInstance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImagingObjectSelectionStudySeriesInstance);

    // The number of items in the collection
    function Item(index : Integer) : TFhirImagingObjectSelectionStudySeriesInstance;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirImagingObjectSelectionStudySeriesInstances[index : Integer] : TFhirImagingObjectSelectionStudySeriesInstance read GetItemN write SetItemN; default;
  End;

  // Identity and location information of the frames in the selected instance.
  TFhirImagingObjectSelectionStudySeriesInstanceFrames = class (TFhirBackboneElement)
  protected
    FframeNumbersList : TFhirUnsignedIntList;
    FUrl : TFhirUri;
    function GetFrameNumbersList : TFhirUnsignedIntList;
    function GetHasFrameNumbersList : Boolean;
    Procedure SetUrl(value : TFhirUri);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImagingObjectSelectionStudySeriesInstanceFrames; overload;
    function Clone : TFhirImagingObjectSelectionStudySeriesInstanceFrames; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The frame numbers in the frame set.
    property frameNumbersList : TFhirUnsignedIntList read GetFrameNumbersList;
    property hasFrameNumbersList : boolean read GetHasFrameNumbersList;

    // Typed access to WADO-RS URL to retrieve the DICOM frames.
    property url : String read GetUrlST write SetUrlST;
    // WADO-RS URL to retrieve the DICOM frames.
    property urlElement : TFhirUri read FUrl write SetUrl;

  end;

  TFhirImagingObjectSelectionStudySeriesInstanceFramesListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImagingObjectSelectionStudySeriesInstanceFramesList;
    function GetCurrent : TFhirImagingObjectSelectionStudySeriesInstanceFrames;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImagingObjectSelectionStudySeriesInstanceFramesList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImagingObjectSelectionStudySeriesInstanceFrames read GetCurrent;
  end;

  TFhirImagingObjectSelectionStudySeriesInstanceFramesList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImagingObjectSelectionStudySeriesInstanceFrames;
    procedure SetItemN(index : Integer; value : TFhirImagingObjectSelectionStudySeriesInstanceFrames);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImagingObjectSelectionStudySeriesInstanceFramesList; Overload;
    function Clone : TFhirImagingObjectSelectionStudySeriesInstanceFramesList; Overload;
    function GetEnumerator : TFhirImagingObjectSelectionStudySeriesInstanceFramesListEnumerator;

    //  Add a FhirImagingObjectSelectionStudySeriesInstanceFrames to the end of the list.
    function Append : TFhirImagingObjectSelectionStudySeriesInstanceFrames;

    // Add an already existing FhirImagingObjectSelectionStudySeriesInstanceFrames to the end of the list.
    procedure AddItem(value : TFhirImagingObjectSelectionStudySeriesInstanceFrames); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImagingObjectSelectionStudySeriesInstanceFrames) : Integer;

    // Insert FhirImagingObjectSelectionStudySeriesInstanceFrames before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImagingObjectSelectionStudySeriesInstanceFrames;

    // Insert an existing FhirImagingObjectSelectionStudySeriesInstanceFrames before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImagingObjectSelectionStudySeriesInstanceFrames);

    // Get the iIndexth FhirImagingObjectSelectionStudySeriesInstanceFrames. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImagingObjectSelectionStudySeriesInstanceFrames);

    // The number of items in the collection
    function Item(index : Integer) : TFhirImagingObjectSelectionStudySeriesInstanceFrames;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirImagingObjectSelectionStudySeriesInstanceFrames[index : Integer] : TFhirImagingObjectSelectionStudySeriesInstanceFrames read GetItemN write SetItemN; default;
  End;

  // A manifest of a set of DICOM Service-Object Pair Instances (SOP Instances).  The referenced SOP Instances (images or other content) are for a single patient, and may be from one or more studies. The referenced SOP Instances have been selected for a purpose, such as quality assurance, conference, or consult. Reflecting that range of purposes, typical ImagingObjectSelection resources may include all SOP Instances in a study (perhaps for sharing through a Health Information Exchange); key images from multiple studies (for reference by a referring or treating physician); a multi-frame ultrasound instance ("cine" video clip) and a set of measurements taken from that instance (for inclusion in a teaching file); and so on.
  TFhirImagingObjectSelection = class (TFhirDomainResource)
  protected
    FUid : TFhirOid;
    FPatient : TFhirReference{TFhirPatient};
    FTitle : TFhirCodeableConcept;
    FDescription : TFhirString;
    FAuthor : TFhirReference{Resource};
    FAuthoringTime : TFhirDateTime;
    FstudyList : TFhirImagingObjectSelectionStudyList;
    Procedure SetUid(value : TFhirOid);
    Function GetUidST : String;
    Procedure SetUidST(value : String);
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    Procedure SetTitle(value : TFhirCodeableConcept);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetAuthor(value : TFhirReference{Resource});
    Procedure SetAuthoringTime(value : TFhirDateTime);
    Function GetAuthoringTimeST : TFslDateTime;
    Procedure SetAuthoringTimeST(value : TFslDateTime);
    function GetStudyList : TFhirImagingObjectSelectionStudyList;
    function GetHasStudyList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImagingObjectSelection; overload;
    function Clone : TFhirImagingObjectSelection; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Instance UID of the DICOM KOS SOP Instances represented in this resource.
    property uid : String read GetUidST write SetUidST;
    // Instance UID of the DICOM KOS SOP Instances represented in this resource.
    property uidElement : TFhirOid read FUid write SetUid;

    // Typed access to A patient resource reference which is the patient subject of all DICOM SOP Instances in this ImagingObjectSelection. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // A patient resource reference which is the patient subject of all DICOM SOP Instances in this ImagingObjectSelection.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Typed access to The reason for, or significance of, the selection of objects referenced in the resource. (defined for API consistency)
    property title : TFhirCodeableConcept read FTitle write SetTitle;
    // The reason for, or significance of, the selection of objects referenced in the resource.
    property titleElement : TFhirCodeableConcept read FTitle write SetTitle;

    // Typed access to Text description of the DICOM SOP instances selected in the ImagingObjectSelection. This should be aligned with the content of the title element, and can provide further explanation of the SOP instances in the selection.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Text description of the DICOM SOP instances selected in the ImagingObjectSelection. This should be aligned with the content of the title element, and can provide further explanation of the SOP instances in the selection.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Author of ImagingObjectSelection. It can be a human author or a device which made the decision of the SOP instances selected. For example, a radiologist selected a set of imaging SOP instances to attach in a diagnostic report, and a CAD application may author a selection to describe SOP instances it used to generate a detection conclusion. (defined for API consistency)
    property author : TFhirReference{Resource} read FAuthor write SetAuthor;
    // Author of ImagingObjectSelection. It can be a human author or a device which made the decision of the SOP instances selected. For example, a radiologist selected a set of imaging SOP instances to attach in a diagnostic report, and a CAD application may author a selection to describe SOP instances it used to generate a detection conclusion.
    property authorElement : TFhirReference{Resource} read FAuthor write SetAuthor;

    // Typed access to Date and time when the selection of the referenced instances were made. It is (typically) different from the creation date of the selection resource, and from dates associated with the referenced instances (e.g. capture time of the referenced image).
    property authoringTime : TFslDateTime read GetAuthoringTimeST write SetAuthoringTimeST;
    // Date and time when the selection of the referenced instances were made. It is (typically) different from the creation date of the selection resource, and from dates associated with the referenced instances (e.g. capture time of the referenced image).
    property authoringTimeElement : TFhirDateTime read FAuthoringTime write SetAuthoringTime;

    // Study identity and locating information of the DICOM SOP instances in the selection.
    property studyList : TFhirImagingObjectSelectionStudyList read GetStudyList;
    property hasStudyList : boolean read GetHasStudyList;

  end;

  TFhirImagingObjectSelectionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImagingObjectSelectionList;
    function GetCurrent : TFhirImagingObjectSelection;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImagingObjectSelectionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImagingObjectSelection read GetCurrent;
  end;

  TFhirImagingObjectSelectionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImagingObjectSelection;
    procedure SetItemN(index : Integer; value : TFhirImagingObjectSelection);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImagingObjectSelectionList; Overload;
    function Clone : TFhirImagingObjectSelectionList; Overload;
    function GetEnumerator : TFhirImagingObjectSelectionListEnumerator;

    //  Add a FhirImagingObjectSelection to the end of the list.
    function Append : TFhirImagingObjectSelection;

    // Add an already existing FhirImagingObjectSelection to the end of the list.
    procedure AddItem(value : TFhirImagingObjectSelection); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImagingObjectSelection) : Integer;

    // Insert FhirImagingObjectSelection before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImagingObjectSelection;

    // Insert an existing FhirImagingObjectSelection before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImagingObjectSelection);

    // Get the iIndexth FhirImagingObjectSelection. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImagingObjectSelection);

    // The number of items in the collection
    function Item(index : Integer) : TFhirImagingObjectSelection;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirImagingObjectSelections[index : Integer] : TFhirImagingObjectSelection read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_IMAGINGOBJECTSELECTION}

{$IFDEF FHIR_IMAGINGSTUDY}

  // Each study has one or more series of images or other content.
  TFhirImagingStudySeries = class (TFhirBackboneElement)
  protected
    FNumber : TFhirUnsignedInt;
    FModality : TFhirCoding;
    FUid : TFhirOid;
    FDescription : TFhirString;
    FNumberOfInstances : TFhirUnsignedInt;
    FAvailability : TFhirEnum;
    FUrl : TFhirUri;
    FBodySite : TFhirCoding;
    FLaterality : TFhirCoding;
    FStarted : TFhirDateTime;
    FinstanceList : TFhirImagingStudySeriesInstanceList;
    Procedure SetNumber(value : TFhirUnsignedInt);
    Function GetNumberST : String;
    Procedure SetNumberST(value : String);
    Procedure SetModality(value : TFhirCoding);
    Procedure SetUid(value : TFhirOid);
    Function GetUidST : String;
    Procedure SetUidST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetNumberOfInstances(value : TFhirUnsignedInt);
    Function GetNumberOfInstancesST : String;
    Procedure SetNumberOfInstancesST(value : String);
    Procedure SetAvailability(value : TFhirEnum);
    Function GetAvailabilityST : TFhirInstanceAvailabilityEnum;
    Procedure SetAvailabilityST(value : TFhirInstanceAvailabilityEnum);
    Procedure SetUrl(value : TFhirUri);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);
    Procedure SetBodySite(value : TFhirCoding);
    Procedure SetLaterality(value : TFhirCoding);
    Procedure SetStarted(value : TFhirDateTime);
    Function GetStartedST : TFslDateTime;
    Procedure SetStartedST(value : TFslDateTime);
    function GetInstanceList : TFhirImagingStudySeriesInstanceList;
    function GetHasInstanceList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImagingStudySeries; overload;
    function Clone : TFhirImagingStudySeries; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The Numeric identifier of this series in the study.
    property number : String read GetNumberST write SetNumberST;
    // The Numeric identifier of this series in the study.
    property numberElement : TFhirUnsignedInt read FNumber write SetNumber;

    // Typed access to The modality of this series sequence. (defined for API consistency)
    property modality : TFhirCoding read FModality write SetModality;
    // The modality of this series sequence.
    property modalityElement : TFhirCoding read FModality write SetModality;

    // Typed access to Formal identifier for this series.
    property uid : String read GetUidST write SetUidST;
    // Formal identifier for this series.
    property uidElement : TFhirOid read FUid write SetUid;

    // Typed access to A description of the series.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A description of the series.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Number of SOP Instances in Series.
    property numberOfInstances : String read GetNumberOfInstancesST write SetNumberOfInstancesST;
    // Number of SOP Instances in Series.
    property numberOfInstancesElement : TFhirUnsignedInt read FNumberOfInstances write SetNumberOfInstances;

    // Availability of series (online, offline or nearline).
    property availability : TFhirInstanceAvailabilityEnum read GetAvailabilityST write SetAvailabilityST;
    property availabilityElement : TFhirEnum read FAvailability write SetAvailability;

    // Typed access to URI/URL specifying the location of the referenced series using WADO-RS.
    property url : String read GetUrlST write SetUrlST;
    // URI/URL specifying the location of the referenced series using WADO-RS.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to Body part examined. See  DICOM Part 16 Annex L for the mapping from DICOM to Snomed CT. (defined for API consistency)
    property bodySite : TFhirCoding read FBodySite write SetBodySite;
    // Body part examined. See  DICOM Part 16 Annex L for the mapping from DICOM to Snomed CT.
    property bodySiteElement : TFhirCoding read FBodySite write SetBodySite;

    // Typed access to Laterality if body site is paired anatomic structure and laterality is not pre-coordinated in body site code. (defined for API consistency)
    property laterality : TFhirCoding read FLaterality write SetLaterality;
    // Laterality if body site is paired anatomic structure and laterality is not pre-coordinated in body site code.
    property lateralityElement : TFhirCoding read FLaterality write SetLaterality;

    // Typed access to The date and time the series was started.
    property started : TFslDateTime read GetStartedST write SetStartedST;
    // The date and time the series was started.
    property startedElement : TFhirDateTime read FStarted write SetStarted;

    // A single SOP Instance within the series, e.g. an image, or presentation state.
    property instanceList : TFhirImagingStudySeriesInstanceList read GetInstanceList;
    property hasInstanceList : boolean read GetHasInstanceList;

  end;

  TFhirImagingStudySeriesListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImagingStudySeriesList;
    function GetCurrent : TFhirImagingStudySeries;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImagingStudySeriesList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImagingStudySeries read GetCurrent;
  end;

  TFhirImagingStudySeriesList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImagingStudySeries;
    procedure SetItemN(index : Integer; value : TFhirImagingStudySeries);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImagingStudySeriesList; Overload;
    function Clone : TFhirImagingStudySeriesList; Overload;
    function GetEnumerator : TFhirImagingStudySeriesListEnumerator;

    //  Add a FhirImagingStudySeries to the end of the list.
    function Append : TFhirImagingStudySeries;

    // Add an already existing FhirImagingStudySeries to the end of the list.
    procedure AddItem(value : TFhirImagingStudySeries); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImagingStudySeries) : Integer;

    // Insert FhirImagingStudySeries before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImagingStudySeries;

    // Insert an existing FhirImagingStudySeries before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImagingStudySeries);

    // Get the iIndexth FhirImagingStudySeries. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImagingStudySeries);

    // The number of items in the collection
    function Item(index : Integer) : TFhirImagingStudySeries;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirImagingStudySeries[index : Integer] : TFhirImagingStudySeries read GetItemN write SetItemN; default;
  End;

  // A single SOP Instance within the series, e.g. an image, or presentation state.
  TFhirImagingStudySeriesInstance = class (TFhirBackboneElement)
  protected
    FNumber : TFhirUnsignedInt;
    FUid : TFhirOid;
    FSopClass : TFhirOid;
    FType_ : TFhirString;
    FTitle : TFhirString;
    FcontentList : TFhirAttachmentList;
    Procedure SetNumber(value : TFhirUnsignedInt);
    Function GetNumberST : String;
    Procedure SetNumberST(value : String);
    Procedure SetUid(value : TFhirOid);
    Function GetUidST : String;
    Procedure SetUidST(value : String);
    Procedure SetSopClass(value : TFhirOid);
    Function GetSopClassST : String;
    Procedure SetSopClassST(value : String);
    Procedure SetType_(value : TFhirString);
    Function GetType_ST : String;
    Procedure SetType_ST(value : String);
    Procedure SetTitle(value : TFhirString);
    Function GetTitleST : String;
    Procedure SetTitleST(value : String);
    function GetContentList : TFhirAttachmentList;
    function GetHasContentList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImagingStudySeriesInstance; overload;
    function Clone : TFhirImagingStudySeriesInstance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The number of instance in the series.
    property number : String read GetNumberST write SetNumberST;
    // The number of instance in the series.
    property numberElement : TFhirUnsignedInt read FNumber write SetNumber;

    // Typed access to Formal identifier for this image or other content.
    property uid : String read GetUidST write SetUidST;
    // Formal identifier for this image or other content.
    property uidElement : TFhirOid read FUid write SetUid;

    // Typed access to DICOM instance  type.
    property sopClass : String read GetSopClassST write SetSopClassST;
    // DICOM instance  type.
    property sopClassElement : TFhirOid read FSopClass write SetSopClass;

    // Typed access to A human-friendly SOP Class name.
    property type_ : String read GetType_ST write SetType_ST;
    // A human-friendly SOP Class name.
    property type_Element : TFhirString read FType_ write SetType_;

    // Typed access to The description of the instance.
    property title : String read GetTitleST write SetTitleST;
    // The description of the instance.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Content of the instance or a rendering thereof (e.g. a JPEG of an image, or an XML of a structured report). May be represented for example by inline encoding; by a URL reference to a WADO-RS service that makes the instance available; or to a FHIR Resource (e.g. Media, Document, etc.). Multiple content attachments may be used for alternate representations of the instance.
    property contentList : TFhirAttachmentList read GetContentList;
    property hasContentList : boolean read GetHasContentList;

  end;

  TFhirImagingStudySeriesInstanceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImagingStudySeriesInstanceList;
    function GetCurrent : TFhirImagingStudySeriesInstance;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImagingStudySeriesInstanceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImagingStudySeriesInstance read GetCurrent;
  end;

  TFhirImagingStudySeriesInstanceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImagingStudySeriesInstance;
    procedure SetItemN(index : Integer; value : TFhirImagingStudySeriesInstance);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImagingStudySeriesInstanceList; Overload;
    function Clone : TFhirImagingStudySeriesInstanceList; Overload;
    function GetEnumerator : TFhirImagingStudySeriesInstanceListEnumerator;

    //  Add a FhirImagingStudySeriesInstance to the end of the list.
    function Append : TFhirImagingStudySeriesInstance;

    // Add an already existing FhirImagingStudySeriesInstance to the end of the list.
    procedure AddItem(value : TFhirImagingStudySeriesInstance); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImagingStudySeriesInstance) : Integer;

    // Insert FhirImagingStudySeriesInstance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImagingStudySeriesInstance;

    // Insert an existing FhirImagingStudySeriesInstance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImagingStudySeriesInstance);

    // Get the iIndexth FhirImagingStudySeriesInstance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImagingStudySeriesInstance);

    // The number of items in the collection
    function Item(index : Integer) : TFhirImagingStudySeriesInstance;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirImagingStudySeriesInstances[index : Integer] : TFhirImagingStudySeriesInstance read GetItemN write SetItemN; default;
  End;

  // Representation of the content produced in a DICOM imaging study. A study comprises a set of series, each of which includes a set of Service-Object Pair Instances (SOP Instances - images or other data) acquired or produced in a common context.  A series is of only one modality (e.g. X-ray, CT, MR, ultrasound), but a study may have multiple series of different modalities.
  TFhirImagingStudy = class (TFhirDomainResource)
  protected
    FStarted : TFhirDateTime;
    FPatient : TFhirReference{TFhirPatient};
    FUid : TFhirOid;
    FAccession : TFhirIdentifier;
    FidentifierList : TFhirIdentifierList;
    ForderList : TFhirReferenceList{TFhirDiagnosticOrder};
    FmodalityListList : TFhirCodingList;
    FReferrer : TFhirReference{TFhirPractitioner};
    FAvailability : TFhirEnum;
    FUrl : TFhirUri;
    FNumberOfSeries : TFhirUnsignedInt;
    FNumberOfInstances : TFhirUnsignedInt;
    Fprocedure_List : TFhirReferenceList{TFhirProcedure};
    FInterpreter : TFhirReference{TFhirPractitioner};
    FDescription : TFhirString;
    FseriesList : TFhirImagingStudySeriesList;
    Procedure SetStarted(value : TFhirDateTime);
    Function GetStartedST : TFslDateTime;
    Procedure SetStartedST(value : TFslDateTime);
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    Procedure SetUid(value : TFhirOid);
    Function GetUidST : String;
    Procedure SetUidST(value : String);
    Procedure SetAccession(value : TFhirIdentifier);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetOrderList : TFhirReferenceList{TFhirDiagnosticOrder};
    function GetHasOrderList : Boolean;
    function GetModalityListList : TFhirCodingList;
    function GetHasModalityListList : Boolean;
    Procedure SetReferrer(value : TFhirReference{TFhirPractitioner});
    Procedure SetAvailability(value : TFhirEnum);
    Function GetAvailabilityST : TFhirInstanceAvailabilityEnum;
    Procedure SetAvailabilityST(value : TFhirInstanceAvailabilityEnum);
    Procedure SetUrl(value : TFhirUri);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);
    Procedure SetNumberOfSeries(value : TFhirUnsignedInt);
    Function GetNumberOfSeriesST : String;
    Procedure SetNumberOfSeriesST(value : String);
    Procedure SetNumberOfInstances(value : TFhirUnsignedInt);
    Function GetNumberOfInstancesST : String;
    Procedure SetNumberOfInstancesST(value : String);
    function GetProcedure_List : TFhirReferenceList{TFhirProcedure};
    function GetHasProcedure_List : Boolean;
    Procedure SetInterpreter(value : TFhirReference{TFhirPractitioner});
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    function GetSeriesList : TFhirImagingStudySeriesList;
    function GetHasSeriesList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImagingStudy; overload;
    function Clone : TFhirImagingStudy; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Date and Time the study started.
    property started : TFslDateTime read GetStartedST write SetStartedST;
    // Date and Time the study started.
    property startedElement : TFhirDateTime read FStarted write SetStarted;

    // Typed access to The patient imaged in the study. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // The patient imaged in the study.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Typed access to Formal identifier for the study.
    property uid : String read GetUidST write SetUidST;
    // Formal identifier for the study.
    property uidElement : TFhirOid read FUid write SetUid;

    // Typed access to Accession Number is an identifier related to some aspect of imaging workflow and data management. Usage may vary across different institutions.  See for instance [IHE Radiology Technical Framework Volume 1 Appendix A](http://www.ihe.net/uploadedFiles/Documents/Radiology/IHE_RAD_TF_Rev13.0_Vol1_FT_2014-07-30.pdf). (defined for API consistency)
    property accession : TFhirIdentifier read FAccession write SetAccession;
    // Accession Number is an identifier related to some aspect of imaging workflow and data management. Usage may vary across different institutions.  See for instance [IHE Radiology Technical Framework Volume 1 Appendix A](http://www.ihe.net/uploadedFiles/Documents/Radiology/IHE_RAD_TF_Rev13.0_Vol1_FT_2014-07-30.pdf).
    property accessionElement : TFhirIdentifier read FAccession write SetAccession;

    // Other identifiers for the study.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A list of the diagnostic orders that resulted in this imaging study being performed.
    property orderList : TFhirReferenceList{TFhirDiagnosticOrder} read GetOrderList;
    property hasOrderList : boolean read GetHasOrderList;

    // A list of all the Series.ImageModality values that are actual acquisition modalities, i.e. those in the DICOM Context Group 29 (value set OID 1.2.840.10008.6.1.19).
    property modalityListList : TFhirCodingList read GetModalityListList;
    property hasModalityListList : boolean read GetHasModalityListList;

    // Typed access to The requesting/referring physician. (defined for API consistency)
    property referrer : TFhirReference{TFhirPractitioner} read FReferrer write SetReferrer;
    // The requesting/referring physician.
    property referrerElement : TFhirReference{TFhirPractitioner} read FReferrer write SetReferrer;

    // Availability of study (online, offline or nearline).
    property availability : TFhirInstanceAvailabilityEnum read GetAvailabilityST write SetAvailabilityST;
    property availabilityElement : TFhirEnum read FAvailability write SetAvailability;

    // Typed access to WADO-RS resource where Study is available.
    property url : String read GetUrlST write SetUrlST;
    // WADO-RS resource where Study is available.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to Number of Series in Study.
    property numberOfSeries : String read GetNumberOfSeriesST write SetNumberOfSeriesST;
    // Number of Series in Study.
    property numberOfSeriesElement : TFhirUnsignedInt read FNumberOfSeries write SetNumberOfSeries;

    // Typed access to Number of SOP Instances in Study.
    property numberOfInstances : String read GetNumberOfInstancesST write SetNumberOfInstancesST;
    // Number of SOP Instances in Study.
    property numberOfInstancesElement : TFhirUnsignedInt read FNumberOfInstances write SetNumberOfInstances;

    // Type of procedure performed.
    property procedure_List : TFhirReferenceList{TFhirProcedure} read GetProcedure_List;
    property hasProcedure_List : boolean read GetHasProcedure_List;

    // Typed access to Who read the study and interpreted the images or other content. (defined for API consistency)
    property interpreter : TFhirReference{TFhirPractitioner} read FInterpreter write SetInterpreter;
    // Who read the study and interpreted the images or other content.
    property interpreterElement : TFhirReference{TFhirPractitioner} read FInterpreter write SetInterpreter;

    // Typed access to Institution-generated description or classification of the Study performed.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Institution-generated description or classification of the Study performed.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Each study has one or more series of images or other content.
    property seriesList : TFhirImagingStudySeriesList read GetSeriesList;
    property hasSeriesList : boolean read GetHasSeriesList;

  end;

  TFhirImagingStudyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImagingStudyList;
    function GetCurrent : TFhirImagingStudy;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImagingStudyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImagingStudy read GetCurrent;
  end;

  TFhirImagingStudyList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImagingStudy;
    procedure SetItemN(index : Integer; value : TFhirImagingStudy);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImagingStudyList; Overload;
    function Clone : TFhirImagingStudyList; Overload;
    function GetEnumerator : TFhirImagingStudyListEnumerator;

    //  Add a FhirImagingStudy to the end of the list.
    function Append : TFhirImagingStudy;

    // Add an already existing FhirImagingStudy to the end of the list.
    procedure AddItem(value : TFhirImagingStudy); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImagingStudy) : Integer;

    // Insert FhirImagingStudy before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImagingStudy;

    // Insert an existing FhirImagingStudy before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImagingStudy);

    // Get the iIndexth FhirImagingStudy. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImagingStudy);

    // The number of items in the collection
    function Item(index : Integer) : TFhirImagingStudy;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirImagingStudies[index : Integer] : TFhirImagingStudy read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_IMAGINGSTUDY}

{$IFDEF FHIR_IMMUNIZATION}

  // Reasons why a vaccine was or was not administered.
  TFhirImmunizationExplanation = class (TFhirBackboneElement)
  protected
    FreasonList : TFhirCodeableConceptList;
    FreasonNotGivenList : TFhirCodeableConceptList;
    function GetReasonList : TFhirCodeableConceptList;
    function GetHasReasonList : Boolean;
    function GetReasonNotGivenList : TFhirCodeableConceptList;
    function GetHasReasonNotGivenList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImmunizationExplanation; overload;
    function Clone : TFhirImmunizationExplanation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Reasons why a vaccine was administered.
    property reasonList : TFhirCodeableConceptList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // Reason why a vaccine was not administered.
    property reasonNotGivenList : TFhirCodeableConceptList read GetReasonNotGivenList;
    property hasReasonNotGivenList : boolean read GetHasReasonNotGivenList;

  end;

  TFhirImmunizationExplanationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImmunizationExplanationList;
    function GetCurrent : TFhirImmunizationExplanation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImmunizationExplanationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImmunizationExplanation read GetCurrent;
  end;

  TFhirImmunizationExplanationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImmunizationExplanation;
    procedure SetItemN(index : Integer; value : TFhirImmunizationExplanation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImmunizationExplanationList; Overload;
    function Clone : TFhirImmunizationExplanationList; Overload;
    function GetEnumerator : TFhirImmunizationExplanationListEnumerator;

    //  Add a FhirImmunizationExplanation to the end of the list.
    function Append : TFhirImmunizationExplanation;

    // Add an already existing FhirImmunizationExplanation to the end of the list.
    procedure AddItem(value : TFhirImmunizationExplanation); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImmunizationExplanation) : Integer;

    // Insert FhirImmunizationExplanation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImmunizationExplanation;

    // Insert an existing FhirImmunizationExplanation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImmunizationExplanation);

    // Get the iIndexth FhirImmunizationExplanation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationExplanation);

    // The number of items in the collection
    function Item(index : Integer) : TFhirImmunizationExplanation;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirImmunizationExplanations[index : Integer] : TFhirImmunizationExplanation read GetItemN write SetItemN; default;
  End;

  // Categorical data indicating that an adverse event is associated in time to an immunization.
  TFhirImmunizationReaction = class (TFhirBackboneElement)
  protected
    FDate : TFhirDateTime;
    FDetail : TFhirReference{TFhirObservation};
    FReported : TFhirBoolean;
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetDetail(value : TFhirReference{TFhirObservation});
    Procedure SetReported(value : TFhirBoolean);
    Function GetReportedST : Boolean;
    Procedure SetReportedST(value : Boolean);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImmunizationReaction; overload;
    function Clone : TFhirImmunizationReaction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Date of reaction to the immunization.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Date of reaction to the immunization.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to Details of the reaction. (defined for API consistency)
    property detail : TFhirReference{TFhirObservation} read FDetail write SetDetail;
    // Details of the reaction.
    property detailElement : TFhirReference{TFhirObservation} read FDetail write SetDetail;

    // Typed access to Self-reported indicator.
    property reported : Boolean read GetReportedST write SetReportedST;
    // Self-reported indicator.
    property reportedElement : TFhirBoolean read FReported write SetReported;

  end;

  TFhirImmunizationReactionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImmunizationReactionList;
    function GetCurrent : TFhirImmunizationReaction;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImmunizationReactionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImmunizationReaction read GetCurrent;
  end;

  TFhirImmunizationReactionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImmunizationReaction;
    procedure SetItemN(index : Integer; value : TFhirImmunizationReaction);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImmunizationReactionList; Overload;
    function Clone : TFhirImmunizationReactionList; Overload;
    function GetEnumerator : TFhirImmunizationReactionListEnumerator;

    //  Add a FhirImmunizationReaction to the end of the list.
    function Append : TFhirImmunizationReaction;

    // Add an already existing FhirImmunizationReaction to the end of the list.
    procedure AddItem(value : TFhirImmunizationReaction); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImmunizationReaction) : Integer;

    // Insert FhirImmunizationReaction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImmunizationReaction;

    // Insert an existing FhirImmunizationReaction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImmunizationReaction);

    // Get the iIndexth FhirImmunizationReaction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationReaction);

    // The number of items in the collection
    function Item(index : Integer) : TFhirImmunizationReaction;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirImmunizationReactions[index : Integer] : TFhirImmunizationReaction read GetItemN write SetItemN; default;
  End;

  // Contains information about the protocol(s) under which the vaccine was administered.
  TFhirImmunizationVaccinationProtocol = class (TFhirBackboneElement)
  protected
    FDoseSequence : TFhirPositiveInt;
    FDescription : TFhirString;
    FAuthority : TFhirReference{TFhirOrganization};
    FSeries : TFhirString;
    FSeriesDoses : TFhirPositiveInt;
    FtargetDiseaseList : TFhirCodeableConceptList;
    FDoseStatus : TFhirCodeableConcept;
    FDoseStatusReason : TFhirCodeableConcept;
    Procedure SetDoseSequence(value : TFhirPositiveInt);
    Function GetDoseSequenceST : String;
    Procedure SetDoseSequenceST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetAuthority(value : TFhirReference{TFhirOrganization});
    Procedure SetSeries(value : TFhirString);
    Function GetSeriesST : String;
    Procedure SetSeriesST(value : String);
    Procedure SetSeriesDoses(value : TFhirPositiveInt);
    Function GetSeriesDosesST : String;
    Procedure SetSeriesDosesST(value : String);
    function GetTargetDiseaseList : TFhirCodeableConceptList;
    function GetHasTargetDiseaseList : Boolean;
    Procedure SetDoseStatus(value : TFhirCodeableConcept);
    Procedure SetDoseStatusReason(value : TFhirCodeableConcept);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImmunizationVaccinationProtocol; overload;
    function Clone : TFhirImmunizationVaccinationProtocol; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Nominal position in a series.
    property doseSequence : String read GetDoseSequenceST write SetDoseSequenceST;
    // Nominal position in a series.
    property doseSequenceElement : TFhirPositiveInt read FDoseSequence write SetDoseSequence;

    // Typed access to Contains the description about the protocol under which the vaccine was administered.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Contains the description about the protocol under which the vaccine was administered.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Indicates the authority who {$IFNDEF FPC}published{$ENDIF} the protocol.  E.g. ACIP. (defined for API consistency)
    property authority : TFhirReference{TFhirOrganization} read FAuthority write SetAuthority;
    // Indicates the authority who {$IFNDEF FPC}published{$ENDIF} the protocol.  E.g. ACIP.
    property authorityElement : TFhirReference{TFhirOrganization} read FAuthority write SetAuthority;

    // Typed access to One possible path to achieve presumed immunity against a disease - within the context of an authority.
    property series : String read GetSeriesST write SetSeriesST;
    // One possible path to achieve presumed immunity against a disease - within the context of an authority.
    property seriesElement : TFhirString read FSeries write SetSeries;

    // Typed access to The recommended number of doses to achieve immunity.
    property seriesDoses : String read GetSeriesDosesST write SetSeriesDosesST;
    // The recommended number of doses to achieve immunity.
    property seriesDosesElement : TFhirPositiveInt read FSeriesDoses write SetSeriesDoses;

    // The targeted disease.
    property targetDiseaseList : TFhirCodeableConceptList read GetTargetDiseaseList;
    property hasTargetDiseaseList : boolean read GetHasTargetDiseaseList;

    // Typed access to Indicates if the immunization event should "count" against  the protocol. (defined for API consistency)
    property doseStatus : TFhirCodeableConcept read FDoseStatus write SetDoseStatus;
    // Indicates if the immunization event should "count" against  the protocol.
    property doseStatusElement : TFhirCodeableConcept read FDoseStatus write SetDoseStatus;

    // Typed access to Provides an explanation as to why an immunization event should or should not count against the protocol. (defined for API consistency)
    property doseStatusReason : TFhirCodeableConcept read FDoseStatusReason write SetDoseStatusReason;
    // Provides an explanation as to why an immunization event should or should not count against the protocol.
    property doseStatusReasonElement : TFhirCodeableConcept read FDoseStatusReason write SetDoseStatusReason;

  end;

  TFhirImmunizationVaccinationProtocolListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImmunizationVaccinationProtocolList;
    function GetCurrent : TFhirImmunizationVaccinationProtocol;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImmunizationVaccinationProtocolList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImmunizationVaccinationProtocol read GetCurrent;
  end;

  TFhirImmunizationVaccinationProtocolList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImmunizationVaccinationProtocol;
    procedure SetItemN(index : Integer; value : TFhirImmunizationVaccinationProtocol);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImmunizationVaccinationProtocolList; Overload;
    function Clone : TFhirImmunizationVaccinationProtocolList; Overload;
    function GetEnumerator : TFhirImmunizationVaccinationProtocolListEnumerator;

    //  Add a FhirImmunizationVaccinationProtocol to the end of the list.
    function Append : TFhirImmunizationVaccinationProtocol;

    // Add an already existing FhirImmunizationVaccinationProtocol to the end of the list.
    procedure AddItem(value : TFhirImmunizationVaccinationProtocol); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImmunizationVaccinationProtocol) : Integer;

    // Insert FhirImmunizationVaccinationProtocol before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImmunizationVaccinationProtocol;

    // Insert an existing FhirImmunizationVaccinationProtocol before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImmunizationVaccinationProtocol);

    // Get the iIndexth FhirImmunizationVaccinationProtocol. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationVaccinationProtocol);

    // The number of items in the collection
    function Item(index : Integer) : TFhirImmunizationVaccinationProtocol;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirImmunizationVaccinationProtocols[index : Integer] : TFhirImmunizationVaccinationProtocol read GetItemN write SetItemN; default;
  End;

  // Describes the event of a patient being administered a vaccination or a record of a vaccination as reported by a patient, a clinician or another party and may include vaccine reaction information and what vaccination protocol was followed.
  TFhirImmunization = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FDate : TFhirDateTime;
    FVaccineCode : TFhirCodeableConcept;
    FPatient : TFhirReference{TFhirPatient};
    FWasNotGiven : TFhirBoolean;
    FReported : TFhirBoolean;
    FPerformer : TFhirReference{TFhirPractitioner};
    FRequester : TFhirReference{TFhirPractitioner};
    FEncounter : TFhirReference{TFhirEncounter};
    FManufacturer : TFhirReference{TFhirOrganization};
    FLocation : TFhirReference{TFhirLocation};
    FLotNumber : TFhirString;
    FExpirationDate : TFhirDate;
    FSite : TFhirCodeableConcept;
    FRoute : TFhirCodeableConcept;
    FDoseQuantity : TFhirQuantity;
    FnoteList : TFhirAnnotationList;
    FExplanation : TFhirImmunizationExplanation;
    FreactionList : TFhirImmunizationReactionList;
    FvaccinationProtocolList : TFhirImmunizationVaccinationProtocolList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirMedicationAdminStatusEnum;
    Procedure SetStatusST(value : TFhirMedicationAdminStatusEnum);
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetVaccineCode(value : TFhirCodeableConcept);
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    Procedure SetWasNotGiven(value : TFhirBoolean);
    Function GetWasNotGivenST : Boolean;
    Procedure SetWasNotGivenST(value : Boolean);
    Procedure SetReported(value : TFhirBoolean);
    Function GetReportedST : Boolean;
    Procedure SetReportedST(value : Boolean);
    Procedure SetPerformer(value : TFhirReference{TFhirPractitioner});
    Procedure SetRequester(value : TFhirReference{TFhirPractitioner});
    Procedure SetEncounter(value : TFhirReference{TFhirEncounter});
    Procedure SetManufacturer(value : TFhirReference{TFhirOrganization});
    Procedure SetLocation(value : TFhirReference{TFhirLocation});
    Procedure SetLotNumber(value : TFhirString);
    Function GetLotNumberST : String;
    Procedure SetLotNumberST(value : String);
    Procedure SetExpirationDate(value : TFhirDate);
    Function GetExpirationDateST : TFslDateTime;
    Procedure SetExpirationDateST(value : TFslDateTime);
    Procedure SetSite(value : TFhirCodeableConcept);
    Procedure SetRoute(value : TFhirCodeableConcept);
    Procedure SetDoseQuantity(value : TFhirQuantity);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    Procedure SetExplanation(value : TFhirImmunizationExplanation);
    function GetReactionList : TFhirImmunizationReactionList;
    function GetHasReactionList : Boolean;
    function GetVaccinationProtocolList : TFhirImmunizationVaccinationProtocolList;
    function GetHasVaccinationProtocolList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImmunization; overload;
    function Clone : TFhirImmunization; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A unique identifier assigned to this immunization record.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Indicates the current status of the vaccination event.
    property status : TFhirMedicationAdminStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Date vaccine administered or was to be administered.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Date vaccine administered or was to be administered.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to Vaccine that was administered or was to be administered. (defined for API consistency)
    property vaccineCode : TFhirCodeableConcept read FVaccineCode write SetVaccineCode;
    // Vaccine that was administered or was to be administered.
    property vaccineCodeElement : TFhirCodeableConcept read FVaccineCode write SetVaccineCode;

    // Typed access to The patient who either received or did not receive the immunization. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // The patient who either received or did not receive the immunization.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Typed access to Indicates if the vaccination was or was not given.
    property wasNotGiven : Boolean read GetWasNotGivenST write SetWasNotGivenST;
    // Indicates if the vaccination was or was not given.
    property wasNotGivenElement : TFhirBoolean read FWasNotGiven write SetWasNotGiven;

    // Typed access to True if this administration was reported rather than directly administered.
    property reported : Boolean read GetReportedST write SetReportedST;
    // True if this administration was reported rather than directly administered.
    property reportedElement : TFhirBoolean read FReported write SetReported;

    // Typed access to Clinician who administered the vaccine. (defined for API consistency)
    property performer : TFhirReference{TFhirPractitioner} read FPerformer write SetPerformer;
    // Clinician who administered the vaccine.
    property performerElement : TFhirReference{TFhirPractitioner} read FPerformer write SetPerformer;

    // Typed access to Clinician who ordered the vaccination. (defined for API consistency)
    property requester : TFhirReference{TFhirPractitioner} read FRequester write SetRequester;
    // Clinician who ordered the vaccination.
    property requesterElement : TFhirReference{TFhirPractitioner} read FRequester write SetRequester;

    // Typed access to The visit or admission or other contact between patient and health care provider the immunization was performed as part of. (defined for API consistency)
    property encounter : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;
    // The visit or admission or other contact between patient and health care provider the immunization was performed as part of.
    property encounterElement : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;

    // Typed access to Name of vaccine manufacturer. (defined for API consistency)
    property manufacturer : TFhirReference{TFhirOrganization} read FManufacturer write SetManufacturer;
    // Name of vaccine manufacturer.
    property manufacturerElement : TFhirReference{TFhirOrganization} read FManufacturer write SetManufacturer;

    // Typed access to The service delivery location where the vaccine administration occurred. (defined for API consistency)
    property location : TFhirReference{TFhirLocation} read FLocation write SetLocation;
    // The service delivery location where the vaccine administration occurred.
    property locationElement : TFhirReference{TFhirLocation} read FLocation write SetLocation;

    // Typed access to Lot number of the  vaccine product.
    property lotNumber : String read GetLotNumberST write SetLotNumberST;
    // Lot number of the  vaccine product.
    property lotNumberElement : TFhirString read FLotNumber write SetLotNumber;

    // Typed access to Date vaccine batch expires.
    property expirationDate : TFslDateTime read GetExpirationDateST write SetExpirationDateST;
    // Date vaccine batch expires.
    property expirationDateElement : TFhirDate read FExpirationDate write SetExpirationDate;

    // Typed access to Body site where vaccine was administered. (defined for API consistency)
    property site : TFhirCodeableConcept read FSite write SetSite;
    // Body site where vaccine was administered.
    property siteElement : TFhirCodeableConcept read FSite write SetSite;

    // Typed access to The path by which the vaccine product is taken into the body. (defined for API consistency)
    property route : TFhirCodeableConcept read FRoute write SetRoute;
    // The path by which the vaccine product is taken into the body.
    property routeElement : TFhirCodeableConcept read FRoute write SetRoute;

    // Typed access to The quantity of vaccine product that was administered. (defined for API consistency)
    property doseQuantity : TFhirQuantity read FDoseQuantity write SetDoseQuantity;
    // The quantity of vaccine product that was administered.
    property doseQuantityElement : TFhirQuantity read FDoseQuantity write SetDoseQuantity;

    // Extra information about the immunization that is not conveyed by the other attributes.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Typed access to Reasons why a vaccine was or was not administered. (defined for API consistency)
    property explanation : TFhirImmunizationExplanation read FExplanation write SetExplanation;
    // Reasons why a vaccine was or was not administered.
    property explanationElement : TFhirImmunizationExplanation read FExplanation write SetExplanation;

    // Categorical data indicating that an adverse event is associated in time to an immunization.
    property reactionList : TFhirImmunizationReactionList read GetReactionList;
    property hasReactionList : boolean read GetHasReactionList;

    // Contains information about the protocol(s) under which the vaccine was administered.
    property vaccinationProtocolList : TFhirImmunizationVaccinationProtocolList read GetVaccinationProtocolList;
    property hasVaccinationProtocolList : boolean read GetHasVaccinationProtocolList;

  end;

  TFhirImmunizationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImmunizationList;
    function GetCurrent : TFhirImmunization;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImmunizationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImmunization read GetCurrent;
  end;

  TFhirImmunizationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImmunization;
    procedure SetItemN(index : Integer; value : TFhirImmunization);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImmunizationList; Overload;
    function Clone : TFhirImmunizationList; Overload;
    function GetEnumerator : TFhirImmunizationListEnumerator;

    //  Add a FhirImmunization to the end of the list.
    function Append : TFhirImmunization;

    // Add an already existing FhirImmunization to the end of the list.
    procedure AddItem(value : TFhirImmunization); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImmunization) : Integer;

    // Insert FhirImmunization before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImmunization;

    // Insert an existing FhirImmunization before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImmunization);

    // Get the iIndexth FhirImmunization. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImmunization);

    // The number of items in the collection
    function Item(index : Integer) : TFhirImmunization;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirImmunizations[index : Integer] : TFhirImmunization read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_IMMUNIZATION}

{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}

  // Vaccine administration recommendations.
  TFhirImmunizationRecommendationRecommendation = class (TFhirBackboneElement)
  protected
    FDate : TFhirDateTime;
    FVaccineCode : TFhirCodeableConcept;
    FDoseNumber : TFhirPositiveInt;
    FForecastStatus : TFhirCodeableConcept;
    FdateCriterionList : TFhirImmunizationRecommendationRecommendationDateCriterionList;
    FProtocol : TFhirImmunizationRecommendationRecommendationProtocol;
    FsupportingImmunizationList : TFhirReferenceList{TFhirImmunization};
    FsupportingPatientInformationList : TFhirReferenceList{Resource};
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetVaccineCode(value : TFhirCodeableConcept);
    Procedure SetDoseNumber(value : TFhirPositiveInt);
    Function GetDoseNumberST : String;
    Procedure SetDoseNumberST(value : String);
    Procedure SetForecastStatus(value : TFhirCodeableConcept);
    function GetDateCriterionList : TFhirImmunizationRecommendationRecommendationDateCriterionList;
    function GetHasDateCriterionList : Boolean;
    Procedure SetProtocol(value : TFhirImmunizationRecommendationRecommendationProtocol);
    function GetSupportingImmunizationList : TFhirReferenceList{TFhirImmunization};
    function GetHasSupportingImmunizationList : Boolean;
    function GetSupportingPatientInformationList : TFhirReferenceList{Resource};
    function GetHasSupportingPatientInformationList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImmunizationRecommendationRecommendation; overload;
    function Clone : TFhirImmunizationRecommendationRecommendation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The date the immunization recommendation was created.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date the immunization recommendation was created.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to Vaccine that pertains to the recommendation. (defined for API consistency)
    property vaccineCode : TFhirCodeableConcept read FVaccineCode write SetVaccineCode;
    // Vaccine that pertains to the recommendation.
    property vaccineCodeElement : TFhirCodeableConcept read FVaccineCode write SetVaccineCode;

    // Typed access to This indicates the next recommended dose number (e.g. dose 2 is the next recommended dose).
    property doseNumber : String read GetDoseNumberST write SetDoseNumberST;
    // This indicates the next recommended dose number (e.g. dose 2 is the next recommended dose).
    property doseNumberElement : TFhirPositiveInt read FDoseNumber write SetDoseNumber;

    // Typed access to Vaccine administration status. (defined for API consistency)
    property forecastStatus : TFhirCodeableConcept read FForecastStatus write SetForecastStatus;
    // Vaccine administration status.
    property forecastStatusElement : TFhirCodeableConcept read FForecastStatus write SetForecastStatus;

    // Vaccine date recommendations.  For example, earliest date to administer, latest date to administer, etc.
    property dateCriterionList : TFhirImmunizationRecommendationRecommendationDateCriterionList read GetDateCriterionList;
    property hasDateCriterionList : boolean read GetHasDateCriterionList;

    // Typed access to Contains information about the protocol under which the vaccine was administered. (defined for API consistency)
    property protocol : TFhirImmunizationRecommendationRecommendationProtocol read FProtocol write SetProtocol;
    // Contains information about the protocol under which the vaccine was administered.
    property protocolElement : TFhirImmunizationRecommendationRecommendationProtocol read FProtocol write SetProtocol;

    // Immunization event history that supports the status and recommendation.
    property supportingImmunizationList : TFhirReferenceList{TFhirImmunization} read GetSupportingImmunizationList;
    property hasSupportingImmunizationList : boolean read GetHasSupportingImmunizationList;

    // Patient Information that supports the status and recommendation.  This includes patient observations, adverse reactions and allergy/intolerance information.
    property supportingPatientInformationList : TFhirReferenceList{Resource} read GetSupportingPatientInformationList;
    property hasSupportingPatientInformationList : boolean read GetHasSupportingPatientInformationList;

  end;

  TFhirImmunizationRecommendationRecommendationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImmunizationRecommendationRecommendationList;
    function GetCurrent : TFhirImmunizationRecommendationRecommendation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImmunizationRecommendationRecommendationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImmunizationRecommendationRecommendation read GetCurrent;
  end;

  TFhirImmunizationRecommendationRecommendationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImmunizationRecommendationRecommendation;
    procedure SetItemN(index : Integer; value : TFhirImmunizationRecommendationRecommendation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImmunizationRecommendationRecommendationList; Overload;
    function Clone : TFhirImmunizationRecommendationRecommendationList; Overload;
    function GetEnumerator : TFhirImmunizationRecommendationRecommendationListEnumerator;

    //  Add a FhirImmunizationRecommendationRecommendation to the end of the list.
    function Append : TFhirImmunizationRecommendationRecommendation;

    // Add an already existing FhirImmunizationRecommendationRecommendation to the end of the list.
    procedure AddItem(value : TFhirImmunizationRecommendationRecommendation); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImmunizationRecommendationRecommendation) : Integer;

    // Insert FhirImmunizationRecommendationRecommendation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImmunizationRecommendationRecommendation;

    // Insert an existing FhirImmunizationRecommendationRecommendation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImmunizationRecommendationRecommendation);

    // Get the iIndexth FhirImmunizationRecommendationRecommendation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationRecommendationRecommendation);

    // The number of items in the collection
    function Item(index : Integer) : TFhirImmunizationRecommendationRecommendation;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirImmunizationRecommendationRecommendations[index : Integer] : TFhirImmunizationRecommendationRecommendation read GetItemN write SetItemN; default;
  End;

  // Vaccine date recommendations.  For example, earliest date to administer, latest date to administer, etc.
  TFhirImmunizationRecommendationRecommendationDateCriterion = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FValue : TFhirDateTime;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetValue(value : TFhirDateTime);
    Function GetValueST : TFslDateTime;
    Procedure SetValueST(value : TFslDateTime);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImmunizationRecommendationRecommendationDateCriterion; overload;
    function Clone : TFhirImmunizationRecommendationRecommendationDateCriterion; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Date classification of recommendation.  For example, earliest date to give, latest date to give, etc. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Date classification of recommendation.  For example, earliest date to give, latest date to give, etc.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The date whose meaning is specified by dateCriterion.code.
    property value : TFslDateTime read GetValueST write SetValueST;
    // The date whose meaning is specified by dateCriterion.code.
    property valueElement : TFhirDateTime read FValue write SetValue;

  end;

  TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImmunizationRecommendationRecommendationDateCriterionList;
    function GetCurrent : TFhirImmunizationRecommendationRecommendationDateCriterion;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImmunizationRecommendationRecommendationDateCriterionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImmunizationRecommendationRecommendationDateCriterion read GetCurrent;
  end;

  TFhirImmunizationRecommendationRecommendationDateCriterionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImmunizationRecommendationRecommendationDateCriterion;
    procedure SetItemN(index : Integer; value : TFhirImmunizationRecommendationRecommendationDateCriterion);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImmunizationRecommendationRecommendationDateCriterionList; Overload;
    function Clone : TFhirImmunizationRecommendationRecommendationDateCriterionList; Overload;
    function GetEnumerator : TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator;

    //  Add a FhirImmunizationRecommendationRecommendationDateCriterion to the end of the list.
    function Append : TFhirImmunizationRecommendationRecommendationDateCriterion;

    // Add an already existing FhirImmunizationRecommendationRecommendationDateCriterion to the end of the list.
    procedure AddItem(value : TFhirImmunizationRecommendationRecommendationDateCriterion); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImmunizationRecommendationRecommendationDateCriterion) : Integer;

    // Insert FhirImmunizationRecommendationRecommendationDateCriterion before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImmunizationRecommendationRecommendationDateCriterion;

    // Insert an existing FhirImmunizationRecommendationRecommendationDateCriterion before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImmunizationRecommendationRecommendationDateCriterion);

    // Get the iIndexth FhirImmunizationRecommendationRecommendationDateCriterion. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationRecommendationRecommendationDateCriterion);

    // The number of items in the collection
    function Item(index : Integer) : TFhirImmunizationRecommendationRecommendationDateCriterion;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirImmunizationRecommendationRecommendationDateCriterions[index : Integer] : TFhirImmunizationRecommendationRecommendationDateCriterion read GetItemN write SetItemN; default;
  End;

  // Contains information about the protocol under which the vaccine was administered.
  TFhirImmunizationRecommendationRecommendationProtocol = class (TFhirBackboneElement)
  protected
    FDoseSequence : TFhirInteger;
    FDescription : TFhirString;
    FAuthority : TFhirReference{TFhirOrganization};
    FSeries : TFhirString;
    Procedure SetDoseSequence(value : TFhirInteger);
    Function GetDoseSequenceST : String;
    Procedure SetDoseSequenceST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetAuthority(value : TFhirReference{TFhirOrganization});
    Procedure SetSeries(value : TFhirString);
    Function GetSeriesST : String;
    Procedure SetSeriesST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImmunizationRecommendationRecommendationProtocol; overload;
    function Clone : TFhirImmunizationRecommendationRecommendationProtocol; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Indicates the nominal position in a series of the next dose.  This is the recommended dose number as per a specified protocol.
    property doseSequence : String read GetDoseSequenceST write SetDoseSequenceST;
    // Indicates the nominal position in a series of the next dose.  This is the recommended dose number as per a specified protocol.
    property doseSequenceElement : TFhirInteger read FDoseSequence write SetDoseSequence;

    // Typed access to Contains the description about the protocol under which the vaccine was administered.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Contains the description about the protocol under which the vaccine was administered.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Indicates the authority who {$IFNDEF FPC}published{$ENDIF} the protocol.  For example, ACIP. (defined for API consistency)
    property authority : TFhirReference{TFhirOrganization} read FAuthority write SetAuthority;
    // Indicates the authority who {$IFNDEF FPC}published{$ENDIF} the protocol.  For example, ACIP.
    property authorityElement : TFhirReference{TFhirOrganization} read FAuthority write SetAuthority;

    // Typed access to One possible path to achieve presumed immunity against a disease - within the context of an authority.
    property series : String read GetSeriesST write SetSeriesST;
    // One possible path to achieve presumed immunity against a disease - within the context of an authority.
    property seriesElement : TFhirString read FSeries write SetSeries;

  end;

  TFhirImmunizationRecommendationRecommendationProtocolListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImmunizationRecommendationRecommendationProtocolList;
    function GetCurrent : TFhirImmunizationRecommendationRecommendationProtocol;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImmunizationRecommendationRecommendationProtocolList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImmunizationRecommendationRecommendationProtocol read GetCurrent;
  end;

  TFhirImmunizationRecommendationRecommendationProtocolList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImmunizationRecommendationRecommendationProtocol;
    procedure SetItemN(index : Integer; value : TFhirImmunizationRecommendationRecommendationProtocol);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImmunizationRecommendationRecommendationProtocolList; Overload;
    function Clone : TFhirImmunizationRecommendationRecommendationProtocolList; Overload;
    function GetEnumerator : TFhirImmunizationRecommendationRecommendationProtocolListEnumerator;

    //  Add a FhirImmunizationRecommendationRecommendationProtocol to the end of the list.
    function Append : TFhirImmunizationRecommendationRecommendationProtocol;

    // Add an already existing FhirImmunizationRecommendationRecommendationProtocol to the end of the list.
    procedure AddItem(value : TFhirImmunizationRecommendationRecommendationProtocol); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImmunizationRecommendationRecommendationProtocol) : Integer;

    // Insert FhirImmunizationRecommendationRecommendationProtocol before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImmunizationRecommendationRecommendationProtocol;

    // Insert an existing FhirImmunizationRecommendationRecommendationProtocol before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImmunizationRecommendationRecommendationProtocol);

    // Get the iIndexth FhirImmunizationRecommendationRecommendationProtocol. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationRecommendationRecommendationProtocol);

    // The number of items in the collection
    function Item(index : Integer) : TFhirImmunizationRecommendationRecommendationProtocol;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirImmunizationRecommendationRecommendationProtocols[index : Integer] : TFhirImmunizationRecommendationRecommendationProtocol read GetItemN write SetItemN; default;
  End;

  // A patient's point-in-time immunization and recommendation (i.e. forecasting a patient's immunization eligibility according to a {$IFNDEF FPC}published{$ENDIF} schedule) with optional supporting justification.
  TFhirImmunizationRecommendation = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FPatient : TFhirReference{TFhirPatient};
    FrecommendationList : TFhirImmunizationRecommendationRecommendationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    function GetRecommendationList : TFhirImmunizationRecommendationRecommendationList;
    function GetHasRecommendationList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImmunizationRecommendation; overload;
    function Clone : TFhirImmunizationRecommendation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A unique identifier assigned to this particular recommendation record.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The patient for whom the recommendations are for. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // The patient for whom the recommendations are for.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Vaccine administration recommendations.
    property recommendationList : TFhirImmunizationRecommendationRecommendationList read GetRecommendationList;
    property hasRecommendationList : boolean read GetHasRecommendationList;

  end;

  TFhirImmunizationRecommendationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImmunizationRecommendationList;
    function GetCurrent : TFhirImmunizationRecommendation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImmunizationRecommendationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImmunizationRecommendation read GetCurrent;
  end;

  TFhirImmunizationRecommendationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImmunizationRecommendation;
    procedure SetItemN(index : Integer; value : TFhirImmunizationRecommendation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImmunizationRecommendationList; Overload;
    function Clone : TFhirImmunizationRecommendationList; Overload;
    function GetEnumerator : TFhirImmunizationRecommendationListEnumerator;

    //  Add a FhirImmunizationRecommendation to the end of the list.
    function Append : TFhirImmunizationRecommendation;

    // Add an already existing FhirImmunizationRecommendation to the end of the list.
    procedure AddItem(value : TFhirImmunizationRecommendation); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImmunizationRecommendation) : Integer;

    // Insert FhirImmunizationRecommendation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImmunizationRecommendation;

    // Insert an existing FhirImmunizationRecommendation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImmunizationRecommendation);

    // Get the iIndexth FhirImmunizationRecommendation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationRecommendation);

    // The number of items in the collection
    function Item(index : Integer) : TFhirImmunizationRecommendation;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirImmunizationRecommendations[index : Integer] : TFhirImmunizationRecommendation read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}

{$IFDEF FHIR_MEDIA}

  // A photo, video, or audio recording acquired or used in healthcare. The actual content may be inline or provided by direct reference.
  TFhirMedia = class (TFhirDomainResource)
  protected
    FType_ : TFhirEnum;
    FSubtype : TFhirCodeableConcept;
    FidentifierList : TFhirIdentifierList;
    FSubject : TFhirReference{Resource};
    FOperator : TFhirReference{TFhirPractitioner};
    FView : TFhirCodeableConcept;
    FDeviceName : TFhirString;
    FHeight : TFhirPositiveInt;
    FWidth : TFhirPositiveInt;
    FFrames : TFhirPositiveInt;
    FDuration : TFhirUnsignedInt;
    FContent : TFhirAttachment;
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirDigitalMediaTypeEnum;
    Procedure SetType_ST(value : TFhirDigitalMediaTypeEnum);
    Procedure SetSubtype(value : TFhirCodeableConcept);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetSubject(value : TFhirReference{Resource});
    Procedure SetOperator(value : TFhirReference{TFhirPractitioner});
    Procedure SetView(value : TFhirCodeableConcept);
    Procedure SetDeviceName(value : TFhirString);
    Function GetDeviceNameST : String;
    Procedure SetDeviceNameST(value : String);
    Procedure SetHeight(value : TFhirPositiveInt);
    Function GetHeightST : String;
    Procedure SetHeightST(value : String);
    Procedure SetWidth(value : TFhirPositiveInt);
    Function GetWidthST : String;
    Procedure SetWidthST(value : String);
    Procedure SetFrames(value : TFhirPositiveInt);
    Function GetFramesST : String;
    Procedure SetFramesST(value : String);
    Procedure SetDuration(value : TFhirUnsignedInt);
    Function GetDurationST : String;
    Procedure SetDurationST(value : String);
    Procedure SetContent(value : TFhirAttachment);

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedia; overload;
    function Clone : TFhirMedia; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Whether the media is a photo (still image), an audio recording, or a video recording.
    property type_ : TFhirDigitalMediaTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to Details of the type of the media - usually, how it was acquired (what type of device). If images sourced from a DICOM system, are wrapped in a Media resource, then this is the modality. (defined for API consistency)
    property subtype : TFhirCodeableConcept read FSubtype write SetSubtype;
    // Details of the type of the media - usually, how it was acquired (what type of device). If images sourced from a DICOM system, are wrapped in a Media resource, then this is the modality.
    property subtypeElement : TFhirCodeableConcept read FSubtype write SetSubtype;

    // Identifiers associated with the image - these may include identifiers for the image itself, identifiers for the context of its collection (e.g. series ids) and context ids such as accession numbers or other workflow identifiers.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Who/What this Media is a record of. (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // Who/What this Media is a record of.
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // Typed access to The person who administered the collection of the image. (defined for API consistency)
    property operator : TFhirReference{TFhirPractitioner} read FOperator write SetOperator;
    // The person who administered the collection of the image.
    property operatorElement : TFhirReference{TFhirPractitioner} read FOperator write SetOperator;

    // Typed access to The name of the imaging view e.g. Lateral or Antero-posterior (AP). (defined for API consistency)
    property view : TFhirCodeableConcept read FView write SetView;
    // The name of the imaging view e.g. Lateral or Antero-posterior (AP).
    property viewElement : TFhirCodeableConcept read FView write SetView;

    // Typed access to The name of the device / manufacturer of the device  that was used to make the recording.
    property deviceName : String read GetDeviceNameST write SetDeviceNameST;
    // The name of the device / manufacturer of the device  that was used to make the recording.
    property deviceNameElement : TFhirString read FDeviceName write SetDeviceName;

    // Typed access to Height of the image in pixels (photo/video).
    property height : String read GetHeightST write SetHeightST;
    // Height of the image in pixels (photo/video).
    property heightElement : TFhirPositiveInt read FHeight write SetHeight;

    // Typed access to Width of the image in pixels (photo/video).
    property width : String read GetWidthST write SetWidthST;
    // Width of the image in pixels (photo/video).
    property widthElement : TFhirPositiveInt read FWidth write SetWidth;

    // Typed access to The number of frames in a photo. This is used with a multi-page fax, or an imaging acquisition context that takes multiple slices in a single image, or an animated gif. If there is more than one frame, this SHALL have a value in order to alert interface software that a multi-frame capable rendering widget is required.
    property frames : String read GetFramesST write SetFramesST;
    // The number of frames in a photo. This is used with a multi-page fax, or an imaging acquisition context that takes multiple slices in a single image, or an animated gif. If there is more than one frame, this SHALL have a value in order to alert interface software that a multi-frame capable rendering widget is required.
    property framesElement : TFhirPositiveInt read FFrames write SetFrames;

    // Typed access to The duration of the recording in seconds - for audio and video.
    property duration : String read GetDurationST write SetDurationST;
    // The duration of the recording in seconds - for audio and video.
    property durationElement : TFhirUnsignedInt read FDuration write SetDuration;

    // Typed access to The actual content of the media - inline or by direct reference to the media source file. (defined for API consistency)
    property content : TFhirAttachment read FContent write SetContent;
    // The actual content of the media - inline or by direct reference to the media source file.
    property contentElement : TFhirAttachment read FContent write SetContent;

  end;

  TFhirMediaListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMediaList;
    function GetCurrent : TFhirMedia;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMediaList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedia read GetCurrent;
  end;

  TFhirMediaList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedia;
    procedure SetItemN(index : Integer; value : TFhirMedia);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMediaList; Overload;
    function Clone : TFhirMediaList; Overload;
    function GetEnumerator : TFhirMediaListEnumerator;

    //  Add a FhirMedia to the end of the list.
    function Append : TFhirMedia;

    // Add an already existing FhirMedia to the end of the list.
    procedure AddItem(value : TFhirMedia); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedia) : Integer;

    // Insert FhirMedia before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedia;

    // Insert an existing FhirMedia before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedia);

    // Get the iIndexth FhirMedia. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedia);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMedia;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMedia[index : Integer] : TFhirMedia read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEDIA}

{$IFDEF FHIR_MEDICATIONADMINISTRATION}

  // Describes the medication dosage information details e.g. dose, rate, site, route, etc.
  TFhirMedicationAdministrationDosage = class (TFhirBackboneElement)
  protected
    FText : TFhirString;
    FSite : TFhirType;
    FRoute : TFhirCodeableConcept;
    FMethod : TFhirCodeableConcept;
    FQuantity : TFhirQuantity;
    FRate : TFhirType;
    Procedure SetText(value : TFhirString);
    Function GetTextST : String;
    Procedure SetTextST(value : String);
    Procedure SetSite(value : TFhirType);
    Procedure SetRoute(value : TFhirCodeableConcept);
    Procedure SetMethod(value : TFhirCodeableConcept);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetRate(value : TFhirType);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationAdministrationDosage; overload;
    function Clone : TFhirMedicationAdministrationDosage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Free text dosage instructions can be used for cases where the instructions are too complex to code. When coded instructions are present, the free text instructions may still be present for display to humans taking or administering the medication.
    property text : String read GetTextST write SetTextST;
    // Free text dosage instructions can be used for cases where the instructions are too complex to code. When coded instructions are present, the free text instructions may still be present for display to humans taking or administering the medication.
    property textElement : TFhirString read FText write SetText;

    // Typed access to A coded specification of the anatomic site where the medication first entered the body.  For example, "left arm". (defined for API consistency)
    property site : TFhirType read FSite write SetSite;
    // A coded specification of the anatomic site where the medication first entered the body.  For example, "left arm".
    property siteElement : TFhirType read FSite write SetSite;

    // Typed access to A code specifying the route or physiological path of administration of a therapeutic agent into or onto the patient.  For example, topical, intravenous, etc. (defined for API consistency)
    property route : TFhirCodeableConcept read FRoute write SetRoute;
    // A code specifying the route or physiological path of administration of a therapeutic agent into or onto the patient.  For example, topical, intravenous, etc.
    property routeElement : TFhirCodeableConcept read FRoute write SetRoute;

    // Typed access to A coded value indicating the method by which the medication is intended to be or was introduced into or on the body.  This attribute will most often NOT be populated.  It is most commonly used for injections.  For example, Slow Push, Deep IV. (defined for API consistency)
    property method : TFhirCodeableConcept read FMethod write SetMethod;
    // A coded value indicating the method by which the medication is intended to be or was introduced into or on the body.  This attribute will most often NOT be populated.  It is most commonly used for injections.  For example, Slow Push, Deep IV.
    property methodElement : TFhirCodeableConcept read FMethod write SetMethod;

    // Typed access to The amount of the medication given at one administration event.   Use this value when the administration is essentially an instantaneous event such as a swallowing a tablet or giving an injection. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The amount of the medication given at one administration event.   Use this value when the administration is essentially an instantaneous event such as a swallowing a tablet or giving an injection.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to Identifies the speed with which the medication was or will be introduced into the patient.  Typically the rate for an infusion e.g. 100 ml per 1 hour or 100 ml/hr.  May also be expressed as a rate per unit of time e.g. 500 ml per 2 hours.  Currently we do not specify a default of '1' in the denominator, but this is being discussed.  Other examples:  200 mcg/min or 200 mcg/1 minute; 1 liter/8 hours. (defined for API consistency)
    property rate : TFhirType read FRate write SetRate;
    // Identifies the speed with which the medication was or will be introduced into the patient.  Typically the rate for an infusion e.g. 100 ml per 1 hour or 100 ml/hr.  May also be expressed as a rate per unit of time e.g. 500 ml per 2 hours.  Currently we do not specify a default of '1' in the denominator, but this is being discussed.  Other examples:  200 mcg/min or 200 mcg/1 minute; 1 liter/8 hours.
    property rateElement : TFhirType read FRate write SetRate;

  end;

  TFhirMedicationAdministrationDosageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationAdministrationDosageList;
    function GetCurrent : TFhirMedicationAdministrationDosage;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationAdministrationDosageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationAdministrationDosage read GetCurrent;
  end;

  TFhirMedicationAdministrationDosageList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationAdministrationDosage;
    procedure SetItemN(index : Integer; value : TFhirMedicationAdministrationDosage);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationAdministrationDosageList; Overload;
    function Clone : TFhirMedicationAdministrationDosageList; Overload;
    function GetEnumerator : TFhirMedicationAdministrationDosageListEnumerator;

    //  Add a FhirMedicationAdministrationDosage to the end of the list.
    function Append : TFhirMedicationAdministrationDosage;

    // Add an already existing FhirMedicationAdministrationDosage to the end of the list.
    procedure AddItem(value : TFhirMedicationAdministrationDosage); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationAdministrationDosage) : Integer;

    // Insert FhirMedicationAdministrationDosage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationAdministrationDosage;

    // Insert an existing FhirMedicationAdministrationDosage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationAdministrationDosage);

    // Get the iIndexth FhirMedicationAdministrationDosage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationAdministrationDosage);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationAdministrationDosage;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMedicationAdministrationDosages[index : Integer] : TFhirMedicationAdministrationDosage read GetItemN write SetItemN; default;
  End;

  // Describes the event of a patient consuming or otherwise being administered a medication.  This may be as simple as swallowing a tablet or it may be a long running infusion.  Related resources tie this event to the authorizing prescription, and the specific encounter between patient and health care practitioner.
  TFhirMedicationAdministration = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FPatient : TFhirReference{TFhirPatient};
    FPractitioner : TFhirReference{Resource};
    FEncounter : TFhirReference{TFhirEncounter};
    FPrescription : TFhirReference{TFhirMedicationOrder};
    FWasNotGiven : TFhirBoolean;
    FreasonNotGivenList : TFhirCodeableConceptList;
    FreasonGivenList : TFhirCodeableConceptList;
    FEffectiveTime : TFhirType;
    FMedication : TFhirType;
    FdeviceList : TFhirReferenceList{TFhirDevice};
    FNote : TFhirString;
    FDosage : TFhirMedicationAdministrationDosage;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirMedicationAdminStatusEnum;
    Procedure SetStatusST(value : TFhirMedicationAdminStatusEnum);
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    Procedure SetPractitioner(value : TFhirReference{Resource});
    Procedure SetEncounter(value : TFhirReference{TFhirEncounter});
    Procedure SetPrescription(value : TFhirReference{TFhirMedicationOrder});
    Procedure SetWasNotGiven(value : TFhirBoolean);
    Function GetWasNotGivenST : Boolean;
    Procedure SetWasNotGivenST(value : Boolean);
    function GetReasonNotGivenList : TFhirCodeableConceptList;
    function GetHasReasonNotGivenList : Boolean;
    function GetReasonGivenList : TFhirCodeableConceptList;
    function GetHasReasonGivenList : Boolean;
    Procedure SetEffectiveTime(value : TFhirType);
    Procedure SetMedication(value : TFhirType);
    function GetDeviceList : TFhirReferenceList{TFhirDevice};
    function GetHasDeviceList : Boolean;
    Procedure SetNote(value : TFhirString);
    Function GetNoteST : String;
    Procedure SetNoteST(value : String);
    Procedure SetDosage(value : TFhirMedicationAdministrationDosage);

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationAdministration; overload;
    function Clone : TFhirMedicationAdministration; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // External identifier - FHIR will generate its own internal identifiers (probably URLs) which do not need to be explicitly managed by the resource.  The identifier here is one that would be used by another non-FHIR system - for example an automated medication pump would provide a record each time it operated; an administration while the patient was off the ward might be made with a different system and entered after the event.  Particularly important if these records have to be updated.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Will generally be set to show that the administration has been completed.  For some long running administrations such as infusions it is possible for an administration to be started but not completed or it may be paused while some other process is under way.
    property status : TFhirMedicationAdminStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The person or animal receiving the medication. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // The person or animal receiving the medication.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Typed access to The individual who was responsible for giving the medication to the patient. (defined for API consistency)
    property practitioner : TFhirReference{Resource} read FPractitioner write SetPractitioner;
    // The individual who was responsible for giving the medication to the patient.
    property practitionerElement : TFhirReference{Resource} read FPractitioner write SetPractitioner;

    // Typed access to The visit, admission or other contact between patient and health care provider the medication administration was performed as part of. (defined for API consistency)
    property encounter : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;
    // The visit, admission or other contact between patient and health care provider the medication administration was performed as part of.
    property encounterElement : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;

    // Typed access to The original request, instruction or authority to perform the administration. (defined for API consistency)
    property prescription : TFhirReference{TFhirMedicationOrder} read FPrescription write SetPrescription;
    // The original request, instruction or authority to perform the administration.
    property prescriptionElement : TFhirReference{TFhirMedicationOrder} read FPrescription write SetPrescription;

    // Typed access to Set this to true if the record is saying that the medication was NOT administered.
    property wasNotGiven : Boolean read GetWasNotGivenST write SetWasNotGivenST;
    // Set this to true if the record is saying that the medication was NOT administered.
    property wasNotGivenElement : TFhirBoolean read FWasNotGiven write SetWasNotGiven;

    // A code indicating why the administration was not performed.
    property reasonNotGivenList : TFhirCodeableConceptList read GetReasonNotGivenList;
    property hasReasonNotGivenList : boolean read GetHasReasonNotGivenList;

    // A code indicating why the medication was given.
    property reasonGivenList : TFhirCodeableConceptList read GetReasonGivenList;
    property hasReasonGivenList : boolean read GetHasReasonGivenList;

    // Typed access to A specific date/time or interval of time during which the administration took place (or did not take place, when the 'notGiven' attribute is true). For many administrations, such as swallowing a tablet the use of dateTime is more appropriate. (defined for API consistency)
    property effectiveTime : TFhirType read FEffectiveTime write SetEffectiveTime;
    // A specific date/time or interval of time during which the administration took place (or did not take place, when the 'notGiven' attribute is true). For many administrations, such as swallowing a tablet the use of dateTime is more appropriate.
    property effectiveTimeElement : TFhirType read FEffectiveTime write SetEffectiveTime;

    // Typed access to Identifies the medication that was administered. This is either a link to a resource representing the details of the medication or a simple attribute carrying a code that identifies the medication from a known list of medications. (defined for API consistency)
    property medication : TFhirType read FMedication write SetMedication;
    // Identifies the medication that was administered. This is either a link to a resource representing the details of the medication or a simple attribute carrying a code that identifies the medication from a known list of medications.
    property medicationElement : TFhirType read FMedication write SetMedication;

    // The device used in administering the medication to the patient.  For example, a particular infusion pump.
    property deviceList : TFhirReferenceList{TFhirDevice} read GetDeviceList;
    property hasDeviceList : boolean read GetHasDeviceList;

    // Typed access to Extra information about the medication administration that is not conveyed by the other attributes.
    property note : String read GetNoteST write SetNoteST;
    // Extra information about the medication administration that is not conveyed by the other attributes.
    property noteElement : TFhirString read FNote write SetNote;

    // Typed access to Describes the medication dosage information details e.g. dose, rate, site, route, etc. (defined for API consistency)
    property dosage : TFhirMedicationAdministrationDosage read FDosage write SetDosage;
    // Describes the medication dosage information details e.g. dose, rate, site, route, etc.
    property dosageElement : TFhirMedicationAdministrationDosage read FDosage write SetDosage;

  end;

  TFhirMedicationAdministrationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationAdministrationList;
    function GetCurrent : TFhirMedicationAdministration;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationAdministrationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationAdministration read GetCurrent;
  end;

  TFhirMedicationAdministrationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationAdministration;
    procedure SetItemN(index : Integer; value : TFhirMedicationAdministration);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationAdministrationList; Overload;
    function Clone : TFhirMedicationAdministrationList; Overload;
    function GetEnumerator : TFhirMedicationAdministrationListEnumerator;

    //  Add a FhirMedicationAdministration to the end of the list.
    function Append : TFhirMedicationAdministration;

    // Add an already existing FhirMedicationAdministration to the end of the list.
    procedure AddItem(value : TFhirMedicationAdministration); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationAdministration) : Integer;

    // Insert FhirMedicationAdministration before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationAdministration;

    // Insert an existing FhirMedicationAdministration before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationAdministration);

    // Get the iIndexth FhirMedicationAdministration. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationAdministration);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationAdministration;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMedicationAdministrations[index : Integer] : TFhirMedicationAdministration read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEDICATIONADMINISTRATION}

{$IFDEF FHIR_MEDICATIONDISPENSE}

  // Indicates how the medication is to be used by the patient.
  TFhirMedicationDispenseDosageInstruction = class (TFhirBackboneElement)
  protected
    FText : TFhirString;
    FAdditionalInstructions : TFhirCodeableConcept;
    FTiming : TFhirTiming;
    FAsNeeded : TFhirType;
    FSite : TFhirType;
    FRoute : TFhirCodeableConcept;
    FMethod : TFhirCodeableConcept;
    FDose : TFhirType;
    FRate : TFhirType;
    FMaxDosePerPeriod : TFhirRatio;
    Procedure SetText(value : TFhirString);
    Function GetTextST : String;
    Procedure SetTextST(value : String);
    Procedure SetAdditionalInstructions(value : TFhirCodeableConcept);
    Procedure SetTiming(value : TFhirTiming);
    Procedure SetAsNeeded(value : TFhirType);
    Procedure SetSite(value : TFhirType);
    Procedure SetRoute(value : TFhirCodeableConcept);
    Procedure SetMethod(value : TFhirCodeableConcept);
    Procedure SetDose(value : TFhirType);
    Procedure SetRate(value : TFhirType);
    Procedure SetMaxDosePerPeriod(value : TFhirRatio);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationDispenseDosageInstruction; overload;
    function Clone : TFhirMedicationDispenseDosageInstruction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Free text dosage instructions can be used for cases where the instructions are too complex to code. When coded instructions are present, the free text instructions may still be present for display to humans taking or administering the medication.
    property text : String read GetTextST write SetTextST;
    // Free text dosage instructions can be used for cases where the instructions are too complex to code. When coded instructions are present, the free text instructions may still be present for display to humans taking or administering the medication.
    property textElement : TFhirString read FText write SetText;

    // Typed access to Additional instructions such as "Swallow with plenty of water" which may or may not be coded. (defined for API consistency)
    property additionalInstructions : TFhirCodeableConcept read FAdditionalInstructions write SetAdditionalInstructions;
    // Additional instructions such as "Swallow with plenty of water" which may or may not be coded.
    property additionalInstructionsElement : TFhirCodeableConcept read FAdditionalInstructions write SetAdditionalInstructions;

    // Typed access to The timing schedule for giving the medication to the patient.  The Schedule data type allows many different expressions.  For example, "Every  8 hours"; "Three times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec 2011:";  "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013". (defined for API consistency)
    property timing : TFhirTiming read FTiming write SetTiming;
    // The timing schedule for giving the medication to the patient.  The Schedule data type allows many different expressions.  For example, "Every  8 hours"; "Three times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec 2011:";  "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013".
    property timingElement : TFhirTiming read FTiming write SetTiming;

    // Typed access to Indicates whether the Medication is only taken when needed within a specific dosing schedule (Boolean option), or it indicates the precondition for taking the Medication (CodeableConcept).    Specifically if 'boolean' datatype is selected, then the following logic applies:  If set to True, this indicates that the medication is only taken when needed, within the specified schedule. (defined for API consistency)
    property asNeeded : TFhirType read FAsNeeded write SetAsNeeded;
    // Indicates whether the Medication is only taken when needed within a specific dosing schedule (Boolean option), or it indicates the precondition for taking the Medication (CodeableConcept).    Specifically if 'boolean' datatype is selected, then the following logic applies:  If set to True, this indicates that the medication is only taken when needed, within the specified schedule.
    property asNeededElement : TFhirType read FAsNeeded write SetAsNeeded;

    // Typed access to A coded specification of the anatomic site where the medication first enters the body. (defined for API consistency)
    property site : TFhirType read FSite write SetSite;
    // A coded specification of the anatomic site where the medication first enters the body.
    property siteElement : TFhirType read FSite write SetSite;

    // Typed access to A code specifying the route or physiological path of administration of a therapeutic agent into or onto a subject. (defined for API consistency)
    property route : TFhirCodeableConcept read FRoute write SetRoute;
    // A code specifying the route or physiological path of administration of a therapeutic agent into or onto a subject.
    property routeElement : TFhirCodeableConcept read FRoute write SetRoute;

    // Typed access to A coded value indicating the method by which the medication is intended to be or was introduced into or on the body. (defined for API consistency)
    property method : TFhirCodeableConcept read FMethod write SetMethod;
    // A coded value indicating the method by which the medication is intended to be or was introduced into or on the body.
    property methodElement : TFhirCodeableConcept read FMethod write SetMethod;

    // Typed access to The amount of therapeutic or other substance given at one administration event. (defined for API consistency)
    property dose : TFhirType read FDose write SetDose;
    // The amount of therapeutic or other substance given at one administration event.
    property doseElement : TFhirType read FDose write SetDose;

    // Typed access to Identifies the speed with which the medication was or will be introduced into the patient. Typically the rate for an infusion e.g. 100 ml per 1 hour or 100 ml/hr.  May also be expressed as a rate per unit of time e.g. 500 ml per 2 hours.   Currently we do not specify a default of '1' in the denominator, but this is being discussed. Other examples: 200 mcg/min or 200 mcg/1 minute; 1 liter/8 hours. (defined for API consistency)
    property rate : TFhirType read FRate write SetRate;
    // Identifies the speed with which the medication was or will be introduced into the patient. Typically the rate for an infusion e.g. 100 ml per 1 hour or 100 ml/hr.  May also be expressed as a rate per unit of time e.g. 500 ml per 2 hours.   Currently we do not specify a default of '1' in the denominator, but this is being discussed. Other examples: 200 mcg/min or 200 mcg/1 minute; 1 liter/8 hours.
    property rateElement : TFhirType read FRate write SetRate;

    // Typed access to The maximum total quantity of a therapeutic substance that may be administered to a subject over the period of time,  e.g. 1000mg in 24 hours. (defined for API consistency)
    property maxDosePerPeriod : TFhirRatio read FMaxDosePerPeriod write SetMaxDosePerPeriod;
    // The maximum total quantity of a therapeutic substance that may be administered to a subject over the period of time,  e.g. 1000mg in 24 hours.
    property maxDosePerPeriodElement : TFhirRatio read FMaxDosePerPeriod write SetMaxDosePerPeriod;

  end;

  TFhirMedicationDispenseDosageInstructionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationDispenseDosageInstructionList;
    function GetCurrent : TFhirMedicationDispenseDosageInstruction;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationDispenseDosageInstructionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationDispenseDosageInstruction read GetCurrent;
  end;

  TFhirMedicationDispenseDosageInstructionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationDispenseDosageInstruction;
    procedure SetItemN(index : Integer; value : TFhirMedicationDispenseDosageInstruction);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationDispenseDosageInstructionList; Overload;
    function Clone : TFhirMedicationDispenseDosageInstructionList; Overload;
    function GetEnumerator : TFhirMedicationDispenseDosageInstructionListEnumerator;

    //  Add a FhirMedicationDispenseDosageInstruction to the end of the list.
    function Append : TFhirMedicationDispenseDosageInstruction;

    // Add an already existing FhirMedicationDispenseDosageInstruction to the end of the list.
    procedure AddItem(value : TFhirMedicationDispenseDosageInstruction); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationDispenseDosageInstruction) : Integer;

    // Insert FhirMedicationDispenseDosageInstruction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationDispenseDosageInstruction;

    // Insert an existing FhirMedicationDispenseDosageInstruction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationDispenseDosageInstruction);

    // Get the iIndexth FhirMedicationDispenseDosageInstruction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationDispenseDosageInstruction);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationDispenseDosageInstruction;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMedicationDispenseDosageInstructions[index : Integer] : TFhirMedicationDispenseDosageInstruction read GetItemN write SetItemN; default;
  End;

  // Indicates whether or not substitution was made as part of the dispense.  In some cases substitution will be expected but does not happen, in other cases substitution is not expected but does happen.  This block explains what substitution did or did not happen and why.
  TFhirMedicationDispenseSubstitution = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FreasonList : TFhirCodeableConceptList;
    FresponsiblePartyList : TFhirReferenceList{TFhirPractitioner};
    Procedure SetType_(value : TFhirCodeableConcept);
    function GetReasonList : TFhirCodeableConceptList;
    function GetHasReasonList : Boolean;
    function GetResponsiblePartyList : TFhirReferenceList{TFhirPractitioner};
    function GetHasResponsiblePartyList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationDispenseSubstitution; overload;
    function Clone : TFhirMedicationDispenseSubstitution; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code signifying whether a different drug was dispensed from what was prescribed. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A code signifying whether a different drug was dispensed from what was prescribed.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Indicates the reason for the substitution of (or lack of substitution) from what was prescribed.
    property reasonList : TFhirCodeableConceptList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // The person or organization that has primary responsibility for the substitution.
    property responsiblePartyList : TFhirReferenceList{TFhirPractitioner} read GetResponsiblePartyList;
    property hasResponsiblePartyList : boolean read GetHasResponsiblePartyList;

  end;

  TFhirMedicationDispenseSubstitutionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationDispenseSubstitutionList;
    function GetCurrent : TFhirMedicationDispenseSubstitution;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationDispenseSubstitutionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationDispenseSubstitution read GetCurrent;
  end;

  TFhirMedicationDispenseSubstitutionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationDispenseSubstitution;
    procedure SetItemN(index : Integer; value : TFhirMedicationDispenseSubstitution);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationDispenseSubstitutionList; Overload;
    function Clone : TFhirMedicationDispenseSubstitutionList; Overload;
    function GetEnumerator : TFhirMedicationDispenseSubstitutionListEnumerator;

    //  Add a FhirMedicationDispenseSubstitution to the end of the list.
    function Append : TFhirMedicationDispenseSubstitution;

    // Add an already existing FhirMedicationDispenseSubstitution to the end of the list.
    procedure AddItem(value : TFhirMedicationDispenseSubstitution); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationDispenseSubstitution) : Integer;

    // Insert FhirMedicationDispenseSubstitution before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationDispenseSubstitution;

    // Insert an existing FhirMedicationDispenseSubstitution before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationDispenseSubstitution);

    // Get the iIndexth FhirMedicationDispenseSubstitution. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationDispenseSubstitution);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationDispenseSubstitution;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMedicationDispenseSubstitutions[index : Integer] : TFhirMedicationDispenseSubstitution read GetItemN write SetItemN; default;
  End;

  // Indicates that a medication product is to be or has been dispensed for a named person/patient.  This includes a description of the medication product (supply) provided and the instructions for administering the medication.  The medication dispense is the result of a pharmacy system responding to a medication order.
  TFhirMedicationDispense = class (TFhirDomainResource)
  protected
    FIdentifier : TFhirIdentifier;
    FStatus : TFhirEnum;
    FPatient : TFhirReference{TFhirPatient};
    FDispenser : TFhirReference{TFhirPractitioner};
    FauthorizingPrescriptionList : TFhirReferenceList{TFhirMedicationOrder};
    FType_ : TFhirCodeableConcept;
    FQuantity : TFhirQuantity;
    FDaysSupply : TFhirQuantity;
    FMedication : TFhirType;
    FWhenPrepared : TFhirDateTime;
    FWhenHandedOver : TFhirDateTime;
    FDestination : TFhirReference{TFhirLocation};
    FreceiverList : TFhirReferenceList{Resource};
    FNote : TFhirString;
    FdosageInstructionList : TFhirMedicationDispenseDosageInstructionList;
    FSubstitution : TFhirMedicationDispenseSubstitution;
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirMedicationDispenseStatusEnum;
    Procedure SetStatusST(value : TFhirMedicationDispenseStatusEnum);
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    Procedure SetDispenser(value : TFhirReference{TFhirPractitioner});
    function GetAuthorizingPrescriptionList : TFhirReferenceList{TFhirMedicationOrder};
    function GetHasAuthorizingPrescriptionList : Boolean;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetDaysSupply(value : TFhirQuantity);
    Procedure SetMedication(value : TFhirType);
    Procedure SetWhenPrepared(value : TFhirDateTime);
    Function GetWhenPreparedST : TFslDateTime;
    Procedure SetWhenPreparedST(value : TFslDateTime);
    Procedure SetWhenHandedOver(value : TFhirDateTime);
    Function GetWhenHandedOverST : TFslDateTime;
    Procedure SetWhenHandedOverST(value : TFslDateTime);
    Procedure SetDestination(value : TFhirReference{TFhirLocation});
    function GetReceiverList : TFhirReferenceList{Resource};
    function GetHasReceiverList : Boolean;
    Procedure SetNote(value : TFhirString);
    Function GetNoteST : String;
    Procedure SetNoteST(value : String);
    function GetDosageInstructionList : TFhirMedicationDispenseDosageInstructionList;
    function GetHasDosageInstructionList : Boolean;
    Procedure SetSubstitution(value : TFhirMedicationDispenseSubstitution);

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationDispense; overload;
    function Clone : TFhirMedicationDispense; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Identifier assigned by the dispensing facility - this is an identifier assigned outside FHIR. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Identifier assigned by the dispensing facility - this is an identifier assigned outside FHIR.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // A code specifying the state of the set of dispense events.
    property status : TFhirMedicationDispenseStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A link to a resource representing the person to whom the medication will be given. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // A link to a resource representing the person to whom the medication will be given.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Typed access to The individual responsible for dispensing the medication. (defined for API consistency)
    property dispenser : TFhirReference{TFhirPractitioner} read FDispenser write SetDispenser;
    // The individual responsible for dispensing the medication.
    property dispenserElement : TFhirReference{TFhirPractitioner} read FDispenser write SetDispenser;

    // Indicates the medication order that is being dispensed against.
    property authorizingPrescriptionList : TFhirReferenceList{TFhirMedicationOrder} read GetAuthorizingPrescriptionList;
    property hasAuthorizingPrescriptionList : boolean read GetHasAuthorizingPrescriptionList;

    // Typed access to Indicates the type of dispensing event that is performed. For example, Trial Fill, Completion of Trial, Partial Fill, Emergency Fill, Samples, etc. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Indicates the type of dispensing event that is performed. For example, Trial Fill, Completion of Trial, Partial Fill, Emergency Fill, Samples, etc.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The amount of medication that has been dispensed. Includes unit of measure. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The amount of medication that has been dispensed. Includes unit of measure.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to The amount of medication expressed as a timing amount. (defined for API consistency)
    property daysSupply : TFhirQuantity read FDaysSupply write SetDaysSupply;
    // The amount of medication expressed as a timing amount.
    property daysSupplyElement : TFhirQuantity read FDaysSupply write SetDaysSupply;

    // Typed access to Identifies the medication being administered. This is either a link to a resource representing the details of the medication or a simple attribute carrying a code that identifies the medication from a known list of medications. (defined for API consistency)
    property medication : TFhirType read FMedication write SetMedication;
    // Identifies the medication being administered. This is either a link to a resource representing the details of the medication or a simple attribute carrying a code that identifies the medication from a known list of medications.
    property medicationElement : TFhirType read FMedication write SetMedication;

    // Typed access to The time when the dispensed product was packaged and reviewed.
    property whenPrepared : TFslDateTime read GetWhenPreparedST write SetWhenPreparedST;
    // The time when the dispensed product was packaged and reviewed.
    property whenPreparedElement : TFhirDateTime read FWhenPrepared write SetWhenPrepared;

    // Typed access to The time the dispensed product was provided to the patient or their representative.
    property whenHandedOver : TFslDateTime read GetWhenHandedOverST write SetWhenHandedOverST;
    // The time the dispensed product was provided to the patient or their representative.
    property whenHandedOverElement : TFhirDateTime read FWhenHandedOver write SetWhenHandedOver;

    // Typed access to Identification of the facility/location where the medication was shipped to, as part of the dispense event. (defined for API consistency)
    property destination : TFhirReference{TFhirLocation} read FDestination write SetDestination;
    // Identification of the facility/location where the medication was shipped to, as part of the dispense event.
    property destinationElement : TFhirReference{TFhirLocation} read FDestination write SetDestination;

    // Identifies the person who picked up the medication.  This will usually be a patient or their caregiver, but some cases exist where it can be a healthcare professional.
    property receiverList : TFhirReferenceList{Resource} read GetReceiverList;
    property hasReceiverList : boolean read GetHasReceiverList;

    // Typed access to Extra information about the dispense that could not be conveyed in the other attributes.
    property note : String read GetNoteST write SetNoteST;
    // Extra information about the dispense that could not be conveyed in the other attributes.
    property noteElement : TFhirString read FNote write SetNote;

    // Indicates how the medication is to be used by the patient.
    property dosageInstructionList : TFhirMedicationDispenseDosageInstructionList read GetDosageInstructionList;
    property hasDosageInstructionList : boolean read GetHasDosageInstructionList;

    // Typed access to Indicates whether or not substitution was made as part of the dispense.  In some cases substitution will be expected but does not happen, in other cases substitution is not expected but does happen.  This block explains what substitution did or did not happen and why. (defined for API consistency)
    property substitution : TFhirMedicationDispenseSubstitution read FSubstitution write SetSubstitution;
    // Indicates whether or not substitution was made as part of the dispense.  In some cases substitution will be expected but does not happen, in other cases substitution is not expected but does happen.  This block explains what substitution did or did not happen and why.
    property substitutionElement : TFhirMedicationDispenseSubstitution read FSubstitution write SetSubstitution;

  end;

  TFhirMedicationDispenseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationDispenseList;
    function GetCurrent : TFhirMedicationDispense;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationDispenseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationDispense read GetCurrent;
  end;

  TFhirMedicationDispenseList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationDispense;
    procedure SetItemN(index : Integer; value : TFhirMedicationDispense);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationDispenseList; Overload;
    function Clone : TFhirMedicationDispenseList; Overload;
    function GetEnumerator : TFhirMedicationDispenseListEnumerator;

    //  Add a FhirMedicationDispense to the end of the list.
    function Append : TFhirMedicationDispense;

    // Add an already existing FhirMedicationDispense to the end of the list.
    procedure AddItem(value : TFhirMedicationDispense); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationDispense) : Integer;

    // Insert FhirMedicationDispense before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationDispense;

    // Insert an existing FhirMedicationDispense before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationDispense);

    // Get the iIndexth FhirMedicationDispense. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationDispense);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationDispense;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMedicationDispenses[index : Integer] : TFhirMedicationDispense read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEDICATIONDISPENSE}

{$IFDEF FHIR_MEDICATIONORDER}

  // Indicates how the medication is to be used by the patient.
  TFhirMedicationOrderDosageInstruction = class (TFhirBackboneElement)
  protected
    FText : TFhirString;
    FAdditionalInstructions : TFhirCodeableConcept;
    FTiming : TFhirTiming;
    FAsNeeded : TFhirType;
    FSite : TFhirType;
    FRoute : TFhirCodeableConcept;
    FMethod : TFhirCodeableConcept;
    FDose : TFhirType;
    FRate : TFhirType;
    FMaxDosePerPeriod : TFhirRatio;
    Procedure SetText(value : TFhirString);
    Function GetTextST : String;
    Procedure SetTextST(value : String);
    Procedure SetAdditionalInstructions(value : TFhirCodeableConcept);
    Procedure SetTiming(value : TFhirTiming);
    Procedure SetAsNeeded(value : TFhirType);
    Procedure SetSite(value : TFhirType);
    Procedure SetRoute(value : TFhirCodeableConcept);
    Procedure SetMethod(value : TFhirCodeableConcept);
    Procedure SetDose(value : TFhirType);
    Procedure SetRate(value : TFhirType);
    Procedure SetMaxDosePerPeriod(value : TFhirRatio);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationOrderDosageInstruction; overload;
    function Clone : TFhirMedicationOrderDosageInstruction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Free text dosage instructions can be used for cases where the instructions are too complex to code.  The content of this attribute does not include the name or description of the medication. When coded instructions are present, the free text instructions may still be present for display to humans taking or administering the medication. It is expected that the text instructions will always be populated.  If the dosage.timing attribute is also populated, then the dosage.text should reflect the same information as the timing.
    property text : String read GetTextST write SetTextST;
    // Free text dosage instructions can be used for cases where the instructions are too complex to code.  The content of this attribute does not include the name or description of the medication. When coded instructions are present, the free text instructions may still be present for display to humans taking or administering the medication. It is expected that the text instructions will always be populated.  If the dosage.timing attribute is also populated, then the dosage.text should reflect the same information as the timing.
    property textElement : TFhirString read FText write SetText;

    // Typed access to Additional instructions such as "Swallow with plenty of water" which may or may not be coded. (defined for API consistency)
    property additionalInstructions : TFhirCodeableConcept read FAdditionalInstructions write SetAdditionalInstructions;
    // Additional instructions such as "Swallow with plenty of water" which may or may not be coded.
    property additionalInstructionsElement : TFhirCodeableConcept read FAdditionalInstructions write SetAdditionalInstructions;

    // Typed access to The timing schedule for giving the medication to the patient. The Schedule data type allows many different expressions. For example: "Every 8 hours"; "Three times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec 2011:"; "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013". (defined for API consistency)
    property timing : TFhirTiming read FTiming write SetTiming;
    // The timing schedule for giving the medication to the patient. The Schedule data type allows many different expressions. For example: "Every 8 hours"; "Three times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec 2011:"; "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013".
    property timingElement : TFhirTiming read FTiming write SetTiming;

    // Typed access to Indicates whether the Medication is only taken when needed within a specific dosing schedule (Boolean option), or it indicates the precondition for taking the Medication (CodeableConcept). (defined for API consistency)
    property asNeeded : TFhirType read FAsNeeded write SetAsNeeded;
    // Indicates whether the Medication is only taken when needed within a specific dosing schedule (Boolean option), or it indicates the precondition for taking the Medication (CodeableConcept).
    property asNeededElement : TFhirType read FAsNeeded write SetAsNeeded;

    // Typed access to A coded specification of the anatomic site where the medication first enters the body. (defined for API consistency)
    property site : TFhirType read FSite write SetSite;
    // A coded specification of the anatomic site where the medication first enters the body.
    property siteElement : TFhirType read FSite write SetSite;

    // Typed access to A code specifying the route or physiological path of administration of a therapeutic agent into or onto a patient's body. (defined for API consistency)
    property route : TFhirCodeableConcept read FRoute write SetRoute;
    // A code specifying the route or physiological path of administration of a therapeutic agent into or onto a patient's body.
    property routeElement : TFhirCodeableConcept read FRoute write SetRoute;

    // Typed access to A coded value indicating the method by which the medication is introduced into or onto the body. Most commonly used for injections.  For examples, Slow Push; Deep IV. (defined for API consistency)
    property method : TFhirCodeableConcept read FMethod write SetMethod;
    // A coded value indicating the method by which the medication is introduced into or onto the body. Most commonly used for injections.  For examples, Slow Push; Deep IV.
    property methodElement : TFhirCodeableConcept read FMethod write SetMethod;

    // Typed access to The amount of therapeutic or other substance given at one administration event. (defined for API consistency)
    property dose : TFhirType read FDose write SetDose;
    // The amount of therapeutic or other substance given at one administration event.
    property doseElement : TFhirType read FDose write SetDose;

    // Typed access to Identifies the speed with which the medication was or will be introduced into the patient. Typically the rate for an infusion e.g. 100 ml per 1 hour or 100 ml/hr.  May also be expressed as a rate per unit of time e.g. 500 ml per 2 hours.   Currently we do not specify a default of '1' in the denominator, but this is being discussed. Other examples: 200 mcg/min or 200 mcg/1 minute; 1 liter/8 hours. (defined for API consistency)
    property rate : TFhirType read FRate write SetRate;
    // Identifies the speed with which the medication was or will be introduced into the patient. Typically the rate for an infusion e.g. 100 ml per 1 hour or 100 ml/hr.  May also be expressed as a rate per unit of time e.g. 500 ml per 2 hours.   Currently we do not specify a default of '1' in the denominator, but this is being discussed. Other examples: 200 mcg/min or 200 mcg/1 minute; 1 liter/8 hours.
    property rateElement : TFhirType read FRate write SetRate;

    // Typed access to The maximum total quantity of a therapeutic substance that may be administered to a subject over the period of time.  For example, 1000mg in 24 hours. (defined for API consistency)
    property maxDosePerPeriod : TFhirRatio read FMaxDosePerPeriod write SetMaxDosePerPeriod;
    // The maximum total quantity of a therapeutic substance that may be administered to a subject over the period of time.  For example, 1000mg in 24 hours.
    property maxDosePerPeriodElement : TFhirRatio read FMaxDosePerPeriod write SetMaxDosePerPeriod;

  end;

  TFhirMedicationOrderDosageInstructionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationOrderDosageInstructionList;
    function GetCurrent : TFhirMedicationOrderDosageInstruction;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationOrderDosageInstructionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationOrderDosageInstruction read GetCurrent;
  end;

  TFhirMedicationOrderDosageInstructionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationOrderDosageInstruction;
    procedure SetItemN(index : Integer; value : TFhirMedicationOrderDosageInstruction);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationOrderDosageInstructionList; Overload;
    function Clone : TFhirMedicationOrderDosageInstructionList; Overload;
    function GetEnumerator : TFhirMedicationOrderDosageInstructionListEnumerator;

    //  Add a FhirMedicationOrderDosageInstruction to the end of the list.
    function Append : TFhirMedicationOrderDosageInstruction;

    // Add an already existing FhirMedicationOrderDosageInstruction to the end of the list.
    procedure AddItem(value : TFhirMedicationOrderDosageInstruction); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationOrderDosageInstruction) : Integer;

    // Insert FhirMedicationOrderDosageInstruction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationOrderDosageInstruction;

    // Insert an existing FhirMedicationOrderDosageInstruction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationOrderDosageInstruction);

    // Get the iIndexth FhirMedicationOrderDosageInstruction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationOrderDosageInstruction);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationOrderDosageInstruction;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMedicationOrderDosageInstructions[index : Integer] : TFhirMedicationOrderDosageInstruction read GetItemN write SetItemN; default;
  End;

  // Indicates the specific details for the dispense or medication supply part of a medication order (also known as a Medication Prescription).  Note that this information is NOT always sent with the order.  There may be in some settings (e.g. hospitals) institutional or system support for completing the dispense details in the pharmacy department.
  TFhirMedicationOrderDispenseRequest = class (TFhirBackboneElement)
  protected
    FMedication : TFhirType;
    FValidityPeriod : TFhirPeriod;
    FNumberOfRepeatsAllowed : TFhirPositiveInt;
    FQuantity : TFhirQuantity;
    FExpectedSupplyDuration : TFhirQuantity;
    Procedure SetMedication(value : TFhirType);
    Procedure SetValidityPeriod(value : TFhirPeriod);
    Procedure SetNumberOfRepeatsAllowed(value : TFhirPositiveInt);
    Function GetNumberOfRepeatsAllowedST : String;
    Procedure SetNumberOfRepeatsAllowedST(value : String);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetExpectedSupplyDuration(value : TFhirQuantity);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationOrderDispenseRequest; overload;
    function Clone : TFhirMedicationOrderDispenseRequest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Identifies the medication being administered. This is a link to a resource that represents the medication which may be the details of the medication or simply an attribute carrying a code that identifies the medication from a known list of medications. (defined for API consistency)
    property medication : TFhirType read FMedication write SetMedication;
    // Identifies the medication being administered. This is a link to a resource that represents the medication which may be the details of the medication or simply an attribute carrying a code that identifies the medication from a known list of medications.
    property medicationElement : TFhirType read FMedication write SetMedication;

    // Typed access to This indicates the validity period of a prescription (stale dating the Prescription). (defined for API consistency)
    property validityPeriod : TFhirPeriod read FValidityPeriod write SetValidityPeriod;
    // This indicates the validity period of a prescription (stale dating the Prescription).
    property validityPeriodElement : TFhirPeriod read FValidityPeriod write SetValidityPeriod;

    // Typed access to An integer indicating the number of additional times (aka refills or repeats) the patient can receive the prescribed medication.   Usage Notes: This integer does NOT include the original order dispense.   This means that if an order indicates dispense 30 tablets plus  "3 repeats", then the order can be dispensed a total of 4 times and the patient can receive a total of 120 tablets.
    property numberOfRepeatsAllowed : String read GetNumberOfRepeatsAllowedST write SetNumberOfRepeatsAllowedST;
    // An integer indicating the number of additional times (aka refills or repeats) the patient can receive the prescribed medication.   Usage Notes: This integer does NOT include the original order dispense.   This means that if an order indicates dispense 30 tablets plus  "3 repeats", then the order can be dispensed a total of 4 times and the patient can receive a total of 120 tablets.
    property numberOfRepeatsAllowedElement : TFhirPositiveInt read FNumberOfRepeatsAllowed write SetNumberOfRepeatsAllowed;

    // Typed access to The amount that is to be dispensed for one fill. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The amount that is to be dispensed for one fill.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to Identifies the period time over which the supplied product is expected to be used, or the length of time the dispense is expected to last. (defined for API consistency)
    property expectedSupplyDuration : TFhirQuantity read FExpectedSupplyDuration write SetExpectedSupplyDuration;
    // Identifies the period time over which the supplied product is expected to be used, or the length of time the dispense is expected to last.
    property expectedSupplyDurationElement : TFhirQuantity read FExpectedSupplyDuration write SetExpectedSupplyDuration;

  end;

  TFhirMedicationOrderDispenseRequestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationOrderDispenseRequestList;
    function GetCurrent : TFhirMedicationOrderDispenseRequest;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationOrderDispenseRequestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationOrderDispenseRequest read GetCurrent;
  end;

  TFhirMedicationOrderDispenseRequestList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationOrderDispenseRequest;
    procedure SetItemN(index : Integer; value : TFhirMedicationOrderDispenseRequest);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationOrderDispenseRequestList; Overload;
    function Clone : TFhirMedicationOrderDispenseRequestList; Overload;
    function GetEnumerator : TFhirMedicationOrderDispenseRequestListEnumerator;

    //  Add a FhirMedicationOrderDispenseRequest to the end of the list.
    function Append : TFhirMedicationOrderDispenseRequest;

    // Add an already existing FhirMedicationOrderDispenseRequest to the end of the list.
    procedure AddItem(value : TFhirMedicationOrderDispenseRequest); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationOrderDispenseRequest) : Integer;

    // Insert FhirMedicationOrderDispenseRequest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationOrderDispenseRequest;

    // Insert an existing FhirMedicationOrderDispenseRequest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationOrderDispenseRequest);

    // Get the iIndexth FhirMedicationOrderDispenseRequest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationOrderDispenseRequest);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationOrderDispenseRequest;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMedicationOrderDispenseRequests[index : Integer] : TFhirMedicationOrderDispenseRequest read GetItemN write SetItemN; default;
  End;

  // Indicates whether or not substitution can or should be part of the dispense. In some cases substitution must happen, in other cases substitution must not happen, and in others it does not matter. This block explains the prescriber's intent. If nothing is specified substitution may be done.
  TFhirMedicationOrderSubstitution = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FReason : TFhirCodeableConcept;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetReason(value : TFhirCodeableConcept);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationOrderSubstitution; overload;
    function Clone : TFhirMedicationOrderSubstitution; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code signifying whether a different drug should be dispensed from what was prescribed. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A code signifying whether a different drug should be dispensed from what was prescribed.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Indicates the reason for the substitution, or why substitution must or must not be performed. (defined for API consistency)
    property reason : TFhirCodeableConcept read FReason write SetReason;
    // Indicates the reason for the substitution, or why substitution must or must not be performed.
    property reasonElement : TFhirCodeableConcept read FReason write SetReason;

  end;

  TFhirMedicationOrderSubstitutionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationOrderSubstitutionList;
    function GetCurrent : TFhirMedicationOrderSubstitution;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationOrderSubstitutionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationOrderSubstitution read GetCurrent;
  end;

  TFhirMedicationOrderSubstitutionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationOrderSubstitution;
    procedure SetItemN(index : Integer; value : TFhirMedicationOrderSubstitution);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationOrderSubstitutionList; Overload;
    function Clone : TFhirMedicationOrderSubstitutionList; Overload;
    function GetEnumerator : TFhirMedicationOrderSubstitutionListEnumerator;

    //  Add a FhirMedicationOrderSubstitution to the end of the list.
    function Append : TFhirMedicationOrderSubstitution;

    // Add an already existing FhirMedicationOrderSubstitution to the end of the list.
    procedure AddItem(value : TFhirMedicationOrderSubstitution); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationOrderSubstitution) : Integer;

    // Insert FhirMedicationOrderSubstitution before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationOrderSubstitution;

    // Insert an existing FhirMedicationOrderSubstitution before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationOrderSubstitution);

    // Get the iIndexth FhirMedicationOrderSubstitution. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationOrderSubstitution);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationOrderSubstitution;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMedicationOrderSubstitutions[index : Integer] : TFhirMedicationOrderSubstitution read GetItemN write SetItemN; default;
  End;

  // An order for both supply of the medication and the instructions for administration of the medication to a patient. The resource is called "MedicationOrder" rather than "MedicationPrescription" to generalize the use across inpatient and outpatient settings as well as for care plans, etc.
  TFhirMedicationOrder = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FDateWritten : TFhirDateTime;
    FStatus : TFhirEnum;
    FDateEnded : TFhirDateTime;
    FReasonEnded : TFhirCodeableConcept;
    FPatient : TFhirReference{TFhirPatient};
    FPrescriber : TFhirReference{TFhirPractitioner};
    FEncounter : TFhirReference{TFhirEncounter};
    FReason : TFhirType;
    FNote : TFhirString;
    FMedication : TFhirType;
    FdosageInstructionList : TFhirMedicationOrderDosageInstructionList;
    FDispenseRequest : TFhirMedicationOrderDispenseRequest;
    FSubstitution : TFhirMedicationOrderSubstitution;
    FPriorPrescription : TFhirReference{TFhirMedicationOrder};
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetDateWritten(value : TFhirDateTime);
    Function GetDateWrittenST : TFslDateTime;
    Procedure SetDateWrittenST(value : TFslDateTime);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirMedicationOrderStatusEnum;
    Procedure SetStatusST(value : TFhirMedicationOrderStatusEnum);
    Procedure SetDateEnded(value : TFhirDateTime);
    Function GetDateEndedST : TFslDateTime;
    Procedure SetDateEndedST(value : TFslDateTime);
    Procedure SetReasonEnded(value : TFhirCodeableConcept);
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    Procedure SetPrescriber(value : TFhirReference{TFhirPractitioner});
    Procedure SetEncounter(value : TFhirReference{TFhirEncounter});
    Procedure SetReason(value : TFhirType);
    Procedure SetNote(value : TFhirString);
    Function GetNoteST : String;
    Procedure SetNoteST(value : String);
    Procedure SetMedication(value : TFhirType);
    function GetDosageInstructionList : TFhirMedicationOrderDosageInstructionList;
    function GetHasDosageInstructionList : Boolean;
    Procedure SetDispenseRequest(value : TFhirMedicationOrderDispenseRequest);
    Procedure SetSubstitution(value : TFhirMedicationOrderSubstitution);
    Procedure SetPriorPrescription(value : TFhirReference{TFhirMedicationOrder});

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationOrder; overload;
    function Clone : TFhirMedicationOrder; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // External identifier - one that would be used by another non-FHIR system - for example a re-imbursement system might issue its own id for each prescription that is created.  This is particularly important where FHIR only provides part of an entire workflow process where records have to be tracked through an entire system.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The date (and perhaps time) when the prescription was written.
    property dateWritten : TFslDateTime read GetDateWrittenST write SetDateWrittenST;
    // The date (and perhaps time) when the prescription was written.
    property dateWrittenElement : TFhirDateTime read FDateWritten write SetDateWritten;

    // A code specifying the state of the order.  Generally this will be active or completed state.
    property status : TFhirMedicationOrderStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The date (and perhaps time) when the prescription was stopped.
    property dateEnded : TFslDateTime read GetDateEndedST write SetDateEndedST;
    // The date (and perhaps time) when the prescription was stopped.
    property dateEndedElement : TFhirDateTime read FDateEnded write SetDateEnded;

    // Typed access to The reason why the prescription was stopped, if it was. (defined for API consistency)
    property reasonEnded : TFhirCodeableConcept read FReasonEnded write SetReasonEnded;
    // The reason why the prescription was stopped, if it was.
    property reasonEndedElement : TFhirCodeableConcept read FReasonEnded write SetReasonEnded;

    // Typed access to A link to a resource representing the person to whom the medication will be given. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // A link to a resource representing the person to whom the medication will be given.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Typed access to The healthcare professional responsible for authorizing the prescription. (defined for API consistency)
    property prescriber : TFhirReference{TFhirPractitioner} read FPrescriber write SetPrescriber;
    // The healthcare professional responsible for authorizing the prescription.
    property prescriberElement : TFhirReference{TFhirPractitioner} read FPrescriber write SetPrescriber;

    // Typed access to A link to a resource that identifies the particular occurrence of contact between patient and health care provider. (defined for API consistency)
    property encounter : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;
    // A link to a resource that identifies the particular occurrence of contact between patient and health care provider.
    property encounterElement : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;

    // Typed access to Can be the reason or the indication for writing the prescription. (defined for API consistency)
    property reason : TFhirType read FReason write SetReason;
    // Can be the reason or the indication for writing the prescription.
    property reasonElement : TFhirType read FReason write SetReason;

    // Typed access to Extra information about the prescription that could not be conveyed by the other attributes.
    property note : String read GetNoteST write SetNoteST;
    // Extra information about the prescription that could not be conveyed by the other attributes.
    property noteElement : TFhirString read FNote write SetNote;

    // Typed access to Identifies the medication being administered. This is a link to a resource that represents the medication which may be the details of the medication or simply an attribute carrying a code that identifies the medication from a known list of medications. (defined for API consistency)
    property medication : TFhirType read FMedication write SetMedication;
    // Identifies the medication being administered. This is a link to a resource that represents the medication which may be the details of the medication or simply an attribute carrying a code that identifies the medication from a known list of medications.
    property medicationElement : TFhirType read FMedication write SetMedication;

    // Indicates how the medication is to be used by the patient.
    property dosageInstructionList : TFhirMedicationOrderDosageInstructionList read GetDosageInstructionList;
    property hasDosageInstructionList : boolean read GetHasDosageInstructionList;

    // Typed access to Indicates the specific details for the dispense or medication supply part of a medication order (also known as a Medication Prescription).  Note that this information is NOT always sent with the order.  There may be in some settings (e.g. hospitals) institutional or system support for completing the dispense details in the pharmacy department. (defined for API consistency)
    property dispenseRequest : TFhirMedicationOrderDispenseRequest read FDispenseRequest write SetDispenseRequest;
    // Indicates the specific details for the dispense or medication supply part of a medication order (also known as a Medication Prescription).  Note that this information is NOT always sent with the order.  There may be in some settings (e.g. hospitals) institutional or system support for completing the dispense details in the pharmacy department.
    property dispenseRequestElement : TFhirMedicationOrderDispenseRequest read FDispenseRequest write SetDispenseRequest;

    // Typed access to Indicates whether or not substitution can or should be part of the dispense. In some cases substitution must happen, in other cases substitution must not happen, and in others it does not matter. This block explains the prescriber's intent. If nothing is specified substitution may be done. (defined for API consistency)
    property substitution : TFhirMedicationOrderSubstitution read FSubstitution write SetSubstitution;
    // Indicates whether or not substitution can or should be part of the dispense. In some cases substitution must happen, in other cases substitution must not happen, and in others it does not matter. This block explains the prescriber's intent. If nothing is specified substitution may be done.
    property substitutionElement : TFhirMedicationOrderSubstitution read FSubstitution write SetSubstitution;

    // Typed access to A link to a resource representing an earlier order or prescription that this order supersedes. (defined for API consistency)
    property priorPrescription : TFhirReference{TFhirMedicationOrder} read FPriorPrescription write SetPriorPrescription;
    // A link to a resource representing an earlier order or prescription that this order supersedes.
    property priorPrescriptionElement : TFhirReference{TFhirMedicationOrder} read FPriorPrescription write SetPriorPrescription;

  end;

  TFhirMedicationOrderListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationOrderList;
    function GetCurrent : TFhirMedicationOrder;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationOrderList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationOrder read GetCurrent;
  end;

  TFhirMedicationOrderList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationOrder;
    procedure SetItemN(index : Integer; value : TFhirMedicationOrder);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationOrderList; Overload;
    function Clone : TFhirMedicationOrderList; Overload;
    function GetEnumerator : TFhirMedicationOrderListEnumerator;

    //  Add a FhirMedicationOrder to the end of the list.
    function Append : TFhirMedicationOrder;

    // Add an already existing FhirMedicationOrder to the end of the list.
    procedure AddItem(value : TFhirMedicationOrder); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationOrder) : Integer;

    // Insert FhirMedicationOrder before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationOrder;

    // Insert an existing FhirMedicationOrder before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationOrder);

    // Get the iIndexth FhirMedicationOrder. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationOrder);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationOrder;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMedicationOrders[index : Integer] : TFhirMedicationOrder read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEDICATIONORDER}

{$IFDEF FHIR_MEDICATIONSTATEMENT}

  // Indicates how the medication is/was used by the patient.
  TFhirMedicationStatementDosage = class (TFhirBackboneElement)
  protected
    FText : TFhirString;
    FTiming : TFhirTiming;
    FAsNeeded : TFhirType;
    FSite : TFhirType;
    FRoute : TFhirCodeableConcept;
    FMethod : TFhirCodeableConcept;
    FQuantity : TFhirType;
    FRate : TFhirType;
    FMaxDosePerPeriod : TFhirRatio;
    Procedure SetText(value : TFhirString);
    Function GetTextST : String;
    Procedure SetTextST(value : String);
    Procedure SetTiming(value : TFhirTiming);
    Procedure SetAsNeeded(value : TFhirType);
    Procedure SetSite(value : TFhirType);
    Procedure SetRoute(value : TFhirCodeableConcept);
    Procedure SetMethod(value : TFhirCodeableConcept);
    Procedure SetQuantity(value : TFhirType);
    Procedure SetRate(value : TFhirType);
    Procedure SetMaxDosePerPeriod(value : TFhirRatio);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationStatementDosage; overload;
    function Clone : TFhirMedicationStatementDosage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Free text dosage information as reported about a patient's medication use. When coded dosage information is present, the free text may still be present for display to humans.
    property text : String read GetTextST write SetTextST;
    // Free text dosage information as reported about a patient's medication use. When coded dosage information is present, the free text may still be present for display to humans.
    property textElement : TFhirString read FText write SetText;

    // Typed access to The timing schedule for giving the medication to the patient.  The Schedule data type allows many different expressions, for example.  "Every  8 hours"; "Three times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec 2011:";  "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013". (defined for API consistency)
    property timing : TFhirTiming read FTiming write SetTiming;
    // The timing schedule for giving the medication to the patient.  The Schedule data type allows many different expressions, for example.  "Every  8 hours"; "Three times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec 2011:";  "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013".
    property timingElement : TFhirTiming read FTiming write SetTiming;

    // Typed access to Indicates whether the Medication is only taken when needed within a specific dosing schedule (Boolean option), or it indicates the precondition for taking the Medication (CodeableConcept).    Specifically if 'boolean' datatype is selected, then the following logic applies:  If set to True, this indicates that the medication is only taken when needed, within the specified schedule. (defined for API consistency)
    property asNeeded : TFhirType read FAsNeeded write SetAsNeeded;
    // Indicates whether the Medication is only taken when needed within a specific dosing schedule (Boolean option), or it indicates the precondition for taking the Medication (CodeableConcept).    Specifically if 'boolean' datatype is selected, then the following logic applies:  If set to True, this indicates that the medication is only taken when needed, within the specified schedule.
    property asNeededElement : TFhirType read FAsNeeded write SetAsNeeded;

    // Typed access to A coded specification of or a reference to the anatomic site where the medication first enters the body. (defined for API consistency)
    property site : TFhirType read FSite write SetSite;
    // A coded specification of or a reference to the anatomic site where the medication first enters the body.
    property siteElement : TFhirType read FSite write SetSite;

    // Typed access to A code specifying the route or physiological path of administration of a therapeutic agent into or onto a subject. (defined for API consistency)
    property route : TFhirCodeableConcept read FRoute write SetRoute;
    // A code specifying the route or physiological path of administration of a therapeutic agent into or onto a subject.
    property routeElement : TFhirCodeableConcept read FRoute write SetRoute;

    // Typed access to A coded value indicating the method by which the medication is intended to be or was introduced into or on the body.  This attribute will most often NOT be populated.  It is most commonly used for injections.  For example, Slow Push, Deep IV. (defined for API consistency)
    property method : TFhirCodeableConcept read FMethod write SetMethod;
    // A coded value indicating the method by which the medication is intended to be or was introduced into or on the body.  This attribute will most often NOT be populated.  It is most commonly used for injections.  For example, Slow Push, Deep IV.
    property methodElement : TFhirCodeableConcept read FMethod write SetMethod;

    // Typed access to The amount of therapeutic or other substance given at one administration event. (defined for API consistency)
    property quantity : TFhirType read FQuantity write SetQuantity;
    // The amount of therapeutic or other substance given at one administration event.
    property quantityElement : TFhirType read FQuantity write SetQuantity;

    // Typed access to Identifies the speed with which the medication was or will be introduced into the patient. Typically the rate for an infusion e.g. 100 ml per 1 hour or 100 ml/hr.  May also be expressed as a rate per unit of time e.g. 500 ml per 2 hours.   Currently we do not specify a default of '1' in the denominator, but this is being discussed. Other examples: 200 mcg/min or 200 mcg/1 minute; 1 liter/8 hours. (defined for API consistency)
    property rate : TFhirType read FRate write SetRate;
    // Identifies the speed with which the medication was or will be introduced into the patient. Typically the rate for an infusion e.g. 100 ml per 1 hour or 100 ml/hr.  May also be expressed as a rate per unit of time e.g. 500 ml per 2 hours.   Currently we do not specify a default of '1' in the denominator, but this is being discussed. Other examples: 200 mcg/min or 200 mcg/1 minute; 1 liter/8 hours.
    property rateElement : TFhirType read FRate write SetRate;

    // Typed access to The maximum total quantity of a therapeutic substance that may be administered to a subject over the period of time.  For example, 1000mg in 24 hours. (defined for API consistency)
    property maxDosePerPeriod : TFhirRatio read FMaxDosePerPeriod write SetMaxDosePerPeriod;
    // The maximum total quantity of a therapeutic substance that may be administered to a subject over the period of time.  For example, 1000mg in 24 hours.
    property maxDosePerPeriodElement : TFhirRatio read FMaxDosePerPeriod write SetMaxDosePerPeriod;

  end;

  TFhirMedicationStatementDosageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationStatementDosageList;
    function GetCurrent : TFhirMedicationStatementDosage;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationStatementDosageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationStatementDosage read GetCurrent;
  end;

  TFhirMedicationStatementDosageList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationStatementDosage;
    procedure SetItemN(index : Integer; value : TFhirMedicationStatementDosage);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationStatementDosageList; Overload;
    function Clone : TFhirMedicationStatementDosageList; Overload;
    function GetEnumerator : TFhirMedicationStatementDosageListEnumerator;

    //  Add a FhirMedicationStatementDosage to the end of the list.
    function Append : TFhirMedicationStatementDosage;

    // Add an already existing FhirMedicationStatementDosage to the end of the list.
    procedure AddItem(value : TFhirMedicationStatementDosage); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationStatementDosage) : Integer;

    // Insert FhirMedicationStatementDosage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationStatementDosage;

    // Insert an existing FhirMedicationStatementDosage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationStatementDosage);

    // Get the iIndexth FhirMedicationStatementDosage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationStatementDosage);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationStatementDosage;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMedicationStatementDosages[index : Integer] : TFhirMedicationStatementDosage read GetItemN write SetItemN; default;
  End;

  // A record of a medication that is being consumed by a patient.   A MedicationStatement may indicate that the patient may be taking the medication now, or has taken the medication in the past or will be taking the medication in the future.  The source of this information can be the patient, significant other (such as a family member or spouse), or a clinician.  A common scenario where this information is captured is during the history taking process during a patient visit or stay.   The medication information may come from e.g. the patient's memory, from a prescription bottle,  or from a list of medications the patient, clinician or other party maintains   The primary difference between a medication statement and a medication administration is that the medication administration has complete administration information and is based on actual administration information from the person who administered the medication.  A medication statement is often, if not always, less
    //  specific.  There is no required date/time when the medication was administered, in fact we only know that a source has reported the patient is taking this medication, where details such as time, quantity, or rate or even medication product may be incomplete or missing or less precise.  As stated earlier, the medication statement information may come from the patient's memory, from a prescription bottle or from a list of medications the patient, clinician or other party maintains.  Medication administration is more formal and is not missing detailed information.
  TFhirMedicationStatement = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FPatient : TFhirReference{TFhirPatient};
    FInformationSource : TFhirReference{Resource};
    FDateAsserted : TFhirDateTime;
    FStatus : TFhirEnum;
    FWasNotTaken : TFhirBoolean;
    FreasonNotTakenList : TFhirCodeableConceptList;
    FReasonForUse : TFhirType;
    FEffective : TFhirType;
    FNote : TFhirString;
    FsupportingInformationList : TFhirReferenceList{TFhirReference};
    FMedication : TFhirType;
    FdosageList : TFhirMedicationStatementDosageList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    Procedure SetInformationSource(value : TFhirReference{Resource});
    Procedure SetDateAsserted(value : TFhirDateTime);
    Function GetDateAssertedST : TFslDateTime;
    Procedure SetDateAssertedST(value : TFslDateTime);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirMedicationStatementStatusEnum;
    Procedure SetStatusST(value : TFhirMedicationStatementStatusEnum);
    Procedure SetWasNotTaken(value : TFhirBoolean);
    Function GetWasNotTakenST : Boolean;
    Procedure SetWasNotTakenST(value : Boolean);
    function GetReasonNotTakenList : TFhirCodeableConceptList;
    function GetHasReasonNotTakenList : Boolean;
    Procedure SetReasonForUse(value : TFhirType);
    Procedure SetEffective(value : TFhirType);
    Procedure SetNote(value : TFhirString);
    Function GetNoteST : String;
    Procedure SetNoteST(value : String);
    function GetSupportingInformationList : TFhirReferenceList{TFhirReference};
    function GetHasSupportingInformationList : Boolean;
    Procedure SetMedication(value : TFhirType);
    function GetDosageList : TFhirMedicationStatementDosageList;
    function GetHasDosageList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationStatement; overload;
    function Clone : TFhirMedicationStatement; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // External identifier - FHIR will generate its own internal identifiers (probably URLs) which do not need to be explicitly managed by the resource.  The identifier here is one that would be used by another non-FHIR system - for example an automated medication pump would provide a record each time it operated; an administration while the patient was off the ward might be made with a different system and entered after the event.  Particularly important if these records have to be updated.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The person or animal who is/was taking the medication. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // The person or animal who is/was taking the medication.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Typed access to The person who provided the information about the taking of this medication. (defined for API consistency)
    property informationSource : TFhirReference{Resource} read FInformationSource write SetInformationSource;
    // The person who provided the information about the taking of this medication.
    property informationSourceElement : TFhirReference{Resource} read FInformationSource write SetInformationSource;

    // Typed access to The date when the medication statement was asserted by the information source.
    property dateAsserted : TFslDateTime read GetDateAssertedST write SetDateAssertedST;
    // The date when the medication statement was asserted by the information source.
    property dateAssertedElement : TFhirDateTime read FDateAsserted write SetDateAsserted;

    // A code representing the patient or other source's judgment about the state of the medication used that this statement is about.  Generally this will be active or completed.
    property status : TFhirMedicationStatementStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Set this to true if the record is saying that the medication was NOT taken.
    property wasNotTaken : Boolean read GetWasNotTakenST write SetWasNotTakenST;
    // Set this to true if the record is saying that the medication was NOT taken.
    property wasNotTakenElement : TFhirBoolean read FWasNotTaken write SetWasNotTaken;

    // A code indicating why the medication was not taken.
    property reasonNotTakenList : TFhirCodeableConceptList read GetReasonNotTakenList;
    property hasReasonNotTakenList : boolean read GetHasReasonNotTakenList;

    // Typed access to A reason for why the medication is being/was taken. (defined for API consistency)
    property reasonForUse : TFhirType read FReasonForUse write SetReasonForUse;
    // A reason for why the medication is being/was taken.
    property reasonForUseElement : TFhirType read FReasonForUse write SetReasonForUse;

    // Typed access to The interval of time during which it is being asserted that the patient was taking the medication (or was not taking, when the wasNotGiven element is true). (defined for API consistency)
    property effective : TFhirType read FEffective write SetEffective;
    // The interval of time during which it is being asserted that the patient was taking the medication (or was not taking, when the wasNotGiven element is true).
    property effectiveElement : TFhirType read FEffective write SetEffective;

    // Typed access to Provides extra information about the medication statement that is not conveyed by the other attributes.
    property note : String read GetNoteST write SetNoteST;
    // Provides extra information about the medication statement that is not conveyed by the other attributes.
    property noteElement : TFhirString read FNote write SetNote;

    // Allows linking the MedicationStatement to the underlying MedicationOrder, or to other information that supports the MedicationStatement.
    property supportingInformationList : TFhirReferenceList{TFhirReference} read GetSupportingInformationList;
    property hasSupportingInformationList : boolean read GetHasSupportingInformationList;

    // Typed access to Identifies the medication being administered. This is either a link to a resource representing the details of the medication or a simple attribute carrying a code that identifies the medication from a known list of medications. (defined for API consistency)
    property medication : TFhirType read FMedication write SetMedication;
    // Identifies the medication being administered. This is either a link to a resource representing the details of the medication or a simple attribute carrying a code that identifies the medication from a known list of medications.
    property medicationElement : TFhirType read FMedication write SetMedication;

    // Indicates how the medication is/was used by the patient.
    property dosageList : TFhirMedicationStatementDosageList read GetDosageList;
    property hasDosageList : boolean read GetHasDosageList;

  end;

  TFhirMedicationStatementListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationStatementList;
    function GetCurrent : TFhirMedicationStatement;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationStatementList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationStatement read GetCurrent;
  end;

  TFhirMedicationStatementList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationStatement;
    procedure SetItemN(index : Integer; value : TFhirMedicationStatement);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationStatementList; Overload;
    function Clone : TFhirMedicationStatementList; Overload;
    function GetEnumerator : TFhirMedicationStatementListEnumerator;

    //  Add a FhirMedicationStatement to the end of the list.
    function Append : TFhirMedicationStatement;

    // Add an already existing FhirMedicationStatement to the end of the list.
    procedure AddItem(value : TFhirMedicationStatement); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationStatement) : Integer;

    // Insert FhirMedicationStatement before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationStatement;

    // Insert an existing FhirMedicationStatement before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationStatement);

    // Get the iIndexth FhirMedicationStatement. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationStatement);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationStatement;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMedicationStatements[index : Integer] : TFhirMedicationStatement read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEDICATIONSTATEMENT}

{$IFDEF FHIR_NUTRITIONORDER}

  // Diet given orally in contrast to enteral (tube) feeding.
  TFhirNutritionOrderOralDiet = class (TFhirBackboneElement)
  protected
    Ftype_List : TFhirCodeableConceptList;
    FscheduleList : TFhirTimingList;
    FnutrientList : TFhirNutritionOrderOralDietNutrientList;
    FtextureList : TFhirNutritionOrderOralDietTextureList;
    FfluidConsistencyTypeList : TFhirCodeableConceptList;
    FInstruction : TFhirString;
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    function GetScheduleList : TFhirTimingList;
    function GetHasScheduleList : Boolean;
    function GetNutrientList : TFhirNutritionOrderOralDietNutrientList;
    function GetHasNutrientList : Boolean;
    function GetTextureList : TFhirNutritionOrderOralDietTextureList;
    function GetHasTextureList : Boolean;
    function GetFluidConsistencyTypeList : TFhirCodeableConceptList;
    function GetHasFluidConsistencyTypeList : Boolean;
    Procedure SetInstruction(value : TFhirString);
    Function GetInstructionST : String;
    Procedure SetInstructionST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionOrderOralDiet; overload;
    function Clone : TFhirNutritionOrderOralDiet; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The kind of diet or dietary restriction such as fiber restricted diet or diabetic diet.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // The time period and frequency at which the diet should be given.
    property scheduleList : TFhirTimingList read GetScheduleList;
    property hasScheduleList : boolean read GetHasScheduleList;

    // Class that defines the quantity and type of nutrient modifications required for the oral diet.
    property nutrientList : TFhirNutritionOrderOralDietNutrientList read GetNutrientList;
    property hasNutrientList : boolean read GetHasNutrientList;

    // Class that describes any texture modifications required for the patient to safely consume various types of solid foods.
    property textureList : TFhirNutritionOrderOralDietTextureList read GetTextureList;
    property hasTextureList : boolean read GetHasTextureList;

    // The required consistency (e.g. honey-thick, nectar-thick, thin, thickened.) of liquids or fluids served to the patient.
    property fluidConsistencyTypeList : TFhirCodeableConceptList read GetFluidConsistencyTypeList;
    property hasFluidConsistencyTypeList : boolean read GetHasFluidConsistencyTypeList;

    // Typed access to Free text or additional instructions or information pertaining to the oral diet.
    property instruction : String read GetInstructionST write SetInstructionST;
    // Free text or additional instructions or information pertaining to the oral diet.
    property instructionElement : TFhirString read FInstruction write SetInstruction;

  end;

  TFhirNutritionOrderOralDietListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionOrderOralDietList;
    function GetCurrent : TFhirNutritionOrderOralDiet;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirNutritionOrderOralDietList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionOrderOralDiet read GetCurrent;
  end;

  TFhirNutritionOrderOralDietList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirNutritionOrderOralDiet;
    procedure SetItemN(index : Integer; value : TFhirNutritionOrderOralDiet);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirNutritionOrderOralDietList; Overload;
    function Clone : TFhirNutritionOrderOralDietList; Overload;
    function GetEnumerator : TFhirNutritionOrderOralDietListEnumerator;

    //  Add a FhirNutritionOrderOralDiet to the end of the list.
    function Append : TFhirNutritionOrderOralDiet;

    // Add an already existing FhirNutritionOrderOralDiet to the end of the list.
    procedure AddItem(value : TFhirNutritionOrderOralDiet); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionOrderOralDiet) : Integer;

    // Insert FhirNutritionOrderOralDiet before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionOrderOralDiet;

    // Insert an existing FhirNutritionOrderOralDiet before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionOrderOralDiet);

    // Get the iIndexth FhirNutritionOrderOralDiet. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionOrderOralDiet);

    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionOrderOralDiet;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirNutritionOrderOralDiets[index : Integer] : TFhirNutritionOrderOralDiet read GetItemN write SetItemN; default;
  End;

  // Class that defines the quantity and type of nutrient modifications required for the oral diet.
  TFhirNutritionOrderOralDietNutrient = class (TFhirBackboneElement)
  protected
    FModifier : TFhirCodeableConcept;
    FAmount : TFhirQuantity;
    Procedure SetModifier(value : TFhirCodeableConcept);
    Procedure SetAmount(value : TFhirQuantity);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionOrderOralDietNutrient; overload;
    function Clone : TFhirNutritionOrderOralDietNutrient; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The nutrient that is being modified such as carbohydrate or sodium. (defined for API consistency)
    property modifier : TFhirCodeableConcept read FModifier write SetModifier;
    // The nutrient that is being modified such as carbohydrate or sodium.
    property modifierElement : TFhirCodeableConcept read FModifier write SetModifier;

    // Typed access to The quantity of the specified nutrient to include in diet. (defined for API consistency)
    property amount : TFhirQuantity read FAmount write SetAmount;
    // The quantity of the specified nutrient to include in diet.
    property amountElement : TFhirQuantity read FAmount write SetAmount;

  end;

  TFhirNutritionOrderOralDietNutrientListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionOrderOralDietNutrientList;
    function GetCurrent : TFhirNutritionOrderOralDietNutrient;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirNutritionOrderOralDietNutrientList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionOrderOralDietNutrient read GetCurrent;
  end;

  TFhirNutritionOrderOralDietNutrientList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirNutritionOrderOralDietNutrient;
    procedure SetItemN(index : Integer; value : TFhirNutritionOrderOralDietNutrient);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirNutritionOrderOralDietNutrientList; Overload;
    function Clone : TFhirNutritionOrderOralDietNutrientList; Overload;
    function GetEnumerator : TFhirNutritionOrderOralDietNutrientListEnumerator;

    //  Add a FhirNutritionOrderOralDietNutrient to the end of the list.
    function Append : TFhirNutritionOrderOralDietNutrient;

    // Add an already existing FhirNutritionOrderOralDietNutrient to the end of the list.
    procedure AddItem(value : TFhirNutritionOrderOralDietNutrient); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionOrderOralDietNutrient) : Integer;

    // Insert FhirNutritionOrderOralDietNutrient before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionOrderOralDietNutrient;

    // Insert an existing FhirNutritionOrderOralDietNutrient before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionOrderOralDietNutrient);

    // Get the iIndexth FhirNutritionOrderOralDietNutrient. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionOrderOralDietNutrient);

    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionOrderOralDietNutrient;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirNutritionOrderOralDietNutrients[index : Integer] : TFhirNutritionOrderOralDietNutrient read GetItemN write SetItemN; default;
  End;

  // Class that describes any texture modifications required for the patient to safely consume various types of solid foods.
  TFhirNutritionOrderOralDietTexture = class (TFhirBackboneElement)
  protected
    FModifier : TFhirCodeableConcept;
    FFoodType : TFhirCodeableConcept;
    Procedure SetModifier(value : TFhirCodeableConcept);
    Procedure SetFoodType(value : TFhirCodeableConcept);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionOrderOralDietTexture; overload;
    function Clone : TFhirNutritionOrderOralDietTexture; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Any texture modifications (for solid foods) that should be made, e.g. easy to chew, chopped, ground, and pureed. (defined for API consistency)
    property modifier : TFhirCodeableConcept read FModifier write SetModifier;
    // Any texture modifications (for solid foods) that should be made, e.g. easy to chew, chopped, ground, and pureed.
    property modifierElement : TFhirCodeableConcept read FModifier write SetModifier;

    // Typed access to The food type(s) (e.g. meats, all foods)  that the texture modification applies to.  This could be all foods types. (defined for API consistency)
    property foodType : TFhirCodeableConcept read FFoodType write SetFoodType;
    // The food type(s) (e.g. meats, all foods)  that the texture modification applies to.  This could be all foods types.
    property foodTypeElement : TFhirCodeableConcept read FFoodType write SetFoodType;

  end;

  TFhirNutritionOrderOralDietTextureListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionOrderOralDietTextureList;
    function GetCurrent : TFhirNutritionOrderOralDietTexture;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirNutritionOrderOralDietTextureList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionOrderOralDietTexture read GetCurrent;
  end;

  TFhirNutritionOrderOralDietTextureList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirNutritionOrderOralDietTexture;
    procedure SetItemN(index : Integer; value : TFhirNutritionOrderOralDietTexture);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirNutritionOrderOralDietTextureList; Overload;
    function Clone : TFhirNutritionOrderOralDietTextureList; Overload;
    function GetEnumerator : TFhirNutritionOrderOralDietTextureListEnumerator;

    //  Add a FhirNutritionOrderOralDietTexture to the end of the list.
    function Append : TFhirNutritionOrderOralDietTexture;

    // Add an already existing FhirNutritionOrderOralDietTexture to the end of the list.
    procedure AddItem(value : TFhirNutritionOrderOralDietTexture); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionOrderOralDietTexture) : Integer;

    // Insert FhirNutritionOrderOralDietTexture before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionOrderOralDietTexture;

    // Insert an existing FhirNutritionOrderOralDietTexture before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionOrderOralDietTexture);

    // Get the iIndexth FhirNutritionOrderOralDietTexture. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionOrderOralDietTexture);

    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionOrderOralDietTexture;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirNutritionOrderOralDietTextures[index : Integer] : TFhirNutritionOrderOralDietTexture read GetItemN write SetItemN; default;
  End;

  // Oral nutritional products given in order to add further nutritional value to the patient's diet.
  TFhirNutritionOrderSupplement = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FProductName : TFhirString;
    FscheduleList : TFhirTimingList;
    FQuantity : TFhirQuantity;
    FInstruction : TFhirString;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetProductName(value : TFhirString);
    Function GetProductNameST : String;
    Procedure SetProductNameST(value : String);
    function GetScheduleList : TFhirTimingList;
    function GetHasScheduleList : Boolean;
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetInstruction(value : TFhirString);
    Function GetInstructionST : String;
    Procedure SetInstructionST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionOrderSupplement; overload;
    function Clone : TFhirNutritionOrderSupplement; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The kind of nutritional supplement product required such as a high protein or pediatric clear liquid supplement. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The kind of nutritional supplement product required such as a high protein or pediatric clear liquid supplement.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The product or brand name of the nutritional supplement such as "Acme Protein Shake".
    property productName : String read GetProductNameST write SetProductNameST;
    // The product or brand name of the nutritional supplement such as "Acme Protein Shake".
    property productNameElement : TFhirString read FProductName write SetProductName;

    // The time period and frequency at which the supplement(s) should be given.
    property scheduleList : TFhirTimingList read GetScheduleList;
    property hasScheduleList : boolean read GetHasScheduleList;

    // Typed access to The amount of the nutritional supplement to be given. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The amount of the nutritional supplement to be given.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to Free text or additional instructions or information pertaining to the oral supplement.
    property instruction : String read GetInstructionST write SetInstructionST;
    // Free text or additional instructions or information pertaining to the oral supplement.
    property instructionElement : TFhirString read FInstruction write SetInstruction;

  end;

  TFhirNutritionOrderSupplementListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionOrderSupplementList;
    function GetCurrent : TFhirNutritionOrderSupplement;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirNutritionOrderSupplementList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionOrderSupplement read GetCurrent;
  end;

  TFhirNutritionOrderSupplementList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirNutritionOrderSupplement;
    procedure SetItemN(index : Integer; value : TFhirNutritionOrderSupplement);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirNutritionOrderSupplementList; Overload;
    function Clone : TFhirNutritionOrderSupplementList; Overload;
    function GetEnumerator : TFhirNutritionOrderSupplementListEnumerator;

    //  Add a FhirNutritionOrderSupplement to the end of the list.
    function Append : TFhirNutritionOrderSupplement;

    // Add an already existing FhirNutritionOrderSupplement to the end of the list.
    procedure AddItem(value : TFhirNutritionOrderSupplement); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionOrderSupplement) : Integer;

    // Insert FhirNutritionOrderSupplement before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionOrderSupplement;

    // Insert an existing FhirNutritionOrderSupplement before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionOrderSupplement);

    // Get the iIndexth FhirNutritionOrderSupplement. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionOrderSupplement);

    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionOrderSupplement;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirNutritionOrderSupplements[index : Integer] : TFhirNutritionOrderSupplement read GetItemN write SetItemN; default;
  End;

  // Feeding provided through the gastrointestinal tract via a tube, catheter, or stoma that delivers nutrition distal to the oral cavity.
  TFhirNutritionOrderEnteralFormula = class (TFhirBackboneElement)
  protected
    FBaseFormulaType : TFhirCodeableConcept;
    FBaseFormulaProductName : TFhirString;
    FAdditiveType : TFhirCodeableConcept;
    FAdditiveProductName : TFhirString;
    FCaloricDensity : TFhirQuantity;
    FRouteofAdministration : TFhirCodeableConcept;
    FadministrationList : TFhirNutritionOrderEnteralFormulaAdministrationList;
    FMaxVolumeToDeliver : TFhirQuantity;
    FAdministrationInstruction : TFhirString;
    Procedure SetBaseFormulaType(value : TFhirCodeableConcept);
    Procedure SetBaseFormulaProductName(value : TFhirString);
    Function GetBaseFormulaProductNameST : String;
    Procedure SetBaseFormulaProductNameST(value : String);
    Procedure SetAdditiveType(value : TFhirCodeableConcept);
    Procedure SetAdditiveProductName(value : TFhirString);
    Function GetAdditiveProductNameST : String;
    Procedure SetAdditiveProductNameST(value : String);
    Procedure SetCaloricDensity(value : TFhirQuantity);
    Procedure SetRouteofAdministration(value : TFhirCodeableConcept);
    function GetAdministrationList : TFhirNutritionOrderEnteralFormulaAdministrationList;
    function GetHasAdministrationList : Boolean;
    Procedure SetMaxVolumeToDeliver(value : TFhirQuantity);
    Procedure SetAdministrationInstruction(value : TFhirString);
    Function GetAdministrationInstructionST : String;
    Procedure SetAdministrationInstructionST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionOrderEnteralFormula; overload;
    function Clone : TFhirNutritionOrderEnteralFormula; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The type of enteral or infant formula such as an adult standard formula with fiber or a soy-based infant formula. (defined for API consistency)
    property baseFormulaType : TFhirCodeableConcept read FBaseFormulaType write SetBaseFormulaType;
    // The type of enteral or infant formula such as an adult standard formula with fiber or a soy-based infant formula.
    property baseFormulaTypeElement : TFhirCodeableConcept read FBaseFormulaType write SetBaseFormulaType;

    // Typed access to The product or brand name of the enteral or infant formula product such as "ACME Adult Standard Formula".
    property baseFormulaProductName : String read GetBaseFormulaProductNameST write SetBaseFormulaProductNameST;
    // The product or brand name of the enteral or infant formula product such as "ACME Adult Standard Formula".
    property baseFormulaProductNameElement : TFhirString read FBaseFormulaProductName write SetBaseFormulaProductName;

    // Typed access to Indicates the type of modular component such as protein, carbohydrate, fat or fiber to be provided in addition to or mixed with the base formula. (defined for API consistency)
    property additiveType : TFhirCodeableConcept read FAdditiveType write SetAdditiveType;
    // Indicates the type of modular component such as protein, carbohydrate, fat or fiber to be provided in addition to or mixed with the base formula.
    property additiveTypeElement : TFhirCodeableConcept read FAdditiveType write SetAdditiveType;

    // Typed access to The product or brand name of the type of modular component to be added to the formula.
    property additiveProductName : String read GetAdditiveProductNameST write SetAdditiveProductNameST;
    // The product or brand name of the type of modular component to be added to the formula.
    property additiveProductNameElement : TFhirString read FAdditiveProductName write SetAdditiveProductName;

    // Typed access to The amount of energy (Calories) that the formula should provide per specified volume, typically per mL or fluid oz.  For example, an infant may require a formula that provides 24 Calories per fluid ounce or an adult may require an enteral formula that provides 1.5 Calorie/mL. (defined for API consistency)
    property caloricDensity : TFhirQuantity read FCaloricDensity write SetCaloricDensity;
    // The amount of energy (Calories) that the formula should provide per specified volume, typically per mL or fluid oz.  For example, an infant may require a formula that provides 24 Calories per fluid ounce or an adult may require an enteral formula that provides 1.5 Calorie/mL.
    property caloricDensityElement : TFhirQuantity read FCaloricDensity write SetCaloricDensity;

    // Typed access to The route or physiological path of administration into the patient's gastrointestinal  tract for purposes of providing the formula feeding, e.g. nasogastric tube. (defined for API consistency)
    property routeofAdministration : TFhirCodeableConcept read FRouteofAdministration write SetRouteofAdministration;
    // The route or physiological path of administration into the patient's gastrointestinal  tract for purposes of providing the formula feeding, e.g. nasogastric tube.
    property routeofAdministrationElement : TFhirCodeableConcept read FRouteofAdministration write SetRouteofAdministration;

    // Formula administration instructions as structured data.  This repeating structure allows for changing the administration rate or volume over time for both bolus and continuous feeding.  An example of this would be an instruction to increase the rate of continuous feeding every 2 hours.
    property administrationList : TFhirNutritionOrderEnteralFormulaAdministrationList read GetAdministrationList;
    property hasAdministrationList : boolean read GetHasAdministrationList;

    // Typed access to The maximum total quantity of formula that may be administered to a subject over the period of time, e.g. 1440 mL over 24 hours. (defined for API consistency)
    property maxVolumeToDeliver : TFhirQuantity read FMaxVolumeToDeliver write SetMaxVolumeToDeliver;
    // The maximum total quantity of formula that may be administered to a subject over the period of time, e.g. 1440 mL over 24 hours.
    property maxVolumeToDeliverElement : TFhirQuantity read FMaxVolumeToDeliver write SetMaxVolumeToDeliver;

    // Typed access to Free text formula administration, feeding instructions or additional instructions or information.
    property administrationInstruction : String read GetAdministrationInstructionST write SetAdministrationInstructionST;
    // Free text formula administration, feeding instructions or additional instructions or information.
    property administrationInstructionElement : TFhirString read FAdministrationInstruction write SetAdministrationInstruction;

  end;

  TFhirNutritionOrderEnteralFormulaListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionOrderEnteralFormulaList;
    function GetCurrent : TFhirNutritionOrderEnteralFormula;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirNutritionOrderEnteralFormulaList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionOrderEnteralFormula read GetCurrent;
  end;

  TFhirNutritionOrderEnteralFormulaList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirNutritionOrderEnteralFormula;
    procedure SetItemN(index : Integer; value : TFhirNutritionOrderEnteralFormula);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirNutritionOrderEnteralFormulaList; Overload;
    function Clone : TFhirNutritionOrderEnteralFormulaList; Overload;
    function GetEnumerator : TFhirNutritionOrderEnteralFormulaListEnumerator;

    //  Add a FhirNutritionOrderEnteralFormula to the end of the list.
    function Append : TFhirNutritionOrderEnteralFormula;

    // Add an already existing FhirNutritionOrderEnteralFormula to the end of the list.
    procedure AddItem(value : TFhirNutritionOrderEnteralFormula); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionOrderEnteralFormula) : Integer;

    // Insert FhirNutritionOrderEnteralFormula before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionOrderEnteralFormula;

    // Insert an existing FhirNutritionOrderEnteralFormula before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionOrderEnteralFormula);

    // Get the iIndexth FhirNutritionOrderEnteralFormula. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionOrderEnteralFormula);

    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionOrderEnteralFormula;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirNutritionOrderEnteralFormulas[index : Integer] : TFhirNutritionOrderEnteralFormula read GetItemN write SetItemN; default;
  End;

  // Formula administration instructions as structured data.  This repeating structure allows for changing the administration rate or volume over time for both bolus and continuous feeding.  An example of this would be an instruction to increase the rate of continuous feeding every 2 hours.
  TFhirNutritionOrderEnteralFormulaAdministration = class (TFhirBackboneElement)
  protected
    FSchedule : TFhirTiming;
    FQuantity : TFhirQuantity;
    FRate : TFhirType;
    Procedure SetSchedule(value : TFhirTiming);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetRate(value : TFhirType);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionOrderEnteralFormulaAdministration; overload;
    function Clone : TFhirNutritionOrderEnteralFormulaAdministration; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The time period and frequency at which the enteral formula should be delivered to the patient. (defined for API consistency)
    property schedule : TFhirTiming read FSchedule write SetSchedule;
    // The time period and frequency at which the enteral formula should be delivered to the patient.
    property scheduleElement : TFhirTiming read FSchedule write SetSchedule;

    // Typed access to The volume of formula to provide to the patient per the specified administration schedule. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The volume of formula to provide to the patient per the specified administration schedule.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to The rate of administration of formula via a feeding pump, e.g. 60 mL per hour, according to the specified schedule. (defined for API consistency)
    property rate : TFhirType read FRate write SetRate;
    // The rate of administration of formula via a feeding pump, e.g. 60 mL per hour, according to the specified schedule.
    property rateElement : TFhirType read FRate write SetRate;

  end;

  TFhirNutritionOrderEnteralFormulaAdministrationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionOrderEnteralFormulaAdministrationList;
    function GetCurrent : TFhirNutritionOrderEnteralFormulaAdministration;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirNutritionOrderEnteralFormulaAdministrationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionOrderEnteralFormulaAdministration read GetCurrent;
  end;

  TFhirNutritionOrderEnteralFormulaAdministrationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirNutritionOrderEnteralFormulaAdministration;
    procedure SetItemN(index : Integer; value : TFhirNutritionOrderEnteralFormulaAdministration);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirNutritionOrderEnteralFormulaAdministrationList; Overload;
    function Clone : TFhirNutritionOrderEnteralFormulaAdministrationList; Overload;
    function GetEnumerator : TFhirNutritionOrderEnteralFormulaAdministrationListEnumerator;

    //  Add a FhirNutritionOrderEnteralFormulaAdministration to the end of the list.
    function Append : TFhirNutritionOrderEnteralFormulaAdministration;

    // Add an already existing FhirNutritionOrderEnteralFormulaAdministration to the end of the list.
    procedure AddItem(value : TFhirNutritionOrderEnteralFormulaAdministration); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionOrderEnteralFormulaAdministration) : Integer;

    // Insert FhirNutritionOrderEnteralFormulaAdministration before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionOrderEnteralFormulaAdministration;

    // Insert an existing FhirNutritionOrderEnteralFormulaAdministration before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionOrderEnteralFormulaAdministration);

    // Get the iIndexth FhirNutritionOrderEnteralFormulaAdministration. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionOrderEnteralFormulaAdministration);

    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionOrderEnteralFormulaAdministration;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirNutritionOrderEnteralFormulaAdministrations[index : Integer] : TFhirNutritionOrderEnteralFormulaAdministration read GetItemN write SetItemN; default;
  End;

  // A request to supply a diet, formula feeding (enteral) or oral nutritional supplement to a patient/resident.
  TFhirNutritionOrder = class (TFhirDomainResource)
  protected
    FPatient : TFhirReference{TFhirPatient};
    FOrderer : TFhirReference{TFhirPractitioner};
    FidentifierList : TFhirIdentifierList;
    FEncounter : TFhirReference{TFhirEncounter};
    FDateTime : TFhirDateTime;
    FStatus : TFhirEnum;
    FallergyIntoleranceList : TFhirReferenceList{TFhirAllergyIntolerance};
    FfoodPreferenceModifierList : TFhirCodeableConceptList;
    FexcludeFoodModifierList : TFhirCodeableConceptList;
    FOralDiet : TFhirNutritionOrderOralDiet;
    FsupplementList : TFhirNutritionOrderSupplementList;
    FEnteralFormula : TFhirNutritionOrderEnteralFormula;
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    Procedure SetOrderer(value : TFhirReference{TFhirPractitioner});
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetEncounter(value : TFhirReference{TFhirEncounter});
    Procedure SetDateTime(value : TFhirDateTime);
    Function GetDateTimeST : TFslDateTime;
    Procedure SetDateTimeST(value : TFslDateTime);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirNutritionOrderStatusEnum;
    Procedure SetStatusST(value : TFhirNutritionOrderStatusEnum);
    function GetAllergyIntoleranceList : TFhirReferenceList{TFhirAllergyIntolerance};
    function GetHasAllergyIntoleranceList : Boolean;
    function GetFoodPreferenceModifierList : TFhirCodeableConceptList;
    function GetHasFoodPreferenceModifierList : Boolean;
    function GetExcludeFoodModifierList : TFhirCodeableConceptList;
    function GetHasExcludeFoodModifierList : Boolean;
    Procedure SetOralDiet(value : TFhirNutritionOrderOralDiet);
    function GetSupplementList : TFhirNutritionOrderSupplementList;
    function GetHasSupplementList : Boolean;
    Procedure SetEnteralFormula(value : TFhirNutritionOrderEnteralFormula);

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionOrder; overload;
    function Clone : TFhirNutritionOrder; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The person (patient) who needs the nutrition order for an oral diet, nutritional supplement and/or enteral or formula feeding. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // The person (patient) who needs the nutrition order for an oral diet, nutritional supplement and/or enteral or formula feeding.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Typed access to The practitioner that holds legal responsibility for ordering the diet, nutritional supplement, or formula feedings. (defined for API consistency)
    property orderer : TFhirReference{TFhirPractitioner} read FOrderer write SetOrderer;
    // The practitioner that holds legal responsibility for ordering the diet, nutritional supplement, or formula feedings.
    property ordererElement : TFhirReference{TFhirPractitioner} read FOrderer write SetOrderer;

    // Identifiers assigned to this order by the order sender or by the order receiver.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to An encounter that provides additional information about the healthcare context in which this request is made. (defined for API consistency)
    property encounter : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;
    // An encounter that provides additional information about the healthcare context in which this request is made.
    property encounterElement : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;

    // Typed access to The date and time that this nutrition order was requested.
    property dateTime : TFslDateTime read GetDateTimeST write SetDateTimeST;
    // The date and time that this nutrition order was requested.
    property dateTimeElement : TFhirDateTime read FDateTime write SetDateTime;

    // The workflow status of the nutrition order/request.
    property status : TFhirNutritionOrderStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // A link to a record of allergies or intolerances  which should be included in the nutrition order.
    property allergyIntoleranceList : TFhirReferenceList{TFhirAllergyIntolerance} read GetAllergyIntoleranceList;
    property hasAllergyIntoleranceList : boolean read GetHasAllergyIntoleranceList;

    // This modifier is used to convey order-specific modifiers about the type of food that should be given. These can be derived from patient allergies, intolerances, or preferences such as Halal, Vegan or Kosher. This modifier applies to the entire nutrition order inclusive of the oral diet, nutritional supplements and enteral formula feedings.
    property foodPreferenceModifierList : TFhirCodeableConceptList read GetFoodPreferenceModifierList;
    property hasFoodPreferenceModifierList : boolean read GetHasFoodPreferenceModifierList;

    // This modifier is used to convey order-specific modifiers about the type of food that should NOT be given. These can be derived from patient allergies, intolerances, or preferences such as No Red Meat, No Soy or No Wheat or  Gluten-Free.  While it should not be necessary to repeat allergy or intolerance information captured in the referenced allergyIntolerance resource in the excludeFoodModifier, this element may be used to convey additional specificity related to foods that should be eliminated from the patient?s diet for any reason.  This modifier applies to the entire nutrition order inclusive of the oral diet, nutritional supplements and enteral formula feedings.
    property excludeFoodModifierList : TFhirCodeableConceptList read GetExcludeFoodModifierList;
    property hasExcludeFoodModifierList : boolean read GetHasExcludeFoodModifierList;

    // Typed access to Diet given orally in contrast to enteral (tube) feeding. (defined for API consistency)
    property oralDiet : TFhirNutritionOrderOralDiet read FOralDiet write SetOralDiet;
    // Diet given orally in contrast to enteral (tube) feeding.
    property oralDietElement : TFhirNutritionOrderOralDiet read FOralDiet write SetOralDiet;

    // Oral nutritional products given in order to add further nutritional value to the patient's diet.
    property supplementList : TFhirNutritionOrderSupplementList read GetSupplementList;
    property hasSupplementList : boolean read GetHasSupplementList;

    // Typed access to Feeding provided through the gastrointestinal tract via a tube, catheter, or stoma that delivers nutrition distal to the oral cavity. (defined for API consistency)
    property enteralFormula : TFhirNutritionOrderEnteralFormula read FEnteralFormula write SetEnteralFormula;
    // Feeding provided through the gastrointestinal tract via a tube, catheter, or stoma that delivers nutrition distal to the oral cavity.
    property enteralFormulaElement : TFhirNutritionOrderEnteralFormula read FEnteralFormula write SetEnteralFormula;

  end;

  TFhirNutritionOrderListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionOrderList;
    function GetCurrent : TFhirNutritionOrder;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirNutritionOrderList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionOrder read GetCurrent;
  end;

  TFhirNutritionOrderList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirNutritionOrder;
    procedure SetItemN(index : Integer; value : TFhirNutritionOrder);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirNutritionOrderList; Overload;
    function Clone : TFhirNutritionOrderList; Overload;
    function GetEnumerator : TFhirNutritionOrderListEnumerator;

    //  Add a FhirNutritionOrder to the end of the list.
    function Append : TFhirNutritionOrder;

    // Add an already existing FhirNutritionOrder to the end of the list.
    procedure AddItem(value : TFhirNutritionOrder); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionOrder) : Integer;

    // Insert FhirNutritionOrder before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionOrder;

    // Insert an existing FhirNutritionOrder before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionOrder);

    // Get the iIndexth FhirNutritionOrder. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionOrder);

    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionOrder;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirNutritionOrders[index : Integer] : TFhirNutritionOrder read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_NUTRITIONORDER}

{$IFDEF FHIR_OBSERVATION}

  // Guidance on how to interpret the value by comparison to a normal or recommended range.
  TFhirObservationReferenceRange = class (TFhirBackboneElement)
  protected
    FLow : TFhirQuantity;
    FHigh : TFhirQuantity;
    FMeaning : TFhirCodeableConcept;
    FAge : TFhirRange;
    FText : TFhirString;
    Procedure SetLow(value : TFhirQuantity);
    Procedure SetHigh(value : TFhirQuantity);
    Procedure SetMeaning(value : TFhirCodeableConcept);
    Procedure SetAge(value : TFhirRange);
    Procedure SetText(value : TFhirString);
    Function GetTextST : String;
    Procedure SetTextST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirObservationReferenceRange; overload;
    function Clone : TFhirObservationReferenceRange; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The value of the low bound of the reference range.  The low bound of the reference range endpoint is inclusive of the value (e.g.  reference range is >=5 - <=9).   If the low bound is omitted,  it is assumed to be meaningless (e.g. reference range is <=2.3). (defined for API consistency)
    property low : TFhirQuantity read FLow write SetLow;
    // The value of the low bound of the reference range.  The low bound of the reference range endpoint is inclusive of the value (e.g.  reference range is >=5 - <=9).   If the low bound is omitted,  it is assumed to be meaningless (e.g. reference range is <=2.3).
    property lowElement : TFhirQuantity read FLow write SetLow;

    // Typed access to The value of the high bound of the reference range.  The high bound of the reference range endpoint is inclusive of the value (e.g.  reference range is >=5 - <=9).   If the high bound is omitted,  it is assumed to be meaningless (e.g. reference range is >= 2.3). (defined for API consistency)
    property high : TFhirQuantity read FHigh write SetHigh;
    // The value of the high bound of the reference range.  The high bound of the reference range endpoint is inclusive of the value (e.g.  reference range is >=5 - <=9).   If the high bound is omitted,  it is assumed to be meaningless (e.g. reference range is >= 2.3).
    property highElement : TFhirQuantity read FHigh write SetHigh;

    // Typed access to Code for the meaning of the reference range. (defined for API consistency)
    property meaning : TFhirCodeableConcept read FMeaning write SetMeaning;
    // Code for the meaning of the reference range.
    property meaningElement : TFhirCodeableConcept read FMeaning write SetMeaning;

    // Typed access to The age at which this reference range is applicable. This is a neonatal age (e.g. number of weeks at term) if the meaning says so. (defined for API consistency)
    property age : TFhirRange read FAge write SetAge;
    // The age at which this reference range is applicable. This is a neonatal age (e.g. number of weeks at term) if the meaning says so.
    property ageElement : TFhirRange read FAge write SetAge;

    // Typed access to Text based reference range in an observation which may be used when a quantitative range is not appropriate for an observation.  An example would be a reference value of "Negative" or a list or table of 'normals'.
    property text : String read GetTextST write SetTextST;
    // Text based reference range in an observation which may be used when a quantitative range is not appropriate for an observation.  An example would be a reference value of "Negative" or a list or table of 'normals'.
    property textElement : TFhirString read FText write SetText;

  end;

  TFhirObservationReferenceRangeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirObservationReferenceRangeList;
    function GetCurrent : TFhirObservationReferenceRange;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirObservationReferenceRangeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirObservationReferenceRange read GetCurrent;
  end;

  TFhirObservationReferenceRangeList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirObservationReferenceRange;
    procedure SetItemN(index : Integer; value : TFhirObservationReferenceRange);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirObservationReferenceRangeList; Overload;
    function Clone : TFhirObservationReferenceRangeList; Overload;
    function GetEnumerator : TFhirObservationReferenceRangeListEnumerator;

    //  Add a FhirObservationReferenceRange to the end of the list.
    function Append : TFhirObservationReferenceRange;

    // Add an already existing FhirObservationReferenceRange to the end of the list.
    procedure AddItem(value : TFhirObservationReferenceRange); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirObservationReferenceRange) : Integer;

    // Insert FhirObservationReferenceRange before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirObservationReferenceRange;

    // Insert an existing FhirObservationReferenceRange before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirObservationReferenceRange);

    // Get the iIndexth FhirObservationReferenceRange. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirObservationReferenceRange);

    // The number of items in the collection
    function Item(index : Integer) : TFhirObservationReferenceRange;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirObservationReferenceRanges[index : Integer] : TFhirObservationReferenceRange read GetItemN write SetItemN; default;
  End;

  // A  reference to another resource (usually another Observation but could  also be a QuestionnaireAnswer) whose relationship is defined by the relationship type code.
  TFhirObservationRelated = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FTarget : TFhirReference{Resource};
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirObservationRelationshiptypesEnum;
    Procedure SetType_ST(value : TFhirObservationRelationshiptypesEnum);
    Procedure SetTarget(value : TFhirReference{Resource});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirObservationRelated; overload;
    function Clone : TFhirObservationRelated; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A code specifying the kind of relationship that exists with the target resource.
    property type_ : TFhirObservationRelationshiptypesEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to A reference to the observation or [[[QuestionnaireResponse]]] resource that is related to this observation. (defined for API consistency)
    property target : TFhirReference{Resource} read FTarget write SetTarget;
    // A reference to the observation or [[[QuestionnaireResponse]]] resource that is related to this observation.
    property targetElement : TFhirReference{Resource} read FTarget write SetTarget;

  end;

  TFhirObservationRelatedListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirObservationRelatedList;
    function GetCurrent : TFhirObservationRelated;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirObservationRelatedList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirObservationRelated read GetCurrent;
  end;

  TFhirObservationRelatedList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirObservationRelated;
    procedure SetItemN(index : Integer; value : TFhirObservationRelated);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirObservationRelatedList; Overload;
    function Clone : TFhirObservationRelatedList; Overload;
    function GetEnumerator : TFhirObservationRelatedListEnumerator;

    //  Add a FhirObservationRelated to the end of the list.
    function Append : TFhirObservationRelated;

    // Add an already existing FhirObservationRelated to the end of the list.
    procedure AddItem(value : TFhirObservationRelated); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirObservationRelated) : Integer;

    // Insert FhirObservationRelated before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirObservationRelated;

    // Insert an existing FhirObservationRelated before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirObservationRelated);

    // Get the iIndexth FhirObservationRelated. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirObservationRelated);

    // The number of items in the collection
    function Item(index : Integer) : TFhirObservationRelated;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirObservationRelateds[index : Integer] : TFhirObservationRelated read GetItemN write SetItemN; default;
  End;

  // Some observations have multiple component observations.  These component observations are expressed as separate code value pairs that share the same attributes.  Examples include systolic and diastolic component observations for blood pressure measurement and multiple component observations for genetics observations.
  TFhirObservationComponent = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FValue : TFhirType;
    FDataAbsentReason : TFhirCodeableConcept;
    FreferenceRangeList : TFhirObservationReferenceRangeList;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetValue(value : TFhirType);
    Procedure SetDataAbsentReason(value : TFhirCodeableConcept);
    function GetReferenceRangeList : TFhirObservationReferenceRangeList;
    function GetHasReferenceRangeList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirObservationComponent; overload;
    function Clone : TFhirObservationComponent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Describes what was observed. Sometimes this is called the observation "code". (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Describes what was observed. Sometimes this is called the observation "code".
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The information determined as a result of making the observation, if the information has a simple value. (defined for API consistency)
    property value : TFhirType read FValue write SetValue;
    // The information determined as a result of making the observation, if the information has a simple value.
    property valueElement : TFhirType read FValue write SetValue;

    // Typed access to Provides a reason why the expected value in the element Observation.value[x] is missing. (defined for API consistency)
    property dataAbsentReason : TFhirCodeableConcept read FDataAbsentReason write SetDataAbsentReason;
    // Provides a reason why the expected value in the element Observation.value[x] is missing.
    property dataAbsentReasonElement : TFhirCodeableConcept read FDataAbsentReason write SetDataAbsentReason;

    // Guidance on how to interpret the value by comparison to a normal or recommended range.
    property referenceRangeList : TFhirObservationReferenceRangeList read GetReferenceRangeList;
    property hasReferenceRangeList : boolean read GetHasReferenceRangeList;

  end;

  TFhirObservationComponentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirObservationComponentList;
    function GetCurrent : TFhirObservationComponent;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirObservationComponentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirObservationComponent read GetCurrent;
  end;

  TFhirObservationComponentList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirObservationComponent;
    procedure SetItemN(index : Integer; value : TFhirObservationComponent);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirObservationComponentList; Overload;
    function Clone : TFhirObservationComponentList; Overload;
    function GetEnumerator : TFhirObservationComponentListEnumerator;

    //  Add a FhirObservationComponent to the end of the list.
    function Append : TFhirObservationComponent;

    // Add an already existing FhirObservationComponent to the end of the list.
    procedure AddItem(value : TFhirObservationComponent); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirObservationComponent) : Integer;

    // Insert FhirObservationComponent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirObservationComponent;

    // Insert an existing FhirObservationComponent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirObservationComponent);

    // Get the iIndexth FhirObservationComponent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirObservationComponent);

    // The number of items in the collection
    function Item(index : Integer) : TFhirObservationComponent;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirObservationComponents[index : Integer] : TFhirObservationComponent read GetItemN write SetItemN; default;
  End;

  // Measurements and simple assertions made about a patient, device or other subject.
  TFhirObservation = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FCategory : TFhirCodeableConcept;
    FCode : TFhirCodeableConcept;
    FSubject : TFhirReference{Resource};
    FEncounter : TFhirReference{TFhirEncounter};
    FEffective : TFhirType;
    FIssued : TFhirInstant;
    FperformerList : TFhirReferenceList{Resource};
    FValue : TFhirType;
    FDataAbsentReason : TFhirCodeableConcept;
    FInterpretation : TFhirCodeableConcept;
    FComments : TFhirString;
    FBodySite : TFhirCodeableConcept;
    FMethod : TFhirCodeableConcept;
    FSpecimen : TFhirReference{TFhirSpecimen};
    FDevice : TFhirReference{Resource};
    FreferenceRangeList : TFhirObservationReferenceRangeList;
    FrelatedList : TFhirObservationRelatedList;
    FcomponentList : TFhirObservationComponentList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirObservationStatusEnum;
    Procedure SetStatusST(value : TFhirObservationStatusEnum);
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetSubject(value : TFhirReference{Resource});
    Procedure SetEncounter(value : TFhirReference{TFhirEncounter});
    Procedure SetEffective(value : TFhirType);
    Procedure SetIssued(value : TFhirInstant);
    Function GetIssuedST : TFslDateTime;
    Procedure SetIssuedST(value : TFslDateTime);
    function GetPerformerList : TFhirReferenceList{Resource};
    function GetHasPerformerList : Boolean;
    Procedure SetValue(value : TFhirType);
    Procedure SetDataAbsentReason(value : TFhirCodeableConcept);
    Procedure SetInterpretation(value : TFhirCodeableConcept);
    Procedure SetComments(value : TFhirString);
    Function GetCommentsST : String;
    Procedure SetCommentsST(value : String);
    Procedure SetBodySite(value : TFhirCodeableConcept);
    Procedure SetMethod(value : TFhirCodeableConcept);
    Procedure SetSpecimen(value : TFhirReference{TFhirSpecimen});
    Procedure SetDevice(value : TFhirReference{Resource});
    function GetReferenceRangeList : TFhirObservationReferenceRangeList;
    function GetHasReferenceRangeList : Boolean;
    function GetRelatedList : TFhirObservationRelatedList;
    function GetHasRelatedList : Boolean;
    function GetComponentList : TFhirObservationComponentList;
    function GetHasComponentList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirObservation; overload;
    function Clone : TFhirObservation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A unique identifier for the simple observation instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the result value.
    property status : TFhirObservationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A code that classifies the general type of observation being made.  This is used  for searching, sorting and display purposes. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // A code that classifies the general type of observation being made.  This is used  for searching, sorting and display purposes.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to Describes what was observed. Sometimes this is called the observation "name". (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Describes what was observed. Sometimes this is called the observation "name".
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The patient, or group of patients, location, or device whose characteristics (direct or indirect) are described by the observation and into whose record the observation is placed.  Comments: Indirect characteristics may be those of a specimen, fetus, donor,  other observer (for example a relative or EMT), or any observation made about the subject. (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // The patient, or group of patients, location, or device whose characteristics (direct or indirect) are described by the observation and into whose record the observation is placed.  Comments: Indirect characteristics may be those of a specimen, fetus, donor,  other observer (for example a relative or EMT), or any observation made about the subject.
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // Typed access to The healthcare event  (e.g. a patient and healthcare provider interaction) during which this observation is made. (defined for API consistency)
    property encounter : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;
    // The healthcare event  (e.g. a patient and healthcare provider interaction) during which this observation is made.
    property encounterElement : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;

    // Typed access to The time or time-period the observed value is asserted as being true. For biological subjects - e.g. human patients - this is usually called the "physiologically relevant time". This is usually either the time of the procedure or of specimen collection, but very often the source of the date/time is not known, only the date/time itself. (defined for API consistency)
    property effective : TFhirType read FEffective write SetEffective;
    // The time or time-period the observed value is asserted as being true. For biological subjects - e.g. human patients - this is usually called the "physiologically relevant time". This is usually either the time of the procedure or of specimen collection, but very often the source of the date/time is not known, only the date/time itself.
    property effectiveElement : TFhirType read FEffective write SetEffective;

    // Typed access to The date and time this observation was made available to providers, typically after the results have been reviewed and verified.
    property issued : TFslDateTime read GetIssuedST write SetIssuedST;
    // The date and time this observation was made available to providers, typically after the results have been reviewed and verified.
    property issuedElement : TFhirInstant read FIssued write SetIssued;

    // Who was responsible for asserting the observed value as "true".
    property performerList : TFhirReferenceList{Resource} read GetPerformerList;
    property hasPerformerList : boolean read GetHasPerformerList;

    // Typed access to The information determined as a result of making the observation, if the information has a simple value. (defined for API consistency)
    property value : TFhirType read FValue write SetValue;
    // The information determined as a result of making the observation, if the information has a simple value.
    property valueElement : TFhirType read FValue write SetValue;

    // Typed access to Provides a reason why the expected value in the element Observation.value[x] is missing. (defined for API consistency)
    property dataAbsentReason : TFhirCodeableConcept read FDataAbsentReason write SetDataAbsentReason;
    // Provides a reason why the expected value in the element Observation.value[x] is missing.
    property dataAbsentReasonElement : TFhirCodeableConcept read FDataAbsentReason write SetDataAbsentReason;

    // Typed access to The assessment made based on the result of the observation.  Intended as a simple compact code often placed adjacent to the result value in reports and flow sheets to signal the meaning/normalcy status of the result. Otherwise known as abnormal flag. (defined for API consistency)
    property interpretation : TFhirCodeableConcept read FInterpretation write SetInterpretation;
    // The assessment made based on the result of the observation.  Intended as a simple compact code often placed adjacent to the result value in reports and flow sheets to signal the meaning/normalcy status of the result. Otherwise known as abnormal flag.
    property interpretationElement : TFhirCodeableConcept read FInterpretation write SetInterpretation;

    // Typed access to May include statements about significant, unexpected or unreliable values, or information about the source of the value where this may be relevant to the interpretation of the result.
    property comments : String read GetCommentsST write SetCommentsST;
    // May include statements about significant, unexpected or unreliable values, or information about the source of the value where this may be relevant to the interpretation of the result.
    property commentsElement : TFhirString read FComments write SetComments;

    // Typed access to Indicates the site on the subject's body where the observation was made (i.e. the target site). (defined for API consistency)
    property bodySite : TFhirCodeableConcept read FBodySite write SetBodySite;
    // Indicates the site on the subject's body where the observation was made (i.e. the target site).
    property bodySiteElement : TFhirCodeableConcept read FBodySite write SetBodySite;

    // Typed access to Indicates the mechanism used to perform the observation. (defined for API consistency)
    property method : TFhirCodeableConcept read FMethod write SetMethod;
    // Indicates the mechanism used to perform the observation.
    property methodElement : TFhirCodeableConcept read FMethod write SetMethod;

    // Typed access to The specimen that was used when this observation was made. (defined for API consistency)
    property specimen : TFhirReference{TFhirSpecimen} read FSpecimen write SetSpecimen;
    // The specimen that was used when this observation was made.
    property specimenElement : TFhirReference{TFhirSpecimen} read FSpecimen write SetSpecimen;

    // Typed access to The device used to generate the observation data. (defined for API consistency)
    property device : TFhirReference{Resource} read FDevice write SetDevice;
    // The device used to generate the observation data.
    property deviceElement : TFhirReference{Resource} read FDevice write SetDevice;

    // Guidance on how to interpret the value by comparison to a normal or recommended range.
    property referenceRangeList : TFhirObservationReferenceRangeList read GetReferenceRangeList;
    property hasReferenceRangeList : boolean read GetHasReferenceRangeList;

    // A  reference to another resource (usually another Observation but could  also be a QuestionnaireAnswer) whose relationship is defined by the relationship type code.
    property relatedList : TFhirObservationRelatedList read GetRelatedList;
    property hasRelatedList : boolean read GetHasRelatedList;

    // Some observations have multiple component observations.  These component observations are expressed as separate code value pairs that share the same attributes.  Examples include systolic and diastolic component observations for blood pressure measurement and multiple component observations for genetics observations.
    property componentList : TFhirObservationComponentList read GetComponentList;
    property hasComponentList : boolean read GetHasComponentList;

  end;

  TFhirObservationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirObservationList;
    function GetCurrent : TFhirObservation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirObservationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirObservation read GetCurrent;
  end;

  TFhirObservationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirObservation;
    procedure SetItemN(index : Integer; value : TFhirObservation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirObservationList; Overload;
    function Clone : TFhirObservationList; Overload;
    function GetEnumerator : TFhirObservationListEnumerator;

    //  Add a FhirObservation to the end of the list.
    function Append : TFhirObservation;

    // Add an already existing FhirObservation to the end of the list.
    procedure AddItem(value : TFhirObservation); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirObservation) : Integer;

    // Insert FhirObservation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirObservation;

    // Insert an existing FhirObservation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirObservation);

    // Get the iIndexth FhirObservation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirObservation);

    // The number of items in the collection
    function Item(index : Integer) : TFhirObservation;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirObservations[index : Integer] : TFhirObservation read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_OBSERVATION}

{$IFDEF FHIR_PROCEDURE}

  // Limited to 'real' people rather than equipment.
  TFhirProcedurePerformer = class (TFhirBackboneElement)
  protected
    FActor : TFhirReference{Resource};
    FRole : TFhirCodeableConcept;
    Procedure SetActor(value : TFhirReference{Resource});
    Procedure SetRole(value : TFhirCodeableConcept);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirProcedurePerformer; overload;
    function Clone : TFhirProcedurePerformer; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The practitioner who was involved in the procedure. (defined for API consistency)
    property actor : TFhirReference{Resource} read FActor write SetActor;
    // The practitioner who was involved in the procedure.
    property actorElement : TFhirReference{Resource} read FActor write SetActor;

    // Typed access to For example: surgeon, anaethetist, endoscopist. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // For example: surgeon, anaethetist, endoscopist.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

  end;

  TFhirProcedurePerformerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirProcedurePerformerList;
    function GetCurrent : TFhirProcedurePerformer;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirProcedurePerformerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProcedurePerformer read GetCurrent;
  end;

  TFhirProcedurePerformerList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirProcedurePerformer;
    procedure SetItemN(index : Integer; value : TFhirProcedurePerformer);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirProcedurePerformerList; Overload;
    function Clone : TFhirProcedurePerformerList; Overload;
    function GetEnumerator : TFhirProcedurePerformerListEnumerator;

    //  Add a FhirProcedurePerformer to the end of the list.
    function Append : TFhirProcedurePerformer;

    // Add an already existing FhirProcedurePerformer to the end of the list.
    procedure AddItem(value : TFhirProcedurePerformer); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirProcedurePerformer) : Integer;

    // Insert FhirProcedurePerformer before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirProcedurePerformer;

    // Insert an existing FhirProcedurePerformer before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirProcedurePerformer);

    // Get the iIndexth FhirProcedurePerformer. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirProcedurePerformer);

    // The number of items in the collection
    function Item(index : Integer) : TFhirProcedurePerformer;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirProcedurePerformers[index : Integer] : TFhirProcedurePerformer read GetItemN write SetItemN; default;
  End;

  // A device that is implanted, removed or otherwise manipulated (calibration, battery replacement, fitting a prosthesis, attaching a wound-vac, etc.) as a focal portion of the Procedure.
  TFhirProcedureFocalDevice = class (TFhirBackboneElement)
  protected
    FAction : TFhirCodeableConcept;
    FManipulated : TFhirReference{TFhirDevice};
    Procedure SetAction(value : TFhirCodeableConcept);
    Procedure SetManipulated(value : TFhirReference{TFhirDevice});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirProcedureFocalDevice; overload;
    function Clone : TFhirProcedureFocalDevice; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The kind of change that happened to the device during the procedure. (defined for API consistency)
    property action : TFhirCodeableConcept read FAction write SetAction;
    // The kind of change that happened to the device during the procedure.
    property actionElement : TFhirCodeableConcept read FAction write SetAction;

    // Typed access to The device that was manipulated (changed) during the procedure. (defined for API consistency)
    property manipulated : TFhirReference{TFhirDevice} read FManipulated write SetManipulated;
    // The device that was manipulated (changed) during the procedure.
    property manipulatedElement : TFhirReference{TFhirDevice} read FManipulated write SetManipulated;

  end;

  TFhirProcedureFocalDeviceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirProcedureFocalDeviceList;
    function GetCurrent : TFhirProcedureFocalDevice;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirProcedureFocalDeviceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProcedureFocalDevice read GetCurrent;
  end;

  TFhirProcedureFocalDeviceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirProcedureFocalDevice;
    procedure SetItemN(index : Integer; value : TFhirProcedureFocalDevice);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirProcedureFocalDeviceList; Overload;
    function Clone : TFhirProcedureFocalDeviceList; Overload;
    function GetEnumerator : TFhirProcedureFocalDeviceListEnumerator;

    //  Add a FhirProcedureFocalDevice to the end of the list.
    function Append : TFhirProcedureFocalDevice;

    // Add an already existing FhirProcedureFocalDevice to the end of the list.
    procedure AddItem(value : TFhirProcedureFocalDevice); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirProcedureFocalDevice) : Integer;

    // Insert FhirProcedureFocalDevice before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirProcedureFocalDevice;

    // Insert an existing FhirProcedureFocalDevice before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirProcedureFocalDevice);

    // Get the iIndexth FhirProcedureFocalDevice. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirProcedureFocalDevice);

    // The number of items in the collection
    function Item(index : Integer) : TFhirProcedureFocalDevice;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirProcedureFocalDevices[index : Integer] : TFhirProcedureFocalDevice read GetItemN write SetItemN; default;
  End;

  // An action that is or was performed on a patient. This can be a physical intervention like an operation, or less invasive like counseling or hypnotherapy.
  TFhirProcedure = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FSubject : TFhirReference{Resource};
    FStatus : TFhirEnum;
    FCategory : TFhirCodeableConcept;
    FCode : TFhirCodeableConcept;
    FNotPerformed : TFhirBoolean;
    FreasonNotPerformedList : TFhirCodeableConceptList;
    FbodySiteList : TFhirCodeableConceptList;
    FReason : TFhirType;
    FperformerList : TFhirProcedurePerformerList;
    FPerformed : TFhirType;
    FEncounter : TFhirReference{TFhirEncounter};
    FLocation : TFhirReference{TFhirLocation};
    FOutcome : TFhirCodeableConcept;
    FreportList : TFhirReferenceList{TFhirDiagnosticReport};
    FcomplicationList : TFhirCodeableConceptList;
    FfollowUpList : TFhirCodeableConceptList;
    FRequest : TFhirReference{Resource};
    FnotesList : TFhirAnnotationList;
    FfocalDeviceList : TFhirProcedureFocalDeviceList;
    FusedList : TFhirReferenceList{Resource};
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetSubject(value : TFhirReference{Resource});
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirProcedureStatusEnum;
    Procedure SetStatusST(value : TFhirProcedureStatusEnum);
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetNotPerformed(value : TFhirBoolean);
    Function GetNotPerformedST : Boolean;
    Procedure SetNotPerformedST(value : Boolean);
    function GetReasonNotPerformedList : TFhirCodeableConceptList;
    function GetHasReasonNotPerformedList : Boolean;
    function GetBodySiteList : TFhirCodeableConceptList;
    function GetHasBodySiteList : Boolean;
    Procedure SetReason(value : TFhirType);
    function GetPerformerList : TFhirProcedurePerformerList;
    function GetHasPerformerList : Boolean;
    Procedure SetPerformed(value : TFhirType);
    Procedure SetEncounter(value : TFhirReference{TFhirEncounter});
    Procedure SetLocation(value : TFhirReference{TFhirLocation});
    Procedure SetOutcome(value : TFhirCodeableConcept);
    function GetReportList : TFhirReferenceList{TFhirDiagnosticReport};
    function GetHasReportList : Boolean;
    function GetComplicationList : TFhirCodeableConceptList;
    function GetHasComplicationList : Boolean;
    function GetFollowUpList : TFhirCodeableConceptList;
    function GetHasFollowUpList : Boolean;
    Procedure SetRequest(value : TFhirReference{Resource});
    function GetNotesList : TFhirAnnotationList;
    function GetHasNotesList : Boolean;
    function GetFocalDeviceList : TFhirProcedureFocalDeviceList;
    function GetHasFocalDeviceList : Boolean;
    function GetUsedList : TFhirReferenceList{Resource};
    function GetHasUsedList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirProcedure; overload;
    function Clone : TFhirProcedure; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // This records identifiers associated with this procedure that are defined by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate (e.g. in CDA documents, or in written / printed documentation).
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The person, animal or group on which the procedure was performed. (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // The person, animal or group on which the procedure was performed.
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // A code specifying the state of the procedure. Generally this will be in-progress or completed state.
    property status : TFhirProcedureStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A code that classifies the procedure for searching, sorting and display purposes (e.g. "Surgical Procedure"). (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // A code that classifies the procedure for searching, sorting and display purposes (e.g. "Surgical Procedure").
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to The specific procedure that is performed. Use text if the exact nature of the procedure cannot be coded (e.g. "Laparoscopic Appendectomy"). (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The specific procedure that is performed. Use text if the exact nature of the procedure cannot be coded (e.g. "Laparoscopic Appendectomy").
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to Set this to true if the record is saying that the procedure was NOT performed.
    property notPerformed : Boolean read GetNotPerformedST write SetNotPerformedST;
    // Set this to true if the record is saying that the procedure was NOT performed.
    property notPerformedElement : TFhirBoolean read FNotPerformed write SetNotPerformed;

    // A code indicating why the procedure was not performed.
    property reasonNotPerformedList : TFhirCodeableConceptList read GetReasonNotPerformedList;
    property hasReasonNotPerformedList : boolean read GetHasReasonNotPerformedList;

    // Detailed and structured anatomical location information. Multiple locations are allowed - e.g. multiple punch biopsies of a lesion.
    property bodySiteList : TFhirCodeableConceptList read GetBodySiteList;
    property hasBodySiteList : boolean read GetHasBodySiteList;

    // Typed access to The reason why the procedure was performed. This may be due to a Condition, may be coded entity of some type, or may simply be present as text. (defined for API consistency)
    property reason : TFhirType read FReason write SetReason;
    // The reason why the procedure was performed. This may be due to a Condition, may be coded entity of some type, or may simply be present as text.
    property reasonElement : TFhirType read FReason write SetReason;

    // Limited to 'real' people rather than equipment.
    property performerList : TFhirProcedurePerformerList read GetPerformerList;
    property hasPerformerList : boolean read GetHasPerformerList;

    // Typed access to The date(time)/period over which the procedure was performed. Allows a period to support complex procedures that span more than one date, and also allows for the length of the procedure to be captured. (defined for API consistency)
    property performed : TFhirType read FPerformed write SetPerformed;
    // The date(time)/period over which the procedure was performed. Allows a period to support complex procedures that span more than one date, and also allows for the length of the procedure to be captured.
    property performedElement : TFhirType read FPerformed write SetPerformed;

    // Typed access to The encounter during which the procedure was performed. (defined for API consistency)
    property encounter : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;
    // The encounter during which the procedure was performed.
    property encounterElement : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;

    // Typed access to The location where the procedure actually happened.  E.g. a newborn at home, a tracheostomy at a restaurant. (defined for API consistency)
    property location : TFhirReference{TFhirLocation} read FLocation write SetLocation;
    // The location where the procedure actually happened.  E.g. a newborn at home, a tracheostomy at a restaurant.
    property locationElement : TFhirReference{TFhirLocation} read FLocation write SetLocation;

    // Typed access to The outcome of the procedure - did it resolve reasons for the procedure being performed? (defined for API consistency)
    property outcome : TFhirCodeableConcept read FOutcome write SetOutcome;
    // The outcome of the procedure - did it resolve reasons for the procedure being performed?
    property outcomeElement : TFhirCodeableConcept read FOutcome write SetOutcome;

    // This could be a histology result, pathology report, surgical report, etc..
    property reportList : TFhirReferenceList{TFhirDiagnosticReport} read GetReportList;
    property hasReportList : boolean read GetHasReportList;

    // Any complications that occurred during the procedure, or in the immediate post-performance period. These are generally tracked separately from the notes, which will typically describe the procedure itself rather than any 'post procedure' issues.
    property complicationList : TFhirCodeableConceptList read GetComplicationList;
    property hasComplicationList : boolean read GetHasComplicationList;

    // If the procedure required specific follow up - e.g. removal of sutures. The followup may be represented as a simple note, or could potentially be more complex in which case the CarePlan resource can be used.
    property followUpList : TFhirCodeableConceptList read GetFollowUpList;
    property hasFollowUpList : boolean read GetHasFollowUpList;

    // Typed access to A reference to a resource that contains details of the request for this procedure. (defined for API consistency)
    property request : TFhirReference{Resource} read FRequest write SetRequest;
    // A reference to a resource that contains details of the request for this procedure.
    property requestElement : TFhirReference{Resource} read FRequest write SetRequest;

    // Any other notes about the procedure.  E.g. the operative notes.
    property notesList : TFhirAnnotationList read GetNotesList;
    property hasNotesList : boolean read GetHasNotesList;

    // A device that is implanted, removed or otherwise manipulated (calibration, battery replacement, fitting a prosthesis, attaching a wound-vac, etc.) as a focal portion of the Procedure.
    property focalDeviceList : TFhirProcedureFocalDeviceList read GetFocalDeviceList;
    property hasFocalDeviceList : boolean read GetHasFocalDeviceList;

    // Identifies medications, devices and any other substance used as part of the procedure.
    property usedList : TFhirReferenceList{Resource} read GetUsedList;
    property hasUsedList : boolean read GetHasUsedList;

  end;

  TFhirProcedureListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirProcedureList;
    function GetCurrent : TFhirProcedure;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirProcedureList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProcedure read GetCurrent;
  end;

  TFhirProcedureList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirProcedure;
    procedure SetItemN(index : Integer; value : TFhirProcedure);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirProcedureList; Overload;
    function Clone : TFhirProcedureList; Overload;
    function GetEnumerator : TFhirProcedureListEnumerator;

    //  Add a FhirProcedure to the end of the list.
    function Append : TFhirProcedure;

    // Add an already existing FhirProcedure to the end of the list.
    procedure AddItem(value : TFhirProcedure); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirProcedure) : Integer;

    // Insert FhirProcedure before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirProcedure;

    // Insert an existing FhirProcedure before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirProcedure);

    // Get the iIndexth FhirProcedure. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirProcedure);

    // The number of items in the collection
    function Item(index : Integer) : TFhirProcedure;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirProcedures[index : Integer] : TFhirProcedure read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PROCEDURE}

{$IFDEF FHIR_PROCEDUREREQUEST}

  // A request for a procedure to be performed. May be a proposal or an order.
  TFhirProcedureRequest = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FSubject : TFhirReference{Resource};
    FCode : TFhirCodeableConcept;
    FbodySiteList : TFhirCodeableConceptList;
    FReason : TFhirType;
    FScheduled : TFhirType;
    FEncounter : TFhirReference{TFhirEncounter};
    FPerformer : TFhirReference{Resource};
    FStatus : TFhirEnum;
    FnotesList : TFhirAnnotationList;
    FAsNeeded : TFhirType;
    FOrderedOn : TFhirDateTime;
    FOrderer : TFhirReference{Resource};
    FPriority : TFhirEnum;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetSubject(value : TFhirReference{Resource});
    Procedure SetCode(value : TFhirCodeableConcept);
    function GetBodySiteList : TFhirCodeableConceptList;
    function GetHasBodySiteList : Boolean;
    Procedure SetReason(value : TFhirType);
    Procedure SetScheduled(value : TFhirType);
    Procedure SetEncounter(value : TFhirReference{TFhirEncounter});
    Procedure SetPerformer(value : TFhirReference{Resource});
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirProcedureRequestStatusEnum;
    Procedure SetStatusST(value : TFhirProcedureRequestStatusEnum);
    function GetNotesList : TFhirAnnotationList;
    function GetHasNotesList : Boolean;
    Procedure SetAsNeeded(value : TFhirType);
    Procedure SetOrderedOn(value : TFhirDateTime);
    Function GetOrderedOnST : TFslDateTime;
    Procedure SetOrderedOnST(value : TFslDateTime);
    Procedure SetOrderer(value : TFhirReference{Resource});
    Procedure SetPriority(value : TFhirEnum);
    Function GetPriorityST : TFhirProcedureRequestPriorityEnum;
    Procedure SetPriorityST(value : TFhirProcedureRequestPriorityEnum);

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirProcedureRequest; overload;
    function Clone : TFhirProcedureRequest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifiers assigned to this order by the order or by the receiver.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The person, animal or group that should receive the procedure. (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // The person, animal or group that should receive the procedure.
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // Typed access to The specific procedure that is ordered. Use text if the exact nature of the procedure cannot be coded. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The specific procedure that is ordered. Use text if the exact nature of the procedure cannot be coded.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Indicates the sites on the subject's body where the procedure should be performed (I.e. the target sites).
    property bodySiteList : TFhirCodeableConceptList read GetBodySiteList;
    property hasBodySiteList : boolean read GetHasBodySiteList;

    // Typed access to The reason why the procedure is being proposed or ordered. This procedure request may be motivated by a Condition for instance. (defined for API consistency)
    property reason : TFhirType read FReason write SetReason;
    // The reason why the procedure is being proposed or ordered. This procedure request may be motivated by a Condition for instance.
    property reasonElement : TFhirType read FReason write SetReason;

    // Typed access to The timing schedule for the proposed or ordered procedure. The Schedule data type allows many different expressions.  E.g. "Every 8 hours"; "Three times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec 2011:"; "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013". (defined for API consistency)
    property scheduled : TFhirType read FScheduled write SetScheduled;
    // The timing schedule for the proposed or ordered procedure. The Schedule data type allows many different expressions.  E.g. "Every 8 hours"; "Three times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec 2011:"; "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013".
    property scheduledElement : TFhirType read FScheduled write SetScheduled;

    // Typed access to The encounter within which the procedure proposal or request was created. (defined for API consistency)
    property encounter : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;
    // The encounter within which the procedure proposal or request was created.
    property encounterElement : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;

    // Typed access to For example, the surgeon, anaethetist, endoscopist, etc. (defined for API consistency)
    property performer : TFhirReference{Resource} read FPerformer write SetPerformer;
    // For example, the surgeon, anaethetist, endoscopist, etc.
    property performerElement : TFhirReference{Resource} read FPerformer write SetPerformer;

    // The status of the order.
    property status : TFhirProcedureRequestStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Any other notes associated with this proposal or order - e.g. provider instructions.
    property notesList : TFhirAnnotationList read GetNotesList;
    property hasNotesList : boolean read GetHasNotesList;

    // Typed access to If a CodeableConcept is present, it indicates the pre-condition for performing the procedure. (defined for API consistency)
    property asNeeded : TFhirType read FAsNeeded write SetAsNeeded;
    // If a CodeableConcept is present, it indicates the pre-condition for performing the procedure.
    property asNeededElement : TFhirType read FAsNeeded write SetAsNeeded;

    // Typed access to The time when the request was made.
    property orderedOn : TFslDateTime read GetOrderedOnST write SetOrderedOnST;
    // The time when the request was made.
    property orderedOnElement : TFhirDateTime read FOrderedOn write SetOrderedOn;

    // Typed access to The healthcare professional responsible for proposing or ordering the procedure. (defined for API consistency)
    property orderer : TFhirReference{Resource} read FOrderer write SetOrderer;
    // The healthcare professional responsible for proposing or ordering the procedure.
    property ordererElement : TFhirReference{Resource} read FOrderer write SetOrderer;

    // The clinical priority associated with this order.
    property priority : TFhirProcedureRequestPriorityEnum read GetPriorityST write SetPriorityST;
    property priorityElement : TFhirEnum read FPriority write SetPriority;

  end;

  TFhirProcedureRequestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirProcedureRequestList;
    function GetCurrent : TFhirProcedureRequest;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirProcedureRequestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProcedureRequest read GetCurrent;
  end;

  TFhirProcedureRequestList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirProcedureRequest;
    procedure SetItemN(index : Integer; value : TFhirProcedureRequest);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirProcedureRequestList; Overload;
    function Clone : TFhirProcedureRequestList; Overload;
    function GetEnumerator : TFhirProcedureRequestListEnumerator;

    //  Add a FhirProcedureRequest to the end of the list.
    function Append : TFhirProcedureRequest;

    // Add an already existing FhirProcedureRequest to the end of the list.
    procedure AddItem(value : TFhirProcedureRequest); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirProcedureRequest) : Integer;

    // Insert FhirProcedureRequest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirProcedureRequest;

    // Insert an existing FhirProcedureRequest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirProcedureRequest);

    // Get the iIndexth FhirProcedureRequest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirProcedureRequest);

    // The number of items in the collection
    function Item(index : Integer) : TFhirProcedureRequest;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirProcedureRequests[index : Integer] : TFhirProcedureRequest read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PROCEDUREREQUEST}

{$IFDEF FHIR_QUESTIONNAIRERESPONSE}

  // A group of questions to a possibly similarly grouped set of questions in the questionnaire response.
  TFhirQuestionnaireResponseGroup = class (TFhirBackboneElement)
  protected
    FLinkId : TFhirString;
    FTitle : TFhirString;
    FText : TFhirString;
    FSubject : TFhirReference{TFhirReference};
    FgroupList : TFhirQuestionnaireResponseGroupList;
    FquestionList : TFhirQuestionnaireResponseGroupQuestionList;
    Procedure SetLinkId(value : TFhirString);
    Function GetLinkIdST : String;
    Procedure SetLinkIdST(value : String);
    Procedure SetTitle(value : TFhirString);
    Function GetTitleST : String;
    Procedure SetTitleST(value : String);
    Procedure SetText(value : TFhirString);
    Function GetTextST : String;
    Procedure SetTextST(value : String);
    Procedure SetSubject(value : TFhirReference{TFhirReference});
    function GetGroupList : TFhirQuestionnaireResponseGroupList;
    function GetHasGroupList : Boolean;
    function GetQuestionList : TFhirQuestionnaireResponseGroupQuestionList;
    function GetHasQuestionList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirQuestionnaireResponseGroup; overload;
    function Clone : TFhirQuestionnaireResponseGroup; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Identifies the group from the Questionnaire that corresponds to this group in the QuestionnaireResponse resource.
    property linkId : String read GetLinkIdST write SetLinkIdST;
    // Identifies the group from the Questionnaire that corresponds to this group in the QuestionnaireResponse resource.
    property linkIdElement : TFhirString read FLinkId write SetLinkId;

    // Typed access to Text that is displayed above the contents of the group.
    property title : String read GetTitleST write SetTitleST;
    // Text that is displayed above the contents of the group.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to Additional text for the group, used for display purposes.
    property text : String read GetTextST write SetTextST;
    // Additional text for the group, used for display purposes.
    property textElement : TFhirString read FText write SetText;

    // Typed access to More specific subject this section's answers are about, details the subject given in QuestionnaireResponse. (defined for API consistency)
    property subject : TFhirReference{TFhirReference} read FSubject write SetSubject;
    // More specific subject this section's answers are about, details the subject given in QuestionnaireResponse.
    property subjectElement : TFhirReference{TFhirReference} read FSubject write SetSubject;

    // A sub-group within a group. The ordering of groups within this group is relevant.
    property groupList : TFhirQuestionnaireResponseGroupList read GetGroupList;
    property hasGroupList : boolean read GetHasGroupList;

    // Set of questions within this group. The order of questions within the group is relevant.
    property questionList : TFhirQuestionnaireResponseGroupQuestionList read GetQuestionList;
    property hasQuestionList : boolean read GetHasQuestionList;

  end;

  TFhirQuestionnaireResponseGroupListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirQuestionnaireResponseGroupList;
    function GetCurrent : TFhirQuestionnaireResponseGroup;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirQuestionnaireResponseGroupList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirQuestionnaireResponseGroup read GetCurrent;
  end;

  TFhirQuestionnaireResponseGroupList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirQuestionnaireResponseGroup;
    procedure SetItemN(index : Integer; value : TFhirQuestionnaireResponseGroup);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirQuestionnaireResponseGroupList; Overload;
    function Clone : TFhirQuestionnaireResponseGroupList; Overload;
    function GetEnumerator : TFhirQuestionnaireResponseGroupListEnumerator;

    //  Add a FhirQuestionnaireResponseGroup to the end of the list.
    function Append : TFhirQuestionnaireResponseGroup;

    // Add an already existing FhirQuestionnaireResponseGroup to the end of the list.
    procedure AddItem(value : TFhirQuestionnaireResponseGroup); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirQuestionnaireResponseGroup) : Integer;

    // Insert FhirQuestionnaireResponseGroup before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirQuestionnaireResponseGroup;

    // Insert an existing FhirQuestionnaireResponseGroup before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirQuestionnaireResponseGroup);

    // Get the iIndexth FhirQuestionnaireResponseGroup. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirQuestionnaireResponseGroup);

    // The number of items in the collection
    function Item(index : Integer) : TFhirQuestionnaireResponseGroup;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirQuestionnaireResponseGroups[index : Integer] : TFhirQuestionnaireResponseGroup read GetItemN write SetItemN; default;
  End;

  // Set of questions within this group. The order of questions within the group is relevant.
  TFhirQuestionnaireResponseGroupQuestion = class (TFhirBackboneElement)
  protected
    FLinkId : TFhirString;
    FText : TFhirString;
    FanswerList : TFhirQuestionnaireResponseGroupQuestionAnswerList;
    Procedure SetLinkId(value : TFhirString);
    Function GetLinkIdST : String;
    Procedure SetLinkIdST(value : String);
    Procedure SetText(value : TFhirString);
    Function GetTextST : String;
    Procedure SetTextST(value : String);
    function GetAnswerList : TFhirQuestionnaireResponseGroupQuestionAnswerList;
    function GetHasAnswerList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirQuestionnaireResponseGroupQuestion; overload;
    function Clone : TFhirQuestionnaireResponseGroupQuestion; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Identifies the question from the Questionnaire that corresponds to this question in the QuestionnaireResponse resource.
    property linkId : String read GetLinkIdST write SetLinkIdST;
    // Identifies the question from the Questionnaire that corresponds to this question in the QuestionnaireResponse resource.
    property linkIdElement : TFhirString read FLinkId write SetLinkId;

    // Typed access to The actual question as shown to the user to prompt them for an answer.
    property text : String read GetTextST write SetTextST;
    // The actual question as shown to the user to prompt them for an answer.
    property textElement : TFhirString read FText write SetText;

    // The respondent's answer(s) to the question.
    property answerList : TFhirQuestionnaireResponseGroupQuestionAnswerList read GetAnswerList;
    property hasAnswerList : boolean read GetHasAnswerList;

  end;

  TFhirQuestionnaireResponseGroupQuestionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirQuestionnaireResponseGroupQuestionList;
    function GetCurrent : TFhirQuestionnaireResponseGroupQuestion;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirQuestionnaireResponseGroupQuestionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirQuestionnaireResponseGroupQuestion read GetCurrent;
  end;

  TFhirQuestionnaireResponseGroupQuestionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirQuestionnaireResponseGroupQuestion;
    procedure SetItemN(index : Integer; value : TFhirQuestionnaireResponseGroupQuestion);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirQuestionnaireResponseGroupQuestionList; Overload;
    function Clone : TFhirQuestionnaireResponseGroupQuestionList; Overload;
    function GetEnumerator : TFhirQuestionnaireResponseGroupQuestionListEnumerator;

    //  Add a FhirQuestionnaireResponseGroupQuestion to the end of the list.
    function Append : TFhirQuestionnaireResponseGroupQuestion;

    // Add an already existing FhirQuestionnaireResponseGroupQuestion to the end of the list.
    procedure AddItem(value : TFhirQuestionnaireResponseGroupQuestion); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirQuestionnaireResponseGroupQuestion) : Integer;

    // Insert FhirQuestionnaireResponseGroupQuestion before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirQuestionnaireResponseGroupQuestion;

    // Insert an existing FhirQuestionnaireResponseGroupQuestion before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirQuestionnaireResponseGroupQuestion);

    // Get the iIndexth FhirQuestionnaireResponseGroupQuestion. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirQuestionnaireResponseGroupQuestion);

    // The number of items in the collection
    function Item(index : Integer) : TFhirQuestionnaireResponseGroupQuestion;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirQuestionnaireResponseGroupQuestions[index : Integer] : TFhirQuestionnaireResponseGroupQuestion read GetItemN write SetItemN; default;
  End;

  // The respondent's answer(s) to the question.
  TFhirQuestionnaireResponseGroupQuestionAnswer = class (TFhirBackboneElement)
  protected
    FValue : TFhirType;
    FgroupList : TFhirQuestionnaireResponseGroupList;
    Procedure SetValue(value : TFhirType);
    function GetGroupList : TFhirQuestionnaireResponseGroupList;
    function GetHasGroupList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirQuestionnaireResponseGroupQuestionAnswer; overload;
    function Clone : TFhirQuestionnaireResponseGroupQuestionAnswer; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The answer (or one of the answers) provided by the respondent to the question. (defined for API consistency)
    property value : TFhirType read FValue write SetValue;
    // The answer (or one of the answers) provided by the respondent to the question.
    property valueElement : TFhirType read FValue write SetValue;

    // Nested group, containing nested question for this question. The order of groups within the question is relevant.
    property groupList : TFhirQuestionnaireResponseGroupList read GetGroupList;
    property hasGroupList : boolean read GetHasGroupList;

  end;

  TFhirQuestionnaireResponseGroupQuestionAnswerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirQuestionnaireResponseGroupQuestionAnswerList;
    function GetCurrent : TFhirQuestionnaireResponseGroupQuestionAnswer;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirQuestionnaireResponseGroupQuestionAnswerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirQuestionnaireResponseGroupQuestionAnswer read GetCurrent;
  end;

  TFhirQuestionnaireResponseGroupQuestionAnswerList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirQuestionnaireResponseGroupQuestionAnswer;
    procedure SetItemN(index : Integer; value : TFhirQuestionnaireResponseGroupQuestionAnswer);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirQuestionnaireResponseGroupQuestionAnswerList; Overload;
    function Clone : TFhirQuestionnaireResponseGroupQuestionAnswerList; Overload;
    function GetEnumerator : TFhirQuestionnaireResponseGroupQuestionAnswerListEnumerator;

    //  Add a FhirQuestionnaireResponseGroupQuestionAnswer to the end of the list.
    function Append : TFhirQuestionnaireResponseGroupQuestionAnswer;

    // Add an already existing FhirQuestionnaireResponseGroupQuestionAnswer to the end of the list.
    procedure AddItem(value : TFhirQuestionnaireResponseGroupQuestionAnswer); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirQuestionnaireResponseGroupQuestionAnswer) : Integer;

    // Insert FhirQuestionnaireResponseGroupQuestionAnswer before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirQuestionnaireResponseGroupQuestionAnswer;

    // Insert an existing FhirQuestionnaireResponseGroupQuestionAnswer before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirQuestionnaireResponseGroupQuestionAnswer);

    // Get the iIndexth FhirQuestionnaireResponseGroupQuestionAnswer. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirQuestionnaireResponseGroupQuestionAnswer);

    // The number of items in the collection
    function Item(index : Integer) : TFhirQuestionnaireResponseGroupQuestionAnswer;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirQuestionnaireResponseGroupQuestionAnswers[index : Integer] : TFhirQuestionnaireResponseGroupQuestionAnswer read GetItemN write SetItemN; default;
  End;

  // A structured set of questions and their answers. The questions are ordered and grouped into coherent subsets, corresponding to the structure of the grouping of the underlying questions.
  TFhirQuestionnaireResponse = class (TFhirDomainResource)
  protected
    FIdentifier : TFhirIdentifier;
    FQuestionnaire : TFhirReference{TFhirQuestionnaire};
    FStatus : TFhirEnum;
    FSubject : TFhirReference{TFhirReference};
    FAuthor : TFhirReference{Resource};
    FAuthored : TFhirDateTime;
    FSource : TFhirReference{Resource};
    FEncounter : TFhirReference{TFhirEncounter};
    FGroup : TFhirQuestionnaireResponseGroup;
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetQuestionnaire(value : TFhirReference{TFhirQuestionnaire});
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirQuestionnaireAnswersStatusEnum;
    Procedure SetStatusST(value : TFhirQuestionnaireAnswersStatusEnum);
    Procedure SetSubject(value : TFhirReference{TFhirReference});
    Procedure SetAuthor(value : TFhirReference{Resource});
    Procedure SetAuthored(value : TFhirDateTime);
    Function GetAuthoredST : TFslDateTime;
    Procedure SetAuthoredST(value : TFslDateTime);
    Procedure SetSource(value : TFhirReference{Resource});
    Procedure SetEncounter(value : TFhirReference{TFhirEncounter});
    Procedure SetGroup(value : TFhirQuestionnaireResponseGroup);

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirQuestionnaireResponse; overload;
    function Clone : TFhirQuestionnaireResponse; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A business identifier assigned to a particular completed (or partially completed) questionnaire. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // A business identifier assigned to a particular completed (or partially completed) questionnaire.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to Indicates the Questionnaire resource that defines the form for which answers are being provided. (defined for API consistency)
    property questionnaire : TFhirReference{TFhirQuestionnaire} read FQuestionnaire write SetQuestionnaire;
    // Indicates the Questionnaire resource that defines the form for which answers are being provided.
    property questionnaireElement : TFhirReference{TFhirQuestionnaire} read FQuestionnaire write SetQuestionnaire;

    // The lifecycle status of the questionnaire response as a whole.
    property status : TFhirQuestionnaireAnswersStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The subject of the questionnaire response.  This could be a patient, organization, practitioner, device, etc.  This is who/what the answers apply to, but is not necessarily the source of information. (defined for API consistency)
    property subject : TFhirReference{TFhirReference} read FSubject write SetSubject;
    // The subject of the questionnaire response.  This could be a patient, organization, practitioner, device, etc.  This is who/what the answers apply to, but is not necessarily the source of information.
    property subjectElement : TFhirReference{TFhirReference} read FSubject write SetSubject;

    // Typed access to Person who received the answers to the questions in the QuestionnaireResponse and recorded them in the system. (defined for API consistency)
    property author : TFhirReference{Resource} read FAuthor write SetAuthor;
    // Person who received the answers to the questions in the QuestionnaireResponse and recorded them in the system.
    property authorElement : TFhirReference{Resource} read FAuthor write SetAuthor;

    // Typed access to The date and/or time that this version of the questionnaire response was authored.
    property authored : TFslDateTime read GetAuthoredST write SetAuthoredST;
    // The date and/or time that this version of the questionnaire response was authored.
    property authoredElement : TFhirDateTime read FAuthored write SetAuthored;

    // Typed access to The person who answered the questions about the subject. (defined for API consistency)
    property source : TFhirReference{Resource} read FSource write SetSource;
    // The person who answered the questions about the subject.
    property sourceElement : TFhirReference{Resource} read FSource write SetSource;

    // Typed access to Encounter during which this set of questionnaire response were collected. When there were multiple encounters, this is the one considered most relevant to the context of the answers. (defined for API consistency)
    property encounter : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;
    // Encounter during which this set of questionnaire response were collected. When there were multiple encounters, this is the one considered most relevant to the context of the answers.
    property encounterElement : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;

    // Typed access to A group of questions to a possibly similarly grouped set of questions in the questionnaire response. (defined for API consistency)
    property group : TFhirQuestionnaireResponseGroup read FGroup write SetGroup;
    // A group of questions to a possibly similarly grouped set of questions in the questionnaire response.
    property groupElement : TFhirQuestionnaireResponseGroup read FGroup write SetGroup;

  end;

  TFhirQuestionnaireResponseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirQuestionnaireResponseList;
    function GetCurrent : TFhirQuestionnaireResponse;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirQuestionnaireResponseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirQuestionnaireResponse read GetCurrent;
  end;

  TFhirQuestionnaireResponseList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirQuestionnaireResponse;
    procedure SetItemN(index : Integer; value : TFhirQuestionnaireResponse);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirQuestionnaireResponseList; Overload;
    function Clone : TFhirQuestionnaireResponseList; Overload;
    function GetEnumerator : TFhirQuestionnaireResponseListEnumerator;

    //  Add a FhirQuestionnaireResponse to the end of the list.
    function Append : TFhirQuestionnaireResponse;

    // Add an already existing FhirQuestionnaireResponse to the end of the list.
    procedure AddItem(value : TFhirQuestionnaireResponse); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirQuestionnaireResponse) : Integer;

    // Insert FhirQuestionnaireResponse before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirQuestionnaireResponse;

    // Insert an existing FhirQuestionnaireResponse before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirQuestionnaireResponse);

    // Get the iIndexth FhirQuestionnaireResponse. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirQuestionnaireResponse);

    // The number of items in the collection
    function Item(index : Integer) : TFhirQuestionnaireResponse;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirQuestionnaireResponses[index : Integer] : TFhirQuestionnaireResponse read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_QUESTIONNAIRERESPONSE}

{$IFDEF FHIR_REFERRALREQUEST}

  // Used to record and send details about a request for referral service or transfer of a patient to the care of another provider or provider organization.
  TFhirReferralRequest = class (TFhirDomainResource)
  protected
    FStatus : TFhirEnum;
    FidentifierList : TFhirIdentifierList;
    FDate : TFhirDateTime;
    FType_ : TFhirCodeableConcept;
    FSpecialty : TFhirCodeableConcept;
    FPriority : TFhirCodeableConcept;
    FPatient : TFhirReference{TFhirPatient};
    FRequester : TFhirReference{Resource};
    FrecipientList : TFhirReferenceList{Resource};
    FEncounter : TFhirReference{TFhirEncounter};
    FDateSent : TFhirDateTime;
    FReason : TFhirCodeableConcept;
    FDescription : TFhirString;
    FserviceRequestedList : TFhirCodeableConceptList;
    FsupportingInformationList : TFhirReferenceList{TFhirReference};
    FFulfillmentTime : TFhirPeriod;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirReferralstatusEnum;
    Procedure SetStatusST(value : TFhirReferralstatusEnum);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetSpecialty(value : TFhirCodeableConcept);
    Procedure SetPriority(value : TFhirCodeableConcept);
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    Procedure SetRequester(value : TFhirReference{Resource});
    function GetRecipientList : TFhirReferenceList{Resource};
    function GetHasRecipientList : Boolean;
    Procedure SetEncounter(value : TFhirReference{TFhirEncounter});
    Procedure SetDateSent(value : TFhirDateTime);
    Function GetDateSentST : TFslDateTime;
    Procedure SetDateSentST(value : TFslDateTime);
    Procedure SetReason(value : TFhirCodeableConcept);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    function GetServiceRequestedList : TFhirCodeableConceptList;
    function GetHasServiceRequestedList : Boolean;
    function GetSupportingInformationList : TFhirReferenceList{TFhirReference};
    function GetHasSupportingInformationList : Boolean;
    Procedure SetFulfillmentTime(value : TFhirPeriod);

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirReferralRequest; overload;
    function Clone : TFhirReferralRequest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The workflow status of the referral or transfer of care request.
    property status : TFhirReferralstatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Business identifier that uniquely identifies the referral/care transfer request instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Date/DateTime of creation for draft requests and date of activation for active requests.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Date/DateTime of creation for draft requests and date of activation for active requests.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to An indication of the type of referral (or where applicable the type of transfer of care) request. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // An indication of the type of referral (or where applicable the type of transfer of care) request.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Indication of the clinical domain or discipline to which the referral or transfer of care request is sent.  For example: Cardiology Gastroenterology Diabetology. (defined for API consistency)
    property specialty : TFhirCodeableConcept read FSpecialty write SetSpecialty;
    // Indication of the clinical domain or discipline to which the referral or transfer of care request is sent.  For example: Cardiology Gastroenterology Diabetology.
    property specialtyElement : TFhirCodeableConcept read FSpecialty write SetSpecialty;

    // Typed access to An indication of the urgency of referral (or where applicable the type of transfer of care) request. (defined for API consistency)
    property priority : TFhirCodeableConcept read FPriority write SetPriority;
    // An indication of the urgency of referral (or where applicable the type of transfer of care) request.
    property priorityElement : TFhirCodeableConcept read FPriority write SetPriority;

    // Typed access to The patient who is the subject of a referral or transfer of care request. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // The patient who is the subject of a referral or transfer of care request.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Typed access to The healthcare provider or provider organization who/which initiated the referral/transfer of care request. Can also be  Patient (a self referral). (defined for API consistency)
    property requester : TFhirReference{Resource} read FRequester write SetRequester;
    // The healthcare provider or provider organization who/which initiated the referral/transfer of care request. Can also be  Patient (a self referral).
    property requesterElement : TFhirReference{Resource} read FRequester write SetRequester;

    // The healthcare provider(s) or provider organization(s) who/which is to receive the referral/transfer of care request.
    property recipientList : TFhirReferenceList{Resource} read GetRecipientList;
    property hasRecipientList : boolean read GetHasRecipientList;

    // Typed access to The encounter at which the request for referral or transfer of care is initiated. (defined for API consistency)
    property encounter : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;
    // The encounter at which the request for referral or transfer of care is initiated.
    property encounterElement : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;

    // Typed access to Date/DateTime the request for referral or transfer of care is sent by the author.
    property dateSent : TFslDateTime read GetDateSentST write SetDateSentST;
    // Date/DateTime the request for referral or transfer of care is sent by the author.
    property dateSentElement : TFhirDateTime read FDateSent write SetDateSent;

    // Typed access to Description of clinical condition indicating why referral/transfer of care is requested.  For example:  Pathological Anomalies, Disabled (physical or mental),  Behavioral Management. (defined for API consistency)
    property reason : TFhirCodeableConcept read FReason write SetReason;
    // Description of clinical condition indicating why referral/transfer of care is requested.  For example:  Pathological Anomalies, Disabled (physical or mental),  Behavioral Management.
    property reasonElement : TFhirCodeableConcept read FReason write SetReason;

    // Typed access to The reason element gives a short description of why the referral is being made, the description expands on this to support a more complete clinical summary.
    property description : String read GetDescriptionST write SetDescriptionST;
    // The reason element gives a short description of why the referral is being made, the description expands on this to support a more complete clinical summary.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // The service(s) that is/are requested to be provided to the patient.  For example: cardiac pacemaker insertion.
    property serviceRequestedList : TFhirCodeableConceptList read GetServiceRequestedList;
    property hasServiceRequestedList : boolean read GetHasServiceRequestedList;

    // Any additional (administrative, financial or clinical) information required to support request for referral or transfer of care.  For example: Presenting problems/chief complaints Medical History Family History Alerts Allergy/Intolerance and Adverse Reactions Medications Observations/Assessments (may include cognitive and fundtional assessments) Diagnostic Reports Care Plan.
    property supportingInformationList : TFhirReferenceList{TFhirReference} read GetSupportingInformationList;
    property hasSupportingInformationList : boolean read GetHasSupportingInformationList;

    // Typed access to The period of time within which the services identified in the referral/transfer of care is specified or required to occur. (defined for API consistency)
    property fulfillmentTime : TFhirPeriod read FFulfillmentTime write SetFulfillmentTime;
    // The period of time within which the services identified in the referral/transfer of care is specified or required to occur.
    property fulfillmentTimeElement : TFhirPeriod read FFulfillmentTime write SetFulfillmentTime;

  end;

  TFhirReferralRequestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirReferralRequestList;
    function GetCurrent : TFhirReferralRequest;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirReferralRequestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirReferralRequest read GetCurrent;
  end;

  TFhirReferralRequestList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirReferralRequest;
    procedure SetItemN(index : Integer; value : TFhirReferralRequest);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirReferralRequestList; Overload;
    function Clone : TFhirReferralRequestList; Overload;
    function GetEnumerator : TFhirReferralRequestListEnumerator;

    //  Add a FhirReferralRequest to the end of the list.
    function Append : TFhirReferralRequest;

    // Add an already existing FhirReferralRequest to the end of the list.
    procedure AddItem(value : TFhirReferralRequest); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirReferralRequest) : Integer;

    // Insert FhirReferralRequest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirReferralRequest;

    // Insert an existing FhirReferralRequest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirReferralRequest);

    // Get the iIndexth FhirReferralRequest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirReferralRequest);

    // The number of items in the collection
    function Item(index : Integer) : TFhirReferralRequest;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirReferralRequests[index : Integer] : TFhirReferralRequest read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_REFERRALREQUEST}

{$IFDEF FHIR_RISKASSESSMENT}

  // Describes the expected outcome for the subject.
  TFhirRiskAssessmentPrediction = class (TFhirBackboneElement)
  protected
    FOutcome : TFhirCodeableConcept;
    FProbability : TFhirType;
    FRelativeRisk : TFhirDecimal;
    FWhen : TFhirType;
    FRationale : TFhirString;
    Procedure SetOutcome(value : TFhirCodeableConcept);
    Procedure SetProbability(value : TFhirType);
    Procedure SetRelativeRisk(value : TFhirDecimal);
    Function GetRelativeRiskST : String;
    Procedure SetRelativeRiskST(value : String);
    Procedure SetWhen(value : TFhirType);
    Procedure SetRationale(value : TFhirString);
    Function GetRationaleST : String;
    Procedure SetRationaleST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRiskAssessmentPrediction; overload;
    function Clone : TFhirRiskAssessmentPrediction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to One of the potential outcomes for the patient (e.g. remission, death,  a particular condition). (defined for API consistency)
    property outcome : TFhirCodeableConcept read FOutcome write SetOutcome;
    // One of the potential outcomes for the patient (e.g. remission, death,  a particular condition).
    property outcomeElement : TFhirCodeableConcept read FOutcome write SetOutcome;

    // Typed access to How likely is the outcome (in the specified timeframe). (defined for API consistency)
    property probability : TFhirType read FProbability write SetProbability;
    // How likely is the outcome (in the specified timeframe).
    property probabilityElement : TFhirType read FProbability write SetProbability;

    // Typed access to Indicates the risk for this particular subject (with their specific characteristics) divided by the risk of the population in general.  (Numbers greater than 1 = higher risk than the population, numbers less than 1 = lower risk.).
    property relativeRisk : String read GetRelativeRiskST write SetRelativeRiskST;
    // Indicates the risk for this particular subject (with their specific characteristics) divided by the risk of the population in general.  (Numbers greater than 1 = higher risk than the population, numbers less than 1 = lower risk.).
    property relativeRiskElement : TFhirDecimal read FRelativeRisk write SetRelativeRisk;

    // Typed access to Indicates the period of time or age range of the subject to which the specified probability applies. (defined for API consistency)
    property when : TFhirType read FWhen write SetWhen;
    // Indicates the period of time or age range of the subject to which the specified probability applies.
    property whenElement : TFhirType read FWhen write SetWhen;

    // Typed access to Additional information explaining the basis for the prediction.
    property rationale : String read GetRationaleST write SetRationaleST;
    // Additional information explaining the basis for the prediction.
    property rationaleElement : TFhirString read FRationale write SetRationale;

  end;

  TFhirRiskAssessmentPredictionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRiskAssessmentPredictionList;
    function GetCurrent : TFhirRiskAssessmentPrediction;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirRiskAssessmentPredictionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRiskAssessmentPrediction read GetCurrent;
  end;

  TFhirRiskAssessmentPredictionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirRiskAssessmentPrediction;
    procedure SetItemN(index : Integer; value : TFhirRiskAssessmentPrediction);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirRiskAssessmentPredictionList; Overload;
    function Clone : TFhirRiskAssessmentPredictionList; Overload;
    function GetEnumerator : TFhirRiskAssessmentPredictionListEnumerator;

    //  Add a FhirRiskAssessmentPrediction to the end of the list.
    function Append : TFhirRiskAssessmentPrediction;

    // Add an already existing FhirRiskAssessmentPrediction to the end of the list.
    procedure AddItem(value : TFhirRiskAssessmentPrediction); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRiskAssessmentPrediction) : Integer;

    // Insert FhirRiskAssessmentPrediction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRiskAssessmentPrediction;

    // Insert an existing FhirRiskAssessmentPrediction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRiskAssessmentPrediction);

    // Get the iIndexth FhirRiskAssessmentPrediction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRiskAssessmentPrediction);

    // The number of items in the collection
    function Item(index : Integer) : TFhirRiskAssessmentPrediction;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirRiskAssessmentPredictions[index : Integer] : TFhirRiskAssessmentPrediction read GetItemN write SetItemN; default;
  End;

  // An assessment of the likely outcome(s) for a patient or other subject as well as the likelihood of each outcome.
  TFhirRiskAssessment = class (TFhirDomainResource)
  protected
    FSubject : TFhirReference{Resource};
    FDate : TFhirDateTime;
    FCondition : TFhirReference{TFhirCondition};
    FEncounter : TFhirReference{TFhirEncounter};
    FPerformer : TFhirReference{Resource};
    FIdentifier : TFhirIdentifier;
    FMethod : TFhirCodeableConcept;
    FbasisList : TFhirReferenceList{TFhirReference};
    FpredictionList : TFhirRiskAssessmentPredictionList;
    FMitigation : TFhirString;
    Procedure SetSubject(value : TFhirReference{Resource});
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetCondition(value : TFhirReference{TFhirCondition});
    Procedure SetEncounter(value : TFhirReference{TFhirEncounter});
    Procedure SetPerformer(value : TFhirReference{Resource});
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetMethod(value : TFhirCodeableConcept);
    function GetBasisList : TFhirReferenceList{TFhirReference};
    function GetHasBasisList : Boolean;
    function GetPredictionList : TFhirRiskAssessmentPredictionList;
    function GetHasPredictionList : Boolean;
    Procedure SetMitigation(value : TFhirString);
    Function GetMitigationST : String;
    Procedure SetMitigationST(value : String);

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRiskAssessment; overload;
    function Clone : TFhirRiskAssessment; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The patient or group the risk assessment applies to. (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // The patient or group the risk assessment applies to.
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // Typed access to The date (and possibly time) the risk assessment was performed.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date (and possibly time) the risk assessment was performed.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to For assessments or prognosis specific to a particular condition, indicates the condition being assessed. (defined for API consistency)
    property condition : TFhirReference{TFhirCondition} read FCondition write SetCondition;
    // For assessments or prognosis specific to a particular condition, indicates the condition being assessed.
    property conditionElement : TFhirReference{TFhirCondition} read FCondition write SetCondition;

    // Typed access to The encounter where the assessment was performed. (defined for API consistency)
    property encounter : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;
    // The encounter where the assessment was performed.
    property encounterElement : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;

    // Typed access to The provider or software application that performed the assessment. (defined for API consistency)
    property performer : TFhirReference{Resource} read FPerformer write SetPerformer;
    // The provider or software application that performed the assessment.
    property performerElement : TFhirReference{Resource} read FPerformer write SetPerformer;

    // Typed access to Business identifier assigned to the risk assessment. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Business identifier assigned to the risk assessment.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to The algorithm, process or mechanism used to evaluate the risk. (defined for API consistency)
    property method : TFhirCodeableConcept read FMethod write SetMethod;
    // The algorithm, process or mechanism used to evaluate the risk.
    property methodElement : TFhirCodeableConcept read FMethod write SetMethod;

    // Indicates the source data considered as part of the assessment (FamilyHistory, Observations, Procedures, Conditions, etc.).
    property basisList : TFhirReferenceList{TFhirReference} read GetBasisList;
    property hasBasisList : boolean read GetHasBasisList;

    // Describes the expected outcome for the subject.
    property predictionList : TFhirRiskAssessmentPredictionList read GetPredictionList;
    property hasPredictionList : boolean read GetHasPredictionList;

    // Typed access to A description of the steps that might be taken to reduce the identified risk(s).
    property mitigation : String read GetMitigationST write SetMitigationST;
    // A description of the steps that might be taken to reduce the identified risk(s).
    property mitigationElement : TFhirString read FMitigation write SetMitigation;

  end;

  TFhirRiskAssessmentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRiskAssessmentList;
    function GetCurrent : TFhirRiskAssessment;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirRiskAssessmentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRiskAssessment read GetCurrent;
  end;

  TFhirRiskAssessmentList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirRiskAssessment;
    procedure SetItemN(index : Integer; value : TFhirRiskAssessment);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirRiskAssessmentList; Overload;
    function Clone : TFhirRiskAssessmentList; Overload;
    function GetEnumerator : TFhirRiskAssessmentListEnumerator;

    //  Add a FhirRiskAssessment to the end of the list.
    function Append : TFhirRiskAssessment;

    // Add an already existing FhirRiskAssessment to the end of the list.
    procedure AddItem(value : TFhirRiskAssessment); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRiskAssessment) : Integer;

    // Insert FhirRiskAssessment before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRiskAssessment;

    // Insert an existing FhirRiskAssessment before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRiskAssessment);

    // Get the iIndexth FhirRiskAssessment. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRiskAssessment);

    // The number of items in the collection
    function Item(index : Integer) : TFhirRiskAssessment;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirRiskAssessments[index : Integer] : TFhirRiskAssessment read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_RISKASSESSMENT}

{$IFDEF FHIR_SPECIMEN}

  // Details concerning the specimen collection.
  TFhirSpecimenCollection = class (TFhirBackboneElement)
  protected
    FCollector : TFhirReference{TFhirPractitioner};
    FcommentList : TFhirStringList;
    FCollected : TFhirType;
    FQuantity : TFhirQuantity;
    FMethod : TFhirCodeableConcept;
    FBodySite : TFhirCodeableConcept;
    Procedure SetCollector(value : TFhirReference{TFhirPractitioner});
    function GetCommentList : TFhirStringList;
    function GetHasCommentList : Boolean;
    Procedure SetCollected(value : TFhirType);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetMethod(value : TFhirCodeableConcept);
    Procedure SetBodySite(value : TFhirCodeableConcept);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSpecimenCollection; overload;
    function Clone : TFhirSpecimenCollection; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Person who collected the specimen. (defined for API consistency)
    property collector : TFhirReference{TFhirPractitioner} read FCollector write SetCollector;
    // Person who collected the specimen.
    property collectorElement : TFhirReference{TFhirPractitioner} read FCollector write SetCollector;

    // To communicate any details or issues encountered during the specimen collection procedure.
    property commentList : TFhirStringList read GetCommentList;
    property hasCommentList : boolean read GetHasCommentList;

    // Typed access to Time when specimen was collected from subject - the physiologically relevant time. (defined for API consistency)
    property collected : TFhirType read FCollected write SetCollected;
    // Time when specimen was collected from subject - the physiologically relevant time.
    property collectedElement : TFhirType read FCollected write SetCollected;

    // Typed access to The quantity of specimen collected; for instance the volume of a blood sample, or the physical measurement of an anatomic pathology sample. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The quantity of specimen collected; for instance the volume of a blood sample, or the physical measurement of an anatomic pathology sample.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to A coded value specifying the technique that is used to perform the procedure. (defined for API consistency)
    property method : TFhirCodeableConcept read FMethod write SetMethod;
    // A coded value specifying the technique that is used to perform the procedure.
    property methodElement : TFhirCodeableConcept read FMethod write SetMethod;

    // Typed access to Anatomical location from which the specimen was collected (if subject is a patient). This is the target site.  This element is not used for environmental specimens. (defined for API consistency)
    property bodySite : TFhirCodeableConcept read FBodySite write SetBodySite;
    // Anatomical location from which the specimen was collected (if subject is a patient). This is the target site.  This element is not used for environmental specimens.
    property bodySiteElement : TFhirCodeableConcept read FBodySite write SetBodySite;

  end;

  TFhirSpecimenCollectionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSpecimenCollectionList;
    function GetCurrent : TFhirSpecimenCollection;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSpecimenCollectionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSpecimenCollection read GetCurrent;
  end;

  TFhirSpecimenCollectionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSpecimenCollection;
    procedure SetItemN(index : Integer; value : TFhirSpecimenCollection);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSpecimenCollectionList; Overload;
    function Clone : TFhirSpecimenCollectionList; Overload;
    function GetEnumerator : TFhirSpecimenCollectionListEnumerator;

    //  Add a FhirSpecimenCollection to the end of the list.
    function Append : TFhirSpecimenCollection;

    // Add an already existing FhirSpecimenCollection to the end of the list.
    procedure AddItem(value : TFhirSpecimenCollection); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSpecimenCollection) : Integer;

    // Insert FhirSpecimenCollection before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSpecimenCollection;

    // Insert an existing FhirSpecimenCollection before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSpecimenCollection);

    // Get the iIndexth FhirSpecimenCollection. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSpecimenCollection);

    // The number of items in the collection
    function Item(index : Integer) : TFhirSpecimenCollection;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirSpecimenCollections[index : Integer] : TFhirSpecimenCollection read GetItemN write SetItemN; default;
  End;

  // Details concerning treatment and processing steps for the specimen.
  TFhirSpecimenTreatment = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FProcedure_ : TFhirCodeableConcept;
    FadditiveList : TFhirReferenceList{TFhirSubstance};
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetProcedure_(value : TFhirCodeableConcept);
    function GetAdditiveList : TFhirReferenceList{TFhirSubstance};
    function GetHasAdditiveList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSpecimenTreatment; overload;
    function Clone : TFhirSpecimenTreatment; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Textual description of procedure.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Textual description of procedure.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to A coded value specifying the procedure used to process the specimen. (defined for API consistency)
    property procedure_ : TFhirCodeableConcept read FProcedure_ write SetProcedure_;
    // A coded value specifying the procedure used to process the specimen.
    property procedure_Element : TFhirCodeableConcept read FProcedure_ write SetProcedure_;

    // Material used in the processing step.
    property additiveList : TFhirReferenceList{TFhirSubstance} read GetAdditiveList;
    property hasAdditiveList : boolean read GetHasAdditiveList;

  end;

  TFhirSpecimenTreatmentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSpecimenTreatmentList;
    function GetCurrent : TFhirSpecimenTreatment;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSpecimenTreatmentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSpecimenTreatment read GetCurrent;
  end;

  TFhirSpecimenTreatmentList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSpecimenTreatment;
    procedure SetItemN(index : Integer; value : TFhirSpecimenTreatment);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSpecimenTreatmentList; Overload;
    function Clone : TFhirSpecimenTreatmentList; Overload;
    function GetEnumerator : TFhirSpecimenTreatmentListEnumerator;

    //  Add a FhirSpecimenTreatment to the end of the list.
    function Append : TFhirSpecimenTreatment;

    // Add an already existing FhirSpecimenTreatment to the end of the list.
    procedure AddItem(value : TFhirSpecimenTreatment); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSpecimenTreatment) : Integer;

    // Insert FhirSpecimenTreatment before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSpecimenTreatment;

    // Insert an existing FhirSpecimenTreatment before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSpecimenTreatment);

    // Get the iIndexth FhirSpecimenTreatment. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSpecimenTreatment);

    // The number of items in the collection
    function Item(index : Integer) : TFhirSpecimenTreatment;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirSpecimenTreatments[index : Integer] : TFhirSpecimenTreatment read GetItemN write SetItemN; default;
  End;

  // The container holding the specimen.  The recursive nature of containers; i.e. blood in tube in tray in rack is not addressed here.
  TFhirSpecimenContainer = class (TFhirBackboneElement)
  protected
    FidentifierList : TFhirIdentifierList;
    FDescription : TFhirString;
    FType_ : TFhirCodeableConcept;
    FCapacity : TFhirQuantity;
    FSpecimenQuantity : TFhirQuantity;
    FAdditive : TFhirType;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetCapacity(value : TFhirQuantity);
    Procedure SetSpecimenQuantity(value : TFhirQuantity);
    Procedure SetAdditive(value : TFhirType);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSpecimenContainer; overload;
    function Clone : TFhirSpecimenContainer; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Id for container. There may be multiple; a manufacturer's bar code, lab assigned identifier, etc. The container ID may differ from the specimen id in some circumstances.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Textual description of the container.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Textual description of the container.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to The type of container associated with the specimen (e.g. slide, aliquot, etc.). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of container associated with the specimen (e.g. slide, aliquot, etc.).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The capacity (volume or other measure) the container may contain. (defined for API consistency)
    property capacity : TFhirQuantity read FCapacity write SetCapacity;
    // The capacity (volume or other measure) the container may contain.
    property capacityElement : TFhirQuantity read FCapacity write SetCapacity;

    // Typed access to The quantity of specimen in the container; may be volume, dimensions, or other appropriate measurements, depending on the specimen type. (defined for API consistency)
    property specimenQuantity : TFhirQuantity read FSpecimenQuantity write SetSpecimenQuantity;
    // The quantity of specimen in the container; may be volume, dimensions, or other appropriate measurements, depending on the specimen type.
    property specimenQuantityElement : TFhirQuantity read FSpecimenQuantity write SetSpecimenQuantity;

    // Typed access to Introduced substance to preserve, maintain or enhance the specimen. Examples: Formalin, Citrate, EDTA. (defined for API consistency)
    property additive : TFhirType read FAdditive write SetAdditive;
    // Introduced substance to preserve, maintain or enhance the specimen. Examples: Formalin, Citrate, EDTA.
    property additiveElement : TFhirType read FAdditive write SetAdditive;

  end;

  TFhirSpecimenContainerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSpecimenContainerList;
    function GetCurrent : TFhirSpecimenContainer;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSpecimenContainerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSpecimenContainer read GetCurrent;
  end;

  TFhirSpecimenContainerList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSpecimenContainer;
    procedure SetItemN(index : Integer; value : TFhirSpecimenContainer);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSpecimenContainerList; Overload;
    function Clone : TFhirSpecimenContainerList; Overload;
    function GetEnumerator : TFhirSpecimenContainerListEnumerator;

    //  Add a FhirSpecimenContainer to the end of the list.
    function Append : TFhirSpecimenContainer;

    // Add an already existing FhirSpecimenContainer to the end of the list.
    procedure AddItem(value : TFhirSpecimenContainer); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSpecimenContainer) : Integer;

    // Insert FhirSpecimenContainer before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSpecimenContainer;

    // Insert an existing FhirSpecimenContainer before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSpecimenContainer);

    // Get the iIndexth FhirSpecimenContainer. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSpecimenContainer);

    // The number of items in the collection
    function Item(index : Integer) : TFhirSpecimenContainer;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirSpecimenContainers[index : Integer] : TFhirSpecimenContainer read GetItemN write SetItemN; default;
  End;

  // A sample to be used for analysis.
  TFhirSpecimen = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FType_ : TFhirCodeableConcept;
    FparentList : TFhirReferenceList{TFhirSpecimen};
    FSubject : TFhirReference{Resource};
    FAccessionIdentifier : TFhirIdentifier;
    FReceivedTime : TFhirDateTime;
    FCollection : TFhirSpecimenCollection;
    FtreatmentList : TFhirSpecimenTreatmentList;
    FcontainerList : TFhirSpecimenContainerList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirSpecimenStatusEnum;
    Procedure SetStatusST(value : TFhirSpecimenStatusEnum);
    Procedure SetType_(value : TFhirCodeableConcept);
    function GetParentList : TFhirReferenceList{TFhirSpecimen};
    function GetHasParentList : Boolean;
    Procedure SetSubject(value : TFhirReference{Resource});
    Procedure SetAccessionIdentifier(value : TFhirIdentifier);
    Procedure SetReceivedTime(value : TFhirDateTime);
    Function GetReceivedTimeST : TFslDateTime;
    Procedure SetReceivedTimeST(value : TFslDateTime);
    Procedure SetCollection(value : TFhirSpecimenCollection);
    function GetTreatmentList : TFhirSpecimenTreatmentList;
    function GetHasTreatmentList : Boolean;
    function GetContainerList : TFhirSpecimenContainerList;
    function GetHasContainerList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSpecimen; overload;
    function Clone : TFhirSpecimen; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Id for specimen.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The availability of the specimen.
    property status : TFhirSpecimenStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The kind of material that forms the specimen. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The kind of material that forms the specimen.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Reference to the parent (source) specimen which is used when the specimen was either derived from or a component of another specimen.
    property parentList : TFhirReferenceList{TFhirSpecimen} read GetParentList;
    property hasParentList : boolean read GetHasParentList;

    // Typed access to Where the specimen came from. This may be from the patient(s) or from the environment or a device. (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // Where the specimen came from. This may be from the patient(s) or from the environment or a device.
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // Typed access to The identifier assigned by the lab when accessioning specimen(s). This is not necessarily the same as the specimen identifier, depending on local lab procedures. (defined for API consistency)
    property accessionIdentifier : TFhirIdentifier read FAccessionIdentifier write SetAccessionIdentifier;
    // The identifier assigned by the lab when accessioning specimen(s). This is not necessarily the same as the specimen identifier, depending on local lab procedures.
    property accessionIdentifierElement : TFhirIdentifier read FAccessionIdentifier write SetAccessionIdentifier;

    // Typed access to Time when specimen was received for processing or testing.
    property receivedTime : TFslDateTime read GetReceivedTimeST write SetReceivedTimeST;
    // Time when specimen was received for processing or testing.
    property receivedTimeElement : TFhirDateTime read FReceivedTime write SetReceivedTime;

    // Typed access to Details concerning the specimen collection. (defined for API consistency)
    property collection : TFhirSpecimenCollection read FCollection write SetCollection;
    // Details concerning the specimen collection.
    property collectionElement : TFhirSpecimenCollection read FCollection write SetCollection;

    // Details concerning treatment and processing steps for the specimen.
    property treatmentList : TFhirSpecimenTreatmentList read GetTreatmentList;
    property hasTreatmentList : boolean read GetHasTreatmentList;

    // The container holding the specimen.  The recursive nature of containers; i.e. blood in tube in tray in rack is not addressed here.
    property containerList : TFhirSpecimenContainerList read GetContainerList;
    property hasContainerList : boolean read GetHasContainerList;

  end;

  TFhirSpecimenListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSpecimenList;
    function GetCurrent : TFhirSpecimen;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSpecimenList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSpecimen read GetCurrent;
  end;

  TFhirSpecimenList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSpecimen;
    procedure SetItemN(index : Integer; value : TFhirSpecimen);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSpecimenList; Overload;
    function Clone : TFhirSpecimenList; Overload;
    function GetEnumerator : TFhirSpecimenListEnumerator;

    //  Add a FhirSpecimen to the end of the list.
    function Append : TFhirSpecimen;

    // Add an already existing FhirSpecimen to the end of the list.
    procedure AddItem(value : TFhirSpecimen); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSpecimen) : Integer;

    // Insert FhirSpecimen before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSpecimen;

    // Insert an existing FhirSpecimen before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSpecimen);

    // Get the iIndexth FhirSpecimen. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSpecimen);

    // The number of items in the collection
    function Item(index : Integer) : TFhirSpecimen;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirSpecimen[index : Integer] : TFhirSpecimen read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SPECIMEN}

{$IFDEF FHIR_SUPPLYDELIVERY}

  // Record of delivery of what is supplied.
  TFhirSupplyDelivery = class (TFhirDomainResource)
  protected
    FIdentifier : TFhirIdentifier;
    FStatus : TFhirEnum;
    FPatient : TFhirReference{TFhirPatient};
    FType_ : TFhirCodeableConcept;
    FQuantity : TFhirQuantity;
    FSuppliedItem : TFhirReference{Resource};
    FSupplier : TFhirReference{TFhirPractitioner};
    FWhenPrepared : TFhirPeriod;
    FTime : TFhirDateTime;
    FDestination : TFhirReference{TFhirLocation};
    FreceiverList : TFhirReferenceList{TFhirPractitioner};
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirSupplydeliveryStatusEnum;
    Procedure SetStatusST(value : TFhirSupplydeliveryStatusEnum);
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetSuppliedItem(value : TFhirReference{Resource});
    Procedure SetSupplier(value : TFhirReference{TFhirPractitioner});
    Procedure SetWhenPrepared(value : TFhirPeriod);
    Procedure SetTime(value : TFhirDateTime);
    Function GetTimeST : TFslDateTime;
    Procedure SetTimeST(value : TFslDateTime);
    Procedure SetDestination(value : TFhirReference{TFhirLocation});
    function GetReceiverList : TFhirReferenceList{TFhirPractitioner};
    function GetHasReceiverList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSupplyDelivery; overload;
    function Clone : TFhirSupplyDelivery; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Identifier assigned by the dispensing facility when the item(s) is dispensed. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Identifier assigned by the dispensing facility when the item(s) is dispensed.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // A code specifying the state of the dispense event.
    property status : TFhirSupplydeliveryStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A link to a resource representing the person whom the delivered item is for. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // A link to a resource representing the person whom the delivered item is for.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Typed access to Indicates the type of dispensing event that is performed. Examples include: Trial Fill, Completion of Trial, Partial Fill, Emergency Fill, Samples, etc. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Indicates the type of dispensing event that is performed. Examples include: Trial Fill, Completion of Trial, Partial Fill, Emergency Fill, Samples, etc.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The amount of supply that has been dispensed. Includes unit of measure. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The amount of supply that has been dispensed. Includes unit of measure.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to Identifies the medication, substance or device being dispensed. This is either a link to a resource representing the details of the item or a simple attribute carrying a code that identifies the item from a known list. (defined for API consistency)
    property suppliedItem : TFhirReference{Resource} read FSuppliedItem write SetSuppliedItem;
    // Identifies the medication, substance or device being dispensed. This is either a link to a resource representing the details of the item or a simple attribute carrying a code that identifies the item from a known list.
    property suppliedItemElement : TFhirReference{Resource} read FSuppliedItem write SetSuppliedItem;

    // Typed access to The individual responsible for dispensing the medication, supplier or device. (defined for API consistency)
    property supplier : TFhirReference{TFhirPractitioner} read FSupplier write SetSupplier;
    // The individual responsible for dispensing the medication, supplier or device.
    property supplierElement : TFhirReference{TFhirPractitioner} read FSupplier write SetSupplier;

    // Typed access to The time the dispense event occurred. (defined for API consistency)
    property whenPrepared : TFhirPeriod read FWhenPrepared write SetWhenPrepared;
    // The time the dispense event occurred.
    property whenPreparedElement : TFhirPeriod read FWhenPrepared write SetWhenPrepared;

    // Typed access to The time the dispensed item was sent or handed to the patient (or agent).
    property time : TFslDateTime read GetTimeST write SetTimeST;
    // The time the dispensed item was sent or handed to the patient (or agent).
    property timeElement : TFhirDateTime read FTime write SetTime;

    // Typed access to Identification of the facility/location where the Supply was shipped to, as part of the dispense event. (defined for API consistency)
    property destination : TFhirReference{TFhirLocation} read FDestination write SetDestination;
    // Identification of the facility/location where the Supply was shipped to, as part of the dispense event.
    property destinationElement : TFhirReference{TFhirLocation} read FDestination write SetDestination;

    // Identifies the person who picked up the Supply.
    property receiverList : TFhirReferenceList{TFhirPractitioner} read GetReceiverList;
    property hasReceiverList : boolean read GetHasReceiverList;

  end;

  TFhirSupplyDeliveryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSupplyDeliveryList;
    function GetCurrent : TFhirSupplyDelivery;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSupplyDeliveryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSupplyDelivery read GetCurrent;
  end;

  TFhirSupplyDeliveryList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSupplyDelivery;
    procedure SetItemN(index : Integer; value : TFhirSupplyDelivery);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSupplyDeliveryList; Overload;
    function Clone : TFhirSupplyDeliveryList; Overload;
    function GetEnumerator : TFhirSupplyDeliveryListEnumerator;

    //  Add a FhirSupplyDelivery to the end of the list.
    function Append : TFhirSupplyDelivery;

    // Add an already existing FhirSupplyDelivery to the end of the list.
    procedure AddItem(value : TFhirSupplyDelivery); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSupplyDelivery) : Integer;

    // Insert FhirSupplyDelivery before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSupplyDelivery;

    // Insert an existing FhirSupplyDelivery before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSupplyDelivery);

    // Get the iIndexth FhirSupplyDelivery. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSupplyDelivery);

    // The number of items in the collection
    function Item(index : Integer) : TFhirSupplyDelivery;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirSupplyDeliveries[index : Integer] : TFhirSupplyDelivery read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SUPPLYDELIVERY}

{$IFDEF FHIR_SUPPLYREQUEST}

  // When the request should be fulfilled.
  TFhirSupplyRequestWhen = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FSchedule : TFhirTiming;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetSchedule(value : TFhirTiming);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSupplyRequestWhen; overload;
    function Clone : TFhirSupplyRequestWhen; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Code indicating when the request should be fulfilled. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Code indicating when the request should be fulfilled.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to Formal fulfillment schedule. (defined for API consistency)
    property schedule : TFhirTiming read FSchedule write SetSchedule;
    // Formal fulfillment schedule.
    property scheduleElement : TFhirTiming read FSchedule write SetSchedule;

  end;

  TFhirSupplyRequestWhenListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSupplyRequestWhenList;
    function GetCurrent : TFhirSupplyRequestWhen;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSupplyRequestWhenList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSupplyRequestWhen read GetCurrent;
  end;

  TFhirSupplyRequestWhenList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSupplyRequestWhen;
    procedure SetItemN(index : Integer; value : TFhirSupplyRequestWhen);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSupplyRequestWhenList; Overload;
    function Clone : TFhirSupplyRequestWhenList; Overload;
    function GetEnumerator : TFhirSupplyRequestWhenListEnumerator;

    //  Add a FhirSupplyRequestWhen to the end of the list.
    function Append : TFhirSupplyRequestWhen;

    // Add an already existing FhirSupplyRequestWhen to the end of the list.
    procedure AddItem(value : TFhirSupplyRequestWhen); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSupplyRequestWhen) : Integer;

    // Insert FhirSupplyRequestWhen before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSupplyRequestWhen;

    // Insert an existing FhirSupplyRequestWhen before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSupplyRequestWhen);

    // Get the iIndexth FhirSupplyRequestWhen. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSupplyRequestWhen);

    // The number of items in the collection
    function Item(index : Integer) : TFhirSupplyRequestWhen;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirSupplyRequestWhens[index : Integer] : TFhirSupplyRequestWhen read GetItemN write SetItemN; default;
  End;

  // A record of a request for a medication, substance or device used in the healthcare setting.
  TFhirSupplyRequest = class (TFhirDomainResource)
  protected
    FPatient : TFhirReference{TFhirPatient};
    FSource : TFhirReference{Resource};
    FDate : TFhirDateTime;
    FIdentifier : TFhirIdentifier;
    FStatus : TFhirEnum;
    FKind : TFhirCodeableConcept;
    FOrderedItem : TFhirReference{Resource};
    FsupplierList : TFhirReferenceList{TFhirOrganization};
    FReason : TFhirType;
    FWhen : TFhirSupplyRequestWhen;
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    Procedure SetSource(value : TFhirReference{Resource});
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirSupplyrequestStatusEnum;
    Procedure SetStatusST(value : TFhirSupplyrequestStatusEnum);
    Procedure SetKind(value : TFhirCodeableConcept);
    Procedure SetOrderedItem(value : TFhirReference{Resource});
    function GetSupplierList : TFhirReferenceList{TFhirOrganization};
    function GetHasSupplierList : Boolean;
    Procedure SetReason(value : TFhirType);
    Procedure SetWhen(value : TFhirSupplyRequestWhen);

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSupplyRequest; overload;
    function Clone : TFhirSupplyRequest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A link to a resource representing the person whom the ordered item is for. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // A link to a resource representing the person whom the ordered item is for.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Typed access to The Practitioner , Organization or Patient who initiated this order for the supply. (defined for API consistency)
    property source : TFhirReference{Resource} read FSource write SetSource;
    // The Practitioner , Organization or Patient who initiated this order for the supply.
    property sourceElement : TFhirReference{Resource} read FSource write SetSource;

    // Typed access to When the request was made.
    property date : TFslDateTime read GetDateST write SetDateST;
    // When the request was made.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to Unique identifier for this supply request. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Unique identifier for this supply request.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Status of the supply request.
    property status : TFhirSupplyrequestStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Category of supply, e.g.  central, non-stock, etc. This is used to support work flows associated with the supply process. (defined for API consistency)
    property kind : TFhirCodeableConcept read FKind write SetKind;
    // Category of supply, e.g.  central, non-stock, etc. This is used to support work flows associated with the supply process.
    property kindElement : TFhirCodeableConcept read FKind write SetKind;

    // Typed access to The item that is requested to be supplied. (defined for API consistency)
    property orderedItem : TFhirReference{Resource} read FOrderedItem write SetOrderedItem;
    // The item that is requested to be supplied.
    property orderedItemElement : TFhirReference{Resource} read FOrderedItem write SetOrderedItem;

    // Who is intended to fulfill the request.
    property supplierList : TFhirReferenceList{TFhirOrganization} read GetSupplierList;
    property hasSupplierList : boolean read GetHasSupplierList;

    // Typed access to Why the supply item was requested. (defined for API consistency)
    property reason : TFhirType read FReason write SetReason;
    // Why the supply item was requested.
    property reasonElement : TFhirType read FReason write SetReason;

    // Typed access to When the request should be fulfilled. (defined for API consistency)
    property when : TFhirSupplyRequestWhen read FWhen write SetWhen;
    // When the request should be fulfilled.
    property whenElement : TFhirSupplyRequestWhen read FWhen write SetWhen;

  end;

  TFhirSupplyRequestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSupplyRequestList;
    function GetCurrent : TFhirSupplyRequest;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSupplyRequestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSupplyRequest read GetCurrent;
  end;

  TFhirSupplyRequestList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSupplyRequest;
    procedure SetItemN(index : Integer; value : TFhirSupplyRequest);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSupplyRequestList; Overload;
    function Clone : TFhirSupplyRequestList; Overload;
    function GetEnumerator : TFhirSupplyRequestListEnumerator;

    //  Add a FhirSupplyRequest to the end of the list.
    function Append : TFhirSupplyRequest;

    // Add an already existing FhirSupplyRequest to the end of the list.
    procedure AddItem(value : TFhirSupplyRequest); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSupplyRequest) : Integer;

    // Insert FhirSupplyRequest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSupplyRequest;

    // Insert an existing FhirSupplyRequest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSupplyRequest);

    // Get the iIndexth FhirSupplyRequest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSupplyRequest);

    // The number of items in the collection
    function Item(index : Integer) : TFhirSupplyRequest;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirSupplyRequests[index : Integer] : TFhirSupplyRequest read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SUPPLYREQUEST}

{$IFDEF FHIR_VISIONPRESCRIPTION}

  // Deals with details of the dispense part of the supply specification.
  TFhirVisionPrescriptionDispense = class (TFhirBackboneElement)
  protected
    FProduct : TFhirCoding;
    FEye : TFhirEnum;
    FSphere : TFhirDecimal;
    FCylinder : TFhirDecimal;
    FAxis : TFhirInteger;
    FPrism : TFhirDecimal;
    FBase : TFhirEnum;
    FAdd : TFhirDecimal;
    FPower : TFhirDecimal;
    FBackCurve : TFhirDecimal;
    FDiameter : TFhirDecimal;
    FDuration : TFhirQuantity;
    FColor : TFhirString;
    FBrand : TFhirString;
    FNotes : TFhirString;
    Procedure SetProduct(value : TFhirCoding);
    Procedure SetEye(value : TFhirEnum);
    Function GetEyeST : TFhirVisionEyeCodesEnum;
    Procedure SetEyeST(value : TFhirVisionEyeCodesEnum);
    Procedure SetSphere(value : TFhirDecimal);
    Function GetSphereST : String;
    Procedure SetSphereST(value : String);
    Procedure SetCylinder(value : TFhirDecimal);
    Function GetCylinderST : String;
    Procedure SetCylinderST(value : String);
    Procedure SetAxis(value : TFhirInteger);
    Function GetAxisST : String;
    Procedure SetAxisST(value : String);
    Procedure SetPrism(value : TFhirDecimal);
    Function GetPrismST : String;
    Procedure SetPrismST(value : String);
    Procedure SetBase(value : TFhirEnum);
    Function GetBaseST : TFhirVisionBaseCodesEnum;
    Procedure SetBaseST(value : TFhirVisionBaseCodesEnum);
    Procedure SetAdd(value : TFhirDecimal);
    Function GetAddST : String;
    Procedure SetAddST(value : String);
    Procedure SetPower(value : TFhirDecimal);
    Function GetPowerST : String;
    Procedure SetPowerST(value : String);
    Procedure SetBackCurve(value : TFhirDecimal);
    Function GetBackCurveST : String;
    Procedure SetBackCurveST(value : String);
    Procedure SetDiameter(value : TFhirDecimal);
    Function GetDiameterST : String;
    Procedure SetDiameterST(value : String);
    Procedure SetDuration(value : TFhirQuantity);
    Procedure SetColor(value : TFhirString);
    Function GetColorST : String;
    Procedure SetColorST(value : String);
    Procedure SetBrand(value : TFhirString);
    Function GetBrandST : String;
    Procedure SetBrandST(value : String);
    Procedure SetNotes(value : TFhirString);
    Function GetNotesST : String;
    Procedure SetNotesST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirVisionPrescriptionDispense; overload;
    function Clone : TFhirVisionPrescriptionDispense; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Identifies the type of vision correction product which is required for the patient. (defined for API consistency)
    property product : TFhirCoding read FProduct write SetProduct;
    // Identifies the type of vision correction product which is required for the patient.
    property productElement : TFhirCoding read FProduct write SetProduct;

    // The eye for which the lens applies.
    property eye : TFhirVisionEyeCodesEnum read GetEyeST write SetEyeST;
    property eyeElement : TFhirEnum read FEye write SetEye;

    // Typed access to Lens power measured in diopters (0.25 units).
    property sphere : String read GetSphereST write SetSphereST;
    // Lens power measured in diopters (0.25 units).
    property sphereElement : TFhirDecimal read FSphere write SetSphere;

    // Typed access to Power adjustment for astigmatism measured in diopters (0.25 units).
    property cylinder : String read GetCylinderST write SetCylinderST;
    // Power adjustment for astigmatism measured in diopters (0.25 units).
    property cylinderElement : TFhirDecimal read FCylinder write SetCylinder;

    // Typed access to Adjustment for astigmatism measured in integer degrees.
    property axis : String read GetAxisST write SetAxisST;
    // Adjustment for astigmatism measured in integer degrees.
    property axisElement : TFhirInteger read FAxis write SetAxis;

    // Typed access to Amount of prism to compensate for eye alignment in fractional units.
    property prism : String read GetPrismST write SetPrismST;
    // Amount of prism to compensate for eye alignment in fractional units.
    property prismElement : TFhirDecimal read FPrism write SetPrism;

    // The relative base, or reference lens edge, for the prism.
    property base : TFhirVisionBaseCodesEnum read GetBaseST write SetBaseST;
    property baseElement : TFhirEnum read FBase write SetBase;

    // Typed access to Power adjustment for multifocal lenses measured in diopters (0.25 units).
    property add : String read GetAddST write SetAddST;
    // Power adjustment for multifocal lenses measured in diopters (0.25 units).
    property addElement : TFhirDecimal read FAdd write SetAdd;

    // Typed access to Contact lens power measured in diopters (0.25 units).
    property power : String read GetPowerST write SetPowerST;
    // Contact lens power measured in diopters (0.25 units).
    property powerElement : TFhirDecimal read FPower write SetPower;

    // Typed access to Back curvature measured in millimeters.
    property backCurve : String read GetBackCurveST write SetBackCurveST;
    // Back curvature measured in millimeters.
    property backCurveElement : TFhirDecimal read FBackCurve write SetBackCurve;

    // Typed access to Contact lens diameter measured in millimeters.
    property diameter : String read GetDiameterST write SetDiameterST;
    // Contact lens diameter measured in millimeters.
    property diameterElement : TFhirDecimal read FDiameter write SetDiameter;

    // Typed access to The recommended maximum wear period for the lens. (defined for API consistency)
    property duration : TFhirQuantity read FDuration write SetDuration;
    // The recommended maximum wear period for the lens.
    property durationElement : TFhirQuantity read FDuration write SetDuration;

    // Typed access to Special color or pattern.
    property color : String read GetColorST write SetColorST;
    // Special color or pattern.
    property colorElement : TFhirString read FColor write SetColor;

    // Typed access to Brand recommendations or restrictions.
    property brand : String read GetBrandST write SetBrandST;
    // Brand recommendations or restrictions.
    property brandElement : TFhirString read FBrand write SetBrand;

    // Typed access to Notes for special requirements such as coatings and lens materials.
    property notes : String read GetNotesST write SetNotesST;
    // Notes for special requirements such as coatings and lens materials.
    property notesElement : TFhirString read FNotes write SetNotes;

  end;

  TFhirVisionPrescriptionDispenseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirVisionPrescriptionDispenseList;
    function GetCurrent : TFhirVisionPrescriptionDispense;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirVisionPrescriptionDispenseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirVisionPrescriptionDispense read GetCurrent;
  end;

  TFhirVisionPrescriptionDispenseList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirVisionPrescriptionDispense;
    procedure SetItemN(index : Integer; value : TFhirVisionPrescriptionDispense);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirVisionPrescriptionDispenseList; Overload;
    function Clone : TFhirVisionPrescriptionDispenseList; Overload;
    function GetEnumerator : TFhirVisionPrescriptionDispenseListEnumerator;

    //  Add a FhirVisionPrescriptionDispense to the end of the list.
    function Append : TFhirVisionPrescriptionDispense;

    // Add an already existing FhirVisionPrescriptionDispense to the end of the list.
    procedure AddItem(value : TFhirVisionPrescriptionDispense); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirVisionPrescriptionDispense) : Integer;

    // Insert FhirVisionPrescriptionDispense before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirVisionPrescriptionDispense;

    // Insert an existing FhirVisionPrescriptionDispense before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirVisionPrescriptionDispense);

    // Get the iIndexth FhirVisionPrescriptionDispense. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirVisionPrescriptionDispense);

    // The number of items in the collection
    function Item(index : Integer) : TFhirVisionPrescriptionDispense;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirVisionPrescriptionDispenses[index : Integer] : TFhirVisionPrescriptionDispense read GetItemN write SetItemN; default;
  End;

  // An authorization for the supply of glasses and/or contact lenses to a patient.
  TFhirVisionPrescription = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FDateWritten : TFhirDateTime;
    FPatient : TFhirReference{TFhirPatient};
    FPrescriber : TFhirReference{TFhirPractitioner};
    FEncounter : TFhirReference{TFhirEncounter};
    FReason : TFhirType;
    FdispenseList : TFhirVisionPrescriptionDispenseList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetDateWritten(value : TFhirDateTime);
    Function GetDateWrittenST : TFslDateTime;
    Procedure SetDateWrittenST(value : TFslDateTime);
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    Procedure SetPrescriber(value : TFhirReference{TFhirPractitioner});
    Procedure SetEncounter(value : TFhirReference{TFhirEncounter});
    Procedure SetReason(value : TFhirType);
    function GetDispenseList : TFhirVisionPrescriptionDispenseList;
    function GetHasDispenseList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirVisionPrescription; overload;
    function Clone : TFhirVisionPrescription; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifier which may be used by other parties to reference or identify the prescription.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The date (and perhaps time) when the prescription was written.
    property dateWritten : TFslDateTime read GetDateWrittenST write SetDateWrittenST;
    // The date (and perhaps time) when the prescription was written.
    property dateWrittenElement : TFhirDateTime read FDateWritten write SetDateWritten;

    // Typed access to A link to a resource representing the person to whom the vision products will be supplied. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // A link to a resource representing the person to whom the vision products will be supplied.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Typed access to The healthcare professional responsible for authorizing the prescription. (defined for API consistency)
    property prescriber : TFhirReference{TFhirPractitioner} read FPrescriber write SetPrescriber;
    // The healthcare professional responsible for authorizing the prescription.
    property prescriberElement : TFhirReference{TFhirPractitioner} read FPrescriber write SetPrescriber;

    // Typed access to A link to a resource that identifies the particular occurrence of contact between patient and health care provider. (defined for API consistency)
    property encounter : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;
    // A link to a resource that identifies the particular occurrence of contact between patient and health care provider.
    property encounterElement : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;

    // Typed access to Can be the reason or the indication for writing the prescription. (defined for API consistency)
    property reason : TFhirType read FReason write SetReason;
    // Can be the reason or the indication for writing the prescription.
    property reasonElement : TFhirType read FReason write SetReason;

    // Deals with details of the dispense part of the supply specification.
    property dispenseList : TFhirVisionPrescriptionDispenseList read GetDispenseList;
    property hasDispenseList : boolean read GetHasDispenseList;

  end;

  TFhirVisionPrescriptionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirVisionPrescriptionList;
    function GetCurrent : TFhirVisionPrescription;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirVisionPrescriptionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirVisionPrescription read GetCurrent;
  end;

  TFhirVisionPrescriptionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirVisionPrescription;
    procedure SetItemN(index : Integer; value : TFhirVisionPrescription);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirVisionPrescriptionList; Overload;
    function Clone : TFhirVisionPrescriptionList; Overload;
    function GetEnumerator : TFhirVisionPrescriptionListEnumerator;

    //  Add a FhirVisionPrescription to the end of the list.
    function Append : TFhirVisionPrescription;

    // Add an already existing FhirVisionPrescription to the end of the list.
    procedure AddItem(value : TFhirVisionPrescription); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirVisionPrescription) : Integer;

    // Insert FhirVisionPrescription before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirVisionPrescription;

    // Insert an existing FhirVisionPrescription before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirVisionPrescription);

    // Get the iIndexth FhirVisionPrescription. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirVisionPrescription);

    // The number of items in the collection
    function Item(index : Integer) : TFhirVisionPrescription;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirVisionPrescriptions[index : Integer] : TFhirVisionPrescription read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_VISIONPRESCRIPTION}

implementation

uses
  fhir2_utilities;

{$IFDEF FHIR_ACCOUNT}

{ TFhirAccount }

constructor TFhirAccount.Create;
begin
  inherited;
end;

destructor TFhirAccount.Destroy;
begin
  FIdentifierList.Free;
  FName.free;
  FType_.free;
  FStatus.free;
  FActivePeriod.free;
  FCurrency.free;
  FBalance.free;
  FCoveragePeriod.free;
  FSubject.free;
  FOwner.free;
  FDescription.free;
  inherited;
end;

function TFhirAccount.GetResourceType : TFhirResourceType;
begin
  result := frtAccount;
end;

procedure TFhirAccount.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirAccount(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirAccount(oSource).FIdentifierList);
  end;
  nameElement := TFhirAccount(oSource).nameElement.Clone;
  type_ := TFhirAccount(oSource).type_.Clone;
  statusElement := TFhirAccount(oSource).statusElement.Clone;
  activePeriod := TFhirAccount(oSource).activePeriod.Clone;
  currency := TFhirAccount(oSource).currency.Clone;
  balance := TFhirAccount(oSource).balance.Clone;
  coveragePeriod := TFhirAccount(oSource).coveragePeriod.Clone;
  subject := TFhirAccount(oSource).subject.Clone;
  owner := TFhirAccount(oSource).owner.Clone;
  descriptionElement := TFhirAccount(oSource).descriptionElement.Clone;
end;

procedure TFhirAccount.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'activePeriod') Then
     list.add(self.link, 'activePeriod', FActivePeriod.Link);
  if (child_name = 'currency') Then
     list.add(self.link, 'currency', FCurrency.Link);
  if (child_name = 'balance') Then
     list.add(self.link, 'balance', FBalance.Link);
  if (child_name = 'coveragePeriod') Then
     list.add(self.link, 'coveragePeriod', FCoveragePeriod.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'owner') Then
     list.add(self.link, 'owner', FOwner.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
end;

procedure TFhirAccount.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirCode, FStatus.Link));{2}
  oList.add(TFHIRProperty.create(self, 'activePeriod', 'Period', false, TFhirPeriod, FActivePeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'currency', 'Coding', false, TFhirCoding, FCurrency.Link));{2}
  oList.add(TFHIRProperty.create(self, 'balance', 'Quantity', false, TFhirQuantity, FBalance.Link));{2}
  oList.add(TFHIRProperty.create(self, 'coveragePeriod', 'Period', false, TFhirPeriod, FCoveragePeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Device|Practitioner|Location|HealthcareService|Organization)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'owner', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FOwner.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
end;

function TFhirAccount.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'activePeriod') then
  begin
    ActivePeriod := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'currency') then
  begin
    Currency := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'balance') then
  begin
    Balance := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'coveragePeriod') then
  begin
    CoveragePeriod := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'owner') then
  begin
    Owner := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirAccount.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else inherited;
end;

function TFhirAccount.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'status') then result := TFhirCode.create() {5b}
  else if (propName = 'activePeriod') then result := TFhirPeriod.create(){4b}
  else if (propName = 'currency') then result := TFhirCoding.create(){4b}
  else if (propName = 'balance') then result := TFhirQuantity.create(){4b}
  else if (propName = 'coveragePeriod') then result := TFhirPeriod.create(){4b}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'owner') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAccount.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'activePeriod') then result := 'Period'
  else if (propName = 'currency') then result := 'Coding'
  else if (propName = 'balance') then result := 'Quantity'
  else if (propName = 'coveragePeriod') then result := 'Period'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'owner') then result := 'Reference'
  else if (propName = 'description') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAccount.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'activePeriod') then ActivePeriodElement := nil
  else if (propName = 'currency') then CurrencyElement := nil
  else if (propName = 'balance') then BalanceElement := nil
  else if (propName = 'coveragePeriod') then CoveragePeriodElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'owner') then OwnerElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAccount.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'status') then StatusElement := asCode(new){5b}
  else if (propName = 'activePeriod') then ActivePeriodElement := new as TFhirPeriod{4}
  else if (propName = 'currency') then CurrencyElement := new as TFhirCoding{4}
  else if (propName = 'balance') then BalanceElement := new as TFhirQuantity{4}
  else if (propName = 'coveragePeriod') then CoveragePeriodElement := new as TFhirPeriod{4}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'owner') then OwnerElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAccount.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAccount.fhirType : string;
begin
  result := 'Account';
end;

function TFhirAccount.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FName) and isEmptyProp(FType_) and isEmptyProp(FStatus) and isEmptyProp(FActivePeriod) and isEmptyProp(FCurrency) and isEmptyProp(FBalance) and isEmptyProp(FCoveragePeriod) and isEmptyProp(FSubject) and isEmptyProp(FOwner) and isEmptyProp(FDescription);
end;

function TFhirAccount.equals(other : TObject) : boolean;
var
  o : TFhirAccount;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAccount)) then
    result := false
  else
  begin
    o := TFhirAccount(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(nameElement, o.nameElement, true) and
      compareDeep(type_Element, o.type_Element, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(activePeriodElement, o.activePeriodElement, true) and compareDeep(currencyElement, o.currencyElement, true) and
      compareDeep(balanceElement, o.balanceElement, true) and compareDeep(coveragePeriodElement, o.coveragePeriodElement, true) and
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(ownerElement, o.ownerElement, true) and
      compareDeep(descriptionElement, o.descriptionElement, true);
  end;
end;

function TFhirAccount.Link : TFhirAccount;
begin
  result := TFhirAccount(inherited Link);
end;

function TFhirAccount.Clone : TFhirAccount;
begin
  result := TFhirAccount(inherited Clone);
end;

procedure TFhirAccount.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('name');
  fields.add('type');
  fields.add('status');
  fields.add('activePeriod');
  fields.add('currency');
  fields.add('balance');
  fields.add('coveragePeriod');
  fields.add('subject');
  fields.add('owner');
  fields.add('description');
end;

{ TFhirAccount }

Function TFhirAccount.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirAccount.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirAccount.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirAccount.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirAccount.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirAccount.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirAccount.SetStatus(value : TFhirCode);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirAccount.GetStatusST : String;
begin
  if FStatus = nil then
    result := ''
  else
    result := FStatus.value;
end;

Procedure TFhirAccount.SetStatusST(value : String);
begin
  if value <> '' then
  begin
    if FStatus = nil then
      FStatus := TFhirCode.create;
    FStatus.value := value
  end
  else if FStatus <> nil then
    FStatus.value := '';
end;

Procedure TFhirAccount.SetActivePeriod(value : TFhirPeriod);
begin
  FActivePeriod.free;
  FActivePeriod := value;
end;

Procedure TFhirAccount.SetCurrency(value : TFhirCoding);
begin
  FCurrency.free;
  FCurrency := value;
end;

Procedure TFhirAccount.SetBalance(value : TFhirQuantity);
begin
  FBalance.free;
  FBalance := value;
end;

Procedure TFhirAccount.SetCoveragePeriod(value : TFhirPeriod);
begin
  FCoveragePeriod.free;
  FCoveragePeriod := value;
end;

Procedure TFhirAccount.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirAccount.SetOwner(value : TFhirReference{TFhirOrganization});
begin
  FOwner.free;
  FOwner := value;
end;

Procedure TFhirAccount.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirAccount.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirAccount.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirAccount.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FActivePeriod.sizeInBytes);
  inc(result, FCurrency.sizeInBytes);
  inc(result, FBalance.sizeInBytes);
  inc(result, FCoveragePeriod.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FOwner.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
end;

{ TFhirAccountListEnumerator }

Constructor TFhirAccountListEnumerator.Create(list : TFhirAccountList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAccountListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAccountListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAccountListEnumerator.GetCurrent : TFhirAccount;
begin
  Result := FList[FIndex];
end;

function TFhirAccountListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAccountList }
procedure TFhirAccountList.AddItem(value: TFhirAccount);
begin
  assert(value.ClassName = 'TFhirAccount', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAccount');
  add(value);
end;

function TFhirAccountList.Append: TFhirAccount;
begin
  result := TFhirAccount.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAccountList.ClearItems;
begin
  Clear;
end;

function TFhirAccountList.GetEnumerator : TFhirAccountListEnumerator;
begin
  result := TFhirAccountListEnumerator.Create(self.link);
end;

function TFhirAccountList.Clone: TFhirAccountList;
begin
  result := TFhirAccountList(inherited Clone);
end;

function TFhirAccountList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAccountList.GetItemN(index: Integer): TFhirAccount;
begin
  result := TFhirAccount(ObjectByIndex[index]);
end;

function TFhirAccountList.ItemClass: TFslObjectClass;
begin
  result := TFhirAccount;
end;
function TFhirAccountList.IndexOf(value: TFhirAccount): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAccountList.Insert(index: Integer): TFhirAccount;
begin
  result := TFhirAccount.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAccountList.InsertItem(index: Integer; value: TFhirAccount);
begin
  assert(value is TFhirAccount);
  Inherited Insert(index, value);
end;

function TFhirAccountList.Item(index: Integer): TFhirAccount;
begin
  result := TFhirAccount(ObjectByIndex[index]);
end;

function TFhirAccountList.Link: TFhirAccountList;
begin
  result := TFhirAccountList(inherited Link);
end;

procedure TFhirAccountList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAccountList.SetItemByIndex(index: Integer; value: TFhirAccount);
begin
  assert(value is TFhirAccount);
  FhirAccounts[index] := value;
end;

procedure TFhirAccountList.SetItemN(index: Integer; value: TFhirAccount);
begin
  assert(value is TFhirAccount);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ACCOUNT}

{$IFDEF FHIR_ALLERGYINTOLERANCE}

{ TFhirAllergyIntoleranceReaction }

constructor TFhirAllergyIntoleranceReaction.Create;
begin
  inherited;
end;

destructor TFhirAllergyIntoleranceReaction.Destroy;
begin
  FSubstance.free;
  FCertainty.free;
  FManifestationList.Free;
  FDescription.free;
  FOnset.free;
  FSeverity.free;
  FExposureRoute.free;
  FNote.free;
  inherited;
end;

procedure TFhirAllergyIntoleranceReaction.Assign(oSource : TFslObject);
begin
  inherited;
  substance := TFhirAllergyIntoleranceReaction(oSource).substance.Clone;
  FCertainty := TFhirAllergyIntoleranceReaction(oSource).FCertainty.Link;
  if (TFhirAllergyIntoleranceReaction(oSource).FManifestationList = nil) then
  begin
    FManifestationList.free;
    FManifestationList := nil;
  end
  else
  begin
    if FManifestationList = nil then
      FManifestationList := TFhirCodeableConceptList.Create;
    FManifestationList.Assign(TFhirAllergyIntoleranceReaction(oSource).FManifestationList);
  end;
  descriptionElement := TFhirAllergyIntoleranceReaction(oSource).descriptionElement.Clone;
  onsetElement := TFhirAllergyIntoleranceReaction(oSource).onsetElement.Clone;
  FSeverity := TFhirAllergyIntoleranceReaction(oSource).FSeverity.Link;
  exposureRoute := TFhirAllergyIntoleranceReaction(oSource).exposureRoute.Clone;
  note := TFhirAllergyIntoleranceReaction(oSource).note.Clone;
end;

procedure TFhirAllergyIntoleranceReaction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'substance') Then
     list.add(self.link, 'substance', FSubstance.Link);
  if (child_name = 'certainty') Then
     list.add(self.link, 'certainty', FCertainty.Link);
  if (child_name = 'manifestation') Then
    list.addAll(self, 'manifestation', FManifestationList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'onset') Then
     list.add(self.link, 'onset', FOnset.Link);
  if (child_name = 'severity') Then
     list.add(self.link, 'severity', FSeverity.Link);
  if (child_name = 'exposureRoute') Then
     list.add(self.link, 'exposureRoute', FExposureRoute.Link);
  if (child_name = 'note') Then
     list.add(self.link, 'note', FNote.Link);
end;

procedure TFhirAllergyIntoleranceReaction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'substance', 'CodeableConcept', false, TFhirCodeableConcept, FSubstance.Link));{2}
  oList.add(TFHIRProperty.create(self, 'certainty', 'code', false, TFHIREnum, FCertainty.Link));{1}
  oList.add(TFHIRProperty.create(self, 'manifestation', 'CodeableConcept', true, TFhirCodeableConcept, FManifestationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'onset', 'dateTime', false, TFhirDateTime, FOnset.Link));{2}
  oList.add(TFHIRProperty.create(self, 'severity', 'code', false, TFHIREnum, FSeverity.Link));{1}
  oList.add(TFHIRProperty.create(self, 'exposureRoute', 'CodeableConcept', false, TFhirCodeableConcept, FExposureRoute.Link));{2}
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', false, TFhirAnnotation, FNote.Link));{2}
end;

function TFhirAllergyIntoleranceReaction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'substance') then
  begin
    Substance := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'certainty') then
  begin
    CertaintyElement := asEnum(SYSTEMS_TFhirReactionEventCertaintyEnum, CODES_TFhirReactionEventCertaintyEnum, propValue);
    result := propValue
  end
  else if (propName = 'manifestation') then
  begin
    ManifestationList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'onset') then
  begin
    OnsetElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'severity') then
  begin
    SeverityElement := asEnum(SYSTEMS_TFhirReactionEventSeverityEnum, CODES_TFhirReactionEventSeverityEnum, propValue);
    result := propValue
  end
  else if (propName = 'exposureRoute') then
  begin
    ExposureRoute := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    Note := propValue as TFhirAnnotation{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAllergyIntoleranceReaction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'manifestation') then ManifestationList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirAllergyIntoleranceReaction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'substance') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'manifestation') then result := ManifestationList.new(){2}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'onset') then result := TFhirDateTime.create() {5b}
  else if (propName = 'exposureRoute') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'note') then result := TFhirAnnotation.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAllergyIntoleranceReaction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'substance') then result := 'CodeableConcept'
  else if (propName = 'certainty') then result := 'code'
  else if (propName = 'manifestation') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'onset') then result := 'dateTime'
  else if (propName = 'severity') then result := 'code'
  else if (propName = 'exposureRoute') then result := 'CodeableConcept'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAllergyIntoleranceReaction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'substance') then SubstanceElement := nil
  else if (propName = 'certainty') then CertaintyElement := nil
  else if (propName = 'manifestation') then deletePropertyValue('manifestation', ManifestationList, value) {2}
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'onset') then OnsetElement := nil
  else if (propName = 'severity') then SeverityElement := nil
  else if (propName = 'exposureRoute') then ExposureRouteElement := nil
  else if (propName = 'note') then NoteElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAllergyIntoleranceReaction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'substance') then SubstanceElement := new as TFhirCodeableConcept{4}
  else if (propName = 'certainty') then CertaintyElement := asEnum(SYSTEMS_TFhirReactionEventCertaintyEnum, CODES_TFhirReactionEventCertaintyEnum, new){4}
  else if (propName = 'manifestation') then replacePropertyValue('manifestation', ManifestationList, existing, new) {2}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'onset') then OnsetElement := asDateTime(new){5b}
  else if (propName = 'severity') then SeverityElement := asEnum(SYSTEMS_TFhirReactionEventSeverityEnum, CODES_TFhirReactionEventSeverityEnum, new){4}
  else if (propName = 'exposureRoute') then ExposureRouteElement := new as TFhirCodeableConcept{4}
  else if (propName = 'note') then NoteElement := new as TFhirAnnotation{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAllergyIntoleranceReaction.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'manifestation') then ManifestationList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAllergyIntoleranceReaction.fhirType : string;
begin
  result := 'reaction';
end;

function TFhirAllergyIntoleranceReaction.Link : TFhirAllergyIntoleranceReaction;
begin
  result := TFhirAllergyIntoleranceReaction(inherited Link);
end;

function TFhirAllergyIntoleranceReaction.Clone : TFhirAllergyIntoleranceReaction;
begin
  result := TFhirAllergyIntoleranceReaction(inherited Clone);
end;

function TFhirAllergyIntoleranceReaction.equals(other : TObject) : boolean;
var
  o : TFhirAllergyIntoleranceReaction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAllergyIntoleranceReaction)) then
    result := false
  else
  begin
    o := TFhirAllergyIntoleranceReaction(other);
    result := compareDeep(substanceElement, o.substanceElement, true) and compareDeep(certaintyElement, o.certaintyElement, true) and
      compareDeep(manifestationList, o.manifestationList, true) and compareDeep(descriptionElement, o.descriptionElement, true) and
      compareDeep(onsetElement, o.onsetElement, true) and compareDeep(severityElement, o.severityElement, true) and
      compareDeep(exposureRouteElement, o.exposureRouteElement, true) and compareDeep(noteElement, o.noteElement, true);
  end;
end;

function TFhirAllergyIntoleranceReaction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSubstance) and isEmptyProp(FCertainty) and isEmptyProp(FmanifestationList) and isEmptyProp(FDescription) and isEmptyProp(FOnset) and isEmptyProp(FSeverity) and isEmptyProp(FExposureRoute) and isEmptyProp(FNote);
end;

procedure TFhirAllergyIntoleranceReaction.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('substance');
  fields.add('certainty');
  fields.add('manifestation');
  fields.add('description');
  fields.add('onset');
  fields.add('severity');
  fields.add('exposureRoute');
  fields.add('note');
end;

{ TFhirAllergyIntoleranceReaction }

Procedure TFhirAllergyIntoleranceReaction.SetSubstance(value : TFhirCodeableConcept);
begin
  FSubstance.free;
  FSubstance := value;
end;

Procedure TFhirAllergyIntoleranceReaction.SetCertainty(value : TFhirEnum);
begin
  FCertainty.free;
  FCertainty := value;
end;

Function TFhirAllergyIntoleranceReaction.GetCertaintyST : TFhirReactionEventCertaintyEnum;
begin
  if FCertainty = nil then
    result := TFhirReactionEventCertaintyEnum(0)
  else
    result := TFhirReactionEventCertaintyEnum(StringArrayIndexOfSensitive(CODES_TFhirReactionEventCertaintyEnum, FCertainty.value));
end;

Procedure TFhirAllergyIntoleranceReaction.SetCertaintyST(value : TFhirReactionEventCertaintyEnum);
begin
  if ord(value) = 0 then
    CertaintyElement := nil
  else
    CertaintyElement := TFhirEnum.create(SYSTEMS_TFhirReactionEventCertaintyEnum[value], CODES_TFhirReactionEventCertaintyEnum[value]);
end;

Function TFhirAllergyIntoleranceReaction.GetManifestationList : TFhirCodeableConceptList;
begin
  if FManifestationList = nil then
    FManifestationList := TFhirCodeableConceptList.Create;
  result := FManifestationList;
end;

Function TFhirAllergyIntoleranceReaction.GetHasManifestationList : boolean;
begin
  result := (FManifestationList <> nil) and (FManifestationList.count > 0);
end;

Procedure TFhirAllergyIntoleranceReaction.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirAllergyIntoleranceReaction.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirAllergyIntoleranceReaction.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirAllergyIntoleranceReaction.SetOnset(value : TFhirDateTime);
begin
  FOnset.free;
  FOnset := value;
end;

Function TFhirAllergyIntoleranceReaction.GetOnsetST : TFslDateTime;
begin
  if FOnset = nil then
    result := TFslDateTime.makeNull
  else
    result := FOnset.value;
end;

Procedure TFhirAllergyIntoleranceReaction.SetOnsetST(value : TFslDateTime);
begin
  if FOnset = nil then
    FOnset := TFhirDateTime.create;
  FOnset.value := value
end;

Procedure TFhirAllergyIntoleranceReaction.SetSeverity(value : TFhirEnum);
begin
  FSeverity.free;
  FSeverity := value;
end;

Function TFhirAllergyIntoleranceReaction.GetSeverityST : TFhirReactionEventSeverityEnum;
begin
  if FSeverity = nil then
    result := TFhirReactionEventSeverityEnum(0)
  else
    result := TFhirReactionEventSeverityEnum(StringArrayIndexOfSensitive(CODES_TFhirReactionEventSeverityEnum, FSeverity.value));
end;

Procedure TFhirAllergyIntoleranceReaction.SetSeverityST(value : TFhirReactionEventSeverityEnum);
begin
  if ord(value) = 0 then
    SeverityElement := nil
  else
    SeverityElement := TFhirEnum.create(SYSTEMS_TFhirReactionEventSeverityEnum[value], CODES_TFhirReactionEventSeverityEnum[value]);
end;

Procedure TFhirAllergyIntoleranceReaction.SetExposureRoute(value : TFhirCodeableConcept);
begin
  FExposureRoute.free;
  FExposureRoute := value;
end;

Procedure TFhirAllergyIntoleranceReaction.SetNote(value : TFhirAnnotation);
begin
  FNote.free;
  FNote := value;
end;

function TFhirAllergyIntoleranceReaction.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSubstance.sizeInBytes);
  inc(result, FCertainty.sizeInBytes);
  inc(result, FmanifestationList.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FOnset.sizeInBytes);
  inc(result, FSeverity.sizeInBytes);
  inc(result, FExposureRoute.sizeInBytes);
  inc(result, FNote.sizeInBytes);
end;

{ TFhirAllergyIntoleranceReactionListEnumerator }

Constructor TFhirAllergyIntoleranceReactionListEnumerator.Create(list : TFhirAllergyIntoleranceReactionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAllergyIntoleranceReactionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAllergyIntoleranceReactionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAllergyIntoleranceReactionListEnumerator.GetCurrent : TFhirAllergyIntoleranceReaction;
begin
  Result := FList[FIndex];
end;

function TFhirAllergyIntoleranceReactionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAllergyIntoleranceReactionList }
procedure TFhirAllergyIntoleranceReactionList.AddItem(value: TFhirAllergyIntoleranceReaction);
begin
  assert(value.ClassName = 'TFhirAllergyIntoleranceReaction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAllergyIntoleranceReaction');
  add(value);
end;

function TFhirAllergyIntoleranceReactionList.Append: TFhirAllergyIntoleranceReaction;
begin
  result := TFhirAllergyIntoleranceReaction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAllergyIntoleranceReactionList.ClearItems;
begin
  Clear;
end;

function TFhirAllergyIntoleranceReactionList.GetEnumerator : TFhirAllergyIntoleranceReactionListEnumerator;
begin
  result := TFhirAllergyIntoleranceReactionListEnumerator.Create(self.link);
end;

function TFhirAllergyIntoleranceReactionList.Clone: TFhirAllergyIntoleranceReactionList;
begin
  result := TFhirAllergyIntoleranceReactionList(inherited Clone);
end;

function TFhirAllergyIntoleranceReactionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAllergyIntoleranceReactionList.GetItemN(index: Integer): TFhirAllergyIntoleranceReaction;
begin
  result := TFhirAllergyIntoleranceReaction(ObjectByIndex[index]);
end;

function TFhirAllergyIntoleranceReactionList.ItemClass: TFslObjectClass;
begin
  result := TFhirAllergyIntoleranceReaction;
end;
function TFhirAllergyIntoleranceReactionList.IndexOf(value: TFhirAllergyIntoleranceReaction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAllergyIntoleranceReactionList.Insert(index: Integer): TFhirAllergyIntoleranceReaction;
begin
  result := TFhirAllergyIntoleranceReaction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAllergyIntoleranceReactionList.InsertItem(index: Integer; value: TFhirAllergyIntoleranceReaction);
begin
  assert(value is TFhirAllergyIntoleranceReaction);
  Inherited Insert(index, value);
end;

function TFhirAllergyIntoleranceReactionList.Item(index: Integer): TFhirAllergyIntoleranceReaction;
begin
  result := TFhirAllergyIntoleranceReaction(ObjectByIndex[index]);
end;

function TFhirAllergyIntoleranceReactionList.Link: TFhirAllergyIntoleranceReactionList;
begin
  result := TFhirAllergyIntoleranceReactionList(inherited Link);
end;

procedure TFhirAllergyIntoleranceReactionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAllergyIntoleranceReactionList.SetItemByIndex(index: Integer; value: TFhirAllergyIntoleranceReaction);
begin
  assert(value is TFhirAllergyIntoleranceReaction);
  FhirAllergyIntoleranceReactions[index] := value;
end;

procedure TFhirAllergyIntoleranceReactionList.SetItemN(index: Integer; value: TFhirAllergyIntoleranceReaction);
begin
  assert(value is TFhirAllergyIntoleranceReaction);
  ObjectByIndex[index] := value;
end;

{ TFhirAllergyIntolerance }

constructor TFhirAllergyIntolerance.Create;
begin
  inherited;
end;

destructor TFhirAllergyIntolerance.Destroy;
begin
  FIdentifierList.Free;
  FOnset.free;
  FRecordedDate.free;
  FRecorder.free;
  FPatient.free;
  FReporter.free;
  FSubstance.free;
  FStatus.free;
  FCriticality.free;
  FType_.free;
  FCategory.free;
  FLastOccurence.free;
  FNote.free;
  FReactionList.Free;
  inherited;
end;

function TFhirAllergyIntolerance.GetResourceType : TFhirResourceType;
begin
  result := frtAllergyIntolerance;
end;

procedure TFhirAllergyIntolerance.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirAllergyIntolerance(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirAllergyIntolerance(oSource).FIdentifierList);
  end;
  onsetElement := TFhirAllergyIntolerance(oSource).onsetElement.Clone;
  recordedDateElement := TFhirAllergyIntolerance(oSource).recordedDateElement.Clone;
  recorder := TFhirAllergyIntolerance(oSource).recorder.Clone;
  patient := TFhirAllergyIntolerance(oSource).patient.Clone;
  reporter := TFhirAllergyIntolerance(oSource).reporter.Clone;
  substance := TFhirAllergyIntolerance(oSource).substance.Clone;
  FStatus := TFhirAllergyIntolerance(oSource).FStatus.Link;
  FCriticality := TFhirAllergyIntolerance(oSource).FCriticality.Link;
  FType_ := TFhirAllergyIntolerance(oSource).FType_.Link;
  FCategory := TFhirAllergyIntolerance(oSource).FCategory.Link;
  lastOccurenceElement := TFhirAllergyIntolerance(oSource).lastOccurenceElement.Clone;
  note := TFhirAllergyIntolerance(oSource).note.Clone;
  if (TFhirAllergyIntolerance(oSource).FReactionList = nil) then
  begin
    FReactionList.free;
    FReactionList := nil;
  end
  else
  begin
    if FReactionList = nil then
      FReactionList := TFhirAllergyIntoleranceReactionList.Create;
    FReactionList.Assign(TFhirAllergyIntolerance(oSource).FReactionList);
  end;
end;

procedure TFhirAllergyIntolerance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'onset') Then
     list.add(self.link, 'onset', FOnset.Link);
  if (child_name = 'recordedDate') Then
     list.add(self.link, 'recordedDate', FRecordedDate.Link);
  if (child_name = 'recorder') Then
     list.add(self.link, 'recorder', FRecorder.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'reporter') Then
     list.add(self.link, 'reporter', FReporter.Link);
  if (child_name = 'substance') Then
     list.add(self.link, 'substance', FSubstance.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'criticality') Then
     list.add(self.link, 'criticality', FCriticality.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'lastOccurence') Then
     list.add(self.link, 'lastOccurence', FLastOccurence.Link);
  if (child_name = 'note') Then
     list.add(self.link, 'note', FNote.Link);
  if (child_name = 'reaction') Then
    list.addAll(self, 'reaction', FReactionList);
end;

procedure TFhirAllergyIntolerance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'onset', 'dateTime', false, TFhirDateTime, FOnset.Link));{2}
  oList.add(TFHIRProperty.create(self, 'recordedDate', 'dateTime', false, TFhirDateTime, FRecordedDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'recorder', 'Reference(Practitioner|Patient)', false, TFhirReference{Resource}, FRecorder.Link));{2}
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reporter', 'Reference(Patient|RelatedPerson|Practitioner)', false, TFhirReference{Resource}, FReporter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'substance', 'CodeableConcept', false, TFhirCodeableConcept, FSubstance.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'criticality', 'code', false, TFHIREnum, FCriticality.Link));{1}
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'category', 'code', false, TFHIREnum, FCategory.Link));{1}
  oList.add(TFHIRProperty.create(self, 'lastOccurence', 'dateTime', false, TFhirDateTime, FLastOccurence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', false, TFhirAnnotation, FNote.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reaction', '', true, TFhirAllergyIntoleranceReaction, FReactionList.Link)){3};
end;

function TFhirAllergyIntolerance.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'onset') then
  begin
    OnsetElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'recordedDate') then
  begin
    RecordedDateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'recorder') then
  begin
    Recorder := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'reporter') then
  begin
    Reporter := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'substance') then
  begin
    Substance := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirAllergyIntoleranceStatusEnum, CODES_TFhirAllergyIntoleranceStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'criticality') then
  begin
    CriticalityElement := asEnum(SYSTEMS_TFhirAllergyIntoleranceCriticalityEnum, CODES_TFhirAllergyIntoleranceCriticalityEnum, propValue);
    result := propValue
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirAllergyIntoleranceTypeEnum, CODES_TFhirAllergyIntoleranceTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'category') then
  begin
    CategoryElement := asEnum(SYSTEMS_TFhirAllergyIntoleranceCategoryEnum, CODES_TFhirAllergyIntoleranceCategoryEnum, propValue);
    result := propValue
  end
  else if (propName = 'lastOccurence') then
  begin
    LastOccurenceElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    Note := propValue as TFhirAnnotation{4b};
    result := propValue;
  end
  else if (propName = 'reaction') then
  begin
    ReactionList.add(propValue as TFhirAllergyIntoleranceReaction){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirAllergyIntolerance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'reaction') then ReactionList.insertItem(index, propValue as TFhirAllergyIntoleranceReaction){2a}
  else inherited;
end;

function TFhirAllergyIntolerance.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'onset') then result := TFhirDateTime.create() {5b}
  else if (propName = 'recordedDate') then result := TFhirDateTime.create() {5b}
  else if (propName = 'recorder') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'reporter') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'substance') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'lastOccurence') then result := TFhirDateTime.create() {5b}
  else if (propName = 'note') then result := TFhirAnnotation.create(){4b}
  else if (propName = 'reaction') then result := ReactionList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAllergyIntolerance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'onset') then result := 'dateTime'
  else if (propName = 'recordedDate') then result := 'dateTime'
  else if (propName = 'recorder') then result := 'Reference'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'reporter') then result := 'Reference'
  else if (propName = 'substance') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'criticality') then result := 'code'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'category') then result := 'code'
  else if (propName = 'lastOccurence') then result := 'dateTime'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'reaction') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAllergyIntolerance.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'onset') then OnsetElement := nil
  else if (propName = 'recordedDate') then RecordedDateElement := nil
  else if (propName = 'recorder') then RecorderElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'reporter') then ReporterElement := nil
  else if (propName = 'substance') then SubstanceElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'criticality') then CriticalityElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'lastOccurence') then LastOccurenceElement := nil
  else if (propName = 'note') then NoteElement := nil
  else if (propName = 'reaction') then deletePropertyValue('reaction', ReactionList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAllergyIntolerance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'onset') then OnsetElement := asDateTime(new){5b}
  else if (propName = 'recordedDate') then RecordedDateElement := asDateTime(new){5b}
  else if (propName = 'recorder') then RecorderElement := new as TFhirReference{Resource}{4}
  else if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'reporter') then ReporterElement := new as TFhirReference{Resource}{4}
  else if (propName = 'substance') then SubstanceElement := new as TFhirCodeableConcept{4}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirAllergyIntoleranceStatusEnum, CODES_TFhirAllergyIntoleranceStatusEnum, new){4}
  else if (propName = 'criticality') then CriticalityElement := asEnum(SYSTEMS_TFhirAllergyIntoleranceCriticalityEnum, CODES_TFhirAllergyIntoleranceCriticalityEnum, new){4}
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirAllergyIntoleranceTypeEnum, CODES_TFhirAllergyIntoleranceTypeEnum, new){4}
  else if (propName = 'category') then CategoryElement := asEnum(SYSTEMS_TFhirAllergyIntoleranceCategoryEnum, CODES_TFhirAllergyIntoleranceCategoryEnum, new){4}
  else if (propName = 'lastOccurence') then LastOccurenceElement := asDateTime(new){5b}
  else if (propName = 'note') then NoteElement := new as TFhirAnnotation{4}
  else if (propName = 'reaction') then replacePropertyValue('reaction', ReactionList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAllergyIntolerance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'reaction') then ReactionList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAllergyIntolerance.fhirType : string;
begin
  result := 'AllergyIntolerance';
end;

function TFhirAllergyIntolerance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FOnset) and isEmptyProp(FRecordedDate) and isEmptyProp(FRecorder) and isEmptyProp(FPatient) and isEmptyProp(FReporter) and isEmptyProp(FSubstance) and isEmptyProp(FStatus) and isEmptyProp(FCriticality) and isEmptyProp(FType_) and isEmptyProp(FCategory) and isEmptyProp(FLastOccurence) and isEmptyProp(FNote) and isEmptyProp(FreactionList);
end;

function TFhirAllergyIntolerance.equals(other : TObject) : boolean;
var
  o : TFhirAllergyIntolerance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAllergyIntolerance)) then
    result := false
  else
  begin
    o := TFhirAllergyIntolerance(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(onsetElement, o.onsetElement, true) and
      compareDeep(recordedDateElement, o.recordedDateElement, true) and compareDeep(recorderElement, o.recorderElement, true) and
      compareDeep(patientElement, o.patientElement, true) and compareDeep(reporterElement, o.reporterElement, true) and
      compareDeep(substanceElement, o.substanceElement, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(criticalityElement, o.criticalityElement, true) and compareDeep(type_Element, o.type_Element, true) and
      compareDeep(categoryElement, o.categoryElement, true) and compareDeep(lastOccurenceElement, o.lastOccurenceElement, true) and
      compareDeep(noteElement, o.noteElement, true) and compareDeep(reactionList, o.reactionList, true);
  end;
end;

function TFhirAllergyIntolerance.Link : TFhirAllergyIntolerance;
begin
  result := TFhirAllergyIntolerance(inherited Link);
end;

function TFhirAllergyIntolerance.Clone : TFhirAllergyIntolerance;
begin
  result := TFhirAllergyIntolerance(inherited Clone);
end;

procedure TFhirAllergyIntolerance.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('onset');
  fields.add('recordedDate');
  fields.add('recorder');
  fields.add('patient');
  fields.add('reporter');
  fields.add('substance');
  fields.add('status');
  fields.add('criticality');
  fields.add('type');
  fields.add('category');
  fields.add('lastOccurence');
  fields.add('note');
  fields.add('reaction');
end;

{ TFhirAllergyIntolerance }

Function TFhirAllergyIntolerance.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirAllergyIntolerance.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirAllergyIntolerance.SetOnset(value : TFhirDateTime);
begin
  FOnset.free;
  FOnset := value;
end;

Function TFhirAllergyIntolerance.GetOnsetST : TFslDateTime;
begin
  if FOnset = nil then
    result := TFslDateTime.makeNull
  else
    result := FOnset.value;
end;

Procedure TFhirAllergyIntolerance.SetOnsetST(value : TFslDateTime);
begin
  if FOnset = nil then
    FOnset := TFhirDateTime.create;
  FOnset.value := value
end;

Procedure TFhirAllergyIntolerance.SetRecordedDate(value : TFhirDateTime);
begin
  FRecordedDate.free;
  FRecordedDate := value;
end;

Function TFhirAllergyIntolerance.GetRecordedDateST : TFslDateTime;
begin
  if FRecordedDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FRecordedDate.value;
end;

Procedure TFhirAllergyIntolerance.SetRecordedDateST(value : TFslDateTime);
begin
  if FRecordedDate = nil then
    FRecordedDate := TFhirDateTime.create;
  FRecordedDate.value := value
end;

Procedure TFhirAllergyIntolerance.SetRecorder(value : TFhirReference{Resource});
begin
  FRecorder.free;
  FRecorder := value;
end;

Procedure TFhirAllergyIntolerance.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Procedure TFhirAllergyIntolerance.SetReporter(value : TFhirReference{Resource});
begin
  FReporter.free;
  FReporter := value;
end;

Procedure TFhirAllergyIntolerance.SetSubstance(value : TFhirCodeableConcept);
begin
  FSubstance.free;
  FSubstance := value;
end;

Procedure TFhirAllergyIntolerance.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirAllergyIntolerance.GetStatusST : TFhirAllergyIntoleranceStatusEnum;
begin
  if FStatus = nil then
    result := TFhirAllergyIntoleranceStatusEnum(0)
  else
    result := TFhirAllergyIntoleranceStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirAllergyIntoleranceStatusEnum, FStatus.value));
end;

Procedure TFhirAllergyIntolerance.SetStatusST(value : TFhirAllergyIntoleranceStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirAllergyIntoleranceStatusEnum[value], CODES_TFhirAllergyIntoleranceStatusEnum[value]);
end;

Procedure TFhirAllergyIntolerance.SetCriticality(value : TFhirEnum);
begin
  FCriticality.free;
  FCriticality := value;
end;

Function TFhirAllergyIntolerance.GetCriticalityST : TFhirAllergyIntoleranceCriticalityEnum;
begin
  if FCriticality = nil then
    result := TFhirAllergyIntoleranceCriticalityEnum(0)
  else
    result := TFhirAllergyIntoleranceCriticalityEnum(StringArrayIndexOfSensitive(CODES_TFhirAllergyIntoleranceCriticalityEnum, FCriticality.value));
end;

Procedure TFhirAllergyIntolerance.SetCriticalityST(value : TFhirAllergyIntoleranceCriticalityEnum);
begin
  if ord(value) = 0 then
    CriticalityElement := nil
  else
    CriticalityElement := TFhirEnum.create(SYSTEMS_TFhirAllergyIntoleranceCriticalityEnum[value], CODES_TFhirAllergyIntoleranceCriticalityEnum[value]);
end;

Procedure TFhirAllergyIntolerance.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirAllergyIntolerance.GetType_ST : TFhirAllergyIntoleranceTypeEnum;
begin
  if FType_ = nil then
    result := TFhirAllergyIntoleranceTypeEnum(0)
  else
    result := TFhirAllergyIntoleranceTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirAllergyIntoleranceTypeEnum, FType_.value));
end;

Procedure TFhirAllergyIntolerance.SetType_ST(value : TFhirAllergyIntoleranceTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirAllergyIntoleranceTypeEnum[value], CODES_TFhirAllergyIntoleranceTypeEnum[value]);
end;

Procedure TFhirAllergyIntolerance.SetCategory(value : TFhirEnum);
begin
  FCategory.free;
  FCategory := value;
end;

Function TFhirAllergyIntolerance.GetCategoryST : TFhirAllergyIntoleranceCategoryEnum;
begin
  if FCategory = nil then
    result := TFhirAllergyIntoleranceCategoryEnum(0)
  else
    result := TFhirAllergyIntoleranceCategoryEnum(StringArrayIndexOfSensitive(CODES_TFhirAllergyIntoleranceCategoryEnum, FCategory.value));
end;

Procedure TFhirAllergyIntolerance.SetCategoryST(value : TFhirAllergyIntoleranceCategoryEnum);
begin
  if ord(value) = 0 then
    CategoryElement := nil
  else
    CategoryElement := TFhirEnum.create(SYSTEMS_TFhirAllergyIntoleranceCategoryEnum[value], CODES_TFhirAllergyIntoleranceCategoryEnum[value]);
end;

Procedure TFhirAllergyIntolerance.SetLastOccurence(value : TFhirDateTime);
begin
  FLastOccurence.free;
  FLastOccurence := value;
end;

Function TFhirAllergyIntolerance.GetLastOccurenceST : TFslDateTime;
begin
  if FLastOccurence = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastOccurence.value;
end;

Procedure TFhirAllergyIntolerance.SetLastOccurenceST(value : TFslDateTime);
begin
  if FLastOccurence = nil then
    FLastOccurence := TFhirDateTime.create;
  FLastOccurence.value := value
end;

Procedure TFhirAllergyIntolerance.SetNote(value : TFhirAnnotation);
begin
  FNote.free;
  FNote := value;
end;

Function TFhirAllergyIntolerance.GetReactionList : TFhirAllergyIntoleranceReactionList;
begin
  if FReactionList = nil then
    FReactionList := TFhirAllergyIntoleranceReactionList.Create;
  result := FReactionList;
end;

Function TFhirAllergyIntolerance.GetHasReactionList : boolean;
begin
  result := (FReactionList <> nil) and (FReactionList.count > 0);
end;

function TFhirAllergyIntolerance.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FOnset.sizeInBytes);
  inc(result, FRecordedDate.sizeInBytes);
  inc(result, FRecorder.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FReporter.sizeInBytes);
  inc(result, FSubstance.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FCriticality.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FLastOccurence.sizeInBytes);
  inc(result, FNote.sizeInBytes);
  inc(result, FreactionList.sizeInBytes);
end;

{ TFhirAllergyIntoleranceListEnumerator }

Constructor TFhirAllergyIntoleranceListEnumerator.Create(list : TFhirAllergyIntoleranceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAllergyIntoleranceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAllergyIntoleranceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAllergyIntoleranceListEnumerator.GetCurrent : TFhirAllergyIntolerance;
begin
  Result := FList[FIndex];
end;

function TFhirAllergyIntoleranceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAllergyIntoleranceList }
procedure TFhirAllergyIntoleranceList.AddItem(value: TFhirAllergyIntolerance);
begin
  assert(value.ClassName = 'TFhirAllergyIntolerance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAllergyIntolerance');
  add(value);
end;

function TFhirAllergyIntoleranceList.Append: TFhirAllergyIntolerance;
begin
  result := TFhirAllergyIntolerance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAllergyIntoleranceList.ClearItems;
begin
  Clear;
end;

function TFhirAllergyIntoleranceList.GetEnumerator : TFhirAllergyIntoleranceListEnumerator;
begin
  result := TFhirAllergyIntoleranceListEnumerator.Create(self.link);
end;

function TFhirAllergyIntoleranceList.Clone: TFhirAllergyIntoleranceList;
begin
  result := TFhirAllergyIntoleranceList(inherited Clone);
end;

function TFhirAllergyIntoleranceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAllergyIntoleranceList.GetItemN(index: Integer): TFhirAllergyIntolerance;
begin
  result := TFhirAllergyIntolerance(ObjectByIndex[index]);
end;

function TFhirAllergyIntoleranceList.ItemClass: TFslObjectClass;
begin
  result := TFhirAllergyIntolerance;
end;
function TFhirAllergyIntoleranceList.IndexOf(value: TFhirAllergyIntolerance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAllergyIntoleranceList.Insert(index: Integer): TFhirAllergyIntolerance;
begin
  result := TFhirAllergyIntolerance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAllergyIntoleranceList.InsertItem(index: Integer; value: TFhirAllergyIntolerance);
begin
  assert(value is TFhirAllergyIntolerance);
  Inherited Insert(index, value);
end;

function TFhirAllergyIntoleranceList.Item(index: Integer): TFhirAllergyIntolerance;
begin
  result := TFhirAllergyIntolerance(ObjectByIndex[index]);
end;

function TFhirAllergyIntoleranceList.Link: TFhirAllergyIntoleranceList;
begin
  result := TFhirAllergyIntoleranceList(inherited Link);
end;

procedure TFhirAllergyIntoleranceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAllergyIntoleranceList.SetItemByIndex(index: Integer; value: TFhirAllergyIntolerance);
begin
  assert(value is TFhirAllergyIntolerance);
  FhirAllergyIntolerances[index] := value;
end;

procedure TFhirAllergyIntoleranceList.SetItemN(index: Integer; value: TFhirAllergyIntolerance);
begin
  assert(value is TFhirAllergyIntolerance);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ALLERGYINTOLERANCE}

{$IFDEF FHIR_APPOINTMENT}

{ TFhirAppointmentParticipant }

constructor TFhirAppointmentParticipant.Create;
begin
  inherited;
end;

destructor TFhirAppointmentParticipant.Destroy;
begin
  FType_List.Free;
  FActor.free;
  FRequired.free;
  FStatus.free;
  inherited;
end;

procedure TFhirAppointmentParticipant.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirAppointmentParticipant(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirAppointmentParticipant(oSource).FType_List);
  end;
  actor := TFhirAppointmentParticipant(oSource).actor.Clone;
  FRequired := TFhirAppointmentParticipant(oSource).FRequired.Link;
  FStatus := TFhirAppointmentParticipant(oSource).FStatus.Link;
end;

procedure TFhirAppointmentParticipant.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'actor') Then
     list.add(self.link, 'actor', FActor.Link);
  if (child_name = 'required') Then
     list.add(self.link, 'required', FRequired.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
end;

procedure TFhirAppointmentParticipant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'actor', 'Reference(Patient|Practitioner|RelatedPerson|Device|HealthcareService|Location)', false, TFhirReference{Resource}, FActor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'required', 'code', false, TFHIREnum, FRequired.Link));{1}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
end;

function TFhirAppointmentParticipant.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    Actor := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'required') then
  begin
    RequiredElement := asEnum(SYSTEMS_TFhirParticipantrequiredEnum, CODES_TFhirParticipantrequiredEnum, propValue);
    result := propValue
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirParticipationstatusEnum, CODES_TFhirParticipationstatusEnum, propValue);
    result := propValue
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAppointmentParticipant.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirAppointmentParticipant.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := Type_List.new(){2}
  else if (propName = 'actor') then result := TFhirReference{Resource}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAppointmentParticipant.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'actor') then result := 'Reference'
  else if (propName = 'required') then result := 'code'
  else if (propName = 'status') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAppointmentParticipant.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then deletePropertyValue('type', Type_List, value) {2}
  else if (propName = 'actor') then ActorElement := nil
  else if (propName = 'required') then RequiredElement := nil
  else if (propName = 'status') then StatusElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAppointmentParticipant.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new) {2}
  else if (propName = 'actor') then ActorElement := new as TFhirReference{Resource}{4}
  else if (propName = 'required') then RequiredElement := asEnum(SYSTEMS_TFhirParticipantrequiredEnum, CODES_TFhirParticipantrequiredEnum, new){4}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirParticipationstatusEnum, CODES_TFhirParticipationstatusEnum, new){4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAppointmentParticipant.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'type') then Type_List.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAppointmentParticipant.fhirType : string;
begin
  result := 'participant';
end;

function TFhirAppointmentParticipant.Link : TFhirAppointmentParticipant;
begin
  result := TFhirAppointmentParticipant(inherited Link);
end;

function TFhirAppointmentParticipant.Clone : TFhirAppointmentParticipant;
begin
  result := TFhirAppointmentParticipant(inherited Clone);
end;

function TFhirAppointmentParticipant.equals(other : TObject) : boolean;
var
  o : TFhirAppointmentParticipant;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAppointmentParticipant)) then
    result := false
  else
  begin
    o := TFhirAppointmentParticipant(other);
    result := compareDeep(type_List, o.type_List, true) and compareDeep(actorElement, o.actorElement, true) and
      compareDeep(requiredElement, o.requiredElement, true) and compareDeep(statusElement, o.statusElement, true);
  end;
end;

function TFhirAppointmentParticipant.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(Ftype_List) and isEmptyProp(FActor) and isEmptyProp(FRequired) and isEmptyProp(FStatus);
end;

procedure TFhirAppointmentParticipant.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('actor');
  fields.add('required');
  fields.add('status');
end;

{ TFhirAppointmentParticipant }

Function TFhirAppointmentParticipant.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

Function TFhirAppointmentParticipant.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

Procedure TFhirAppointmentParticipant.SetActor(value : TFhirReference{Resource});
begin
  FActor.free;
  FActor := value;
end;

Procedure TFhirAppointmentParticipant.SetRequired(value : TFhirEnum);
begin
  FRequired.free;
  FRequired := value;
end;

Function TFhirAppointmentParticipant.GetRequiredST : TFhirParticipantrequiredEnum;
begin
  if FRequired = nil then
    result := TFhirParticipantrequiredEnum(0)
  else
    result := TFhirParticipantrequiredEnum(StringArrayIndexOfSensitive(CODES_TFhirParticipantrequiredEnum, FRequired.value));
end;

Procedure TFhirAppointmentParticipant.SetRequiredST(value : TFhirParticipantrequiredEnum);
begin
  if ord(value) = 0 then
    RequiredElement := nil
  else
    RequiredElement := TFhirEnum.create(SYSTEMS_TFhirParticipantrequiredEnum[value], CODES_TFhirParticipantrequiredEnum[value]);
end;

Procedure TFhirAppointmentParticipant.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirAppointmentParticipant.GetStatusST : TFhirParticipationstatusEnum;
begin
  if FStatus = nil then
    result := TFhirParticipationstatusEnum(0)
  else
    result := TFhirParticipationstatusEnum(StringArrayIndexOfSensitive(CODES_TFhirParticipationstatusEnum, FStatus.value));
end;

Procedure TFhirAppointmentParticipant.SetStatusST(value : TFhirParticipationstatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirParticipationstatusEnum[value], CODES_TFhirParticipationstatusEnum[value]);
end;

function TFhirAppointmentParticipant.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, Ftype_List.sizeInBytes);
  inc(result, FActor.sizeInBytes);
  inc(result, FRequired.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
end;

{ TFhirAppointmentParticipantListEnumerator }

Constructor TFhirAppointmentParticipantListEnumerator.Create(list : TFhirAppointmentParticipantList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAppointmentParticipantListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAppointmentParticipantListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAppointmentParticipantListEnumerator.GetCurrent : TFhirAppointmentParticipant;
begin
  Result := FList[FIndex];
end;

function TFhirAppointmentParticipantListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAppointmentParticipantList }
procedure TFhirAppointmentParticipantList.AddItem(value: TFhirAppointmentParticipant);
begin
  assert(value.ClassName = 'TFhirAppointmentParticipant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAppointmentParticipant');
  add(value);
end;

function TFhirAppointmentParticipantList.Append: TFhirAppointmentParticipant;
begin
  result := TFhirAppointmentParticipant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAppointmentParticipantList.ClearItems;
begin
  Clear;
end;

function TFhirAppointmentParticipantList.GetEnumerator : TFhirAppointmentParticipantListEnumerator;
begin
  result := TFhirAppointmentParticipantListEnumerator.Create(self.link);
end;

function TFhirAppointmentParticipantList.Clone: TFhirAppointmentParticipantList;
begin
  result := TFhirAppointmentParticipantList(inherited Clone);
end;

function TFhirAppointmentParticipantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAppointmentParticipantList.GetItemN(index: Integer): TFhirAppointmentParticipant;
begin
  result := TFhirAppointmentParticipant(ObjectByIndex[index]);
end;

function TFhirAppointmentParticipantList.ItemClass: TFslObjectClass;
begin
  result := TFhirAppointmentParticipant;
end;
function TFhirAppointmentParticipantList.IndexOf(value: TFhirAppointmentParticipant): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAppointmentParticipantList.Insert(index: Integer): TFhirAppointmentParticipant;
begin
  result := TFhirAppointmentParticipant.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAppointmentParticipantList.InsertItem(index: Integer; value: TFhirAppointmentParticipant);
begin
  assert(value is TFhirAppointmentParticipant);
  Inherited Insert(index, value);
end;

function TFhirAppointmentParticipantList.Item(index: Integer): TFhirAppointmentParticipant;
begin
  result := TFhirAppointmentParticipant(ObjectByIndex[index]);
end;

function TFhirAppointmentParticipantList.Link: TFhirAppointmentParticipantList;
begin
  result := TFhirAppointmentParticipantList(inherited Link);
end;

procedure TFhirAppointmentParticipantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAppointmentParticipantList.SetItemByIndex(index: Integer; value: TFhirAppointmentParticipant);
begin
  assert(value is TFhirAppointmentParticipant);
  FhirAppointmentParticipants[index] := value;
end;

procedure TFhirAppointmentParticipantList.SetItemN(index: Integer; value: TFhirAppointmentParticipant);
begin
  assert(value is TFhirAppointmentParticipant);
  ObjectByIndex[index] := value;
end;

{ TFhirAppointment }

constructor TFhirAppointment.Create;
begin
  inherited;
end;

destructor TFhirAppointment.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FType_.free;
  FReason.free;
  FPriority.free;
  FDescription.free;
  FStart.free;
  FEnd_.free;
  FMinutesDuration.free;
  FSlotList.Free;
  FComment.free;
  FParticipantList.Free;
  inherited;
end;

function TFhirAppointment.GetResourceType : TFhirResourceType;
begin
  result := frtAppointment;
end;

procedure TFhirAppointment.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirAppointment(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirAppointment(oSource).FIdentifierList);
  end;
  FStatus := TFhirAppointment(oSource).FStatus.Link;
  type_ := TFhirAppointment(oSource).type_.Clone;
  reason := TFhirAppointment(oSource).reason.Clone;
  priorityElement := TFhirAppointment(oSource).priorityElement.Clone;
  descriptionElement := TFhirAppointment(oSource).descriptionElement.Clone;
  startElement := TFhirAppointment(oSource).startElement.Clone;
  end_Element := TFhirAppointment(oSource).end_Element.Clone;
  minutesDurationElement := TFhirAppointment(oSource).minutesDurationElement.Clone;
  if (TFhirAppointment(oSource).FSlotList = nil) then
  begin
    FSlotList.free;
    FSlotList := nil;
  end
  else
  begin
    if FSlotList = nil then
      FSlotList := TFhirReferenceList{TFhirSlot}.Create;
    FSlotList.Assign(TFhirAppointment(oSource).FSlotList);
  end;
  commentElement := TFhirAppointment(oSource).commentElement.Clone;
  if (TFhirAppointment(oSource).FParticipantList = nil) then
  begin
    FParticipantList.free;
    FParticipantList := nil;
  end
  else
  begin
    if FParticipantList = nil then
      FParticipantList := TFhirAppointmentParticipantList.Create;
    FParticipantList.Assign(TFhirAppointment(oSource).FParticipantList);
  end;
end;

procedure TFhirAppointment.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'reason') Then
     list.add(self.link, 'reason', FReason.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'start') Then
     list.add(self.link, 'start', FStart.Link);
  if (child_name = 'end') Then
     list.add(self.link, 'end', FEnd_.Link);
  if (child_name = 'minutesDuration') Then
     list.add(self.link, 'minutesDuration', FMinutesDuration.Link);
  if (child_name = 'slot') Then
    list.addAll(self, 'slot', FSlotList);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
  if (child_name = 'participant') Then
    list.addAll(self, 'participant', FParticipantList);
end;

procedure TFhirAppointment.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', false, TFhirCodeableConcept, FReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'priority', 'unsignedInt', false, TFhirUnsignedInt, FPriority.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'start', 'instant', false, TFhirInstant, FStart.Link));{2}
  oList.add(TFHIRProperty.create(self, 'end', 'instant', false, TFhirInstant, FEnd_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'minutesDuration', 'positiveInt', false, TFhirPositiveInt, FMinutesDuration.Link));{2}
  oList.add(TFHIRProperty.create(self, 'slot', 'Reference(Slot)', true, TFhirReference{TFhirSlot}, FSlotList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'comment', 'string', false, TFhirString, FComment.Link));{2}
  oList.add(TFHIRProperty.create(self, 'participant', '', true, TFhirAppointmentParticipant, FParticipantList.Link)){3};
end;

function TFhirAppointment.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirAppointmentstatusEnum, CODES_TFhirAppointmentstatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    Reason := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asUnsignedInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'start') then
  begin
    StartElement := asInstant(propValue){5a};
    result := propValue;
  end
  else if (propName = 'end') then
  begin
    End_Element := asInstant(propValue){5a};
    result := propValue;
  end
  else if (propName = 'minutesDuration') then
  begin
    MinutesDurationElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'slot') then
  begin
    SlotList.add(propValue as TFhirReference{TFhirSlot}){2a};
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'participant') then
  begin
    ParticipantList.add(propValue as TFhirAppointmentParticipant){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirAppointment.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'slot') then SlotList.insertItem(index, propValue as TFhirReference{TFhirSlot}){2a}
  else if (propName = 'participant') then ParticipantList.insertItem(index, propValue as TFhirAppointmentParticipant){2a}
  else inherited;
end;

function TFhirAppointment.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'reason') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'priority') then result := TFhirUnsignedInt.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'start') then result := TFhirInstant.create() {5b}
  else if (propName = 'end') then result := TFhirInstant.create() {5b}
  else if (propName = 'minutesDuration') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'slot') then result := SlotList.new(){2}
  else if (propName = 'comment') then result := TFhirString.create() {5b}
  else if (propName = 'participant') then result := ParticipantList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAppointment.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else if (propName = 'priority') then result := 'unsignedInt'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'start') then result := 'instant'
  else if (propName = 'end') then result := 'instant'
  else if (propName = 'minutesDuration') then result := 'positiveInt'
  else if (propName = 'slot') then result := 'Reference'
  else if (propName = 'comment') then result := 'string'
  else if (propName = 'participant') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAppointment.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'reason') then ReasonElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'start') then StartElement := nil
  else if (propName = 'end') then End_Element := nil
  else if (propName = 'minutesDuration') then MinutesDurationElement := nil
  else if (propName = 'slot') then deletePropertyValue('slot', SlotList, value) {2}
  else if (propName = 'comment') then CommentElement := nil
  else if (propName = 'participant') then deletePropertyValue('participant', ParticipantList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAppointment.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirAppointmentstatusEnum, CODES_TFhirAppointmentstatusEnum, new){4}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'reason') then ReasonElement := new as TFhirCodeableConcept{4}
  else if (propName = 'priority') then PriorityElement := asUnsignedInt(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'start') then StartElement := asInstant(new){5b}
  else if (propName = 'end') then End_Element := asInstant(new){5b}
  else if (propName = 'minutesDuration') then MinutesDurationElement := asPositiveInt(new){5b}
  else if (propName = 'slot') then replacePropertyValue('slot', SlotList, existing, new) {2}
  else if (propName = 'comment') then CommentElement := asString(new){5b}
  else if (propName = 'participant') then replacePropertyValue('participant', ParticipantList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAppointment.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'slot') then SlotList.move(source, destination){2a}
  else if (propName = 'participant') then ParticipantList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAppointment.fhirType : string;
begin
  result := 'Appointment';
end;

function TFhirAppointment.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FType_) and isEmptyProp(FReason) and isEmptyProp(FPriority) and isEmptyProp(FDescription) and isEmptyProp(FStart) and isEmptyProp(FEnd_) and isEmptyProp(FMinutesDuration) and isEmptyProp(FslotList) and isEmptyProp(FComment) and isEmptyProp(FparticipantList);
end;

function TFhirAppointment.equals(other : TObject) : boolean;
var
  o : TFhirAppointment;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAppointment)) then
    result := false
  else
  begin
    o := TFhirAppointment(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(type_Element, o.type_Element, true) and compareDeep(reasonElement, o.reasonElement, true) and
      compareDeep(priorityElement, o.priorityElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and
      compareDeep(startElement, o.startElement, true) and compareDeep(end_Element, o.end_Element, true) and
      compareDeep(minutesDurationElement, o.minutesDurationElement, true) and compareDeep(slotList, o.slotList, true) and
      compareDeep(commentElement, o.commentElement, true) and compareDeep(participantList, o.participantList, true);
  end;
end;

function TFhirAppointment.Link : TFhirAppointment;
begin
  result := TFhirAppointment(inherited Link);
end;

function TFhirAppointment.Clone : TFhirAppointment;
begin
  result := TFhirAppointment(inherited Clone);
end;

procedure TFhirAppointment.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('type');
  fields.add('reason');
  fields.add('priority');
  fields.add('description');
  fields.add('start');
  fields.add('end');
  fields.add('minutesDuration');
  fields.add('slot');
  fields.add('comment');
  fields.add('participant');
end;

{ TFhirAppointment }

Function TFhirAppointment.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirAppointment.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirAppointment.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirAppointment.GetStatusST : TFhirAppointmentstatusEnum;
begin
  if FStatus = nil then
    result := TFhirAppointmentstatusEnum(0)
  else
    result := TFhirAppointmentstatusEnum(StringArrayIndexOfSensitive(CODES_TFhirAppointmentstatusEnum, FStatus.value));
end;

Procedure TFhirAppointment.SetStatusST(value : TFhirAppointmentstatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirAppointmentstatusEnum[value], CODES_TFhirAppointmentstatusEnum[value]);
end;

Procedure TFhirAppointment.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirAppointment.SetReason(value : TFhirCodeableConcept);
begin
  FReason.free;
  FReason := value;
end;

Procedure TFhirAppointment.SetPriority(value : TFhirUnsignedInt);
begin
  FPriority.free;
  FPriority := value;
end;

Function TFhirAppointment.GetPriorityST : String;
begin
  if FPriority = nil then
    result := ''
  else
    result := FPriority.value;
end;

Procedure TFhirAppointment.SetPriorityST(value : String);
begin
  if value <> '' then
  begin
    if FPriority = nil then
      FPriority := TFhirUnsignedInt.create;
    FPriority.value := value
  end
  else if FPriority <> nil then
    FPriority.value := '';
end;

Procedure TFhirAppointment.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirAppointment.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirAppointment.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirAppointment.SetStart(value : TFhirInstant);
begin
  FStart.free;
  FStart := value;
end;

Function TFhirAppointment.GetStartST : TFslDateTime;
begin
  if FStart = nil then
    result := TFslDateTime.makeNull
  else
    result := FStart.value;
end;

Procedure TFhirAppointment.SetStartST(value : TFslDateTime);
begin
  if FStart = nil then
    FStart := TFhirInstant.create;
  FStart.value := value
end;

Procedure TFhirAppointment.SetEnd_(value : TFhirInstant);
begin
  FEnd_.free;
  FEnd_ := value;
end;

Function TFhirAppointment.GetEnd_ST : TFslDateTime;
begin
  if FEnd_ = nil then
    result := TFslDateTime.makeNull
  else
    result := FEnd_.value;
end;

Procedure TFhirAppointment.SetEnd_ST(value : TFslDateTime);
begin
  if FEnd_ = nil then
    FEnd_ := TFhirInstant.create;
  FEnd_.value := value
end;

Procedure TFhirAppointment.SetMinutesDuration(value : TFhirPositiveInt);
begin
  FMinutesDuration.free;
  FMinutesDuration := value;
end;

Function TFhirAppointment.GetMinutesDurationST : String;
begin
  if FMinutesDuration = nil then
    result := ''
  else
    result := FMinutesDuration.value;
end;

Procedure TFhirAppointment.SetMinutesDurationST(value : String);
begin
  if value <> '' then
  begin
    if FMinutesDuration = nil then
      FMinutesDuration := TFhirPositiveInt.create;
    FMinutesDuration.value := value
  end
  else if FMinutesDuration <> nil then
    FMinutesDuration.value := '';
end;

Function TFhirAppointment.GetSlotList : TFhirReferenceList{TFhirSlot};
begin
  if FSlotList = nil then
    FSlotList := TFhirReferenceList{TFhirSlot}.Create;
  result := FSlotList;
end;

Function TFhirAppointment.GetHasSlotList : boolean;
begin
  result := (FSlotList <> nil) and (FSlotList.count > 0);
end;

Procedure TFhirAppointment.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value;
end;

Function TFhirAppointment.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

Procedure TFhirAppointment.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

Function TFhirAppointment.GetParticipantList : TFhirAppointmentParticipantList;
begin
  if FParticipantList = nil then
    FParticipantList := TFhirAppointmentParticipantList.Create;
  result := FParticipantList;
end;

Function TFhirAppointment.GetHasParticipantList : boolean;
begin
  result := (FParticipantList <> nil) and (FParticipantList.count > 0);
end;

function TFhirAppointment.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FReason.sizeInBytes);
  inc(result, FPriority.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FStart.sizeInBytes);
  inc(result, FEnd_.sizeInBytes);
  inc(result, FMinutesDuration.sizeInBytes);
  inc(result, FslotList.sizeInBytes);
  inc(result, FComment.sizeInBytes);
  inc(result, FparticipantList.sizeInBytes);
end;

{ TFhirAppointmentListEnumerator }

Constructor TFhirAppointmentListEnumerator.Create(list : TFhirAppointmentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAppointmentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAppointmentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAppointmentListEnumerator.GetCurrent : TFhirAppointment;
begin
  Result := FList[FIndex];
end;

function TFhirAppointmentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAppointmentList }
procedure TFhirAppointmentList.AddItem(value: TFhirAppointment);
begin
  assert(value.ClassName = 'TFhirAppointment', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAppointment');
  add(value);
end;

function TFhirAppointmentList.Append: TFhirAppointment;
begin
  result := TFhirAppointment.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAppointmentList.ClearItems;
begin
  Clear;
end;

function TFhirAppointmentList.GetEnumerator : TFhirAppointmentListEnumerator;
begin
  result := TFhirAppointmentListEnumerator.Create(self.link);
end;

function TFhirAppointmentList.Clone: TFhirAppointmentList;
begin
  result := TFhirAppointmentList(inherited Clone);
end;

function TFhirAppointmentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAppointmentList.GetItemN(index: Integer): TFhirAppointment;
begin
  result := TFhirAppointment(ObjectByIndex[index]);
end;

function TFhirAppointmentList.ItemClass: TFslObjectClass;
begin
  result := TFhirAppointment;
end;
function TFhirAppointmentList.IndexOf(value: TFhirAppointment): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAppointmentList.Insert(index: Integer): TFhirAppointment;
begin
  result := TFhirAppointment.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAppointmentList.InsertItem(index: Integer; value: TFhirAppointment);
begin
  assert(value is TFhirAppointment);
  Inherited Insert(index, value);
end;

function TFhirAppointmentList.Item(index: Integer): TFhirAppointment;
begin
  result := TFhirAppointment(ObjectByIndex[index]);
end;

function TFhirAppointmentList.Link: TFhirAppointmentList;
begin
  result := TFhirAppointmentList(inherited Link);
end;

procedure TFhirAppointmentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAppointmentList.SetItemByIndex(index: Integer; value: TFhirAppointment);
begin
  assert(value is TFhirAppointment);
  FhirAppointments[index] := value;
end;

procedure TFhirAppointmentList.SetItemN(index: Integer; value: TFhirAppointment);
begin
  assert(value is TFhirAppointment);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_APPOINTMENT}

{$IFDEF FHIR_APPOINTMENTRESPONSE}

{ TFhirAppointmentResponse }

constructor TFhirAppointmentResponse.Create;
begin
  inherited;
end;

destructor TFhirAppointmentResponse.Destroy;
begin
  FIdentifierList.Free;
  FAppointment.free;
  FStart.free;
  FEnd_.free;
  FParticipantTypeList.Free;
  FActor.free;
  FParticipantStatus.free;
  FComment.free;
  inherited;
end;

function TFhirAppointmentResponse.GetResourceType : TFhirResourceType;
begin
  result := frtAppointmentResponse;
end;

procedure TFhirAppointmentResponse.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirAppointmentResponse(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirAppointmentResponse(oSource).FIdentifierList);
  end;
  appointment := TFhirAppointmentResponse(oSource).appointment.Clone;
  startElement := TFhirAppointmentResponse(oSource).startElement.Clone;
  end_Element := TFhirAppointmentResponse(oSource).end_Element.Clone;
  if (TFhirAppointmentResponse(oSource).FParticipantTypeList = nil) then
  begin
    FParticipantTypeList.free;
    FParticipantTypeList := nil;
  end
  else
  begin
    if FParticipantTypeList = nil then
      FParticipantTypeList := TFhirCodeableConceptList.Create;
    FParticipantTypeList.Assign(TFhirAppointmentResponse(oSource).FParticipantTypeList);
  end;
  actor := TFhirAppointmentResponse(oSource).actor.Clone;
  FParticipantStatus := TFhirAppointmentResponse(oSource).FParticipantStatus.Link;
  commentElement := TFhirAppointmentResponse(oSource).commentElement.Clone;
end;

procedure TFhirAppointmentResponse.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'appointment') Then
     list.add(self.link, 'appointment', FAppointment.Link);
  if (child_name = 'start') Then
     list.add(self.link, 'start', FStart.Link);
  if (child_name = 'end') Then
     list.add(self.link, 'end', FEnd_.Link);
  if (child_name = 'participantType') Then
    list.addAll(self, 'participantType', FParticipantTypeList);
  if (child_name = 'actor') Then
     list.add(self.link, 'actor', FActor.Link);
  if (child_name = 'participantStatus') Then
     list.add(self.link, 'participantStatus', FParticipantStatus.Link);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
end;

procedure TFhirAppointmentResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'appointment', 'Reference(Appointment)', false, TFhirReference{TFhirAppointment}, FAppointment.Link));{2}
  oList.add(TFHIRProperty.create(self, 'start', 'instant', false, TFhirInstant, FStart.Link));{2}
  oList.add(TFHIRProperty.create(self, 'end', 'instant', false, TFhirInstant, FEnd_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'participantType', 'CodeableConcept', true, TFhirCodeableConcept, FParticipantTypeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'actor', 'Reference(Patient|Practitioner|RelatedPerson|Device|HealthcareService|Location)', false, TFhirReference{Resource}, FActor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'participantStatus', 'code', false, TFHIREnum, FParticipantStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'comment', 'string', false, TFhirString, FComment.Link));{2}
end;

function TFhirAppointmentResponse.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'appointment') then
  begin
    Appointment := propValue as TFhirReference{TFhirAppointment}{4b};
    result := propValue;
  end
  else if (propName = 'start') then
  begin
    StartElement := asInstant(propValue){5a};
    result := propValue;
  end
  else if (propName = 'end') then
  begin
    End_Element := asInstant(propValue){5a};
    result := propValue;
  end
  else if (propName = 'participantType') then
  begin
    ParticipantTypeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    Actor := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'participantStatus') then
  begin
    ParticipantStatusElement := asEnum(SYSTEMS_TFhirParticipantstatusEnum, CODES_TFhirParticipantstatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'comment') then
  begin
    CommentElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirAppointmentResponse.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'participantType') then ParticipantTypeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirAppointmentResponse.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'appointment') then result := TFhirReference{TFhirAppointment}.create(){4b}
  else if (propName = 'start') then result := TFhirInstant.create() {5b}
  else if (propName = 'end') then result := TFhirInstant.create() {5b}
  else if (propName = 'participantType') then result := ParticipantTypeList.new(){2}
  else if (propName = 'actor') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'comment') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAppointmentResponse.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'appointment') then result := 'Reference'
  else if (propName = 'start') then result := 'instant'
  else if (propName = 'end') then result := 'instant'
  else if (propName = 'participantType') then result := 'CodeableConcept'
  else if (propName = 'actor') then result := 'Reference'
  else if (propName = 'participantStatus') then result := 'code'
  else if (propName = 'comment') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAppointmentResponse.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'appointment') then AppointmentElement := nil
  else if (propName = 'start') then StartElement := nil
  else if (propName = 'end') then End_Element := nil
  else if (propName = 'participantType') then deletePropertyValue('participantType', ParticipantTypeList, value) {2}
  else if (propName = 'actor') then ActorElement := nil
  else if (propName = 'participantStatus') then ParticipantStatusElement := nil
  else if (propName = 'comment') then CommentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAppointmentResponse.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'appointment') then AppointmentElement := new as TFhirReference{TFhirAppointment}{4}
  else if (propName = 'start') then StartElement := asInstant(new){5b}
  else if (propName = 'end') then End_Element := asInstant(new){5b}
  else if (propName = 'participantType') then replacePropertyValue('participantType', ParticipantTypeList, existing, new) {2}
  else if (propName = 'actor') then ActorElement := new as TFhirReference{Resource}{4}
  else if (propName = 'participantStatus') then ParticipantStatusElement := asEnum(SYSTEMS_TFhirParticipantstatusEnum, CODES_TFhirParticipantstatusEnum, new){4}
  else if (propName = 'comment') then CommentElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAppointmentResponse.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'participantType') then ParticipantTypeList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAppointmentResponse.fhirType : string;
begin
  result := 'AppointmentResponse';
end;

function TFhirAppointmentResponse.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FAppointment) and isEmptyProp(FStart) and isEmptyProp(FEnd_) and isEmptyProp(FparticipantTypeList) and isEmptyProp(FActor) and isEmptyProp(FParticipantStatus) and isEmptyProp(FComment);
end;

function TFhirAppointmentResponse.equals(other : TObject) : boolean;
var
  o : TFhirAppointmentResponse;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAppointmentResponse)) then
    result := false
  else
  begin
    o := TFhirAppointmentResponse(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(appointmentElement, o.appointmentElement, true) and
      compareDeep(startElement, o.startElement, true) and compareDeep(end_Element, o.end_Element, true) and
      compareDeep(participantTypeList, o.participantTypeList, true) and compareDeep(actorElement, o.actorElement, true) and
      compareDeep(participantStatusElement, o.participantStatusElement, true) and compareDeep(commentElement, o.commentElement, true);
  end;
end;

function TFhirAppointmentResponse.Link : TFhirAppointmentResponse;
begin
  result := TFhirAppointmentResponse(inherited Link);
end;

function TFhirAppointmentResponse.Clone : TFhirAppointmentResponse;
begin
  result := TFhirAppointmentResponse(inherited Clone);
end;

procedure TFhirAppointmentResponse.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('appointment');
  fields.add('start');
  fields.add('end');
  fields.add('participantType');
  fields.add('actor');
  fields.add('participantStatus');
  fields.add('comment');
end;

{ TFhirAppointmentResponse }

Function TFhirAppointmentResponse.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirAppointmentResponse.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirAppointmentResponse.SetAppointment(value : TFhirReference{TFhirAppointment});
begin
  FAppointment.free;
  FAppointment := value;
end;

Procedure TFhirAppointmentResponse.SetStart(value : TFhirInstant);
begin
  FStart.free;
  FStart := value;
end;

Function TFhirAppointmentResponse.GetStartST : TFslDateTime;
begin
  if FStart = nil then
    result := TFslDateTime.makeNull
  else
    result := FStart.value;
end;

Procedure TFhirAppointmentResponse.SetStartST(value : TFslDateTime);
begin
  if FStart = nil then
    FStart := TFhirInstant.create;
  FStart.value := value
end;

Procedure TFhirAppointmentResponse.SetEnd_(value : TFhirInstant);
begin
  FEnd_.free;
  FEnd_ := value;
end;

Function TFhirAppointmentResponse.GetEnd_ST : TFslDateTime;
begin
  if FEnd_ = nil then
    result := TFslDateTime.makeNull
  else
    result := FEnd_.value;
end;

Procedure TFhirAppointmentResponse.SetEnd_ST(value : TFslDateTime);
begin
  if FEnd_ = nil then
    FEnd_ := TFhirInstant.create;
  FEnd_.value := value
end;

Function TFhirAppointmentResponse.GetParticipantTypeList : TFhirCodeableConceptList;
begin
  if FParticipantTypeList = nil then
    FParticipantTypeList := TFhirCodeableConceptList.Create;
  result := FParticipantTypeList;
end;

Function TFhirAppointmentResponse.GetHasParticipantTypeList : boolean;
begin
  result := (FParticipantTypeList <> nil) and (FParticipantTypeList.count > 0);
end;

Procedure TFhirAppointmentResponse.SetActor(value : TFhirReference{Resource});
begin
  FActor.free;
  FActor := value;
end;

Procedure TFhirAppointmentResponse.SetParticipantStatus(value : TFhirEnum);
begin
  FParticipantStatus.free;
  FParticipantStatus := value;
end;

Function TFhirAppointmentResponse.GetParticipantStatusST : TFhirParticipantstatusEnum;
begin
  if FParticipantStatus = nil then
    result := TFhirParticipantstatusEnum(0)
  else
    result := TFhirParticipantstatusEnum(StringArrayIndexOfSensitive(CODES_TFhirParticipantstatusEnum, FParticipantStatus.value));
end;

Procedure TFhirAppointmentResponse.SetParticipantStatusST(value : TFhirParticipantstatusEnum);
begin
  if ord(value) = 0 then
    ParticipantStatusElement := nil
  else
    ParticipantStatusElement := TFhirEnum.create(SYSTEMS_TFhirParticipantstatusEnum[value], CODES_TFhirParticipantstatusEnum[value]);
end;

Procedure TFhirAppointmentResponse.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value;
end;

Function TFhirAppointmentResponse.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

Procedure TFhirAppointmentResponse.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

function TFhirAppointmentResponse.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FAppointment.sizeInBytes);
  inc(result, FStart.sizeInBytes);
  inc(result, FEnd_.sizeInBytes);
  inc(result, FparticipantTypeList.sizeInBytes);
  inc(result, FActor.sizeInBytes);
  inc(result, FParticipantStatus.sizeInBytes);
  inc(result, FComment.sizeInBytes);
end;

{ TFhirAppointmentResponseListEnumerator }

Constructor TFhirAppointmentResponseListEnumerator.Create(list : TFhirAppointmentResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAppointmentResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAppointmentResponseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAppointmentResponseListEnumerator.GetCurrent : TFhirAppointmentResponse;
begin
  Result := FList[FIndex];
end;

function TFhirAppointmentResponseListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAppointmentResponseList }
procedure TFhirAppointmentResponseList.AddItem(value: TFhirAppointmentResponse);
begin
  assert(value.ClassName = 'TFhirAppointmentResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAppointmentResponse');
  add(value);
end;

function TFhirAppointmentResponseList.Append: TFhirAppointmentResponse;
begin
  result := TFhirAppointmentResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAppointmentResponseList.ClearItems;
begin
  Clear;
end;

function TFhirAppointmentResponseList.GetEnumerator : TFhirAppointmentResponseListEnumerator;
begin
  result := TFhirAppointmentResponseListEnumerator.Create(self.link);
end;

function TFhirAppointmentResponseList.Clone: TFhirAppointmentResponseList;
begin
  result := TFhirAppointmentResponseList(inherited Clone);
end;

function TFhirAppointmentResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAppointmentResponseList.GetItemN(index: Integer): TFhirAppointmentResponse;
begin
  result := TFhirAppointmentResponse(ObjectByIndex[index]);
end;

function TFhirAppointmentResponseList.ItemClass: TFslObjectClass;
begin
  result := TFhirAppointmentResponse;
end;
function TFhirAppointmentResponseList.IndexOf(value: TFhirAppointmentResponse): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAppointmentResponseList.Insert(index: Integer): TFhirAppointmentResponse;
begin
  result := TFhirAppointmentResponse.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAppointmentResponseList.InsertItem(index: Integer; value: TFhirAppointmentResponse);
begin
  assert(value is TFhirAppointmentResponse);
  Inherited Insert(index, value);
end;

function TFhirAppointmentResponseList.Item(index: Integer): TFhirAppointmentResponse;
begin
  result := TFhirAppointmentResponse(ObjectByIndex[index]);
end;

function TFhirAppointmentResponseList.Link: TFhirAppointmentResponseList;
begin
  result := TFhirAppointmentResponseList(inherited Link);
end;

procedure TFhirAppointmentResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAppointmentResponseList.SetItemByIndex(index: Integer; value: TFhirAppointmentResponse);
begin
  assert(value is TFhirAppointmentResponse);
  FhirAppointmentResponses[index] := value;
end;

procedure TFhirAppointmentResponseList.SetItemN(index: Integer; value: TFhirAppointmentResponse);
begin
  assert(value is TFhirAppointmentResponse);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_APPOINTMENTRESPONSE}

{$IFDEF FHIR_BASIC}

{ TFhirBasic }

constructor TFhirBasic.Create;
begin
  inherited;
end;

destructor TFhirBasic.Destroy;
begin
  FIdentifierList.Free;
  FCode.free;
  FSubject.free;
  FAuthor.free;
  FCreated.free;
  inherited;
end;

function TFhirBasic.GetResourceType : TFhirResourceType;
begin
  result := frtBasic;
end;

procedure TFhirBasic.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirBasic(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirBasic(oSource).FIdentifierList);
  end;
  code := TFhirBasic(oSource).code.Clone;
  subject := TFhirBasic(oSource).subject.Clone;
  author := TFhirBasic(oSource).author.Clone;
  createdElement := TFhirBasic(oSource).createdElement.Clone;
end;

procedure TFhirBasic.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
end;

procedure TFhirBasic.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Any)', false, TFhirReference{TFhirReference}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'author', 'Reference(Practitioner|Patient|RelatedPerson)', false, TFhirReference{Resource}, FAuthor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'created', 'date', false, TFhirDate, FCreated.Link));{2}
end;

function TFhirBasic.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDate(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirBasic.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else inherited;
end;

function TFhirBasic.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subject') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'author') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'created') then result := TFhirDate.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirBasic.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'created') then result := 'date'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBasic.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'author') then AuthorElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBasic.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'author') then AuthorElement := new as TFhirReference{Resource}{4}
  else if (propName = 'created') then CreatedElement := asDate(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBasic.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirBasic.fhirType : string;
begin
  result := 'Basic';
end;

function TFhirBasic.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FCode) and isEmptyProp(FSubject) and isEmptyProp(FAuthor) and isEmptyProp(FCreated);
end;

function TFhirBasic.equals(other : TObject) : boolean;
var
  o : TFhirBasic;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBasic)) then
    result := false
  else
  begin
    o := TFhirBasic(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(codeElement, o.codeElement, true) and
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(authorElement, o.authorElement, true) and
      compareDeep(createdElement, o.createdElement, true);
  end;
end;

function TFhirBasic.Link : TFhirBasic;
begin
  result := TFhirBasic(inherited Link);
end;

function TFhirBasic.Clone : TFhirBasic;
begin
  result := TFhirBasic(inherited Clone);
end;

procedure TFhirBasic.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('code');
  fields.add('subject');
  fields.add('author');
  fields.add('created');
end;

{ TFhirBasic }

Function TFhirBasic.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirBasic.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirBasic.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirBasic.SetSubject(value : TFhirReference{TFhirReference});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirBasic.SetAuthor(value : TFhirReference{Resource});
begin
  FAuthor.free;
  FAuthor := value;
end;

Procedure TFhirBasic.SetCreated(value : TFhirDate);
begin
  FCreated.free;
  FCreated := value;
end;

Function TFhirBasic.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

Procedure TFhirBasic.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDate.create;
  FCreated.value := value
end;

function TFhirBasic.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FAuthor.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
end;

{ TFhirBasicListEnumerator }

Constructor TFhirBasicListEnumerator.Create(list : TFhirBasicList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBasicListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBasicListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBasicListEnumerator.GetCurrent : TFhirBasic;
begin
  Result := FList[FIndex];
end;

function TFhirBasicListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirBasicList }
procedure TFhirBasicList.AddItem(value: TFhirBasic);
begin
  assert(value.ClassName = 'TFhirBasic', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBasic');
  add(value);
end;

function TFhirBasicList.Append: TFhirBasic;
begin
  result := TFhirBasic.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBasicList.ClearItems;
begin
  Clear;
end;

function TFhirBasicList.GetEnumerator : TFhirBasicListEnumerator;
begin
  result := TFhirBasicListEnumerator.Create(self.link);
end;

function TFhirBasicList.Clone: TFhirBasicList;
begin
  result := TFhirBasicList(inherited Clone);
end;

function TFhirBasicList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBasicList.GetItemN(index: Integer): TFhirBasic;
begin
  result := TFhirBasic(ObjectByIndex[index]);
end;

function TFhirBasicList.ItemClass: TFslObjectClass;
begin
  result := TFhirBasic;
end;
function TFhirBasicList.IndexOf(value: TFhirBasic): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBasicList.Insert(index: Integer): TFhirBasic;
begin
  result := TFhirBasic.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBasicList.InsertItem(index: Integer; value: TFhirBasic);
begin
  assert(value is TFhirBasic);
  Inherited Insert(index, value);
end;

function TFhirBasicList.Item(index: Integer): TFhirBasic;
begin
  result := TFhirBasic(ObjectByIndex[index]);
end;

function TFhirBasicList.Link: TFhirBasicList;
begin
  result := TFhirBasicList(inherited Link);
end;

procedure TFhirBasicList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBasicList.SetItemByIndex(index: Integer; value: TFhirBasic);
begin
  assert(value is TFhirBasic);
  FhirBasics[index] := value;
end;

procedure TFhirBasicList.SetItemN(index: Integer; value: TFhirBasic);
begin
  assert(value is TFhirBasic);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_BASIC}

{$IFDEF FHIR_BODYSITE}

{ TFhirBodySite }

constructor TFhirBodySite.Create;
begin
  inherited;
end;

destructor TFhirBodySite.Destroy;
begin
  FPatient.free;
  FIdentifierList.Free;
  FCode.free;
  FModifierList.Free;
  FDescription.free;
  FImageList.Free;
  inherited;
end;

function TFhirBodySite.GetResourceType : TFhirResourceType;
begin
  result := frtBodySite;
end;

procedure TFhirBodySite.Assign(oSource : TFslObject);
begin
  inherited;
  patient := TFhirBodySite(oSource).patient.Clone;
  if (TFhirBodySite(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirBodySite(oSource).FIdentifierList);
  end;
  code := TFhirBodySite(oSource).code.Clone;
  if (TFhirBodySite(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirBodySite(oSource).FModifierList);
  end;
  descriptionElement := TFhirBodySite(oSource).descriptionElement.Clone;
  if (TFhirBodySite(oSource).FImageList = nil) then
  begin
    FImageList.free;
    FImageList := nil;
  end
  else
  begin
    if FImageList = nil then
      FImageList := TFhirAttachmentList.Create;
    FImageList.Assign(TFhirBodySite(oSource).FImageList);
  end;
end;

procedure TFhirBodySite.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'image') Then
    list.addAll(self, 'image', FImageList);
end;

procedure TFhirBodySite.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'image', 'Attachment', true, TFhirAttachment, FImageList.Link)){3};
end;

function TFhirBodySite.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'image') then
  begin
    ImageList.add(propValue as TFhirAttachment){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirBodySite.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'image') then ImageList.insertItem(index, propValue as TFhirAttachment){2a}
  else inherited;
end;

function TFhirBodySite.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'modifier') then result := ModifierList.new(){2}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'image') then result := ImageList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirBodySite.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'patient') then result := 'Reference'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'image') then result := 'Attachment'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBodySite.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'patient') then PatientElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value) {2}
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'image') then deletePropertyValue('image', ImageList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBodySite.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new) {2}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'image') then replacePropertyValue('image', ImageList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBodySite.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'modifier') then ModifierList.move(source, destination){2a}
  else if (propName = 'image') then ImageList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirBodySite.fhirType : string;
begin
  result := 'BodySite';
end;

function TFhirBodySite.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPatient) and isEmptyProp(FidentifierList) and isEmptyProp(FCode) and isEmptyProp(FmodifierList) and isEmptyProp(FDescription) and isEmptyProp(FimageList);
end;

function TFhirBodySite.equals(other : TObject) : boolean;
var
  o : TFhirBodySite;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBodySite)) then
    result := false
  else
  begin
    o := TFhirBodySite(other);
    result := compareDeep(patientElement, o.patientElement, true) and compareDeep(identifierList, o.identifierList, true) and
      compareDeep(codeElement, o.codeElement, true) and compareDeep(modifierList, o.modifierList, true) and
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(imageList, o.imageList, true);
  end;
end;

function TFhirBodySite.Link : TFhirBodySite;
begin
  result := TFhirBodySite(inherited Link);
end;

function TFhirBodySite.Clone : TFhirBodySite;
begin
  result := TFhirBodySite(inherited Clone);
end;

procedure TFhirBodySite.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('patient');
  fields.add('identifier');
  fields.add('code');
  fields.add('modifier');
  fields.add('description');
  fields.add('image');
end;

{ TFhirBodySite }

Procedure TFhirBodySite.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Function TFhirBodySite.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirBodySite.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirBodySite.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirBodySite.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

Function TFhirBodySite.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

Procedure TFhirBodySite.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirBodySite.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirBodySite.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Function TFhirBodySite.GetImageList : TFhirAttachmentList;
begin
  if FImageList = nil then
    FImageList := TFhirAttachmentList.Create;
  result := FImageList;
end;

Function TFhirBodySite.GetHasImageList : boolean;
begin
  result := (FImageList <> nil) and (FImageList.count > 0);
end;

function TFhirBodySite.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FPatient.sizeInBytes);
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FmodifierList.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FimageList.sizeInBytes);
end;

{ TFhirBodySiteListEnumerator }

Constructor TFhirBodySiteListEnumerator.Create(list : TFhirBodySiteList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBodySiteListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBodySiteListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBodySiteListEnumerator.GetCurrent : TFhirBodySite;
begin
  Result := FList[FIndex];
end;

function TFhirBodySiteListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirBodySiteList }
procedure TFhirBodySiteList.AddItem(value: TFhirBodySite);
begin
  assert(value.ClassName = 'TFhirBodySite', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBodySite');
  add(value);
end;

function TFhirBodySiteList.Append: TFhirBodySite;
begin
  result := TFhirBodySite.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBodySiteList.ClearItems;
begin
  Clear;
end;

function TFhirBodySiteList.GetEnumerator : TFhirBodySiteListEnumerator;
begin
  result := TFhirBodySiteListEnumerator.Create(self.link);
end;

function TFhirBodySiteList.Clone: TFhirBodySiteList;
begin
  result := TFhirBodySiteList(inherited Clone);
end;

function TFhirBodySiteList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBodySiteList.GetItemN(index: Integer): TFhirBodySite;
begin
  result := TFhirBodySite(ObjectByIndex[index]);
end;

function TFhirBodySiteList.ItemClass: TFslObjectClass;
begin
  result := TFhirBodySite;
end;
function TFhirBodySiteList.IndexOf(value: TFhirBodySite): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBodySiteList.Insert(index: Integer): TFhirBodySite;
begin
  result := TFhirBodySite.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBodySiteList.InsertItem(index: Integer; value: TFhirBodySite);
begin
  assert(value is TFhirBodySite);
  Inherited Insert(index, value);
end;

function TFhirBodySiteList.Item(index: Integer): TFhirBodySite;
begin
  result := TFhirBodySite(ObjectByIndex[index]);
end;

function TFhirBodySiteList.Link: TFhirBodySiteList;
begin
  result := TFhirBodySiteList(inherited Link);
end;

procedure TFhirBodySiteList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBodySiteList.SetItemByIndex(index: Integer; value: TFhirBodySite);
begin
  assert(value is TFhirBodySite);
  FhirBodySites[index] := value;
end;

procedure TFhirBodySiteList.SetItemN(index: Integer; value: TFhirBodySite);
begin
  assert(value is TFhirBodySite);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_BODYSITE}

{$IFDEF FHIR_CAREPLAN}

{ TFhirCarePlanRelatedPlan }

constructor TFhirCarePlanRelatedPlan.Create;
begin
  inherited;
end;

destructor TFhirCarePlanRelatedPlan.Destroy;
begin
  FCode.free;
  FPlan.free;
  inherited;
end;

procedure TFhirCarePlanRelatedPlan.Assign(oSource : TFslObject);
begin
  inherited;
  FCode := TFhirCarePlanRelatedPlan(oSource).FCode.Link;
  plan := TFhirCarePlanRelatedPlan(oSource).plan.Clone;
end;

procedure TFhirCarePlanRelatedPlan.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'plan') Then
     list.add(self.link, 'plan', FPlan.Link);
end;

procedure TFhirCarePlanRelatedPlan.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFHIREnum, FCode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'plan', 'Reference(CarePlan)', false, TFhirReference{TFhirCarePlan}, FPlan.Link));{2}
end;

function TFhirCarePlanRelatedPlan.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeElement := asEnum(SYSTEMS_TFhirCarePlanRelationshipEnum, CODES_TFhirCarePlanRelationshipEnum, propValue);
    result := propValue
  end
  else if (propName = 'plan') then
  begin
    Plan := propValue as TFhirReference{TFhirCarePlan}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCarePlanRelatedPlan.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCarePlanRelatedPlan.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'plan') then result := TFhirReference{TFhirCarePlan}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCarePlanRelatedPlan.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'code'
  else if (propName = 'plan') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCarePlanRelatedPlan.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'plan') then PlanElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCarePlanRelatedPlan.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := asEnum(SYSTEMS_TFhirCarePlanRelationshipEnum, CODES_TFhirCarePlanRelationshipEnum, new){4}
  else if (propName = 'plan') then PlanElement := new as TFhirReference{TFhirCarePlan}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCarePlanRelatedPlan.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCarePlanRelatedPlan.fhirType : string;
begin
  result := 'relatedPlan';
end;

function TFhirCarePlanRelatedPlan.Link : TFhirCarePlanRelatedPlan;
begin
  result := TFhirCarePlanRelatedPlan(inherited Link);
end;

function TFhirCarePlanRelatedPlan.Clone : TFhirCarePlanRelatedPlan;
begin
  result := TFhirCarePlanRelatedPlan(inherited Clone);
end;

function TFhirCarePlanRelatedPlan.equals(other : TObject) : boolean;
var
  o : TFhirCarePlanRelatedPlan;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCarePlanRelatedPlan)) then
    result := false
  else
  begin
    o := TFhirCarePlanRelatedPlan(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(planElement, o.planElement, true);
  end;
end;

function TFhirCarePlanRelatedPlan.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FPlan);
end;

procedure TFhirCarePlanRelatedPlan.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('plan');
end;

{ TFhirCarePlanRelatedPlan }

Procedure TFhirCarePlanRelatedPlan.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirCarePlanRelatedPlan.GetCodeST : TFhirCarePlanRelationshipEnum;
begin
  if FCode = nil then
    result := TFhirCarePlanRelationshipEnum(0)
  else
    result := TFhirCarePlanRelationshipEnum(StringArrayIndexOfSensitive(CODES_TFhirCarePlanRelationshipEnum, FCode.value));
end;

Procedure TFhirCarePlanRelatedPlan.SetCodeST(value : TFhirCarePlanRelationshipEnum);
begin
  if ord(value) = 0 then
    CodeElement := nil
  else
    CodeElement := TFhirEnum.create(SYSTEMS_TFhirCarePlanRelationshipEnum[value], CODES_TFhirCarePlanRelationshipEnum[value]);
end;

Procedure TFhirCarePlanRelatedPlan.SetPlan(value : TFhirReference{TFhirCarePlan});
begin
  FPlan.free;
  FPlan := value;
end;

function TFhirCarePlanRelatedPlan.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FPlan.sizeInBytes);
end;

{ TFhirCarePlanRelatedPlanListEnumerator }

Constructor TFhirCarePlanRelatedPlanListEnumerator.Create(list : TFhirCarePlanRelatedPlanList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCarePlanRelatedPlanListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCarePlanRelatedPlanListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCarePlanRelatedPlanListEnumerator.GetCurrent : TFhirCarePlanRelatedPlan;
begin
  Result := FList[FIndex];
end;

function TFhirCarePlanRelatedPlanListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCarePlanRelatedPlanList }
procedure TFhirCarePlanRelatedPlanList.AddItem(value: TFhirCarePlanRelatedPlan);
begin
  assert(value.ClassName = 'TFhirCarePlanRelatedPlan', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCarePlanRelatedPlan');
  add(value);
end;

function TFhirCarePlanRelatedPlanList.Append: TFhirCarePlanRelatedPlan;
begin
  result := TFhirCarePlanRelatedPlan.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCarePlanRelatedPlanList.ClearItems;
begin
  Clear;
end;

function TFhirCarePlanRelatedPlanList.GetEnumerator : TFhirCarePlanRelatedPlanListEnumerator;
begin
  result := TFhirCarePlanRelatedPlanListEnumerator.Create(self.link);
end;

function TFhirCarePlanRelatedPlanList.Clone: TFhirCarePlanRelatedPlanList;
begin
  result := TFhirCarePlanRelatedPlanList(inherited Clone);
end;

function TFhirCarePlanRelatedPlanList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCarePlanRelatedPlanList.GetItemN(index: Integer): TFhirCarePlanRelatedPlan;
begin
  result := TFhirCarePlanRelatedPlan(ObjectByIndex[index]);
end;

function TFhirCarePlanRelatedPlanList.ItemClass: TFslObjectClass;
begin
  result := TFhirCarePlanRelatedPlan;
end;
function TFhirCarePlanRelatedPlanList.IndexOf(value: TFhirCarePlanRelatedPlan): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCarePlanRelatedPlanList.Insert(index: Integer): TFhirCarePlanRelatedPlan;
begin
  result := TFhirCarePlanRelatedPlan.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCarePlanRelatedPlanList.InsertItem(index: Integer; value: TFhirCarePlanRelatedPlan);
begin
  assert(value is TFhirCarePlanRelatedPlan);
  Inherited Insert(index, value);
end;

function TFhirCarePlanRelatedPlanList.Item(index: Integer): TFhirCarePlanRelatedPlan;
begin
  result := TFhirCarePlanRelatedPlan(ObjectByIndex[index]);
end;

function TFhirCarePlanRelatedPlanList.Link: TFhirCarePlanRelatedPlanList;
begin
  result := TFhirCarePlanRelatedPlanList(inherited Link);
end;

procedure TFhirCarePlanRelatedPlanList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCarePlanRelatedPlanList.SetItemByIndex(index: Integer; value: TFhirCarePlanRelatedPlan);
begin
  assert(value is TFhirCarePlanRelatedPlan);
  FhirCarePlanRelatedPlans[index] := value;
end;

procedure TFhirCarePlanRelatedPlanList.SetItemN(index: Integer; value: TFhirCarePlanRelatedPlan);
begin
  assert(value is TFhirCarePlanRelatedPlan);
  ObjectByIndex[index] := value;
end;

{ TFhirCarePlanParticipant }

constructor TFhirCarePlanParticipant.Create;
begin
  inherited;
end;

destructor TFhirCarePlanParticipant.Destroy;
begin
  FRole.free;
  FMember.free;
  inherited;
end;

procedure TFhirCarePlanParticipant.Assign(oSource : TFslObject);
begin
  inherited;
  role := TFhirCarePlanParticipant(oSource).role.Clone;
  member := TFhirCarePlanParticipant(oSource).member.Clone;
end;

procedure TFhirCarePlanParticipant.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'member') Then
     list.add(self.link, 'member', FMember.Link);
end;

procedure TFhirCarePlanParticipant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));{2}
  oList.add(TFHIRProperty.create(self, 'member', 'Reference(Practitioner|RelatedPerson|Patient|Organization)', false, TFhirReference{Resource}, FMember.Link));{2}
end;

function TFhirCarePlanParticipant.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'member') then
  begin
    Member := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCarePlanParticipant.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCarePlanParticipant.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'role') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'member') then result := TFhirReference{Resource}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCarePlanParticipant.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'member') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCarePlanParticipant.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := nil
  else if (propName = 'member') then MemberElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCarePlanParticipant.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := new as TFhirCodeableConcept{4}
  else if (propName = 'member') then MemberElement := new as TFhirReference{Resource}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCarePlanParticipant.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCarePlanParticipant.fhirType : string;
begin
  result := 'participant';
end;

function TFhirCarePlanParticipant.Link : TFhirCarePlanParticipant;
begin
  result := TFhirCarePlanParticipant(inherited Link);
end;

function TFhirCarePlanParticipant.Clone : TFhirCarePlanParticipant;
begin
  result := TFhirCarePlanParticipant(inherited Clone);
end;

function TFhirCarePlanParticipant.equals(other : TObject) : boolean;
var
  o : TFhirCarePlanParticipant;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCarePlanParticipant)) then
    result := false
  else
  begin
    o := TFhirCarePlanParticipant(other);
    result := compareDeep(roleElement, o.roleElement, true) and compareDeep(memberElement, o.memberElement, true);
  end;
end;

function TFhirCarePlanParticipant.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRole) and isEmptyProp(FMember);
end;

procedure TFhirCarePlanParticipant.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('role');
  fields.add('member');
end;

{ TFhirCarePlanParticipant }

Procedure TFhirCarePlanParticipant.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

Procedure TFhirCarePlanParticipant.SetMember(value : TFhirReference{Resource});
begin
  FMember.free;
  FMember := value;
end;

function TFhirCarePlanParticipant.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FRole.sizeInBytes);
  inc(result, FMember.sizeInBytes);
end;

{ TFhirCarePlanParticipantListEnumerator }

Constructor TFhirCarePlanParticipantListEnumerator.Create(list : TFhirCarePlanParticipantList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCarePlanParticipantListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCarePlanParticipantListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCarePlanParticipantListEnumerator.GetCurrent : TFhirCarePlanParticipant;
begin
  Result := FList[FIndex];
end;

function TFhirCarePlanParticipantListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCarePlanParticipantList }
procedure TFhirCarePlanParticipantList.AddItem(value: TFhirCarePlanParticipant);
begin
  assert(value.ClassName = 'TFhirCarePlanParticipant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCarePlanParticipant');
  add(value);
end;

function TFhirCarePlanParticipantList.Append: TFhirCarePlanParticipant;
begin
  result := TFhirCarePlanParticipant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCarePlanParticipantList.ClearItems;
begin
  Clear;
end;

function TFhirCarePlanParticipantList.GetEnumerator : TFhirCarePlanParticipantListEnumerator;
begin
  result := TFhirCarePlanParticipantListEnumerator.Create(self.link);
end;

function TFhirCarePlanParticipantList.Clone: TFhirCarePlanParticipantList;
begin
  result := TFhirCarePlanParticipantList(inherited Clone);
end;

function TFhirCarePlanParticipantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCarePlanParticipantList.GetItemN(index: Integer): TFhirCarePlanParticipant;
begin
  result := TFhirCarePlanParticipant(ObjectByIndex[index]);
end;

function TFhirCarePlanParticipantList.ItemClass: TFslObjectClass;
begin
  result := TFhirCarePlanParticipant;
end;
function TFhirCarePlanParticipantList.IndexOf(value: TFhirCarePlanParticipant): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCarePlanParticipantList.Insert(index: Integer): TFhirCarePlanParticipant;
begin
  result := TFhirCarePlanParticipant.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCarePlanParticipantList.InsertItem(index: Integer; value: TFhirCarePlanParticipant);
begin
  assert(value is TFhirCarePlanParticipant);
  Inherited Insert(index, value);
end;

function TFhirCarePlanParticipantList.Item(index: Integer): TFhirCarePlanParticipant;
begin
  result := TFhirCarePlanParticipant(ObjectByIndex[index]);
end;

function TFhirCarePlanParticipantList.Link: TFhirCarePlanParticipantList;
begin
  result := TFhirCarePlanParticipantList(inherited Link);
end;

procedure TFhirCarePlanParticipantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCarePlanParticipantList.SetItemByIndex(index: Integer; value: TFhirCarePlanParticipant);
begin
  assert(value is TFhirCarePlanParticipant);
  FhirCarePlanParticipants[index] := value;
end;

procedure TFhirCarePlanParticipantList.SetItemN(index: Integer; value: TFhirCarePlanParticipant);
begin
  assert(value is TFhirCarePlanParticipant);
  ObjectByIndex[index] := value;
end;

{ TFhirCarePlanActivity }

constructor TFhirCarePlanActivity.Create;
begin
  inherited;
end;

destructor TFhirCarePlanActivity.Destroy;
begin
  FActionResultingList.Free;
  FProgressList.Free;
  FReference.free;
  FDetail.free;
  inherited;
end;

procedure TFhirCarePlanActivity.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCarePlanActivity(oSource).FActionResultingList = nil) then
  begin
    FActionResultingList.free;
    FActionResultingList := nil;
  end
  else
  begin
    if FActionResultingList = nil then
      FActionResultingList := TFhirReferenceList{TFhirReference}.Create;
    FActionResultingList.Assign(TFhirCarePlanActivity(oSource).FActionResultingList);
  end;
  if (TFhirCarePlanActivity(oSource).FProgressList = nil) then
  begin
    FProgressList.free;
    FProgressList := nil;
  end
  else
  begin
    if FProgressList = nil then
      FProgressList := TFhirAnnotationList.Create;
    FProgressList.Assign(TFhirCarePlanActivity(oSource).FProgressList);
  end;
  reference := TFhirCarePlanActivity(oSource).reference.Clone;
  detail := TFhirCarePlanActivity(oSource).detail.Clone;
end;

procedure TFhirCarePlanActivity.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'actionResulting') Then
    list.addAll(self, 'actionResulting', FActionResultingList);
  if (child_name = 'progress') Then
    list.addAll(self, 'progress', FProgressList);
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
  if (child_name = 'detail') Then
     list.add(self.link, 'detail', FDetail.Link);
end;

procedure TFhirCarePlanActivity.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'actionResulting', 'Reference(Any)', true, TFhirReference{TFhirReference}, FActionResultingList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'progress', 'Annotation', true, TFhirAnnotation, FProgressList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reference', 'Reference(Appointment|CommunicationRequest|DeviceUseRequest|DiagnosticOrder|MedicationOrder|NutritionOrder|Order|ProcedureRequest|ProcessRequest|ReferralRequest|SupplyRequest|VisionPrescription)', false, TFhirReference{Resource}, FReference.Link));{2}
  oList.add(TFHIRProperty.create(self, 'detail', '', false, TFhirCarePlanActivityDetail, FDetail.Link));{2}
end;

function TFhirCarePlanActivity.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'actionResulting') then
  begin
    ActionResultingList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'progress') then
  begin
    ProgressList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else if (propName = 'reference') then
  begin
    Reference := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    Detail := propValue as TFhirCarePlanActivityDetail{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCarePlanActivity.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'actionResulting') then ActionResultingList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'progress') then ProgressList.insertItem(index, propValue as TFhirAnnotation){2a}
  else inherited;
end;

function TFhirCarePlanActivity.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'actionResulting') then result := ActionResultingList.new(){2}
  else if (propName = 'progress') then result := ProgressList.new(){2}
  else if (propName = 'reference') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'detail') then result := TFhirCarePlanActivityDetail.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCarePlanActivity.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'actionResulting') then result := 'Reference'
  else if (propName = 'progress') then result := 'Annotation'
  else if (propName = 'reference') then result := 'Reference'
  else if (propName = 'detail') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCarePlanActivity.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'actionResulting') then deletePropertyValue('actionResulting', ActionResultingList, value) {2}
  else if (propName = 'progress') then deletePropertyValue('progress', ProgressList, value) {2}
  else if (propName = 'reference') then ReferenceElement := nil
  else if (propName = 'detail') then DetailElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCarePlanActivity.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'actionResulting') then replacePropertyValue('actionResulting', ActionResultingList, existing, new) {2}
  else if (propName = 'progress') then replacePropertyValue('progress', ProgressList, existing, new) {2}
  else if (propName = 'reference') then ReferenceElement := new as TFhirReference{Resource}{4}
  else if (propName = 'detail') then DetailElement := new as TFhirCarePlanActivityDetail{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCarePlanActivity.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'actionResulting') then ActionResultingList.move(source, destination){2a}
  else if (propName = 'progress') then ProgressList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCarePlanActivity.fhirType : string;
begin
  result := 'activity';
end;

function TFhirCarePlanActivity.Link : TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity(inherited Link);
end;

function TFhirCarePlanActivity.Clone : TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity(inherited Clone);
end;

function TFhirCarePlanActivity.equals(other : TObject) : boolean;
var
  o : TFhirCarePlanActivity;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCarePlanActivity)) then
    result := false
  else
  begin
    o := TFhirCarePlanActivity(other);
    result := compareDeep(actionResultingList, o.actionResultingList, true) and
      compareDeep(progressList, o.progressList, true) and compareDeep(referenceElement, o.referenceElement, true) and
      compareDeep(detailElement, o.detailElement, true);
  end;
end;

function TFhirCarePlanActivity.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FactionResultingList) and isEmptyProp(FprogressList) and isEmptyProp(FReference) and isEmptyProp(FDetail);
end;

procedure TFhirCarePlanActivity.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('actionResulting');
  fields.add('progress');
  fields.add('reference');
  fields.add('detail');
end;

{ TFhirCarePlanActivity }

Function TFhirCarePlanActivity.GetActionResultingList : TFhirReferenceList{TFhirReference};
begin
  if FActionResultingList = nil then
    FActionResultingList := TFhirReferenceList{TFhirReference}.Create;
  result := FActionResultingList;
end;

Function TFhirCarePlanActivity.GetHasActionResultingList : boolean;
begin
  result := (FActionResultingList <> nil) and (FActionResultingList.count > 0);
end;

Function TFhirCarePlanActivity.GetProgressList : TFhirAnnotationList;
begin
  if FProgressList = nil then
    FProgressList := TFhirAnnotationList.Create;
  result := FProgressList;
end;

Function TFhirCarePlanActivity.GetHasProgressList : boolean;
begin
  result := (FProgressList <> nil) and (FProgressList.count > 0);
end;

Procedure TFhirCarePlanActivity.SetReference(value : TFhirReference{Resource});
begin
  FReference.free;
  FReference := value;
end;

Procedure TFhirCarePlanActivity.SetDetail(value : TFhirCarePlanActivityDetail);
begin
  FDetail.free;
  FDetail := value;
end;

function TFhirCarePlanActivity.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FactionResultingList.sizeInBytes);
  inc(result, FprogressList.sizeInBytes);
  inc(result, FReference.sizeInBytes);
  inc(result, FDetail.sizeInBytes);
end;

{ TFhirCarePlanActivityListEnumerator }

Constructor TFhirCarePlanActivityListEnumerator.Create(list : TFhirCarePlanActivityList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCarePlanActivityListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCarePlanActivityListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCarePlanActivityListEnumerator.GetCurrent : TFhirCarePlanActivity;
begin
  Result := FList[FIndex];
end;

function TFhirCarePlanActivityListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCarePlanActivityList }
procedure TFhirCarePlanActivityList.AddItem(value: TFhirCarePlanActivity);
begin
  assert(value.ClassName = 'TFhirCarePlanActivity', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCarePlanActivity');
  add(value);
end;

function TFhirCarePlanActivityList.Append: TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCarePlanActivityList.ClearItems;
begin
  Clear;
end;

function TFhirCarePlanActivityList.GetEnumerator : TFhirCarePlanActivityListEnumerator;
begin
  result := TFhirCarePlanActivityListEnumerator.Create(self.link);
end;

function TFhirCarePlanActivityList.Clone: TFhirCarePlanActivityList;
begin
  result := TFhirCarePlanActivityList(inherited Clone);
end;

function TFhirCarePlanActivityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCarePlanActivityList.GetItemN(index: Integer): TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity(ObjectByIndex[index]);
end;

function TFhirCarePlanActivityList.ItemClass: TFslObjectClass;
begin
  result := TFhirCarePlanActivity;
end;
function TFhirCarePlanActivityList.IndexOf(value: TFhirCarePlanActivity): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCarePlanActivityList.Insert(index: Integer): TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCarePlanActivityList.InsertItem(index: Integer; value: TFhirCarePlanActivity);
begin
  assert(value is TFhirCarePlanActivity);
  Inherited Insert(index, value);
end;

function TFhirCarePlanActivityList.Item(index: Integer): TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity(ObjectByIndex[index]);
end;

function TFhirCarePlanActivityList.Link: TFhirCarePlanActivityList;
begin
  result := TFhirCarePlanActivityList(inherited Link);
end;

procedure TFhirCarePlanActivityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCarePlanActivityList.SetItemByIndex(index: Integer; value: TFhirCarePlanActivity);
begin
  assert(value is TFhirCarePlanActivity);
  FhirCarePlanActivities[index] := value;
end;

procedure TFhirCarePlanActivityList.SetItemN(index: Integer; value: TFhirCarePlanActivity);
begin
  assert(value is TFhirCarePlanActivity);
  ObjectByIndex[index] := value;
end;

{ TFhirCarePlanActivityDetail }

constructor TFhirCarePlanActivityDetail.Create;
begin
  inherited;
end;

destructor TFhirCarePlanActivityDetail.Destroy;
begin
  FCategory.free;
  FCode.free;
  FReasonCodeList.Free;
  FReasonReferenceList.Free;
  FGoalList.Free;
  FStatus.free;
  FStatusReason.free;
  FProhibited.free;
  FScheduled.free;
  FLocation.free;
  FPerformerList.Free;
  FProduct.free;
  FDailyAmount.free;
  FQuantity.free;
  FDescription.free;
  inherited;
end;

procedure TFhirCarePlanActivityDetail.Assign(oSource : TFslObject);
begin
  inherited;
  category := TFhirCarePlanActivityDetail(oSource).category.Clone;
  code := TFhirCarePlanActivityDetail(oSource).code.Clone;
  if (TFhirCarePlanActivityDetail(oSource).FReasonCodeList = nil) then
  begin
    FReasonCodeList.free;
    FReasonCodeList := nil;
  end
  else
  begin
    if FReasonCodeList = nil then
      FReasonCodeList := TFhirCodeableConceptList.Create;
    FReasonCodeList.Assign(TFhirCarePlanActivityDetail(oSource).FReasonCodeList);
  end;
  if (TFhirCarePlanActivityDetail(oSource).FReasonReferenceList = nil) then
  begin
    FReasonReferenceList.free;
    FReasonReferenceList := nil;
  end
  else
  begin
    if FReasonReferenceList = nil then
      FReasonReferenceList := TFhirReferenceList{TFhirCondition}.Create;
    FReasonReferenceList.Assign(TFhirCarePlanActivityDetail(oSource).FReasonReferenceList);
  end;
  if (TFhirCarePlanActivityDetail(oSource).FGoalList = nil) then
  begin
    FGoalList.free;
    FGoalList := nil;
  end
  else
  begin
    if FGoalList = nil then
      FGoalList := TFhirReferenceList{TFhirGoal}.Create;
    FGoalList.Assign(TFhirCarePlanActivityDetail(oSource).FGoalList);
  end;
  FStatus := TFhirCarePlanActivityDetail(oSource).FStatus.Link;
  statusReason := TFhirCarePlanActivityDetail(oSource).statusReason.Clone;
  prohibitedElement := TFhirCarePlanActivityDetail(oSource).prohibitedElement.Clone;
  scheduled := TFhirCarePlanActivityDetail(oSource).scheduled.Clone;
  location := TFhirCarePlanActivityDetail(oSource).location.Clone;
  if (TFhirCarePlanActivityDetail(oSource).FPerformerList = nil) then
  begin
    FPerformerList.free;
    FPerformerList := nil;
  end
  else
  begin
    if FPerformerList = nil then
      FPerformerList := TFhirReferenceList{Resource}.Create;
    FPerformerList.Assign(TFhirCarePlanActivityDetail(oSource).FPerformerList);
  end;
  product := TFhirCarePlanActivityDetail(oSource).product.Clone;
  dailyAmount := TFhirCarePlanActivityDetail(oSource).dailyAmount.Clone;
  quantity := TFhirCarePlanActivityDetail(oSource).quantity.Clone;
  descriptionElement := TFhirCarePlanActivityDetail(oSource).descriptionElement.Clone;
end;

procedure TFhirCarePlanActivityDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'reasonCode') Then
    list.addAll(self, 'reasonCode', FReasonCodeList);
  if (child_name = 'reasonReference') Then
    list.addAll(self, 'reasonReference', FReasonReferenceList);
  if (child_name = 'goal') Then
    list.addAll(self, 'goal', FGoalList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusReason') Then
     list.add(self.link, 'statusReason', FStatusReason.Link);
  if (child_name = 'prohibited') Then
     list.add(self.link, 'prohibited', FProhibited.Link);
  if (child_name = 'scheduled[x]') or (child_name = 'scheduled') Then
     list.add(self.link, 'scheduled[x]', FScheduled.Link);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'performer') Then
    list.addAll(self, 'performer', FPerformerList);
  if (child_name = 'product[x]') or (child_name = 'product') Then
     list.add(self.link, 'product[x]', FProduct.Link);
  if (child_name = 'dailyAmount') Then
     list.add(self.link, 'dailyAmount', FDailyAmount.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
end;

procedure TFhirCarePlanActivityDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reasonCode', 'CodeableConcept', true, TFhirCodeableConcept, FReasonCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reasonReference', 'Reference(Condition)', true, TFhirReference{TFhirCondition}, FReasonReferenceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'goal', 'Reference(Goal)', true, TFhirReference{TFhirGoal}, FGoalList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'statusReason', 'CodeableConcept', false, TFhirCodeableConcept, FStatusReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'prohibited', 'boolean', false, TFhirBoolean, FProhibited.Link));{2}
  oList.add(TFHIRProperty.create(self, 'scheduled[x]', 'Timing|Period|string', false, TFhirType, FScheduled.Link));{2}
  oList.add(TFHIRProperty.create(self, 'location', 'Reference(Location)', false, TFhirReference{TFhirLocation}, FLocation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'performer', 'Reference(Practitioner|Organization|RelatedPerson|Patient)', true, TFhirReference{Resource}, FPerformerList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'product[x]', 'CodeableConcept|Reference(Medication|Substance)', false, TFhirType, FProduct.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dailyAmount', 'Quantity', false, TFhirQuantity, FDailyAmount.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
end;

function TFhirCarePlanActivityDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'reasonCode') then
  begin
    ReasonCodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'reasonReference') then
  begin
    ReasonReferenceList.add(propValue as TFhirReference{TFhirCondition}){2a};
    result := propValue;
  end
  else if (propName = 'goal') then
  begin
    GoalList.add(propValue as TFhirReference{TFhirGoal}){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirCarePlanActivityStatusEnum, CODES_TFhirCarePlanActivityStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'statusReason') then
  begin
    StatusReason := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'prohibited') then
  begin
    ProhibitedElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'scheduled', ['Timing', 'Period', 'String'])) then
  begin
    Scheduled := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirReference{TFhirLocation}{4b};
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    PerformerList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'product', ['CodeableConcept', 'Reference'])) then
  begin
    Product := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'dailyAmount') then
  begin
    DailyAmount := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCarePlanActivityDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'reasonCode') then ReasonCodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'reasonReference') then ReasonReferenceList.insertItem(index, propValue as TFhirReference{TFhirCondition}){2a}
  else if (propName = 'goal') then GoalList.insertItem(index, propValue as TFhirReference{TFhirGoal}){2a}
  else if (propName = 'performer') then PerformerList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else inherited;
end;

function TFhirCarePlanActivityDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'reasonCode') then result := ReasonCodeList.new(){2}
  else if (propName = 'reasonReference') then result := ReasonReferenceList.new(){2}
  else if (propName = 'goal') then result := GoalList.new(){2}
  else if (propName = 'statusReason') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'prohibited') then result := TFhirBoolean.create() {5b}
  else if (isMatchingName(propName, 'scheduled', ['Timing', 'Period', 'String'])) then raise EFHIRException.create('Cannot make property Scheduled'){4x}
  else if (propName = 'location') then result := TFhirReference{TFhirLocation}.create(){4b}
  else if (propName = 'performer') then result := PerformerList.new(){2}
  else if (isMatchingName(propName, 'product', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Product'){4x}
  else if (propName = 'dailyAmount') then result := TFhirQuantity.create(){4b}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCarePlanActivityDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'reasonCode') then result := 'CodeableConcept'
  else if (propName = 'reasonReference') then result := 'Reference'
  else if (propName = 'goal') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'statusReason') then result := 'CodeableConcept'
  else if (propName = 'prohibited') then result := 'boolean'
  else if (propName = 'scheduled[x]') then result := 'Timing|Period|string'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'performer') then result := 'Reference'
  else if (propName = 'product[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'dailyAmount') then result := 'Quantity'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'description') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCarePlanActivityDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'reasonCode') then deletePropertyValue('reasonCode', ReasonCodeList, value) {2}
  else if (propName = 'reasonReference') then deletePropertyValue('reasonReference', ReasonReferenceList, value) {2}
  else if (propName = 'goal') then deletePropertyValue('goal', GoalList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusReason') then StatusReasonElement := nil
  else if (propName = 'prohibited') then ProhibitedElement := nil
  else if (isMatchingName(propName, 'scheduled', ['Timing', 'Period', 'String'])) then ScheduledElement := nil{4x}
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'performer') then deletePropertyValue('performer', PerformerList, value) {2}
  else if (isMatchingName(propName, 'product', ['CodeableConcept', 'Reference'])) then ProductElement := nil{4x}
  else if (propName = 'dailyAmount') then DailyAmountElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCarePlanActivityDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'reasonCode') then replacePropertyValue('reasonCode', ReasonCodeList, existing, new) {2}
  else if (propName = 'reasonReference') then replacePropertyValue('reasonReference', ReasonReferenceList, existing, new) {2}
  else if (propName = 'goal') then replacePropertyValue('goal', GoalList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirCarePlanActivityStatusEnum, CODES_TFhirCarePlanActivityStatusEnum, new){4}
  else if (propName = 'statusReason') then StatusReasonElement := new as TFhirCodeableConcept{4}
  else if (propName = 'prohibited') then ProhibitedElement := asBoolean(new){5b}
  else if (isMatchingName(propName, 'scheduled', ['Timing', 'Period', 'String'])) then ScheduledElement := new as TFhirType{4x}
  else if (propName = 'location') then LocationElement := new as TFhirReference{TFhirLocation}{4}
  else if (propName = 'performer') then replacePropertyValue('performer', PerformerList, existing, new) {2}
  else if (isMatchingName(propName, 'product', ['CodeableConcept', 'Reference'])) then ProductElement := new as TFhirType{4x}
  else if (propName = 'dailyAmount') then DailyAmountElement := new as TFhirQuantity{4}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCarePlanActivityDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'reasonCode') then ReasonCodeList.move(source, destination){2a}
  else if (propName = 'reasonReference') then ReasonReferenceList.move(source, destination){2a}
  else if (propName = 'goal') then GoalList.move(source, destination){2a}
  else if (propName = 'performer') then PerformerList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCarePlanActivityDetail.fhirType : string;
begin
  result := 'detail';
end;

function TFhirCarePlanActivityDetail.Link : TFhirCarePlanActivityDetail;
begin
  result := TFhirCarePlanActivityDetail(inherited Link);
end;

function TFhirCarePlanActivityDetail.Clone : TFhirCarePlanActivityDetail;
begin
  result := TFhirCarePlanActivityDetail(inherited Clone);
end;

function TFhirCarePlanActivityDetail.equals(other : TObject) : boolean;
var
  o : TFhirCarePlanActivityDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCarePlanActivityDetail)) then
    result := false
  else
  begin
    o := TFhirCarePlanActivityDetail(other);
    result := compareDeep(categoryElement, o.categoryElement, true) and compareDeep(codeElement, o.codeElement, true) and
      compareDeep(reasonCodeList, o.reasonCodeList, true) and compareDeep(reasonReferenceList, o.reasonReferenceList, true) and
      compareDeep(goalList, o.goalList, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(statusReasonElement, o.statusReasonElement, true) and compareDeep(prohibitedElement, o.prohibitedElement, true) and
      compareDeep(scheduledElement, o.scheduledElement, true) and compareDeep(locationElement, o.locationElement, true) and
      compareDeep(performerList, o.performerList, true) and compareDeep(productElement, o.productElement, true) and
      compareDeep(dailyAmountElement, o.dailyAmountElement, true) and compareDeep(quantityElement, o.quantityElement, true) and
      compareDeep(descriptionElement, o.descriptionElement, true);
  end;
end;

function TFhirCarePlanActivityDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCategory) and isEmptyProp(FCode) and isEmptyProp(FreasonCodeList) and isEmptyProp(FreasonReferenceList) and isEmptyProp(FgoalList) and isEmptyProp(FStatus) and isEmptyProp(FStatusReason) and isEmptyProp(FProhibited) and isEmptyProp(FScheduled) and isEmptyProp(FLocation) and isEmptyProp(FperformerList) and isEmptyProp(FProduct) and isEmptyProp(FDailyAmount) and isEmptyProp(FQuantity) and isEmptyProp(FDescription);
end;

procedure TFhirCarePlanActivityDetail.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('category');
  fields.add('code');
  fields.add('reasonCode');
  fields.add('reasonReference');
  fields.add('goal');
  fields.add('status');
  fields.add('statusReason');
  fields.add('prohibited');
  fields.add('scheduled[x]');
  fields.add('location');
  fields.add('performer');
  fields.add('product[x]');
  fields.add('dailyAmount');
  fields.add('quantity');
  fields.add('description');
end;

{ TFhirCarePlanActivityDetail }

Procedure TFhirCarePlanActivityDetail.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirCarePlanActivityDetail.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirCarePlanActivityDetail.GetReasonCodeList : TFhirCodeableConceptList;
begin
  if FReasonCodeList = nil then
    FReasonCodeList := TFhirCodeableConceptList.Create;
  result := FReasonCodeList;
end;

Function TFhirCarePlanActivityDetail.GetHasReasonCodeList : boolean;
begin
  result := (FReasonCodeList <> nil) and (FReasonCodeList.count > 0);
end;

Function TFhirCarePlanActivityDetail.GetReasonReferenceList : TFhirReferenceList{TFhirCondition};
begin
  if FReasonReferenceList = nil then
    FReasonReferenceList := TFhirReferenceList{TFhirCondition}.Create;
  result := FReasonReferenceList;
end;

Function TFhirCarePlanActivityDetail.GetHasReasonReferenceList : boolean;
begin
  result := (FReasonReferenceList <> nil) and (FReasonReferenceList.count > 0);
end;

Function TFhirCarePlanActivityDetail.GetGoalList : TFhirReferenceList{TFhirGoal};
begin
  if FGoalList = nil then
    FGoalList := TFhirReferenceList{TFhirGoal}.Create;
  result := FGoalList;
end;

Function TFhirCarePlanActivityDetail.GetHasGoalList : boolean;
begin
  result := (FGoalList <> nil) and (FGoalList.count > 0);
end;

Procedure TFhirCarePlanActivityDetail.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirCarePlanActivityDetail.GetStatusST : TFhirCarePlanActivityStatusEnum;
begin
  if FStatus = nil then
    result := TFhirCarePlanActivityStatusEnum(0)
  else
    result := TFhirCarePlanActivityStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirCarePlanActivityStatusEnum, FStatus.value));
end;

Procedure TFhirCarePlanActivityDetail.SetStatusST(value : TFhirCarePlanActivityStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirCarePlanActivityStatusEnum[value], CODES_TFhirCarePlanActivityStatusEnum[value]);
end;

Procedure TFhirCarePlanActivityDetail.SetStatusReason(value : TFhirCodeableConcept);
begin
  FStatusReason.free;
  FStatusReason := value;
end;

Procedure TFhirCarePlanActivityDetail.SetProhibited(value : TFhirBoolean);
begin
  FProhibited.free;
  FProhibited := value;
end;

Function TFhirCarePlanActivityDetail.GetProhibitedST : Boolean;
begin
  if FProhibited = nil then
    result := false
  else
    result := FProhibited.value;
end;

Procedure TFhirCarePlanActivityDetail.SetProhibitedST(value : Boolean);
begin
  if FProhibited = nil then
    FProhibited := TFhirBoolean.create;
  FProhibited.value := value
end;

Procedure TFhirCarePlanActivityDetail.SetScheduled(value : TFhirType);
begin
  FScheduled.free;
  FScheduled := value;
end;

Procedure TFhirCarePlanActivityDetail.SetLocation(value : TFhirReference{TFhirLocation});
begin
  FLocation.free;
  FLocation := value;
end;

Function TFhirCarePlanActivityDetail.GetPerformerList : TFhirReferenceList{Resource};
begin
  if FPerformerList = nil then
    FPerformerList := TFhirReferenceList{Resource}.Create;
  result := FPerformerList;
end;

Function TFhirCarePlanActivityDetail.GetHasPerformerList : boolean;
begin
  result := (FPerformerList <> nil) and (FPerformerList.count > 0);
end;

Procedure TFhirCarePlanActivityDetail.SetProduct(value : TFhirType);
begin
  FProduct.free;
  FProduct := value;
end;

Procedure TFhirCarePlanActivityDetail.SetDailyAmount(value : TFhirQuantity);
begin
  FDailyAmount.free;
  FDailyAmount := value;
end;

Procedure TFhirCarePlanActivityDetail.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirCarePlanActivityDetail.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirCarePlanActivityDetail.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirCarePlanActivityDetail.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirCarePlanActivityDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCategory.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FreasonCodeList.sizeInBytes);
  inc(result, FreasonReferenceList.sizeInBytes);
  inc(result, FgoalList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FStatusReason.sizeInBytes);
  inc(result, FProhibited.sizeInBytes);
  inc(result, FScheduled.sizeInBytes);
  inc(result, FLocation.sizeInBytes);
  inc(result, FperformerList.sizeInBytes);
  inc(result, FProduct.sizeInBytes);
  inc(result, FDailyAmount.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
end;

{ TFhirCarePlanActivityDetailListEnumerator }

Constructor TFhirCarePlanActivityDetailListEnumerator.Create(list : TFhirCarePlanActivityDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCarePlanActivityDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCarePlanActivityDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCarePlanActivityDetailListEnumerator.GetCurrent : TFhirCarePlanActivityDetail;
begin
  Result := FList[FIndex];
end;

function TFhirCarePlanActivityDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCarePlanActivityDetailList }
procedure TFhirCarePlanActivityDetailList.AddItem(value: TFhirCarePlanActivityDetail);
begin
  assert(value.ClassName = 'TFhirCarePlanActivityDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCarePlanActivityDetail');
  add(value);
end;

function TFhirCarePlanActivityDetailList.Append: TFhirCarePlanActivityDetail;
begin
  result := TFhirCarePlanActivityDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCarePlanActivityDetailList.ClearItems;
begin
  Clear;
end;

function TFhirCarePlanActivityDetailList.GetEnumerator : TFhirCarePlanActivityDetailListEnumerator;
begin
  result := TFhirCarePlanActivityDetailListEnumerator.Create(self.link);
end;

function TFhirCarePlanActivityDetailList.Clone: TFhirCarePlanActivityDetailList;
begin
  result := TFhirCarePlanActivityDetailList(inherited Clone);
end;

function TFhirCarePlanActivityDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCarePlanActivityDetailList.GetItemN(index: Integer): TFhirCarePlanActivityDetail;
begin
  result := TFhirCarePlanActivityDetail(ObjectByIndex[index]);
end;

function TFhirCarePlanActivityDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirCarePlanActivityDetail;
end;
function TFhirCarePlanActivityDetailList.IndexOf(value: TFhirCarePlanActivityDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCarePlanActivityDetailList.Insert(index: Integer): TFhirCarePlanActivityDetail;
begin
  result := TFhirCarePlanActivityDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCarePlanActivityDetailList.InsertItem(index: Integer; value: TFhirCarePlanActivityDetail);
begin
  assert(value is TFhirCarePlanActivityDetail);
  Inherited Insert(index, value);
end;

function TFhirCarePlanActivityDetailList.Item(index: Integer): TFhirCarePlanActivityDetail;
begin
  result := TFhirCarePlanActivityDetail(ObjectByIndex[index]);
end;

function TFhirCarePlanActivityDetailList.Link: TFhirCarePlanActivityDetailList;
begin
  result := TFhirCarePlanActivityDetailList(inherited Link);
end;

procedure TFhirCarePlanActivityDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCarePlanActivityDetailList.SetItemByIndex(index: Integer; value: TFhirCarePlanActivityDetail);
begin
  assert(value is TFhirCarePlanActivityDetail);
  FhirCarePlanActivityDetails[index] := value;
end;

procedure TFhirCarePlanActivityDetailList.SetItemN(index: Integer; value: TFhirCarePlanActivityDetail);
begin
  assert(value is TFhirCarePlanActivityDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirCarePlan }

constructor TFhirCarePlan.Create;
begin
  inherited;
end;

destructor TFhirCarePlan.Destroy;
begin
  FIdentifierList.Free;
  FSubject.free;
  FStatus.free;
  FContext.free;
  FPeriod.free;
  FAuthorList.Free;
  FModified.free;
  FCategoryList.Free;
  FDescription.free;
  FAddressesList.Free;
  FSupportList.Free;
  FRelatedPlanList.Free;
  FParticipantList.Free;
  FGoalList.Free;
  FActivityList.Free;
  FNote.free;
  inherited;
end;

function TFhirCarePlan.GetResourceType : TFhirResourceType;
begin
  result := frtCarePlan;
end;

procedure TFhirCarePlan.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCarePlan(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirCarePlan(oSource).FIdentifierList);
  end;
  subject := TFhirCarePlan(oSource).subject.Clone;
  FStatus := TFhirCarePlan(oSource).FStatus.Link;
  context := TFhirCarePlan(oSource).context.Clone;
  period := TFhirCarePlan(oSource).period.Clone;
  if (TFhirCarePlan(oSource).FAuthorList = nil) then
  begin
    FAuthorList.free;
    FAuthorList := nil;
  end
  else
  begin
    if FAuthorList = nil then
      FAuthorList := TFhirReferenceList{Resource}.Create;
    FAuthorList.Assign(TFhirCarePlan(oSource).FAuthorList);
  end;
  modifiedElement := TFhirCarePlan(oSource).modifiedElement.Clone;
  if (TFhirCarePlan(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirCarePlan(oSource).FCategoryList);
  end;
  descriptionElement := TFhirCarePlan(oSource).descriptionElement.Clone;
  if (TFhirCarePlan(oSource).FAddressesList = nil) then
  begin
    FAddressesList.free;
    FAddressesList := nil;
  end
  else
  begin
    if FAddressesList = nil then
      FAddressesList := TFhirReferenceList{TFhirCondition}.Create;
    FAddressesList.Assign(TFhirCarePlan(oSource).FAddressesList);
  end;
  if (TFhirCarePlan(oSource).FSupportList = nil) then
  begin
    FSupportList.free;
    FSupportList := nil;
  end
  else
  begin
    if FSupportList = nil then
      FSupportList := TFhirReferenceList{TFhirReference}.Create;
    FSupportList.Assign(TFhirCarePlan(oSource).FSupportList);
  end;
  if (TFhirCarePlan(oSource).FRelatedPlanList = nil) then
  begin
    FRelatedPlanList.free;
    FRelatedPlanList := nil;
  end
  else
  begin
    if FRelatedPlanList = nil then
      FRelatedPlanList := TFhirCarePlanRelatedPlanList.Create;
    FRelatedPlanList.Assign(TFhirCarePlan(oSource).FRelatedPlanList);
  end;
  if (TFhirCarePlan(oSource).FParticipantList = nil) then
  begin
    FParticipantList.free;
    FParticipantList := nil;
  end
  else
  begin
    if FParticipantList = nil then
      FParticipantList := TFhirCarePlanParticipantList.Create;
    FParticipantList.Assign(TFhirCarePlan(oSource).FParticipantList);
  end;
  if (TFhirCarePlan(oSource).FGoalList = nil) then
  begin
    FGoalList.free;
    FGoalList := nil;
  end
  else
  begin
    if FGoalList = nil then
      FGoalList := TFhirReferenceList{TFhirGoal}.Create;
    FGoalList.Assign(TFhirCarePlan(oSource).FGoalList);
  end;
  if (TFhirCarePlan(oSource).FActivityList = nil) then
  begin
    FActivityList.free;
    FActivityList := nil;
  end
  else
  begin
    if FActivityList = nil then
      FActivityList := TFhirCarePlanActivityList.Create;
    FActivityList.Assign(TFhirCarePlan(oSource).FActivityList);
  end;
  note := TFhirCarePlan(oSource).note.Clone;
end;

procedure TFhirCarePlan.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'context') Then
     list.add(self.link, 'context', FContext.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'author') Then
    list.addAll(self, 'author', FAuthorList);
  if (child_name = 'modified') Then
     list.add(self.link, 'modified', FModified.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'addresses') Then
    list.addAll(self, 'addresses', FAddressesList);
  if (child_name = 'support') Then
    list.addAll(self, 'support', FSupportList);
  if (child_name = 'relatedPlan') Then
    list.addAll(self, 'relatedPlan', FRelatedPlanList);
  if (child_name = 'participant') Then
    list.addAll(self, 'participant', FParticipantList);
  if (child_name = 'goal') Then
    list.addAll(self, 'goal', FGoalList);
  if (child_name = 'activity') Then
    list.addAll(self, 'activity', FActivityList);
  if (child_name = 'note') Then
     list.add(self.link, 'note', FNote.Link);
end;

procedure TFhirCarePlan.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Group)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'context', 'Reference(Encounter|EpisodeOfCare)', false, TFhirReference{Resource}, FContext.Link));{2}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'author', 'Reference(Patient|Practitioner|RelatedPerson|Organization)', true, TFhirReference{Resource}, FAuthorList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'modified', 'dateTime', false, TFhirDateTime, FModified.Link));{2}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'addresses', 'Reference(Condition)', true, TFhirReference{TFhirCondition}, FAddressesList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'support', 'Reference(Any)', true, TFhirReference{TFhirReference}, FSupportList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'relatedPlan', '', true, TFhirCarePlanRelatedPlan, FRelatedPlanList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'participant', '', true, TFhirCarePlanParticipant, FParticipantList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'goal', 'Reference(Goal)', true, TFhirReference{TFhirGoal}, FGoalList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'activity', '', true, TFhirCarePlanActivity, FActivityList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', false, TFhirAnnotation, FNote.Link));{2}
end;

function TFhirCarePlan.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirCarePlanStatusEnum, CODES_TFhirCarePlanStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'context') then
  begin
    Context := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    AuthorList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'modified') then
  begin
    ModifiedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'addresses') then
  begin
    AddressesList.add(propValue as TFhirReference{TFhirCondition}){2a};
    result := propValue;
  end
  else if (propName = 'support') then
  begin
    SupportList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'relatedPlan') then
  begin
    RelatedPlanList.add(propValue as TFhirCarePlanRelatedPlan){2a};
    result := propValue;
  end
  else if (propName = 'participant') then
  begin
    ParticipantList.add(propValue as TFhirCarePlanParticipant){2a};
    result := propValue;
  end
  else if (propName = 'goal') then
  begin
    GoalList.add(propValue as TFhirReference{TFhirGoal}){2a};
    result := propValue;
  end
  else if (propName = 'activity') then
  begin
    ActivityList.add(propValue as TFhirCarePlanActivity){2a};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    Note := propValue as TFhirAnnotation{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirCarePlan.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'author') then AuthorList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'addresses') then AddressesList.insertItem(index, propValue as TFhirReference{TFhirCondition}){2a}
  else if (propName = 'support') then SupportList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'relatedPlan') then RelatedPlanList.insertItem(index, propValue as TFhirCarePlanRelatedPlan){2a}
  else if (propName = 'participant') then ParticipantList.insertItem(index, propValue as TFhirCarePlanParticipant){2a}
  else if (propName = 'goal') then GoalList.insertItem(index, propValue as TFhirReference{TFhirGoal}){2a}
  else if (propName = 'activity') then ActivityList.insertItem(index, propValue as TFhirCarePlanActivity){2a}
  else inherited;
end;

function TFhirCarePlan.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'context') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'period') then result := TFhirPeriod.create(){4b}
  else if (propName = 'author') then result := AuthorList.new(){2}
  else if (propName = 'modified') then result := TFhirDateTime.create() {5b}
  else if (propName = 'category') then result := CategoryList.new(){2}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'addresses') then result := AddressesList.new(){2}
  else if (propName = 'support') then result := SupportList.new(){2}
  else if (propName = 'relatedPlan') then result := RelatedPlanList.new(){2}
  else if (propName = 'participant') then result := ParticipantList.new(){2}
  else if (propName = 'goal') then result := GoalList.new(){2}
  else if (propName = 'activity') then result := ActivityList.new(){2}
  else if (propName = 'note') then result := TFhirAnnotation.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCarePlan.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'context') then result := 'Reference'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'modified') then result := 'dateTime'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'addresses') then result := 'Reference'
  else if (propName = 'support') then result := 'Reference'
  else if (propName = 'relatedPlan') then result := ''
  else if (propName = 'participant') then result := ''
  else if (propName = 'goal') then result := 'Reference'
  else if (propName = 'activity') then result := ''
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCarePlan.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'context') then ContextElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'author') then deletePropertyValue('author', AuthorList, value) {2}
  else if (propName = 'modified') then ModifiedElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value) {2}
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'addresses') then deletePropertyValue('addresses', AddressesList, value) {2}
  else if (propName = 'support') then deletePropertyValue('support', SupportList, value) {2}
  else if (propName = 'relatedPlan') then deletePropertyValue('relatedPlan', RelatedPlanList, value) {2}
  else if (propName = 'participant') then deletePropertyValue('participant', ParticipantList, value) {2}
  else if (propName = 'goal') then deletePropertyValue('goal', GoalList, value) {2}
  else if (propName = 'activity') then deletePropertyValue('activity', ActivityList, value) {2}
  else if (propName = 'note') then NoteElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCarePlan.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirCarePlanStatusEnum, CODES_TFhirCarePlanStatusEnum, new){4}
  else if (propName = 'context') then ContextElement := new as TFhirReference{Resource}{4}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else if (propName = 'author') then replacePropertyValue('author', AuthorList, existing, new) {2}
  else if (propName = 'modified') then ModifiedElement := asDateTime(new){5b}
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new) {2}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'addresses') then replacePropertyValue('addresses', AddressesList, existing, new) {2}
  else if (propName = 'support') then replacePropertyValue('support', SupportList, existing, new) {2}
  else if (propName = 'relatedPlan') then replacePropertyValue('relatedPlan', RelatedPlanList, existing, new) {2}
  else if (propName = 'participant') then replacePropertyValue('participant', ParticipantList, existing, new) {2}
  else if (propName = 'goal') then replacePropertyValue('goal', GoalList, existing, new) {2}
  else if (propName = 'activity') then replacePropertyValue('activity', ActivityList, existing, new) {2}
  else if (propName = 'note') then NoteElement := new as TFhirAnnotation{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCarePlan.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'author') then AuthorList.move(source, destination){2a}
  else if (propName = 'category') then CategoryList.move(source, destination){2a}
  else if (propName = 'addresses') then AddressesList.move(source, destination){2a}
  else if (propName = 'support') then SupportList.move(source, destination){2a}
  else if (propName = 'relatedPlan') then RelatedPlanList.move(source, destination){2a}
  else if (propName = 'participant') then ParticipantList.move(source, destination){2a}
  else if (propName = 'goal') then GoalList.move(source, destination){2a}
  else if (propName = 'activity') then ActivityList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCarePlan.fhirType : string;
begin
  result := 'CarePlan';
end;

function TFhirCarePlan.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FSubject) and isEmptyProp(FStatus) and isEmptyProp(FContext) and isEmptyProp(FPeriod) and isEmptyProp(FauthorList) and isEmptyProp(FModified) and isEmptyProp(FcategoryList) and isEmptyProp(FDescription) and isEmptyProp(FaddressesList) and isEmptyProp(FsupportList) and isEmptyProp(FrelatedPlanList) and isEmptyProp(FparticipantList) and isEmptyProp(FgoalList) and isEmptyProp(FactivityList) and isEmptyProp(FNote);
end;

function TFhirCarePlan.equals(other : TObject) : boolean;
var
  o : TFhirCarePlan;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCarePlan)) then
    result := false
  else
  begin
    o := TFhirCarePlan(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(subjectElement, o.subjectElement, true) and
      compareDeep(statusElement, o.statusElement, true) and compareDeep(contextElement, o.contextElement, true) and
      compareDeep(periodElement, o.periodElement, true) and compareDeep(authorList, o.authorList, true) and
      compareDeep(modifiedElement, o.modifiedElement, true) and compareDeep(categoryList, o.categoryList, true) and
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(addressesList, o.addressesList, true) and
      compareDeep(supportList, o.supportList, true) and compareDeep(relatedPlanList, o.relatedPlanList, true) and
      compareDeep(participantList, o.participantList, true) and compareDeep(goalList, o.goalList, true) and
      compareDeep(activityList, o.activityList, true) and compareDeep(noteElement, o.noteElement, true);
  end;
end;

function TFhirCarePlan.Link : TFhirCarePlan;
begin
  result := TFhirCarePlan(inherited Link);
end;

function TFhirCarePlan.Clone : TFhirCarePlan;
begin
  result := TFhirCarePlan(inherited Clone);
end;

procedure TFhirCarePlan.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('subject');
  fields.add('status');
  fields.add('context');
  fields.add('period');
  fields.add('author');
  fields.add('modified');
  fields.add('category');
  fields.add('description');
  fields.add('addresses');
  fields.add('support');
  fields.add('relatedPlan');
  fields.add('participant');
  fields.add('goal');
  fields.add('activity');
  fields.add('note');
end;

{ TFhirCarePlan }

Function TFhirCarePlan.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirCarePlan.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirCarePlan.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirCarePlan.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirCarePlan.GetStatusST : TFhirCarePlanStatusEnum;
begin
  if FStatus = nil then
    result := TFhirCarePlanStatusEnum(0)
  else
    result := TFhirCarePlanStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirCarePlanStatusEnum, FStatus.value));
end;

Procedure TFhirCarePlan.SetStatusST(value : TFhirCarePlanStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirCarePlanStatusEnum[value], CODES_TFhirCarePlanStatusEnum[value]);
end;

Procedure TFhirCarePlan.SetContext(value : TFhirReference{Resource});
begin
  FContext.free;
  FContext := value;
end;

Procedure TFhirCarePlan.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Function TFhirCarePlan.GetAuthorList : TFhirReferenceList{Resource};
begin
  if FAuthorList = nil then
    FAuthorList := TFhirReferenceList{Resource}.Create;
  result := FAuthorList;
end;

Function TFhirCarePlan.GetHasAuthorList : boolean;
begin
  result := (FAuthorList <> nil) and (FAuthorList.count > 0);
end;

Procedure TFhirCarePlan.SetModified(value : TFhirDateTime);
begin
  FModified.free;
  FModified := value;
end;

Function TFhirCarePlan.GetModifiedST : TFslDateTime;
begin
  if FModified = nil then
    result := TFslDateTime.makeNull
  else
    result := FModified.value;
end;

Procedure TFhirCarePlan.SetModifiedST(value : TFslDateTime);
begin
  if FModified = nil then
    FModified := TFhirDateTime.create;
  FModified.value := value
end;

Function TFhirCarePlan.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

Function TFhirCarePlan.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

Procedure TFhirCarePlan.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirCarePlan.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirCarePlan.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Function TFhirCarePlan.GetAddressesList : TFhirReferenceList{TFhirCondition};
begin
  if FAddressesList = nil then
    FAddressesList := TFhirReferenceList{TFhirCondition}.Create;
  result := FAddressesList;
end;

Function TFhirCarePlan.GetHasAddressesList : boolean;
begin
  result := (FAddressesList <> nil) and (FAddressesList.count > 0);
end;

Function TFhirCarePlan.GetSupportList : TFhirReferenceList{TFhirReference};
begin
  if FSupportList = nil then
    FSupportList := TFhirReferenceList{TFhirReference}.Create;
  result := FSupportList;
end;

Function TFhirCarePlan.GetHasSupportList : boolean;
begin
  result := (FSupportList <> nil) and (FSupportList.count > 0);
end;

Function TFhirCarePlan.GetRelatedPlanList : TFhirCarePlanRelatedPlanList;
begin
  if FRelatedPlanList = nil then
    FRelatedPlanList := TFhirCarePlanRelatedPlanList.Create;
  result := FRelatedPlanList;
end;

Function TFhirCarePlan.GetHasRelatedPlanList : boolean;
begin
  result := (FRelatedPlanList <> nil) and (FRelatedPlanList.count > 0);
end;

Function TFhirCarePlan.GetParticipantList : TFhirCarePlanParticipantList;
begin
  if FParticipantList = nil then
    FParticipantList := TFhirCarePlanParticipantList.Create;
  result := FParticipantList;
end;

Function TFhirCarePlan.GetHasParticipantList : boolean;
begin
  result := (FParticipantList <> nil) and (FParticipantList.count > 0);
end;

Function TFhirCarePlan.GetGoalList : TFhirReferenceList{TFhirGoal};
begin
  if FGoalList = nil then
    FGoalList := TFhirReferenceList{TFhirGoal}.Create;
  result := FGoalList;
end;

Function TFhirCarePlan.GetHasGoalList : boolean;
begin
  result := (FGoalList <> nil) and (FGoalList.count > 0);
end;

Function TFhirCarePlan.GetActivityList : TFhirCarePlanActivityList;
begin
  if FActivityList = nil then
    FActivityList := TFhirCarePlanActivityList.Create;
  result := FActivityList;
end;

Function TFhirCarePlan.GetHasActivityList : boolean;
begin
  result := (FActivityList <> nil) and (FActivityList.count > 0);
end;

Procedure TFhirCarePlan.SetNote(value : TFhirAnnotation);
begin
  FNote.free;
  FNote := value;
end;

function TFhirCarePlan.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FContext.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FauthorList.sizeInBytes);
  inc(result, FModified.sizeInBytes);
  inc(result, FcategoryList.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FaddressesList.sizeInBytes);
  inc(result, FsupportList.sizeInBytes);
  inc(result, FrelatedPlanList.sizeInBytes);
  inc(result, FparticipantList.sizeInBytes);
  inc(result, FgoalList.sizeInBytes);
  inc(result, FactivityList.sizeInBytes);
  inc(result, FNote.sizeInBytes);
end;

{ TFhirCarePlanListEnumerator }

Constructor TFhirCarePlanListEnumerator.Create(list : TFhirCarePlanList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCarePlanListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCarePlanListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCarePlanListEnumerator.GetCurrent : TFhirCarePlan;
begin
  Result := FList[FIndex];
end;

function TFhirCarePlanListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCarePlanList }
procedure TFhirCarePlanList.AddItem(value: TFhirCarePlan);
begin
  assert(value.ClassName = 'TFhirCarePlan', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCarePlan');
  add(value);
end;

function TFhirCarePlanList.Append: TFhirCarePlan;
begin
  result := TFhirCarePlan.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCarePlanList.ClearItems;
begin
  Clear;
end;

function TFhirCarePlanList.GetEnumerator : TFhirCarePlanListEnumerator;
begin
  result := TFhirCarePlanListEnumerator.Create(self.link);
end;

function TFhirCarePlanList.Clone: TFhirCarePlanList;
begin
  result := TFhirCarePlanList(inherited Clone);
end;

function TFhirCarePlanList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCarePlanList.GetItemN(index: Integer): TFhirCarePlan;
begin
  result := TFhirCarePlan(ObjectByIndex[index]);
end;

function TFhirCarePlanList.ItemClass: TFslObjectClass;
begin
  result := TFhirCarePlan;
end;
function TFhirCarePlanList.IndexOf(value: TFhirCarePlan): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCarePlanList.Insert(index: Integer): TFhirCarePlan;
begin
  result := TFhirCarePlan.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCarePlanList.InsertItem(index: Integer; value: TFhirCarePlan);
begin
  assert(value is TFhirCarePlan);
  Inherited Insert(index, value);
end;

function TFhirCarePlanList.Item(index: Integer): TFhirCarePlan;
begin
  result := TFhirCarePlan(ObjectByIndex[index]);
end;

function TFhirCarePlanList.Link: TFhirCarePlanList;
begin
  result := TFhirCarePlanList(inherited Link);
end;

procedure TFhirCarePlanList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCarePlanList.SetItemByIndex(index: Integer; value: TFhirCarePlan);
begin
  assert(value is TFhirCarePlan);
  FhirCarePlans[index] := value;
end;

procedure TFhirCarePlanList.SetItemN(index: Integer; value: TFhirCarePlan);
begin
  assert(value is TFhirCarePlan);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CAREPLAN}

{$IFDEF FHIR_CLINICALIMPRESSION}

{ TFhirClinicalImpressionInvestigations }

constructor TFhirClinicalImpressionInvestigations.Create;
begin
  inherited;
end;

destructor TFhirClinicalImpressionInvestigations.Destroy;
begin
  FCode.free;
  FItemList.Free;
  inherited;
end;

procedure TFhirClinicalImpressionInvestigations.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirClinicalImpressionInvestigations(oSource).code.Clone;
  if (TFhirClinicalImpressionInvestigations(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirReferenceList{Resource}.Create;
    FItemList.Assign(TFhirClinicalImpressionInvestigations(oSource).FItemList);
  end;
end;

procedure TFhirClinicalImpressionInvestigations.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
end;

procedure TFhirClinicalImpressionInvestigations.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'item', 'Reference(Observation|QuestionnaireResponse|FamilyMemberHistory|DiagnosticReport)', true, TFhirReference{Resource}, FItemList.Link)){3};
end;

function TFhirClinicalImpressionInvestigations.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClinicalImpressionInvestigations.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else inherited;
end;

function TFhirClinicalImpressionInvestigations.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'item') then result := ItemList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClinicalImpressionInvestigations.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'item') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClinicalImpressionInvestigations.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'item') then deletePropertyValue('item', ItemList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClinicalImpressionInvestigations.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClinicalImpressionInvestigations.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'item') then ItemList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClinicalImpressionInvestigations.fhirType : string;
begin
  result := 'investigations';
end;

function TFhirClinicalImpressionInvestigations.Link : TFhirClinicalImpressionInvestigations;
begin
  result := TFhirClinicalImpressionInvestigations(inherited Link);
end;

function TFhirClinicalImpressionInvestigations.Clone : TFhirClinicalImpressionInvestigations;
begin
  result := TFhirClinicalImpressionInvestigations(inherited Clone);
end;

function TFhirClinicalImpressionInvestigations.equals(other : TObject) : boolean;
var
  o : TFhirClinicalImpressionInvestigations;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClinicalImpressionInvestigations)) then
    result := false
  else
  begin
    o := TFhirClinicalImpressionInvestigations(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(itemList, o.itemList, true);
  end;
end;

function TFhirClinicalImpressionInvestigations.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FitemList);
end;

procedure TFhirClinicalImpressionInvestigations.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('item');
end;

{ TFhirClinicalImpressionInvestigations }

Procedure TFhirClinicalImpressionInvestigations.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirClinicalImpressionInvestigations.GetItemList : TFhirReferenceList{Resource};
begin
  if FItemList = nil then
    FItemList := TFhirReferenceList{Resource}.Create;
  result := FItemList;
end;

Function TFhirClinicalImpressionInvestigations.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

function TFhirClinicalImpressionInvestigations.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FitemList.sizeInBytes);
end;

{ TFhirClinicalImpressionInvestigationsListEnumerator }

Constructor TFhirClinicalImpressionInvestigationsListEnumerator.Create(list : TFhirClinicalImpressionInvestigationsList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClinicalImpressionInvestigationsListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClinicalImpressionInvestigationsListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClinicalImpressionInvestigationsListEnumerator.GetCurrent : TFhirClinicalImpressionInvestigations;
begin
  Result := FList[FIndex];
end;

function TFhirClinicalImpressionInvestigationsListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClinicalImpressionInvestigationsList }
procedure TFhirClinicalImpressionInvestigationsList.AddItem(value: TFhirClinicalImpressionInvestigations);
begin
  assert(value.ClassName = 'TFhirClinicalImpressionInvestigations', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClinicalImpressionInvestigations');
  add(value);
end;

function TFhirClinicalImpressionInvestigationsList.Append: TFhirClinicalImpressionInvestigations;
begin
  result := TFhirClinicalImpressionInvestigations.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalImpressionInvestigationsList.ClearItems;
begin
  Clear;
end;

function TFhirClinicalImpressionInvestigationsList.GetEnumerator : TFhirClinicalImpressionInvestigationsListEnumerator;
begin
  result := TFhirClinicalImpressionInvestigationsListEnumerator.Create(self.link);
end;

function TFhirClinicalImpressionInvestigationsList.Clone: TFhirClinicalImpressionInvestigationsList;
begin
  result := TFhirClinicalImpressionInvestigationsList(inherited Clone);
end;

function TFhirClinicalImpressionInvestigationsList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClinicalImpressionInvestigationsList.GetItemN(index: Integer): TFhirClinicalImpressionInvestigations;
begin
  result := TFhirClinicalImpressionInvestigations(ObjectByIndex[index]);
end;

function TFhirClinicalImpressionInvestigationsList.ItemClass: TFslObjectClass;
begin
  result := TFhirClinicalImpressionInvestigations;
end;
function TFhirClinicalImpressionInvestigationsList.IndexOf(value: TFhirClinicalImpressionInvestigations): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClinicalImpressionInvestigationsList.Insert(index: Integer): TFhirClinicalImpressionInvestigations;
begin
  result := TFhirClinicalImpressionInvestigations.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalImpressionInvestigationsList.InsertItem(index: Integer; value: TFhirClinicalImpressionInvestigations);
begin
  assert(value is TFhirClinicalImpressionInvestigations);
  Inherited Insert(index, value);
end;

function TFhirClinicalImpressionInvestigationsList.Item(index: Integer): TFhirClinicalImpressionInvestigations;
begin
  result := TFhirClinicalImpressionInvestigations(ObjectByIndex[index]);
end;

function TFhirClinicalImpressionInvestigationsList.Link: TFhirClinicalImpressionInvestigationsList;
begin
  result := TFhirClinicalImpressionInvestigationsList(inherited Link);
end;

procedure TFhirClinicalImpressionInvestigationsList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClinicalImpressionInvestigationsList.SetItemByIndex(index: Integer; value: TFhirClinicalImpressionInvestigations);
begin
  assert(value is TFhirClinicalImpressionInvestigations);
  FhirClinicalImpressionInvestigations[index] := value;
end;

procedure TFhirClinicalImpressionInvestigationsList.SetItemN(index: Integer; value: TFhirClinicalImpressionInvestigations);
begin
  assert(value is TFhirClinicalImpressionInvestigations);
  ObjectByIndex[index] := value;
end;

{ TFhirClinicalImpressionFinding }

constructor TFhirClinicalImpressionFinding.Create;
begin
  inherited;
end;

destructor TFhirClinicalImpressionFinding.Destroy;
begin
  FItem.free;
  FCause.free;
  inherited;
end;

procedure TFhirClinicalImpressionFinding.Assign(oSource : TFslObject);
begin
  inherited;
  item := TFhirClinicalImpressionFinding(oSource).item.Clone;
  causeElement := TFhirClinicalImpressionFinding(oSource).causeElement.Clone;
end;

procedure TFhirClinicalImpressionFinding.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'item') Then
     list.add(self.link, 'item', FItem.Link);
  if (child_name = 'cause') Then
     list.add(self.link, 'cause', FCause.Link);
end;

procedure TFhirClinicalImpressionFinding.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'item', 'CodeableConcept', false, TFhirCodeableConcept, FItem.Link));{2}
  oList.add(TFHIRProperty.create(self, 'cause', 'string', false, TFhirString, FCause.Link));{2}
end;

function TFhirClinicalImpressionFinding.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'item') then
  begin
    Item := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'cause') then
  begin
    CauseElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClinicalImpressionFinding.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClinicalImpressionFinding.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'item') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'cause') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClinicalImpressionFinding.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'item') then result := 'CodeableConcept'
  else if (propName = 'cause') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClinicalImpressionFinding.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'item') then ItemElement := nil
  else if (propName = 'cause') then CauseElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClinicalImpressionFinding.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'item') then ItemElement := new as TFhirCodeableConcept{4}
  else if (propName = 'cause') then CauseElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClinicalImpressionFinding.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClinicalImpressionFinding.fhirType : string;
begin
  result := 'finding';
end;

function TFhirClinicalImpressionFinding.Link : TFhirClinicalImpressionFinding;
begin
  result := TFhirClinicalImpressionFinding(inherited Link);
end;

function TFhirClinicalImpressionFinding.Clone : TFhirClinicalImpressionFinding;
begin
  result := TFhirClinicalImpressionFinding(inherited Clone);
end;

function TFhirClinicalImpressionFinding.equals(other : TObject) : boolean;
var
  o : TFhirClinicalImpressionFinding;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClinicalImpressionFinding)) then
    result := false
  else
  begin
    o := TFhirClinicalImpressionFinding(other);
    result := compareDeep(itemElement, o.itemElement, true) and compareDeep(causeElement, o.causeElement, true);
  end;
end;

function TFhirClinicalImpressionFinding.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FItem) and isEmptyProp(FCause);
end;

procedure TFhirClinicalImpressionFinding.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('item');
  fields.add('cause');
end;

{ TFhirClinicalImpressionFinding }

Procedure TFhirClinicalImpressionFinding.SetItem(value : TFhirCodeableConcept);
begin
  FItem.free;
  FItem := value;
end;

Procedure TFhirClinicalImpressionFinding.SetCause(value : TFhirString);
begin
  FCause.free;
  FCause := value;
end;

Function TFhirClinicalImpressionFinding.GetCauseST : String;
begin
  if FCause = nil then
    result := ''
  else
    result := FCause.value;
end;

Procedure TFhirClinicalImpressionFinding.SetCauseST(value : String);
begin
  if value <> '' then
  begin
    if FCause = nil then
      FCause := TFhirString.create;
    FCause.value := value
  end
  else if FCause <> nil then
    FCause.value := '';
end;

function TFhirClinicalImpressionFinding.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FItem.sizeInBytes);
  inc(result, FCause.sizeInBytes);
end;

{ TFhirClinicalImpressionFindingListEnumerator }

Constructor TFhirClinicalImpressionFindingListEnumerator.Create(list : TFhirClinicalImpressionFindingList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClinicalImpressionFindingListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClinicalImpressionFindingListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClinicalImpressionFindingListEnumerator.GetCurrent : TFhirClinicalImpressionFinding;
begin
  Result := FList[FIndex];
end;

function TFhirClinicalImpressionFindingListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClinicalImpressionFindingList }
procedure TFhirClinicalImpressionFindingList.AddItem(value: TFhirClinicalImpressionFinding);
begin
  assert(value.ClassName = 'TFhirClinicalImpressionFinding', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClinicalImpressionFinding');
  add(value);
end;

function TFhirClinicalImpressionFindingList.Append: TFhirClinicalImpressionFinding;
begin
  result := TFhirClinicalImpressionFinding.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalImpressionFindingList.ClearItems;
begin
  Clear;
end;

function TFhirClinicalImpressionFindingList.GetEnumerator : TFhirClinicalImpressionFindingListEnumerator;
begin
  result := TFhirClinicalImpressionFindingListEnumerator.Create(self.link);
end;

function TFhirClinicalImpressionFindingList.Clone: TFhirClinicalImpressionFindingList;
begin
  result := TFhirClinicalImpressionFindingList(inherited Clone);
end;

function TFhirClinicalImpressionFindingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClinicalImpressionFindingList.GetItemN(index: Integer): TFhirClinicalImpressionFinding;
begin
  result := TFhirClinicalImpressionFinding(ObjectByIndex[index]);
end;

function TFhirClinicalImpressionFindingList.ItemClass: TFslObjectClass;
begin
  result := TFhirClinicalImpressionFinding;
end;
function TFhirClinicalImpressionFindingList.IndexOf(value: TFhirClinicalImpressionFinding): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClinicalImpressionFindingList.Insert(index: Integer): TFhirClinicalImpressionFinding;
begin
  result := TFhirClinicalImpressionFinding.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalImpressionFindingList.InsertItem(index: Integer; value: TFhirClinicalImpressionFinding);
begin
  assert(value is TFhirClinicalImpressionFinding);
  Inherited Insert(index, value);
end;

function TFhirClinicalImpressionFindingList.Item(index: Integer): TFhirClinicalImpressionFinding;
begin
  result := TFhirClinicalImpressionFinding(ObjectByIndex[index]);
end;

function TFhirClinicalImpressionFindingList.Link: TFhirClinicalImpressionFindingList;
begin
  result := TFhirClinicalImpressionFindingList(inherited Link);
end;

procedure TFhirClinicalImpressionFindingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClinicalImpressionFindingList.SetItemByIndex(index: Integer; value: TFhirClinicalImpressionFinding);
begin
  assert(value is TFhirClinicalImpressionFinding);
  FhirClinicalImpressionFindings[index] := value;
end;

procedure TFhirClinicalImpressionFindingList.SetItemN(index: Integer; value: TFhirClinicalImpressionFinding);
begin
  assert(value is TFhirClinicalImpressionFinding);
  ObjectByIndex[index] := value;
end;

{ TFhirClinicalImpressionRuledOut }

constructor TFhirClinicalImpressionRuledOut.Create;
begin
  inherited;
end;

destructor TFhirClinicalImpressionRuledOut.Destroy;
begin
  FItem.free;
  FReason.free;
  inherited;
end;

procedure TFhirClinicalImpressionRuledOut.Assign(oSource : TFslObject);
begin
  inherited;
  item := TFhirClinicalImpressionRuledOut(oSource).item.Clone;
  reasonElement := TFhirClinicalImpressionRuledOut(oSource).reasonElement.Clone;
end;

procedure TFhirClinicalImpressionRuledOut.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'item') Then
     list.add(self.link, 'item', FItem.Link);
  if (child_name = 'reason') Then
     list.add(self.link, 'reason', FReason.Link);
end;

procedure TFhirClinicalImpressionRuledOut.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'item', 'CodeableConcept', false, TFhirCodeableConcept, FItem.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason', 'string', false, TFhirString, FReason.Link));{2}
end;

function TFhirClinicalImpressionRuledOut.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'item') then
  begin
    Item := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClinicalImpressionRuledOut.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClinicalImpressionRuledOut.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'item') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'reason') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClinicalImpressionRuledOut.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'item') then result := 'CodeableConcept'
  else if (propName = 'reason') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClinicalImpressionRuledOut.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'item') then ItemElement := nil
  else if (propName = 'reason') then ReasonElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClinicalImpressionRuledOut.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'item') then ItemElement := new as TFhirCodeableConcept{4}
  else if (propName = 'reason') then ReasonElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClinicalImpressionRuledOut.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClinicalImpressionRuledOut.fhirType : string;
begin
  result := 'ruledOut';
end;

function TFhirClinicalImpressionRuledOut.Link : TFhirClinicalImpressionRuledOut;
begin
  result := TFhirClinicalImpressionRuledOut(inherited Link);
end;

function TFhirClinicalImpressionRuledOut.Clone : TFhirClinicalImpressionRuledOut;
begin
  result := TFhirClinicalImpressionRuledOut(inherited Clone);
end;

function TFhirClinicalImpressionRuledOut.equals(other : TObject) : boolean;
var
  o : TFhirClinicalImpressionRuledOut;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClinicalImpressionRuledOut)) then
    result := false
  else
  begin
    o := TFhirClinicalImpressionRuledOut(other);
    result := compareDeep(itemElement, o.itemElement, true) and compareDeep(reasonElement, o.reasonElement, true);
  end;
end;

function TFhirClinicalImpressionRuledOut.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FItem) and isEmptyProp(FReason);
end;

procedure TFhirClinicalImpressionRuledOut.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('item');
  fields.add('reason');
end;

{ TFhirClinicalImpressionRuledOut }

Procedure TFhirClinicalImpressionRuledOut.SetItem(value : TFhirCodeableConcept);
begin
  FItem.free;
  FItem := value;
end;

Procedure TFhirClinicalImpressionRuledOut.SetReason(value : TFhirString);
begin
  FReason.free;
  FReason := value;
end;

Function TFhirClinicalImpressionRuledOut.GetReasonST : String;
begin
  if FReason = nil then
    result := ''
  else
    result := FReason.value;
end;

Procedure TFhirClinicalImpressionRuledOut.SetReasonST(value : String);
begin
  if value <> '' then
  begin
    if FReason = nil then
      FReason := TFhirString.create;
    FReason.value := value
  end
  else if FReason <> nil then
    FReason.value := '';
end;

function TFhirClinicalImpressionRuledOut.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FItem.sizeInBytes);
  inc(result, FReason.sizeInBytes);
end;

{ TFhirClinicalImpressionRuledOutListEnumerator }

Constructor TFhirClinicalImpressionRuledOutListEnumerator.Create(list : TFhirClinicalImpressionRuledOutList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClinicalImpressionRuledOutListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClinicalImpressionRuledOutListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClinicalImpressionRuledOutListEnumerator.GetCurrent : TFhirClinicalImpressionRuledOut;
begin
  Result := FList[FIndex];
end;

function TFhirClinicalImpressionRuledOutListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClinicalImpressionRuledOutList }
procedure TFhirClinicalImpressionRuledOutList.AddItem(value: TFhirClinicalImpressionRuledOut);
begin
  assert(value.ClassName = 'TFhirClinicalImpressionRuledOut', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClinicalImpressionRuledOut');
  add(value);
end;

function TFhirClinicalImpressionRuledOutList.Append: TFhirClinicalImpressionRuledOut;
begin
  result := TFhirClinicalImpressionRuledOut.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalImpressionRuledOutList.ClearItems;
begin
  Clear;
end;

function TFhirClinicalImpressionRuledOutList.GetEnumerator : TFhirClinicalImpressionRuledOutListEnumerator;
begin
  result := TFhirClinicalImpressionRuledOutListEnumerator.Create(self.link);
end;

function TFhirClinicalImpressionRuledOutList.Clone: TFhirClinicalImpressionRuledOutList;
begin
  result := TFhirClinicalImpressionRuledOutList(inherited Clone);
end;

function TFhirClinicalImpressionRuledOutList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClinicalImpressionRuledOutList.GetItemN(index: Integer): TFhirClinicalImpressionRuledOut;
begin
  result := TFhirClinicalImpressionRuledOut(ObjectByIndex[index]);
end;

function TFhirClinicalImpressionRuledOutList.ItemClass: TFslObjectClass;
begin
  result := TFhirClinicalImpressionRuledOut;
end;
function TFhirClinicalImpressionRuledOutList.IndexOf(value: TFhirClinicalImpressionRuledOut): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClinicalImpressionRuledOutList.Insert(index: Integer): TFhirClinicalImpressionRuledOut;
begin
  result := TFhirClinicalImpressionRuledOut.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalImpressionRuledOutList.InsertItem(index: Integer; value: TFhirClinicalImpressionRuledOut);
begin
  assert(value is TFhirClinicalImpressionRuledOut);
  Inherited Insert(index, value);
end;

function TFhirClinicalImpressionRuledOutList.Item(index: Integer): TFhirClinicalImpressionRuledOut;
begin
  result := TFhirClinicalImpressionRuledOut(ObjectByIndex[index]);
end;

function TFhirClinicalImpressionRuledOutList.Link: TFhirClinicalImpressionRuledOutList;
begin
  result := TFhirClinicalImpressionRuledOutList(inherited Link);
end;

procedure TFhirClinicalImpressionRuledOutList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClinicalImpressionRuledOutList.SetItemByIndex(index: Integer; value: TFhirClinicalImpressionRuledOut);
begin
  assert(value is TFhirClinicalImpressionRuledOut);
  FhirClinicalImpressionRuledOuts[index] := value;
end;

procedure TFhirClinicalImpressionRuledOutList.SetItemN(index: Integer; value: TFhirClinicalImpressionRuledOut);
begin
  assert(value is TFhirClinicalImpressionRuledOut);
  ObjectByIndex[index] := value;
end;

{ TFhirClinicalImpression }

constructor TFhirClinicalImpression.Create;
begin
  inherited;
end;

destructor TFhirClinicalImpression.Destroy;
begin
  FPatient.free;
  FAssessor.free;
  FStatus.free;
  FDate.free;
  FDescription.free;
  FPrevious.free;
  FProblemList.Free;
  FTrigger.free;
  FInvestigationsList.Free;
  FProtocol.free;
  FSummary.free;
  FFindingList.Free;
  FResolvedList.Free;
  FRuledOutList.Free;
  FPrognosis.free;
  FPlanList.Free;
  FActionList.Free;
  inherited;
end;

function TFhirClinicalImpression.GetResourceType : TFhirResourceType;
begin
  result := frtClinicalImpression;
end;

procedure TFhirClinicalImpression.Assign(oSource : TFslObject);
begin
  inherited;
  patient := TFhirClinicalImpression(oSource).patient.Clone;
  assessor := TFhirClinicalImpression(oSource).assessor.Clone;
  FStatus := TFhirClinicalImpression(oSource).FStatus.Link;
  dateElement := TFhirClinicalImpression(oSource).dateElement.Clone;
  descriptionElement := TFhirClinicalImpression(oSource).descriptionElement.Clone;
  previous := TFhirClinicalImpression(oSource).previous.Clone;
  if (TFhirClinicalImpression(oSource).FProblemList = nil) then
  begin
    FProblemList.free;
    FProblemList := nil;
  end
  else
  begin
    if FProblemList = nil then
      FProblemList := TFhirReferenceList{Resource}.Create;
    FProblemList.Assign(TFhirClinicalImpression(oSource).FProblemList);
  end;
  trigger := TFhirClinicalImpression(oSource).trigger.Clone;
  if (TFhirClinicalImpression(oSource).FInvestigationsList = nil) then
  begin
    FInvestigationsList.free;
    FInvestigationsList := nil;
  end
  else
  begin
    if FInvestigationsList = nil then
      FInvestigationsList := TFhirClinicalImpressionInvestigationsList.Create;
    FInvestigationsList.Assign(TFhirClinicalImpression(oSource).FInvestigationsList);
  end;
  protocolElement := TFhirClinicalImpression(oSource).protocolElement.Clone;
  summaryElement := TFhirClinicalImpression(oSource).summaryElement.Clone;
  if (TFhirClinicalImpression(oSource).FFindingList = nil) then
  begin
    FFindingList.free;
    FFindingList := nil;
  end
  else
  begin
    if FFindingList = nil then
      FFindingList := TFhirClinicalImpressionFindingList.Create;
    FFindingList.Assign(TFhirClinicalImpression(oSource).FFindingList);
  end;
  if (TFhirClinicalImpression(oSource).FResolvedList = nil) then
  begin
    FResolvedList.free;
    FResolvedList := nil;
  end
  else
  begin
    if FResolvedList = nil then
      FResolvedList := TFhirCodeableConceptList.Create;
    FResolvedList.Assign(TFhirClinicalImpression(oSource).FResolvedList);
  end;
  if (TFhirClinicalImpression(oSource).FRuledOutList = nil) then
  begin
    FRuledOutList.free;
    FRuledOutList := nil;
  end
  else
  begin
    if FRuledOutList = nil then
      FRuledOutList := TFhirClinicalImpressionRuledOutList.Create;
    FRuledOutList.Assign(TFhirClinicalImpression(oSource).FRuledOutList);
  end;
  prognosisElement := TFhirClinicalImpression(oSource).prognosisElement.Clone;
  if (TFhirClinicalImpression(oSource).FPlanList = nil) then
  begin
    FPlanList.free;
    FPlanList := nil;
  end
  else
  begin
    if FPlanList = nil then
      FPlanList := TFhirReferenceList{Resource}.Create;
    FPlanList.Assign(TFhirClinicalImpression(oSource).FPlanList);
  end;
  if (TFhirClinicalImpression(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirReferenceList{Resource}.Create;
    FActionList.Assign(TFhirClinicalImpression(oSource).FActionList);
  end;
end;

procedure TFhirClinicalImpression.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'assessor') Then
     list.add(self.link, 'assessor', FAssessor.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'previous') Then
     list.add(self.link, 'previous', FPrevious.Link);
  if (child_name = 'problem') Then
    list.addAll(self, 'problem', FProblemList);
  if (child_name = 'trigger[x]') or (child_name = 'trigger') Then
     list.add(self.link, 'trigger[x]', FTrigger.Link);
  if (child_name = 'investigations') Then
    list.addAll(self, 'investigations', FInvestigationsList);
  if (child_name = 'protocol') Then
     list.add(self.link, 'protocol', FProtocol.Link);
  if (child_name = 'summary') Then
     list.add(self.link, 'summary', FSummary.Link);
  if (child_name = 'finding') Then
    list.addAll(self, 'finding', FFindingList);
  if (child_name = 'resolved') Then
    list.addAll(self, 'resolved', FResolvedList);
  if (child_name = 'ruledOut') Then
    list.addAll(self, 'ruledOut', FRuledOutList);
  if (child_name = 'prognosis') Then
     list.add(self.link, 'prognosis', FPrognosis.Link);
  if (child_name = 'plan') Then
    list.addAll(self, 'plan', FPlanList);
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
end;

procedure TFhirClinicalImpression.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'assessor', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FAssessor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'previous', 'Reference(ClinicalImpression)', false, TFhirReference{TFhirClinicalImpression}, FPrevious.Link));{2}
  oList.add(TFHIRProperty.create(self, 'problem', 'Reference(Condition|AllergyIntolerance)', true, TFhirReference{Resource}, FProblemList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'trigger[x]', 'CodeableConcept|Reference(Any)', false, TFhirType, FTrigger.Link));{2}
  oList.add(TFHIRProperty.create(self, 'investigations', '', true, TFhirClinicalImpressionInvestigations, FInvestigationsList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'protocol', 'uri', false, TFhirUri, FProtocol.Link));{2}
  oList.add(TFHIRProperty.create(self, 'summary', 'string', false, TFhirString, FSummary.Link));{2}
  oList.add(TFHIRProperty.create(self, 'finding', '', true, TFhirClinicalImpressionFinding, FFindingList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'resolved', 'CodeableConcept', true, TFhirCodeableConcept, FResolvedList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'ruledOut', '', true, TFhirClinicalImpressionRuledOut, FRuledOutList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'prognosis', 'string', false, TFhirString, FPrognosis.Link));{2}
  oList.add(TFHIRProperty.create(self, 'plan', 'Reference(CarePlan|Appointment|CommunicationRequest|DeviceUseRequest|DiagnosticOrder|MedicationOrder|NutritionOrder|Order|ProcedureRequest|ProcessRequest|ReferralRequest|SupplyRequest|VisionPrescription)', true, TFhirReference{Resource}, FPlanList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'action', 'Reference(ReferralRequest|ProcedureRequest|Procedure|MedicationOrder|DiagnosticOrder|NutritionOrder|SupplyRequest|Appointment)', true, TFhirReference{Resource}, FActionList.Link)){3};
end;

function TFhirClinicalImpression.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'assessor') then
  begin
    Assessor := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirClinicalImpressionStatusEnum, CODES_TFhirClinicalImpressionStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'previous') then
  begin
    Previous := propValue as TFhirReference{TFhirClinicalImpression}{4b};
    result := propValue;
  end
  else if (propName = 'problem') then
  begin
    ProblemList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'trigger', ['CodeableConcept', 'Reference'])) then
  begin
    Trigger := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'investigations') then
  begin
    InvestigationsList.add(propValue as TFhirClinicalImpressionInvestigations){2a};
    result := propValue;
  end
  else if (propName = 'protocol') then
  begin
    ProtocolElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'summary') then
  begin
    SummaryElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'finding') then
  begin
    FindingList.add(propValue as TFhirClinicalImpressionFinding){2a};
    result := propValue;
  end
  else if (propName = 'resolved') then
  begin
    ResolvedList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'ruledOut') then
  begin
    RuledOutList.add(propValue as TFhirClinicalImpressionRuledOut){2a};
    result := propValue;
  end
  else if (propName = 'prognosis') then
  begin
    PrognosisElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'plan') then
  begin
    PlanList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirClinicalImpression.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'problem') then ProblemList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'investigations') then InvestigationsList.insertItem(index, propValue as TFhirClinicalImpressionInvestigations){2a}
  else if (propName = 'finding') then FindingList.insertItem(index, propValue as TFhirClinicalImpressionFinding){2a}
  else if (propName = 'resolved') then ResolvedList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'ruledOut') then RuledOutList.insertItem(index, propValue as TFhirClinicalImpressionRuledOut){2a}
  else if (propName = 'plan') then PlanList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else inherited;
end;

function TFhirClinicalImpression.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'assessor') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'previous') then result := TFhirReference{TFhirClinicalImpression}.create(){4b}
  else if (propName = 'problem') then result := ProblemList.new(){2}
  else if (isMatchingName(propName, 'trigger', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Trigger'){4x}
  else if (propName = 'investigations') then result := InvestigationsList.new(){2}
  else if (propName = 'protocol') then result := TFhirUri.create() {5b}
  else if (propName = 'summary') then result := TFhirString.create() {5b}
  else if (propName = 'finding') then result := FindingList.new(){2}
  else if (propName = 'resolved') then result := ResolvedList.new(){2}
  else if (propName = 'ruledOut') then result := RuledOutList.new(){2}
  else if (propName = 'prognosis') then result := TFhirString.create() {5b}
  else if (propName = 'plan') then result := PlanList.new(){2}
  else if (propName = 'action') then result := ActionList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClinicalImpression.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'patient') then result := 'Reference'
  else if (propName = 'assessor') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'previous') then result := 'Reference'
  else if (propName = 'problem') then result := 'Reference'
  else if (propName = 'trigger[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'investigations') then result := ''
  else if (propName = 'protocol') then result := 'uri'
  else if (propName = 'summary') then result := 'string'
  else if (propName = 'finding') then result := ''
  else if (propName = 'resolved') then result := 'CodeableConcept'
  else if (propName = 'ruledOut') then result := ''
  else if (propName = 'prognosis') then result := 'string'
  else if (propName = 'plan') then result := 'Reference'
  else if (propName = 'action') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClinicalImpression.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'patient') then PatientElement := nil
  else if (propName = 'assessor') then AssessorElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'previous') then PreviousElement := nil
  else if (propName = 'problem') then deletePropertyValue('problem', ProblemList, value) {2}
  else if (isMatchingName(propName, 'trigger', ['CodeableConcept', 'Reference'])) then TriggerElement := nil{4x}
  else if (propName = 'investigations') then deletePropertyValue('investigations', InvestigationsList, value) {2}
  else if (propName = 'protocol') then ProtocolElement := nil
  else if (propName = 'summary') then SummaryElement := nil
  else if (propName = 'finding') then deletePropertyValue('finding', FindingList, value) {2}
  else if (propName = 'resolved') then deletePropertyValue('resolved', ResolvedList, value) {2}
  else if (propName = 'ruledOut') then deletePropertyValue('ruledOut', RuledOutList, value) {2}
  else if (propName = 'prognosis') then PrognosisElement := nil
  else if (propName = 'plan') then deletePropertyValue('plan', PlanList, value) {2}
  else if (propName = 'action') then deletePropertyValue('action', ActionList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClinicalImpression.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'assessor') then AssessorElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirClinicalImpressionStatusEnum, CODES_TFhirClinicalImpressionStatusEnum, new){4}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'previous') then PreviousElement := new as TFhirReference{TFhirClinicalImpression}{4}
  else if (propName = 'problem') then replacePropertyValue('problem', ProblemList, existing, new) {2}
  else if (isMatchingName(propName, 'trigger', ['CodeableConcept', 'Reference'])) then TriggerElement := new as TFhirType{4x}
  else if (propName = 'investigations') then replacePropertyValue('investigations', InvestigationsList, existing, new) {2}
  else if (propName = 'protocol') then ProtocolElement := asUri(new){5b}
  else if (propName = 'summary') then SummaryElement := asString(new){5b}
  else if (propName = 'finding') then replacePropertyValue('finding', FindingList, existing, new) {2}
  else if (propName = 'resolved') then replacePropertyValue('resolved', ResolvedList, existing, new) {2}
  else if (propName = 'ruledOut') then replacePropertyValue('ruledOut', RuledOutList, existing, new) {2}
  else if (propName = 'prognosis') then PrognosisElement := asString(new){5b}
  else if (propName = 'plan') then replacePropertyValue('plan', PlanList, existing, new) {2}
  else if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClinicalImpression.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'problem') then ProblemList.move(source, destination){2a}
  else if (propName = 'investigations') then InvestigationsList.move(source, destination){2a}
  else if (propName = 'finding') then FindingList.move(source, destination){2a}
  else if (propName = 'resolved') then ResolvedList.move(source, destination){2a}
  else if (propName = 'ruledOut') then RuledOutList.move(source, destination){2a}
  else if (propName = 'plan') then PlanList.move(source, destination){2a}
  else if (propName = 'action') then ActionList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClinicalImpression.fhirType : string;
begin
  result := 'ClinicalImpression';
end;

function TFhirClinicalImpression.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPatient) and isEmptyProp(FAssessor) and isEmptyProp(FStatus) and isEmptyProp(FDate) and isEmptyProp(FDescription) and isEmptyProp(FPrevious) and isEmptyProp(FproblemList) and isEmptyProp(FTrigger) and isEmptyProp(FinvestigationsList) and isEmptyProp(FProtocol) and isEmptyProp(FSummary) and isEmptyProp(FfindingList) and isEmptyProp(FresolvedList) and isEmptyProp(FruledOutList) and isEmptyProp(FPrognosis) and isEmptyProp(FplanList) and isEmptyProp(FactionList);
end;

function TFhirClinicalImpression.equals(other : TObject) : boolean;
var
  o : TFhirClinicalImpression;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClinicalImpression)) then
    result := false
  else
  begin
    o := TFhirClinicalImpression(other);
    result := compareDeep(patientElement, o.patientElement, true) and compareDeep(assessorElement, o.assessorElement, true) and
      compareDeep(statusElement, o.statusElement, true) and compareDeep(dateElement, o.dateElement, true) and
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(previousElement, o.previousElement, true) and
      compareDeep(problemList, o.problemList, true) and compareDeep(triggerElement, o.triggerElement, true) and
      compareDeep(investigationsList, o.investigationsList, true) and compareDeep(protocolElement, o.protocolElement, true) and
      compareDeep(summaryElement, o.summaryElement, true) and compareDeep(findingList, o.findingList, true) and
      compareDeep(resolvedList, o.resolvedList, true) and compareDeep(ruledOutList, o.ruledOutList, true) and
      compareDeep(prognosisElement, o.prognosisElement, true) and compareDeep(planList, o.planList, true) and
      compareDeep(actionList, o.actionList, true);
  end;
end;

function TFhirClinicalImpression.Link : TFhirClinicalImpression;
begin
  result := TFhirClinicalImpression(inherited Link);
end;

function TFhirClinicalImpression.Clone : TFhirClinicalImpression;
begin
  result := TFhirClinicalImpression(inherited Clone);
end;

procedure TFhirClinicalImpression.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('patient');
  fields.add('assessor');
  fields.add('status');
  fields.add('date');
  fields.add('description');
  fields.add('previous');
  fields.add('problem');
  fields.add('trigger[x]');
  fields.add('investigations');
  fields.add('protocol');
  fields.add('summary');
  fields.add('finding');
  fields.add('resolved');
  fields.add('ruledOut');
  fields.add('prognosis');
  fields.add('plan');
  fields.add('action');
end;

{ TFhirClinicalImpression }

Procedure TFhirClinicalImpression.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Procedure TFhirClinicalImpression.SetAssessor(value : TFhirReference{TFhirPractitioner});
begin
  FAssessor.free;
  FAssessor := value;
end;

Procedure TFhirClinicalImpression.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirClinicalImpression.GetStatusST : TFhirClinicalImpressionStatusEnum;
begin
  if FStatus = nil then
    result := TFhirClinicalImpressionStatusEnum(0)
  else
    result := TFhirClinicalImpressionStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirClinicalImpressionStatusEnum, FStatus.value));
end;

Procedure TFhirClinicalImpression.SetStatusST(value : TFhirClinicalImpressionStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirClinicalImpressionStatusEnum[value], CODES_TFhirClinicalImpressionStatusEnum[value]);
end;

Procedure TFhirClinicalImpression.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirClinicalImpression.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirClinicalImpression.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirClinicalImpression.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirClinicalImpression.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirClinicalImpression.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirClinicalImpression.SetPrevious(value : TFhirReference{TFhirClinicalImpression});
begin
  FPrevious.free;
  FPrevious := value;
end;

Function TFhirClinicalImpression.GetProblemList : TFhirReferenceList{Resource};
begin
  if FProblemList = nil then
    FProblemList := TFhirReferenceList{Resource}.Create;
  result := FProblemList;
end;

Function TFhirClinicalImpression.GetHasProblemList : boolean;
begin
  result := (FProblemList <> nil) and (FProblemList.count > 0);
end;

Procedure TFhirClinicalImpression.SetTrigger(value : TFhirType);
begin
  FTrigger.free;
  FTrigger := value;
end;

Function TFhirClinicalImpression.GetInvestigationsList : TFhirClinicalImpressionInvestigationsList;
begin
  if FInvestigationsList = nil then
    FInvestigationsList := TFhirClinicalImpressionInvestigationsList.Create;
  result := FInvestigationsList;
end;

Function TFhirClinicalImpression.GetHasInvestigationsList : boolean;
begin
  result := (FInvestigationsList <> nil) and (FInvestigationsList.count > 0);
end;

Procedure TFhirClinicalImpression.SetProtocol(value : TFhirUri);
begin
  FProtocol.free;
  FProtocol := value;
end;

Function TFhirClinicalImpression.GetProtocolST : String;
begin
  if FProtocol = nil then
    result := ''
  else
    result := FProtocol.value;
end;

Procedure TFhirClinicalImpression.SetProtocolST(value : String);
begin
  if value <> '' then
  begin
    if FProtocol = nil then
      FProtocol := TFhirUri.create;
    FProtocol.value := value
  end
  else if FProtocol <> nil then
    FProtocol.value := '';
end;

Procedure TFhirClinicalImpression.SetSummary(value : TFhirString);
begin
  FSummary.free;
  FSummary := value;
end;

Function TFhirClinicalImpression.GetSummaryST : String;
begin
  if FSummary = nil then
    result := ''
  else
    result := FSummary.value;
end;

Procedure TFhirClinicalImpression.SetSummaryST(value : String);
begin
  if value <> '' then
  begin
    if FSummary = nil then
      FSummary := TFhirString.create;
    FSummary.value := value
  end
  else if FSummary <> nil then
    FSummary.value := '';
end;

Function TFhirClinicalImpression.GetFindingList : TFhirClinicalImpressionFindingList;
begin
  if FFindingList = nil then
    FFindingList := TFhirClinicalImpressionFindingList.Create;
  result := FFindingList;
end;

Function TFhirClinicalImpression.GetHasFindingList : boolean;
begin
  result := (FFindingList <> nil) and (FFindingList.count > 0);
end;

Function TFhirClinicalImpression.GetResolvedList : TFhirCodeableConceptList;
begin
  if FResolvedList = nil then
    FResolvedList := TFhirCodeableConceptList.Create;
  result := FResolvedList;
end;

Function TFhirClinicalImpression.GetHasResolvedList : boolean;
begin
  result := (FResolvedList <> nil) and (FResolvedList.count > 0);
end;

Function TFhirClinicalImpression.GetRuledOutList : TFhirClinicalImpressionRuledOutList;
begin
  if FRuledOutList = nil then
    FRuledOutList := TFhirClinicalImpressionRuledOutList.Create;
  result := FRuledOutList;
end;

Function TFhirClinicalImpression.GetHasRuledOutList : boolean;
begin
  result := (FRuledOutList <> nil) and (FRuledOutList.count > 0);
end;

Procedure TFhirClinicalImpression.SetPrognosis(value : TFhirString);
begin
  FPrognosis.free;
  FPrognosis := value;
end;

Function TFhirClinicalImpression.GetPrognosisST : String;
begin
  if FPrognosis = nil then
    result := ''
  else
    result := FPrognosis.value;
end;

Procedure TFhirClinicalImpression.SetPrognosisST(value : String);
begin
  if value <> '' then
  begin
    if FPrognosis = nil then
      FPrognosis := TFhirString.create;
    FPrognosis.value := value
  end
  else if FPrognosis <> nil then
    FPrognosis.value := '';
end;

Function TFhirClinicalImpression.GetPlanList : TFhirReferenceList{Resource};
begin
  if FPlanList = nil then
    FPlanList := TFhirReferenceList{Resource}.Create;
  result := FPlanList;
end;

Function TFhirClinicalImpression.GetHasPlanList : boolean;
begin
  result := (FPlanList <> nil) and (FPlanList.count > 0);
end;

Function TFhirClinicalImpression.GetActionList : TFhirReferenceList{Resource};
begin
  if FActionList = nil then
    FActionList := TFhirReferenceList{Resource}.Create;
  result := FActionList;
end;

Function TFhirClinicalImpression.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

function TFhirClinicalImpression.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FPatient.sizeInBytes);
  inc(result, FAssessor.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FPrevious.sizeInBytes);
  inc(result, FproblemList.sizeInBytes);
  inc(result, FTrigger.sizeInBytes);
  inc(result, FinvestigationsList.sizeInBytes);
  inc(result, FProtocol.sizeInBytes);
  inc(result, FSummary.sizeInBytes);
  inc(result, FfindingList.sizeInBytes);
  inc(result, FresolvedList.sizeInBytes);
  inc(result, FruledOutList.sizeInBytes);
  inc(result, FPrognosis.sizeInBytes);
  inc(result, FplanList.sizeInBytes);
  inc(result, FactionList.sizeInBytes);
end;

{ TFhirClinicalImpressionListEnumerator }

Constructor TFhirClinicalImpressionListEnumerator.Create(list : TFhirClinicalImpressionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClinicalImpressionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClinicalImpressionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClinicalImpressionListEnumerator.GetCurrent : TFhirClinicalImpression;
begin
  Result := FList[FIndex];
end;

function TFhirClinicalImpressionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClinicalImpressionList }
procedure TFhirClinicalImpressionList.AddItem(value: TFhirClinicalImpression);
begin
  assert(value.ClassName = 'TFhirClinicalImpression', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClinicalImpression');
  add(value);
end;

function TFhirClinicalImpressionList.Append: TFhirClinicalImpression;
begin
  result := TFhirClinicalImpression.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalImpressionList.ClearItems;
begin
  Clear;
end;

function TFhirClinicalImpressionList.GetEnumerator : TFhirClinicalImpressionListEnumerator;
begin
  result := TFhirClinicalImpressionListEnumerator.Create(self.link);
end;

function TFhirClinicalImpressionList.Clone: TFhirClinicalImpressionList;
begin
  result := TFhirClinicalImpressionList(inherited Clone);
end;

function TFhirClinicalImpressionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClinicalImpressionList.GetItemN(index: Integer): TFhirClinicalImpression;
begin
  result := TFhirClinicalImpression(ObjectByIndex[index]);
end;

function TFhirClinicalImpressionList.ItemClass: TFslObjectClass;
begin
  result := TFhirClinicalImpression;
end;
function TFhirClinicalImpressionList.IndexOf(value: TFhirClinicalImpression): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClinicalImpressionList.Insert(index: Integer): TFhirClinicalImpression;
begin
  result := TFhirClinicalImpression.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalImpressionList.InsertItem(index: Integer; value: TFhirClinicalImpression);
begin
  assert(value is TFhirClinicalImpression);
  Inherited Insert(index, value);
end;

function TFhirClinicalImpressionList.Item(index: Integer): TFhirClinicalImpression;
begin
  result := TFhirClinicalImpression(ObjectByIndex[index]);
end;

function TFhirClinicalImpressionList.Link: TFhirClinicalImpressionList;
begin
  result := TFhirClinicalImpressionList(inherited Link);
end;

procedure TFhirClinicalImpressionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClinicalImpressionList.SetItemByIndex(index: Integer; value: TFhirClinicalImpression);
begin
  assert(value is TFhirClinicalImpression);
  FhirClinicalImpressions[index] := value;
end;

procedure TFhirClinicalImpressionList.SetItemN(index: Integer; value: TFhirClinicalImpression);
begin
  assert(value is TFhirClinicalImpression);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CLINICALIMPRESSION}

{$IFDEF FHIR_COMMUNICATION}

{ TFhirCommunicationPayload }

constructor TFhirCommunicationPayload.Create;
begin
  inherited;
end;

destructor TFhirCommunicationPayload.Destroy;
begin
  FContent.free;
  inherited;
end;

procedure TFhirCommunicationPayload.Assign(oSource : TFslObject);
begin
  inherited;
  content := TFhirCommunicationPayload(oSource).content.Clone;
end;

procedure TFhirCommunicationPayload.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'content[x]') or (child_name = 'content') Then
     list.add(self.link, 'content[x]', FContent.Link);
end;

procedure TFhirCommunicationPayload.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'content[x]', 'string|Attachment|Reference(Any)', false, TFhirType, FContent.Link));{2}
end;

function TFhirCommunicationPayload.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['String', 'Attachment', 'Reference'])) then
  begin
    Content := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCommunicationPayload.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCommunicationPayload.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['String', 'Attachment', 'Reference'])) then raise EFHIRException.create('Cannot make property Content'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCommunicationPayload.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'content[x]') then result := 'string|Attachment|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCommunicationPayload.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['String', 'Attachment', 'Reference'])) then ContentElement := nil{4x}
  else
  inherited deleteProperty(propName, value);
end;

procedure TFhirCommunicationPayload.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['String', 'Attachment', 'Reference'])) then ContentElement := new as TFhirType{4x}
  else
  inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCommunicationPayload.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCommunicationPayload.fhirType : string;
begin
  result := 'payload';
end;

function TFhirCommunicationPayload.Link : TFhirCommunicationPayload;
begin
  result := TFhirCommunicationPayload(inherited Link);
end;

function TFhirCommunicationPayload.Clone : TFhirCommunicationPayload;
begin
  result := TFhirCommunicationPayload(inherited Clone);
end;

function TFhirCommunicationPayload.equals(other : TObject) : boolean;
var
  o : TFhirCommunicationPayload;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCommunicationPayload)) then
    result := false
  else
  begin
    o := TFhirCommunicationPayload(other);
    result := compareDeep(contentElement, o.contentElement, true);
  end;
end;

function TFhirCommunicationPayload.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FContent);
end;

procedure TFhirCommunicationPayload.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('content[x]');
end;

{ TFhirCommunicationPayload }

Procedure TFhirCommunicationPayload.SetContent(value : TFhirType);
begin
  FContent.free;
  FContent := value;
end;

function TFhirCommunicationPayload.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FContent.sizeInBytes);
end;

{ TFhirCommunicationPayloadListEnumerator }

Constructor TFhirCommunicationPayloadListEnumerator.Create(list : TFhirCommunicationPayloadList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCommunicationPayloadListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCommunicationPayloadListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCommunicationPayloadListEnumerator.GetCurrent : TFhirCommunicationPayload;
begin
  Result := FList[FIndex];
end;

function TFhirCommunicationPayloadListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCommunicationPayloadList }
procedure TFhirCommunicationPayloadList.AddItem(value: TFhirCommunicationPayload);
begin
  assert(value.ClassName = 'TFhirCommunicationPayload', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCommunicationPayload');
  add(value);
end;

function TFhirCommunicationPayloadList.Append: TFhirCommunicationPayload;
begin
  result := TFhirCommunicationPayload.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCommunicationPayloadList.ClearItems;
begin
  Clear;
end;

function TFhirCommunicationPayloadList.GetEnumerator : TFhirCommunicationPayloadListEnumerator;
begin
  result := TFhirCommunicationPayloadListEnumerator.Create(self.link);
end;

function TFhirCommunicationPayloadList.Clone: TFhirCommunicationPayloadList;
begin
  result := TFhirCommunicationPayloadList(inherited Clone);
end;

function TFhirCommunicationPayloadList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCommunicationPayloadList.GetItemN(index: Integer): TFhirCommunicationPayload;
begin
  result := TFhirCommunicationPayload(ObjectByIndex[index]);
end;

function TFhirCommunicationPayloadList.ItemClass: TFslObjectClass;
begin
  result := TFhirCommunicationPayload;
end;
function TFhirCommunicationPayloadList.IndexOf(value: TFhirCommunicationPayload): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCommunicationPayloadList.Insert(index: Integer): TFhirCommunicationPayload;
begin
  result := TFhirCommunicationPayload.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCommunicationPayloadList.InsertItem(index: Integer; value: TFhirCommunicationPayload);
begin
  assert(value is TFhirCommunicationPayload);
  Inherited Insert(index, value);
end;

function TFhirCommunicationPayloadList.Item(index: Integer): TFhirCommunicationPayload;
begin
  result := TFhirCommunicationPayload(ObjectByIndex[index]);
end;

function TFhirCommunicationPayloadList.Link: TFhirCommunicationPayloadList;
begin
  result := TFhirCommunicationPayloadList(inherited Link);
end;

procedure TFhirCommunicationPayloadList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCommunicationPayloadList.SetItemByIndex(index: Integer; value: TFhirCommunicationPayload);
begin
  assert(value is TFhirCommunicationPayload);
  FhirCommunicationPayloads[index] := value;
end;

procedure TFhirCommunicationPayloadList.SetItemN(index: Integer; value: TFhirCommunicationPayload);
begin
  assert(value is TFhirCommunicationPayload);
  ObjectByIndex[index] := value;
end;

{ TFhirCommunication }

constructor TFhirCommunication.Create;
begin
  inherited;
end;

destructor TFhirCommunication.Destroy;
begin
  FIdentifierList.Free;
  FCategory.free;
  FSender.free;
  FRecipientList.Free;
  FPayloadList.Free;
  FMediumList.Free;
  FStatus.free;
  FEncounter.free;
  FSent.free;
  FReceived.free;
  FReasonList.Free;
  FSubject.free;
  FRequestDetail.free;
  inherited;
end;

function TFhirCommunication.GetResourceType : TFhirResourceType;
begin
  result := frtCommunication;
end;

procedure TFhirCommunication.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCommunication(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirCommunication(oSource).FIdentifierList);
  end;
  category := TFhirCommunication(oSource).category.Clone;
  sender := TFhirCommunication(oSource).sender.Clone;
  if (TFhirCommunication(oSource).FRecipientList = nil) then
  begin
    FRecipientList.free;
    FRecipientList := nil;
  end
  else
  begin
    if FRecipientList = nil then
      FRecipientList := TFhirReferenceList{Resource}.Create;
    FRecipientList.Assign(TFhirCommunication(oSource).FRecipientList);
  end;
  if (TFhirCommunication(oSource).FPayloadList = nil) then
  begin
    FPayloadList.free;
    FPayloadList := nil;
  end
  else
  begin
    if FPayloadList = nil then
      FPayloadList := TFhirCommunicationPayloadList.Create;
    FPayloadList.Assign(TFhirCommunication(oSource).FPayloadList);
  end;
  if (TFhirCommunication(oSource).FMediumList = nil) then
  begin
    FMediumList.free;
    FMediumList := nil;
  end
  else
  begin
    if FMediumList = nil then
      FMediumList := TFhirCodeableConceptList.Create;
    FMediumList.Assign(TFhirCommunication(oSource).FMediumList);
  end;
  FStatus := TFhirCommunication(oSource).FStatus.Link;
  encounter := TFhirCommunication(oSource).encounter.Clone;
  sentElement := TFhirCommunication(oSource).sentElement.Clone;
  receivedElement := TFhirCommunication(oSource).receivedElement.Clone;
  if (TFhirCommunication(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableConceptList.Create;
    FReasonList.Assign(TFhirCommunication(oSource).FReasonList);
  end;
  subject := TFhirCommunication(oSource).subject.Clone;
  requestDetail := TFhirCommunication(oSource).requestDetail.Clone;
end;

procedure TFhirCommunication.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'sender') Then
     list.add(self.link, 'sender', FSender.Link);
  if (child_name = 'recipient') Then
    list.addAll(self, 'recipient', FRecipientList);
  if (child_name = 'payload') Then
    list.addAll(self, 'payload', FPayloadList);
  if (child_name = 'medium') Then
    list.addAll(self, 'medium', FMediumList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'sent') Then
     list.add(self.link, 'sent', FSent.Link);
  if (child_name = 'received') Then
     list.add(self.link, 'received', FReceived.Link);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'requestDetail') Then
     list.add(self.link, 'requestDetail', FRequestDetail.Link);
end;

procedure TFhirCommunication.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'sender', 'Reference(Device|Organization|Patient|Practitioner|RelatedPerson)', false, TFhirReference{Resource}, FSender.Link));{2}
  oList.add(TFHIRProperty.create(self, 'recipient', 'Reference(Device|Organization|Patient|Practitioner|RelatedPerson|Group)', true, TFhirReference{Resource}, FRecipientList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'payload', '', true, TFhirCommunicationPayload, FPayloadList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'medium', 'CodeableConcept', true, TFhirCodeableConcept, FMediumList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference(Encounter)', false, TFhirReference{TFhirEncounter}, FEncounter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'sent', 'dateTime', false, TFhirDateTime, FSent.Link));{2}
  oList.add(TFHIRProperty.create(self, 'received', 'dateTime', false, TFhirDateTime, FReceived.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', true, TFhirCodeableConcept, FReasonList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requestDetail', 'Reference(CommunicationRequest)', false, TFhirReference{TFhirCommunicationRequest}, FRequestDetail.Link));{2}
end;

function TFhirCommunication.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'sender') then
  begin
    Sender := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'recipient') then
  begin
    RecipientList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'payload') then
  begin
    PayloadList.add(propValue as TFhirCommunicationPayload){2a};
    result := propValue;
  end
  else if (propName = 'medium') then
  begin
    MediumList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirCommunicationStatusEnum, CODES_TFhirCommunicationStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference{TFhirEncounter}{4b};
    result := propValue;
  end
  else if (propName = 'sent') then
  begin
    SentElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'received') then
  begin
    ReceivedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'requestDetail') then
  begin
    RequestDetail := propValue as TFhirReference{TFhirCommunicationRequest}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirCommunication.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'recipient') then RecipientList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'payload') then PayloadList.insertItem(index, propValue as TFhirCommunicationPayload){2a}
  else if (propName = 'medium') then MediumList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirCommunication.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'sender') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'recipient') then result := RecipientList.new(){2}
  else if (propName = 'payload') then result := PayloadList.new(){2}
  else if (propName = 'medium') then result := MediumList.new(){2}
  else if (propName = 'encounter') then result := TFhirReference{TFhirEncounter}.create(){4b}
  else if (propName = 'sent') then result := TFhirDateTime.create() {5b}
  else if (propName = 'received') then result := TFhirDateTime.create() {5b}
  else if (propName = 'reason') then result := ReasonList.new(){2}
  else if (propName = 'subject') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'requestDetail') then result := TFhirReference{TFhirCommunicationRequest}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCommunication.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'sender') then result := 'Reference'
  else if (propName = 'recipient') then result := 'Reference'
  else if (propName = 'payload') then result := ''
  else if (propName = 'medium') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'sent') then result := 'dateTime'
  else if (propName = 'received') then result := 'dateTime'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'requestDetail') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCommunication.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'sender') then SenderElement := nil
  else if (propName = 'recipient') then deletePropertyValue('recipient', RecipientList, value) {2}
  else if (propName = 'payload') then deletePropertyValue('payload', PayloadList, value) {2}
  else if (propName = 'medium') then deletePropertyValue('medium', MediumList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'sent') then SentElement := nil
  else if (propName = 'received') then ReceivedElement := nil
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value) {2}
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'requestDetail') then RequestDetailElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCommunication.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'sender') then SenderElement := new as TFhirReference{Resource}{4}
  else if (propName = 'recipient') then replacePropertyValue('recipient', RecipientList, existing, new) {2}
  else if (propName = 'payload') then replacePropertyValue('payload', PayloadList, existing, new) {2}
  else if (propName = 'medium') then replacePropertyValue('medium', MediumList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirCommunicationStatusEnum, CODES_TFhirCommunicationStatusEnum, new){4}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference{TFhirEncounter}{4}
  else if (propName = 'sent') then SentElement := asDateTime(new){5b}
  else if (propName = 'received') then ReceivedElement := asDateTime(new){5b}
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new) {2}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'requestDetail') then RequestDetailElement := new as TFhirReference{TFhirCommunicationRequest}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCommunication.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'recipient') then RecipientList.move(source, destination){2a}
  else if (propName = 'payload') then PayloadList.move(source, destination){2a}
  else if (propName = 'medium') then MediumList.move(source, destination){2a}
  else if (propName = 'reason') then ReasonList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCommunication.fhirType : string;
begin
  result := 'Communication';
end;

function TFhirCommunication.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FCategory) and isEmptyProp(FSender) and isEmptyProp(FrecipientList) and isEmptyProp(FpayloadList) and isEmptyProp(FmediumList) and isEmptyProp(FStatus) and isEmptyProp(FEncounter) and isEmptyProp(FSent) and isEmptyProp(FReceived) and isEmptyProp(FreasonList) and isEmptyProp(FSubject) and isEmptyProp(FRequestDetail);
end;

function TFhirCommunication.equals(other : TObject) : boolean;
var
  o : TFhirCommunication;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCommunication)) then
    result := false
  else
  begin
    o := TFhirCommunication(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(categoryElement, o.categoryElement, true) and
      compareDeep(senderElement, o.senderElement, true) and compareDeep(recipientList, o.recipientList, true) and
      compareDeep(payloadList, o.payloadList, true) and compareDeep(mediumList, o.mediumList, true) and
      compareDeep(statusElement, o.statusElement, true) and compareDeep(encounterElement, o.encounterElement, true) and
      compareDeep(sentElement, o.sentElement, true) and compareDeep(receivedElement, o.receivedElement, true) and
      compareDeep(reasonList, o.reasonList, true) and compareDeep(subjectElement, o.subjectElement, true) and
      compareDeep(requestDetailElement, o.requestDetailElement, true);
  end;
end;

function TFhirCommunication.Link : TFhirCommunication;
begin
  result := TFhirCommunication(inherited Link);
end;

function TFhirCommunication.Clone : TFhirCommunication;
begin
  result := TFhirCommunication(inherited Clone);
end;

procedure TFhirCommunication.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('category');
  fields.add('sender');
  fields.add('recipient');
  fields.add('payload');
  fields.add('medium');
  fields.add('status');
  fields.add('encounter');
  fields.add('sent');
  fields.add('received');
  fields.add('reason');
  fields.add('subject');
  fields.add('requestDetail');
end;

{ TFhirCommunication }

Function TFhirCommunication.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirCommunication.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirCommunication.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirCommunication.SetSender(value : TFhirReference{Resource});
begin
  FSender.free;
  FSender := value;
end;

Function TFhirCommunication.GetRecipientList : TFhirReferenceList{Resource};
begin
  if FRecipientList = nil then
    FRecipientList := TFhirReferenceList{Resource}.Create;
  result := FRecipientList;
end;

Function TFhirCommunication.GetHasRecipientList : boolean;
begin
  result := (FRecipientList <> nil) and (FRecipientList.count > 0);
end;

Function TFhirCommunication.GetPayloadList : TFhirCommunicationPayloadList;
begin
  if FPayloadList = nil then
    FPayloadList := TFhirCommunicationPayloadList.Create;
  result := FPayloadList;
end;

Function TFhirCommunication.GetHasPayloadList : boolean;
begin
  result := (FPayloadList <> nil) and (FPayloadList.count > 0);
end;

Function TFhirCommunication.GetMediumList : TFhirCodeableConceptList;
begin
  if FMediumList = nil then
    FMediumList := TFhirCodeableConceptList.Create;
  result := FMediumList;
end;

Function TFhirCommunication.GetHasMediumList : boolean;
begin
  result := (FMediumList <> nil) and (FMediumList.count > 0);
end;

Procedure TFhirCommunication.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirCommunication.GetStatusST : TFhirCommunicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirCommunicationStatusEnum(0)
  else
    result := TFhirCommunicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirCommunicationStatusEnum, FStatus.value));
end;

Procedure TFhirCommunication.SetStatusST(value : TFhirCommunicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirCommunicationStatusEnum[value], CODES_TFhirCommunicationStatusEnum[value]);
end;

Procedure TFhirCommunication.SetEncounter(value : TFhirReference{TFhirEncounter});
begin
  FEncounter.free;
  FEncounter := value;
end;

Procedure TFhirCommunication.SetSent(value : TFhirDateTime);
begin
  FSent.free;
  FSent := value;
end;

Function TFhirCommunication.GetSentST : TFslDateTime;
begin
  if FSent = nil then
    result := TFslDateTime.makeNull
  else
    result := FSent.value;
end;

Procedure TFhirCommunication.SetSentST(value : TFslDateTime);
begin
  if FSent = nil then
    FSent := TFhirDateTime.create;
  FSent.value := value
end;

Procedure TFhirCommunication.SetReceived(value : TFhirDateTime);
begin
  FReceived.free;
  FReceived := value;
end;

Function TFhirCommunication.GetReceivedST : TFslDateTime;
begin
  if FReceived = nil then
    result := TFslDateTime.makeNull
  else
    result := FReceived.value;
end;

Procedure TFhirCommunication.SetReceivedST(value : TFslDateTime);
begin
  if FReceived = nil then
    FReceived := TFhirDateTime.create;
  FReceived.value := value
end;

Function TFhirCommunication.GetReasonList : TFhirCodeableConceptList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableConceptList.Create;
  result := FReasonList;
end;

Function TFhirCommunication.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

Procedure TFhirCommunication.SetSubject(value : TFhirReference{TFhirPatient});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirCommunication.SetRequestDetail(value : TFhirReference{TFhirCommunicationRequest});
begin
  FRequestDetail.free;
  FRequestDetail := value;
end;

function TFhirCommunication.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FSender.sizeInBytes);
  inc(result, FrecipientList.sizeInBytes);
  inc(result, FpayloadList.sizeInBytes);
  inc(result, FmediumList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FSent.sizeInBytes);
  inc(result, FReceived.sizeInBytes);
  inc(result, FreasonList.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FRequestDetail.sizeInBytes);
end;

{ TFhirCommunicationListEnumerator }

Constructor TFhirCommunicationListEnumerator.Create(list : TFhirCommunicationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCommunicationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCommunicationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCommunicationListEnumerator.GetCurrent : TFhirCommunication;
begin
  Result := FList[FIndex];
end;

function TFhirCommunicationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCommunicationList }
procedure TFhirCommunicationList.AddItem(value: TFhirCommunication);
begin
  assert(value.ClassName = 'TFhirCommunication', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCommunication');
  add(value);
end;

function TFhirCommunicationList.Append: TFhirCommunication;
begin
  result := TFhirCommunication.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCommunicationList.ClearItems;
begin
  Clear;
end;

function TFhirCommunicationList.GetEnumerator : TFhirCommunicationListEnumerator;
begin
  result := TFhirCommunicationListEnumerator.Create(self.link);
end;

function TFhirCommunicationList.Clone: TFhirCommunicationList;
begin
  result := TFhirCommunicationList(inherited Clone);
end;

function TFhirCommunicationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCommunicationList.GetItemN(index: Integer): TFhirCommunication;
begin
  result := TFhirCommunication(ObjectByIndex[index]);
end;

function TFhirCommunicationList.ItemClass: TFslObjectClass;
begin
  result := TFhirCommunication;
end;
function TFhirCommunicationList.IndexOf(value: TFhirCommunication): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCommunicationList.Insert(index: Integer): TFhirCommunication;
begin
  result := TFhirCommunication.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCommunicationList.InsertItem(index: Integer; value: TFhirCommunication);
begin
  assert(value is TFhirCommunication);
  Inherited Insert(index, value);
end;

function TFhirCommunicationList.Item(index: Integer): TFhirCommunication;
begin
  result := TFhirCommunication(ObjectByIndex[index]);
end;

function TFhirCommunicationList.Link: TFhirCommunicationList;
begin
  result := TFhirCommunicationList(inherited Link);
end;

procedure TFhirCommunicationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCommunicationList.SetItemByIndex(index: Integer; value: TFhirCommunication);
begin
  assert(value is TFhirCommunication);
  FhirCommunications[index] := value;
end;

procedure TFhirCommunicationList.SetItemN(index: Integer; value: TFhirCommunication);
begin
  assert(value is TFhirCommunication);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_COMMUNICATION}

{$IFDEF FHIR_COMMUNICATIONREQUEST}

{ TFhirCommunicationRequestPayload }

constructor TFhirCommunicationRequestPayload.Create;
begin
  inherited;
end;

destructor TFhirCommunicationRequestPayload.Destroy;
begin
  FContent.free;
  inherited;
end;

procedure TFhirCommunicationRequestPayload.Assign(oSource : TFslObject);
begin
  inherited;
  content := TFhirCommunicationRequestPayload(oSource).content.Clone;
end;

procedure TFhirCommunicationRequestPayload.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'content[x]') or (child_name = 'content') Then
     list.add(self.link, 'content[x]', FContent.Link);
end;

procedure TFhirCommunicationRequestPayload.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'content[x]', 'string|Attachment|Reference(Any)', false, TFhirType, FContent.Link));{2}
end;

function TFhirCommunicationRequestPayload.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['String', 'Attachment', 'Reference'])) then
  begin
    Content := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCommunicationRequestPayload.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCommunicationRequestPayload.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['String', 'Attachment', 'Reference'])) then raise EFHIRException.create('Cannot make property Content'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCommunicationRequestPayload.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'content[x]') then result := 'string|Attachment|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCommunicationRequestPayload.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['String', 'Attachment', 'Reference'])) then ContentElement := nil{4x}
  else
  inherited deleteProperty(propName, value);
end;

procedure TFhirCommunicationRequestPayload.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['String', 'Attachment', 'Reference'])) then ContentElement := new as TFhirType{4x}
  else
  inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCommunicationRequestPayload.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCommunicationRequestPayload.fhirType : string;
begin
  result := 'payload';
end;

function TFhirCommunicationRequestPayload.Link : TFhirCommunicationRequestPayload;
begin
  result := TFhirCommunicationRequestPayload(inherited Link);
end;

function TFhirCommunicationRequestPayload.Clone : TFhirCommunicationRequestPayload;
begin
  result := TFhirCommunicationRequestPayload(inherited Clone);
end;

function TFhirCommunicationRequestPayload.equals(other : TObject) : boolean;
var
  o : TFhirCommunicationRequestPayload;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCommunicationRequestPayload)) then
    result := false
  else
  begin
    o := TFhirCommunicationRequestPayload(other);
    result := compareDeep(contentElement, o.contentElement, true);
  end;
end;

function TFhirCommunicationRequestPayload.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FContent);
end;

procedure TFhirCommunicationRequestPayload.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('content[x]');
end;

{ TFhirCommunicationRequestPayload }

Procedure TFhirCommunicationRequestPayload.SetContent(value : TFhirType);
begin
  FContent.free;
  FContent := value;
end;

function TFhirCommunicationRequestPayload.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FContent.sizeInBytes);
end;

{ TFhirCommunicationRequestPayloadListEnumerator }

Constructor TFhirCommunicationRequestPayloadListEnumerator.Create(list : TFhirCommunicationRequestPayloadList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCommunicationRequestPayloadListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCommunicationRequestPayloadListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCommunicationRequestPayloadListEnumerator.GetCurrent : TFhirCommunicationRequestPayload;
begin
  Result := FList[FIndex];
end;

function TFhirCommunicationRequestPayloadListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCommunicationRequestPayloadList }
procedure TFhirCommunicationRequestPayloadList.AddItem(value: TFhirCommunicationRequestPayload);
begin
  assert(value.ClassName = 'TFhirCommunicationRequestPayload', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCommunicationRequestPayload');
  add(value);
end;

function TFhirCommunicationRequestPayloadList.Append: TFhirCommunicationRequestPayload;
begin
  result := TFhirCommunicationRequestPayload.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCommunicationRequestPayloadList.ClearItems;
begin
  Clear;
end;

function TFhirCommunicationRequestPayloadList.GetEnumerator : TFhirCommunicationRequestPayloadListEnumerator;
begin
  result := TFhirCommunicationRequestPayloadListEnumerator.Create(self.link);
end;

function TFhirCommunicationRequestPayloadList.Clone: TFhirCommunicationRequestPayloadList;
begin
  result := TFhirCommunicationRequestPayloadList(inherited Clone);
end;

function TFhirCommunicationRequestPayloadList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCommunicationRequestPayloadList.GetItemN(index: Integer): TFhirCommunicationRequestPayload;
begin
  result := TFhirCommunicationRequestPayload(ObjectByIndex[index]);
end;

function TFhirCommunicationRequestPayloadList.ItemClass: TFslObjectClass;
begin
  result := TFhirCommunicationRequestPayload;
end;
function TFhirCommunicationRequestPayloadList.IndexOf(value: TFhirCommunicationRequestPayload): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCommunicationRequestPayloadList.Insert(index: Integer): TFhirCommunicationRequestPayload;
begin
  result := TFhirCommunicationRequestPayload.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCommunicationRequestPayloadList.InsertItem(index: Integer; value: TFhirCommunicationRequestPayload);
begin
  assert(value is TFhirCommunicationRequestPayload);
  Inherited Insert(index, value);
end;

function TFhirCommunicationRequestPayloadList.Item(index: Integer): TFhirCommunicationRequestPayload;
begin
  result := TFhirCommunicationRequestPayload(ObjectByIndex[index]);
end;

function TFhirCommunicationRequestPayloadList.Link: TFhirCommunicationRequestPayloadList;
begin
  result := TFhirCommunicationRequestPayloadList(inherited Link);
end;

procedure TFhirCommunicationRequestPayloadList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCommunicationRequestPayloadList.SetItemByIndex(index: Integer; value: TFhirCommunicationRequestPayload);
begin
  assert(value is TFhirCommunicationRequestPayload);
  FhirCommunicationRequestPayloads[index] := value;
end;

procedure TFhirCommunicationRequestPayloadList.SetItemN(index: Integer; value: TFhirCommunicationRequestPayload);
begin
  assert(value is TFhirCommunicationRequestPayload);
  ObjectByIndex[index] := value;
end;

{ TFhirCommunicationRequest }

constructor TFhirCommunicationRequest.Create;
begin
  inherited;
end;

destructor TFhirCommunicationRequest.Destroy;
begin
  FIdentifierList.Free;
  FCategory.free;
  FSender.free;
  FRecipientList.Free;
  FPayloadList.Free;
  FMediumList.Free;
  FRequester.free;
  FStatus.free;
  FEncounter.free;
  FScheduled.free;
  FReasonList.Free;
  FRequestedOn.free;
  FSubject.free;
  FPriority.free;
  inherited;
end;

function TFhirCommunicationRequest.GetResourceType : TFhirResourceType;
begin
  result := frtCommunicationRequest;
end;

procedure TFhirCommunicationRequest.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCommunicationRequest(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirCommunicationRequest(oSource).FIdentifierList);
  end;
  category := TFhirCommunicationRequest(oSource).category.Clone;
  sender := TFhirCommunicationRequest(oSource).sender.Clone;
  if (TFhirCommunicationRequest(oSource).FRecipientList = nil) then
  begin
    FRecipientList.free;
    FRecipientList := nil;
  end
  else
  begin
    if FRecipientList = nil then
      FRecipientList := TFhirReferenceList{Resource}.Create;
    FRecipientList.Assign(TFhirCommunicationRequest(oSource).FRecipientList);
  end;
  if (TFhirCommunicationRequest(oSource).FPayloadList = nil) then
  begin
    FPayloadList.free;
    FPayloadList := nil;
  end
  else
  begin
    if FPayloadList = nil then
      FPayloadList := TFhirCommunicationRequestPayloadList.Create;
    FPayloadList.Assign(TFhirCommunicationRequest(oSource).FPayloadList);
  end;
  if (TFhirCommunicationRequest(oSource).FMediumList = nil) then
  begin
    FMediumList.free;
    FMediumList := nil;
  end
  else
  begin
    if FMediumList = nil then
      FMediumList := TFhirCodeableConceptList.Create;
    FMediumList.Assign(TFhirCommunicationRequest(oSource).FMediumList);
  end;
  requester := TFhirCommunicationRequest(oSource).requester.Clone;
  FStatus := TFhirCommunicationRequest(oSource).FStatus.Link;
  encounter := TFhirCommunicationRequest(oSource).encounter.Clone;
  scheduled := TFhirCommunicationRequest(oSource).scheduled.Clone;
  if (TFhirCommunicationRequest(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableConceptList.Create;
    FReasonList.Assign(TFhirCommunicationRequest(oSource).FReasonList);
  end;
  requestedOnElement := TFhirCommunicationRequest(oSource).requestedOnElement.Clone;
  subject := TFhirCommunicationRequest(oSource).subject.Clone;
  priority := TFhirCommunicationRequest(oSource).priority.Clone;
end;

procedure TFhirCommunicationRequest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'sender') Then
     list.add(self.link, 'sender', FSender.Link);
  if (child_name = 'recipient') Then
    list.addAll(self, 'recipient', FRecipientList);
  if (child_name = 'payload') Then
    list.addAll(self, 'payload', FPayloadList);
  if (child_name = 'medium') Then
    list.addAll(self, 'medium', FMediumList);
  if (child_name = 'requester') Then
     list.add(self.link, 'requester', FRequester.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'scheduled[x]') or (child_name = 'scheduled') Then
     list.add(self.link, 'scheduled[x]', FScheduled.Link);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'requestedOn') Then
     list.add(self.link, 'requestedOn', FRequestedOn.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
end;

procedure TFhirCommunicationRequest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'sender', 'Reference(Device|Organization|Patient|Practitioner|RelatedPerson)', false, TFhirReference{Resource}, FSender.Link));{2}
  oList.add(TFHIRProperty.create(self, 'recipient', 'Reference(Device|Organization|Patient|Practitioner|RelatedPerson)', true, TFhirReference{Resource}, FRecipientList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'payload', '', true, TFhirCommunicationRequestPayload, FPayloadList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'medium', 'CodeableConcept', true, TFhirCodeableConcept, FMediumList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'requester', 'Reference(Practitioner|Patient|RelatedPerson)', false, TFhirReference{Resource}, FRequester.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference(Encounter)', false, TFhirReference{TFhirEncounter}, FEncounter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'scheduled[x]', 'dateTime|Period', false, TFhirType, FScheduled.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', true, TFhirCodeableConcept, FReasonList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'requestedOn', 'dateTime', false, TFhirDateTime, FRequestedOn.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'priority', 'CodeableConcept', false, TFhirCodeableConcept, FPriority.Link));{2}
end;

function TFhirCommunicationRequest.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'sender') then
  begin
    Sender := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'recipient') then
  begin
    RecipientList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'payload') then
  begin
    PayloadList.add(propValue as TFhirCommunicationRequestPayload){2a};
    result := propValue;
  end
  else if (propName = 'medium') then
  begin
    MediumList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'requester') then
  begin
    Requester := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirCommunicationRequestStatusEnum, CODES_TFhirCommunicationRequestStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference{TFhirEncounter}{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'scheduled', ['DateTime', 'Period'])) then
  begin
    Scheduled := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'requestedOn') then
  begin
    RequestedOnElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    Priority := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirCommunicationRequest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'recipient') then RecipientList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'payload') then PayloadList.insertItem(index, propValue as TFhirCommunicationRequestPayload){2a}
  else if (propName = 'medium') then MediumList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirCommunicationRequest.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'sender') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'recipient') then result := RecipientList.new(){2}
  else if (propName = 'payload') then result := PayloadList.new(){2}
  else if (propName = 'medium') then result := MediumList.new(){2}
  else if (propName = 'requester') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'encounter') then result := TFhirReference{TFhirEncounter}.create(){4b}
  else if (isMatchingName(propName, 'scheduled', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Scheduled'){4x}
  else if (propName = 'reason') then result := ReasonList.new(){2}
  else if (propName = 'requestedOn') then result := TFhirDateTime.create() {5b}
  else if (propName = 'subject') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'priority') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCommunicationRequest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'sender') then result := 'Reference'
  else if (propName = 'recipient') then result := 'Reference'
  else if (propName = 'payload') then result := ''
  else if (propName = 'medium') then result := 'CodeableConcept'
  else if (propName = 'requester') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'scheduled[x]') then result := 'dateTime|Period'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else if (propName = 'requestedOn') then result := 'dateTime'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'priority') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCommunicationRequest.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'sender') then SenderElement := nil
  else if (propName = 'recipient') then deletePropertyValue('recipient', RecipientList, value) {2}
  else if (propName = 'payload') then deletePropertyValue('payload', PayloadList, value) {2}
  else if (propName = 'medium') then deletePropertyValue('medium', MediumList, value) {2}
  else if (propName = 'requester') then RequesterElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (isMatchingName(propName, 'scheduled', ['DateTime', 'Period'])) then ScheduledElement := nil{4x}
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value) {2}
  else if (propName = 'requestedOn') then RequestedOnElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCommunicationRequest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'sender') then SenderElement := new as TFhirReference{Resource}{4}
  else if (propName = 'recipient') then replacePropertyValue('recipient', RecipientList, existing, new) {2}
  else if (propName = 'payload') then replacePropertyValue('payload', PayloadList, existing, new) {2}
  else if (propName = 'medium') then replacePropertyValue('medium', MediumList, existing, new) {2}
  else if (propName = 'requester') then RequesterElement := new as TFhirReference{Resource}{4}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirCommunicationRequestStatusEnum, CODES_TFhirCommunicationRequestStatusEnum, new){4}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference{TFhirEncounter}{4}
  else if (isMatchingName(propName, 'scheduled', ['DateTime', 'Period'])) then ScheduledElement := new as TFhirType{4x}
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new) {2}
  else if (propName = 'requestedOn') then RequestedOnElement := asDateTime(new){5b}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'priority') then PriorityElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCommunicationRequest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'recipient') then RecipientList.move(source, destination){2a}
  else if (propName = 'payload') then PayloadList.move(source, destination){2a}
  else if (propName = 'medium') then MediumList.move(source, destination){2a}
  else if (propName = 'reason') then ReasonList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCommunicationRequest.fhirType : string;
begin
  result := 'CommunicationRequest';
end;

function TFhirCommunicationRequest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FCategory) and isEmptyProp(FSender) and isEmptyProp(FrecipientList) and isEmptyProp(FpayloadList) and isEmptyProp(FmediumList) and isEmptyProp(FRequester) and isEmptyProp(FStatus) and isEmptyProp(FEncounter) and isEmptyProp(FScheduled) and isEmptyProp(FreasonList) and isEmptyProp(FRequestedOn) and isEmptyProp(FSubject) and isEmptyProp(FPriority);
end;

function TFhirCommunicationRequest.equals(other : TObject) : boolean;
var
  o : TFhirCommunicationRequest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCommunicationRequest)) then
    result := false
  else
  begin
    o := TFhirCommunicationRequest(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(categoryElement, o.categoryElement, true) and
      compareDeep(senderElement, o.senderElement, true) and compareDeep(recipientList, o.recipientList, true) and
      compareDeep(payloadList, o.payloadList, true) and compareDeep(mediumList, o.mediumList, true) and
      compareDeep(requesterElement, o.requesterElement, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(scheduledElement, o.scheduledElement, true) and
      compareDeep(reasonList, o.reasonList, true) and compareDeep(requestedOnElement, o.requestedOnElement, true) and
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(priorityElement, o.priorityElement, true);
  end;
end;

function TFhirCommunicationRequest.Link : TFhirCommunicationRequest;
begin
  result := TFhirCommunicationRequest(inherited Link);
end;

function TFhirCommunicationRequest.Clone : TFhirCommunicationRequest;
begin
  result := TFhirCommunicationRequest(inherited Clone);
end;

procedure TFhirCommunicationRequest.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('category');
  fields.add('sender');
  fields.add('recipient');
  fields.add('payload');
  fields.add('medium');
  fields.add('requester');
  fields.add('status');
  fields.add('encounter');
  fields.add('scheduled[x]');
  fields.add('reason');
  fields.add('requestedOn');
  fields.add('subject');
  fields.add('priority');
end;

{ TFhirCommunicationRequest }

Function TFhirCommunicationRequest.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirCommunicationRequest.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirCommunicationRequest.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirCommunicationRequest.SetSender(value : TFhirReference{Resource});
begin
  FSender.free;
  FSender := value;
end;

Function TFhirCommunicationRequest.GetRecipientList : TFhirReferenceList{Resource};
begin
  if FRecipientList = nil then
    FRecipientList := TFhirReferenceList{Resource}.Create;
  result := FRecipientList;
end;

Function TFhirCommunicationRequest.GetHasRecipientList : boolean;
begin
  result := (FRecipientList <> nil) and (FRecipientList.count > 0);
end;

Function TFhirCommunicationRequest.GetPayloadList : TFhirCommunicationRequestPayloadList;
begin
  if FPayloadList = nil then
    FPayloadList := TFhirCommunicationRequestPayloadList.Create;
  result := FPayloadList;
end;

Function TFhirCommunicationRequest.GetHasPayloadList : boolean;
begin
  result := (FPayloadList <> nil) and (FPayloadList.count > 0);
end;

Function TFhirCommunicationRequest.GetMediumList : TFhirCodeableConceptList;
begin
  if FMediumList = nil then
    FMediumList := TFhirCodeableConceptList.Create;
  result := FMediumList;
end;

Function TFhirCommunicationRequest.GetHasMediumList : boolean;
begin
  result := (FMediumList <> nil) and (FMediumList.count > 0);
end;

Procedure TFhirCommunicationRequest.SetRequester(value : TFhirReference{Resource});
begin
  FRequester.free;
  FRequester := value;
end;

Procedure TFhirCommunicationRequest.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirCommunicationRequest.GetStatusST : TFhirCommunicationRequestStatusEnum;
begin
  if FStatus = nil then
    result := TFhirCommunicationRequestStatusEnum(0)
  else
    result := TFhirCommunicationRequestStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirCommunicationRequestStatusEnum, FStatus.value));
end;

Procedure TFhirCommunicationRequest.SetStatusST(value : TFhirCommunicationRequestStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirCommunicationRequestStatusEnum[value], CODES_TFhirCommunicationRequestStatusEnum[value]);
end;

Procedure TFhirCommunicationRequest.SetEncounter(value : TFhirReference{TFhirEncounter});
begin
  FEncounter.free;
  FEncounter := value;
end;

Procedure TFhirCommunicationRequest.SetScheduled(value : TFhirType);
begin
  FScheduled.free;
  FScheduled := value;
end;

Function TFhirCommunicationRequest.GetReasonList : TFhirCodeableConceptList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableConceptList.Create;
  result := FReasonList;
end;

Function TFhirCommunicationRequest.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

Procedure TFhirCommunicationRequest.SetRequestedOn(value : TFhirDateTime);
begin
  FRequestedOn.free;
  FRequestedOn := value;
end;

Function TFhirCommunicationRequest.GetRequestedOnST : TFslDateTime;
begin
  if FRequestedOn = nil then
    result := TFslDateTime.makeNull
  else
    result := FRequestedOn.value;
end;

Procedure TFhirCommunicationRequest.SetRequestedOnST(value : TFslDateTime);
begin
  if FRequestedOn = nil then
    FRequestedOn := TFhirDateTime.create;
  FRequestedOn.value := value
end;

Procedure TFhirCommunicationRequest.SetSubject(value : TFhirReference{TFhirPatient});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirCommunicationRequest.SetPriority(value : TFhirCodeableConcept);
begin
  FPriority.free;
  FPriority := value;
end;

function TFhirCommunicationRequest.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FSender.sizeInBytes);
  inc(result, FrecipientList.sizeInBytes);
  inc(result, FpayloadList.sizeInBytes);
  inc(result, FmediumList.sizeInBytes);
  inc(result, FRequester.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FScheduled.sizeInBytes);
  inc(result, FreasonList.sizeInBytes);
  inc(result, FRequestedOn.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FPriority.sizeInBytes);
end;

{ TFhirCommunicationRequestListEnumerator }

Constructor TFhirCommunicationRequestListEnumerator.Create(list : TFhirCommunicationRequestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCommunicationRequestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCommunicationRequestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCommunicationRequestListEnumerator.GetCurrent : TFhirCommunicationRequest;
begin
  Result := FList[FIndex];
end;

function TFhirCommunicationRequestListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCommunicationRequestList }
procedure TFhirCommunicationRequestList.AddItem(value: TFhirCommunicationRequest);
begin
  assert(value.ClassName = 'TFhirCommunicationRequest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCommunicationRequest');
  add(value);
end;

function TFhirCommunicationRequestList.Append: TFhirCommunicationRequest;
begin
  result := TFhirCommunicationRequest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCommunicationRequestList.ClearItems;
begin
  Clear;
end;

function TFhirCommunicationRequestList.GetEnumerator : TFhirCommunicationRequestListEnumerator;
begin
  result := TFhirCommunicationRequestListEnumerator.Create(self.link);
end;

function TFhirCommunicationRequestList.Clone: TFhirCommunicationRequestList;
begin
  result := TFhirCommunicationRequestList(inherited Clone);
end;

function TFhirCommunicationRequestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCommunicationRequestList.GetItemN(index: Integer): TFhirCommunicationRequest;
begin
  result := TFhirCommunicationRequest(ObjectByIndex[index]);
end;

function TFhirCommunicationRequestList.ItemClass: TFslObjectClass;
begin
  result := TFhirCommunicationRequest;
end;
function TFhirCommunicationRequestList.IndexOf(value: TFhirCommunicationRequest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCommunicationRequestList.Insert(index: Integer): TFhirCommunicationRequest;
begin
  result := TFhirCommunicationRequest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCommunicationRequestList.InsertItem(index: Integer; value: TFhirCommunicationRequest);
begin
  assert(value is TFhirCommunicationRequest);
  Inherited Insert(index, value);
end;

function TFhirCommunicationRequestList.Item(index: Integer): TFhirCommunicationRequest;
begin
  result := TFhirCommunicationRequest(ObjectByIndex[index]);
end;

function TFhirCommunicationRequestList.Link: TFhirCommunicationRequestList;
begin
  result := TFhirCommunicationRequestList(inherited Link);
end;

procedure TFhirCommunicationRequestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCommunicationRequestList.SetItemByIndex(index: Integer; value: TFhirCommunicationRequest);
begin
  assert(value is TFhirCommunicationRequest);
  FhirCommunicationRequests[index] := value;
end;

procedure TFhirCommunicationRequestList.SetItemN(index: Integer; value: TFhirCommunicationRequest);
begin
  assert(value is TFhirCommunicationRequest);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_COMMUNICATIONREQUEST}

{$IFDEF FHIR_COMPOSITION}

{ TFhirCompositionAttester }

constructor TFhirCompositionAttester.Create;
begin
  inherited;
end;

destructor TFhirCompositionAttester.Destroy;
begin
  FMode.Free;
  FTime.free;
  FParty.free;
  inherited;
end;

procedure TFhirCompositionAttester.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCompositionAttester(oSource).FMode = nil) then
  begin
    FMode.free;
    FMode := nil;
  end
  else
  begin
    FMode := TFHIREnumList.Create(SYSTEMS_TFhirCompositionAttestationModeEnum, CODES_TFhirCompositionAttestationModeEnum);
    FMode.Assign(TFhirCompositionAttester(oSource).FMode);
  end;
  timeElement := TFhirCompositionAttester(oSource).timeElement.Clone;
  party := TFhirCompositionAttester(oSource).party.Clone;
end;

procedure TFhirCompositionAttester.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'mode') Then
     list.addAll(self, 'mode', FMode);
  if (child_name = 'time') Then
     list.add(self.link, 'time', FTime.Link);
  if (child_name = 'party') Then
     list.add(self.link, 'party', FParty.Link);
end;

procedure TFhirCompositionAttester.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'mode', 'code', true, TFHIREnum, FMode.Link)){3};
  oList.add(TFHIRProperty.create(self, 'time', 'dateTime', false, TFhirDateTime, FTime.Link));{2}
  oList.add(TFHIRProperty.create(self, 'party', 'Reference(Patient|Practitioner|Organization)', false, TFhirReference{Resource}, FParty.Link));{2}
end;

function TFhirCompositionAttester.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'mode') then
  begin
    ModeList.add(asEnum(SYSTEMS_TFhirCompositionAttestationModeEnum, CODES_TFhirCompositionAttestationModeEnum, propValue)); {1}
    result := propValue;
  end
  else if (propName = 'time') then
  begin
    TimeElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'party') then
  begin
    Party := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCompositionAttester.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'mode') then FMode.insertItem(index, asEnum(SYSTEMS_TFhirCompositionAttestationModeEnum, CODES_TFhirCompositionAttestationModeEnum, propValue)) {1}
  else inherited;
end;

function TFhirCompositionAttester.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'time') then result := TFhirDateTime.create() {5b}
  else if (propName = 'party') then result := TFhirReference{Resource}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCompositionAttester.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'mode') then result := 'code'
  else if (propName = 'time') then result := 'dateTime'
  else if (propName = 'party') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCompositionAttester.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'time') then TimeElement := nil
  else if (propName = 'party') then PartyElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCompositionAttester.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'time') then TimeElement := asDateTime(new){5b}
  else if (propName = 'party') then PartyElement := new as TFhirReference{Resource}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCompositionAttester.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'mode') then FMode.move(source, destination) {1}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCompositionAttester.fhirType : string;
begin
  result := 'attester';
end;

function TFhirCompositionAttester.Link : TFhirCompositionAttester;
begin
  result := TFhirCompositionAttester(inherited Link);
end;

function TFhirCompositionAttester.Clone : TFhirCompositionAttester;
begin
  result := TFhirCompositionAttester(inherited Clone);
end;

function TFhirCompositionAttester.equals(other : TObject) : boolean;
var
  o : TFhirCompositionAttester;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCompositionAttester)) then
    result := false
  else
  begin
    o := TFhirCompositionAttester(other);
    result := compareDeep(modeList, o.modeList, true) and compareDeep(timeElement, o.timeElement, true) and
      compareDeep(partyElement, o.partyElement, true);
  end;
end;

function TFhirCompositionAttester.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMode) and isEmptyProp(FTime) and isEmptyProp(FParty);
end;

procedure TFhirCompositionAttester.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('mode');
  fields.add('time');
  fields.add('party');
end;

{ TFhirCompositionAttester }

Function TFhirCompositionAttester.GetMode : TFhirEnumList;
begin
  if FMode = nil then
    FMode := TFHIREnumList.Create(SYSTEMS_TFhirCompositionAttestationModeEnum, CODES_TFhirCompositionAttestationModeEnum);
  result := FMode;
end;

Function TFhirCompositionAttester.GetHasMode : boolean;
begin
  result := (FMode <> nil) and (FMode.count > 0);
end;

Function TFhirCompositionAttester.GetModeST : TFhirCompositionAttestationModeEnumList;
  var i : integer;
begin
  result := [];
  if Fmode <> nil then
    for i := 0 to Fmode.count - 1 do
      result := result + [TFhirCompositionAttestationModeEnum(StringArrayIndexOfSensitive(CODES_TFhirCompositionAttestationModeEnum, Fmode[i].value))];
end;

Procedure TFhirCompositionAttester.SetModeST(value : TFhirCompositionAttestationModeEnumList);
var a : TFhirCompositionAttestationModeEnum;
begin
  if Fmode = nil then
    Fmode := TFhirEnumList.create(SYSTEMS_TFhirCompositionAttestationModeEnum, CODES_TFhirCompositionAttestationModeEnum);
  Fmode.clear;
  for a := low(TFhirCompositionAttestationModeEnum) to high(TFhirCompositionAttestationModeEnum) do
    if a in value then
      begin
         if Fmode = nil then
           Fmode := TFhirEnumList.create(SYSTEMS_TFhirCompositionAttestationModeEnum, CODES_TFhirCompositionAttestationModeEnum);
         Fmode.add(TFhirEnum.create(SYSTEMS_TFhirCompositionAttestationModeEnum[a], CODES_TFhirCompositionAttestationModeEnum[a]));
      end;
end;

Procedure TFhirCompositionAttester.SetTime(value : TFhirDateTime);
begin
  FTime.free;
  FTime := value;
end;

Function TFhirCompositionAttester.GetTimeST : TFslDateTime;
begin
  if FTime = nil then
    result := TFslDateTime.makeNull
  else
    result := FTime.value;
end;

Procedure TFhirCompositionAttester.SetTimeST(value : TFslDateTime);
begin
  if FTime = nil then
    FTime := TFhirDateTime.create;
  FTime.value := value
end;

Procedure TFhirCompositionAttester.SetParty(value : TFhirReference{Resource});
begin
  FParty.free;
  FParty := value;
end;

function TFhirCompositionAttester.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FMode.sizeInBytes);
  inc(result, FTime.sizeInBytes);
  inc(result, FParty.sizeInBytes);
end;

{ TFhirCompositionAttesterListEnumerator }

Constructor TFhirCompositionAttesterListEnumerator.Create(list : TFhirCompositionAttesterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCompositionAttesterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCompositionAttesterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCompositionAttesterListEnumerator.GetCurrent : TFhirCompositionAttester;
begin
  Result := FList[FIndex];
end;

function TFhirCompositionAttesterListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCompositionAttesterList }
procedure TFhirCompositionAttesterList.AddItem(value: TFhirCompositionAttester);
begin
  assert(value.ClassName = 'TFhirCompositionAttester', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCompositionAttester');
  add(value);
end;

function TFhirCompositionAttesterList.Append: TFhirCompositionAttester;
begin
  result := TFhirCompositionAttester.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompositionAttesterList.ClearItems;
begin
  Clear;
end;

function TFhirCompositionAttesterList.GetEnumerator : TFhirCompositionAttesterListEnumerator;
begin
  result := TFhirCompositionAttesterListEnumerator.Create(self.link);
end;

function TFhirCompositionAttesterList.Clone: TFhirCompositionAttesterList;
begin
  result := TFhirCompositionAttesterList(inherited Clone);
end;

function TFhirCompositionAttesterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCompositionAttesterList.GetItemN(index: Integer): TFhirCompositionAttester;
begin
  result := TFhirCompositionAttester(ObjectByIndex[index]);
end;

function TFhirCompositionAttesterList.ItemClass: TFslObjectClass;
begin
  result := TFhirCompositionAttester;
end;
function TFhirCompositionAttesterList.IndexOf(value: TFhirCompositionAttester): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCompositionAttesterList.Insert(index: Integer): TFhirCompositionAttester;
begin
  result := TFhirCompositionAttester.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompositionAttesterList.InsertItem(index: Integer; value: TFhirCompositionAttester);
begin
  assert(value is TFhirCompositionAttester);
  Inherited Insert(index, value);
end;

function TFhirCompositionAttesterList.Item(index: Integer): TFhirCompositionAttester;
begin
  result := TFhirCompositionAttester(ObjectByIndex[index]);
end;

function TFhirCompositionAttesterList.Link: TFhirCompositionAttesterList;
begin
  result := TFhirCompositionAttesterList(inherited Link);
end;

procedure TFhirCompositionAttesterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCompositionAttesterList.SetItemByIndex(index: Integer; value: TFhirCompositionAttester);
begin
  assert(value is TFhirCompositionAttester);
  FhirCompositionAttesters[index] := value;
end;

procedure TFhirCompositionAttesterList.SetItemN(index: Integer; value: TFhirCompositionAttester);
begin
  assert(value is TFhirCompositionAttester);
  ObjectByIndex[index] := value;
end;

{ TFhirCompositionEvent }

constructor TFhirCompositionEvent.Create;
begin
  inherited;
end;

destructor TFhirCompositionEvent.Destroy;
begin
  FCodeList.Free;
  FPeriod.free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirCompositionEvent.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCompositionEvent(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirCodeableConceptList.Create;
    FCodeList.Assign(TFhirCompositionEvent(oSource).FCodeList);
  end;
  period := TFhirCompositionEvent(oSource).period.Clone;
  if (TFhirCompositionEvent(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirReferenceList{TFhirReference}.Create;
    FDetailList.Assign(TFhirCompositionEvent(oSource).FDetailList);
  end;
end;

procedure TFhirCompositionEvent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
end;

procedure TFhirCompositionEvent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', true, TFhirCodeableConcept, FCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'detail', 'Reference(Any)', true, TFhirReference{TFhirReference}, FDetailList.Link)){3};
end;

function TFhirCompositionEvent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCompositionEvent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else inherited;
end;

function TFhirCompositionEvent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := CodeList.new(){2}
  else if (propName = 'period') then result := TFhirPeriod.create(){4b}
  else if (propName = 'detail') then result := DetailList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCompositionEvent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'detail') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCompositionEvent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then deletePropertyValue('code', CodeList, value) {2}
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCompositionEvent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new) {2}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCompositionEvent.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'code') then CodeList.move(source, destination){2a}
  else if (propName = 'detail') then DetailList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCompositionEvent.fhirType : string;
begin
  result := 'event';
end;

function TFhirCompositionEvent.Link : TFhirCompositionEvent;
begin
  result := TFhirCompositionEvent(inherited Link);
end;

function TFhirCompositionEvent.Clone : TFhirCompositionEvent;
begin
  result := TFhirCompositionEvent(inherited Clone);
end;

function TFhirCompositionEvent.equals(other : TObject) : boolean;
var
  o : TFhirCompositionEvent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCompositionEvent)) then
    result := false
  else
  begin
    o := TFhirCompositionEvent(other);
    result := compareDeep(codeList, o.codeList, true) and compareDeep(periodElement, o.periodElement, true) and
      compareDeep(detailList, o.detailList, true);
  end;
end;

function TFhirCompositionEvent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FcodeList) and isEmptyProp(FPeriod) and isEmptyProp(FdetailList);
end;

procedure TFhirCompositionEvent.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('period');
  fields.add('detail');
end;

{ TFhirCompositionEvent }

Function TFhirCompositionEvent.GetCodeList : TFhirCodeableConceptList;
begin
  if FCodeList = nil then
    FCodeList := TFhirCodeableConceptList.Create;
  result := FCodeList;
end;

Function TFhirCompositionEvent.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

Procedure TFhirCompositionEvent.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Function TFhirCompositionEvent.GetDetailList : TFhirReferenceList{TFhirReference};
begin
  if FDetailList = nil then
    FDetailList := TFhirReferenceList{TFhirReference}.Create;
  result := FDetailList;
end;

Function TFhirCompositionEvent.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

function TFhirCompositionEvent.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FcodeList.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FdetailList.sizeInBytes);
end;

{ TFhirCompositionEventListEnumerator }

Constructor TFhirCompositionEventListEnumerator.Create(list : TFhirCompositionEventList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCompositionEventListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCompositionEventListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCompositionEventListEnumerator.GetCurrent : TFhirCompositionEvent;
begin
  Result := FList[FIndex];
end;

function TFhirCompositionEventListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCompositionEventList }
procedure TFhirCompositionEventList.AddItem(value: TFhirCompositionEvent);
begin
  assert(value.ClassName = 'TFhirCompositionEvent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCompositionEvent');
  add(value);
end;

function TFhirCompositionEventList.Append: TFhirCompositionEvent;
begin
  result := TFhirCompositionEvent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompositionEventList.ClearItems;
begin
  Clear;
end;

function TFhirCompositionEventList.GetEnumerator : TFhirCompositionEventListEnumerator;
begin
  result := TFhirCompositionEventListEnumerator.Create(self.link);
end;

function TFhirCompositionEventList.Clone: TFhirCompositionEventList;
begin
  result := TFhirCompositionEventList(inherited Clone);
end;

function TFhirCompositionEventList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCompositionEventList.GetItemN(index: Integer): TFhirCompositionEvent;
begin
  result := TFhirCompositionEvent(ObjectByIndex[index]);
end;

function TFhirCompositionEventList.ItemClass: TFslObjectClass;
begin
  result := TFhirCompositionEvent;
end;
function TFhirCompositionEventList.IndexOf(value: TFhirCompositionEvent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCompositionEventList.Insert(index: Integer): TFhirCompositionEvent;
begin
  result := TFhirCompositionEvent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompositionEventList.InsertItem(index: Integer; value: TFhirCompositionEvent);
begin
  assert(value is TFhirCompositionEvent);
  Inherited Insert(index, value);
end;

function TFhirCompositionEventList.Item(index: Integer): TFhirCompositionEvent;
begin
  result := TFhirCompositionEvent(ObjectByIndex[index]);
end;

function TFhirCompositionEventList.Link: TFhirCompositionEventList;
begin
  result := TFhirCompositionEventList(inherited Link);
end;

procedure TFhirCompositionEventList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCompositionEventList.SetItemByIndex(index: Integer; value: TFhirCompositionEvent);
begin
  assert(value is TFhirCompositionEvent);
  FhirCompositionEvents[index] := value;
end;

procedure TFhirCompositionEventList.SetItemN(index: Integer; value: TFhirCompositionEvent);
begin
  assert(value is TFhirCompositionEvent);
  ObjectByIndex[index] := value;
end;

{ TFhirCompositionSection }

constructor TFhirCompositionSection.Create;
begin
  inherited;
end;

destructor TFhirCompositionSection.Destroy;
begin
  FTitle.free;
  FCode.free;
  FText.free;
  FMode.free;
  FOrderedBy.free;
  FEntryList.Free;
  FEmptyReason.free;
  FSectionList.Free;
  inherited;
end;

procedure TFhirCompositionSection.Assign(oSource : TFslObject);
begin
  inherited;
  titleElement := TFhirCompositionSection(oSource).titleElement.Clone;
  code := TFhirCompositionSection(oSource).code.Clone;
  text := TFhirCompositionSection(oSource).text.Clone;
  FMode := TFhirCompositionSection(oSource).FMode.Link;
  orderedBy := TFhirCompositionSection(oSource).orderedBy.Clone;
  if (TFhirCompositionSection(oSource).FEntryList = nil) then
  begin
    FEntryList.free;
    FEntryList := nil;
  end
  else
  begin
    if FEntryList = nil then
      FEntryList := TFhirReferenceList{TFhirReference}.Create;
    FEntryList.Assign(TFhirCompositionSection(oSource).FEntryList);
  end;
  emptyReason := TFhirCompositionSection(oSource).emptyReason.Clone;
  if (TFhirCompositionSection(oSource).FSectionList = nil) then
  begin
    FSectionList.free;
    FSectionList := nil;
  end
  else
  begin
    if FSectionList = nil then
      FSectionList := TFhirCompositionSectionList.Create;
    FSectionList.Assign(TFhirCompositionSection(oSource).FSectionList);
  end;
end;

procedure TFhirCompositionSection.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'mode') Then
     list.add(self.link, 'mode', FMode.Link);
  if (child_name = 'orderedBy') Then
     list.add(self.link, 'orderedBy', FOrderedBy.Link);
  if (child_name = 'entry') Then
    list.addAll(self, 'entry', FEntryList);
  if (child_name = 'emptyReason') Then
     list.add(self.link, 'emptyReason', FEmptyReason.Link);
  if (child_name = 'section') Then
    list.addAll(self, 'section', FSectionList);
end;

procedure TFhirCompositionSection.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'text', 'Narrative', false, TFhirNarrative, FText.Link));{2}
  oList.add(TFHIRProperty.create(self, 'mode', 'code', false, TFHIREnum, FMode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'orderedBy', 'CodeableConcept', false, TFhirCodeableConcept, FOrderedBy.Link));{2}
  oList.add(TFHIRProperty.create(self, 'entry', 'Reference(Any)', true, TFhirReference{TFhirReference}, FEntryList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'emptyReason', 'CodeableConcept', false, TFhirCodeableConcept, FEmptyReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'section', '@Composition.section', true, TFhirCompositionSection, FSectionList.Link)){3};
end;

function TFhirCompositionSection.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'title') then
  begin
    TitleElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    Text := propValue as TFhirNarrative{4b};
    result := propValue;
  end
  else if (propName = 'mode') then
  begin
    ModeElement := asEnum(SYSTEMS_TFhirListModeEnum, CODES_TFhirListModeEnum, propValue);
    result := propValue
  end
  else if (propName = 'orderedBy') then
  begin
    OrderedBy := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'entry') then
  begin
    EntryList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'emptyReason') then
  begin
    EmptyReason := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'section') then
  begin
    SectionList.add(propValue as TFhirCompositionSection){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCompositionSection.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'entry') then EntryList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'section') then SectionList.insertItem(index, propValue as TFhirCompositionSection){2a}
  else inherited;
end;

function TFhirCompositionSection.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'title') then result := TFhirString.create() {5b}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'text') then result := TFhirNarrative.create(){4b}
  else if (propName = 'orderedBy') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'entry') then result := EntryList.new(){2}
  else if (propName = 'emptyReason') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'section') then result := SectionList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCompositionSection.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'title') then result := 'string'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'text') then result := 'Narrative'
  else if (propName = 'mode') then result := 'code'
  else if (propName = 'orderedBy') then result := 'CodeableConcept'
  else if (propName = 'entry') then result := 'Reference'
  else if (propName = 'emptyReason') then result := 'CodeableConcept'
  else if (propName = 'section') then result := '@Composition.section'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCompositionSection.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'title') then TitleElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'text') then TextElement := nil
  else if (propName = 'mode') then ModeElement := nil
  else if (propName = 'orderedBy') then OrderedByElement := nil
  else if (propName = 'entry') then deletePropertyValue('entry', EntryList, value) {2}
  else if (propName = 'emptyReason') then EmptyReasonElement := nil
  else if (propName = 'section') then deletePropertyValue('section', SectionList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCompositionSection.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'title') then TitleElement := asString(new){5b}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'text') then TextElement := new as TFhirNarrative{4}
  else if (propName = 'mode') then ModeElement := asEnum(SYSTEMS_TFhirListModeEnum, CODES_TFhirListModeEnum, new){4}
  else if (propName = 'orderedBy') then OrderedByElement := new as TFhirCodeableConcept{4}
  else if (propName = 'entry') then replacePropertyValue('entry', EntryList, existing, new) {2}
  else if (propName = 'emptyReason') then EmptyReasonElement := new as TFhirCodeableConcept{4}
  else if (propName = 'section') then replacePropertyValue('section', SectionList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCompositionSection.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'entry') then EntryList.move(source, destination){2a}
  else if (propName = 'section') then SectionList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCompositionSection.fhirType : string;
begin
  result := 'section';
end;

function TFhirCompositionSection.Link : TFhirCompositionSection;
begin
  result := TFhirCompositionSection(inherited Link);
end;

function TFhirCompositionSection.Clone : TFhirCompositionSection;
begin
  result := TFhirCompositionSection(inherited Clone);
end;

function TFhirCompositionSection.equals(other : TObject) : boolean;
var
  o : TFhirCompositionSection;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCompositionSection)) then
    result := false
  else
  begin
    o := TFhirCompositionSection(other);
    result := compareDeep(titleElement, o.titleElement, true) and compareDeep(codeElement, o.codeElement, true) and
      compareDeep(textElement, o.textElement, true) and compareDeep(modeElement, o.modeElement, true) and
      compareDeep(orderedByElement, o.orderedByElement, true) and compareDeep(entryList, o.entryList, true) and
      compareDeep(emptyReasonElement, o.emptyReasonElement, true) and compareDeep(sectionList, o.sectionList, true);
  end;
end;

function TFhirCompositionSection.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FTitle) and isEmptyProp(FCode) and isEmptyProp(FText) and isEmptyProp(FMode) and isEmptyProp(FOrderedBy) and isEmptyProp(FentryList) and isEmptyProp(FEmptyReason) and isEmptyProp(FsectionList);
end;

procedure TFhirCompositionSection.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('title');
  fields.add('code');
  fields.add('text');
  fields.add('mode');
  fields.add('orderedBy');
  fields.add('entry');
  fields.add('emptyReason');
  fields.add('section');
end;

{ TFhirCompositionSection }

Procedure TFhirCompositionSection.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

Function TFhirCompositionSection.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

Procedure TFhirCompositionSection.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

Procedure TFhirCompositionSection.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirCompositionSection.SetText(value : TFhirNarrative);
begin
  FText.free;
  FText := value;
end;

Procedure TFhirCompositionSection.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

Function TFhirCompositionSection.GetModeST : TFhirListModeEnum;
begin
  if FMode = nil then
    result := TFhirListModeEnum(0)
  else
    result := TFhirListModeEnum(StringArrayIndexOfSensitive(CODES_TFhirListModeEnum, FMode.value));
end;

Procedure TFhirCompositionSection.SetModeST(value : TFhirListModeEnum);
begin
  if ord(value) = 0 then
    ModeElement := nil
  else
    ModeElement := TFhirEnum.create(SYSTEMS_TFhirListModeEnum[value], CODES_TFhirListModeEnum[value]);
end;

Procedure TFhirCompositionSection.SetOrderedBy(value : TFhirCodeableConcept);
begin
  FOrderedBy.free;
  FOrderedBy := value;
end;

Function TFhirCompositionSection.GetEntryList : TFhirReferenceList{TFhirReference};
begin
  if FEntryList = nil then
    FEntryList := TFhirReferenceList{TFhirReference}.Create;
  result := FEntryList;
end;

Function TFhirCompositionSection.GetHasEntryList : boolean;
begin
  result := (FEntryList <> nil) and (FEntryList.count > 0);
end;

Procedure TFhirCompositionSection.SetEmptyReason(value : TFhirCodeableConcept);
begin
  FEmptyReason.free;
  FEmptyReason := value;
end;

Function TFhirCompositionSection.GetSectionList : TFhirCompositionSectionList;
begin
  if FSectionList = nil then
    FSectionList := TFhirCompositionSectionList.Create;
  result := FSectionList;
end;

Function TFhirCompositionSection.GetHasSectionList : boolean;
begin
  result := (FSectionList <> nil) and (FSectionList.count > 0);
end;

function TFhirCompositionSection.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FTitle.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FText.sizeInBytes);
  inc(result, FMode.sizeInBytes);
  inc(result, FOrderedBy.sizeInBytes);
  inc(result, FentryList.sizeInBytes);
  inc(result, FEmptyReason.sizeInBytes);
  inc(result, FsectionList.sizeInBytes);
end;

{ TFhirCompositionSectionListEnumerator }

Constructor TFhirCompositionSectionListEnumerator.Create(list : TFhirCompositionSectionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCompositionSectionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCompositionSectionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCompositionSectionListEnumerator.GetCurrent : TFhirCompositionSection;
begin
  Result := FList[FIndex];
end;

function TFhirCompositionSectionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCompositionSectionList }
procedure TFhirCompositionSectionList.AddItem(value: TFhirCompositionSection);
begin
  assert(value.ClassName = 'TFhirCompositionSection', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCompositionSection');
  add(value);
end;

function TFhirCompositionSectionList.Append: TFhirCompositionSection;
begin
  result := TFhirCompositionSection.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompositionSectionList.ClearItems;
begin
  Clear;
end;

function TFhirCompositionSectionList.GetEnumerator : TFhirCompositionSectionListEnumerator;
begin
  result := TFhirCompositionSectionListEnumerator.Create(self.link);
end;

function TFhirCompositionSectionList.Clone: TFhirCompositionSectionList;
begin
  result := TFhirCompositionSectionList(inherited Clone);
end;

function TFhirCompositionSectionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCompositionSectionList.GetItemN(index: Integer): TFhirCompositionSection;
begin
  result := TFhirCompositionSection(ObjectByIndex[index]);
end;

function TFhirCompositionSectionList.ItemClass: TFslObjectClass;
begin
  result := TFhirCompositionSection;
end;
function TFhirCompositionSectionList.IndexOf(value: TFhirCompositionSection): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCompositionSectionList.Insert(index: Integer): TFhirCompositionSection;
begin
  result := TFhirCompositionSection.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompositionSectionList.InsertItem(index: Integer; value: TFhirCompositionSection);
begin
  assert(value is TFhirCompositionSection);
  Inherited Insert(index, value);
end;

function TFhirCompositionSectionList.Item(index: Integer): TFhirCompositionSection;
begin
  result := TFhirCompositionSection(ObjectByIndex[index]);
end;

function TFhirCompositionSectionList.Link: TFhirCompositionSectionList;
begin
  result := TFhirCompositionSectionList(inherited Link);
end;

procedure TFhirCompositionSectionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCompositionSectionList.SetItemByIndex(index: Integer; value: TFhirCompositionSection);
begin
  assert(value is TFhirCompositionSection);
  FhirCompositionSections[index] := value;
end;

procedure TFhirCompositionSectionList.SetItemN(index: Integer; value: TFhirCompositionSection);
begin
  assert(value is TFhirCompositionSection);
  ObjectByIndex[index] := value;
end;

{ TFhirComposition }

constructor TFhirComposition.Create;
begin
  inherited;
end;

destructor TFhirComposition.Destroy;
begin
  FIdentifier.free;
  FDate.free;
  FType_.free;
  FClass_.free;
  FTitle.free;
  FStatus.free;
  FConfidentiality.free;
  FSubject.free;
  FAuthorList.Free;
  FAttesterList.Free;
  FCustodian.free;
  FEventList.Free;
  FEncounter.free;
  FSectionList.Free;
  inherited;
end;

function TFhirComposition.GetResourceType : TFhirResourceType;
begin
  result := frtComposition;
end;

procedure TFhirComposition.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirComposition(oSource).identifier.Clone;
  dateElement := TFhirComposition(oSource).dateElement.Clone;
  type_ := TFhirComposition(oSource).type_.Clone;
  class_ := TFhirComposition(oSource).class_.Clone;
  titleElement := TFhirComposition(oSource).titleElement.Clone;
  FStatus := TFhirComposition(oSource).FStatus.Link;
  FConfidentiality := TFhirComposition(oSource).FConfidentiality.Link;
  subject := TFhirComposition(oSource).subject.Clone;
  if (TFhirComposition(oSource).FAuthorList = nil) then
  begin
    FAuthorList.free;
    FAuthorList := nil;
  end
  else
  begin
    if FAuthorList = nil then
      FAuthorList := TFhirReferenceList{Resource}.Create;
    FAuthorList.Assign(TFhirComposition(oSource).FAuthorList);
  end;
  if (TFhirComposition(oSource).FAttesterList = nil) then
  begin
    FAttesterList.free;
    FAttesterList := nil;
  end
  else
  begin
    if FAttesterList = nil then
      FAttesterList := TFhirCompositionAttesterList.Create;
    FAttesterList.Assign(TFhirComposition(oSource).FAttesterList);
  end;
  custodian := TFhirComposition(oSource).custodian.Clone;
  if (TFhirComposition(oSource).FEventList = nil) then
  begin
    FEventList.free;
    FEventList := nil;
  end
  else
  begin
    if FEventList = nil then
      FEventList := TFhirCompositionEventList.Create;
    FEventList.Assign(TFhirComposition(oSource).FEventList);
  end;
  encounter := TFhirComposition(oSource).encounter.Clone;
  if (TFhirComposition(oSource).FSectionList = nil) then
  begin
    FSectionList.free;
    FSectionList := nil;
  end
  else
  begin
    if FSectionList = nil then
      FSectionList := TFhirCompositionSectionList.Create;
    FSectionList.Assign(TFhirComposition(oSource).FSectionList);
  end;
end;

procedure TFhirComposition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'class') Then
     list.add(self.link, 'class', FClass_.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'confidentiality') Then
     list.add(self.link, 'confidentiality', FConfidentiality.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'author') Then
    list.addAll(self, 'author', FAuthorList);
  if (child_name = 'attester') Then
    list.addAll(self, 'attester', FAttesterList);
  if (child_name = 'custodian') Then
     list.add(self.link, 'custodian', FCustodian.Link);
  if (child_name = 'event') Then
    list.addAll(self, 'event', FEventList);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'section') Then
    list.addAll(self, 'section', FSectionList);
end;

procedure TFhirComposition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'class', 'CodeableConcept', false, TFhirCodeableConcept, FClass_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'confidentiality', 'code', false, TFHIREnum, FConfidentiality.Link));{1}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Any)', false, TFhirReference{TFhirReference}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'author', 'Reference(Practitioner|Device|Patient|RelatedPerson)', true, TFhirReference{Resource}, FAuthorList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'attester', '', true, TFhirCompositionAttester, FAttesterList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'custodian', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FCustodian.Link));{2}
  oList.add(TFHIRProperty.create(self, 'event', '', true, TFhirCompositionEvent, FEventList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference(Encounter)', false, TFhirReference{TFhirEncounter}, FEncounter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'section', '', true, TFhirCompositionSection, FSectionList.Link)){3};
end;

function TFhirComposition.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'class') then
  begin
    Class_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirCompositionStatusEnum, CODES_TFhirCompositionStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'confidentiality') then
  begin
    ConfidentialityElement := asEnum(SYSTEMS_TFhirV3ConfidentialityEnum, CODES_TFhirV3ConfidentialityEnum, propValue);
    result := propValue
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    AuthorList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'attester') then
  begin
    AttesterList.add(propValue as TFhirCompositionAttester){2a};
    result := propValue;
  end
  else if (propName = 'custodian') then
  begin
    Custodian := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'event') then
  begin
    EventList.add(propValue as TFhirCompositionEvent){2a};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference{TFhirEncounter}{4b};
    result := propValue;
  end
  else if (propName = 'section') then
  begin
    SectionList.add(propValue as TFhirCompositionSection){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirComposition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'author') then AuthorList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'attester') then AttesterList.insertItem(index, propValue as TFhirCompositionAttester){2a}
  else if (propName = 'event') then EventList.insertItem(index, propValue as TFhirCompositionEvent){2a}
  else if (propName = 'section') then SectionList.insertItem(index, propValue as TFhirCompositionSection){2a}
  else inherited;
end;

function TFhirComposition.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'class') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'title') then result := TFhirString.create() {5b}
  else if (propName = 'subject') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'author') then result := AuthorList.new(){2}
  else if (propName = 'attester') then result := AttesterList.new(){2}
  else if (propName = 'custodian') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'event') then result := EventList.new(){2}
  else if (propName = 'encounter') then result := TFhirReference{TFhirEncounter}.create(){4b}
  else if (propName = 'section') then result := SectionList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirComposition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'class') then result := 'CodeableConcept'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'confidentiality') then result := 'code'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'attester') then result := ''
  else if (propName = 'custodian') then result := 'Reference'
  else if (propName = 'event') then result := ''
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'section') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirComposition.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'class') then Class_Element := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'confidentiality') then ConfidentialityElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'author') then deletePropertyValue('author', AuthorList, value) {2}
  else if (propName = 'attester') then deletePropertyValue('attester', AttesterList, value) {2}
  else if (propName = 'custodian') then CustodianElement := nil
  else if (propName = 'event') then deletePropertyValue('event', EventList, value) {2}
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'section') then deletePropertyValue('section', SectionList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirComposition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'class') then Class_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'title') then TitleElement := asString(new){5b}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirCompositionStatusEnum, CODES_TFhirCompositionStatusEnum, new){4}
  else if (propName = 'confidentiality') then ConfidentialityElement := asEnum(SYSTEMS_TFhirV3ConfidentialityEnum, CODES_TFhirV3ConfidentialityEnum, new){4}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'author') then replacePropertyValue('author', AuthorList, existing, new) {2}
  else if (propName = 'attester') then replacePropertyValue('attester', AttesterList, existing, new) {2}
  else if (propName = 'custodian') then CustodianElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'event') then replacePropertyValue('event', EventList, existing, new) {2}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference{TFhirEncounter}{4}
  else if (propName = 'section') then replacePropertyValue('section', SectionList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirComposition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'author') then AuthorList.move(source, destination){2a}
  else if (propName = 'attester') then AttesterList.move(source, destination){2a}
  else if (propName = 'event') then EventList.move(source, destination){2a}
  else if (propName = 'section') then SectionList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirComposition.fhirType : string;
begin
  result := 'Composition';
end;

function TFhirComposition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FDate) and isEmptyProp(FType_) and isEmptyProp(FClass_) and isEmptyProp(FTitle) and isEmptyProp(FStatus) and isEmptyProp(FConfidentiality) and isEmptyProp(FSubject) and isEmptyProp(FauthorList) and isEmptyProp(FattesterList) and isEmptyProp(FCustodian) and isEmptyProp(FeventList) and isEmptyProp(FEncounter) and isEmptyProp(FsectionList);
end;

function TFhirComposition.equals(other : TObject) : boolean;
var
  o : TFhirComposition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirComposition)) then
    result := false
  else
  begin
    o := TFhirComposition(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(dateElement, o.dateElement, true) and
      compareDeep(type_Element, o.type_Element, true) and compareDeep(class_Element, o.class_Element, true) and
      compareDeep(titleElement, o.titleElement, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(confidentialityElement, o.confidentialityElement, true) and compareDeep(subjectElement, o.subjectElement, true) and
      compareDeep(authorList, o.authorList, true) and compareDeep(attesterList, o.attesterList, true) and
      compareDeep(custodianElement, o.custodianElement, true) and compareDeep(eventList, o.eventList, true) and
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(sectionList, o.sectionList, true);
  end;
end;

function TFhirComposition.Link : TFhirComposition;
begin
  result := TFhirComposition(inherited Link);
end;

function TFhirComposition.Clone : TFhirComposition;
begin
  result := TFhirComposition(inherited Clone);
end;

procedure TFhirComposition.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('date');
  fields.add('type');
  fields.add('class');
  fields.add('title');
  fields.add('status');
  fields.add('confidentiality');
  fields.add('subject');
  fields.add('author');
  fields.add('attester');
  fields.add('custodian');
  fields.add('event');
  fields.add('encounter');
  fields.add('section');
end;

{ TFhirComposition }

Procedure TFhirComposition.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirComposition.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirComposition.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirComposition.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirComposition.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirComposition.SetClass_(value : TFhirCodeableConcept);
begin
  FClass_.free;
  FClass_ := value;
end;

Procedure TFhirComposition.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

Function TFhirComposition.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

Procedure TFhirComposition.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

Procedure TFhirComposition.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirComposition.GetStatusST : TFhirCompositionStatusEnum;
begin
  if FStatus = nil then
    result := TFhirCompositionStatusEnum(0)
  else
    result := TFhirCompositionStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirCompositionStatusEnum, FStatus.value));
end;

Procedure TFhirComposition.SetStatusST(value : TFhirCompositionStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirCompositionStatusEnum[value], CODES_TFhirCompositionStatusEnum[value]);
end;

Procedure TFhirComposition.SetConfidentiality(value : TFhirEnum);
begin
  FConfidentiality.free;
  FConfidentiality := value;
end;

Function TFhirComposition.GetConfidentialityST : TFhirV3ConfidentialityEnum;
begin
  if FConfidentiality = nil then
    result := TFhirV3ConfidentialityEnum(0)
  else
    result := TFhirV3ConfidentialityEnum(StringArrayIndexOfSensitive(CODES_TFhirV3ConfidentialityEnum, FConfidentiality.value));
end;

Procedure TFhirComposition.SetConfidentialityST(value : TFhirV3ConfidentialityEnum);
begin
  if ord(value) = 0 then
    ConfidentialityElement := nil
  else
    ConfidentialityElement := TFhirEnum.create(SYSTEMS_TFhirV3ConfidentialityEnum[value], CODES_TFhirV3ConfidentialityEnum[value]);
end;

Procedure TFhirComposition.SetSubject(value : TFhirReference{TFhirReference});
begin
  FSubject.free;
  FSubject := value;
end;

Function TFhirComposition.GetAuthorList : TFhirReferenceList{Resource};
begin
  if FAuthorList = nil then
    FAuthorList := TFhirReferenceList{Resource}.Create;
  result := FAuthorList;
end;

Function TFhirComposition.GetHasAuthorList : boolean;
begin
  result := (FAuthorList <> nil) and (FAuthorList.count > 0);
end;

Function TFhirComposition.GetAttesterList : TFhirCompositionAttesterList;
begin
  if FAttesterList = nil then
    FAttesterList := TFhirCompositionAttesterList.Create;
  result := FAttesterList;
end;

Function TFhirComposition.GetHasAttesterList : boolean;
begin
  result := (FAttesterList <> nil) and (FAttesterList.count > 0);
end;

Procedure TFhirComposition.SetCustodian(value : TFhirReference{TFhirOrganization});
begin
  FCustodian.free;
  FCustodian := value;
end;

Function TFhirComposition.GetEventList : TFhirCompositionEventList;
begin
  if FEventList = nil then
    FEventList := TFhirCompositionEventList.Create;
  result := FEventList;
end;

Function TFhirComposition.GetHasEventList : boolean;
begin
  result := (FEventList <> nil) and (FEventList.count > 0);
end;

Procedure TFhirComposition.SetEncounter(value : TFhirReference{TFhirEncounter});
begin
  FEncounter.free;
  FEncounter := value;
end;

Function TFhirComposition.GetSectionList : TFhirCompositionSectionList;
begin
  if FSectionList = nil then
    FSectionList := TFhirCompositionSectionList.Create;
  result := FSectionList;
end;

Function TFhirComposition.GetHasSectionList : boolean;
begin
  result := (FSectionList <> nil) and (FSectionList.count > 0);
end;

function TFhirComposition.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FClass_.sizeInBytes);
  inc(result, FTitle.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FConfidentiality.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FauthorList.sizeInBytes);
  inc(result, FattesterList.sizeInBytes);
  inc(result, FCustodian.sizeInBytes);
  inc(result, FeventList.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FsectionList.sizeInBytes);
end;

{ TFhirCompositionListEnumerator }

Constructor TFhirCompositionListEnumerator.Create(list : TFhirCompositionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCompositionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCompositionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCompositionListEnumerator.GetCurrent : TFhirComposition;
begin
  Result := FList[FIndex];
end;

function TFhirCompositionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCompositionList }
procedure TFhirCompositionList.AddItem(value: TFhirComposition);
begin
  assert(value.ClassName = 'TFhirComposition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirComposition');
  add(value);
end;

function TFhirCompositionList.Append: TFhirComposition;
begin
  result := TFhirComposition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompositionList.ClearItems;
begin
  Clear;
end;

function TFhirCompositionList.GetEnumerator : TFhirCompositionListEnumerator;
begin
  result := TFhirCompositionListEnumerator.Create(self.link);
end;

function TFhirCompositionList.Clone: TFhirCompositionList;
begin
  result := TFhirCompositionList(inherited Clone);
end;

function TFhirCompositionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCompositionList.GetItemN(index: Integer): TFhirComposition;
begin
  result := TFhirComposition(ObjectByIndex[index]);
end;

function TFhirCompositionList.ItemClass: TFslObjectClass;
begin
  result := TFhirComposition;
end;
function TFhirCompositionList.IndexOf(value: TFhirComposition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCompositionList.Insert(index: Integer): TFhirComposition;
begin
  result := TFhirComposition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompositionList.InsertItem(index: Integer; value: TFhirComposition);
begin
  assert(value is TFhirComposition);
  Inherited Insert(index, value);
end;

function TFhirCompositionList.Item(index: Integer): TFhirComposition;
begin
  result := TFhirComposition(ObjectByIndex[index]);
end;

function TFhirCompositionList.Link: TFhirCompositionList;
begin
  result := TFhirCompositionList(inherited Link);
end;

procedure TFhirCompositionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCompositionList.SetItemByIndex(index: Integer; value: TFhirComposition);
begin
  assert(value is TFhirComposition);
  FhirCompositions[index] := value;
end;

procedure TFhirCompositionList.SetItemN(index: Integer; value: TFhirComposition);
begin
  assert(value is TFhirComposition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_COMPOSITION}

{$IFDEF FHIR_CONDITION}

{ TFhirConditionStage }

constructor TFhirConditionStage.Create;
begin
  inherited;
end;

destructor TFhirConditionStage.Destroy;
begin
  FSummary.free;
  FAssessmentList.Free;
  inherited;
end;

procedure TFhirConditionStage.Assign(oSource : TFslObject);
begin
  inherited;
  summary := TFhirConditionStage(oSource).summary.Clone;
  if (TFhirConditionStage(oSource).FAssessmentList = nil) then
  begin
    FAssessmentList.free;
    FAssessmentList := nil;
  end
  else
  begin
    if FAssessmentList = nil then
      FAssessmentList := TFhirReferenceList{Resource}.Create;
    FAssessmentList.Assign(TFhirConditionStage(oSource).FAssessmentList);
  end;
end;

procedure TFhirConditionStage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'summary') Then
     list.add(self.link, 'summary', FSummary.Link);
  if (child_name = 'assessment') Then
    list.addAll(self, 'assessment', FAssessmentList);
end;

procedure TFhirConditionStage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'summary', 'CodeableConcept', false, TFhirCodeableConcept, FSummary.Link));{2}
  oList.add(TFHIRProperty.create(self, 'assessment', 'Reference(ClinicalImpression|DiagnosticReport|Observation)', true, TFhirReference{Resource}, FAssessmentList.Link)){3};
end;

function TFhirConditionStage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'summary') then
  begin
    Summary := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'assessment') then
  begin
    AssessmentList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConditionStage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'assessment') then AssessmentList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else inherited;
end;

function TFhirConditionStage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'summary') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'assessment') then result := AssessmentList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConditionStage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'summary') then result := 'CodeableConcept'
  else if (propName = 'assessment') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConditionStage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'summary') then SummaryElement := nil
  else if (propName = 'assessment') then deletePropertyValue('assessment', AssessmentList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConditionStage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'summary') then SummaryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'assessment') then replacePropertyValue('assessment', AssessmentList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConditionStage.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'assessment') then AssessmentList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirConditionStage.fhirType : string;
begin
  result := 'stage';
end;

function TFhirConditionStage.Link : TFhirConditionStage;
begin
  result := TFhirConditionStage(inherited Link);
end;

function TFhirConditionStage.Clone : TFhirConditionStage;
begin
  result := TFhirConditionStage(inherited Clone);
end;

function TFhirConditionStage.equals(other : TObject) : boolean;
var
  o : TFhirConditionStage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConditionStage)) then
    result := false
  else
  begin
    o := TFhirConditionStage(other);
    result := compareDeep(summaryElement, o.summaryElement, true) and compareDeep(assessmentList, o.assessmentList, true);
  end;
end;

function TFhirConditionStage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSummary) and isEmptyProp(FassessmentList);
end;

procedure TFhirConditionStage.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('summary');
  fields.add('assessment');
end;

{ TFhirConditionStage }

Procedure TFhirConditionStage.SetSummary(value : TFhirCodeableConcept);
begin
  FSummary.free;
  FSummary := value;
end;

Function TFhirConditionStage.GetAssessmentList : TFhirReferenceList{Resource};
begin
  if FAssessmentList = nil then
    FAssessmentList := TFhirReferenceList{Resource}.Create;
  result := FAssessmentList;
end;

Function TFhirConditionStage.GetHasAssessmentList : boolean;
begin
  result := (FAssessmentList <> nil) and (FAssessmentList.count > 0);
end;

function TFhirConditionStage.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSummary.sizeInBytes);
  inc(result, FassessmentList.sizeInBytes);
end;

{ TFhirConditionStageListEnumerator }

Constructor TFhirConditionStageListEnumerator.Create(list : TFhirConditionStageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConditionStageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConditionStageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConditionStageListEnumerator.GetCurrent : TFhirConditionStage;
begin
  Result := FList[FIndex];
end;

function TFhirConditionStageListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConditionStageList }
procedure TFhirConditionStageList.AddItem(value: TFhirConditionStage);
begin
  assert(value.ClassName = 'TFhirConditionStage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConditionStage');
  add(value);
end;

function TFhirConditionStageList.Append: TFhirConditionStage;
begin
  result := TFhirConditionStage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConditionStageList.ClearItems;
begin
  Clear;
end;

function TFhirConditionStageList.GetEnumerator : TFhirConditionStageListEnumerator;
begin
  result := TFhirConditionStageListEnumerator.Create(self.link);
end;

function TFhirConditionStageList.Clone: TFhirConditionStageList;
begin
  result := TFhirConditionStageList(inherited Clone);
end;

function TFhirConditionStageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConditionStageList.GetItemN(index: Integer): TFhirConditionStage;
begin
  result := TFhirConditionStage(ObjectByIndex[index]);
end;

function TFhirConditionStageList.ItemClass: TFslObjectClass;
begin
  result := TFhirConditionStage;
end;
function TFhirConditionStageList.IndexOf(value: TFhirConditionStage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConditionStageList.Insert(index: Integer): TFhirConditionStage;
begin
  result := TFhirConditionStage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConditionStageList.InsertItem(index: Integer; value: TFhirConditionStage);
begin
  assert(value is TFhirConditionStage);
  Inherited Insert(index, value);
end;

function TFhirConditionStageList.Item(index: Integer): TFhirConditionStage;
begin
  result := TFhirConditionStage(ObjectByIndex[index]);
end;

function TFhirConditionStageList.Link: TFhirConditionStageList;
begin
  result := TFhirConditionStageList(inherited Link);
end;

procedure TFhirConditionStageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConditionStageList.SetItemByIndex(index: Integer; value: TFhirConditionStage);
begin
  assert(value is TFhirConditionStage);
  FhirConditionStages[index] := value;
end;

procedure TFhirConditionStageList.SetItemN(index: Integer; value: TFhirConditionStage);
begin
  assert(value is TFhirConditionStage);
  ObjectByIndex[index] := value;
end;

{ TFhirConditionEvidence }

constructor TFhirConditionEvidence.Create;
begin
  inherited;
end;

destructor TFhirConditionEvidence.Destroy;
begin
  FCode.free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirConditionEvidence.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirConditionEvidence(oSource).code.Clone;
  if (TFhirConditionEvidence(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirReferenceList{TFhirReference}.Create;
    FDetailList.Assign(TFhirConditionEvidence(oSource).FDetailList);
  end;
end;

procedure TFhirConditionEvidence.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
end;

procedure TFhirConditionEvidence.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'detail', 'Reference(Any)', true, TFhirReference{TFhirReference}, FDetailList.Link)){3};
end;

function TFhirConditionEvidence.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConditionEvidence.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else inherited;
end;

function TFhirConditionEvidence.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'detail') then result := DetailList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConditionEvidence.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'detail') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConditionEvidence.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConditionEvidence.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConditionEvidence.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'detail') then DetailList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirConditionEvidence.fhirType : string;
begin
  result := 'evidence';
end;

function TFhirConditionEvidence.Link : TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence(inherited Link);
end;

function TFhirConditionEvidence.Clone : TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence(inherited Clone);
end;

function TFhirConditionEvidence.equals(other : TObject) : boolean;
var
  o : TFhirConditionEvidence;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConditionEvidence)) then
    result := false
  else
  begin
    o := TFhirConditionEvidence(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(detailList, o.detailList, true);
  end;
end;

function TFhirConditionEvidence.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FdetailList);
end;

procedure TFhirConditionEvidence.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('detail');
end;

{ TFhirConditionEvidence }

Procedure TFhirConditionEvidence.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirConditionEvidence.GetDetailList : TFhirReferenceList{TFhirReference};
begin
  if FDetailList = nil then
    FDetailList := TFhirReferenceList{TFhirReference}.Create;
  result := FDetailList;
end;

Function TFhirConditionEvidence.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

function TFhirConditionEvidence.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FdetailList.sizeInBytes);
end;

{ TFhirConditionEvidenceListEnumerator }

Constructor TFhirConditionEvidenceListEnumerator.Create(list : TFhirConditionEvidenceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConditionEvidenceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConditionEvidenceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConditionEvidenceListEnumerator.GetCurrent : TFhirConditionEvidence;
begin
  Result := FList[FIndex];
end;

function TFhirConditionEvidenceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConditionEvidenceList }
procedure TFhirConditionEvidenceList.AddItem(value: TFhirConditionEvidence);
begin
  assert(value.ClassName = 'TFhirConditionEvidence', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConditionEvidence');
  add(value);
end;

function TFhirConditionEvidenceList.Append: TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConditionEvidenceList.ClearItems;
begin
  Clear;
end;

function TFhirConditionEvidenceList.GetEnumerator : TFhirConditionEvidenceListEnumerator;
begin
  result := TFhirConditionEvidenceListEnumerator.Create(self.link);
end;

function TFhirConditionEvidenceList.Clone: TFhirConditionEvidenceList;
begin
  result := TFhirConditionEvidenceList(inherited Clone);
end;

function TFhirConditionEvidenceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConditionEvidenceList.GetItemN(index: Integer): TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence(ObjectByIndex[index]);
end;

function TFhirConditionEvidenceList.ItemClass: TFslObjectClass;
begin
  result := TFhirConditionEvidence;
end;
function TFhirConditionEvidenceList.IndexOf(value: TFhirConditionEvidence): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConditionEvidenceList.Insert(index: Integer): TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConditionEvidenceList.InsertItem(index: Integer; value: TFhirConditionEvidence);
begin
  assert(value is TFhirConditionEvidence);
  Inherited Insert(index, value);
end;

function TFhirConditionEvidenceList.Item(index: Integer): TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence(ObjectByIndex[index]);
end;

function TFhirConditionEvidenceList.Link: TFhirConditionEvidenceList;
begin
  result := TFhirConditionEvidenceList(inherited Link);
end;

procedure TFhirConditionEvidenceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConditionEvidenceList.SetItemByIndex(index: Integer; value: TFhirConditionEvidence);
begin
  assert(value is TFhirConditionEvidence);
  FhirConditionEvidences[index] := value;
end;

procedure TFhirConditionEvidenceList.SetItemN(index: Integer; value: TFhirConditionEvidence);
begin
  assert(value is TFhirConditionEvidence);
  ObjectByIndex[index] := value;
end;

{ TFhirCondition }

constructor TFhirCondition.Create;
begin
  inherited;
end;

destructor TFhirCondition.Destroy;
begin
  FIdentifierList.Free;
  FPatient.free;
  FEncounter.free;
  FAsserter.free;
  FDateRecorded.free;
  FCode.free;
  FCategory.free;
  FClinicalStatus.free;
  FVerificationStatus.free;
  FSeverity.free;
  FOnset.free;
  FAbatement.free;
  FStage.free;
  FEvidenceList.Free;
  FBodySiteList.Free;
  FNotes.free;
  inherited;
end;

function TFhirCondition.GetResourceType : TFhirResourceType;
begin
  result := frtCondition;
end;

procedure TFhirCondition.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCondition(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirCondition(oSource).FIdentifierList);
  end;
  patient := TFhirCondition(oSource).patient.Clone;
  encounter := TFhirCondition(oSource).encounter.Clone;
  asserter := TFhirCondition(oSource).asserter.Clone;
  dateRecordedElement := TFhirCondition(oSource).dateRecordedElement.Clone;
  code := TFhirCondition(oSource).code.Clone;
  category := TFhirCondition(oSource).category.Clone;
  clinicalStatusElement := TFhirCondition(oSource).clinicalStatusElement.Clone;
  FVerificationStatus := TFhirCondition(oSource).FVerificationStatus.Link;
  severity := TFhirCondition(oSource).severity.Clone;
  onset := TFhirCondition(oSource).onset.Clone;
  abatement := TFhirCondition(oSource).abatement.Clone;
  stage := TFhirCondition(oSource).stage.Clone;
  if (TFhirCondition(oSource).FEvidenceList = nil) then
  begin
    FEvidenceList.free;
    FEvidenceList := nil;
  end
  else
  begin
    if FEvidenceList = nil then
      FEvidenceList := TFhirConditionEvidenceList.Create;
    FEvidenceList.Assign(TFhirCondition(oSource).FEvidenceList);
  end;
  if (TFhirCondition(oSource).FBodySiteList = nil) then
  begin
    FBodySiteList.free;
    FBodySiteList := nil;
  end
  else
  begin
    if FBodySiteList = nil then
      FBodySiteList := TFhirCodeableConceptList.Create;
    FBodySiteList.Assign(TFhirCondition(oSource).FBodySiteList);
  end;
  notesElement := TFhirCondition(oSource).notesElement.Clone;
end;

procedure TFhirCondition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'asserter') Then
     list.add(self.link, 'asserter', FAsserter.Link);
  if (child_name = 'dateRecorded') Then
     list.add(self.link, 'dateRecorded', FDateRecorded.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'clinicalStatus') Then
     list.add(self.link, 'clinicalStatus', FClinicalStatus.Link);
  if (child_name = 'verificationStatus') Then
     list.add(self.link, 'verificationStatus', FVerificationStatus.Link);
  if (child_name = 'severity') Then
     list.add(self.link, 'severity', FSeverity.Link);
  if (child_name = 'onset[x]') or (child_name = 'onset') Then
     list.add(self.link, 'onset[x]', FOnset.Link);
  if (child_name = 'abatement[x]') or (child_name = 'abatement') Then
     list.add(self.link, 'abatement[x]', FAbatement.Link);
  if (child_name = 'stage') Then
     list.add(self.link, 'stage', FStage.Link);
  if (child_name = 'evidence') Then
    list.addAll(self, 'evidence', FEvidenceList);
  if (child_name = 'bodySite') Then
    list.addAll(self, 'bodySite', FBodySiteList);
  if (child_name = 'notes') Then
     list.add(self.link, 'notes', FNotes.Link);
end;

procedure TFhirCondition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference(Encounter)', false, TFhirReference{TFhirEncounter}, FEncounter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'asserter', 'Reference(Practitioner|Patient)', false, TFhirReference{Resource}, FAsserter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dateRecorded', 'date', false, TFhirDate, FDateRecorded.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'clinicalStatus', 'code', false, TFhirCode, FClinicalStatus.Link));{2}
  oList.add(TFHIRProperty.create(self, 'verificationStatus', 'code', false, TFHIREnum, FVerificationStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'severity', 'CodeableConcept', false, TFhirCodeableConcept, FSeverity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'onset[x]', 'dateTime|Quantity|Period|Range|string', false, TFhirType, FOnset.Link));{2}
  oList.add(TFHIRProperty.create(self, 'abatement[x]', 'dateTime|Quantity|boolean|Period|Range|string', false, TFhirType, FAbatement.Link));{2}
  oList.add(TFHIRProperty.create(self, 'stage', '', false, TFhirConditionStage, FStage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'evidence', '', true, TFhirConditionEvidence, FEvidenceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', true, TFhirCodeableConcept, FBodySiteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'notes', 'string', false, TFhirString, FNotes.Link));{2}
end;

function TFhirCondition.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference{TFhirEncounter}{4b};
    result := propValue;
  end
  else if (propName = 'asserter') then
  begin
    Asserter := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'dateRecorded') then
  begin
    DateRecordedElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'clinicalStatus') then
  begin
    ClinicalStatusElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'verificationStatus') then
  begin
    VerificationStatusElement := asEnum(SYSTEMS_TFhirConditionVerStatusEnum, CODES_TFhirConditionVerStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'severity') then
  begin
    Severity := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'onset', ['DateTime', 'Quantity', 'Period', 'Range', 'String'])) then
  begin
    Onset := propValue as TFhirType{4};
    result := propValue;
  end
  else if (isMatchingName(propName, 'abatement', ['DateTime', 'Quantity', 'Boolean', 'Period', 'Range', 'String'])) then
  begin
    Abatement := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'stage') then
  begin
    Stage := propValue as TFhirConditionStage{4b};
    result := propValue;
  end
  else if (propName = 'evidence') then
  begin
    EvidenceList.add(propValue as TFhirConditionEvidence){2a};
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySiteList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'notes') then
  begin
    NotesElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirCondition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'evidence') then EvidenceList.insertItem(index, propValue as TFhirConditionEvidence){2a}
  else if (propName = 'bodySite') then BodySiteList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirCondition.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'encounter') then result := TFhirReference{TFhirEncounter}.create(){4b}
  else if (propName = 'asserter') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'dateRecorded') then result := TFhirDate.create() {5b}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'clinicalStatus') then result := TFhirCode.create() {5b}
  else if (propName = 'severity') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'onset', ['DateTime', 'Quantity', 'Period', 'Range', 'String'])) then raise EFHIRException.create('Cannot make property Onset'){4x}
  else if (isMatchingName(propName, 'abatement', ['DateTime', 'Quantity', 'Boolean', 'Period', 'Range', 'String'])) then raise EFHIRException.create('Cannot make property Abatement'){4x}
  else if (propName = 'stage') then result := TFhirConditionStage.create(){4b}
  else if (propName = 'evidence') then result := EvidenceList.new(){2}
  else if (propName = 'bodySite') then result := BodySiteList.new(){2}
  else if (propName = 'notes') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCondition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'asserter') then result := 'Reference'
  else if (propName = 'dateRecorded') then result := 'date'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'clinicalStatus') then result := 'code'
  else if (propName = 'verificationStatus') then result := 'code'
  else if (propName = 'severity') then result := 'CodeableConcept'
  else if (propName = 'onset[x]') then result := 'dateTime|Quantity|Period|Range|string'
  else if (propName = 'abatement[x]') then result := 'dateTime|Quantity|boolean|Period|Range|string'
  else if (propName = 'stage') then result := ''
  else if (propName = 'evidence') then result := ''
  else if (propName = 'bodySite') then result := 'CodeableConcept'
  else if (propName = 'notes') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCondition.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'asserter') then AsserterElement := nil
  else if (propName = 'dateRecorded') then DateRecordedElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'clinicalStatus') then ClinicalStatusElement := nil
  else if (propName = 'verificationStatus') then VerificationStatusElement := nil
  else if (propName = 'severity') then SeverityElement := nil
  else if (isMatchingName(propName, 'onset', ['DateTime', 'Quantity', 'Period', 'Range', 'String'])) then OnsetElement := nil{4x}
  else if (isMatchingName(propName, 'abatement', ['DateTime', 'Quantity', 'Boolean', 'Period', 'Range', 'String'])) then AbatementElement := nil{4x}
  else if (propName = 'stage') then StageElement := nil
  else if (propName = 'evidence') then deletePropertyValue('evidence', EvidenceList, value) {2}
  else if (propName = 'bodySite') then deletePropertyValue('bodySite', BodySiteList, value) {2}
  else if (propName = 'notes') then NotesElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCondition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference{TFhirEncounter}{4}
  else if (propName = 'asserter') then AsserterElement := new as TFhirReference{Resource}{4}
  else if (propName = 'dateRecorded') then DateRecordedElement := asDate(new){5b}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'clinicalStatus') then ClinicalStatusElement := asCode(new){5b}
  else if (propName = 'verificationStatus') then VerificationStatusElement := asEnum(SYSTEMS_TFhirConditionVerStatusEnum, CODES_TFhirConditionVerStatusEnum, new){4}
  else if (propName = 'severity') then SeverityElement := new as TFhirCodeableConcept{4}
  else if (isMatchingName(propName, 'onset', ['DateTime', 'Quantity', 'Period', 'Range', 'String'])) then OnsetElement := new as TFhirType{4x}
  else if (isMatchingName(propName, 'abatement', ['DateTime', 'Quantity', 'Boolean', 'Period', 'Range', 'String'])) then AbatementElement := new as TFhirType{4x}
  else if (propName = 'stage') then StageElement := new as TFhirConditionStage{4}
  else if (propName = 'evidence') then replacePropertyValue('evidence', EvidenceList, existing, new) {2}
  else if (propName = 'bodySite') then replacePropertyValue('bodySite', BodySiteList, existing, new) {2}
  else if (propName = 'notes') then NotesElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCondition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'evidence') then EvidenceList.move(source, destination){2a}
  else if (propName = 'bodySite') then BodySiteList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCondition.fhirType : string;
begin
  result := 'Condition';
end;

function TFhirCondition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FPatient) and isEmptyProp(FEncounter) and isEmptyProp(FAsserter) and isEmptyProp(FDateRecorded) and isEmptyProp(FCode) and isEmptyProp(FCategory) and isEmptyProp(FClinicalStatus) and isEmptyProp(FVerificationStatus) and isEmptyProp(FSeverity) and isEmptyProp(FOnset) and isEmptyProp(FAbatement) and isEmptyProp(FStage) and isEmptyProp(FevidenceList) and isEmptyProp(FbodySiteList) and isEmptyProp(FNotes);
end;

function TFhirCondition.equals(other : TObject) : boolean;
var
  o : TFhirCondition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCondition)) then
    result := false
  else
  begin
    o := TFhirCondition(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(patientElement, o.patientElement, true) and
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(asserterElement, o.asserterElement, true) and
      compareDeep(dateRecordedElement, o.dateRecordedElement, true) and compareDeep(codeElement, o.codeElement, true) and
      compareDeep(categoryElement, o.categoryElement, true) and compareDeep(clinicalStatusElement, o.clinicalStatusElement, true) and
      compareDeep(verificationStatusElement, o.verificationStatusElement, true) and
      compareDeep(severityElement, o.severityElement, true) and compareDeep(onsetElement, o.onsetElement, true) and
      compareDeep(abatementElement, o.abatementElement, true) and compareDeep(stageElement, o.stageElement, true) and
      compareDeep(evidenceList, o.evidenceList, true) and compareDeep(bodySiteList, o.bodySiteList, true) and
      compareDeep(notesElement, o.notesElement, true);
  end;
end;

function TFhirCondition.Link : TFhirCondition;
begin
  result := TFhirCondition(inherited Link);
end;

function TFhirCondition.Clone : TFhirCondition;
begin
  result := TFhirCondition(inherited Clone);
end;

procedure TFhirCondition.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('patient');
  fields.add('encounter');
  fields.add('asserter');
  fields.add('dateRecorded');
  fields.add('code');
  fields.add('category');
  fields.add('clinicalStatus');
  fields.add('verificationStatus');
  fields.add('severity');
  fields.add('onset[x]');
  fields.add('abatement[x]');
  fields.add('stage');
  fields.add('evidence');
  fields.add('bodySite');
  fields.add('notes');
end;

{ TFhirCondition }

Function TFhirCondition.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirCondition.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirCondition.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Procedure TFhirCondition.SetEncounter(value : TFhirReference{TFhirEncounter});
begin
  FEncounter.free;
  FEncounter := value;
end;

Procedure TFhirCondition.SetAsserter(value : TFhirReference{Resource});
begin
  FAsserter.free;
  FAsserter := value;
end;

Procedure TFhirCondition.SetDateRecorded(value : TFhirDate);
begin
  FDateRecorded.free;
  FDateRecorded := value;
end;

Function TFhirCondition.GetDateRecordedST : TFslDateTime;
begin
  if FDateRecorded = nil then
    result := TFslDateTime.makeNull
  else
    result := FDateRecorded.value;
end;

Procedure TFhirCondition.SetDateRecordedST(value : TFslDateTime);
begin
  if FDateRecorded = nil then
    FDateRecorded := TFhirDate.create;
  FDateRecorded.value := value
end;

Procedure TFhirCondition.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirCondition.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirCondition.SetClinicalStatus(value : TFhirCode);
begin
  FClinicalStatus.free;
  FClinicalStatus := value;
end;

Function TFhirCondition.GetClinicalStatusST : String;
begin
  if FClinicalStatus = nil then
    result := ''
  else
    result := FClinicalStatus.value;
end;

Procedure TFhirCondition.SetClinicalStatusST(value : String);
begin
  if value <> '' then
  begin
    if FClinicalStatus = nil then
      FClinicalStatus := TFhirCode.create;
    FClinicalStatus.value := value
  end
  else if FClinicalStatus <> nil then
    FClinicalStatus.value := '';
end;

Procedure TFhirCondition.SetVerificationStatus(value : TFhirEnum);
begin
  FVerificationStatus.free;
  FVerificationStatus := value;
end;

Function TFhirCondition.GetVerificationStatusST : TFhirConditionVerStatusEnum;
begin
  if FVerificationStatus = nil then
    result := TFhirConditionVerStatusEnum(0)
  else
    result := TFhirConditionVerStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirConditionVerStatusEnum, FVerificationStatus.value));
end;

Procedure TFhirCondition.SetVerificationStatusST(value : TFhirConditionVerStatusEnum);
begin
  if ord(value) = 0 then
    VerificationStatusElement := nil
  else
    VerificationStatusElement := TFhirEnum.create(SYSTEMS_TFhirConditionVerStatusEnum[value], CODES_TFhirConditionVerStatusEnum[value]);
end;

Procedure TFhirCondition.SetSeverity(value : TFhirCodeableConcept);
begin
  FSeverity.free;
  FSeverity := value;
end;

Procedure TFhirCondition.SetOnset(value : TFhirType);
begin
  FOnset.free;
  FOnset := value;
end;

Procedure TFhirCondition.SetAbatement(value : TFhirType);
begin
  FAbatement.free;
  FAbatement := value;
end;

Procedure TFhirCondition.SetStage(value : TFhirConditionStage);
begin
  FStage.free;
  FStage := value;
end;

Function TFhirCondition.GetEvidenceList : TFhirConditionEvidenceList;
begin
  if FEvidenceList = nil then
    FEvidenceList := TFhirConditionEvidenceList.Create;
  result := FEvidenceList;
end;

Function TFhirCondition.GetHasEvidenceList : boolean;
begin
  result := (FEvidenceList <> nil) and (FEvidenceList.count > 0);
end;

Function TFhirCondition.GetBodySiteList : TFhirCodeableConceptList;
begin
  if FBodySiteList = nil then
    FBodySiteList := TFhirCodeableConceptList.Create;
  result := FBodySiteList;
end;

Function TFhirCondition.GetHasBodySiteList : boolean;
begin
  result := (FBodySiteList <> nil) and (FBodySiteList.count > 0);
end;

Procedure TFhirCondition.SetNotes(value : TFhirString);
begin
  FNotes.free;
  FNotes := value;
end;

Function TFhirCondition.GetNotesST : String;
begin
  if FNotes = nil then
    result := ''
  else
    result := FNotes.value;
end;

Procedure TFhirCondition.SetNotesST(value : String);
begin
  if value <> '' then
  begin
    if FNotes = nil then
      FNotes := TFhirString.create;
    FNotes.value := value
  end
  else if FNotes <> nil then
    FNotes.value := '';
end;

function TFhirCondition.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FAsserter.sizeInBytes);
  inc(result, FDateRecorded.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FClinicalStatus.sizeInBytes);
  inc(result, FVerificationStatus.sizeInBytes);
  inc(result, FSeverity.sizeInBytes);
  inc(result, FOnset.sizeInBytes);
  inc(result, FAbatement.sizeInBytes);
  inc(result, FStage.sizeInBytes);
  inc(result, FevidenceList.sizeInBytes);
  inc(result, FbodySiteList.sizeInBytes);
  inc(result, FNotes.sizeInBytes);
end;

{ TFhirConditionListEnumerator }

Constructor TFhirConditionListEnumerator.Create(list : TFhirConditionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConditionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConditionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConditionListEnumerator.GetCurrent : TFhirCondition;
begin
  Result := FList[FIndex];
end;

function TFhirConditionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConditionList }
procedure TFhirConditionList.AddItem(value: TFhirCondition);
begin
  assert(value.ClassName = 'TFhirCondition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCondition');
  add(value);
end;

function TFhirConditionList.Append: TFhirCondition;
begin
  result := TFhirCondition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConditionList.ClearItems;
begin
  Clear;
end;

function TFhirConditionList.GetEnumerator : TFhirConditionListEnumerator;
begin
  result := TFhirConditionListEnumerator.Create(self.link);
end;

function TFhirConditionList.Clone: TFhirConditionList;
begin
  result := TFhirConditionList(inherited Clone);
end;

function TFhirConditionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConditionList.GetItemN(index: Integer): TFhirCondition;
begin
  result := TFhirCondition(ObjectByIndex[index]);
end;

function TFhirConditionList.ItemClass: TFslObjectClass;
begin
  result := TFhirCondition;
end;
function TFhirConditionList.IndexOf(value: TFhirCondition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConditionList.Insert(index: Integer): TFhirCondition;
begin
  result := TFhirCondition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConditionList.InsertItem(index: Integer; value: TFhirCondition);
begin
  assert(value is TFhirCondition);
  Inherited Insert(index, value);
end;

function TFhirConditionList.Item(index: Integer): TFhirCondition;
begin
  result := TFhirCondition(ObjectByIndex[index]);
end;

function TFhirConditionList.Link: TFhirConditionList;
begin
  result := TFhirConditionList(inherited Link);
end;

procedure TFhirConditionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConditionList.SetItemByIndex(index: Integer; value: TFhirCondition);
begin
  assert(value is TFhirCondition);
  FhirConditions[index] := value;
end;

procedure TFhirConditionList.SetItemN(index: Integer; value: TFhirCondition);
begin
  assert(value is TFhirCondition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CONDITION}

{$IFDEF FHIR_COVERAGE}

{ TFhirCoverage }

constructor TFhirCoverage.Create;
begin
  inherited;
end;

destructor TFhirCoverage.Destroy;
begin
  FIssuer.free;
  FBin.free;
  FPeriod.free;
  FType_.free;
  FSubscriberId.free;
  FIdentifierList.Free;
  FGroup.free;
  FPlan.free;
  FSubPlan.free;
  FDependent.free;
  FSequence.free;
  FSubscriber.free;
  FNetwork.free;
  FContractList.Free;
  inherited;
end;

function TFhirCoverage.GetResourceType : TFhirResourceType;
begin
  result := frtCoverage;
end;

procedure TFhirCoverage.Assign(oSource : TFslObject);
begin
  inherited;
  issuer := TFhirCoverage(oSource).issuer.Clone;
  bin := TFhirCoverage(oSource).bin.Clone;
  period := TFhirCoverage(oSource).period.Clone;
  type_ := TFhirCoverage(oSource).type_.Clone;
  subscriberId := TFhirCoverage(oSource).subscriberId.Clone;
  if (TFhirCoverage(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirCoverage(oSource).FIdentifierList);
  end;
  groupElement := TFhirCoverage(oSource).groupElement.Clone;
  planElement := TFhirCoverage(oSource).planElement.Clone;
  subPlanElement := TFhirCoverage(oSource).subPlanElement.Clone;
  dependentElement := TFhirCoverage(oSource).dependentElement.Clone;
  sequenceElement := TFhirCoverage(oSource).sequenceElement.Clone;
  subscriber := TFhirCoverage(oSource).subscriber.Clone;
  network := TFhirCoverage(oSource).network.Clone;
  if (TFhirCoverage(oSource).FContractList = nil) then
  begin
    FContractList.free;
    FContractList := nil;
  end
  else
  begin
    if FContractList = nil then
      FContractList := TFhirReferenceList{TFhirContract}.Create;
    FContractList.Assign(TFhirCoverage(oSource).FContractList);
  end;
end;

procedure TFhirCoverage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'issuer') Then
     list.add(self.link, 'issuer', FIssuer.Link);
  if (child_name = 'bin') Then
     list.add(self.link, 'bin', FBin.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subscriberId') Then
     list.add(self.link, 'subscriberId', FSubscriberId.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'group') Then
     list.add(self.link, 'group', FGroup.Link);
  if (child_name = 'plan') Then
     list.add(self.link, 'plan', FPlan.Link);
  if (child_name = 'subPlan') Then
     list.add(self.link, 'subPlan', FSubPlan.Link);
  if (child_name = 'dependent') Then
     list.add(self.link, 'dependent', FDependent.Link);
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'subscriber') Then
     list.add(self.link, 'subscriber', FSubscriber.Link);
  if (child_name = 'network') Then
     list.add(self.link, 'network', FNetwork.Link);
  if (child_name = 'contract') Then
    list.addAll(self, 'contract', FContractList);
end;

procedure TFhirCoverage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'issuer', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FIssuer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'bin', 'Identifier', false, TFhirIdentifier, FBin.Link));{2}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', false, TFhirCoding, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subscriberId', 'Identifier', false, TFhirIdentifier, FSubscriberId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'group', 'string', false, TFhirString, FGroup.Link));{2}
  oList.add(TFHIRProperty.create(self, 'plan', 'string', false, TFhirString, FPlan.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subPlan', 'string', false, TFhirString, FSubPlan.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dependent', 'positiveInt', false, TFhirPositiveInt, FDependent.Link));{2}
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subscriber', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FSubscriber.Link));{2}
  oList.add(TFHIRProperty.create(self, 'network', 'Identifier', false, TFhirIdentifier, FNetwork.Link));{2}
  oList.add(TFHIRProperty.create(self, 'contract', 'Reference(Contract)', true, TFhirReference{TFhirContract}, FContractList.Link)){3};
end;

function TFhirCoverage.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'issuer') then
  begin
    Issuer := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'bin') then
  begin
    Bin := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'subscriberId') then
  begin
    SubscriberId := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'group') then
  begin
    GroupElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'plan') then
  begin
    PlanElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'subPlan') then
  begin
    SubPlanElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'dependent') then
  begin
    DependentElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'subscriber') then
  begin
    Subscriber := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'network') then
  begin
    Network := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'contract') then
  begin
    ContractList.add(propValue as TFhirReference{TFhirContract}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirCoverage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'contract') then ContractList.insertItem(index, propValue as TFhirReference{TFhirContract}){2a}
  else inherited;
end;

function TFhirCoverage.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'issuer') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'bin') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'period') then result := TFhirPeriod.create(){4b}
  else if (propName = 'type') then result := TFhirCoding.create(){4b}
  else if (propName = 'subscriberId') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'group') then result := TFhirString.create() {5b}
  else if (propName = 'plan') then result := TFhirString.create() {5b}
  else if (propName = 'subPlan') then result := TFhirString.create() {5b}
  else if (propName = 'dependent') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'sequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'subscriber') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'network') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'contract') then result := ContractList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'issuer') then result := 'Reference'
  else if (propName = 'bin') then result := 'Identifier'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'type') then result := 'Coding'
  else if (propName = 'subscriberId') then result := 'Identifier'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'group') then result := 'string'
  else if (propName = 'plan') then result := 'string'
  else if (propName = 'subPlan') then result := 'string'
  else if (propName = 'dependent') then result := 'positiveInt'
  else if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'subscriber') then result := 'Reference'
  else if (propName = 'network') then result := 'Identifier'
  else if (propName = 'contract') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverage.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'issuer') then IssuerElement := nil
  else if (propName = 'bin') then BinElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'subscriberId') then SubscriberIdElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'group') then GroupElement := nil
  else if (propName = 'plan') then PlanElement := nil
  else if (propName = 'subPlan') then SubPlanElement := nil
  else if (propName = 'dependent') then DependentElement := nil
  else if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'subscriber') then SubscriberElement := nil
  else if (propName = 'network') then NetworkElement := nil
  else if (propName = 'contract') then deletePropertyValue('contract', ContractList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'issuer') then IssuerElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'bin') then BinElement := new as TFhirIdentifier{4}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else if (propName = 'type') then Type_Element := new as TFhirCoding{4}
  else if (propName = 'subscriberId') then SubscriberIdElement := new as TFhirIdentifier{4}
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'group') then GroupElement := asString(new){5b}
  else if (propName = 'plan') then PlanElement := asString(new){5b}
  else if (propName = 'subPlan') then SubPlanElement := asString(new){5b}
  else if (propName = 'dependent') then DependentElement := asPositiveInt(new){5b}
  else if (propName = 'sequence') then SequenceElement := asPositiveInt(new){5b}
  else if (propName = 'subscriber') then SubscriberElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'network') then NetworkElement := new as TFhirIdentifier{4}
  else if (propName = 'contract') then replacePropertyValue('contract', ContractList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverage.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'contract') then ContractList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverage.fhirType : string;
begin
  result := 'Coverage';
end;

function TFhirCoverage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIssuer) and isEmptyProp(FBin) and isEmptyProp(FPeriod) and isEmptyProp(FType_) and isEmptyProp(FSubscriberId) and isEmptyProp(FidentifierList) and isEmptyProp(FGroup) and isEmptyProp(FPlan) and isEmptyProp(FSubPlan) and isEmptyProp(FDependent) and isEmptyProp(FSequence) and isEmptyProp(FSubscriber) and isEmptyProp(FNetwork) and isEmptyProp(FcontractList);
end;

function TFhirCoverage.equals(other : TObject) : boolean;
var
  o : TFhirCoverage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverage)) then
    result := false
  else
  begin
    o := TFhirCoverage(other);
    result := compareDeep(issuerElement, o.issuerElement, true) and compareDeep(binElement, o.binElement, true) and
      compareDeep(periodElement, o.periodElement, true) and compareDeep(type_Element, o.type_Element, true) and
      compareDeep(subscriberIdElement, o.subscriberIdElement, true) and compareDeep(identifierList, o.identifierList, true) and
      compareDeep(groupElement, o.groupElement, true) and compareDeep(planElement, o.planElement, true) and
      compareDeep(subPlanElement, o.subPlanElement, true) and compareDeep(dependentElement, o.dependentElement, true) and
      compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(subscriberElement, o.subscriberElement, true) and
      compareDeep(networkElement, o.networkElement, true) and compareDeep(contractList, o.contractList, true);
  end;
end;

function TFhirCoverage.Link : TFhirCoverage;
begin
  result := TFhirCoverage(inherited Link);
end;

function TFhirCoverage.Clone : TFhirCoverage;
begin
  result := TFhirCoverage(inherited Clone);
end;

procedure TFhirCoverage.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('issuer');
  fields.add('bin');
  fields.add('period');
  fields.add('type');
  fields.add('subscriberId');
  fields.add('identifier');
  fields.add('group');
  fields.add('plan');
  fields.add('subPlan');
  fields.add('dependent');
  fields.add('sequence');
  fields.add('subscriber');
  fields.add('network');
  fields.add('contract');
end;

{ TFhirCoverage }

Procedure TFhirCoverage.SetIssuer(value : TFhirReference{TFhirOrganization});
begin
  FIssuer.free;
  FIssuer := value;
end;

Procedure TFhirCoverage.SetBin(value : TFhirIdentifier);
begin
  FBin.free;
  FBin := value;
end;

Procedure TFhirCoverage.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Procedure TFhirCoverage.SetType_(value : TFhirCoding);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirCoverage.SetSubscriberId(value : TFhirIdentifier);
begin
  FSubscriberId.free;
  FSubscriberId := value;
end;

Function TFhirCoverage.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirCoverage.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirCoverage.SetGroup(value : TFhirString);
begin
  FGroup.free;
  FGroup := value;
end;

Function TFhirCoverage.GetGroupST : String;
begin
  if FGroup = nil then
    result := ''
  else
    result := FGroup.value;
end;

Procedure TFhirCoverage.SetGroupST(value : String);
begin
  if value <> '' then
  begin
    if FGroup = nil then
      FGroup := TFhirString.create;
    FGroup.value := value
  end
  else if FGroup <> nil then
    FGroup.value := '';
end;

Procedure TFhirCoverage.SetPlan(value : TFhirString);
begin
  FPlan.free;
  FPlan := value;
end;

Function TFhirCoverage.GetPlanST : String;
begin
  if FPlan = nil then
    result := ''
  else
    result := FPlan.value;
end;

Procedure TFhirCoverage.SetPlanST(value : String);
begin
  if value <> '' then
  begin
    if FPlan = nil then
      FPlan := TFhirString.create;
    FPlan.value := value
  end
  else if FPlan <> nil then
    FPlan.value := '';
end;

Procedure TFhirCoverage.SetSubPlan(value : TFhirString);
begin
  FSubPlan.free;
  FSubPlan := value;
end;

Function TFhirCoverage.GetSubPlanST : String;
begin
  if FSubPlan = nil then
    result := ''
  else
    result := FSubPlan.value;
end;

Procedure TFhirCoverage.SetSubPlanST(value : String);
begin
  if value <> '' then
  begin
    if FSubPlan = nil then
      FSubPlan := TFhirString.create;
    FSubPlan.value := value
  end
  else if FSubPlan <> nil then
    FSubPlan.value := '';
end;

Procedure TFhirCoverage.SetDependent(value : TFhirPositiveInt);
begin
  FDependent.free;
  FDependent := value;
end;

Function TFhirCoverage.GetDependentST : String;
begin
  if FDependent = nil then
    result := ''
  else
    result := FDependent.value;
end;

Procedure TFhirCoverage.SetDependentST(value : String);
begin
  if value <> '' then
  begin
    if FDependent = nil then
      FDependent := TFhirPositiveInt.create;
    FDependent.value := value
  end
  else if FDependent <> nil then
    FDependent.value := '';
end;

Procedure TFhirCoverage.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirCoverage.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirCoverage.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Procedure TFhirCoverage.SetSubscriber(value : TFhirReference{TFhirPatient});
begin
  FSubscriber.free;
  FSubscriber := value;
end;

Procedure TFhirCoverage.SetNetwork(value : TFhirIdentifier);
begin
  FNetwork.free;
  FNetwork := value;
end;

Function TFhirCoverage.GetContractList : TFhirReferenceList{TFhirContract};
begin
  if FContractList = nil then
    FContractList := TFhirReferenceList{TFhirContract}.Create;
  result := FContractList;
end;

Function TFhirCoverage.GetHasContractList : boolean;
begin
  result := (FContractList <> nil) and (FContractList.count > 0);
end;

function TFhirCoverage.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIssuer.sizeInBytes);
  inc(result, FBin.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FSubscriberId.sizeInBytes);
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FGroup.sizeInBytes);
  inc(result, FPlan.sizeInBytes);
  inc(result, FSubPlan.sizeInBytes);
  inc(result, FDependent.sizeInBytes);
  inc(result, FSequence.sizeInBytes);
  inc(result, FSubscriber.sizeInBytes);
  inc(result, FNetwork.sizeInBytes);
  inc(result, FcontractList.sizeInBytes);
end;

{ TFhirCoverageListEnumerator }

Constructor TFhirCoverageListEnumerator.Create(list : TFhirCoverageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageListEnumerator.GetCurrent : TFhirCoverage;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCoverageList }
procedure TFhirCoverageList.AddItem(value: TFhirCoverage);
begin
  assert(value.ClassName = 'TFhirCoverage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverage');
  add(value);
end;

function TFhirCoverageList.Append: TFhirCoverage;
begin
  result := TFhirCoverage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageList.GetEnumerator : TFhirCoverageListEnumerator;
begin
  result := TFhirCoverageListEnumerator.Create(self.link);
end;

function TFhirCoverageList.Clone: TFhirCoverageList;
begin
  result := TFhirCoverageList(inherited Clone);
end;

function TFhirCoverageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageList.GetItemN(index: Integer): TFhirCoverage;
begin
  result := TFhirCoverage(ObjectByIndex[index]);
end;

function TFhirCoverageList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverage;
end;
function TFhirCoverageList.IndexOf(value: TFhirCoverage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageList.Insert(index: Integer): TFhirCoverage;
begin
  result := TFhirCoverage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageList.InsertItem(index: Integer; value: TFhirCoverage);
begin
  assert(value is TFhirCoverage);
  Inherited Insert(index, value);
end;

function TFhirCoverageList.Item(index: Integer): TFhirCoverage;
begin
  result := TFhirCoverage(ObjectByIndex[index]);
end;

function TFhirCoverageList.Link: TFhirCoverageList;
begin
  result := TFhirCoverageList(inherited Link);
end;

procedure TFhirCoverageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageList.SetItemByIndex(index: Integer; value: TFhirCoverage);
begin
  assert(value is TFhirCoverage);
  FhirCoverages[index] := value;
end;

procedure TFhirCoverageList.SetItemN(index: Integer; value: TFhirCoverage);
begin
  assert(value is TFhirCoverage);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_COVERAGE}

{$IFDEF FHIR_DETECTEDISSUE}

{ TFhirDetectedIssueMitigation }

constructor TFhirDetectedIssueMitigation.Create;
begin
  inherited;
end;

destructor TFhirDetectedIssueMitigation.Destroy;
begin
  FAction.free;
  FDate.free;
  FAuthor.free;
  inherited;
end;

procedure TFhirDetectedIssueMitigation.Assign(oSource : TFslObject);
begin
  inherited;
  action := TFhirDetectedIssueMitigation(oSource).action.Clone;
  dateElement := TFhirDetectedIssueMitigation(oSource).dateElement.Clone;
  author := TFhirDetectedIssueMitigation(oSource).author.Clone;
end;

procedure TFhirDetectedIssueMitigation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'action') Then
     list.add(self.link, 'action', FAction.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
end;

procedure TFhirDetectedIssueMitigation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'action', 'CodeableConcept', false, TFhirCodeableConcept, FAction.Link));{2}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'author', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FAuthor.Link));{2}
end;

function TFhirDetectedIssueMitigation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'action') then
  begin
    Action := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDetectedIssueMitigation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDetectedIssueMitigation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'action') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'author') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDetectedIssueMitigation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'action') then result := 'CodeableConcept'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'author') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDetectedIssueMitigation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'action') then ActionElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'author') then AuthorElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDetectedIssueMitigation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'action') then ActionElement := new as TFhirCodeableConcept{4}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'author') then AuthorElement := new as TFhirReference{TFhirPractitioner}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDetectedIssueMitigation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDetectedIssueMitigation.fhirType : string;
begin
  result := 'mitigation';
end;

function TFhirDetectedIssueMitigation.Link : TFhirDetectedIssueMitigation;
begin
  result := TFhirDetectedIssueMitigation(inherited Link);
end;

function TFhirDetectedIssueMitigation.Clone : TFhirDetectedIssueMitigation;
begin
  result := TFhirDetectedIssueMitigation(inherited Clone);
end;

function TFhirDetectedIssueMitigation.equals(other : TObject) : boolean;
var
  o : TFhirDetectedIssueMitigation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDetectedIssueMitigation)) then
    result := false
  else
  begin
    o := TFhirDetectedIssueMitigation(other);
    result := compareDeep(actionElement, o.actionElement, true) and compareDeep(dateElement, o.dateElement, true) and
      compareDeep(authorElement, o.authorElement, true);
  end;
end;

function TFhirDetectedIssueMitigation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAction) and isEmptyProp(FDate) and isEmptyProp(FAuthor);
end;

procedure TFhirDetectedIssueMitigation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('action');
  fields.add('date');
  fields.add('author');
end;

{ TFhirDetectedIssueMitigation }

Procedure TFhirDetectedIssueMitigation.SetAction(value : TFhirCodeableConcept);
begin
  FAction.free;
  FAction := value;
end;

Procedure TFhirDetectedIssueMitigation.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirDetectedIssueMitigation.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirDetectedIssueMitigation.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirDetectedIssueMitigation.SetAuthor(value : TFhirReference{TFhirPractitioner});
begin
  FAuthor.free;
  FAuthor := value;
end;

function TFhirDetectedIssueMitigation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FAction.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FAuthor.sizeInBytes);
end;

{ TFhirDetectedIssueMitigationListEnumerator }

Constructor TFhirDetectedIssueMitigationListEnumerator.Create(list : TFhirDetectedIssueMitigationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDetectedIssueMitigationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDetectedIssueMitigationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDetectedIssueMitigationListEnumerator.GetCurrent : TFhirDetectedIssueMitigation;
begin
  Result := FList[FIndex];
end;

function TFhirDetectedIssueMitigationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDetectedIssueMitigationList }
procedure TFhirDetectedIssueMitigationList.AddItem(value: TFhirDetectedIssueMitigation);
begin
  assert(value.ClassName = 'TFhirDetectedIssueMitigation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDetectedIssueMitigation');
  add(value);
end;

function TFhirDetectedIssueMitigationList.Append: TFhirDetectedIssueMitigation;
begin
  result := TFhirDetectedIssueMitigation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDetectedIssueMitigationList.ClearItems;
begin
  Clear;
end;

function TFhirDetectedIssueMitigationList.GetEnumerator : TFhirDetectedIssueMitigationListEnumerator;
begin
  result := TFhirDetectedIssueMitigationListEnumerator.Create(self.link);
end;

function TFhirDetectedIssueMitigationList.Clone: TFhirDetectedIssueMitigationList;
begin
  result := TFhirDetectedIssueMitigationList(inherited Clone);
end;

function TFhirDetectedIssueMitigationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDetectedIssueMitigationList.GetItemN(index: Integer): TFhirDetectedIssueMitigation;
begin
  result := TFhirDetectedIssueMitigation(ObjectByIndex[index]);
end;

function TFhirDetectedIssueMitigationList.ItemClass: TFslObjectClass;
begin
  result := TFhirDetectedIssueMitigation;
end;
function TFhirDetectedIssueMitigationList.IndexOf(value: TFhirDetectedIssueMitigation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDetectedIssueMitigationList.Insert(index: Integer): TFhirDetectedIssueMitigation;
begin
  result := TFhirDetectedIssueMitigation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDetectedIssueMitigationList.InsertItem(index: Integer; value: TFhirDetectedIssueMitigation);
begin
  assert(value is TFhirDetectedIssueMitigation);
  Inherited Insert(index, value);
end;

function TFhirDetectedIssueMitigationList.Item(index: Integer): TFhirDetectedIssueMitigation;
begin
  result := TFhirDetectedIssueMitigation(ObjectByIndex[index]);
end;

function TFhirDetectedIssueMitigationList.Link: TFhirDetectedIssueMitigationList;
begin
  result := TFhirDetectedIssueMitigationList(inherited Link);
end;

procedure TFhirDetectedIssueMitigationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDetectedIssueMitigationList.SetItemByIndex(index: Integer; value: TFhirDetectedIssueMitigation);
begin
  assert(value is TFhirDetectedIssueMitigation);
  FhirDetectedIssueMitigations[index] := value;
end;

procedure TFhirDetectedIssueMitigationList.SetItemN(index: Integer; value: TFhirDetectedIssueMitigation);
begin
  assert(value is TFhirDetectedIssueMitigation);
  ObjectByIndex[index] := value;
end;

{ TFhirDetectedIssue }

constructor TFhirDetectedIssue.Create;
begin
  inherited;
end;

destructor TFhirDetectedIssue.Destroy;
begin
  FPatient.free;
  FCategory.free;
  FSeverity.free;
  FImplicatedList.Free;
  FDetail.free;
  FDate.free;
  FAuthor.free;
  FIdentifier.free;
  FReference.free;
  FMitigationList.Free;
  inherited;
end;

function TFhirDetectedIssue.GetResourceType : TFhirResourceType;
begin
  result := frtDetectedIssue;
end;

procedure TFhirDetectedIssue.Assign(oSource : TFslObject);
begin
  inherited;
  patient := TFhirDetectedIssue(oSource).patient.Clone;
  category := TFhirDetectedIssue(oSource).category.Clone;
  FSeverity := TFhirDetectedIssue(oSource).FSeverity.Link;
  if (TFhirDetectedIssue(oSource).FImplicatedList = nil) then
  begin
    FImplicatedList.free;
    FImplicatedList := nil;
  end
  else
  begin
    if FImplicatedList = nil then
      FImplicatedList := TFhirReferenceList{TFhirReference}.Create;
    FImplicatedList.Assign(TFhirDetectedIssue(oSource).FImplicatedList);
  end;
  detailElement := TFhirDetectedIssue(oSource).detailElement.Clone;
  dateElement := TFhirDetectedIssue(oSource).dateElement.Clone;
  author := TFhirDetectedIssue(oSource).author.Clone;
  identifier := TFhirDetectedIssue(oSource).identifier.Clone;
  referenceElement := TFhirDetectedIssue(oSource).referenceElement.Clone;
  if (TFhirDetectedIssue(oSource).FMitigationList = nil) then
  begin
    FMitigationList.free;
    FMitigationList := nil;
  end
  else
  begin
    if FMitigationList = nil then
      FMitigationList := TFhirDetectedIssueMitigationList.Create;
    FMitigationList.Assign(TFhirDetectedIssue(oSource).FMitigationList);
  end;
end;

procedure TFhirDetectedIssue.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'severity') Then
     list.add(self.link, 'severity', FSeverity.Link);
  if (child_name = 'implicated') Then
    list.addAll(self, 'implicated', FImplicatedList);
  if (child_name = 'detail') Then
     list.add(self.link, 'detail', FDetail.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
  if (child_name = 'mitigation') Then
    list.addAll(self, 'mitigation', FMitigationList);
end;

procedure TFhirDetectedIssue.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'severity', 'code', false, TFHIREnum, FSeverity.Link));{1}
  oList.add(TFHIRProperty.create(self, 'implicated', 'Reference(Any)', true, TFhirReference{TFhirReference}, FImplicatedList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'detail', 'string', false, TFhirString, FDetail.Link));{2}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'author', 'Reference(Practitioner|Device)', false, TFhirReference{Resource}, FAuthor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reference', 'uri', false, TFhirUri, FReference.Link));{2}
  oList.add(TFHIRProperty.create(self, 'mitigation', '', true, TFhirDetectedIssueMitigation, FMitigationList.Link)){3};
end;

function TFhirDetectedIssue.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'severity') then
  begin
    SeverityElement := asEnum(SYSTEMS_TFhirDetectedissueSeverityEnum, CODES_TFhirDetectedissueSeverityEnum, propValue);
    result := propValue
  end
  else if (propName = 'implicated') then
  begin
    ImplicatedList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'reference') then
  begin
    ReferenceElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'mitigation') then
  begin
    MitigationList.add(propValue as TFhirDetectedIssueMitigation){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirDetectedIssue.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'implicated') then ImplicatedList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'mitigation') then MitigationList.insertItem(index, propValue as TFhirDetectedIssueMitigation){2a}
  else inherited;
end;

function TFhirDetectedIssue.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'implicated') then result := ImplicatedList.new(){2}
  else if (propName = 'detail') then result := TFhirString.create() {5b}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'author') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'reference') then result := TFhirUri.create() {5b}
  else if (propName = 'mitigation') then result := MitigationList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDetectedIssue.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'patient') then result := 'Reference'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'severity') then result := 'code'
  else if (propName = 'implicated') then result := 'Reference'
  else if (propName = 'detail') then result := 'string'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'reference') then result := 'uri'
  else if (propName = 'mitigation') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDetectedIssue.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'patient') then PatientElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'severity') then SeverityElement := nil
  else if (propName = 'implicated') then deletePropertyValue('implicated', ImplicatedList, value) {2}
  else if (propName = 'detail') then DetailElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'author') then AuthorElement := nil
  else if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'reference') then ReferenceElement := nil
  else if (propName = 'mitigation') then deletePropertyValue('mitigation', MitigationList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDetectedIssue.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'severity') then SeverityElement := asEnum(SYSTEMS_TFhirDetectedissueSeverityEnum, CODES_TFhirDetectedissueSeverityEnum, new){4}
  else if (propName = 'implicated') then replacePropertyValue('implicated', ImplicatedList, existing, new) {2}
  else if (propName = 'detail') then DetailElement := asString(new){5b}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'author') then AuthorElement := new as TFhirReference{Resource}{4}
  else if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'reference') then ReferenceElement := asUri(new){5b}
  else if (propName = 'mitigation') then replacePropertyValue('mitigation', MitigationList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDetectedIssue.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'implicated') then ImplicatedList.move(source, destination){2a}
  else if (propName = 'mitigation') then MitigationList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDetectedIssue.fhirType : string;
begin
  result := 'DetectedIssue';
end;

function TFhirDetectedIssue.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPatient) and isEmptyProp(FCategory) and isEmptyProp(FSeverity) and isEmptyProp(FimplicatedList) and isEmptyProp(FDetail) and isEmptyProp(FDate) and isEmptyProp(FAuthor) and isEmptyProp(FIdentifier) and isEmptyProp(FReference) and isEmptyProp(FmitigationList);
end;

function TFhirDetectedIssue.equals(other : TObject) : boolean;
var
  o : TFhirDetectedIssue;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDetectedIssue)) then
    result := false
  else
  begin
    o := TFhirDetectedIssue(other);
    result := compareDeep(patientElement, o.patientElement, true) and compareDeep(categoryElement, o.categoryElement, true) and
      compareDeep(severityElement, o.severityElement, true) and compareDeep(implicatedList, o.implicatedList, true) and
      compareDeep(detailElement, o.detailElement, true) and compareDeep(dateElement, o.dateElement, true) and
      compareDeep(authorElement, o.authorElement, true) and compareDeep(identifierElement, o.identifierElement, true) and
      compareDeep(referenceElement, o.referenceElement, true) and compareDeep(mitigationList, o.mitigationList, true);
  end;
end;

function TFhirDetectedIssue.Link : TFhirDetectedIssue;
begin
  result := TFhirDetectedIssue(inherited Link);
end;

function TFhirDetectedIssue.Clone : TFhirDetectedIssue;
begin
  result := TFhirDetectedIssue(inherited Clone);
end;

procedure TFhirDetectedIssue.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('patient');
  fields.add('category');
  fields.add('severity');
  fields.add('implicated');
  fields.add('detail');
  fields.add('date');
  fields.add('author');
  fields.add('identifier');
  fields.add('reference');
  fields.add('mitigation');
end;

{ TFhirDetectedIssue }

Procedure TFhirDetectedIssue.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Procedure TFhirDetectedIssue.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirDetectedIssue.SetSeverity(value : TFhirEnum);
begin
  FSeverity.free;
  FSeverity := value;
end;

Function TFhirDetectedIssue.GetSeverityST : TFhirDetectedissueSeverityEnum;
begin
  if FSeverity = nil then
    result := TFhirDetectedissueSeverityEnum(0)
  else
    result := TFhirDetectedissueSeverityEnum(StringArrayIndexOfSensitive(CODES_TFhirDetectedissueSeverityEnum, FSeverity.value));
end;

Procedure TFhirDetectedIssue.SetSeverityST(value : TFhirDetectedissueSeverityEnum);
begin
  if ord(value) = 0 then
    SeverityElement := nil
  else
    SeverityElement := TFhirEnum.create(SYSTEMS_TFhirDetectedissueSeverityEnum[value], CODES_TFhirDetectedissueSeverityEnum[value]);
end;

Function TFhirDetectedIssue.GetImplicatedList : TFhirReferenceList{TFhirReference};
begin
  if FImplicatedList = nil then
    FImplicatedList := TFhirReferenceList{TFhirReference}.Create;
  result := FImplicatedList;
end;

Function TFhirDetectedIssue.GetHasImplicatedList : boolean;
begin
  result := (FImplicatedList <> nil) and (FImplicatedList.count > 0);
end;

Procedure TFhirDetectedIssue.SetDetail(value : TFhirString);
begin
  FDetail.free;
  FDetail := value;
end;

Function TFhirDetectedIssue.GetDetailST : String;
begin
  if FDetail = nil then
    result := ''
  else
    result := FDetail.value;
end;

Procedure TFhirDetectedIssue.SetDetailST(value : String);
begin
  if value <> '' then
  begin
    if FDetail = nil then
      FDetail := TFhirString.create;
    FDetail.value := value
  end
  else if FDetail <> nil then
    FDetail.value := '';
end;

Procedure TFhirDetectedIssue.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirDetectedIssue.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirDetectedIssue.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirDetectedIssue.SetAuthor(value : TFhirReference{Resource});
begin
  FAuthor.free;
  FAuthor := value;
end;

Procedure TFhirDetectedIssue.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirDetectedIssue.SetReference(value : TFhirUri);
begin
  FReference.free;
  FReference := value;
end;

Function TFhirDetectedIssue.GetReferenceST : String;
begin
  if FReference = nil then
    result := ''
  else
    result := FReference.value;
end;

Procedure TFhirDetectedIssue.SetReferenceST(value : String);
begin
  if value <> '' then
  begin
    if FReference = nil then
      FReference := TFhirUri.create;
    FReference.value := value
  end
  else if FReference <> nil then
    FReference.value := '';
end;

Function TFhirDetectedIssue.GetMitigationList : TFhirDetectedIssueMitigationList;
begin
  if FMitigationList = nil then
    FMitigationList := TFhirDetectedIssueMitigationList.Create;
  result := FMitigationList;
end;

Function TFhirDetectedIssue.GetHasMitigationList : boolean;
begin
  result := (FMitigationList <> nil) and (FMitigationList.count > 0);
end;

function TFhirDetectedIssue.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FPatient.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FSeverity.sizeInBytes);
  inc(result, FimplicatedList.sizeInBytes);
  inc(result, FDetail.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FAuthor.sizeInBytes);
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FReference.sizeInBytes);
  inc(result, FmitigationList.sizeInBytes);
end;

{ TFhirDetectedIssueListEnumerator }

Constructor TFhirDetectedIssueListEnumerator.Create(list : TFhirDetectedIssueList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDetectedIssueListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDetectedIssueListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDetectedIssueListEnumerator.GetCurrent : TFhirDetectedIssue;
begin
  Result := FList[FIndex];
end;

function TFhirDetectedIssueListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDetectedIssueList }
procedure TFhirDetectedIssueList.AddItem(value: TFhirDetectedIssue);
begin
  assert(value.ClassName = 'TFhirDetectedIssue', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDetectedIssue');
  add(value);
end;

function TFhirDetectedIssueList.Append: TFhirDetectedIssue;
begin
  result := TFhirDetectedIssue.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDetectedIssueList.ClearItems;
begin
  Clear;
end;

function TFhirDetectedIssueList.GetEnumerator : TFhirDetectedIssueListEnumerator;
begin
  result := TFhirDetectedIssueListEnumerator.Create(self.link);
end;

function TFhirDetectedIssueList.Clone: TFhirDetectedIssueList;
begin
  result := TFhirDetectedIssueList(inherited Clone);
end;

function TFhirDetectedIssueList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDetectedIssueList.GetItemN(index: Integer): TFhirDetectedIssue;
begin
  result := TFhirDetectedIssue(ObjectByIndex[index]);
end;

function TFhirDetectedIssueList.ItemClass: TFslObjectClass;
begin
  result := TFhirDetectedIssue;
end;
function TFhirDetectedIssueList.IndexOf(value: TFhirDetectedIssue): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDetectedIssueList.Insert(index: Integer): TFhirDetectedIssue;
begin
  result := TFhirDetectedIssue.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDetectedIssueList.InsertItem(index: Integer; value: TFhirDetectedIssue);
begin
  assert(value is TFhirDetectedIssue);
  Inherited Insert(index, value);
end;

function TFhirDetectedIssueList.Item(index: Integer): TFhirDetectedIssue;
begin
  result := TFhirDetectedIssue(ObjectByIndex[index]);
end;

function TFhirDetectedIssueList.Link: TFhirDetectedIssueList;
begin
  result := TFhirDetectedIssueList(inherited Link);
end;

procedure TFhirDetectedIssueList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDetectedIssueList.SetItemByIndex(index: Integer; value: TFhirDetectedIssue);
begin
  assert(value is TFhirDetectedIssue);
  FhirDetectedIssues[index] := value;
end;

procedure TFhirDetectedIssueList.SetItemN(index: Integer; value: TFhirDetectedIssue);
begin
  assert(value is TFhirDetectedIssue);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_DETECTEDISSUE}

{$IFDEF FHIR_DEVICEUSEREQUEST}

{ TFhirDeviceUseRequest }

constructor TFhirDeviceUseRequest.Create;
begin
  inherited;
end;

destructor TFhirDeviceUseRequest.Destroy;
begin
  FBodySite.free;
  FStatus.free;
  FDevice.free;
  FEncounter.free;
  FIdentifierList.Free;
  FIndicationList.Free;
  FNotesList.Free;
  FPrnReasonList.Free;
  FOrderedOn.free;
  FRecordedOn.free;
  FSubject.free;
  FTiming.free;
  FPriority.free;
  inherited;
end;

function TFhirDeviceUseRequest.GetResourceType : TFhirResourceType;
begin
  result := frtDeviceUseRequest;
end;

procedure TFhirDeviceUseRequest.Assign(oSource : TFslObject);
begin
  inherited;
  bodySite := TFhirDeviceUseRequest(oSource).bodySite.Clone;
  FStatus := TFhirDeviceUseRequest(oSource).FStatus.Link;
  device := TFhirDeviceUseRequest(oSource).device.Clone;
  encounter := TFhirDeviceUseRequest(oSource).encounter.Clone;
  if (TFhirDeviceUseRequest(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirDeviceUseRequest(oSource).FIdentifierList);
  end;
  if (TFhirDeviceUseRequest(oSource).FIndicationList = nil) then
  begin
    FIndicationList.free;
    FIndicationList := nil;
  end
  else
  begin
    if FIndicationList = nil then
      FIndicationList := TFhirCodeableConceptList.Create;
    FIndicationList.Assign(TFhirDeviceUseRequest(oSource).FIndicationList);
  end;
  if (TFhirDeviceUseRequest(oSource).FNotesList = nil) then
  begin
    FNotesList.free;
    FNotesList := nil;
  end
  else
  begin
    if FNotesList = nil then
      FNotesList := TFhirStringList.Create;
    FNotesList.Assign(TFhirDeviceUseRequest(oSource).FNotesList);
  end;
  if (TFhirDeviceUseRequest(oSource).FPrnReasonList = nil) then
  begin
    FPrnReasonList.free;
    FPrnReasonList := nil;
  end
  else
  begin
    if FPrnReasonList = nil then
      FPrnReasonList := TFhirCodeableConceptList.Create;
    FPrnReasonList.Assign(TFhirDeviceUseRequest(oSource).FPrnReasonList);
  end;
  orderedOnElement := TFhirDeviceUseRequest(oSource).orderedOnElement.Clone;
  recordedOnElement := TFhirDeviceUseRequest(oSource).recordedOnElement.Clone;
  subject := TFhirDeviceUseRequest(oSource).subject.Clone;
  timing := TFhirDeviceUseRequest(oSource).timing.Clone;
  FPriority := TFhirDeviceUseRequest(oSource).FPriority.Link;
end;

procedure TFhirDeviceUseRequest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'bodySite[x]') or (child_name = 'bodySite') Then
     list.add(self.link, 'bodySite[x]', FBodySite.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'device') Then
     list.add(self.link, 'device', FDevice.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'indication') Then
    list.addAll(self, 'indication', FIndicationList);
  if (child_name = 'notes') Then
    list.addAll(self, 'notes', FNotesList);
  if (child_name = 'prnReason') Then
    list.addAll(self, 'prnReason', FPrnReasonList);
  if (child_name = 'orderedOn') Then
     list.add(self.link, 'orderedOn', FOrderedOn.Link);
  if (child_name = 'recordedOn') Then
     list.add(self.link, 'recordedOn', FRecordedOn.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'timing[x]') or (child_name = 'timing') Then
     list.add(self.link, 'timing[x]', FTiming.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
end;

procedure TFhirDeviceUseRequest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'bodySite[x]', 'CodeableConcept|Reference(BodySite)', false, TFhirType, FBodySite.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'device', 'Reference(Device)', false, TFhirReference{TFhirDevice}, FDevice.Link));{2}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference(Encounter)', false, TFhirReference{TFhirEncounter}, FEncounter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'indication', 'CodeableConcept', true, TFhirCodeableConcept, FIndicationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'notes', 'string', true, TFhirString, FNotesList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'prnReason', 'CodeableConcept', true, TFhirCodeableConcept, FPrnReasonList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'orderedOn', 'dateTime', false, TFhirDateTime, FOrderedOn.Link));{2}
  oList.add(TFHIRProperty.create(self, 'recordedOn', 'dateTime', false, TFhirDateTime, FRecordedOn.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'timing[x]', 'Timing|Period|dateTime', false, TFhirType, FTiming.Link));{2}
  oList.add(TFHIRProperty.create(self, 'priority', 'code', false, TFHIREnum, FPriority.Link));{1}
end;

function TFhirDeviceUseRequest.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'bodySite', ['CodeableConcept', 'Reference'])) then
  begin
    BodySite := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirDeviceUseRequestStatusEnum, CODES_TFhirDeviceUseRequestStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'device') then
  begin
    Device := propValue as TFhirReference{TFhirDevice}{4b};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference{TFhirEncounter}{4b};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'indication') then
  begin
    IndicationList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'notes') then
  begin
    NotesList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'prnReason') then
  begin
    PrnReasonList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'orderedOn') then
  begin
    OrderedOnElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'recordedOn') then
  begin
    RecordedOnElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'timing', ['Timing', 'Period', 'DateTime'])) then
  begin
    Timing := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asEnum(SYSTEMS_TFhirDeviceUseRequestPriorityEnum, CODES_TFhirDeviceUseRequestPriorityEnum, propValue);
    result := propValue
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirDeviceUseRequest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'indication') then IndicationList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'notes') then NotesList.insertItem(index, asString(propValue)){2}
  else if (propName = 'prnReason') then PrnReasonList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirDeviceUseRequest.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'bodySite', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property BodySite'){4x}
  else if (propName = 'device') then result := TFhirReference{TFhirDevice}.create(){4b}
  else if (propName = 'encounter') then result := TFhirReference{TFhirEncounter}.create(){4b}
  else if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'indication') then result := IndicationList.new(){2}
  else if (propName = 'notes') then result := NotesList.new(){2}
  else if (propName = 'prnReason') then result := PrnReasonList.new(){2}
  else if (propName = 'orderedOn') then result := TFhirDateTime.create() {5b}
  else if (propName = 'recordedOn') then result := TFhirDateTime.create() {5b}
  else if (propName = 'subject') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (isMatchingName(propName, 'timing', ['Timing', 'Period', 'DateTime'])) then raise EFHIRException.create('Cannot make property Timing'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceUseRequest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'bodySite[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'device') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'indication') then result := 'CodeableConcept'
  else if (propName = 'notes') then result := 'string'
  else if (propName = 'prnReason') then result := 'CodeableConcept'
  else if (propName = 'orderedOn') then result := 'dateTime'
  else if (propName = 'recordedOn') then result := 'dateTime'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'timing[x]') then result := 'Timing|Period|dateTime'
  else if (propName = 'priority') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceUseRequest.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'bodySite', ['CodeableConcept', 'Reference'])) then BodySiteElement := nil{4x}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'device') then DeviceElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'indication') then deletePropertyValue('indication', IndicationList, value) {2}
  else if (propName = 'notes') then deletePropertyValue('notes', NotesList, value) {2}
  else if (propName = 'prnReason') then deletePropertyValue('prnReason', PrnReasonList, value) {2}
  else if (propName = 'orderedOn') then OrderedOnElement := nil
  else if (propName = 'recordedOn') then RecordedOnElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (isMatchingName(propName, 'timing', ['Timing', 'Period', 'DateTime'])) then TimingElement := nil{4x}
  else if (propName = 'priority') then PriorityElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceUseRequest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'bodySite', ['CodeableConcept', 'Reference'])) then BodySiteElement := new as TFhirType{4x}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirDeviceUseRequestStatusEnum, CODES_TFhirDeviceUseRequestStatusEnum, new){4}
  else if (propName = 'device') then DeviceElement := new as TFhirReference{TFhirDevice}{4}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference{TFhirEncounter}{4}
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'indication') then replacePropertyValue('indication', IndicationList, existing, new) {2}
  else if (propName = 'notes') then replacePropertyValue('notes', NotesList, existing, new) {2}
  else if (propName = 'prnReason') then replacePropertyValue('prnReason', PrnReasonList, existing, new) {2}
  else if (propName = 'orderedOn') then OrderedOnElement := asDateTime(new){5b}
  else if (propName = 'recordedOn') then RecordedOnElement := asDateTime(new){5b}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{TFhirPatient}{4}
  else if (isMatchingName(propName, 'timing', ['Timing', 'Period', 'DateTime'])) then TimingElement := new as TFhirType{4x}
  else if (propName = 'priority') then PriorityElement := asEnum(SYSTEMS_TFhirDeviceUseRequestPriorityEnum, CODES_TFhirDeviceUseRequestPriorityEnum, new){4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceUseRequest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'indication') then IndicationList.move(source, destination){2a}
  else if (propName = 'notes') then NotesList.move(source, destination){2}
  else if (propName = 'prnReason') then PrnReasonList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceUseRequest.fhirType : string;
begin
  result := 'DeviceUseRequest';
end;

function TFhirDeviceUseRequest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FBodySite) and isEmptyProp(FStatus) and isEmptyProp(FDevice) and isEmptyProp(FEncounter) and isEmptyProp(FidentifierList) and isEmptyProp(FindicationList) and isEmptyProp(FnotesList) and isEmptyProp(FprnReasonList) and isEmptyProp(FOrderedOn) and isEmptyProp(FRecordedOn) and isEmptyProp(FSubject) and isEmptyProp(FTiming) and isEmptyProp(FPriority);
end;

function TFhirDeviceUseRequest.equals(other : TObject) : boolean;
var
  o : TFhirDeviceUseRequest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceUseRequest)) then
    result := false
  else
  begin
    o := TFhirDeviceUseRequest(other);
    result := compareDeep(bodySiteElement, o.bodySiteElement, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(deviceElement, o.deviceElement, true) and compareDeep(encounterElement, o.encounterElement, true) and
      compareDeep(identifierList, o.identifierList, true) and compareDeep(indicationList, o.indicationList, true) and
      compareDeep(notesList, o.notesList, true) and compareDeep(prnReasonList, o.prnReasonList, true) and
      compareDeep(orderedOnElement, o.orderedOnElement, true) and compareDeep(recordedOnElement, o.recordedOnElement, true) and
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(timingElement, o.timingElement, true) and
      compareDeep(priorityElement, o.priorityElement, true);
  end;
end;

function TFhirDeviceUseRequest.Link : TFhirDeviceUseRequest;
begin
  result := TFhirDeviceUseRequest(inherited Link);
end;

function TFhirDeviceUseRequest.Clone : TFhirDeviceUseRequest;
begin
  result := TFhirDeviceUseRequest(inherited Clone);
end;

procedure TFhirDeviceUseRequest.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('bodySite[x]');
  fields.add('status');
  fields.add('device');
  fields.add('encounter');
  fields.add('identifier');
  fields.add('indication');
  fields.add('notes');
  fields.add('prnReason');
  fields.add('orderedOn');
  fields.add('recordedOn');
  fields.add('subject');
  fields.add('timing[x]');
  fields.add('priority');
end;

{ TFhirDeviceUseRequest }

Procedure TFhirDeviceUseRequest.SetBodySite(value : TFhirType);
begin
  FBodySite.free;
  FBodySite := value;
end;

Procedure TFhirDeviceUseRequest.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirDeviceUseRequest.GetStatusST : TFhirDeviceUseRequestStatusEnum;
begin
  if FStatus = nil then
    result := TFhirDeviceUseRequestStatusEnum(0)
  else
    result := TFhirDeviceUseRequestStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirDeviceUseRequestStatusEnum, FStatus.value));
end;

Procedure TFhirDeviceUseRequest.SetStatusST(value : TFhirDeviceUseRequestStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirDeviceUseRequestStatusEnum[value], CODES_TFhirDeviceUseRequestStatusEnum[value]);
end;

Procedure TFhirDeviceUseRequest.SetDevice(value : TFhirReference{TFhirDevice});
begin
  FDevice.free;
  FDevice := value;
end;

Procedure TFhirDeviceUseRequest.SetEncounter(value : TFhirReference{TFhirEncounter});
begin
  FEncounter.free;
  FEncounter := value;
end;

Function TFhirDeviceUseRequest.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirDeviceUseRequest.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Function TFhirDeviceUseRequest.GetIndicationList : TFhirCodeableConceptList;
begin
  if FIndicationList = nil then
    FIndicationList := TFhirCodeableConceptList.Create;
  result := FIndicationList;
end;

Function TFhirDeviceUseRequest.GetHasIndicationList : boolean;
begin
  result := (FIndicationList <> nil) and (FIndicationList.count > 0);
end;

Function TFhirDeviceUseRequest.GetNotesList : TFhirStringList;
begin
  if FNotesList = nil then
    FNotesList := TFhirStringList.Create;
  result := FNotesList;
end;

Function TFhirDeviceUseRequest.GetHasNotesList : boolean;
begin
  result := (FNotesList <> nil) and (FNotesList.count > 0);
end;

Function TFhirDeviceUseRequest.GetPrnReasonList : TFhirCodeableConceptList;
begin
  if FPrnReasonList = nil then
    FPrnReasonList := TFhirCodeableConceptList.Create;
  result := FPrnReasonList;
end;

Function TFhirDeviceUseRequest.GetHasPrnReasonList : boolean;
begin
  result := (FPrnReasonList <> nil) and (FPrnReasonList.count > 0);
end;

Procedure TFhirDeviceUseRequest.SetOrderedOn(value : TFhirDateTime);
begin
  FOrderedOn.free;
  FOrderedOn := value;
end;

Function TFhirDeviceUseRequest.GetOrderedOnST : TFslDateTime;
begin
  if FOrderedOn = nil then
    result := TFslDateTime.makeNull
  else
    result := FOrderedOn.value;
end;

Procedure TFhirDeviceUseRequest.SetOrderedOnST(value : TFslDateTime);
begin
  if FOrderedOn = nil then
    FOrderedOn := TFhirDateTime.create;
  FOrderedOn.value := value
end;

Procedure TFhirDeviceUseRequest.SetRecordedOn(value : TFhirDateTime);
begin
  FRecordedOn.free;
  FRecordedOn := value;
end;

Function TFhirDeviceUseRequest.GetRecordedOnST : TFslDateTime;
begin
  if FRecordedOn = nil then
    result := TFslDateTime.makeNull
  else
    result := FRecordedOn.value;
end;

Procedure TFhirDeviceUseRequest.SetRecordedOnST(value : TFslDateTime);
begin
  if FRecordedOn = nil then
    FRecordedOn := TFhirDateTime.create;
  FRecordedOn.value := value
end;

Procedure TFhirDeviceUseRequest.SetSubject(value : TFhirReference{TFhirPatient});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirDeviceUseRequest.SetTiming(value : TFhirType);
begin
  FTiming.free;
  FTiming := value;
end;

Procedure TFhirDeviceUseRequest.SetPriority(value : TFhirEnum);
begin
  FPriority.free;
  FPriority := value;
end;

Function TFhirDeviceUseRequest.GetPriorityST : TFhirDeviceUseRequestPriorityEnum;
begin
  if FPriority = nil then
    result := TFhirDeviceUseRequestPriorityEnum(0)
  else
    result := TFhirDeviceUseRequestPriorityEnum(StringArrayIndexOfSensitive(CODES_TFhirDeviceUseRequestPriorityEnum, FPriority.value));
end;

Procedure TFhirDeviceUseRequest.SetPriorityST(value : TFhirDeviceUseRequestPriorityEnum);
begin
  if ord(value) = 0 then
    PriorityElement := nil
  else
    PriorityElement := TFhirEnum.create(SYSTEMS_TFhirDeviceUseRequestPriorityEnum[value], CODES_TFhirDeviceUseRequestPriorityEnum[value]);
end;

function TFhirDeviceUseRequest.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FBodySite.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FDevice.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FindicationList.sizeInBytes);
  inc(result, FnotesList.sizeInBytes);
  inc(result, FprnReasonList.sizeInBytes);
  inc(result, FOrderedOn.sizeInBytes);
  inc(result, FRecordedOn.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FTiming.sizeInBytes);
  inc(result, FPriority.sizeInBytes);
end;

{ TFhirDeviceUseRequestListEnumerator }

Constructor TFhirDeviceUseRequestListEnumerator.Create(list : TFhirDeviceUseRequestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceUseRequestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceUseRequestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceUseRequestListEnumerator.GetCurrent : TFhirDeviceUseRequest;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceUseRequestListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDeviceUseRequestList }
procedure TFhirDeviceUseRequestList.AddItem(value: TFhirDeviceUseRequest);
begin
  assert(value.ClassName = 'TFhirDeviceUseRequest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceUseRequest');
  add(value);
end;

function TFhirDeviceUseRequestList.Append: TFhirDeviceUseRequest;
begin
  result := TFhirDeviceUseRequest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceUseRequestList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceUseRequestList.GetEnumerator : TFhirDeviceUseRequestListEnumerator;
begin
  result := TFhirDeviceUseRequestListEnumerator.Create(self.link);
end;

function TFhirDeviceUseRequestList.Clone: TFhirDeviceUseRequestList;
begin
  result := TFhirDeviceUseRequestList(inherited Clone);
end;

function TFhirDeviceUseRequestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceUseRequestList.GetItemN(index: Integer): TFhirDeviceUseRequest;
begin
  result := TFhirDeviceUseRequest(ObjectByIndex[index]);
end;

function TFhirDeviceUseRequestList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceUseRequest;
end;
function TFhirDeviceUseRequestList.IndexOf(value: TFhirDeviceUseRequest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceUseRequestList.Insert(index: Integer): TFhirDeviceUseRequest;
begin
  result := TFhirDeviceUseRequest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceUseRequestList.InsertItem(index: Integer; value: TFhirDeviceUseRequest);
begin
  assert(value is TFhirDeviceUseRequest);
  Inherited Insert(index, value);
end;

function TFhirDeviceUseRequestList.Item(index: Integer): TFhirDeviceUseRequest;
begin
  result := TFhirDeviceUseRequest(ObjectByIndex[index]);
end;

function TFhirDeviceUseRequestList.Link: TFhirDeviceUseRequestList;
begin
  result := TFhirDeviceUseRequestList(inherited Link);
end;

procedure TFhirDeviceUseRequestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceUseRequestList.SetItemByIndex(index: Integer; value: TFhirDeviceUseRequest);
begin
  assert(value is TFhirDeviceUseRequest);
  FhirDeviceUseRequests[index] := value;
end;

procedure TFhirDeviceUseRequestList.SetItemN(index: Integer; value: TFhirDeviceUseRequest);
begin
  assert(value is TFhirDeviceUseRequest);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_DEVICEUSEREQUEST}

{$IFDEF FHIR_DEVICEUSESTATEMENT}

{ TFhirDeviceUseStatement }

constructor TFhirDeviceUseStatement.Create;
begin
  inherited;
end;

destructor TFhirDeviceUseStatement.Destroy;
begin
  FBodySite.free;
  FWhenUsed.free;
  FDevice.free;
  FIdentifierList.Free;
  FIndicationList.Free;
  FNotesList.Free;
  FRecordedOn.free;
  FSubject.free;
  FTiming.free;
  inherited;
end;

function TFhirDeviceUseStatement.GetResourceType : TFhirResourceType;
begin
  result := frtDeviceUseStatement;
end;

procedure TFhirDeviceUseStatement.Assign(oSource : TFslObject);
begin
  inherited;
  bodySite := TFhirDeviceUseStatement(oSource).bodySite.Clone;
  whenUsed := TFhirDeviceUseStatement(oSource).whenUsed.Clone;
  device := TFhirDeviceUseStatement(oSource).device.Clone;
  if (TFhirDeviceUseStatement(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirDeviceUseStatement(oSource).FIdentifierList);
  end;
  if (TFhirDeviceUseStatement(oSource).FIndicationList = nil) then
  begin
    FIndicationList.free;
    FIndicationList := nil;
  end
  else
  begin
    if FIndicationList = nil then
      FIndicationList := TFhirCodeableConceptList.Create;
    FIndicationList.Assign(TFhirDeviceUseStatement(oSource).FIndicationList);
  end;
  if (TFhirDeviceUseStatement(oSource).FNotesList = nil) then
  begin
    FNotesList.free;
    FNotesList := nil;
  end
  else
  begin
    if FNotesList = nil then
      FNotesList := TFhirStringList.Create;
    FNotesList.Assign(TFhirDeviceUseStatement(oSource).FNotesList);
  end;
  recordedOnElement := TFhirDeviceUseStatement(oSource).recordedOnElement.Clone;
  subject := TFhirDeviceUseStatement(oSource).subject.Clone;
  timing := TFhirDeviceUseStatement(oSource).timing.Clone;
end;

procedure TFhirDeviceUseStatement.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'bodySite[x]') or (child_name = 'bodySite') Then
     list.add(self.link, 'bodySite[x]', FBodySite.Link);
  if (child_name = 'whenUsed') Then
     list.add(self.link, 'whenUsed', FWhenUsed.Link);
  if (child_name = 'device') Then
     list.add(self.link, 'device', FDevice.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'indication') Then
    list.addAll(self, 'indication', FIndicationList);
  if (child_name = 'notes') Then
    list.addAll(self, 'notes', FNotesList);
  if (child_name = 'recordedOn') Then
     list.add(self.link, 'recordedOn', FRecordedOn.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'timing[x]') or (child_name = 'timing') Then
     list.add(self.link, 'timing[x]', FTiming.Link);
end;

procedure TFhirDeviceUseStatement.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'bodySite[x]', 'CodeableConcept|Reference(BodySite)', false, TFhirType, FBodySite.Link));{2}
  oList.add(TFHIRProperty.create(self, 'whenUsed', 'Period', false, TFhirPeriod, FWhenUsed.Link));{2}
  oList.add(TFHIRProperty.create(self, 'device', 'Reference(Device)', false, TFhirReference{TFhirDevice}, FDevice.Link));{2}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'indication', 'CodeableConcept', true, TFhirCodeableConcept, FIndicationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'notes', 'string', true, TFhirString, FNotesList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'recordedOn', 'dateTime', false, TFhirDateTime, FRecordedOn.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'timing[x]', 'Timing|Period|dateTime', false, TFhirType, FTiming.Link));{2}
end;

function TFhirDeviceUseStatement.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'bodySite', ['CodeableConcept', 'Reference'])) then
  begin
    BodySite := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'whenUsed') then
  begin
    WhenUsed := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'device') then
  begin
    Device := propValue as TFhirReference{TFhirDevice}{4b};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'indication') then
  begin
    IndicationList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'notes') then
  begin
    NotesList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'recordedOn') then
  begin
    RecordedOnElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'timing', ['Timing', 'Period', 'DateTime'])) then
  begin
    Timing := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirDeviceUseStatement.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'indication') then IndicationList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'notes') then NotesList.insertItem(index, asString(propValue)){2}
  else inherited;
end;

function TFhirDeviceUseStatement.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'bodySite', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property BodySite'){4x}
  else if (propName = 'whenUsed') then result := TFhirPeriod.create(){4b}
  else if (propName = 'device') then result := TFhirReference{TFhirDevice}.create(){4b}
  else if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'indication') then result := IndicationList.new(){2}
  else if (propName = 'notes') then result := NotesList.new(){2}
  else if (propName = 'recordedOn') then result := TFhirDateTime.create() {5b}
  else if (propName = 'subject') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (isMatchingName(propName, 'timing', ['Timing', 'Period', 'DateTime'])) then raise EFHIRException.create('Cannot make property Timing'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceUseStatement.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'bodySite[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'whenUsed') then result := 'Period'
  else if (propName = 'device') then result := 'Reference'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'indication') then result := 'CodeableConcept'
  else if (propName = 'notes') then result := 'string'
  else if (propName = 'recordedOn') then result := 'dateTime'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'timing[x]') then result := 'Timing|Period|dateTime'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceUseStatement.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'bodySite', ['CodeableConcept', 'Reference'])) then BodySiteElement := nil{4x}
  else if (propName = 'whenUsed') then WhenUsedElement := nil
  else if (propName = 'device') then DeviceElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'indication') then deletePropertyValue('indication', IndicationList, value) {2}
  else if (propName = 'notes') then deletePropertyValue('notes', NotesList, value) {2}
  else if (propName = 'recordedOn') then RecordedOnElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (isMatchingName(propName, 'timing', ['Timing', 'Period', 'DateTime'])) then TimingElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceUseStatement.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'bodySite', ['CodeableConcept', 'Reference'])) then BodySiteElement := new as TFhirType{4x}
  else if (propName = 'whenUsed') then WhenUsedElement := new as TFhirPeriod{4}
  else if (propName = 'device') then DeviceElement := new as TFhirReference{TFhirDevice}{4}
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'indication') then replacePropertyValue('indication', IndicationList, existing, new) {2}
  else if (propName = 'notes') then replacePropertyValue('notes', NotesList, existing, new) {2}
  else if (propName = 'recordedOn') then RecordedOnElement := asDateTime(new){5b}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{TFhirPatient}{4}
  else if (isMatchingName(propName, 'timing', ['Timing', 'Period', 'DateTime'])) then TimingElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceUseStatement.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'indication') then IndicationList.move(source, destination){2a}
  else if (propName = 'notes') then NotesList.move(source, destination){2}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceUseStatement.fhirType : string;
begin
  result := 'DeviceUseStatement';
end;

function TFhirDeviceUseStatement.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FBodySite) and isEmptyProp(FWhenUsed) and isEmptyProp(FDevice) and isEmptyProp(FidentifierList) and isEmptyProp(FindicationList) and isEmptyProp(FnotesList) and isEmptyProp(FRecordedOn) and isEmptyProp(FSubject) and isEmptyProp(FTiming);
end;

function TFhirDeviceUseStatement.equals(other : TObject) : boolean;
var
  o : TFhirDeviceUseStatement;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceUseStatement)) then
    result := false
  else
  begin
    o := TFhirDeviceUseStatement(other);
    result := compareDeep(bodySiteElement, o.bodySiteElement, true) and compareDeep(whenUsedElement, o.whenUsedElement, true) and
      compareDeep(deviceElement, o.deviceElement, true) and compareDeep(identifierList, o.identifierList, true) and
      compareDeep(indicationList, o.indicationList, true) and compareDeep(notesList, o.notesList, true) and
      compareDeep(recordedOnElement, o.recordedOnElement, true) and compareDeep(subjectElement, o.subjectElement, true) and
      compareDeep(timingElement, o.timingElement, true);
  end;
end;

function TFhirDeviceUseStatement.Link : TFhirDeviceUseStatement;
begin
  result := TFhirDeviceUseStatement(inherited Link);
end;

function TFhirDeviceUseStatement.Clone : TFhirDeviceUseStatement;
begin
  result := TFhirDeviceUseStatement(inherited Clone);
end;

procedure TFhirDeviceUseStatement.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('bodySite[x]');
  fields.add('whenUsed');
  fields.add('device');
  fields.add('identifier');
  fields.add('indication');
  fields.add('notes');
  fields.add('recordedOn');
  fields.add('subject');
  fields.add('timing[x]');
end;

{ TFhirDeviceUseStatement }

Procedure TFhirDeviceUseStatement.SetBodySite(value : TFhirType);
begin
  FBodySite.free;
  FBodySite := value;
end;

Procedure TFhirDeviceUseStatement.SetWhenUsed(value : TFhirPeriod);
begin
  FWhenUsed.free;
  FWhenUsed := value;
end;

Procedure TFhirDeviceUseStatement.SetDevice(value : TFhirReference{TFhirDevice});
begin
  FDevice.free;
  FDevice := value;
end;

Function TFhirDeviceUseStatement.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirDeviceUseStatement.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Function TFhirDeviceUseStatement.GetIndicationList : TFhirCodeableConceptList;
begin
  if FIndicationList = nil then
    FIndicationList := TFhirCodeableConceptList.Create;
  result := FIndicationList;
end;

Function TFhirDeviceUseStatement.GetHasIndicationList : boolean;
begin
  result := (FIndicationList <> nil) and (FIndicationList.count > 0);
end;

Function TFhirDeviceUseStatement.GetNotesList : TFhirStringList;
begin
  if FNotesList = nil then
    FNotesList := TFhirStringList.Create;
  result := FNotesList;
end;

Function TFhirDeviceUseStatement.GetHasNotesList : boolean;
begin
  result := (FNotesList <> nil) and (FNotesList.count > 0);
end;

Procedure TFhirDeviceUseStatement.SetRecordedOn(value : TFhirDateTime);
begin
  FRecordedOn.free;
  FRecordedOn := value;
end;

Function TFhirDeviceUseStatement.GetRecordedOnST : TFslDateTime;
begin
  if FRecordedOn = nil then
    result := TFslDateTime.makeNull
  else
    result := FRecordedOn.value;
end;

Procedure TFhirDeviceUseStatement.SetRecordedOnST(value : TFslDateTime);
begin
  if FRecordedOn = nil then
    FRecordedOn := TFhirDateTime.create;
  FRecordedOn.value := value
end;

Procedure TFhirDeviceUseStatement.SetSubject(value : TFhirReference{TFhirPatient});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirDeviceUseStatement.SetTiming(value : TFhirType);
begin
  FTiming.free;
  FTiming := value;
end;

function TFhirDeviceUseStatement.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FBodySite.sizeInBytes);
  inc(result, FWhenUsed.sizeInBytes);
  inc(result, FDevice.sizeInBytes);
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FindicationList.sizeInBytes);
  inc(result, FnotesList.sizeInBytes);
  inc(result, FRecordedOn.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FTiming.sizeInBytes);
end;

{ TFhirDeviceUseStatementListEnumerator }

Constructor TFhirDeviceUseStatementListEnumerator.Create(list : TFhirDeviceUseStatementList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceUseStatementListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceUseStatementListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceUseStatementListEnumerator.GetCurrent : TFhirDeviceUseStatement;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceUseStatementListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDeviceUseStatementList }
procedure TFhirDeviceUseStatementList.AddItem(value: TFhirDeviceUseStatement);
begin
  assert(value.ClassName = 'TFhirDeviceUseStatement', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceUseStatement');
  add(value);
end;

function TFhirDeviceUseStatementList.Append: TFhirDeviceUseStatement;
begin
  result := TFhirDeviceUseStatement.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceUseStatementList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceUseStatementList.GetEnumerator : TFhirDeviceUseStatementListEnumerator;
begin
  result := TFhirDeviceUseStatementListEnumerator.Create(self.link);
end;

function TFhirDeviceUseStatementList.Clone: TFhirDeviceUseStatementList;
begin
  result := TFhirDeviceUseStatementList(inherited Clone);
end;

function TFhirDeviceUseStatementList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceUseStatementList.GetItemN(index: Integer): TFhirDeviceUseStatement;
begin
  result := TFhirDeviceUseStatement(ObjectByIndex[index]);
end;

function TFhirDeviceUseStatementList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceUseStatement;
end;
function TFhirDeviceUseStatementList.IndexOf(value: TFhirDeviceUseStatement): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceUseStatementList.Insert(index: Integer): TFhirDeviceUseStatement;
begin
  result := TFhirDeviceUseStatement.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceUseStatementList.InsertItem(index: Integer; value: TFhirDeviceUseStatement);
begin
  assert(value is TFhirDeviceUseStatement);
  Inherited Insert(index, value);
end;

function TFhirDeviceUseStatementList.Item(index: Integer): TFhirDeviceUseStatement;
begin
  result := TFhirDeviceUseStatement(ObjectByIndex[index]);
end;

function TFhirDeviceUseStatementList.Link: TFhirDeviceUseStatementList;
begin
  result := TFhirDeviceUseStatementList(inherited Link);
end;

procedure TFhirDeviceUseStatementList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceUseStatementList.SetItemByIndex(index: Integer; value: TFhirDeviceUseStatement);
begin
  assert(value is TFhirDeviceUseStatement);
  FhirDeviceUseStatements[index] := value;
end;

procedure TFhirDeviceUseStatementList.SetItemN(index: Integer; value: TFhirDeviceUseStatement);
begin
  assert(value is TFhirDeviceUseStatement);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_DEVICEUSESTATEMENT}

{$IFDEF FHIR_DIAGNOSTICORDER}

{ TFhirDiagnosticOrderEvent }

constructor TFhirDiagnosticOrderEvent.Create;
begin
  inherited;
end;

destructor TFhirDiagnosticOrderEvent.Destroy;
begin
  FStatus.free;
  FDescription.free;
  FDateTime.free;
  FActor.free;
  inherited;
end;

procedure TFhirDiagnosticOrderEvent.Assign(oSource : TFslObject);
begin
  inherited;
  FStatus := TFhirDiagnosticOrderEvent(oSource).FStatus.Link;
  description := TFhirDiagnosticOrderEvent(oSource).description.Clone;
  dateTimeElement := TFhirDiagnosticOrderEvent(oSource).dateTimeElement.Clone;
  actor := TFhirDiagnosticOrderEvent(oSource).actor.Clone;
end;

procedure TFhirDiagnosticOrderEvent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'dateTime') Then
     list.add(self.link, 'dateTime', FDateTime.Link);
  if (child_name = 'actor') Then
     list.add(self.link, 'actor', FActor.Link);
end;

procedure TFhirDiagnosticOrderEvent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'description', 'CodeableConcept', false, TFhirCodeableConcept, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dateTime', 'dateTime', false, TFhirDateTime, FDateTime.Link));{2}
  oList.add(TFHIRProperty.create(self, 'actor', 'Reference(Practitioner|Device)', false, TFhirReference{Resource}, FActor.Link));{2}
end;

function TFhirDiagnosticOrderEvent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirDiagnosticOrderStatusEnum, CODES_TFhirDiagnosticOrderStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'description') then
  begin
    Description := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'dateTime') then
  begin
    DateTimeElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    Actor := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDiagnosticOrderEvent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDiagnosticOrderEvent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'dateTime') then result := TFhirDateTime.create() {5b}
  else if (propName = 'actor') then result := TFhirReference{Resource}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDiagnosticOrderEvent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'status') then result := 'code'
  else if (propName = 'description') then result := 'CodeableConcept'
  else if (propName = 'dateTime') then result := 'dateTime'
  else if (propName = 'actor') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDiagnosticOrderEvent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'dateTime') then DateTimeElement := nil
  else if (propName = 'actor') then ActorElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDiagnosticOrderEvent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirDiagnosticOrderStatusEnum, CODES_TFhirDiagnosticOrderStatusEnum, new){4}
  else if (propName = 'description') then DescriptionElement := new as TFhirCodeableConcept{4}
  else if (propName = 'dateTime') then DateTimeElement := asDateTime(new){5b}
  else if (propName = 'actor') then ActorElement := new as TFhirReference{Resource}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDiagnosticOrderEvent.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDiagnosticOrderEvent.fhirType : string;
begin
  result := 'event';
end;

function TFhirDiagnosticOrderEvent.Link : TFhirDiagnosticOrderEvent;
begin
  result := TFhirDiagnosticOrderEvent(inherited Link);
end;

function TFhirDiagnosticOrderEvent.Clone : TFhirDiagnosticOrderEvent;
begin
  result := TFhirDiagnosticOrderEvent(inherited Clone);
end;

function TFhirDiagnosticOrderEvent.equals(other : TObject) : boolean;
var
  o : TFhirDiagnosticOrderEvent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDiagnosticOrderEvent)) then
    result := false
  else
  begin
    o := TFhirDiagnosticOrderEvent(other);
    result := compareDeep(statusElement, o.statusElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and
      compareDeep(dateTimeElement, o.dateTimeElement, true) and compareDeep(actorElement, o.actorElement, true);
  end;
end;

function TFhirDiagnosticOrderEvent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FStatus) and isEmptyProp(FDescription) and isEmptyProp(FDateTime) and isEmptyProp(FActor);
end;

procedure TFhirDiagnosticOrderEvent.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('status');
  fields.add('description');
  fields.add('dateTime');
  fields.add('actor');
end;

{ TFhirDiagnosticOrderEvent }

Procedure TFhirDiagnosticOrderEvent.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirDiagnosticOrderEvent.GetStatusST : TFhirDiagnosticOrderStatusEnum;
begin
  if FStatus = nil then
    result := TFhirDiagnosticOrderStatusEnum(0)
  else
    result := TFhirDiagnosticOrderStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirDiagnosticOrderStatusEnum, FStatus.value));
end;

Procedure TFhirDiagnosticOrderEvent.SetStatusST(value : TFhirDiagnosticOrderStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirDiagnosticOrderStatusEnum[value], CODES_TFhirDiagnosticOrderStatusEnum[value]);
end;

Procedure TFhirDiagnosticOrderEvent.SetDescription(value : TFhirCodeableConcept);
begin
  FDescription.free;
  FDescription := value;
end;

Procedure TFhirDiagnosticOrderEvent.SetDateTime(value : TFhirDateTime);
begin
  FDateTime.free;
  FDateTime := value;
end;

Function TFhirDiagnosticOrderEvent.GetDateTimeST : TFslDateTime;
begin
  if FDateTime = nil then
    result := TFslDateTime.makeNull
  else
    result := FDateTime.value;
end;

Procedure TFhirDiagnosticOrderEvent.SetDateTimeST(value : TFslDateTime);
begin
  if FDateTime = nil then
    FDateTime := TFhirDateTime.create;
  FDateTime.value := value
end;

Procedure TFhirDiagnosticOrderEvent.SetActor(value : TFhirReference{Resource});
begin
  FActor.free;
  FActor := value;
end;

function TFhirDiagnosticOrderEvent.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FStatus.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FDateTime.sizeInBytes);
  inc(result, FActor.sizeInBytes);
end;

{ TFhirDiagnosticOrderEventListEnumerator }

Constructor TFhirDiagnosticOrderEventListEnumerator.Create(list : TFhirDiagnosticOrderEventList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDiagnosticOrderEventListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDiagnosticOrderEventListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDiagnosticOrderEventListEnumerator.GetCurrent : TFhirDiagnosticOrderEvent;
begin
  Result := FList[FIndex];
end;

function TFhirDiagnosticOrderEventListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDiagnosticOrderEventList }
procedure TFhirDiagnosticOrderEventList.AddItem(value: TFhirDiagnosticOrderEvent);
begin
  assert(value.ClassName = 'TFhirDiagnosticOrderEvent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDiagnosticOrderEvent');
  add(value);
end;

function TFhirDiagnosticOrderEventList.Append: TFhirDiagnosticOrderEvent;
begin
  result := TFhirDiagnosticOrderEvent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDiagnosticOrderEventList.ClearItems;
begin
  Clear;
end;

function TFhirDiagnosticOrderEventList.GetEnumerator : TFhirDiagnosticOrderEventListEnumerator;
begin
  result := TFhirDiagnosticOrderEventListEnumerator.Create(self.link);
end;

function TFhirDiagnosticOrderEventList.Clone: TFhirDiagnosticOrderEventList;
begin
  result := TFhirDiagnosticOrderEventList(inherited Clone);
end;

function TFhirDiagnosticOrderEventList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDiagnosticOrderEventList.GetItemN(index: Integer): TFhirDiagnosticOrderEvent;
begin
  result := TFhirDiagnosticOrderEvent(ObjectByIndex[index]);
end;

function TFhirDiagnosticOrderEventList.ItemClass: TFslObjectClass;
begin
  result := TFhirDiagnosticOrderEvent;
end;
function TFhirDiagnosticOrderEventList.IndexOf(value: TFhirDiagnosticOrderEvent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDiagnosticOrderEventList.Insert(index: Integer): TFhirDiagnosticOrderEvent;
begin
  result := TFhirDiagnosticOrderEvent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDiagnosticOrderEventList.InsertItem(index: Integer; value: TFhirDiagnosticOrderEvent);
begin
  assert(value is TFhirDiagnosticOrderEvent);
  Inherited Insert(index, value);
end;

function TFhirDiagnosticOrderEventList.Item(index: Integer): TFhirDiagnosticOrderEvent;
begin
  result := TFhirDiagnosticOrderEvent(ObjectByIndex[index]);
end;

function TFhirDiagnosticOrderEventList.Link: TFhirDiagnosticOrderEventList;
begin
  result := TFhirDiagnosticOrderEventList(inherited Link);
end;

procedure TFhirDiagnosticOrderEventList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDiagnosticOrderEventList.SetItemByIndex(index: Integer; value: TFhirDiagnosticOrderEvent);
begin
  assert(value is TFhirDiagnosticOrderEvent);
  FhirDiagnosticOrderEvents[index] := value;
end;

procedure TFhirDiagnosticOrderEventList.SetItemN(index: Integer; value: TFhirDiagnosticOrderEvent);
begin
  assert(value is TFhirDiagnosticOrderEvent);
  ObjectByIndex[index] := value;
end;

{ TFhirDiagnosticOrderItem }

constructor TFhirDiagnosticOrderItem.Create;
begin
  inherited;
end;

destructor TFhirDiagnosticOrderItem.Destroy;
begin
  FCode.free;
  FSpecimenList.Free;
  FBodySite.free;
  FStatus.free;
  FEventList.Free;
  inherited;
end;

procedure TFhirDiagnosticOrderItem.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirDiagnosticOrderItem(oSource).code.Clone;
  if (TFhirDiagnosticOrderItem(oSource).FSpecimenList = nil) then
  begin
    FSpecimenList.free;
    FSpecimenList := nil;
  end
  else
  begin
    if FSpecimenList = nil then
      FSpecimenList := TFhirReferenceList{TFhirSpecimen}.Create;
    FSpecimenList.Assign(TFhirDiagnosticOrderItem(oSource).FSpecimenList);
  end;
  bodySite := TFhirDiagnosticOrderItem(oSource).bodySite.Clone;
  FStatus := TFhirDiagnosticOrderItem(oSource).FStatus.Link;
  if (TFhirDiagnosticOrderItem(oSource).FEventList = nil) then
  begin
    FEventList.free;
    FEventList := nil;
  end
  else
  begin
    if FEventList = nil then
      FEventList := TFhirDiagnosticOrderEventList.Create;
    FEventList.Assign(TFhirDiagnosticOrderItem(oSource).FEventList);
  end;
end;

procedure TFhirDiagnosticOrderItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'specimen') Then
    list.addAll(self, 'specimen', FSpecimenList);
  if (child_name = 'bodySite') Then
     list.add(self.link, 'bodySite', FBodySite.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'event') Then
    list.addAll(self, 'event', FEventList);
end;

procedure TFhirDiagnosticOrderItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'specimen', 'Reference(Specimen)', true, TFhirReference{TFhirSpecimen}, FSpecimenList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', false, TFhirCodeableConcept, FBodySite.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'event', '@DiagnosticOrder.event', true, TFhirDiagnosticOrderEvent, FEventList.Link)){3};
end;

function TFhirDiagnosticOrderItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'specimen') then
  begin
    SpecimenList.add(propValue as TFhirReference{TFhirSpecimen}){2a};
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySite := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirDiagnosticOrderStatusEnum, CODES_TFhirDiagnosticOrderStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'event') then
  begin
    EventList.add(propValue as TFhirDiagnosticOrderEvent){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDiagnosticOrderItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'specimen') then SpecimenList.insertItem(index, propValue as TFhirReference{TFhirSpecimen}){2a}
  else if (propName = 'event') then EventList.insertItem(index, propValue as TFhirDiagnosticOrderEvent){2a}
  else inherited;
end;

function TFhirDiagnosticOrderItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'specimen') then result := SpecimenList.new(){2}
  else if (propName = 'bodySite') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'event') then result := EventList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDiagnosticOrderItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'specimen') then result := 'Reference'
  else if (propName = 'bodySite') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'event') then result := '@DiagnosticOrder.event'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDiagnosticOrderItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'specimen') then deletePropertyValue('specimen', SpecimenList, value) {2}
  else if (propName = 'bodySite') then BodySiteElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'event') then deletePropertyValue('event', EventList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDiagnosticOrderItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'specimen') then replacePropertyValue('specimen', SpecimenList, existing, new) {2}
  else if (propName = 'bodySite') then BodySiteElement := new as TFhirCodeableConcept{4}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirDiagnosticOrderStatusEnum, CODES_TFhirDiagnosticOrderStatusEnum, new){4}
  else if (propName = 'event') then replacePropertyValue('event', EventList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDiagnosticOrderItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'specimen') then SpecimenList.move(source, destination){2a}
  else if (propName = 'event') then EventList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDiagnosticOrderItem.fhirType : string;
begin
  result := 'item';
end;

function TFhirDiagnosticOrderItem.Link : TFhirDiagnosticOrderItem;
begin
  result := TFhirDiagnosticOrderItem(inherited Link);
end;

function TFhirDiagnosticOrderItem.Clone : TFhirDiagnosticOrderItem;
begin
  result := TFhirDiagnosticOrderItem(inherited Clone);
end;

function TFhirDiagnosticOrderItem.equals(other : TObject) : boolean;
var
  o : TFhirDiagnosticOrderItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDiagnosticOrderItem)) then
    result := false
  else
  begin
    o := TFhirDiagnosticOrderItem(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(specimenList, o.specimenList, true) and
      compareDeep(bodySiteElement, o.bodySiteElement, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(eventList, o.eventList, true);
  end;
end;

function TFhirDiagnosticOrderItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FspecimenList) and isEmptyProp(FBodySite) and isEmptyProp(FStatus) and isEmptyProp(FeventList);
end;

procedure TFhirDiagnosticOrderItem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('specimen');
  fields.add('bodySite');
  fields.add('status');
  fields.add('event');
end;

{ TFhirDiagnosticOrderItem }

Procedure TFhirDiagnosticOrderItem.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirDiagnosticOrderItem.GetSpecimenList : TFhirReferenceList{TFhirSpecimen};
begin
  if FSpecimenList = nil then
    FSpecimenList := TFhirReferenceList{TFhirSpecimen}.Create;
  result := FSpecimenList;
end;

Function TFhirDiagnosticOrderItem.GetHasSpecimenList : boolean;
begin
  result := (FSpecimenList <> nil) and (FSpecimenList.count > 0);
end;

Procedure TFhirDiagnosticOrderItem.SetBodySite(value : TFhirCodeableConcept);
begin
  FBodySite.free;
  FBodySite := value;
end;

Procedure TFhirDiagnosticOrderItem.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirDiagnosticOrderItem.GetStatusST : TFhirDiagnosticOrderStatusEnum;
begin
  if FStatus = nil then
    result := TFhirDiagnosticOrderStatusEnum(0)
  else
    result := TFhirDiagnosticOrderStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirDiagnosticOrderStatusEnum, FStatus.value));
end;

Procedure TFhirDiagnosticOrderItem.SetStatusST(value : TFhirDiagnosticOrderStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirDiagnosticOrderStatusEnum[value], CODES_TFhirDiagnosticOrderStatusEnum[value]);
end;

Function TFhirDiagnosticOrderItem.GetEventList : TFhirDiagnosticOrderEventList;
begin
  if FEventList = nil then
    FEventList := TFhirDiagnosticOrderEventList.Create;
  result := FEventList;
end;

Function TFhirDiagnosticOrderItem.GetHasEventList : boolean;
begin
  result := (FEventList <> nil) and (FEventList.count > 0);
end;

function TFhirDiagnosticOrderItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FspecimenList.sizeInBytes);
  inc(result, FBodySite.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FeventList.sizeInBytes);
end;

{ TFhirDiagnosticOrderItemListEnumerator }

Constructor TFhirDiagnosticOrderItemListEnumerator.Create(list : TFhirDiagnosticOrderItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDiagnosticOrderItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDiagnosticOrderItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDiagnosticOrderItemListEnumerator.GetCurrent : TFhirDiagnosticOrderItem;
begin
  Result := FList[FIndex];
end;

function TFhirDiagnosticOrderItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDiagnosticOrderItemList }
procedure TFhirDiagnosticOrderItemList.AddItem(value: TFhirDiagnosticOrderItem);
begin
  assert(value.ClassName = 'TFhirDiagnosticOrderItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDiagnosticOrderItem');
  add(value);
end;

function TFhirDiagnosticOrderItemList.Append: TFhirDiagnosticOrderItem;
begin
  result := TFhirDiagnosticOrderItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDiagnosticOrderItemList.ClearItems;
begin
  Clear;
end;

function TFhirDiagnosticOrderItemList.GetEnumerator : TFhirDiagnosticOrderItemListEnumerator;
begin
  result := TFhirDiagnosticOrderItemListEnumerator.Create(self.link);
end;

function TFhirDiagnosticOrderItemList.Clone: TFhirDiagnosticOrderItemList;
begin
  result := TFhirDiagnosticOrderItemList(inherited Clone);
end;

function TFhirDiagnosticOrderItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDiagnosticOrderItemList.GetItemN(index: Integer): TFhirDiagnosticOrderItem;
begin
  result := TFhirDiagnosticOrderItem(ObjectByIndex[index]);
end;

function TFhirDiagnosticOrderItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirDiagnosticOrderItem;
end;
function TFhirDiagnosticOrderItemList.IndexOf(value: TFhirDiagnosticOrderItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDiagnosticOrderItemList.Insert(index: Integer): TFhirDiagnosticOrderItem;
begin
  result := TFhirDiagnosticOrderItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDiagnosticOrderItemList.InsertItem(index: Integer; value: TFhirDiagnosticOrderItem);
begin
  assert(value is TFhirDiagnosticOrderItem);
  Inherited Insert(index, value);
end;

function TFhirDiagnosticOrderItemList.Item(index: Integer): TFhirDiagnosticOrderItem;
begin
  result := TFhirDiagnosticOrderItem(ObjectByIndex[index]);
end;

function TFhirDiagnosticOrderItemList.Link: TFhirDiagnosticOrderItemList;
begin
  result := TFhirDiagnosticOrderItemList(inherited Link);
end;

procedure TFhirDiagnosticOrderItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDiagnosticOrderItemList.SetItemByIndex(index: Integer; value: TFhirDiagnosticOrderItem);
begin
  assert(value is TFhirDiagnosticOrderItem);
  FhirDiagnosticOrderItems[index] := value;
end;

procedure TFhirDiagnosticOrderItemList.SetItemN(index: Integer; value: TFhirDiagnosticOrderItem);
begin
  assert(value is TFhirDiagnosticOrderItem);
  ObjectByIndex[index] := value;
end;

{ TFhirDiagnosticOrder }

constructor TFhirDiagnosticOrder.Create;
begin
  inherited;
end;

destructor TFhirDiagnosticOrder.Destroy;
begin
  FSubject.free;
  FOrderer.free;
  FIdentifierList.Free;
  FEncounter.free;
  FReasonList.Free;
  FSupportingInformationList.Free;
  FSpecimenList.Free;
  FStatus.free;
  FPriority.free;
  FEventList.Free;
  FItemList.Free;
  FNoteList.Free;
  inherited;
end;

function TFhirDiagnosticOrder.GetResourceType : TFhirResourceType;
begin
  result := frtDiagnosticOrder;
end;

procedure TFhirDiagnosticOrder.Assign(oSource : TFslObject);
begin
  inherited;
  subject := TFhirDiagnosticOrder(oSource).subject.Clone;
  orderer := TFhirDiagnosticOrder(oSource).orderer.Clone;
  if (TFhirDiagnosticOrder(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirDiagnosticOrder(oSource).FIdentifierList);
  end;
  encounter := TFhirDiagnosticOrder(oSource).encounter.Clone;
  if (TFhirDiagnosticOrder(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableConceptList.Create;
    FReasonList.Assign(TFhirDiagnosticOrder(oSource).FReasonList);
  end;
  if (TFhirDiagnosticOrder(oSource).FSupportingInformationList = nil) then
  begin
    FSupportingInformationList.free;
    FSupportingInformationList := nil;
  end
  else
  begin
    if FSupportingInformationList = nil then
      FSupportingInformationList := TFhirReferenceList{Resource}.Create;
    FSupportingInformationList.Assign(TFhirDiagnosticOrder(oSource).FSupportingInformationList);
  end;
  if (TFhirDiagnosticOrder(oSource).FSpecimenList = nil) then
  begin
    FSpecimenList.free;
    FSpecimenList := nil;
  end
  else
  begin
    if FSpecimenList = nil then
      FSpecimenList := TFhirReferenceList{TFhirSpecimen}.Create;
    FSpecimenList.Assign(TFhirDiagnosticOrder(oSource).FSpecimenList);
  end;
  FStatus := TFhirDiagnosticOrder(oSource).FStatus.Link;
  FPriority := TFhirDiagnosticOrder(oSource).FPriority.Link;
  if (TFhirDiagnosticOrder(oSource).FEventList = nil) then
  begin
    FEventList.free;
    FEventList := nil;
  end
  else
  begin
    if FEventList = nil then
      FEventList := TFhirDiagnosticOrderEventList.Create;
    FEventList.Assign(TFhirDiagnosticOrder(oSource).FEventList);
  end;
  if (TFhirDiagnosticOrder(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirDiagnosticOrderItemList.Create;
    FItemList.Assign(TFhirDiagnosticOrder(oSource).FItemList);
  end;
  if (TFhirDiagnosticOrder(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirDiagnosticOrder(oSource).FNoteList);
  end;
end;

procedure TFhirDiagnosticOrder.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'orderer') Then
     list.add(self.link, 'orderer', FOrderer.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'supportingInformation') Then
    list.addAll(self, 'supportingInformation', FSupportingInformationList);
  if (child_name = 'specimen') Then
    list.addAll(self, 'specimen', FSpecimenList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'event') Then
    list.addAll(self, 'event', FEventList);
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirDiagnosticOrder.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Group|Location|Device)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'orderer', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FOrderer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference(Encounter)', false, TFhirReference{TFhirEncounter}, FEncounter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', true, TFhirCodeableConcept, FReasonList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'supportingInformation', 'Reference(Observation|Condition|DocumentReference)', true, TFhirReference{Resource}, FSupportingInformationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'specimen', 'Reference(Specimen)', true, TFhirReference{TFhirSpecimen}, FSpecimenList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'priority', 'code', false, TFHIREnum, FPriority.Link));{1}
  oList.add(TFHIRProperty.create(self, 'event', '', true, TFhirDiagnosticOrderEvent, FEventList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'item', '', true, TFhirDiagnosticOrderItem, FItemList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
end;

function TFhirDiagnosticOrder.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'orderer') then
  begin
    Orderer := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference{TFhirEncounter}{4b};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'supportingInformation') then
  begin
    SupportingInformationList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'specimen') then
  begin
    SpecimenList.add(propValue as TFhirReference{TFhirSpecimen}){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirDiagnosticOrderStatusEnum, CODES_TFhirDiagnosticOrderStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asEnum(SYSTEMS_TFhirDiagnosticOrderPriorityEnum, CODES_TFhirDiagnosticOrderPriorityEnum, propValue);
    result := propValue
  end
  else if (propName = 'event') then
  begin
    EventList.add(propValue as TFhirDiagnosticOrderEvent){2a};
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirDiagnosticOrderItem){2a};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirDiagnosticOrder.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'supportingInformation') then SupportingInformationList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'specimen') then SpecimenList.insertItem(index, propValue as TFhirReference{TFhirSpecimen}){2a}
  else if (propName = 'event') then EventList.insertItem(index, propValue as TFhirDiagnosticOrderEvent){2a}
  else if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirDiagnosticOrderItem){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else inherited;
end;

function TFhirDiagnosticOrder.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'orderer') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'encounter') then result := TFhirReference{TFhirEncounter}.create(){4b}
  else if (propName = 'reason') then result := ReasonList.new(){2}
  else if (propName = 'supportingInformation') then result := SupportingInformationList.new(){2}
  else if (propName = 'specimen') then result := SpecimenList.new(){2}
  else if (propName = 'event') then result := EventList.new(){2}
  else if (propName = 'item') then result := ItemList.new(){2}
  else if (propName = 'note') then result := NoteList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDiagnosticOrder.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'subject') then result := 'Reference'
  else if (propName = 'orderer') then result := 'Reference'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else if (propName = 'supportingInformation') then result := 'Reference'
  else if (propName = 'specimen') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'priority') then result := 'code'
  else if (propName = 'event') then result := ''
  else if (propName = 'item') then result := ''
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDiagnosticOrder.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'orderer') then OrdererElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value) {2}
  else if (propName = 'supportingInformation') then deletePropertyValue('supportingInformation', SupportingInformationList, value) {2}
  else if (propName = 'specimen') then deletePropertyValue('specimen', SpecimenList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'event') then deletePropertyValue('event', EventList, value) {2}
  else if (propName = 'item') then deletePropertyValue('item', ItemList, value) {2}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDiagnosticOrder.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'orderer') then OrdererElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference{TFhirEncounter}{4}
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new) {2}
  else if (propName = 'supportingInformation') then replacePropertyValue('supportingInformation', SupportingInformationList, existing, new) {2}
  else if (propName = 'specimen') then replacePropertyValue('specimen', SpecimenList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirDiagnosticOrderStatusEnum, CODES_TFhirDiagnosticOrderStatusEnum, new){4}
  else if (propName = 'priority') then PriorityElement := asEnum(SYSTEMS_TFhirDiagnosticOrderPriorityEnum, CODES_TFhirDiagnosticOrderPriorityEnum, new){4}
  else if (propName = 'event') then replacePropertyValue('event', EventList, existing, new) {2}
  else if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new) {2}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDiagnosticOrder.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'reason') then ReasonList.move(source, destination){2a}
  else if (propName = 'supportingInformation') then SupportingInformationList.move(source, destination){2a}
  else if (propName = 'specimen') then SpecimenList.move(source, destination){2a}
  else if (propName = 'event') then EventList.move(source, destination){2a}
  else if (propName = 'item') then ItemList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDiagnosticOrder.fhirType : string;
begin
  result := 'DiagnosticOrder';
end;

function TFhirDiagnosticOrder.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSubject) and isEmptyProp(FOrderer) and isEmptyProp(FidentifierList) and isEmptyProp(FEncounter) and isEmptyProp(FreasonList) and isEmptyProp(FsupportingInformationList) and isEmptyProp(FspecimenList) and isEmptyProp(FStatus) and isEmptyProp(FPriority) and isEmptyProp(FeventList) and isEmptyProp(FitemList) and isEmptyProp(FnoteList);
end;

function TFhirDiagnosticOrder.equals(other : TObject) : boolean;
var
  o : TFhirDiagnosticOrder;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDiagnosticOrder)) then
    result := false
  else
  begin
    o := TFhirDiagnosticOrder(other);
    result := compareDeep(subjectElement, o.subjectElement, true) and compareDeep(ordererElement, o.ordererElement, true) and
      compareDeep(identifierList, o.identifierList, true) and compareDeep(encounterElement, o.encounterElement, true) and
      compareDeep(reasonList, o.reasonList, true) and compareDeep(supportingInformationList, o.supportingInformationList, true) and
      compareDeep(specimenList, o.specimenList, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(priorityElement, o.priorityElement, true) and compareDeep(eventList, o.eventList, true) and
      compareDeep(itemList, o.itemList, true) and compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirDiagnosticOrder.Link : TFhirDiagnosticOrder;
begin
  result := TFhirDiagnosticOrder(inherited Link);
end;

function TFhirDiagnosticOrder.Clone : TFhirDiagnosticOrder;
begin
  result := TFhirDiagnosticOrder(inherited Clone);
end;

procedure TFhirDiagnosticOrder.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('subject');
  fields.add('orderer');
  fields.add('identifier');
  fields.add('encounter');
  fields.add('reason');
  fields.add('supportingInformation');
  fields.add('specimen');
  fields.add('status');
  fields.add('priority');
  fields.add('event');
  fields.add('item');
  fields.add('note');
end;

{ TFhirDiagnosticOrder }

Procedure TFhirDiagnosticOrder.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirDiagnosticOrder.SetOrderer(value : TFhirReference{TFhirPractitioner});
begin
  FOrderer.free;
  FOrderer := value;
end;

Function TFhirDiagnosticOrder.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirDiagnosticOrder.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirDiagnosticOrder.SetEncounter(value : TFhirReference{TFhirEncounter});
begin
  FEncounter.free;
  FEncounter := value;
end;

Function TFhirDiagnosticOrder.GetReasonList : TFhirCodeableConceptList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableConceptList.Create;
  result := FReasonList;
end;

Function TFhirDiagnosticOrder.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

Function TFhirDiagnosticOrder.GetSupportingInformationList : TFhirReferenceList{Resource};
begin
  if FSupportingInformationList = nil then
    FSupportingInformationList := TFhirReferenceList{Resource}.Create;
  result := FSupportingInformationList;
end;

Function TFhirDiagnosticOrder.GetHasSupportingInformationList : boolean;
begin
  result := (FSupportingInformationList <> nil) and (FSupportingInformationList.count > 0);
end;

Function TFhirDiagnosticOrder.GetSpecimenList : TFhirReferenceList{TFhirSpecimen};
begin
  if FSpecimenList = nil then
    FSpecimenList := TFhirReferenceList{TFhirSpecimen}.Create;
  result := FSpecimenList;
end;

Function TFhirDiagnosticOrder.GetHasSpecimenList : boolean;
begin
  result := (FSpecimenList <> nil) and (FSpecimenList.count > 0);
end;

Procedure TFhirDiagnosticOrder.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirDiagnosticOrder.GetStatusST : TFhirDiagnosticOrderStatusEnum;
begin
  if FStatus = nil then
    result := TFhirDiagnosticOrderStatusEnum(0)
  else
    result := TFhirDiagnosticOrderStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirDiagnosticOrderStatusEnum, FStatus.value));
end;

Procedure TFhirDiagnosticOrder.SetStatusST(value : TFhirDiagnosticOrderStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirDiagnosticOrderStatusEnum[value], CODES_TFhirDiagnosticOrderStatusEnum[value]);
end;

Procedure TFhirDiagnosticOrder.SetPriority(value : TFhirEnum);
begin
  FPriority.free;
  FPriority := value;
end;

Function TFhirDiagnosticOrder.GetPriorityST : TFhirDiagnosticOrderPriorityEnum;
begin
  if FPriority = nil then
    result := TFhirDiagnosticOrderPriorityEnum(0)
  else
    result := TFhirDiagnosticOrderPriorityEnum(StringArrayIndexOfSensitive(CODES_TFhirDiagnosticOrderPriorityEnum, FPriority.value));
end;

Procedure TFhirDiagnosticOrder.SetPriorityST(value : TFhirDiagnosticOrderPriorityEnum);
begin
  if ord(value) = 0 then
    PriorityElement := nil
  else
    PriorityElement := TFhirEnum.create(SYSTEMS_TFhirDiagnosticOrderPriorityEnum[value], CODES_TFhirDiagnosticOrderPriorityEnum[value]);
end;

Function TFhirDiagnosticOrder.GetEventList : TFhirDiagnosticOrderEventList;
begin
  if FEventList = nil then
    FEventList := TFhirDiagnosticOrderEventList.Create;
  result := FEventList;
end;

Function TFhirDiagnosticOrder.GetHasEventList : boolean;
begin
  result := (FEventList <> nil) and (FEventList.count > 0);
end;

Function TFhirDiagnosticOrder.GetItemList : TFhirDiagnosticOrderItemList;
begin
  if FItemList = nil then
    FItemList := TFhirDiagnosticOrderItemList.Create;
  result := FItemList;
end;

Function TFhirDiagnosticOrder.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

Function TFhirDiagnosticOrder.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirDiagnosticOrder.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirDiagnosticOrder.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSubject.sizeInBytes);
  inc(result, FOrderer.sizeInBytes);
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FreasonList.sizeInBytes);
  inc(result, FsupportingInformationList.sizeInBytes);
  inc(result, FspecimenList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FPriority.sizeInBytes);
  inc(result, FeventList.sizeInBytes);
  inc(result, FitemList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
end;

{ TFhirDiagnosticOrderListEnumerator }

Constructor TFhirDiagnosticOrderListEnumerator.Create(list : TFhirDiagnosticOrderList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDiagnosticOrderListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDiagnosticOrderListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDiagnosticOrderListEnumerator.GetCurrent : TFhirDiagnosticOrder;
begin
  Result := FList[FIndex];
end;

function TFhirDiagnosticOrderListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDiagnosticOrderList }
procedure TFhirDiagnosticOrderList.AddItem(value: TFhirDiagnosticOrder);
begin
  assert(value.ClassName = 'TFhirDiagnosticOrder', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDiagnosticOrder');
  add(value);
end;

function TFhirDiagnosticOrderList.Append: TFhirDiagnosticOrder;
begin
  result := TFhirDiagnosticOrder.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDiagnosticOrderList.ClearItems;
begin
  Clear;
end;

function TFhirDiagnosticOrderList.GetEnumerator : TFhirDiagnosticOrderListEnumerator;
begin
  result := TFhirDiagnosticOrderListEnumerator.Create(self.link);
end;

function TFhirDiagnosticOrderList.Clone: TFhirDiagnosticOrderList;
begin
  result := TFhirDiagnosticOrderList(inherited Clone);
end;

function TFhirDiagnosticOrderList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDiagnosticOrderList.GetItemN(index: Integer): TFhirDiagnosticOrder;
begin
  result := TFhirDiagnosticOrder(ObjectByIndex[index]);
end;

function TFhirDiagnosticOrderList.ItemClass: TFslObjectClass;
begin
  result := TFhirDiagnosticOrder;
end;
function TFhirDiagnosticOrderList.IndexOf(value: TFhirDiagnosticOrder): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDiagnosticOrderList.Insert(index: Integer): TFhirDiagnosticOrder;
begin
  result := TFhirDiagnosticOrder.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDiagnosticOrderList.InsertItem(index: Integer; value: TFhirDiagnosticOrder);
begin
  assert(value is TFhirDiagnosticOrder);
  Inherited Insert(index, value);
end;

function TFhirDiagnosticOrderList.Item(index: Integer): TFhirDiagnosticOrder;
begin
  result := TFhirDiagnosticOrder(ObjectByIndex[index]);
end;

function TFhirDiagnosticOrderList.Link: TFhirDiagnosticOrderList;
begin
  result := TFhirDiagnosticOrderList(inherited Link);
end;

procedure TFhirDiagnosticOrderList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDiagnosticOrderList.SetItemByIndex(index: Integer; value: TFhirDiagnosticOrder);
begin
  assert(value is TFhirDiagnosticOrder);
  FhirDiagnosticOrders[index] := value;
end;

procedure TFhirDiagnosticOrderList.SetItemN(index: Integer; value: TFhirDiagnosticOrder);
begin
  assert(value is TFhirDiagnosticOrder);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_DIAGNOSTICORDER}

{$IFDEF FHIR_DIAGNOSTICREPORT}

{ TFhirDiagnosticReportImage }

constructor TFhirDiagnosticReportImage.Create;
begin
  inherited;
end;

destructor TFhirDiagnosticReportImage.Destroy;
begin
  FComment.free;
  FLink_.free;
  inherited;
end;

procedure TFhirDiagnosticReportImage.Assign(oSource : TFslObject);
begin
  inherited;
  commentElement := TFhirDiagnosticReportImage(oSource).commentElement.Clone;
  link_ := TFhirDiagnosticReportImage(oSource).link_.Clone;
end;

procedure TFhirDiagnosticReportImage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
  if (child_name = 'link') Then
     list.add(self.link, 'link', FLink_.Link);
end;

procedure TFhirDiagnosticReportImage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'comment', 'string', false, TFhirString, FComment.Link));{2}
  oList.add(TFHIRProperty.create(self, 'link', 'Reference(Media)', false, TFhirReference{TFhirMedia}, FLink_.Link));{2}
end;

function TFhirDiagnosticReportImage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'comment') then
  begin
    CommentElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'link') then
  begin
    Link_ := propValue as TFhirReference{TFhirMedia}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDiagnosticReportImage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDiagnosticReportImage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'comment') then result := TFhirString.create() {5b}
  else if (propName = 'link') then result := TFhirReference{TFhirMedia}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDiagnosticReportImage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'comment') then result := 'string'
  else if (propName = 'link') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDiagnosticReportImage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'comment') then CommentElement := nil
  else if (propName = 'link') then Link_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDiagnosticReportImage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'comment') then CommentElement := asString(new){5b}
  else if (propName = 'link') then Link_Element := new as TFhirReference{TFhirMedia}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDiagnosticReportImage.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDiagnosticReportImage.fhirType : string;
begin
  result := 'image';
end;

function TFhirDiagnosticReportImage.Link : TFhirDiagnosticReportImage;
begin
  result := TFhirDiagnosticReportImage(inherited Link);
end;

function TFhirDiagnosticReportImage.Clone : TFhirDiagnosticReportImage;
begin
  result := TFhirDiagnosticReportImage(inherited Clone);
end;

function TFhirDiagnosticReportImage.equals(other : TObject) : boolean;
var
  o : TFhirDiagnosticReportImage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDiagnosticReportImage)) then
    result := false
  else
  begin
    o := TFhirDiagnosticReportImage(other);
    result := compareDeep(commentElement, o.commentElement, true) and compareDeep(link_Element, o.link_Element, true);
  end;
end;

function TFhirDiagnosticReportImage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FComment) and isEmptyProp(FLink_);
end;

procedure TFhirDiagnosticReportImage.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('comment');
  fields.add('link');
end;

{ TFhirDiagnosticReportImage }

Procedure TFhirDiagnosticReportImage.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value;
end;

Function TFhirDiagnosticReportImage.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

Procedure TFhirDiagnosticReportImage.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

Procedure TFhirDiagnosticReportImage.SetLink_(value : TFhirReference{TFhirMedia});
begin
  FLink_.free;
  FLink_ := value;
end;

function TFhirDiagnosticReportImage.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FComment.sizeInBytes);
  inc(result, FLink_.sizeInBytes);
end;

{ TFhirDiagnosticReportImageListEnumerator }

Constructor TFhirDiagnosticReportImageListEnumerator.Create(list : TFhirDiagnosticReportImageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDiagnosticReportImageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDiagnosticReportImageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDiagnosticReportImageListEnumerator.GetCurrent : TFhirDiagnosticReportImage;
begin
  Result := FList[FIndex];
end;

function TFhirDiagnosticReportImageListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDiagnosticReportImageList }
procedure TFhirDiagnosticReportImageList.AddItem(value: TFhirDiagnosticReportImage);
begin
  assert(value.ClassName = 'TFhirDiagnosticReportImage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDiagnosticReportImage');
  add(value);
end;

function TFhirDiagnosticReportImageList.Append: TFhirDiagnosticReportImage;
begin
  result := TFhirDiagnosticReportImage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDiagnosticReportImageList.ClearItems;
begin
  Clear;
end;

function TFhirDiagnosticReportImageList.GetEnumerator : TFhirDiagnosticReportImageListEnumerator;
begin
  result := TFhirDiagnosticReportImageListEnumerator.Create(self.link);
end;

function TFhirDiagnosticReportImageList.Clone: TFhirDiagnosticReportImageList;
begin
  result := TFhirDiagnosticReportImageList(inherited Clone);
end;

function TFhirDiagnosticReportImageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDiagnosticReportImageList.GetItemN(index: Integer): TFhirDiagnosticReportImage;
begin
  result := TFhirDiagnosticReportImage(ObjectByIndex[index]);
end;

function TFhirDiagnosticReportImageList.ItemClass: TFslObjectClass;
begin
  result := TFhirDiagnosticReportImage;
end;
function TFhirDiagnosticReportImageList.IndexOf(value: TFhirDiagnosticReportImage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDiagnosticReportImageList.Insert(index: Integer): TFhirDiagnosticReportImage;
begin
  result := TFhirDiagnosticReportImage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDiagnosticReportImageList.InsertItem(index: Integer; value: TFhirDiagnosticReportImage);
begin
  assert(value is TFhirDiagnosticReportImage);
  Inherited Insert(index, value);
end;

function TFhirDiagnosticReportImageList.Item(index: Integer): TFhirDiagnosticReportImage;
begin
  result := TFhirDiagnosticReportImage(ObjectByIndex[index]);
end;

function TFhirDiagnosticReportImageList.Link: TFhirDiagnosticReportImageList;
begin
  result := TFhirDiagnosticReportImageList(inherited Link);
end;

procedure TFhirDiagnosticReportImageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDiagnosticReportImageList.SetItemByIndex(index: Integer; value: TFhirDiagnosticReportImage);
begin
  assert(value is TFhirDiagnosticReportImage);
  FhirDiagnosticReportImages[index] := value;
end;

procedure TFhirDiagnosticReportImageList.SetItemN(index: Integer; value: TFhirDiagnosticReportImage);
begin
  assert(value is TFhirDiagnosticReportImage);
  ObjectByIndex[index] := value;
end;

{ TFhirDiagnosticReport }

constructor TFhirDiagnosticReport.Create;
begin
  inherited;
end;

destructor TFhirDiagnosticReport.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FCategory.free;
  FCode.free;
  FSubject.free;
  FEncounter.free;
  FEffective.free;
  FIssued.free;
  FPerformer.free;
  FRequestList.Free;
  FSpecimenList.Free;
  FResultList.Free;
  FImagingStudyList.Free;
  FImageList.Free;
  FConclusion.free;
  FCodedDiagnosisList.Free;
  FPresentedFormList.Free;
  inherited;
end;

function TFhirDiagnosticReport.GetResourceType : TFhirResourceType;
begin
  result := frtDiagnosticReport;
end;

procedure TFhirDiagnosticReport.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirDiagnosticReport(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirDiagnosticReport(oSource).FIdentifierList);
  end;
  FStatus := TFhirDiagnosticReport(oSource).FStatus.Link;
  category := TFhirDiagnosticReport(oSource).category.Clone;
  code := TFhirDiagnosticReport(oSource).code.Clone;
  subject := TFhirDiagnosticReport(oSource).subject.Clone;
  encounter := TFhirDiagnosticReport(oSource).encounter.Clone;
  effective := TFhirDiagnosticReport(oSource).effective.Clone;
  issuedElement := TFhirDiagnosticReport(oSource).issuedElement.Clone;
  performer := TFhirDiagnosticReport(oSource).performer.Clone;
  if (TFhirDiagnosticReport(oSource).FRequestList = nil) then
  begin
    FRequestList.free;
    FRequestList := nil;
  end
  else
  begin
    if FRequestList = nil then
      FRequestList := TFhirReferenceList{Resource}.Create;
    FRequestList.Assign(TFhirDiagnosticReport(oSource).FRequestList);
  end;
  if (TFhirDiagnosticReport(oSource).FSpecimenList = nil) then
  begin
    FSpecimenList.free;
    FSpecimenList := nil;
  end
  else
  begin
    if FSpecimenList = nil then
      FSpecimenList := TFhirReferenceList{TFhirSpecimen}.Create;
    FSpecimenList.Assign(TFhirDiagnosticReport(oSource).FSpecimenList);
  end;
  if (TFhirDiagnosticReport(oSource).FResultList = nil) then
  begin
    FResultList.free;
    FResultList := nil;
  end
  else
  begin
    if FResultList = nil then
      FResultList := TFhirReferenceList{TFhirObservation}.Create;
    FResultList.Assign(TFhirDiagnosticReport(oSource).FResultList);
  end;
  if (TFhirDiagnosticReport(oSource).FImagingStudyList = nil) then
  begin
    FImagingStudyList.free;
    FImagingStudyList := nil;
  end
  else
  begin
    if FImagingStudyList = nil then
      FImagingStudyList := TFhirReferenceList{Resource}.Create;
    FImagingStudyList.Assign(TFhirDiagnosticReport(oSource).FImagingStudyList);
  end;
  if (TFhirDiagnosticReport(oSource).FImageList = nil) then
  begin
    FImageList.free;
    FImageList := nil;
  end
  else
  begin
    if FImageList = nil then
      FImageList := TFhirDiagnosticReportImageList.Create;
    FImageList.Assign(TFhirDiagnosticReport(oSource).FImageList);
  end;
  conclusionElement := TFhirDiagnosticReport(oSource).conclusionElement.Clone;
  if (TFhirDiagnosticReport(oSource).FCodedDiagnosisList = nil) then
  begin
    FCodedDiagnosisList.free;
    FCodedDiagnosisList := nil;
  end
  else
  begin
    if FCodedDiagnosisList = nil then
      FCodedDiagnosisList := TFhirCodeableConceptList.Create;
    FCodedDiagnosisList.Assign(TFhirDiagnosticReport(oSource).FCodedDiagnosisList);
  end;
  if (TFhirDiagnosticReport(oSource).FPresentedFormList = nil) then
  begin
    FPresentedFormList.free;
    FPresentedFormList := nil;
  end
  else
  begin
    if FPresentedFormList = nil then
      FPresentedFormList := TFhirAttachmentList.Create;
    FPresentedFormList.Assign(TFhirDiagnosticReport(oSource).FPresentedFormList);
  end;
end;

procedure TFhirDiagnosticReport.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'effective[x]') or (child_name = 'effective') Then
     list.add(self.link, 'effective[x]', FEffective.Link);
  if (child_name = 'issued') Then
     list.add(self.link, 'issued', FIssued.Link);
  if (child_name = 'performer') Then
     list.add(self.link, 'performer', FPerformer.Link);
  if (child_name = 'request') Then
    list.addAll(self, 'request', FRequestList);
  if (child_name = 'specimen') Then
    list.addAll(self, 'specimen', FSpecimenList);
  if (child_name = 'result') Then
    list.addAll(self, 'result', FResultList);
  if (child_name = 'imagingStudy') Then
    list.addAll(self, 'imagingStudy', FImagingStudyList);
  if (child_name = 'image') Then
    list.addAll(self, 'image', FImageList);
  if (child_name = 'conclusion') Then
     list.add(self.link, 'conclusion', FConclusion.Link);
  if (child_name = 'codedDiagnosis') Then
    list.addAll(self, 'codedDiagnosis', FCodedDiagnosisList);
  if (child_name = 'presentedForm') Then
    list.addAll(self, 'presentedForm', FPresentedFormList);
end;

procedure TFhirDiagnosticReport.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Group|Device|Location)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference(Encounter)', false, TFhirReference{TFhirEncounter}, FEncounter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'effective[x]', 'dateTime|Period', false, TFhirType, FEffective.Link));{2}
  oList.add(TFHIRProperty.create(self, 'issued', 'instant', false, TFhirInstant, FIssued.Link));{2}
  oList.add(TFHIRProperty.create(self, 'performer', 'Reference(Practitioner|Organization)', false, TFhirReference{Resource}, FPerformer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'request', 'Reference(DiagnosticOrder|ProcedureRequest|ReferralRequest)', true, TFhirReference{Resource}, FRequestList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'specimen', 'Reference(Specimen)', true, TFhirReference{TFhirSpecimen}, FSpecimenList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'result', 'Reference(Observation)', true, TFhirReference{TFhirObservation}, FResultList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'imagingStudy', 'Reference(ImagingStudy|ImagingObjectSelection)', true, TFhirReference{Resource}, FImagingStudyList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'image', '', true, TFhirDiagnosticReportImage, FImageList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'conclusion', 'string', false, TFhirString, FConclusion.Link));{2}
  oList.add(TFHIRProperty.create(self, 'codedDiagnosis', 'CodeableConcept', true, TFhirCodeableConcept, FCodedDiagnosisList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'presentedForm', 'Attachment', true, TFhirAttachment, FPresentedFormList.Link)){3};
end;

function TFhirDiagnosticReport.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirDiagnosticReportStatusEnum, CODES_TFhirDiagnosticReportStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference{TFhirEncounter}{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then
  begin
    Effective := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'issued') then
  begin
    IssuedElement := asInstant(propValue){5a};
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    Performer := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    RequestList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'specimen') then
  begin
    SpecimenList.add(propValue as TFhirReference{TFhirSpecimen}){2a};
    result := propValue;
  end
  else if (propName = 'result') then
  begin
    ResultList.add(propValue as TFhirReference{TFhirObservation}){2a};
    result := propValue;
  end
  else if (propName = 'imagingStudy') then
  begin
    ImagingStudyList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'image') then
  begin
    ImageList.add(propValue as TFhirDiagnosticReportImage){2a};
    result := propValue;
  end
  else if (propName = 'conclusion') then
  begin
    ConclusionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'codedDiagnosis') then
  begin
    CodedDiagnosisList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'presentedForm') then
  begin
    PresentedFormList.add(propValue as TFhirAttachment){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirDiagnosticReport.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'request') then RequestList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'specimen') then SpecimenList.insertItem(index, propValue as TFhirReference{TFhirSpecimen}){2a}
  else if (propName = 'result') then ResultList.insertItem(index, propValue as TFhirReference{TFhirObservation}){2a}
  else if (propName = 'imagingStudy') then ImagingStudyList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'image') then ImageList.insertItem(index, propValue as TFhirDiagnosticReportImage){2a}
  else if (propName = 'codedDiagnosis') then CodedDiagnosisList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'presentedForm') then PresentedFormList.insertItem(index, propValue as TFhirAttachment){2a}
  else inherited;
end;

function TFhirDiagnosticReport.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'encounter') then result := TFhirReference{TFhirEncounter}.create(){4b}
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Effective'){4x}
  else if (propName = 'issued') then result := TFhirInstant.create() {5b}
  else if (propName = 'performer') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'request') then result := RequestList.new(){2}
  else if (propName = 'specimen') then result := SpecimenList.new(){2}
  else if (propName = 'result') then result := ResultList.new(){2}
  else if (propName = 'imagingStudy') then result := ImagingStudyList.new(){2}
  else if (propName = 'image') then result := ImageList.new(){2}
  else if (propName = 'conclusion') then result := TFhirString.create() {5b}
  else if (propName = 'codedDiagnosis') then result := CodedDiagnosisList.new(){2}
  else if (propName = 'presentedForm') then result := PresentedFormList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDiagnosticReport.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'effective[x]') then result := 'dateTime|Period'
  else if (propName = 'issued') then result := 'instant'
  else if (propName = 'performer') then result := 'Reference'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'specimen') then result := 'Reference'
  else if (propName = 'result') then result := 'Reference'
  else if (propName = 'imagingStudy') then result := 'Reference'
  else if (propName = 'image') then result := ''
  else if (propName = 'conclusion') then result := 'string'
  else if (propName = 'codedDiagnosis') then result := 'CodeableConcept'
  else if (propName = 'presentedForm') then result := 'Attachment'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDiagnosticReport.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then EffectiveElement := nil{4x}
  else if (propName = 'issued') then IssuedElement := nil
  else if (propName = 'performer') then PerformerElement := nil
  else if (propName = 'request') then deletePropertyValue('request', RequestList, value) {2}
  else if (propName = 'specimen') then deletePropertyValue('specimen', SpecimenList, value) {2}
  else if (propName = 'result') then deletePropertyValue('result', ResultList, value) {2}
  else if (propName = 'imagingStudy') then deletePropertyValue('imagingStudy', ImagingStudyList, value) {2}
  else if (propName = 'image') then deletePropertyValue('image', ImageList, value) {2}
  else if (propName = 'conclusion') then ConclusionElement := nil
  else if (propName = 'codedDiagnosis') then deletePropertyValue('codedDiagnosis', CodedDiagnosisList, value) {2}
  else if (propName = 'presentedForm') then deletePropertyValue('presentedForm', PresentedFormList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDiagnosticReport.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirDiagnosticReportStatusEnum, CODES_TFhirDiagnosticReportStatusEnum, new){4}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference{TFhirEncounter}{4}
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then EffectiveElement := new as TFhirType{4x}
  else if (propName = 'issued') then IssuedElement := asInstant(new){5b}
  else if (propName = 'performer') then PerformerElement := new as TFhirReference{Resource}{4}
  else if (propName = 'request') then replacePropertyValue('request', RequestList, existing, new) {2}
  else if (propName = 'specimen') then replacePropertyValue('specimen', SpecimenList, existing, new) {2}
  else if (propName = 'result') then replacePropertyValue('result', ResultList, existing, new) {2}
  else if (propName = 'imagingStudy') then replacePropertyValue('imagingStudy', ImagingStudyList, existing, new) {2}
  else if (propName = 'image') then replacePropertyValue('image', ImageList, existing, new) {2}
  else if (propName = 'conclusion') then ConclusionElement := asString(new){5b}
  else if (propName = 'codedDiagnosis') then replacePropertyValue('codedDiagnosis', CodedDiagnosisList, existing, new) {2}
  else if (propName = 'presentedForm') then replacePropertyValue('presentedForm', PresentedFormList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDiagnosticReport.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'request') then RequestList.move(source, destination){2a}
  else if (propName = 'specimen') then SpecimenList.move(source, destination){2a}
  else if (propName = 'result') then ResultList.move(source, destination){2a}
  else if (propName = 'imagingStudy') then ImagingStudyList.move(source, destination){2a}
  else if (propName = 'image') then ImageList.move(source, destination){2a}
  else if (propName = 'codedDiagnosis') then CodedDiagnosisList.move(source, destination){2a}
  else if (propName = 'presentedForm') then PresentedFormList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDiagnosticReport.fhirType : string;
begin
  result := 'DiagnosticReport';
end;

function TFhirDiagnosticReport.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FCategory) and isEmptyProp(FCode) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FEffective) and isEmptyProp(FIssued) and isEmptyProp(FPerformer) and isEmptyProp(FrequestList) and isEmptyProp(FspecimenList) and isEmptyProp(FresultList) and isEmptyProp(FimagingStudyList) and isEmptyProp(FimageList) and isEmptyProp(FConclusion) and isEmptyProp(FcodedDiagnosisList) and isEmptyProp(FpresentedFormList);
end;

function TFhirDiagnosticReport.equals(other : TObject) : boolean;
var
  o : TFhirDiagnosticReport;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDiagnosticReport)) then
    result := false
  else
  begin
    o := TFhirDiagnosticReport(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(categoryElement, o.categoryElement, true) and compareDeep(codeElement, o.codeElement, true) and
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(encounterElement, o.encounterElement, true) and
      compareDeep(effectiveElement, o.effectiveElement, true) and compareDeep(issuedElement, o.issuedElement, true) and
      compareDeep(performerElement, o.performerElement, true) and compareDeep(requestList, o.requestList, true) and
      compareDeep(specimenList, o.specimenList, true) and compareDeep(resultList, o.resultList, true) and
      compareDeep(imagingStudyList, o.imagingStudyList, true) and compareDeep(imageList, o.imageList, true) and
      compareDeep(conclusionElement, o.conclusionElement, true) and compareDeep(codedDiagnosisList, o.codedDiagnosisList, true) and
      compareDeep(presentedFormList, o.presentedFormList, true);
  end;
end;

function TFhirDiagnosticReport.Link : TFhirDiagnosticReport;
begin
  result := TFhirDiagnosticReport(inherited Link);
end;

function TFhirDiagnosticReport.Clone : TFhirDiagnosticReport;
begin
  result := TFhirDiagnosticReport(inherited Clone);
end;

procedure TFhirDiagnosticReport.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('category');
  fields.add('code');
  fields.add('subject');
  fields.add('encounter');
  fields.add('effective[x]');
  fields.add('issued');
  fields.add('performer');
  fields.add('request');
  fields.add('specimen');
  fields.add('result');
  fields.add('imagingStudy');
  fields.add('image');
  fields.add('conclusion');
  fields.add('codedDiagnosis');
  fields.add('presentedForm');
end;

{ TFhirDiagnosticReport }

Function TFhirDiagnosticReport.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirDiagnosticReport.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirDiagnosticReport.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirDiagnosticReport.GetStatusST : TFhirDiagnosticReportStatusEnum;
begin
  if FStatus = nil then
    result := TFhirDiagnosticReportStatusEnum(0)
  else
    result := TFhirDiagnosticReportStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirDiagnosticReportStatusEnum, FStatus.value));
end;

Procedure TFhirDiagnosticReport.SetStatusST(value : TFhirDiagnosticReportStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirDiagnosticReportStatusEnum[value], CODES_TFhirDiagnosticReportStatusEnum[value]);
end;

Procedure TFhirDiagnosticReport.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirDiagnosticReport.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirDiagnosticReport.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirDiagnosticReport.SetEncounter(value : TFhirReference{TFhirEncounter});
begin
  FEncounter.free;
  FEncounter := value;
end;

Procedure TFhirDiagnosticReport.SetEffective(value : TFhirType);
begin
  FEffective.free;
  FEffective := value;
end;

Procedure TFhirDiagnosticReport.SetIssued(value : TFhirInstant);
begin
  FIssued.free;
  FIssued := value;
end;

Function TFhirDiagnosticReport.GetIssuedST : TFslDateTime;
begin
  if FIssued = nil then
    result := TFslDateTime.makeNull
  else
    result := FIssued.value;
end;

Procedure TFhirDiagnosticReport.SetIssuedST(value : TFslDateTime);
begin
  if FIssued = nil then
    FIssued := TFhirInstant.create;
  FIssued.value := value
end;

Procedure TFhirDiagnosticReport.SetPerformer(value : TFhirReference{Resource});
begin
  FPerformer.free;
  FPerformer := value;
end;

Function TFhirDiagnosticReport.GetRequestList : TFhirReferenceList{Resource};
begin
  if FRequestList = nil then
    FRequestList := TFhirReferenceList{Resource}.Create;
  result := FRequestList;
end;

Function TFhirDiagnosticReport.GetHasRequestList : boolean;
begin
  result := (FRequestList <> nil) and (FRequestList.count > 0);
end;

Function TFhirDiagnosticReport.GetSpecimenList : TFhirReferenceList{TFhirSpecimen};
begin
  if FSpecimenList = nil then
    FSpecimenList := TFhirReferenceList{TFhirSpecimen}.Create;
  result := FSpecimenList;
end;

Function TFhirDiagnosticReport.GetHasSpecimenList : boolean;
begin
  result := (FSpecimenList <> nil) and (FSpecimenList.count > 0);
end;

Function TFhirDiagnosticReport.GetResultList : TFhirReferenceList{TFhirObservation};
begin
  if FResultList = nil then
    FResultList := TFhirReferenceList{TFhirObservation}.Create;
  result := FResultList;
end;

Function TFhirDiagnosticReport.GetHasResultList : boolean;
begin
  result := (FResultList <> nil) and (FResultList.count > 0);
end;

Function TFhirDiagnosticReport.GetImagingStudyList : TFhirReferenceList{Resource};
begin
  if FImagingStudyList = nil then
    FImagingStudyList := TFhirReferenceList{Resource}.Create;
  result := FImagingStudyList;
end;

Function TFhirDiagnosticReport.GetHasImagingStudyList : boolean;
begin
  result := (FImagingStudyList <> nil) and (FImagingStudyList.count > 0);
end;

Function TFhirDiagnosticReport.GetImageList : TFhirDiagnosticReportImageList;
begin
  if FImageList = nil then
    FImageList := TFhirDiagnosticReportImageList.Create;
  result := FImageList;
end;

Function TFhirDiagnosticReport.GetHasImageList : boolean;
begin
  result := (FImageList <> nil) and (FImageList.count > 0);
end;

Procedure TFhirDiagnosticReport.SetConclusion(value : TFhirString);
begin
  FConclusion.free;
  FConclusion := value;
end;

Function TFhirDiagnosticReport.GetConclusionST : String;
begin
  if FConclusion = nil then
    result := ''
  else
    result := FConclusion.value;
end;

Procedure TFhirDiagnosticReport.SetConclusionST(value : String);
begin
  if value <> '' then
  begin
    if FConclusion = nil then
      FConclusion := TFhirString.create;
    FConclusion.value := value
  end
  else if FConclusion <> nil then
    FConclusion.value := '';
end;

Function TFhirDiagnosticReport.GetCodedDiagnosisList : TFhirCodeableConceptList;
begin
  if FCodedDiagnosisList = nil then
    FCodedDiagnosisList := TFhirCodeableConceptList.Create;
  result := FCodedDiagnosisList;
end;

Function TFhirDiagnosticReport.GetHasCodedDiagnosisList : boolean;
begin
  result := (FCodedDiagnosisList <> nil) and (FCodedDiagnosisList.count > 0);
end;

Function TFhirDiagnosticReport.GetPresentedFormList : TFhirAttachmentList;
begin
  if FPresentedFormList = nil then
    FPresentedFormList := TFhirAttachmentList.Create;
  result := FPresentedFormList;
end;

Function TFhirDiagnosticReport.GetHasPresentedFormList : boolean;
begin
  result := (FPresentedFormList <> nil) and (FPresentedFormList.count > 0);
end;

function TFhirDiagnosticReport.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FEffective.sizeInBytes);
  inc(result, FIssued.sizeInBytes);
  inc(result, FPerformer.sizeInBytes);
  inc(result, FrequestList.sizeInBytes);
  inc(result, FspecimenList.sizeInBytes);
  inc(result, FresultList.sizeInBytes);
  inc(result, FimagingStudyList.sizeInBytes);
  inc(result, FimageList.sizeInBytes);
  inc(result, FConclusion.sizeInBytes);
  inc(result, FcodedDiagnosisList.sizeInBytes);
  inc(result, FpresentedFormList.sizeInBytes);
end;

{ TFhirDiagnosticReportListEnumerator }

Constructor TFhirDiagnosticReportListEnumerator.Create(list : TFhirDiagnosticReportList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDiagnosticReportListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDiagnosticReportListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDiagnosticReportListEnumerator.GetCurrent : TFhirDiagnosticReport;
begin
  Result := FList[FIndex];
end;

function TFhirDiagnosticReportListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDiagnosticReportList }
procedure TFhirDiagnosticReportList.AddItem(value: TFhirDiagnosticReport);
begin
  assert(value.ClassName = 'TFhirDiagnosticReport', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDiagnosticReport');
  add(value);
end;

function TFhirDiagnosticReportList.Append: TFhirDiagnosticReport;
begin
  result := TFhirDiagnosticReport.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDiagnosticReportList.ClearItems;
begin
  Clear;
end;

function TFhirDiagnosticReportList.GetEnumerator : TFhirDiagnosticReportListEnumerator;
begin
  result := TFhirDiagnosticReportListEnumerator.Create(self.link);
end;

function TFhirDiagnosticReportList.Clone: TFhirDiagnosticReportList;
begin
  result := TFhirDiagnosticReportList(inherited Clone);
end;

function TFhirDiagnosticReportList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDiagnosticReportList.GetItemN(index: Integer): TFhirDiagnosticReport;
begin
  result := TFhirDiagnosticReport(ObjectByIndex[index]);
end;

function TFhirDiagnosticReportList.ItemClass: TFslObjectClass;
begin
  result := TFhirDiagnosticReport;
end;
function TFhirDiagnosticReportList.IndexOf(value: TFhirDiagnosticReport): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDiagnosticReportList.Insert(index: Integer): TFhirDiagnosticReport;
begin
  result := TFhirDiagnosticReport.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDiagnosticReportList.InsertItem(index: Integer; value: TFhirDiagnosticReport);
begin
  assert(value is TFhirDiagnosticReport);
  Inherited Insert(index, value);
end;

function TFhirDiagnosticReportList.Item(index: Integer): TFhirDiagnosticReport;
begin
  result := TFhirDiagnosticReport(ObjectByIndex[index]);
end;

function TFhirDiagnosticReportList.Link: TFhirDiagnosticReportList;
begin
  result := TFhirDiagnosticReportList(inherited Link);
end;

procedure TFhirDiagnosticReportList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDiagnosticReportList.SetItemByIndex(index: Integer; value: TFhirDiagnosticReport);
begin
  assert(value is TFhirDiagnosticReport);
  FhirDiagnosticReports[index] := value;
end;

procedure TFhirDiagnosticReportList.SetItemN(index: Integer; value: TFhirDiagnosticReport);
begin
  assert(value is TFhirDiagnosticReport);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_DIAGNOSTICREPORT}

{$IFDEF FHIR_DOCUMENTMANIFEST}

{ TFhirDocumentManifestContent }

constructor TFhirDocumentManifestContent.Create;
begin
  inherited;
end;

destructor TFhirDocumentManifestContent.Destroy;
begin
  FP.free;
  inherited;
end;

procedure TFhirDocumentManifestContent.Assign(oSource : TFslObject);
begin
  inherited;
  p := TFhirDocumentManifestContent(oSource).p.Clone;
end;

procedure TFhirDocumentManifestContent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'p[x]') or (child_name = 'p') Then
     list.add(self.link, 'p[x]', FP.Link);
end;

procedure TFhirDocumentManifestContent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'p[x]', 'Attachment|Reference(Any)', false, TFhirType, FP.Link));{2}
end;

function TFhirDocumentManifestContent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'p', ['Attachment', 'Reference'])) then
  begin
    P := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDocumentManifestContent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDocumentManifestContent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'p', ['Attachment', 'Reference'])) then raise EFHIRException.create('Cannot make property P'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDocumentManifestContent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'p[x]') then result := 'Attachment|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDocumentManifestContent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'p', ['Attachment', 'Reference'])) then PElement := nil{4x}
  else
  inherited deleteProperty(propName, value);
end;

procedure TFhirDocumentManifestContent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'p', ['Attachment', 'Reference'])) then PElement := new as TFhirType{4x}
  else
  inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDocumentManifestContent.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDocumentManifestContent.fhirType : string;
begin
  result := 'content';
end;

function TFhirDocumentManifestContent.Link : TFhirDocumentManifestContent;
begin
  result := TFhirDocumentManifestContent(inherited Link);
end;

function TFhirDocumentManifestContent.Clone : TFhirDocumentManifestContent;
begin
  result := TFhirDocumentManifestContent(inherited Clone);
end;

function TFhirDocumentManifestContent.equals(other : TObject) : boolean;
var
  o : TFhirDocumentManifestContent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDocumentManifestContent)) then
    result := false
  else
  begin
    o := TFhirDocumentManifestContent(other);
    result := compareDeep(pElement, o.pElement, true);
  end;
end;

function TFhirDocumentManifestContent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FP);
end;

procedure TFhirDocumentManifestContent.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('p[x]');
end;

{ TFhirDocumentManifestContent }

Procedure TFhirDocumentManifestContent.SetP(value : TFhirType);
begin
  FP.free;
  FP := value;
end;

function TFhirDocumentManifestContent.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FP.sizeInBytes);
end;

{ TFhirDocumentManifestContentListEnumerator }

Constructor TFhirDocumentManifestContentListEnumerator.Create(list : TFhirDocumentManifestContentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDocumentManifestContentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDocumentManifestContentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDocumentManifestContentListEnumerator.GetCurrent : TFhirDocumentManifestContent;
begin
  Result := FList[FIndex];
end;

function TFhirDocumentManifestContentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDocumentManifestContentList }
procedure TFhirDocumentManifestContentList.AddItem(value: TFhirDocumentManifestContent);
begin
  assert(value.ClassName = 'TFhirDocumentManifestContent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDocumentManifestContent');
  add(value);
end;

function TFhirDocumentManifestContentList.Append: TFhirDocumentManifestContent;
begin
  result := TFhirDocumentManifestContent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentManifestContentList.ClearItems;
begin
  Clear;
end;

function TFhirDocumentManifestContentList.GetEnumerator : TFhirDocumentManifestContentListEnumerator;
begin
  result := TFhirDocumentManifestContentListEnumerator.Create(self.link);
end;

function TFhirDocumentManifestContentList.Clone: TFhirDocumentManifestContentList;
begin
  result := TFhirDocumentManifestContentList(inherited Clone);
end;

function TFhirDocumentManifestContentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDocumentManifestContentList.GetItemN(index: Integer): TFhirDocumentManifestContent;
begin
  result := TFhirDocumentManifestContent(ObjectByIndex[index]);
end;

function TFhirDocumentManifestContentList.ItemClass: TFslObjectClass;
begin
  result := TFhirDocumentManifestContent;
end;
function TFhirDocumentManifestContentList.IndexOf(value: TFhirDocumentManifestContent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDocumentManifestContentList.Insert(index: Integer): TFhirDocumentManifestContent;
begin
  result := TFhirDocumentManifestContent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentManifestContentList.InsertItem(index: Integer; value: TFhirDocumentManifestContent);
begin
  assert(value is TFhirDocumentManifestContent);
  Inherited Insert(index, value);
end;

function TFhirDocumentManifestContentList.Item(index: Integer): TFhirDocumentManifestContent;
begin
  result := TFhirDocumentManifestContent(ObjectByIndex[index]);
end;

function TFhirDocumentManifestContentList.Link: TFhirDocumentManifestContentList;
begin
  result := TFhirDocumentManifestContentList(inherited Link);
end;

procedure TFhirDocumentManifestContentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDocumentManifestContentList.SetItemByIndex(index: Integer; value: TFhirDocumentManifestContent);
begin
  assert(value is TFhirDocumentManifestContent);
  FhirDocumentManifestContents[index] := value;
end;

procedure TFhirDocumentManifestContentList.SetItemN(index: Integer; value: TFhirDocumentManifestContent);
begin
  assert(value is TFhirDocumentManifestContent);
  ObjectByIndex[index] := value;
end;

{ TFhirDocumentManifestRelated }

constructor TFhirDocumentManifestRelated.Create;
begin
  inherited;
end;

destructor TFhirDocumentManifestRelated.Destroy;
begin
  FIdentifier.free;
  FRef.free;
  inherited;
end;

procedure TFhirDocumentManifestRelated.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirDocumentManifestRelated(oSource).identifier.Clone;
  ref := TFhirDocumentManifestRelated(oSource).ref.Clone;
end;

procedure TFhirDocumentManifestRelated.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'ref') Then
     list.add(self.link, 'ref', FRef.Link);
end;

procedure TFhirDocumentManifestRelated.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'ref', 'Reference(Any)', false, TFhirReference{TFhirReference}, FRef.Link));{2}
end;

function TFhirDocumentManifestRelated.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'ref') then
  begin
    Ref := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDocumentManifestRelated.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDocumentManifestRelated.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'ref') then result := TFhirReference{TFhirReference}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDocumentManifestRelated.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'ref') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDocumentManifestRelated.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'ref') then RefElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDocumentManifestRelated.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'ref') then RefElement := new as TFhirReference{TFhirReference}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDocumentManifestRelated.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDocumentManifestRelated.fhirType : string;
begin
  result := 'related';
end;

function TFhirDocumentManifestRelated.Link : TFhirDocumentManifestRelated;
begin
  result := TFhirDocumentManifestRelated(inherited Link);
end;

function TFhirDocumentManifestRelated.Clone : TFhirDocumentManifestRelated;
begin
  result := TFhirDocumentManifestRelated(inherited Clone);
end;

function TFhirDocumentManifestRelated.equals(other : TObject) : boolean;
var
  o : TFhirDocumentManifestRelated;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDocumentManifestRelated)) then
    result := false
  else
  begin
    o := TFhirDocumentManifestRelated(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(refElement, o.refElement, true);
  end;
end;

function TFhirDocumentManifestRelated.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FRef);
end;

procedure TFhirDocumentManifestRelated.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('ref');
end;

{ TFhirDocumentManifestRelated }

Procedure TFhirDocumentManifestRelated.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirDocumentManifestRelated.SetRef(value : TFhirReference{TFhirReference});
begin
  FRef.free;
  FRef := value;
end;

function TFhirDocumentManifestRelated.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FRef.sizeInBytes);
end;

{ TFhirDocumentManifestRelatedListEnumerator }

Constructor TFhirDocumentManifestRelatedListEnumerator.Create(list : TFhirDocumentManifestRelatedList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDocumentManifestRelatedListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDocumentManifestRelatedListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDocumentManifestRelatedListEnumerator.GetCurrent : TFhirDocumentManifestRelated;
begin
  Result := FList[FIndex];
end;

function TFhirDocumentManifestRelatedListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDocumentManifestRelatedList }
procedure TFhirDocumentManifestRelatedList.AddItem(value: TFhirDocumentManifestRelated);
begin
  assert(value.ClassName = 'TFhirDocumentManifestRelated', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDocumentManifestRelated');
  add(value);
end;

function TFhirDocumentManifestRelatedList.Append: TFhirDocumentManifestRelated;
begin
  result := TFhirDocumentManifestRelated.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentManifestRelatedList.ClearItems;
begin
  Clear;
end;

function TFhirDocumentManifestRelatedList.GetEnumerator : TFhirDocumentManifestRelatedListEnumerator;
begin
  result := TFhirDocumentManifestRelatedListEnumerator.Create(self.link);
end;

function TFhirDocumentManifestRelatedList.Clone: TFhirDocumentManifestRelatedList;
begin
  result := TFhirDocumentManifestRelatedList(inherited Clone);
end;

function TFhirDocumentManifestRelatedList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDocumentManifestRelatedList.GetItemN(index: Integer): TFhirDocumentManifestRelated;
begin
  result := TFhirDocumentManifestRelated(ObjectByIndex[index]);
end;

function TFhirDocumentManifestRelatedList.ItemClass: TFslObjectClass;
begin
  result := TFhirDocumentManifestRelated;
end;
function TFhirDocumentManifestRelatedList.IndexOf(value: TFhirDocumentManifestRelated): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDocumentManifestRelatedList.Insert(index: Integer): TFhirDocumentManifestRelated;
begin
  result := TFhirDocumentManifestRelated.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentManifestRelatedList.InsertItem(index: Integer; value: TFhirDocumentManifestRelated);
begin
  assert(value is TFhirDocumentManifestRelated);
  Inherited Insert(index, value);
end;

function TFhirDocumentManifestRelatedList.Item(index: Integer): TFhirDocumentManifestRelated;
begin
  result := TFhirDocumentManifestRelated(ObjectByIndex[index]);
end;

function TFhirDocumentManifestRelatedList.Link: TFhirDocumentManifestRelatedList;
begin
  result := TFhirDocumentManifestRelatedList(inherited Link);
end;

procedure TFhirDocumentManifestRelatedList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDocumentManifestRelatedList.SetItemByIndex(index: Integer; value: TFhirDocumentManifestRelated);
begin
  assert(value is TFhirDocumentManifestRelated);
  FhirDocumentManifestRelateds[index] := value;
end;

procedure TFhirDocumentManifestRelatedList.SetItemN(index: Integer; value: TFhirDocumentManifestRelated);
begin
  assert(value is TFhirDocumentManifestRelated);
  ObjectByIndex[index] := value;
end;

{ TFhirDocumentManifest }

constructor TFhirDocumentManifest.Create;
begin
  inherited;
end;

destructor TFhirDocumentManifest.Destroy;
begin
  FMasterIdentifier.free;
  FIdentifierList.Free;
  FSubject.free;
  FRecipientList.Free;
  FType_.free;
  FAuthorList.Free;
  FCreated.free;
  FSource.free;
  FStatus.free;
  FDescription.free;
  FContentList.Free;
  FRelatedList.Free;
  inherited;
end;

function TFhirDocumentManifest.GetResourceType : TFhirResourceType;
begin
  result := frtDocumentManifest;
end;

procedure TFhirDocumentManifest.Assign(oSource : TFslObject);
begin
  inherited;
  masterIdentifier := TFhirDocumentManifest(oSource).masterIdentifier.Clone;
  if (TFhirDocumentManifest(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirDocumentManifest(oSource).FIdentifierList);
  end;
  subject := TFhirDocumentManifest(oSource).subject.Clone;
  if (TFhirDocumentManifest(oSource).FRecipientList = nil) then
  begin
    FRecipientList.free;
    FRecipientList := nil;
  end
  else
  begin
    if FRecipientList = nil then
      FRecipientList := TFhirReferenceList{Resource}.Create;
    FRecipientList.Assign(TFhirDocumentManifest(oSource).FRecipientList);
  end;
  type_ := TFhirDocumentManifest(oSource).type_.Clone;
  if (TFhirDocumentManifest(oSource).FAuthorList = nil) then
  begin
    FAuthorList.free;
    FAuthorList := nil;
  end
  else
  begin
    if FAuthorList = nil then
      FAuthorList := TFhirReferenceList{Resource}.Create;
    FAuthorList.Assign(TFhirDocumentManifest(oSource).FAuthorList);
  end;
  createdElement := TFhirDocumentManifest(oSource).createdElement.Clone;
  sourceElement := TFhirDocumentManifest(oSource).sourceElement.Clone;
  FStatus := TFhirDocumentManifest(oSource).FStatus.Link;
  descriptionElement := TFhirDocumentManifest(oSource).descriptionElement.Clone;
  if (TFhirDocumentManifest(oSource).FContentList = nil) then
  begin
    FContentList.free;
    FContentList := nil;
  end
  else
  begin
    if FContentList = nil then
      FContentList := TFhirDocumentManifestContentList.Create;
    FContentList.Assign(TFhirDocumentManifest(oSource).FContentList);
  end;
  if (TFhirDocumentManifest(oSource).FRelatedList = nil) then
  begin
    FRelatedList.free;
    FRelatedList := nil;
  end
  else
  begin
    if FRelatedList = nil then
      FRelatedList := TFhirDocumentManifestRelatedList.Create;
    FRelatedList.Assign(TFhirDocumentManifest(oSource).FRelatedList);
  end;
end;

procedure TFhirDocumentManifest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'masterIdentifier') Then
     list.add(self.link, 'masterIdentifier', FMasterIdentifier.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'recipient') Then
    list.addAll(self, 'recipient', FRecipientList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'author') Then
    list.addAll(self, 'author', FAuthorList);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'content') Then
    list.addAll(self, 'content', FContentList);
  if (child_name = 'related') Then
    list.addAll(self, 'related', FRelatedList);
end;

procedure TFhirDocumentManifest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'masterIdentifier', 'Identifier', false, TFhirIdentifier, FMasterIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Practitioner|Group|Device)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'recipient', 'Reference(Patient|Practitioner|RelatedPerson|Organization)', true, TFhirReference{Resource}, FRecipientList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'author', 'Reference(Practitioner|Organization|Device|Patient|RelatedPerson)', true, TFhirReference{Resource}, FAuthorList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));{2}
  oList.add(TFHIRProperty.create(self, 'source', 'uri', false, TFhirUri, FSource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'content', '', true, TFhirDocumentManifestContent, FContentList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'related', '', true, TFhirDocumentManifestRelated, FRelatedList.Link)){3};
end;

function TFhirDocumentManifest.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'masterIdentifier') then
  begin
    MasterIdentifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'recipient') then
  begin
    RecipientList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    AuthorList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    SourceElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirDocumentReferenceStatusEnum, CODES_TFhirDocumentReferenceStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'content') then
  begin
    ContentList.add(propValue as TFhirDocumentManifestContent){2a};
    result := propValue;
  end
  else if (propName = 'related') then
  begin
    RelatedList.add(propValue as TFhirDocumentManifestRelated){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirDocumentManifest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'recipient') then RecipientList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'author') then AuthorList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'content') then ContentList.insertItem(index, propValue as TFhirDocumentManifestContent){2a}
  else if (propName = 'related') then RelatedList.insertItem(index, propValue as TFhirDocumentManifestRelated){2a}
  else inherited;
end;

function TFhirDocumentManifest.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'masterIdentifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'recipient') then result := RecipientList.new(){2}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'author') then result := AuthorList.new(){2}
  else if (propName = 'created') then result := TFhirDateTime.create() {5b}
  else if (propName = 'source') then result := TFhirUri.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'content') then result := ContentList.new(){2}
  else if (propName = 'related') then result := RelatedList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDocumentManifest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'masterIdentifier') then result := 'Identifier'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'recipient') then result := 'Reference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'source') then result := 'uri'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'content') then result := ''
  else if (propName = 'related') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDocumentManifest.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'masterIdentifier') then MasterIdentifierElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'recipient') then deletePropertyValue('recipient', RecipientList, value) {2}
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'author') then deletePropertyValue('author', AuthorList, value) {2}
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'source') then SourceElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'content') then deletePropertyValue('content', ContentList, value) {2}
  else if (propName = 'related') then deletePropertyValue('related', RelatedList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDocumentManifest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'masterIdentifier') then MasterIdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'recipient') then replacePropertyValue('recipient', RecipientList, existing, new) {2}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'author') then replacePropertyValue('author', AuthorList, existing, new) {2}
  else if (propName = 'created') then CreatedElement := asDateTime(new){5b}
  else if (propName = 'source') then SourceElement := asUri(new){5b}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirDocumentReferenceStatusEnum, CODES_TFhirDocumentReferenceStatusEnum, new){4}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'content') then replacePropertyValue('content', ContentList, existing, new) {2}
  else if (propName = 'related') then replacePropertyValue('related', RelatedList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDocumentManifest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'recipient') then RecipientList.move(source, destination){2a}
  else if (propName = 'author') then AuthorList.move(source, destination){2a}
  else if (propName = 'content') then ContentList.move(source, destination){2a}
  else if (propName = 'related') then RelatedList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDocumentManifest.fhirType : string;
begin
  result := 'DocumentManifest';
end;

function TFhirDocumentManifest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMasterIdentifier) and isEmptyProp(FidentifierList) and isEmptyProp(FSubject) and isEmptyProp(FrecipientList) and isEmptyProp(FType_) and isEmptyProp(FauthorList) and isEmptyProp(FCreated) and isEmptyProp(FSource) and isEmptyProp(FStatus) and isEmptyProp(FDescription) and isEmptyProp(FcontentList) and isEmptyProp(FrelatedList);
end;

function TFhirDocumentManifest.equals(other : TObject) : boolean;
var
  o : TFhirDocumentManifest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDocumentManifest)) then
    result := false
  else
  begin
    o := TFhirDocumentManifest(other);
    result := compareDeep(masterIdentifierElement, o.masterIdentifierElement, true) and
      compareDeep(identifierList, o.identifierList, true) and compareDeep(subjectElement, o.subjectElement, true) and
      compareDeep(recipientList, o.recipientList, true) and compareDeep(type_Element, o.type_Element, true) and
      compareDeep(authorList, o.authorList, true) and compareDeep(createdElement, o.createdElement, true) and
      compareDeep(sourceElement, o.sourceElement, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(contentList, o.contentList, true) and
      compareDeep(relatedList, o.relatedList, true);
  end;
end;

function TFhirDocumentManifest.Link : TFhirDocumentManifest;
begin
  result := TFhirDocumentManifest(inherited Link);
end;

function TFhirDocumentManifest.Clone : TFhirDocumentManifest;
begin
  result := TFhirDocumentManifest(inherited Clone);
end;

procedure TFhirDocumentManifest.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('masterIdentifier');
  fields.add('identifier');
  fields.add('subject');
  fields.add('recipient');
  fields.add('type');
  fields.add('author');
  fields.add('created');
  fields.add('source');
  fields.add('status');
  fields.add('description');
  fields.add('content');
  fields.add('related');
end;

{ TFhirDocumentManifest }

Procedure TFhirDocumentManifest.SetMasterIdentifier(value : TFhirIdentifier);
begin
  FMasterIdentifier.free;
  FMasterIdentifier := value;
end;

Function TFhirDocumentManifest.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirDocumentManifest.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirDocumentManifest.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Function TFhirDocumentManifest.GetRecipientList : TFhirReferenceList{Resource};
begin
  if FRecipientList = nil then
    FRecipientList := TFhirReferenceList{Resource}.Create;
  result := FRecipientList;
end;

Function TFhirDocumentManifest.GetHasRecipientList : boolean;
begin
  result := (FRecipientList <> nil) and (FRecipientList.count > 0);
end;

Procedure TFhirDocumentManifest.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirDocumentManifest.GetAuthorList : TFhirReferenceList{Resource};
begin
  if FAuthorList = nil then
    FAuthorList := TFhirReferenceList{Resource}.Create;
  result := FAuthorList;
end;

Function TFhirDocumentManifest.GetHasAuthorList : boolean;
begin
  result := (FAuthorList <> nil) and (FAuthorList.count > 0);
end;

Procedure TFhirDocumentManifest.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

Function TFhirDocumentManifest.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

Procedure TFhirDocumentManifest.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

Procedure TFhirDocumentManifest.SetSource(value : TFhirUri);
begin
  FSource.free;
  FSource := value;
end;

Function TFhirDocumentManifest.GetSourceST : String;
begin
  if FSource = nil then
    result := ''
  else
    result := FSource.value;
end;

Procedure TFhirDocumentManifest.SetSourceST(value : String);
begin
  if value <> '' then
  begin
    if FSource = nil then
      FSource := TFhirUri.create;
    FSource.value := value
  end
  else if FSource <> nil then
    FSource.value := '';
end;

Procedure TFhirDocumentManifest.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirDocumentManifest.GetStatusST : TFhirDocumentReferenceStatusEnum;
begin
  if FStatus = nil then
    result := TFhirDocumentReferenceStatusEnum(0)
  else
    result := TFhirDocumentReferenceStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirDocumentReferenceStatusEnum, FStatus.value));
end;

Procedure TFhirDocumentManifest.SetStatusST(value : TFhirDocumentReferenceStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirDocumentReferenceStatusEnum[value], CODES_TFhirDocumentReferenceStatusEnum[value]);
end;

Procedure TFhirDocumentManifest.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirDocumentManifest.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirDocumentManifest.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Function TFhirDocumentManifest.GetContentList : TFhirDocumentManifestContentList;
begin
  if FContentList = nil then
    FContentList := TFhirDocumentManifestContentList.Create;
  result := FContentList;
end;

Function TFhirDocumentManifest.GetHasContentList : boolean;
begin
  result := (FContentList <> nil) and (FContentList.count > 0);
end;

Function TFhirDocumentManifest.GetRelatedList : TFhirDocumentManifestRelatedList;
begin
  if FRelatedList = nil then
    FRelatedList := TFhirDocumentManifestRelatedList.Create;
  result := FRelatedList;
end;

Function TFhirDocumentManifest.GetHasRelatedList : boolean;
begin
  result := (FRelatedList <> nil) and (FRelatedList.count > 0);
end;

function TFhirDocumentManifest.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FMasterIdentifier.sizeInBytes);
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FrecipientList.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FauthorList.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FSource.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FcontentList.sizeInBytes);
  inc(result, FrelatedList.sizeInBytes);
end;

{ TFhirDocumentManifestListEnumerator }

Constructor TFhirDocumentManifestListEnumerator.Create(list : TFhirDocumentManifestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDocumentManifestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDocumentManifestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDocumentManifestListEnumerator.GetCurrent : TFhirDocumentManifest;
begin
  Result := FList[FIndex];
end;

function TFhirDocumentManifestListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDocumentManifestList }
procedure TFhirDocumentManifestList.AddItem(value: TFhirDocumentManifest);
begin
  assert(value.ClassName = 'TFhirDocumentManifest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDocumentManifest');
  add(value);
end;

function TFhirDocumentManifestList.Append: TFhirDocumentManifest;
begin
  result := TFhirDocumentManifest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentManifestList.ClearItems;
begin
  Clear;
end;

function TFhirDocumentManifestList.GetEnumerator : TFhirDocumentManifestListEnumerator;
begin
  result := TFhirDocumentManifestListEnumerator.Create(self.link);
end;

function TFhirDocumentManifestList.Clone: TFhirDocumentManifestList;
begin
  result := TFhirDocumentManifestList(inherited Clone);
end;

function TFhirDocumentManifestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDocumentManifestList.GetItemN(index: Integer): TFhirDocumentManifest;
begin
  result := TFhirDocumentManifest(ObjectByIndex[index]);
end;

function TFhirDocumentManifestList.ItemClass: TFslObjectClass;
begin
  result := TFhirDocumentManifest;
end;
function TFhirDocumentManifestList.IndexOf(value: TFhirDocumentManifest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDocumentManifestList.Insert(index: Integer): TFhirDocumentManifest;
begin
  result := TFhirDocumentManifest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentManifestList.InsertItem(index: Integer; value: TFhirDocumentManifest);
begin
  assert(value is TFhirDocumentManifest);
  Inherited Insert(index, value);
end;

function TFhirDocumentManifestList.Item(index: Integer): TFhirDocumentManifest;
begin
  result := TFhirDocumentManifest(ObjectByIndex[index]);
end;

function TFhirDocumentManifestList.Link: TFhirDocumentManifestList;
begin
  result := TFhirDocumentManifestList(inherited Link);
end;

procedure TFhirDocumentManifestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDocumentManifestList.SetItemByIndex(index: Integer; value: TFhirDocumentManifest);
begin
  assert(value is TFhirDocumentManifest);
  FhirDocumentManifests[index] := value;
end;

procedure TFhirDocumentManifestList.SetItemN(index: Integer; value: TFhirDocumentManifest);
begin
  assert(value is TFhirDocumentManifest);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_DOCUMENTMANIFEST}

{$IFDEF FHIR_DOCUMENTREFERENCE}

{ TFhirDocumentReferenceRelatesTo }

constructor TFhirDocumentReferenceRelatesTo.Create;
begin
  inherited;
end;

destructor TFhirDocumentReferenceRelatesTo.Destroy;
begin
  FCode.free;
  FTarget.free;
  inherited;
end;

procedure TFhirDocumentReferenceRelatesTo.Assign(oSource : TFslObject);
begin
  inherited;
  FCode := TFhirDocumentReferenceRelatesTo(oSource).FCode.Link;
  target := TFhirDocumentReferenceRelatesTo(oSource).target.Clone;
end;

procedure TFhirDocumentReferenceRelatesTo.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'target') Then
     list.add(self.link, 'target', FTarget.Link);
end;

procedure TFhirDocumentReferenceRelatesTo.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFHIREnum, FCode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'target', 'Reference(DocumentReference)', false, TFhirReference{TFhirDocumentReference}, FTarget.Link));{2}
end;

function TFhirDocumentReferenceRelatesTo.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeElement := asEnum(SYSTEMS_TFhirDocumentRelationshipTypeEnum, CODES_TFhirDocumentRelationshipTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'target') then
  begin
    Target := propValue as TFhirReference{TFhirDocumentReference}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDocumentReferenceRelatesTo.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDocumentReferenceRelatesTo.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'target') then result := TFhirReference{TFhirDocumentReference}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDocumentReferenceRelatesTo.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'code'
  else if (propName = 'target') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDocumentReferenceRelatesTo.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'target') then TargetElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDocumentReferenceRelatesTo.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := asEnum(SYSTEMS_TFhirDocumentRelationshipTypeEnum, CODES_TFhirDocumentRelationshipTypeEnum, new){4}
  else if (propName = 'target') then TargetElement := new as TFhirReference{TFhirDocumentReference}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDocumentReferenceRelatesTo.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDocumentReferenceRelatesTo.fhirType : string;
begin
  result := 'relatesTo';
end;

function TFhirDocumentReferenceRelatesTo.Link : TFhirDocumentReferenceRelatesTo;
begin
  result := TFhirDocumentReferenceRelatesTo(inherited Link);
end;

function TFhirDocumentReferenceRelatesTo.Clone : TFhirDocumentReferenceRelatesTo;
begin
  result := TFhirDocumentReferenceRelatesTo(inherited Clone);
end;

function TFhirDocumentReferenceRelatesTo.equals(other : TObject) : boolean;
var
  o : TFhirDocumentReferenceRelatesTo;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDocumentReferenceRelatesTo)) then
    result := false
  else
  begin
    o := TFhirDocumentReferenceRelatesTo(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(targetElement, o.targetElement, true);
  end;
end;

function TFhirDocumentReferenceRelatesTo.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FTarget);
end;

procedure TFhirDocumentReferenceRelatesTo.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('target');
end;

{ TFhirDocumentReferenceRelatesTo }

Procedure TFhirDocumentReferenceRelatesTo.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirDocumentReferenceRelatesTo.GetCodeST : TFhirDocumentRelationshipTypeEnum;
begin
  if FCode = nil then
    result := TFhirDocumentRelationshipTypeEnum(0)
  else
    result := TFhirDocumentRelationshipTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirDocumentRelationshipTypeEnum, FCode.value));
end;

Procedure TFhirDocumentReferenceRelatesTo.SetCodeST(value : TFhirDocumentRelationshipTypeEnum);
begin
  if ord(value) = 0 then
    CodeElement := nil
  else
    CodeElement := TFhirEnum.create(SYSTEMS_TFhirDocumentRelationshipTypeEnum[value], CODES_TFhirDocumentRelationshipTypeEnum[value]);
end;

Procedure TFhirDocumentReferenceRelatesTo.SetTarget(value : TFhirReference{TFhirDocumentReference});
begin
  FTarget.free;
  FTarget := value;
end;

function TFhirDocumentReferenceRelatesTo.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FTarget.sizeInBytes);
end;

{ TFhirDocumentReferenceRelatesToListEnumerator }

Constructor TFhirDocumentReferenceRelatesToListEnumerator.Create(list : TFhirDocumentReferenceRelatesToList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDocumentReferenceRelatesToListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDocumentReferenceRelatesToListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDocumentReferenceRelatesToListEnumerator.GetCurrent : TFhirDocumentReferenceRelatesTo;
begin
  Result := FList[FIndex];
end;

function TFhirDocumentReferenceRelatesToListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDocumentReferenceRelatesToList }
procedure TFhirDocumentReferenceRelatesToList.AddItem(value: TFhirDocumentReferenceRelatesTo);
begin
  assert(value.ClassName = 'TFhirDocumentReferenceRelatesTo', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDocumentReferenceRelatesTo');
  add(value);
end;

function TFhirDocumentReferenceRelatesToList.Append: TFhirDocumentReferenceRelatesTo;
begin
  result := TFhirDocumentReferenceRelatesTo.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentReferenceRelatesToList.ClearItems;
begin
  Clear;
end;

function TFhirDocumentReferenceRelatesToList.GetEnumerator : TFhirDocumentReferenceRelatesToListEnumerator;
begin
  result := TFhirDocumentReferenceRelatesToListEnumerator.Create(self.link);
end;

function TFhirDocumentReferenceRelatesToList.Clone: TFhirDocumentReferenceRelatesToList;
begin
  result := TFhirDocumentReferenceRelatesToList(inherited Clone);
end;

function TFhirDocumentReferenceRelatesToList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDocumentReferenceRelatesToList.GetItemN(index: Integer): TFhirDocumentReferenceRelatesTo;
begin
  result := TFhirDocumentReferenceRelatesTo(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceRelatesToList.ItemClass: TFslObjectClass;
begin
  result := TFhirDocumentReferenceRelatesTo;
end;
function TFhirDocumentReferenceRelatesToList.IndexOf(value: TFhirDocumentReferenceRelatesTo): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDocumentReferenceRelatesToList.Insert(index: Integer): TFhirDocumentReferenceRelatesTo;
begin
  result := TFhirDocumentReferenceRelatesTo.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentReferenceRelatesToList.InsertItem(index: Integer; value: TFhirDocumentReferenceRelatesTo);
begin
  assert(value is TFhirDocumentReferenceRelatesTo);
  Inherited Insert(index, value);
end;

function TFhirDocumentReferenceRelatesToList.Item(index: Integer): TFhirDocumentReferenceRelatesTo;
begin
  result := TFhirDocumentReferenceRelatesTo(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceRelatesToList.Link: TFhirDocumentReferenceRelatesToList;
begin
  result := TFhirDocumentReferenceRelatesToList(inherited Link);
end;

procedure TFhirDocumentReferenceRelatesToList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDocumentReferenceRelatesToList.SetItemByIndex(index: Integer; value: TFhirDocumentReferenceRelatesTo);
begin
  assert(value is TFhirDocumentReferenceRelatesTo);
  FhirDocumentReferenceRelatesTos[index] := value;
end;

procedure TFhirDocumentReferenceRelatesToList.SetItemN(index: Integer; value: TFhirDocumentReferenceRelatesTo);
begin
  assert(value is TFhirDocumentReferenceRelatesTo);
  ObjectByIndex[index] := value;
end;

{ TFhirDocumentReferenceContent }

constructor TFhirDocumentReferenceContent.Create;
begin
  inherited;
end;

destructor TFhirDocumentReferenceContent.Destroy;
begin
  FAttachment.free;
  FFormatList.Free;
  inherited;
end;

procedure TFhirDocumentReferenceContent.Assign(oSource : TFslObject);
begin
  inherited;
  attachment := TFhirDocumentReferenceContent(oSource).attachment.Clone;
  if (TFhirDocumentReferenceContent(oSource).FFormatList = nil) then
  begin
    FFormatList.free;
    FFormatList := nil;
  end
  else
  begin
    if FFormatList = nil then
      FFormatList := TFhirCodingList.Create;
    FFormatList.Assign(TFhirDocumentReferenceContent(oSource).FFormatList);
  end;
end;

procedure TFhirDocumentReferenceContent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'attachment') Then
     list.add(self.link, 'attachment', FAttachment.Link);
  if (child_name = 'format') Then
    list.addAll(self, 'format', FFormatList);
end;

procedure TFhirDocumentReferenceContent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'attachment', 'Attachment', false, TFhirAttachment, FAttachment.Link));{2}
  oList.add(TFHIRProperty.create(self, 'format', 'Coding', true, TFhirCoding, FFormatList.Link)){3};
end;

function TFhirDocumentReferenceContent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'attachment') then
  begin
    Attachment := propValue as TFhirAttachment{4b};
    result := propValue;
  end
  else if (propName = 'format') then
  begin
    FormatList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDocumentReferenceContent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'format') then FormatList.insertItem(index, propValue as TFhirCoding){2a}
  else inherited;
end;

function TFhirDocumentReferenceContent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'attachment') then result := TFhirAttachment.create(){4b}
  else if (propName = 'format') then result := FormatList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDocumentReferenceContent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'attachment') then result := 'Attachment'
  else if (propName = 'format') then result := 'Coding'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDocumentReferenceContent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'attachment') then AttachmentElement := nil
  else if (propName = 'format') then deletePropertyValue('format', FormatList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDocumentReferenceContent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'attachment') then AttachmentElement := new as TFhirAttachment{4}
  else if (propName = 'format') then replacePropertyValue('format', FormatList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDocumentReferenceContent.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'format') then FormatList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDocumentReferenceContent.fhirType : string;
begin
  result := 'content';
end;

function TFhirDocumentReferenceContent.Link : TFhirDocumentReferenceContent;
begin
  result := TFhirDocumentReferenceContent(inherited Link);
end;

function TFhirDocumentReferenceContent.Clone : TFhirDocumentReferenceContent;
begin
  result := TFhirDocumentReferenceContent(inherited Clone);
end;

function TFhirDocumentReferenceContent.equals(other : TObject) : boolean;
var
  o : TFhirDocumentReferenceContent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDocumentReferenceContent)) then
    result := false
  else
  begin
    o := TFhirDocumentReferenceContent(other);
    result := compareDeep(attachmentElement, o.attachmentElement, true) and compareDeep(formatList, o.formatList, true);
  end;
end;

function TFhirDocumentReferenceContent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAttachment) and isEmptyProp(FformatList);
end;

procedure TFhirDocumentReferenceContent.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('attachment');
  fields.add('format');
end;

{ TFhirDocumentReferenceContent }

Procedure TFhirDocumentReferenceContent.SetAttachment(value : TFhirAttachment);
begin
  FAttachment.free;
  FAttachment := value;
end;

Function TFhirDocumentReferenceContent.GetFormatList : TFhirCodingList;
begin
  if FFormatList = nil then
    FFormatList := TFhirCodingList.Create;
  result := FFormatList;
end;

Function TFhirDocumentReferenceContent.GetHasFormatList : boolean;
begin
  result := (FFormatList <> nil) and (FFormatList.count > 0);
end;

function TFhirDocumentReferenceContent.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FAttachment.sizeInBytes);
  inc(result, FformatList.sizeInBytes);
end;

{ TFhirDocumentReferenceContentListEnumerator }

Constructor TFhirDocumentReferenceContentListEnumerator.Create(list : TFhirDocumentReferenceContentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDocumentReferenceContentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDocumentReferenceContentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDocumentReferenceContentListEnumerator.GetCurrent : TFhirDocumentReferenceContent;
begin
  Result := FList[FIndex];
end;

function TFhirDocumentReferenceContentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDocumentReferenceContentList }
procedure TFhirDocumentReferenceContentList.AddItem(value: TFhirDocumentReferenceContent);
begin
  assert(value.ClassName = 'TFhirDocumentReferenceContent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDocumentReferenceContent');
  add(value);
end;

function TFhirDocumentReferenceContentList.Append: TFhirDocumentReferenceContent;
begin
  result := TFhirDocumentReferenceContent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentReferenceContentList.ClearItems;
begin
  Clear;
end;

function TFhirDocumentReferenceContentList.GetEnumerator : TFhirDocumentReferenceContentListEnumerator;
begin
  result := TFhirDocumentReferenceContentListEnumerator.Create(self.link);
end;

function TFhirDocumentReferenceContentList.Clone: TFhirDocumentReferenceContentList;
begin
  result := TFhirDocumentReferenceContentList(inherited Clone);
end;

function TFhirDocumentReferenceContentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDocumentReferenceContentList.GetItemN(index: Integer): TFhirDocumentReferenceContent;
begin
  result := TFhirDocumentReferenceContent(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceContentList.ItemClass: TFslObjectClass;
begin
  result := TFhirDocumentReferenceContent;
end;
function TFhirDocumentReferenceContentList.IndexOf(value: TFhirDocumentReferenceContent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDocumentReferenceContentList.Insert(index: Integer): TFhirDocumentReferenceContent;
begin
  result := TFhirDocumentReferenceContent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentReferenceContentList.InsertItem(index: Integer; value: TFhirDocumentReferenceContent);
begin
  assert(value is TFhirDocumentReferenceContent);
  Inherited Insert(index, value);
end;

function TFhirDocumentReferenceContentList.Item(index: Integer): TFhirDocumentReferenceContent;
begin
  result := TFhirDocumentReferenceContent(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceContentList.Link: TFhirDocumentReferenceContentList;
begin
  result := TFhirDocumentReferenceContentList(inherited Link);
end;

procedure TFhirDocumentReferenceContentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDocumentReferenceContentList.SetItemByIndex(index: Integer; value: TFhirDocumentReferenceContent);
begin
  assert(value is TFhirDocumentReferenceContent);
  FhirDocumentReferenceContents[index] := value;
end;

procedure TFhirDocumentReferenceContentList.SetItemN(index: Integer; value: TFhirDocumentReferenceContent);
begin
  assert(value is TFhirDocumentReferenceContent);
  ObjectByIndex[index] := value;
end;

{ TFhirDocumentReferenceContext }

constructor TFhirDocumentReferenceContext.Create;
begin
  inherited;
end;

destructor TFhirDocumentReferenceContext.Destroy;
begin
  FEncounter.free;
  FEventList.Free;
  FPeriod.free;
  FFacilityType.free;
  FPracticeSetting.free;
  FSourcePatientInfo.free;
  FRelatedList.Free;
  inherited;
end;

procedure TFhirDocumentReferenceContext.Assign(oSource : TFslObject);
begin
  inherited;
  encounter := TFhirDocumentReferenceContext(oSource).encounter.Clone;
  if (TFhirDocumentReferenceContext(oSource).FEventList = nil) then
  begin
    FEventList.free;
    FEventList := nil;
  end
  else
  begin
    if FEventList = nil then
      FEventList := TFhirCodeableConceptList.Create;
    FEventList.Assign(TFhirDocumentReferenceContext(oSource).FEventList);
  end;
  period := TFhirDocumentReferenceContext(oSource).period.Clone;
  facilityType := TFhirDocumentReferenceContext(oSource).facilityType.Clone;
  practiceSetting := TFhirDocumentReferenceContext(oSource).practiceSetting.Clone;
  sourcePatientInfo := TFhirDocumentReferenceContext(oSource).sourcePatientInfo.Clone;
  if (TFhirDocumentReferenceContext(oSource).FRelatedList = nil) then
  begin
    FRelatedList.free;
    FRelatedList := nil;
  end
  else
  begin
    if FRelatedList = nil then
      FRelatedList := TFhirDocumentReferenceContextRelatedList.Create;
    FRelatedList.Assign(TFhirDocumentReferenceContext(oSource).FRelatedList);
  end;
end;

procedure TFhirDocumentReferenceContext.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'event') Then
    list.addAll(self, 'event', FEventList);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'facilityType') Then
     list.add(self.link, 'facilityType', FFacilityType.Link);
  if (child_name = 'practiceSetting') Then
     list.add(self.link, 'practiceSetting', FPracticeSetting.Link);
  if (child_name = 'sourcePatientInfo') Then
     list.add(self.link, 'sourcePatientInfo', FSourcePatientInfo.Link);
  if (child_name = 'related') Then
    list.addAll(self, 'related', FRelatedList);
end;

procedure TFhirDocumentReferenceContext.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference(Encounter)', false, TFhirReference{TFhirEncounter}, FEncounter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'event', 'CodeableConcept', true, TFhirCodeableConcept, FEventList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'facilityType', 'CodeableConcept', false, TFhirCodeableConcept, FFacilityType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'practiceSetting', 'CodeableConcept', false, TFhirCodeableConcept, FPracticeSetting.Link));{2}
  oList.add(TFHIRProperty.create(self, 'sourcePatientInfo', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FSourcePatientInfo.Link));{2}
  oList.add(TFHIRProperty.create(self, 'related', '', true, TFhirDocumentReferenceContextRelated, FRelatedList.Link)){3};
end;

function TFhirDocumentReferenceContext.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference{TFhirEncounter}{4b};
    result := propValue;
  end
  else if (propName = 'event') then
  begin
    EventList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'facilityType') then
  begin
    FacilityType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'practiceSetting') then
  begin
    PracticeSetting := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'sourcePatientInfo') then
  begin
    SourcePatientInfo := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'related') then
  begin
    RelatedList.add(propValue as TFhirDocumentReferenceContextRelated){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDocumentReferenceContext.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'event') then EventList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'related') then RelatedList.insertItem(index, propValue as TFhirDocumentReferenceContextRelated){2a}
  else inherited;
end;

function TFhirDocumentReferenceContext.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'encounter') then result := TFhirReference{TFhirEncounter}.create(){4b}
  else if (propName = 'event') then result := EventList.new(){2}
  else if (propName = 'period') then result := TFhirPeriod.create(){4b}
  else if (propName = 'facilityType') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'practiceSetting') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'sourcePatientInfo') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'related') then result := RelatedList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDocumentReferenceContext.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'event') then result := 'CodeableConcept'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'facilityType') then result := 'CodeableConcept'
  else if (propName = 'practiceSetting') then result := 'CodeableConcept'
  else if (propName = 'sourcePatientInfo') then result := 'Reference'
  else if (propName = 'related') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDocumentReferenceContext.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'event') then deletePropertyValue('event', EventList, value) {2}
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'facilityType') then FacilityTypeElement := nil
  else if (propName = 'practiceSetting') then PracticeSettingElement := nil
  else if (propName = 'sourcePatientInfo') then SourcePatientInfoElement := nil
  else if (propName = 'related') then deletePropertyValue('related', RelatedList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDocumentReferenceContext.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'encounter') then EncounterElement := new as TFhirReference{TFhirEncounter}{4}
  else if (propName = 'event') then replacePropertyValue('event', EventList, existing, new) {2}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else if (propName = 'facilityType') then FacilityTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'practiceSetting') then PracticeSettingElement := new as TFhirCodeableConcept{4}
  else if (propName = 'sourcePatientInfo') then SourcePatientInfoElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'related') then replacePropertyValue('related', RelatedList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDocumentReferenceContext.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'event') then EventList.move(source, destination){2a}
  else if (propName = 'related') then RelatedList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDocumentReferenceContext.fhirType : string;
begin
  result := 'context';
end;

function TFhirDocumentReferenceContext.Link : TFhirDocumentReferenceContext;
begin
  result := TFhirDocumentReferenceContext(inherited Link);
end;

function TFhirDocumentReferenceContext.Clone : TFhirDocumentReferenceContext;
begin
  result := TFhirDocumentReferenceContext(inherited Clone);
end;

function TFhirDocumentReferenceContext.equals(other : TObject) : boolean;
var
  o : TFhirDocumentReferenceContext;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDocumentReferenceContext)) then
    result := false
  else
  begin
    o := TFhirDocumentReferenceContext(other);
    result := compareDeep(encounterElement, o.encounterElement, true) and compareDeep(eventList, o.eventList, true) and
      compareDeep(periodElement, o.periodElement, true) and compareDeep(facilityTypeElement, o.facilityTypeElement, true) and
      compareDeep(practiceSettingElement, o.practiceSettingElement, true) and compareDeep(sourcePatientInfoElement, o.sourcePatientInfoElement, true) and
      compareDeep(relatedList, o.relatedList, true);
  end;
end;

function TFhirDocumentReferenceContext.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FEncounter) and isEmptyProp(FeventList) and isEmptyProp(FPeriod) and isEmptyProp(FFacilityType) and isEmptyProp(FPracticeSetting) and isEmptyProp(FSourcePatientInfo) and isEmptyProp(FrelatedList);
end;

procedure TFhirDocumentReferenceContext.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('encounter');
  fields.add('event');
  fields.add('period');
  fields.add('facilityType');
  fields.add('practiceSetting');
  fields.add('sourcePatientInfo');
  fields.add('related');
end;

{ TFhirDocumentReferenceContext }

Procedure TFhirDocumentReferenceContext.SetEncounter(value : TFhirReference{TFhirEncounter});
begin
  FEncounter.free;
  FEncounter := value;
end;

Function TFhirDocumentReferenceContext.GetEventList : TFhirCodeableConceptList;
begin
  if FEventList = nil then
    FEventList := TFhirCodeableConceptList.Create;
  result := FEventList;
end;

Function TFhirDocumentReferenceContext.GetHasEventList : boolean;
begin
  result := (FEventList <> nil) and (FEventList.count > 0);
end;

Procedure TFhirDocumentReferenceContext.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Procedure TFhirDocumentReferenceContext.SetFacilityType(value : TFhirCodeableConcept);
begin
  FFacilityType.free;
  FFacilityType := value;
end;

Procedure TFhirDocumentReferenceContext.SetPracticeSetting(value : TFhirCodeableConcept);
begin
  FPracticeSetting.free;
  FPracticeSetting := value;
end;

Procedure TFhirDocumentReferenceContext.SetSourcePatientInfo(value : TFhirReference{TFhirPatient});
begin
  FSourcePatientInfo.free;
  FSourcePatientInfo := value;
end;

Function TFhirDocumentReferenceContext.GetRelatedList : TFhirDocumentReferenceContextRelatedList;
begin
  if FRelatedList = nil then
    FRelatedList := TFhirDocumentReferenceContextRelatedList.Create;
  result := FRelatedList;
end;

Function TFhirDocumentReferenceContext.GetHasRelatedList : boolean;
begin
  result := (FRelatedList <> nil) and (FRelatedList.count > 0);
end;

function TFhirDocumentReferenceContext.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FEncounter.sizeInBytes);
  inc(result, FeventList.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FFacilityType.sizeInBytes);
  inc(result, FPracticeSetting.sizeInBytes);
  inc(result, FSourcePatientInfo.sizeInBytes);
  inc(result, FrelatedList.sizeInBytes);
end;

{ TFhirDocumentReferenceContextListEnumerator }

Constructor TFhirDocumentReferenceContextListEnumerator.Create(list : TFhirDocumentReferenceContextList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDocumentReferenceContextListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDocumentReferenceContextListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDocumentReferenceContextListEnumerator.GetCurrent : TFhirDocumentReferenceContext;
begin
  Result := FList[FIndex];
end;

function TFhirDocumentReferenceContextListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDocumentReferenceContextList }
procedure TFhirDocumentReferenceContextList.AddItem(value: TFhirDocumentReferenceContext);
begin
  assert(value.ClassName = 'TFhirDocumentReferenceContext', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDocumentReferenceContext');
  add(value);
end;

function TFhirDocumentReferenceContextList.Append: TFhirDocumentReferenceContext;
begin
  result := TFhirDocumentReferenceContext.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentReferenceContextList.ClearItems;
begin
  Clear;
end;

function TFhirDocumentReferenceContextList.GetEnumerator : TFhirDocumentReferenceContextListEnumerator;
begin
  result := TFhirDocumentReferenceContextListEnumerator.Create(self.link);
end;

function TFhirDocumentReferenceContextList.Clone: TFhirDocumentReferenceContextList;
begin
  result := TFhirDocumentReferenceContextList(inherited Clone);
end;

function TFhirDocumentReferenceContextList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDocumentReferenceContextList.GetItemN(index: Integer): TFhirDocumentReferenceContext;
begin
  result := TFhirDocumentReferenceContext(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceContextList.ItemClass: TFslObjectClass;
begin
  result := TFhirDocumentReferenceContext;
end;
function TFhirDocumentReferenceContextList.IndexOf(value: TFhirDocumentReferenceContext): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDocumentReferenceContextList.Insert(index: Integer): TFhirDocumentReferenceContext;
begin
  result := TFhirDocumentReferenceContext.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentReferenceContextList.InsertItem(index: Integer; value: TFhirDocumentReferenceContext);
begin
  assert(value is TFhirDocumentReferenceContext);
  Inherited Insert(index, value);
end;

function TFhirDocumentReferenceContextList.Item(index: Integer): TFhirDocumentReferenceContext;
begin
  result := TFhirDocumentReferenceContext(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceContextList.Link: TFhirDocumentReferenceContextList;
begin
  result := TFhirDocumentReferenceContextList(inherited Link);
end;

procedure TFhirDocumentReferenceContextList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDocumentReferenceContextList.SetItemByIndex(index: Integer; value: TFhirDocumentReferenceContext);
begin
  assert(value is TFhirDocumentReferenceContext);
  FhirDocumentReferenceContexts[index] := value;
end;

procedure TFhirDocumentReferenceContextList.SetItemN(index: Integer; value: TFhirDocumentReferenceContext);
begin
  assert(value is TFhirDocumentReferenceContext);
  ObjectByIndex[index] := value;
end;

{ TFhirDocumentReferenceContextRelated }

constructor TFhirDocumentReferenceContextRelated.Create;
begin
  inherited;
end;

destructor TFhirDocumentReferenceContextRelated.Destroy;
begin
  FIdentifier.free;
  FRef.free;
  inherited;
end;

procedure TFhirDocumentReferenceContextRelated.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirDocumentReferenceContextRelated(oSource).identifier.Clone;
  ref := TFhirDocumentReferenceContextRelated(oSource).ref.Clone;
end;

procedure TFhirDocumentReferenceContextRelated.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'ref') Then
     list.add(self.link, 'ref', FRef.Link);
end;

procedure TFhirDocumentReferenceContextRelated.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'ref', 'Reference(Any)', false, TFhirReference{TFhirReference}, FRef.Link));{2}
end;

function TFhirDocumentReferenceContextRelated.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'ref') then
  begin
    Ref := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDocumentReferenceContextRelated.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDocumentReferenceContextRelated.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'ref') then result := TFhirReference{TFhirReference}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDocumentReferenceContextRelated.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'ref') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDocumentReferenceContextRelated.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'ref') then RefElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDocumentReferenceContextRelated.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'ref') then RefElement := new as TFhirReference{TFhirReference}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDocumentReferenceContextRelated.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDocumentReferenceContextRelated.fhirType : string;
begin
  result := 'related';
end;

function TFhirDocumentReferenceContextRelated.Link : TFhirDocumentReferenceContextRelated;
begin
  result := TFhirDocumentReferenceContextRelated(inherited Link);
end;

function TFhirDocumentReferenceContextRelated.Clone : TFhirDocumentReferenceContextRelated;
begin
  result := TFhirDocumentReferenceContextRelated(inherited Clone);
end;

function TFhirDocumentReferenceContextRelated.equals(other : TObject) : boolean;
var
  o : TFhirDocumentReferenceContextRelated;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDocumentReferenceContextRelated)) then
    result := false
  else
  begin
    o := TFhirDocumentReferenceContextRelated(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(refElement, o.refElement, true);
  end;
end;

function TFhirDocumentReferenceContextRelated.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FRef);
end;

procedure TFhirDocumentReferenceContextRelated.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('ref');
end;

{ TFhirDocumentReferenceContextRelated }

Procedure TFhirDocumentReferenceContextRelated.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirDocumentReferenceContextRelated.SetRef(value : TFhirReference{TFhirReference});
begin
  FRef.free;
  FRef := value;
end;

function TFhirDocumentReferenceContextRelated.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FRef.sizeInBytes);
end;

{ TFhirDocumentReferenceContextRelatedListEnumerator }

Constructor TFhirDocumentReferenceContextRelatedListEnumerator.Create(list : TFhirDocumentReferenceContextRelatedList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDocumentReferenceContextRelatedListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDocumentReferenceContextRelatedListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDocumentReferenceContextRelatedListEnumerator.GetCurrent : TFhirDocumentReferenceContextRelated;
begin
  Result := FList[FIndex];
end;

function TFhirDocumentReferenceContextRelatedListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDocumentReferenceContextRelatedList }
procedure TFhirDocumentReferenceContextRelatedList.AddItem(value: TFhirDocumentReferenceContextRelated);
begin
  assert(value.ClassName = 'TFhirDocumentReferenceContextRelated', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDocumentReferenceContextRelated');
  add(value);
end;

function TFhirDocumentReferenceContextRelatedList.Append: TFhirDocumentReferenceContextRelated;
begin
  result := TFhirDocumentReferenceContextRelated.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentReferenceContextRelatedList.ClearItems;
begin
  Clear;
end;

function TFhirDocumentReferenceContextRelatedList.GetEnumerator : TFhirDocumentReferenceContextRelatedListEnumerator;
begin
  result := TFhirDocumentReferenceContextRelatedListEnumerator.Create(self.link);
end;

function TFhirDocumentReferenceContextRelatedList.Clone: TFhirDocumentReferenceContextRelatedList;
begin
  result := TFhirDocumentReferenceContextRelatedList(inherited Clone);
end;

function TFhirDocumentReferenceContextRelatedList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDocumentReferenceContextRelatedList.GetItemN(index: Integer): TFhirDocumentReferenceContextRelated;
begin
  result := TFhirDocumentReferenceContextRelated(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceContextRelatedList.ItemClass: TFslObjectClass;
begin
  result := TFhirDocumentReferenceContextRelated;
end;
function TFhirDocumentReferenceContextRelatedList.IndexOf(value: TFhirDocumentReferenceContextRelated): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDocumentReferenceContextRelatedList.Insert(index: Integer): TFhirDocumentReferenceContextRelated;
begin
  result := TFhirDocumentReferenceContextRelated.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentReferenceContextRelatedList.InsertItem(index: Integer; value: TFhirDocumentReferenceContextRelated);
begin
  assert(value is TFhirDocumentReferenceContextRelated);
  Inherited Insert(index, value);
end;

function TFhirDocumentReferenceContextRelatedList.Item(index: Integer): TFhirDocumentReferenceContextRelated;
begin
  result := TFhirDocumentReferenceContextRelated(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceContextRelatedList.Link: TFhirDocumentReferenceContextRelatedList;
begin
  result := TFhirDocumentReferenceContextRelatedList(inherited Link);
end;

procedure TFhirDocumentReferenceContextRelatedList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDocumentReferenceContextRelatedList.SetItemByIndex(index: Integer; value: TFhirDocumentReferenceContextRelated);
begin
  assert(value is TFhirDocumentReferenceContextRelated);
  FhirDocumentReferenceContextRelateds[index] := value;
end;

procedure TFhirDocumentReferenceContextRelatedList.SetItemN(index: Integer; value: TFhirDocumentReferenceContextRelated);
begin
  assert(value is TFhirDocumentReferenceContextRelated);
  ObjectByIndex[index] := value;
end;

{ TFhirDocumentReference }

constructor TFhirDocumentReference.Create;
begin
  inherited;
end;

destructor TFhirDocumentReference.Destroy;
begin
  FMasterIdentifier.free;
  FIdentifierList.Free;
  FSubject.free;
  FType_.free;
  FClass_.free;
  FAuthorList.Free;
  FCustodian.free;
  FAuthenticator.free;
  FCreated.free;
  FIndexed.free;
  FStatus.free;
  FDocStatus.free;
  FRelatesToList.Free;
  FDescription.free;
  FSecurityLabelList.Free;
  FContentList.Free;
  FContext.free;
  inherited;
end;

function TFhirDocumentReference.GetResourceType : TFhirResourceType;
begin
  result := frtDocumentReference;
end;

procedure TFhirDocumentReference.Assign(oSource : TFslObject);
begin
  inherited;
  masterIdentifier := TFhirDocumentReference(oSource).masterIdentifier.Clone;
  if (TFhirDocumentReference(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirDocumentReference(oSource).FIdentifierList);
  end;
  subject := TFhirDocumentReference(oSource).subject.Clone;
  type_ := TFhirDocumentReference(oSource).type_.Clone;
  class_ := TFhirDocumentReference(oSource).class_.Clone;
  if (TFhirDocumentReference(oSource).FAuthorList = nil) then
  begin
    FAuthorList.free;
    FAuthorList := nil;
  end
  else
  begin
    if FAuthorList = nil then
      FAuthorList := TFhirReferenceList{Resource}.Create;
    FAuthorList.Assign(TFhirDocumentReference(oSource).FAuthorList);
  end;
  custodian := TFhirDocumentReference(oSource).custodian.Clone;
  authenticator := TFhirDocumentReference(oSource).authenticator.Clone;
  createdElement := TFhirDocumentReference(oSource).createdElement.Clone;
  indexedElement := TFhirDocumentReference(oSource).indexedElement.Clone;
  FStatus := TFhirDocumentReference(oSource).FStatus.Link;
  docStatus := TFhirDocumentReference(oSource).docStatus.Clone;
  if (TFhirDocumentReference(oSource).FRelatesToList = nil) then
  begin
    FRelatesToList.free;
    FRelatesToList := nil;
  end
  else
  begin
    if FRelatesToList = nil then
      FRelatesToList := TFhirDocumentReferenceRelatesToList.Create;
    FRelatesToList.Assign(TFhirDocumentReference(oSource).FRelatesToList);
  end;
  descriptionElement := TFhirDocumentReference(oSource).descriptionElement.Clone;
  if (TFhirDocumentReference(oSource).FSecurityLabelList = nil) then
  begin
    FSecurityLabelList.free;
    FSecurityLabelList := nil;
  end
  else
  begin
    if FSecurityLabelList = nil then
      FSecurityLabelList := TFhirCodeableConceptList.Create;
    FSecurityLabelList.Assign(TFhirDocumentReference(oSource).FSecurityLabelList);
  end;
  if (TFhirDocumentReference(oSource).FContentList = nil) then
  begin
    FContentList.free;
    FContentList := nil;
  end
  else
  begin
    if FContentList = nil then
      FContentList := TFhirDocumentReferenceContentList.Create;
    FContentList.Assign(TFhirDocumentReference(oSource).FContentList);
  end;
  context := TFhirDocumentReference(oSource).context.Clone;
end;

procedure TFhirDocumentReference.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'masterIdentifier') Then
     list.add(self.link, 'masterIdentifier', FMasterIdentifier.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'class') Then
     list.add(self.link, 'class', FClass_.Link);
  if (child_name = 'author') Then
    list.addAll(self, 'author', FAuthorList);
  if (child_name = 'custodian') Then
     list.add(self.link, 'custodian', FCustodian.Link);
  if (child_name = 'authenticator') Then
     list.add(self.link, 'authenticator', FAuthenticator.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'indexed') Then
     list.add(self.link, 'indexed', FIndexed.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'docStatus') Then
     list.add(self.link, 'docStatus', FDocStatus.Link);
  if (child_name = 'relatesTo') Then
    list.addAll(self, 'relatesTo', FRelatesToList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'securityLabel') Then
    list.addAll(self, 'securityLabel', FSecurityLabelList);
  if (child_name = 'content') Then
    list.addAll(self, 'content', FContentList);
  if (child_name = 'context') Then
     list.add(self.link, 'context', FContext.Link);
end;

procedure TFhirDocumentReference.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'masterIdentifier', 'Identifier', false, TFhirIdentifier, FMasterIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Practitioner|Group|Device)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'class', 'CodeableConcept', false, TFhirCodeableConcept, FClass_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'author', 'Reference(Practitioner|Organization|Device|Patient|RelatedPerson)', true, TFhirReference{Resource}, FAuthorList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'custodian', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FCustodian.Link));{2}
  oList.add(TFHIRProperty.create(self, 'authenticator', 'Reference(Practitioner|Organization)', false, TFhirReference{Resource}, FAuthenticator.Link));{2}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));{2}
  oList.add(TFHIRProperty.create(self, 'indexed', 'instant', false, TFhirInstant, FIndexed.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'docStatus', 'CodeableConcept', false, TFhirCodeableConcept, FDocStatus.Link));{2}
  oList.add(TFHIRProperty.create(self, 'relatesTo', '', true, TFhirDocumentReferenceRelatesTo, FRelatesToList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'securityLabel', 'CodeableConcept', true, TFhirCodeableConcept, FSecurityLabelList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'content', '', true, TFhirDocumentReferenceContent, FContentList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'context', '', false, TFhirDocumentReferenceContext, FContext.Link));{2}
end;

function TFhirDocumentReference.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'masterIdentifier') then
  begin
    MasterIdentifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'class') then
  begin
    Class_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    AuthorList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'custodian') then
  begin
    Custodian := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'authenticator') then
  begin
    Authenticator := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'indexed') then
  begin
    IndexedElement := asInstant(propValue){5a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirDocumentReferenceStatusEnum, CODES_TFhirDocumentReferenceStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'docStatus') then
  begin
    DocStatus := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'relatesTo') then
  begin
    RelatesToList.add(propValue as TFhirDocumentReferenceRelatesTo){2a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'securityLabel') then
  begin
    SecurityLabelList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'content') then
  begin
    ContentList.add(propValue as TFhirDocumentReferenceContent){2a};
    result := propValue;
  end
  else if (propName = 'context') then
  begin
    Context := propValue as TFhirDocumentReferenceContext{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirDocumentReference.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'author') then AuthorList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'relatesTo') then RelatesToList.insertItem(index, propValue as TFhirDocumentReferenceRelatesTo){2a}
  else if (propName = 'securityLabel') then SecurityLabelList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'content') then ContentList.insertItem(index, propValue as TFhirDocumentReferenceContent){2a}
  else inherited;
end;

function TFhirDocumentReference.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'masterIdentifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'class') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'author') then result := AuthorList.new(){2}
  else if (propName = 'custodian') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'authenticator') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'created') then result := TFhirDateTime.create() {5b}
  else if (propName = 'indexed') then result := TFhirInstant.create() {5b}
  else if (propName = 'docStatus') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'relatesTo') then result := RelatesToList.new(){2}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'securityLabel') then result := SecurityLabelList.new(){2}
  else if (propName = 'content') then result := ContentList.new(){2}
  else if (propName = 'context') then result := TFhirDocumentReferenceContext.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDocumentReference.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'masterIdentifier') then result := 'Identifier'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'class') then result := 'CodeableConcept'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'custodian') then result := 'Reference'
  else if (propName = 'authenticator') then result := 'Reference'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'indexed') then result := 'instant'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'docStatus') then result := 'CodeableConcept'
  else if (propName = 'relatesTo') then result := ''
  else if (propName = 'description') then result := 'string'
  else if (propName = 'securityLabel') then result := 'CodeableConcept'
  else if (propName = 'content') then result := ''
  else if (propName = 'context') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDocumentReference.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'masterIdentifier') then MasterIdentifierElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'class') then Class_Element := nil
  else if (propName = 'author') then deletePropertyValue('author', AuthorList, value) {2}
  else if (propName = 'custodian') then CustodianElement := nil
  else if (propName = 'authenticator') then AuthenticatorElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'indexed') then IndexedElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'docStatus') then DocStatusElement := nil
  else if (propName = 'relatesTo') then deletePropertyValue('relatesTo', RelatesToList, value) {2}
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'securityLabel') then deletePropertyValue('securityLabel', SecurityLabelList, value) {2}
  else if (propName = 'content') then deletePropertyValue('content', ContentList, value) {2}
  else if (propName = 'context') then ContextElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDocumentReference.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'masterIdentifier') then MasterIdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'class') then Class_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'author') then replacePropertyValue('author', AuthorList, existing, new) {2}
  else if (propName = 'custodian') then CustodianElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'authenticator') then AuthenticatorElement := new as TFhirReference{Resource}{4}
  else if (propName = 'created') then CreatedElement := asDateTime(new){5b}
  else if (propName = 'indexed') then IndexedElement := asInstant(new){5b}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirDocumentReferenceStatusEnum, CODES_TFhirDocumentReferenceStatusEnum, new){4}
  else if (propName = 'docStatus') then DocStatusElement := new as TFhirCodeableConcept{4}
  else if (propName = 'relatesTo') then replacePropertyValue('relatesTo', RelatesToList, existing, new) {2}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'securityLabel') then replacePropertyValue('securityLabel', SecurityLabelList, existing, new) {2}
  else if (propName = 'content') then replacePropertyValue('content', ContentList, existing, new) {2}
  else if (propName = 'context') then ContextElement := new as TFhirDocumentReferenceContext{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDocumentReference.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'author') then AuthorList.move(source, destination){2a}
  else if (propName = 'relatesTo') then RelatesToList.move(source, destination){2a}
  else if (propName = 'securityLabel') then SecurityLabelList.move(source, destination){2a}
  else if (propName = 'content') then ContentList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDocumentReference.fhirType : string;
begin
  result := 'DocumentReference';
end;

function TFhirDocumentReference.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMasterIdentifier) and isEmptyProp(FidentifierList) and isEmptyProp(FSubject) and isEmptyProp(FType_) and isEmptyProp(FClass_) and isEmptyProp(FauthorList) and isEmptyProp(FCustodian) and isEmptyProp(FAuthenticator) and isEmptyProp(FCreated) and isEmptyProp(FIndexed) and isEmptyProp(FStatus) and isEmptyProp(FDocStatus) and isEmptyProp(FrelatesToList) and isEmptyProp(FDescription) and isEmptyProp(FsecurityLabelList) and isEmptyProp(FcontentList) and isEmptyProp(FContext);
end;

function TFhirDocumentReference.equals(other : TObject) : boolean;
var
  o : TFhirDocumentReference;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDocumentReference)) then
    result := false
  else
  begin
    o := TFhirDocumentReference(other);
    result := compareDeep(masterIdentifierElement, o.masterIdentifierElement, true) and
      compareDeep(identifierList, o.identifierList, true) and compareDeep(subjectElement, o.subjectElement, true) and
      compareDeep(type_Element, o.type_Element, true) and compareDeep(class_Element, o.class_Element, true) and
      compareDeep(authorList, o.authorList, true) and compareDeep(custodianElement, o.custodianElement, true) and
      compareDeep(authenticatorElement, o.authenticatorElement, true) and compareDeep(createdElement, o.createdElement, true) and
      compareDeep(indexedElement, o.indexedElement, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(docStatusElement, o.docStatusElement, true) and compareDeep(relatesToList, o.relatesToList, true) and
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(securityLabelList, o.securityLabelList, true) and
      compareDeep(contentList, o.contentList, true) and compareDeep(contextElement, o.contextElement, true);
  end;
end;

function TFhirDocumentReference.Link : TFhirDocumentReference;
begin
  result := TFhirDocumentReference(inherited Link);
end;

function TFhirDocumentReference.Clone : TFhirDocumentReference;
begin
  result := TFhirDocumentReference(inherited Clone);
end;

procedure TFhirDocumentReference.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('masterIdentifier');
  fields.add('identifier');
  fields.add('subject');
  fields.add('type');
  fields.add('class');
  fields.add('author');
  fields.add('custodian');
  fields.add('authenticator');
  fields.add('created');
  fields.add('indexed');
  fields.add('status');
  fields.add('docStatus');
  fields.add('relatesTo');
  fields.add('description');
  fields.add('securityLabel');
  fields.add('content');
  fields.add('context');
end;

{ TFhirDocumentReference }

Procedure TFhirDocumentReference.SetMasterIdentifier(value : TFhirIdentifier);
begin
  FMasterIdentifier.free;
  FMasterIdentifier := value;
end;

Function TFhirDocumentReference.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirDocumentReference.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirDocumentReference.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirDocumentReference.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirDocumentReference.SetClass_(value : TFhirCodeableConcept);
begin
  FClass_.free;
  FClass_ := value;
end;

Function TFhirDocumentReference.GetAuthorList : TFhirReferenceList{Resource};
begin
  if FAuthorList = nil then
    FAuthorList := TFhirReferenceList{Resource}.Create;
  result := FAuthorList;
end;

Function TFhirDocumentReference.GetHasAuthorList : boolean;
begin
  result := (FAuthorList <> nil) and (FAuthorList.count > 0);
end;

Procedure TFhirDocumentReference.SetCustodian(value : TFhirReference{TFhirOrganization});
begin
  FCustodian.free;
  FCustodian := value;
end;

Procedure TFhirDocumentReference.SetAuthenticator(value : TFhirReference{Resource});
begin
  FAuthenticator.free;
  FAuthenticator := value;
end;

Procedure TFhirDocumentReference.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

Function TFhirDocumentReference.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

Procedure TFhirDocumentReference.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

Procedure TFhirDocumentReference.SetIndexed(value : TFhirInstant);
begin
  FIndexed.free;
  FIndexed := value;
end;

Function TFhirDocumentReference.GetIndexedST : TFslDateTime;
begin
  if FIndexed = nil then
    result := TFslDateTime.makeNull
  else
    result := FIndexed.value;
end;

Procedure TFhirDocumentReference.SetIndexedST(value : TFslDateTime);
begin
  if FIndexed = nil then
    FIndexed := TFhirInstant.create;
  FIndexed.value := value
end;

Procedure TFhirDocumentReference.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirDocumentReference.GetStatusST : TFhirDocumentReferenceStatusEnum;
begin
  if FStatus = nil then
    result := TFhirDocumentReferenceStatusEnum(0)
  else
    result := TFhirDocumentReferenceStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirDocumentReferenceStatusEnum, FStatus.value));
end;

Procedure TFhirDocumentReference.SetStatusST(value : TFhirDocumentReferenceStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirDocumentReferenceStatusEnum[value], CODES_TFhirDocumentReferenceStatusEnum[value]);
end;

Procedure TFhirDocumentReference.SetDocStatus(value : TFhirCodeableConcept);
begin
  FDocStatus.free;
  FDocStatus := value;
end;

Function TFhirDocumentReference.GetRelatesToList : TFhirDocumentReferenceRelatesToList;
begin
  if FRelatesToList = nil then
    FRelatesToList := TFhirDocumentReferenceRelatesToList.Create;
  result := FRelatesToList;
end;

Function TFhirDocumentReference.GetHasRelatesToList : boolean;
begin
  result := (FRelatesToList <> nil) and (FRelatesToList.count > 0);
end;

Procedure TFhirDocumentReference.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirDocumentReference.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirDocumentReference.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Function TFhirDocumentReference.GetSecurityLabelList : TFhirCodeableConceptList;
begin
  if FSecurityLabelList = nil then
    FSecurityLabelList := TFhirCodeableConceptList.Create;
  result := FSecurityLabelList;
end;

Function TFhirDocumentReference.GetHasSecurityLabelList : boolean;
begin
  result := (FSecurityLabelList <> nil) and (FSecurityLabelList.count > 0);
end;

Function TFhirDocumentReference.GetContentList : TFhirDocumentReferenceContentList;
begin
  if FContentList = nil then
    FContentList := TFhirDocumentReferenceContentList.Create;
  result := FContentList;
end;

Function TFhirDocumentReference.GetHasContentList : boolean;
begin
  result := (FContentList <> nil) and (FContentList.count > 0);
end;

Procedure TFhirDocumentReference.SetContext(value : TFhirDocumentReferenceContext);
begin
  FContext.free;
  FContext := value;
end;

function TFhirDocumentReference.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FMasterIdentifier.sizeInBytes);
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FClass_.sizeInBytes);
  inc(result, FauthorList.sizeInBytes);
  inc(result, FCustodian.sizeInBytes);
  inc(result, FAuthenticator.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FIndexed.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FDocStatus.sizeInBytes);
  inc(result, FrelatesToList.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FsecurityLabelList.sizeInBytes);
  inc(result, FcontentList.sizeInBytes);
  inc(result, FContext.sizeInBytes);
end;

{ TFhirDocumentReferenceListEnumerator }

Constructor TFhirDocumentReferenceListEnumerator.Create(list : TFhirDocumentReferenceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDocumentReferenceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDocumentReferenceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDocumentReferenceListEnumerator.GetCurrent : TFhirDocumentReference;
begin
  Result := FList[FIndex];
end;

function TFhirDocumentReferenceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDocumentReferenceList }
procedure TFhirDocumentReferenceList.AddItem(value: TFhirDocumentReference);
begin
  assert(value.ClassName = 'TFhirDocumentReference', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDocumentReference');
  add(value);
end;

function TFhirDocumentReferenceList.Append: TFhirDocumentReference;
begin
  result := TFhirDocumentReference.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentReferenceList.ClearItems;
begin
  Clear;
end;

function TFhirDocumentReferenceList.GetEnumerator : TFhirDocumentReferenceListEnumerator;
begin
  result := TFhirDocumentReferenceListEnumerator.Create(self.link);
end;

function TFhirDocumentReferenceList.Clone: TFhirDocumentReferenceList;
begin
  result := TFhirDocumentReferenceList(inherited Clone);
end;

function TFhirDocumentReferenceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDocumentReferenceList.GetItemN(index: Integer): TFhirDocumentReference;
begin
  result := TFhirDocumentReference(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceList.ItemClass: TFslObjectClass;
begin
  result := TFhirDocumentReference;
end;
function TFhirDocumentReferenceList.IndexOf(value: TFhirDocumentReference): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDocumentReferenceList.Insert(index: Integer): TFhirDocumentReference;
begin
  result := TFhirDocumentReference.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentReferenceList.InsertItem(index: Integer; value: TFhirDocumentReference);
begin
  assert(value is TFhirDocumentReference);
  Inherited Insert(index, value);
end;

function TFhirDocumentReferenceList.Item(index: Integer): TFhirDocumentReference;
begin
  result := TFhirDocumentReference(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceList.Link: TFhirDocumentReferenceList;
begin
  result := TFhirDocumentReferenceList(inherited Link);
end;

procedure TFhirDocumentReferenceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDocumentReferenceList.SetItemByIndex(index: Integer; value: TFhirDocumentReference);
begin
  assert(value is TFhirDocumentReference);
  FhirDocumentReferences[index] := value;
end;

procedure TFhirDocumentReferenceList.SetItemN(index: Integer; value: TFhirDocumentReference);
begin
  assert(value is TFhirDocumentReference);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_DOCUMENTREFERENCE}

{$IFDEF FHIR_FAMILYMEMBERHISTORY}

{ TFhirFamilyMemberHistoryCondition }

constructor TFhirFamilyMemberHistoryCondition.Create;
begin
  inherited;
end;

destructor TFhirFamilyMemberHistoryCondition.Destroy;
begin
  FCode.free;
  FOutcome.free;
  FOnset.free;
  FNote.free;
  inherited;
end;

procedure TFhirFamilyMemberHistoryCondition.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirFamilyMemberHistoryCondition(oSource).code.Clone;
  outcome := TFhirFamilyMemberHistoryCondition(oSource).outcome.Clone;
  onset := TFhirFamilyMemberHistoryCondition(oSource).onset.Clone;
  note := TFhirFamilyMemberHistoryCondition(oSource).note.Clone;
end;

procedure TFhirFamilyMemberHistoryCondition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'onset[x]') or (child_name = 'onset') Then
     list.add(self.link, 'onset[x]', FOnset.Link);
  if (child_name = 'note') Then
     list.add(self.link, 'note', FNote.Link);
end;

procedure TFhirFamilyMemberHistoryCondition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'outcome', 'CodeableConcept', false, TFhirCodeableConcept, FOutcome.Link));{2}
  oList.add(TFHIRProperty.create(self, 'onset[x]', 'Quantity|Range|Period|string', false, TFhirType, FOnset.Link));{2}
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', false, TFhirAnnotation, FNote.Link));{2}
end;

function TFhirFamilyMemberHistoryCondition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    Outcome := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'onset', ['Quantity', 'Range', 'Period', 'String'])) then
  begin
    Onset := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    Note := propValue as TFhirAnnotation{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirFamilyMemberHistoryCondition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirFamilyMemberHistoryCondition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'outcome') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'onset', ['Quantity', 'Range', 'Period', 'String'])) then raise EFHIRException.create('Cannot make property Onset'){4x}
  else if (propName = 'note') then result := TFhirAnnotation.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirFamilyMemberHistoryCondition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'outcome') then result := 'CodeableConcept'
  else if (propName = 'onset[x]') then result := 'Quantity|Range|Period|string'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirFamilyMemberHistoryCondition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (isMatchingName(propName, 'onset', ['Quantity', 'Range', 'Period', 'String'])) then OnsetElement := nil{4x}
  else if (propName = 'note') then NoteElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirFamilyMemberHistoryCondition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'outcome') then OutcomeElement := new as TFhirCodeableConcept{4}
  else if (isMatchingName(propName, 'onset', ['Quantity', 'Range', 'Period', 'String'])) then OnsetElement := new as TFhirType{4x}
  else if (propName = 'note') then NoteElement := new as TFhirAnnotation{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirFamilyMemberHistoryCondition.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirFamilyMemberHistoryCondition.fhirType : string;
begin
  result := 'condition';
end;

function TFhirFamilyMemberHistoryCondition.Link : TFhirFamilyMemberHistoryCondition;
begin
  result := TFhirFamilyMemberHistoryCondition(inherited Link);
end;

function TFhirFamilyMemberHistoryCondition.Clone : TFhirFamilyMemberHistoryCondition;
begin
  result := TFhirFamilyMemberHistoryCondition(inherited Clone);
end;

function TFhirFamilyMemberHistoryCondition.equals(other : TObject) : boolean;
var
  o : TFhirFamilyMemberHistoryCondition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirFamilyMemberHistoryCondition)) then
    result := false
  else
  begin
    o := TFhirFamilyMemberHistoryCondition(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(outcomeElement, o.outcomeElement, true) and
      compareDeep(onsetElement, o.onsetElement, true) and compareDeep(noteElement, o.noteElement, true);
  end;
end;

function TFhirFamilyMemberHistoryCondition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FOutcome) and isEmptyProp(FOnset) and isEmptyProp(FNote);
end;

procedure TFhirFamilyMemberHistoryCondition.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('outcome');
  fields.add('onset[x]');
  fields.add('note');
end;

{ TFhirFamilyMemberHistoryCondition }

Procedure TFhirFamilyMemberHistoryCondition.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirFamilyMemberHistoryCondition.SetOutcome(value : TFhirCodeableConcept);
begin
  FOutcome.free;
  FOutcome := value;
end;

Procedure TFhirFamilyMemberHistoryCondition.SetOnset(value : TFhirType);
begin
  FOnset.free;
  FOnset := value;
end;

Procedure TFhirFamilyMemberHistoryCondition.SetNote(value : TFhirAnnotation);
begin
  FNote.free;
  FNote := value;
end;

function TFhirFamilyMemberHistoryCondition.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FOutcome.sizeInBytes);
  inc(result, FOnset.sizeInBytes);
  inc(result, FNote.sizeInBytes);
end;

{ TFhirFamilyMemberHistoryConditionListEnumerator }

Constructor TFhirFamilyMemberHistoryConditionListEnumerator.Create(list : TFhirFamilyMemberHistoryConditionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirFamilyMemberHistoryConditionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirFamilyMemberHistoryConditionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirFamilyMemberHistoryConditionListEnumerator.GetCurrent : TFhirFamilyMemberHistoryCondition;
begin
  Result := FList[FIndex];
end;

function TFhirFamilyMemberHistoryConditionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirFamilyMemberHistoryConditionList }
procedure TFhirFamilyMemberHistoryConditionList.AddItem(value: TFhirFamilyMemberHistoryCondition);
begin
  assert(value.ClassName = 'TFhirFamilyMemberHistoryCondition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirFamilyMemberHistoryCondition');
  add(value);
end;

function TFhirFamilyMemberHistoryConditionList.Append: TFhirFamilyMemberHistoryCondition;
begin
  result := TFhirFamilyMemberHistoryCondition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirFamilyMemberHistoryConditionList.ClearItems;
begin
  Clear;
end;

function TFhirFamilyMemberHistoryConditionList.GetEnumerator : TFhirFamilyMemberHistoryConditionListEnumerator;
begin
  result := TFhirFamilyMemberHistoryConditionListEnumerator.Create(self.link);
end;

function TFhirFamilyMemberHistoryConditionList.Clone: TFhirFamilyMemberHistoryConditionList;
begin
  result := TFhirFamilyMemberHistoryConditionList(inherited Clone);
end;

function TFhirFamilyMemberHistoryConditionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirFamilyMemberHistoryConditionList.GetItemN(index: Integer): TFhirFamilyMemberHistoryCondition;
begin
  result := TFhirFamilyMemberHistoryCondition(ObjectByIndex[index]);
end;

function TFhirFamilyMemberHistoryConditionList.ItemClass: TFslObjectClass;
begin
  result := TFhirFamilyMemberHistoryCondition;
end;
function TFhirFamilyMemberHistoryConditionList.IndexOf(value: TFhirFamilyMemberHistoryCondition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirFamilyMemberHistoryConditionList.Insert(index: Integer): TFhirFamilyMemberHistoryCondition;
begin
  result := TFhirFamilyMemberHistoryCondition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirFamilyMemberHistoryConditionList.InsertItem(index: Integer; value: TFhirFamilyMemberHistoryCondition);
begin
  assert(value is TFhirFamilyMemberHistoryCondition);
  Inherited Insert(index, value);
end;

function TFhirFamilyMemberHistoryConditionList.Item(index: Integer): TFhirFamilyMemberHistoryCondition;
begin
  result := TFhirFamilyMemberHistoryCondition(ObjectByIndex[index]);
end;

function TFhirFamilyMemberHistoryConditionList.Link: TFhirFamilyMemberHistoryConditionList;
begin
  result := TFhirFamilyMemberHistoryConditionList(inherited Link);
end;

procedure TFhirFamilyMemberHistoryConditionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirFamilyMemberHistoryConditionList.SetItemByIndex(index: Integer; value: TFhirFamilyMemberHistoryCondition);
begin
  assert(value is TFhirFamilyMemberHistoryCondition);
  FhirFamilyMemberHistoryConditions[index] := value;
end;

procedure TFhirFamilyMemberHistoryConditionList.SetItemN(index: Integer; value: TFhirFamilyMemberHistoryCondition);
begin
  assert(value is TFhirFamilyMemberHistoryCondition);
  ObjectByIndex[index] := value;
end;

{ TFhirFamilyMemberHistory }

constructor TFhirFamilyMemberHistory.Create;
begin
  inherited;
end;

destructor TFhirFamilyMemberHistory.Destroy;
begin
  FIdentifierList.Free;
  FPatient.free;
  FDate.free;
  FStatus.free;
  FName.free;
  FRelationship.free;
  FGender.free;
  FBorn.free;
  FAge.free;
  FDeceased.free;
  FNote.free;
  FConditionList.Free;
  inherited;
end;

function TFhirFamilyMemberHistory.GetResourceType : TFhirResourceType;
begin
  result := frtFamilyMemberHistory;
end;

procedure TFhirFamilyMemberHistory.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirFamilyMemberHistory(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirFamilyMemberHistory(oSource).FIdentifierList);
  end;
  patient := TFhirFamilyMemberHistory(oSource).patient.Clone;
  dateElement := TFhirFamilyMemberHistory(oSource).dateElement.Clone;
  FStatus := TFhirFamilyMemberHistory(oSource).FStatus.Link;
  nameElement := TFhirFamilyMemberHistory(oSource).nameElement.Clone;
  relationship := TFhirFamilyMemberHistory(oSource).relationship.Clone;
  FGender := TFhirFamilyMemberHistory(oSource).FGender.Link;
  born := TFhirFamilyMemberHistory(oSource).born.Clone;
  age := TFhirFamilyMemberHistory(oSource).age.Clone;
  deceased := TFhirFamilyMemberHistory(oSource).deceased.Clone;
  note := TFhirFamilyMemberHistory(oSource).note.Clone;
  if (TFhirFamilyMemberHistory(oSource).FConditionList = nil) then
  begin
    FConditionList.free;
    FConditionList := nil;
  end
  else
  begin
    if FConditionList = nil then
      FConditionList := TFhirFamilyMemberHistoryConditionList.Create;
    FConditionList.Assign(TFhirFamilyMemberHistory(oSource).FConditionList);
  end;
end;

procedure TFhirFamilyMemberHistory.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'relationship') Then
     list.add(self.link, 'relationship', FRelationship.Link);
  if (child_name = 'gender') Then
     list.add(self.link, 'gender', FGender.Link);
  if (child_name = 'born[x]') or (child_name = 'born') Then
     list.add(self.link, 'born[x]', FBorn.Link);
  if (child_name = 'age[x]') or (child_name = 'age') Then
     list.add(self.link, 'age[x]', FAge.Link);
  if (child_name = 'deceased[x]') or (child_name = 'deceased') Then
     list.add(self.link, 'deceased[x]', FDeceased.Link);
  if (child_name = 'note') Then
     list.add(self.link, 'note', FNote.Link);
  if (child_name = 'condition') Then
    list.addAll(self, 'condition', FConditionList);
end;

procedure TFhirFamilyMemberHistory.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'relationship', 'CodeableConcept', false, TFhirCodeableConcept, FRelationship.Link));{2}
  oList.add(TFHIRProperty.create(self, 'gender', 'code', false, TFHIREnum, FGender.Link));{1}
  oList.add(TFHIRProperty.create(self, 'born[x]', 'Period|date|string', false, TFhirType, FBorn.Link));{2}
  oList.add(TFHIRProperty.create(self, 'age[x]', 'Quantity|Range|string', false, TFhirType, FAge.Link));{2}
  oList.add(TFHIRProperty.create(self, 'deceased[x]', 'boolean|Quantity|Range|date|string', false, TFhirType, FDeceased.Link));{2}
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', false, TFhirAnnotation, FNote.Link));{2}
  oList.add(TFHIRProperty.create(self, 'condition', '', true, TFhirFamilyMemberHistoryCondition, FConditionList.Link)){3};
end;

function TFhirFamilyMemberHistory.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirHistoryStatusEnum, CODES_TFhirHistoryStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'relationship') then
  begin
    Relationship := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'gender') then
  begin
    GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, propValue);
    result := propValue
  end
  else if (isMatchingName(propName, 'born', ['Period', 'Date', 'String'])) then
  begin
    Born := propValue as TFhirType{4};
    result := propValue;
  end
  else if (isMatchingName(propName, 'age', ['Quantity', 'Range', 'String'])) then
  begin
    Age := propValue as TFhirType{4};
    result := propValue;
  end
  else if (isMatchingName(propName, 'deceased', ['Boolean', 'Quantity', 'Range', 'Date', 'String'])) then
  begin
    Deceased := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    Note := propValue as TFhirAnnotation{4b};
    result := propValue;
  end
  else if (propName = 'condition') then
  begin
    ConditionList.add(propValue as TFhirFamilyMemberHistoryCondition){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirFamilyMemberHistory.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'condition') then ConditionList.insertItem(index, propValue as TFhirFamilyMemberHistoryCondition){2a}
  else inherited;
end;

function TFhirFamilyMemberHistory.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'relationship') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'born', ['Period', 'Date', 'String'])) then raise EFHIRException.create('Cannot make property Born'){4x}
  else if (isMatchingName(propName, 'age', ['Quantity', 'Range', 'String'])) then raise EFHIRException.create('Cannot make property Age'){4x}
  else if (isMatchingName(propName, 'deceased', ['Boolean', 'Quantity', 'Range', 'Date', 'String'])) then raise EFHIRException.create('Cannot make property Deceased'){4x}
  else if (propName = 'note') then result := TFhirAnnotation.create(){4b}
  else if (propName = 'condition') then result := ConditionList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirFamilyMemberHistory.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'relationship') then result := 'CodeableConcept'
  else if (propName = 'gender') then result := 'code'
  else if (propName = 'born[x]') then result := 'Period|date|string'
  else if (propName = 'age[x]') then result := 'Quantity|Range|string'
  else if (propName = 'deceased[x]') then result := 'boolean|Quantity|Range|date|string'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'condition') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirFamilyMemberHistory.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'relationship') then RelationshipElement := nil
  else if (propName = 'gender') then GenderElement := nil
  else if (isMatchingName(propName, 'born', ['Period', 'Date', 'String'])) then BornElement := nil{4x}
  else if (isMatchingName(propName, 'age', ['Quantity', 'Range', 'String'])) then AgeElement := nil{4x}
  else if (isMatchingName(propName, 'deceased', ['Boolean', 'Quantity', 'Range', 'Date', 'String'])) then DeceasedElement := nil{4x}
  else if (propName = 'note') then NoteElement := nil
  else if (propName = 'condition') then deletePropertyValue('condition', ConditionList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirFamilyMemberHistory.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirHistoryStatusEnum, CODES_TFhirHistoryStatusEnum, new){4}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'relationship') then RelationshipElement := new as TFhirCodeableConcept{4}
  else if (propName = 'gender') then GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, new){4}
  else if (isMatchingName(propName, 'born', ['Period', 'Date', 'String'])) then BornElement := new as TFhirType{4x}
  else if (isMatchingName(propName, 'age', ['Quantity', 'Range', 'String'])) then AgeElement := new as TFhirType{4x}
  else if (isMatchingName(propName, 'deceased', ['Boolean', 'Quantity', 'Range', 'Date', 'String'])) then DeceasedElement := new as TFhirType{4x}
  else if (propName = 'note') then NoteElement := new as TFhirAnnotation{4}
  else if (propName = 'condition') then replacePropertyValue('condition', ConditionList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirFamilyMemberHistory.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'condition') then ConditionList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirFamilyMemberHistory.fhirType : string;
begin
  result := 'FamilyMemberHistory';
end;

function TFhirFamilyMemberHistory.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FPatient) and isEmptyProp(FDate) and isEmptyProp(FStatus) and isEmptyProp(FName) and isEmptyProp(FRelationship) and isEmptyProp(FGender) and isEmptyProp(FBorn) and isEmptyProp(FAge) and isEmptyProp(FDeceased) and isEmptyProp(FNote) and isEmptyProp(FconditionList);
end;

function TFhirFamilyMemberHistory.equals(other : TObject) : boolean;
var
  o : TFhirFamilyMemberHistory;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirFamilyMemberHistory)) then
    result := false
  else
  begin
    o := TFhirFamilyMemberHistory(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(patientElement, o.patientElement, true) and
      compareDeep(dateElement, o.dateElement, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(nameElement, o.nameElement, true) and compareDeep(relationshipElement, o.relationshipElement, true) and
      compareDeep(genderElement, o.genderElement, true) and compareDeep(bornElement, o.bornElement, true) and
      compareDeep(ageElement, o.ageElement, true) and compareDeep(deceasedElement, o.deceasedElement, true) and
      compareDeep(noteElement, o.noteElement, true) and compareDeep(conditionList, o.conditionList, true);
  end;
end;

function TFhirFamilyMemberHistory.Link : TFhirFamilyMemberHistory;
begin
  result := TFhirFamilyMemberHistory(inherited Link);
end;

function TFhirFamilyMemberHistory.Clone : TFhirFamilyMemberHistory;
begin
  result := TFhirFamilyMemberHistory(inherited Clone);
end;

procedure TFhirFamilyMemberHistory.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('patient');
  fields.add('date');
  fields.add('status');
  fields.add('name');
  fields.add('relationship');
  fields.add('gender');
  fields.add('born[x]');
  fields.add('age[x]');
  fields.add('deceased[x]');
  fields.add('note');
  fields.add('condition');
end;

{ TFhirFamilyMemberHistory }

Function TFhirFamilyMemberHistory.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirFamilyMemberHistory.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirFamilyMemberHistory.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Procedure TFhirFamilyMemberHistory.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirFamilyMemberHistory.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirFamilyMemberHistory.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirFamilyMemberHistory.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirFamilyMemberHistory.GetStatusST : TFhirHistoryStatusEnum;
begin
  if FStatus = nil then
    result := TFhirHistoryStatusEnum(0)
  else
    result := TFhirHistoryStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirHistoryStatusEnum, FStatus.value));
end;

Procedure TFhirFamilyMemberHistory.SetStatusST(value : TFhirHistoryStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirHistoryStatusEnum[value], CODES_TFhirHistoryStatusEnum[value]);
end;

Procedure TFhirFamilyMemberHistory.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirFamilyMemberHistory.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirFamilyMemberHistory.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirFamilyMemberHistory.SetRelationship(value : TFhirCodeableConcept);
begin
  FRelationship.free;
  FRelationship := value;
end;

Procedure TFhirFamilyMemberHistory.SetGender(value : TFhirEnum);
begin
  FGender.free;
  FGender := value;
end;

Function TFhirFamilyMemberHistory.GetGenderST : TFhirAdministrativeGenderEnum;
begin
  if FGender = nil then
    result := TFhirAdministrativeGenderEnum(0)
  else
    result := TFhirAdministrativeGenderEnum(StringArrayIndexOfSensitive(CODES_TFhirAdministrativeGenderEnum, FGender.value));
end;

Procedure TFhirFamilyMemberHistory.SetGenderST(value : TFhirAdministrativeGenderEnum);
begin
  if ord(value) = 0 then
    GenderElement := nil
  else
    GenderElement := TFhirEnum.create(SYSTEMS_TFhirAdministrativeGenderEnum[value], CODES_TFhirAdministrativeGenderEnum[value]);
end;

Procedure TFhirFamilyMemberHistory.SetBorn(value : TFhirType);
begin
  FBorn.free;
  FBorn := value;
end;

Procedure TFhirFamilyMemberHistory.SetAge(value : TFhirType);
begin
  FAge.free;
  FAge := value;
end;

Procedure TFhirFamilyMemberHistory.SetDeceased(value : TFhirType);
begin
  FDeceased.free;
  FDeceased := value;
end;

Procedure TFhirFamilyMemberHistory.SetNote(value : TFhirAnnotation);
begin
  FNote.free;
  FNote := value;
end;

Function TFhirFamilyMemberHistory.GetConditionList : TFhirFamilyMemberHistoryConditionList;
begin
  if FConditionList = nil then
    FConditionList := TFhirFamilyMemberHistoryConditionList.Create;
  result := FConditionList;
end;

Function TFhirFamilyMemberHistory.GetHasConditionList : boolean;
begin
  result := (FConditionList <> nil) and (FConditionList.count > 0);
end;

function TFhirFamilyMemberHistory.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FRelationship.sizeInBytes);
  inc(result, FGender.sizeInBytes);
  inc(result, FBorn.sizeInBytes);
  inc(result, FAge.sizeInBytes);
  inc(result, FDeceased.sizeInBytes);
  inc(result, FNote.sizeInBytes);
  inc(result, FconditionList.sizeInBytes);
end;

{ TFhirFamilyMemberHistoryListEnumerator }

Constructor TFhirFamilyMemberHistoryListEnumerator.Create(list : TFhirFamilyMemberHistoryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirFamilyMemberHistoryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirFamilyMemberHistoryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirFamilyMemberHistoryListEnumerator.GetCurrent : TFhirFamilyMemberHistory;
begin
  Result := FList[FIndex];
end;

function TFhirFamilyMemberHistoryListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirFamilyMemberHistoryList }
procedure TFhirFamilyMemberHistoryList.AddItem(value: TFhirFamilyMemberHistory);
begin
  assert(value.ClassName = 'TFhirFamilyMemberHistory', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirFamilyMemberHistory');
  add(value);
end;

function TFhirFamilyMemberHistoryList.Append: TFhirFamilyMemberHistory;
begin
  result := TFhirFamilyMemberHistory.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirFamilyMemberHistoryList.ClearItems;
begin
  Clear;
end;

function TFhirFamilyMemberHistoryList.GetEnumerator : TFhirFamilyMemberHistoryListEnumerator;
begin
  result := TFhirFamilyMemberHistoryListEnumerator.Create(self.link);
end;

function TFhirFamilyMemberHistoryList.Clone: TFhirFamilyMemberHistoryList;
begin
  result := TFhirFamilyMemberHistoryList(inherited Clone);
end;

function TFhirFamilyMemberHistoryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirFamilyMemberHistoryList.GetItemN(index: Integer): TFhirFamilyMemberHistory;
begin
  result := TFhirFamilyMemberHistory(ObjectByIndex[index]);
end;

function TFhirFamilyMemberHistoryList.ItemClass: TFslObjectClass;
begin
  result := TFhirFamilyMemberHistory;
end;
function TFhirFamilyMemberHistoryList.IndexOf(value: TFhirFamilyMemberHistory): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirFamilyMemberHistoryList.Insert(index: Integer): TFhirFamilyMemberHistory;
begin
  result := TFhirFamilyMemberHistory.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirFamilyMemberHistoryList.InsertItem(index: Integer; value: TFhirFamilyMemberHistory);
begin
  assert(value is TFhirFamilyMemberHistory);
  Inherited Insert(index, value);
end;

function TFhirFamilyMemberHistoryList.Item(index: Integer): TFhirFamilyMemberHistory;
begin
  result := TFhirFamilyMemberHistory(ObjectByIndex[index]);
end;

function TFhirFamilyMemberHistoryList.Link: TFhirFamilyMemberHistoryList;
begin
  result := TFhirFamilyMemberHistoryList(inherited Link);
end;

procedure TFhirFamilyMemberHistoryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirFamilyMemberHistoryList.SetItemByIndex(index: Integer; value: TFhirFamilyMemberHistory);
begin
  assert(value is TFhirFamilyMemberHistory);
  FhirFamilyMemberHistories[index] := value;
end;

procedure TFhirFamilyMemberHistoryList.SetItemN(index: Integer; value: TFhirFamilyMemberHistory);
begin
  assert(value is TFhirFamilyMemberHistory);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_FAMILYMEMBERHISTORY}

{$IFDEF FHIR_FLAG}

{ TFhirFlag }

constructor TFhirFlag.Create;
begin
  inherited;
end;

destructor TFhirFlag.Destroy;
begin
  FIdentifierList.Free;
  FCategory.free;
  FStatus.free;
  FPeriod.free;
  FSubject.free;
  FEncounter.free;
  FAuthor.free;
  FCode.free;
  inherited;
end;

function TFhirFlag.GetResourceType : TFhirResourceType;
begin
  result := frtFlag;
end;

procedure TFhirFlag.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirFlag(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirFlag(oSource).FIdentifierList);
  end;
  category := TFhirFlag(oSource).category.Clone;
  FStatus := TFhirFlag(oSource).FStatus.Link;
  period := TFhirFlag(oSource).period.Clone;
  subject := TFhirFlag(oSource).subject.Clone;
  encounter := TFhirFlag(oSource).encounter.Clone;
  author := TFhirFlag(oSource).author.Clone;
  code := TFhirFlag(oSource).code.Clone;
end;

procedure TFhirFlag.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
end;

procedure TFhirFlag.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Location|Group|Organization|Practitioner)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference(Encounter)', false, TFhirReference{TFhirEncounter}, FEncounter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'author', 'Reference(Device|Organization|Patient|Practitioner)', false, TFhirReference{Resource}, FAuthor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
end;

function TFhirFlag.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFlagStatusEnum, CODES_TFhirFlagStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference{TFhirEncounter}{4b};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirFlag.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else inherited;
end;

function TFhirFlag.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'period') then result := TFhirPeriod.create(){4b}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'encounter') then result := TFhirReference{TFhirEncounter}.create(){4b}
  else if (propName = 'author') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirFlag.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'code') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirFlag.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'author') then AuthorElement := nil
  else if (propName = 'code') then CodeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirFlag.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFlagStatusEnum, CODES_TFhirFlagStatusEnum, new){4}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference{TFhirEncounter}{4}
  else if (propName = 'author') then AuthorElement := new as TFhirReference{Resource}{4}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirFlag.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirFlag.fhirType : string;
begin
  result := 'Flag';
end;

function TFhirFlag.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FCategory) and isEmptyProp(FStatus) and isEmptyProp(FPeriod) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FAuthor) and isEmptyProp(FCode);
end;

function TFhirFlag.equals(other : TObject) : boolean;
var
  o : TFhirFlag;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirFlag)) then
    result := false
  else
  begin
    o := TFhirFlag(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(categoryElement, o.categoryElement, true) and
      compareDeep(statusElement, o.statusElement, true) and compareDeep(periodElement, o.periodElement, true) and
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(encounterElement, o.encounterElement, true) and
      compareDeep(authorElement, o.authorElement, true) and compareDeep(codeElement, o.codeElement, true);
  end;
end;

function TFhirFlag.Link : TFhirFlag;
begin
  result := TFhirFlag(inherited Link);
end;

function TFhirFlag.Clone : TFhirFlag;
begin
  result := TFhirFlag(inherited Clone);
end;

procedure TFhirFlag.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('category');
  fields.add('status');
  fields.add('period');
  fields.add('subject');
  fields.add('encounter');
  fields.add('author');
  fields.add('code');
end;

{ TFhirFlag }

Function TFhirFlag.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirFlag.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirFlag.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirFlag.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirFlag.GetStatusST : TFhirFlagStatusEnum;
begin
  if FStatus = nil then
    result := TFhirFlagStatusEnum(0)
  else
    result := TFhirFlagStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirFlagStatusEnum, FStatus.value));
end;

Procedure TFhirFlag.SetStatusST(value : TFhirFlagStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFlagStatusEnum[value], CODES_TFhirFlagStatusEnum[value]);
end;

Procedure TFhirFlag.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Procedure TFhirFlag.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirFlag.SetEncounter(value : TFhirReference{TFhirEncounter});
begin
  FEncounter.free;
  FEncounter := value;
end;

Procedure TFhirFlag.SetAuthor(value : TFhirReference{Resource});
begin
  FAuthor.free;
  FAuthor := value;
end;

Procedure TFhirFlag.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

function TFhirFlag.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FAuthor.sizeInBytes);
  inc(result, FCode.sizeInBytes);
end;

{ TFhirFlagListEnumerator }

Constructor TFhirFlagListEnumerator.Create(list : TFhirFlagList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirFlagListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirFlagListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirFlagListEnumerator.GetCurrent : TFhirFlag;
begin
  Result := FList[FIndex];
end;

function TFhirFlagListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirFlagList }
procedure TFhirFlagList.AddItem(value: TFhirFlag);
begin
  assert(value.ClassName = 'TFhirFlag', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirFlag');
  add(value);
end;

function TFhirFlagList.Append: TFhirFlag;
begin
  result := TFhirFlag.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirFlagList.ClearItems;
begin
  Clear;
end;

function TFhirFlagList.GetEnumerator : TFhirFlagListEnumerator;
begin
  result := TFhirFlagListEnumerator.Create(self.link);
end;

function TFhirFlagList.Clone: TFhirFlagList;
begin
  result := TFhirFlagList(inherited Clone);
end;

function TFhirFlagList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirFlagList.GetItemN(index: Integer): TFhirFlag;
begin
  result := TFhirFlag(ObjectByIndex[index]);
end;

function TFhirFlagList.ItemClass: TFslObjectClass;
begin
  result := TFhirFlag;
end;
function TFhirFlagList.IndexOf(value: TFhirFlag): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirFlagList.Insert(index: Integer): TFhirFlag;
begin
  result := TFhirFlag.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirFlagList.InsertItem(index: Integer; value: TFhirFlag);
begin
  assert(value is TFhirFlag);
  Inherited Insert(index, value);
end;

function TFhirFlagList.Item(index: Integer): TFhirFlag;
begin
  result := TFhirFlag(ObjectByIndex[index]);
end;

function TFhirFlagList.Link: TFhirFlagList;
begin
  result := TFhirFlagList(inherited Link);
end;

procedure TFhirFlagList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirFlagList.SetItemByIndex(index: Integer; value: TFhirFlag);
begin
  assert(value is TFhirFlag);
  FhirFlags[index] := value;
end;

procedure TFhirFlagList.SetItemN(index: Integer; value: TFhirFlag);
begin
  assert(value is TFhirFlag);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_FLAG}

{$IFDEF FHIR_GOAL}

{ TFhirGoalOutcome }

constructor TFhirGoalOutcome.Create;
begin
  inherited;
end;

destructor TFhirGoalOutcome.Destroy;
begin
  FResult.free;
  inherited;
end;

procedure TFhirGoalOutcome.Assign(oSource : TFslObject);
begin
  inherited;
  result := TFhirGoalOutcome(oSource).result.Clone;
end;

procedure TFhirGoalOutcome.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'result[x]') or (child_name = 'result') Then
     list.add(self.link, 'result[x]', FResult.Link);
end;

procedure TFhirGoalOutcome.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'result[x]', 'CodeableConcept|Reference(Observation)', false, TFhirType, FResult.Link));{2}
end;

function TFhirGoalOutcome.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'result', ['CodeableConcept', 'Reference'])) then
  begin
    Result := propValue as TFhirType{4};
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirGoalOutcome.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirGoalOutcome.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'result', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Result'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirGoalOutcome.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'result[x]') then result := 'CodeableConcept|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirGoalOutcome.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'result', ['CodeableConcept', 'Reference'])) then ResultElement := nil{4x}
  else
  inherited deleteProperty(propName, value);
end;

procedure TFhirGoalOutcome.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'result', ['CodeableConcept', 'Reference'])) then ResultElement := new as TFhirType{4x}
  else
  inherited replaceProperty(propName, existing, new);
end;

procedure TFhirGoalOutcome.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirGoalOutcome.fhirType : string;
begin
  result := 'outcome';
end;

function TFhirGoalOutcome.Link : TFhirGoalOutcome;
begin
  result := TFhirGoalOutcome(inherited Link);
end;

function TFhirGoalOutcome.Clone : TFhirGoalOutcome;
begin
  result := TFhirGoalOutcome(inherited Clone);
end;

function TFhirGoalOutcome.equals(other : TObject) : boolean;
var
  o : TFhirGoalOutcome;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirGoalOutcome)) then
    result := false
  else
  begin
    o := TFhirGoalOutcome(other);
    result := compareDeep(resultElement, o.resultElement, true);
  end;
end;

function TFhirGoalOutcome.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FResult);
end;

procedure TFhirGoalOutcome.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('result[x]');
end;

{ TFhirGoalOutcome }

Procedure TFhirGoalOutcome.SetResult(value : TFhirType);
begin
  FResult.free;
  FResult := value;
end;

function TFhirGoalOutcome.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FResult.sizeInBytes);
end;

{ TFhirGoalOutcomeListEnumerator }

Constructor TFhirGoalOutcomeListEnumerator.Create(list : TFhirGoalOutcomeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirGoalOutcomeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirGoalOutcomeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirGoalOutcomeListEnumerator.GetCurrent : TFhirGoalOutcome;
begin
  Result := FList[FIndex];
end;

function TFhirGoalOutcomeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirGoalOutcomeList }
procedure TFhirGoalOutcomeList.AddItem(value: TFhirGoalOutcome);
begin
  assert(value.ClassName = 'TFhirGoalOutcome', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirGoalOutcome');
  add(value);
end;

function TFhirGoalOutcomeList.Append: TFhirGoalOutcome;
begin
  result := TFhirGoalOutcome.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGoalOutcomeList.ClearItems;
begin
  Clear;
end;

function TFhirGoalOutcomeList.GetEnumerator : TFhirGoalOutcomeListEnumerator;
begin
  result := TFhirGoalOutcomeListEnumerator.Create(self.link);
end;

function TFhirGoalOutcomeList.Clone: TFhirGoalOutcomeList;
begin
  result := TFhirGoalOutcomeList(inherited Clone);
end;

function TFhirGoalOutcomeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirGoalOutcomeList.GetItemN(index: Integer): TFhirGoalOutcome;
begin
  result := TFhirGoalOutcome(ObjectByIndex[index]);
end;

function TFhirGoalOutcomeList.ItemClass: TFslObjectClass;
begin
  result := TFhirGoalOutcome;
end;
function TFhirGoalOutcomeList.IndexOf(value: TFhirGoalOutcome): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirGoalOutcomeList.Insert(index: Integer): TFhirGoalOutcome;
begin
  result := TFhirGoalOutcome.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGoalOutcomeList.InsertItem(index: Integer; value: TFhirGoalOutcome);
begin
  assert(value is TFhirGoalOutcome);
  Inherited Insert(index, value);
end;

function TFhirGoalOutcomeList.Item(index: Integer): TFhirGoalOutcome;
begin
  result := TFhirGoalOutcome(ObjectByIndex[index]);
end;

function TFhirGoalOutcomeList.Link: TFhirGoalOutcomeList;
begin
  result := TFhirGoalOutcomeList(inherited Link);
end;

procedure TFhirGoalOutcomeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirGoalOutcomeList.SetItemByIndex(index: Integer; value: TFhirGoalOutcome);
begin
  assert(value is TFhirGoalOutcome);
  FhirGoalOutcomes[index] := value;
end;

procedure TFhirGoalOutcomeList.SetItemN(index: Integer; value: TFhirGoalOutcome);
begin
  assert(value is TFhirGoalOutcome);
  ObjectByIndex[index] := value;
end;

{ TFhirGoal }

constructor TFhirGoal.Create;
begin
  inherited;
end;

destructor TFhirGoal.Destroy;
begin
  FIdentifierList.Free;
  FSubject.free;
  FStart.free;
  FTarget.free;
  FCategoryList.Free;
  FDescription.free;
  FStatus.free;
  FStatusDate.free;
  FStatusReason.free;
  FAuthor.free;
  FPriority.free;
  FAddressesList.Free;
  FNoteList.Free;
  FOutcomeList.Free;
  inherited;
end;

function TFhirGoal.GetResourceType : TFhirResourceType;
begin
  result := frtGoal;
end;

procedure TFhirGoal.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirGoal(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirGoal(oSource).FIdentifierList);
  end;
  subject := TFhirGoal(oSource).subject.Clone;
  start := TFhirGoal(oSource).start.Clone;
  target := TFhirGoal(oSource).target.Clone;
  if (TFhirGoal(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirGoal(oSource).FCategoryList);
  end;
  descriptionElement := TFhirGoal(oSource).descriptionElement.Clone;
  FStatus := TFhirGoal(oSource).FStatus.Link;
  statusDateElement := TFhirGoal(oSource).statusDateElement.Clone;
  statusReason := TFhirGoal(oSource).statusReason.Clone;
  author := TFhirGoal(oSource).author.Clone;
  priority := TFhirGoal(oSource).priority.Clone;
  if (TFhirGoal(oSource).FAddressesList = nil) then
  begin
    FAddressesList.free;
    FAddressesList := nil;
  end
  else
  begin
    if FAddressesList = nil then
      FAddressesList := TFhirReferenceList{Resource}.Create;
    FAddressesList.Assign(TFhirGoal(oSource).FAddressesList);
  end;
  if (TFhirGoal(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirGoal(oSource).FNoteList);
  end;
  if (TFhirGoal(oSource).FOutcomeList = nil) then
  begin
    FOutcomeList.free;
    FOutcomeList := nil;
  end
  else
  begin
    if FOutcomeList = nil then
      FOutcomeList := TFhirGoalOutcomeList.Create;
    FOutcomeList.Assign(TFhirGoal(oSource).FOutcomeList);
  end;
end;

procedure TFhirGoal.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'start[x]') or (child_name = 'start') Then
     list.add(self.link, 'start[x]', FStart.Link);
  if (child_name = 'target[x]') or (child_name = 'target') Then
     list.add(self.link, 'target[x]', FTarget.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusDate') Then
     list.add(self.link, 'statusDate', FStatusDate.Link);
  if (child_name = 'statusReason') Then
     list.add(self.link, 'statusReason', FStatusReason.Link);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'addresses') Then
    list.addAll(self, 'addresses', FAddressesList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'outcome') Then
    list.addAll(self, 'outcome', FOutcomeList);
end;

procedure TFhirGoal.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Group|Organization)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'start[x]', 'date|CodeableConcept', false, TFhirType, FStart.Link));{2}
  oList.add(TFHIRProperty.create(self, 'target[x]', 'date|Quantity', false, TFhirType, FTarget.Link));{2}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'statusDate', 'date', false, TFhirDate, FStatusDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'statusReason', 'CodeableConcept', false, TFhirCodeableConcept, FStatusReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'author', 'Reference(Patient|Practitioner|RelatedPerson)', false, TFhirReference{Resource}, FAuthor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'priority', 'CodeableConcept', false, TFhirCodeableConcept, FPriority.Link));{2}
  oList.add(TFHIRProperty.create(self, 'addresses', 'Reference(Condition|Observation|MedicationStatement|NutritionOrder|ProcedureRequest|RiskAssessment)', true, TFhirReference{Resource}, FAddressesList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'outcome', '', true, TFhirGoalOutcome, FOutcomeList.Link)){3};
end;

function TFhirGoal.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'start', ['Date', 'CodeableConcept'])) then
  begin
    Start := propValue as TFhirType{4};
    result := propValue;
  end
  else if (isMatchingName(propName, 'target', ['Date', 'Quantity'])) then
  begin
    Target := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirGoalStatusEnum, CODES_TFhirGoalStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'statusDate') then
  begin
    StatusDateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'statusReason') then
  begin
    StatusReason := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    Priority := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'addresses') then
  begin
    AddressesList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    OutcomeList.add(propValue as TFhirGoalOutcome){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirGoal.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'addresses') then AddressesList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else if (propName = 'outcome') then OutcomeList.insertItem(index, propValue as TFhirGoalOutcome){2a}
  else inherited;
end;

function TFhirGoal.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (isMatchingName(propName, 'start', ['Date', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property Start'){4x}
  else if (isMatchingName(propName, 'target', ['Date', 'Quantity'])) then raise EFHIRException.create('Cannot make property Target'){4x}
  else if (propName = 'category') then result := CategoryList.new(){2}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'statusDate') then result := TFhirDate.create() {5b}
  else if (propName = 'statusReason') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'author') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'priority') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'addresses') then result := AddressesList.new(){2}
  else if (propName = 'note') then result := NoteList.new(){2}
  else if (propName = 'outcome') then result := OutcomeList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirGoal.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'start[x]') then result := 'date|CodeableConcept'
  else if (propName = 'target[x]') then result := 'date|Quantity'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'statusDate') then result := 'date'
  else if (propName = 'statusReason') then result := 'CodeableConcept'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'priority') then result := 'CodeableConcept'
  else if (propName = 'addresses') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'outcome') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirGoal.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'subject') then SubjectElement := nil
  else if (isMatchingName(propName, 'start', ['Date', 'CodeableConcept'])) then StartElement := nil{4x}
  else if (isMatchingName(propName, 'target', ['Date', 'Quantity'])) then TargetElement := nil{4x}
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value) {2}
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusDate') then StatusDateElement := nil
  else if (propName = 'statusReason') then StatusReasonElement := nil
  else if (propName = 'author') then AuthorElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'addresses') then deletePropertyValue('addresses', AddressesList, value) {2}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else if (propName = 'outcome') then deletePropertyValue('outcome', OutcomeList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirGoal.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (isMatchingName(propName, 'start', ['Date', 'CodeableConcept'])) then StartElement := new as TFhirType{4x}
  else if (isMatchingName(propName, 'target', ['Date', 'Quantity'])) then TargetElement := new as TFhirType{4x}
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new) {2}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirGoalStatusEnum, CODES_TFhirGoalStatusEnum, new){4}
  else if (propName = 'statusDate') then StatusDateElement := asDate(new){5b}
  else if (propName = 'statusReason') then StatusReasonElement := new as TFhirCodeableConcept{4}
  else if (propName = 'author') then AuthorElement := new as TFhirReference{Resource}{4}
  else if (propName = 'priority') then PriorityElement := new as TFhirCodeableConcept{4}
  else if (propName = 'addresses') then replacePropertyValue('addresses', AddressesList, existing, new) {2}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else if (propName = 'outcome') then replacePropertyValue('outcome', OutcomeList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirGoal.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'category') then CategoryList.move(source, destination){2a}
  else if (propName = 'addresses') then AddressesList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else if (propName = 'outcome') then OutcomeList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirGoal.fhirType : string;
begin
  result := 'Goal';
end;

function TFhirGoal.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FSubject) and isEmptyProp(FStart) and isEmptyProp(FTarget) and isEmptyProp(FcategoryList) and isEmptyProp(FDescription) and isEmptyProp(FStatus) and isEmptyProp(FStatusDate) and isEmptyProp(FStatusReason) and isEmptyProp(FAuthor) and isEmptyProp(FPriority) and isEmptyProp(FaddressesList) and isEmptyProp(FnoteList) and isEmptyProp(FoutcomeList);
end;

function TFhirGoal.equals(other : TObject) : boolean;
var
  o : TFhirGoal;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirGoal)) then
    result := false
  else
  begin
    o := TFhirGoal(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(subjectElement, o.subjectElement, true) and
      compareDeep(startElement, o.startElement, true) and compareDeep(targetElement, o.targetElement, true) and
      compareDeep(categoryList, o.categoryList, true) and compareDeep(descriptionElement, o.descriptionElement, true) and
      compareDeep(statusElement, o.statusElement, true) and compareDeep(statusDateElement, o.statusDateElement, true) and
      compareDeep(statusReasonElement, o.statusReasonElement, true) and compareDeep(authorElement, o.authorElement, true) and
      compareDeep(priorityElement, o.priorityElement, true) and compareDeep(addressesList, o.addressesList, true) and
      compareDeep(noteList, o.noteList, true) and compareDeep(outcomeList, o.outcomeList, true);
  end;
end;

function TFhirGoal.Link : TFhirGoal;
begin
  result := TFhirGoal(inherited Link);
end;

function TFhirGoal.Clone : TFhirGoal;
begin
  result := TFhirGoal(inherited Clone);
end;

procedure TFhirGoal.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('subject');
  fields.add('start[x]');
  fields.add('target[x]');
  fields.add('category');
  fields.add('description');
  fields.add('status');
  fields.add('statusDate');
  fields.add('statusReason');
  fields.add('author');
  fields.add('priority');
  fields.add('addresses');
  fields.add('note');
  fields.add('outcome');
end;

{ TFhirGoal }

Function TFhirGoal.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirGoal.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirGoal.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirGoal.SetStart(value : TFhirType);
begin
  FStart.free;
  FStart := value;
end;

Procedure TFhirGoal.SetTarget(value : TFhirType);
begin
  FTarget.free;
  FTarget := value;
end;

Function TFhirGoal.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

Function TFhirGoal.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

Procedure TFhirGoal.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirGoal.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirGoal.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirGoal.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirGoal.GetStatusST : TFhirGoalStatusEnum;
begin
  if FStatus = nil then
    result := TFhirGoalStatusEnum(0)
  else
    result := TFhirGoalStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirGoalStatusEnum, FStatus.value));
end;

Procedure TFhirGoal.SetStatusST(value : TFhirGoalStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirGoalStatusEnum[value], CODES_TFhirGoalStatusEnum[value]);
end;

Procedure TFhirGoal.SetStatusDate(value : TFhirDate);
begin
  FStatusDate.free;
  FStatusDate := value;
end;

Function TFhirGoal.GetStatusDateST : TFslDateTime;
begin
  if FStatusDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FStatusDate.value;
end;

Procedure TFhirGoal.SetStatusDateST(value : TFslDateTime);
begin
  if FStatusDate = nil then
    FStatusDate := TFhirDate.create;
  FStatusDate.value := value
end;

Procedure TFhirGoal.SetStatusReason(value : TFhirCodeableConcept);
begin
  FStatusReason.free;
  FStatusReason := value;
end;

Procedure TFhirGoal.SetAuthor(value : TFhirReference{Resource});
begin
  FAuthor.free;
  FAuthor := value;
end;

Procedure TFhirGoal.SetPriority(value : TFhirCodeableConcept);
begin
  FPriority.free;
  FPriority := value;
end;

Function TFhirGoal.GetAddressesList : TFhirReferenceList{Resource};
begin
  if FAddressesList = nil then
    FAddressesList := TFhirReferenceList{Resource}.Create;
  result := FAddressesList;
end;

Function TFhirGoal.GetHasAddressesList : boolean;
begin
  result := (FAddressesList <> nil) and (FAddressesList.count > 0);
end;

Function TFhirGoal.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirGoal.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

Function TFhirGoal.GetOutcomeList : TFhirGoalOutcomeList;
begin
  if FOutcomeList = nil then
    FOutcomeList := TFhirGoalOutcomeList.Create;
  result := FOutcomeList;
end;

Function TFhirGoal.GetHasOutcomeList : boolean;
begin
  result := (FOutcomeList <> nil) and (FOutcomeList.count > 0);
end;

function TFhirGoal.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FStart.sizeInBytes);
  inc(result, FTarget.sizeInBytes);
  inc(result, FcategoryList.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FStatusDate.sizeInBytes);
  inc(result, FStatusReason.sizeInBytes);
  inc(result, FAuthor.sizeInBytes);
  inc(result, FPriority.sizeInBytes);
  inc(result, FaddressesList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FoutcomeList.sizeInBytes);
end;

{ TFhirGoalListEnumerator }

Constructor TFhirGoalListEnumerator.Create(list : TFhirGoalList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirGoalListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirGoalListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirGoalListEnumerator.GetCurrent : TFhirGoal;
begin
  Result := FList[FIndex];
end;

function TFhirGoalListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirGoalList }
procedure TFhirGoalList.AddItem(value: TFhirGoal);
begin
  assert(value.ClassName = 'TFhirGoal', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirGoal');
  add(value);
end;

function TFhirGoalList.Append: TFhirGoal;
begin
  result := TFhirGoal.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGoalList.ClearItems;
begin
  Clear;
end;

function TFhirGoalList.GetEnumerator : TFhirGoalListEnumerator;
begin
  result := TFhirGoalListEnumerator.Create(self.link);
end;

function TFhirGoalList.Clone: TFhirGoalList;
begin
  result := TFhirGoalList(inherited Clone);
end;

function TFhirGoalList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirGoalList.GetItemN(index: Integer): TFhirGoal;
begin
  result := TFhirGoal(ObjectByIndex[index]);
end;

function TFhirGoalList.ItemClass: TFslObjectClass;
begin
  result := TFhirGoal;
end;
function TFhirGoalList.IndexOf(value: TFhirGoal): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirGoalList.Insert(index: Integer): TFhirGoal;
begin
  result := TFhirGoal.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGoalList.InsertItem(index: Integer; value: TFhirGoal);
begin
  assert(value is TFhirGoal);
  Inherited Insert(index, value);
end;

function TFhirGoalList.Item(index: Integer): TFhirGoal;
begin
  result := TFhirGoal(ObjectByIndex[index]);
end;

function TFhirGoalList.Link: TFhirGoalList;
begin
  result := TFhirGoalList(inherited Link);
end;

procedure TFhirGoalList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirGoalList.SetItemByIndex(index: Integer; value: TFhirGoal);
begin
  assert(value is TFhirGoal);
  FhirGoals[index] := value;
end;

procedure TFhirGoalList.SetItemN(index: Integer; value: TFhirGoal);
begin
  assert(value is TFhirGoal);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_GOAL}

{$IFDEF FHIR_IMAGINGOBJECTSELECTION}

{ TFhirImagingObjectSelectionStudy }

constructor TFhirImagingObjectSelectionStudy.Create;
begin
  inherited;
end;

destructor TFhirImagingObjectSelectionStudy.Destroy;
begin
  FUid.free;
  FUrl.free;
  FImagingStudy.free;
  FSeriesList.Free;
  inherited;
end;

procedure TFhirImagingObjectSelectionStudy.Assign(oSource : TFslObject);
begin
  inherited;
  uidElement := TFhirImagingObjectSelectionStudy(oSource).uidElement.Clone;
  urlElement := TFhirImagingObjectSelectionStudy(oSource).urlElement.Clone;
  imagingStudy := TFhirImagingObjectSelectionStudy(oSource).imagingStudy.Clone;
  if (TFhirImagingObjectSelectionStudy(oSource).FSeriesList = nil) then
  begin
    FSeriesList.free;
    FSeriesList := nil;
  end
  else
  begin
    if FSeriesList = nil then
      FSeriesList := TFhirImagingObjectSelectionStudySeriesList.Create;
    FSeriesList.Assign(TFhirImagingObjectSelectionStudy(oSource).FSeriesList);
  end;
end;

procedure TFhirImagingObjectSelectionStudy.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'uid') Then
     list.add(self.link, 'uid', FUid.Link);
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'imagingStudy') Then
     list.add(self.link, 'imagingStudy', FImagingStudy.Link);
  if (child_name = 'series') Then
    list.addAll(self, 'series', FSeriesList);
end;

procedure TFhirImagingObjectSelectionStudy.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'uid', 'oid', false, TFhirOid, FUid.Link));{2}
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));{2}
  oList.add(TFHIRProperty.create(self, 'imagingStudy', 'Reference(ImagingStudy)', false, TFhirReference{TFhirImagingStudy}, FImagingStudy.Link));{2}
  oList.add(TFHIRProperty.create(self, 'series', '', true, TFhirImagingObjectSelectionStudySeries, FSeriesList.Link)){3};
end;

function TFhirImagingObjectSelectionStudy.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'uid') then
  begin
    UidElement := asOid(propValue){5a};
    result := propValue;
  end
  else if (propName = 'url') then
  begin
    UrlElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'imagingStudy') then
  begin
    ImagingStudy := propValue as TFhirReference{TFhirImagingStudy}{4b};
    result := propValue;
  end
  else if (propName = 'series') then
  begin
    SeriesList.add(propValue as TFhirImagingObjectSelectionStudySeries){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImagingObjectSelectionStudy.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'series') then SeriesList.insertItem(index, propValue as TFhirImagingObjectSelectionStudySeries){2a}
  else inherited;
end;

function TFhirImagingObjectSelectionStudy.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'uid') then result := TFhirOid.create() {5b}
  else if (propName = 'url') then result := TFhirUri.create() {5b}
  else if (propName = 'imagingStudy') then result := TFhirReference{TFhirImagingStudy}.create(){4b}
  else if (propName = 'series') then result := SeriesList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImagingObjectSelectionStudy.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'uid') then result := 'oid'
  else if (propName = 'url') then result := 'uri'
  else if (propName = 'imagingStudy') then result := 'Reference'
  else if (propName = 'series') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImagingObjectSelectionStudy.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'uid') then UidElement := nil
  else if (propName = 'url') then UrlElement := nil
  else if (propName = 'imagingStudy') then ImagingStudyElement := nil
  else if (propName = 'series') then deletePropertyValue('series', SeriesList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImagingObjectSelectionStudy.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'uid') then UidElement := asOid(new){5b}
  else if (propName = 'url') then UrlElement := asUri(new){5b}
  else if (propName = 'imagingStudy') then ImagingStudyElement := new as TFhirReference{TFhirImagingStudy}{4}
  else if (propName = 'series') then replacePropertyValue('series', SeriesList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImagingObjectSelectionStudy.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'series') then SeriesList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImagingObjectSelectionStudy.fhirType : string;
begin
  result := 'study';
end;

function TFhirImagingObjectSelectionStudy.Link : TFhirImagingObjectSelectionStudy;
begin
  result := TFhirImagingObjectSelectionStudy(inherited Link);
end;

function TFhirImagingObjectSelectionStudy.Clone : TFhirImagingObjectSelectionStudy;
begin
  result := TFhirImagingObjectSelectionStudy(inherited Clone);
end;

function TFhirImagingObjectSelectionStudy.equals(other : TObject) : boolean;
var
  o : TFhirImagingObjectSelectionStudy;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImagingObjectSelectionStudy)) then
    result := false
  else
  begin
    o := TFhirImagingObjectSelectionStudy(other);
    result := compareDeep(uidElement, o.uidElement, true) and compareDeep(urlElement, o.urlElement, true) and
      compareDeep(imagingStudyElement, o.imagingStudyElement, true) and compareDeep(seriesList, o.seriesList, true);
  end;
end;

function TFhirImagingObjectSelectionStudy.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUid) and isEmptyProp(FUrl) and isEmptyProp(FImagingStudy) and isEmptyProp(FseriesList);
end;

procedure TFhirImagingObjectSelectionStudy.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('uid');
  fields.add('url');
  fields.add('imagingStudy');
  fields.add('series');
end;

{ TFhirImagingObjectSelectionStudy }

Procedure TFhirImagingObjectSelectionStudy.SetUid(value : TFhirOid);
begin
  FUid.free;
  FUid := value;
end;

Function TFhirImagingObjectSelectionStudy.GetUidST : String;
begin
  if FUid = nil then
    result := ''
  else
    result := FUid.value;
end;

Procedure TFhirImagingObjectSelectionStudy.SetUidST(value : String);
begin
  if value <> '' then
  begin
    if FUid = nil then
      FUid := TFhirOid.create;
    FUid.value := value
  end
  else if FUid <> nil then
    FUid.value := '';
end;

Procedure TFhirImagingObjectSelectionStudy.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirImagingObjectSelectionStudy.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

Procedure TFhirImagingObjectSelectionStudy.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

Procedure TFhirImagingObjectSelectionStudy.SetImagingStudy(value : TFhirReference{TFhirImagingStudy});
begin
  FImagingStudy.free;
  FImagingStudy := value;
end;

Function TFhirImagingObjectSelectionStudy.GetSeriesList : TFhirImagingObjectSelectionStudySeriesList;
begin
  if FSeriesList = nil then
    FSeriesList := TFhirImagingObjectSelectionStudySeriesList.Create;
  result := FSeriesList;
end;

Function TFhirImagingObjectSelectionStudy.GetHasSeriesList : boolean;
begin
  result := (FSeriesList <> nil) and (FSeriesList.count > 0);
end;

function TFhirImagingObjectSelectionStudy.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FUid.sizeInBytes);
  inc(result, FUrl.sizeInBytes);
  inc(result, FImagingStudy.sizeInBytes);
  inc(result, FseriesList.sizeInBytes);
end;

{ TFhirImagingObjectSelectionStudyListEnumerator }

Constructor TFhirImagingObjectSelectionStudyListEnumerator.Create(list : TFhirImagingObjectSelectionStudyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImagingObjectSelectionStudyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImagingObjectSelectionStudyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImagingObjectSelectionStudyListEnumerator.GetCurrent : TFhirImagingObjectSelectionStudy;
begin
  Result := FList[FIndex];
end;

function TFhirImagingObjectSelectionStudyListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImagingObjectSelectionStudyList }
procedure TFhirImagingObjectSelectionStudyList.AddItem(value: TFhirImagingObjectSelectionStudy);
begin
  assert(value.ClassName = 'TFhirImagingObjectSelectionStudy', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImagingObjectSelectionStudy');
  add(value);
end;

function TFhirImagingObjectSelectionStudyList.Append: TFhirImagingObjectSelectionStudy;
begin
  result := TFhirImagingObjectSelectionStudy.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingObjectSelectionStudyList.ClearItems;
begin
  Clear;
end;

function TFhirImagingObjectSelectionStudyList.GetEnumerator : TFhirImagingObjectSelectionStudyListEnumerator;
begin
  result := TFhirImagingObjectSelectionStudyListEnumerator.Create(self.link);
end;

function TFhirImagingObjectSelectionStudyList.Clone: TFhirImagingObjectSelectionStudyList;
begin
  result := TFhirImagingObjectSelectionStudyList(inherited Clone);
end;

function TFhirImagingObjectSelectionStudyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImagingObjectSelectionStudyList.GetItemN(index: Integer): TFhirImagingObjectSelectionStudy;
begin
  result := TFhirImagingObjectSelectionStudy(ObjectByIndex[index]);
end;

function TFhirImagingObjectSelectionStudyList.ItemClass: TFslObjectClass;
begin
  result := TFhirImagingObjectSelectionStudy;
end;
function TFhirImagingObjectSelectionStudyList.IndexOf(value: TFhirImagingObjectSelectionStudy): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImagingObjectSelectionStudyList.Insert(index: Integer): TFhirImagingObjectSelectionStudy;
begin
  result := TFhirImagingObjectSelectionStudy.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingObjectSelectionStudyList.InsertItem(index: Integer; value: TFhirImagingObjectSelectionStudy);
begin
  assert(value is TFhirImagingObjectSelectionStudy);
  Inherited Insert(index, value);
end;

function TFhirImagingObjectSelectionStudyList.Item(index: Integer): TFhirImagingObjectSelectionStudy;
begin
  result := TFhirImagingObjectSelectionStudy(ObjectByIndex[index]);
end;

function TFhirImagingObjectSelectionStudyList.Link: TFhirImagingObjectSelectionStudyList;
begin
  result := TFhirImagingObjectSelectionStudyList(inherited Link);
end;

procedure TFhirImagingObjectSelectionStudyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImagingObjectSelectionStudyList.SetItemByIndex(index: Integer; value: TFhirImagingObjectSelectionStudy);
begin
  assert(value is TFhirImagingObjectSelectionStudy);
  FhirImagingObjectSelectionStudies[index] := value;
end;

procedure TFhirImagingObjectSelectionStudyList.SetItemN(index: Integer; value: TFhirImagingObjectSelectionStudy);
begin
  assert(value is TFhirImagingObjectSelectionStudy);
  ObjectByIndex[index] := value;
end;

{ TFhirImagingObjectSelectionStudySeries }

constructor TFhirImagingObjectSelectionStudySeries.Create;
begin
  inherited;
end;

destructor TFhirImagingObjectSelectionStudySeries.Destroy;
begin
  FUid.free;
  FUrl.free;
  FInstanceList.Free;
  inherited;
end;

procedure TFhirImagingObjectSelectionStudySeries.Assign(oSource : TFslObject);
begin
  inherited;
  uidElement := TFhirImagingObjectSelectionStudySeries(oSource).uidElement.Clone;
  urlElement := TFhirImagingObjectSelectionStudySeries(oSource).urlElement.Clone;
  if (TFhirImagingObjectSelectionStudySeries(oSource).FInstanceList = nil) then
  begin
    FInstanceList.free;
    FInstanceList := nil;
  end
  else
  begin
    if FInstanceList = nil then
      FInstanceList := TFhirImagingObjectSelectionStudySeriesInstanceList.Create;
    FInstanceList.Assign(TFhirImagingObjectSelectionStudySeries(oSource).FInstanceList);
  end;
end;

procedure TFhirImagingObjectSelectionStudySeries.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'uid') Then
     list.add(self.link, 'uid', FUid.Link);
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'instance') Then
    list.addAll(self, 'instance', FInstanceList);
end;

procedure TFhirImagingObjectSelectionStudySeries.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'uid', 'oid', false, TFhirOid, FUid.Link));{2}
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));{2}
  oList.add(TFHIRProperty.create(self, 'instance', '', true, TFhirImagingObjectSelectionStudySeriesInstance, FInstanceList.Link)){3};
end;

function TFhirImagingObjectSelectionStudySeries.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'uid') then
  begin
    UidElement := asOid(propValue){5a};
    result := propValue;
  end
  else if (propName = 'url') then
  begin
    UrlElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'instance') then
  begin
    InstanceList.add(propValue as TFhirImagingObjectSelectionStudySeriesInstance){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImagingObjectSelectionStudySeries.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'instance') then InstanceList.insertItem(index, propValue as TFhirImagingObjectSelectionStudySeriesInstance){2a}
  else inherited;
end;

function TFhirImagingObjectSelectionStudySeries.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'uid') then result := TFhirOid.create() {5b}
  else if (propName = 'url') then result := TFhirUri.create() {5b}
  else if (propName = 'instance') then result := InstanceList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImagingObjectSelectionStudySeries.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'uid') then result := 'oid'
  else if (propName = 'url') then result := 'uri'
  else if (propName = 'instance') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImagingObjectSelectionStudySeries.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'uid') then UidElement := nil
  else if (propName = 'url') then UrlElement := nil
  else if (propName = 'instance') then deletePropertyValue('instance', InstanceList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImagingObjectSelectionStudySeries.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'uid') then UidElement := asOid(new){5b}
  else if (propName = 'url') then UrlElement := asUri(new){5b}
  else if (propName = 'instance') then replacePropertyValue('instance', InstanceList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImagingObjectSelectionStudySeries.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'instance') then InstanceList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImagingObjectSelectionStudySeries.fhirType : string;
begin
  result := 'series';
end;

function TFhirImagingObjectSelectionStudySeries.Link : TFhirImagingObjectSelectionStudySeries;
begin
  result := TFhirImagingObjectSelectionStudySeries(inherited Link);
end;

function TFhirImagingObjectSelectionStudySeries.Clone : TFhirImagingObjectSelectionStudySeries;
begin
  result := TFhirImagingObjectSelectionStudySeries(inherited Clone);
end;

function TFhirImagingObjectSelectionStudySeries.equals(other : TObject) : boolean;
var
  o : TFhirImagingObjectSelectionStudySeries;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImagingObjectSelectionStudySeries)) then
    result := false
  else
  begin
    o := TFhirImagingObjectSelectionStudySeries(other);
    result := compareDeep(uidElement, o.uidElement, true) and compareDeep(urlElement, o.urlElement, true) and
      compareDeep(instanceList, o.instanceList, true);
  end;
end;

function TFhirImagingObjectSelectionStudySeries.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUid) and isEmptyProp(FUrl) and isEmptyProp(FinstanceList);
end;

procedure TFhirImagingObjectSelectionStudySeries.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('uid');
  fields.add('url');
  fields.add('instance');
end;

{ TFhirImagingObjectSelectionStudySeries }

Procedure TFhirImagingObjectSelectionStudySeries.SetUid(value : TFhirOid);
begin
  FUid.free;
  FUid := value;
end;

Function TFhirImagingObjectSelectionStudySeries.GetUidST : String;
begin
  if FUid = nil then
    result := ''
  else
    result := FUid.value;
end;

Procedure TFhirImagingObjectSelectionStudySeries.SetUidST(value : String);
begin
  if value <> '' then
  begin
    if FUid = nil then
      FUid := TFhirOid.create;
    FUid.value := value
  end
  else if FUid <> nil then
    FUid.value := '';
end;

Procedure TFhirImagingObjectSelectionStudySeries.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirImagingObjectSelectionStudySeries.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

Procedure TFhirImagingObjectSelectionStudySeries.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

Function TFhirImagingObjectSelectionStudySeries.GetInstanceList : TFhirImagingObjectSelectionStudySeriesInstanceList;
begin
  if FInstanceList = nil then
    FInstanceList := TFhirImagingObjectSelectionStudySeriesInstanceList.Create;
  result := FInstanceList;
end;

Function TFhirImagingObjectSelectionStudySeries.GetHasInstanceList : boolean;
begin
  result := (FInstanceList <> nil) and (FInstanceList.count > 0);
end;

function TFhirImagingObjectSelectionStudySeries.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FUid.sizeInBytes);
  inc(result, FUrl.sizeInBytes);
  inc(result, FinstanceList.sizeInBytes);
end;

{ TFhirImagingObjectSelectionStudySeriesListEnumerator }

Constructor TFhirImagingObjectSelectionStudySeriesListEnumerator.Create(list : TFhirImagingObjectSelectionStudySeriesList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImagingObjectSelectionStudySeriesListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImagingObjectSelectionStudySeriesListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImagingObjectSelectionStudySeriesListEnumerator.GetCurrent : TFhirImagingObjectSelectionStudySeries;
begin
  Result := FList[FIndex];
end;

function TFhirImagingObjectSelectionStudySeriesListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImagingObjectSelectionStudySeriesList }
procedure TFhirImagingObjectSelectionStudySeriesList.AddItem(value: TFhirImagingObjectSelectionStudySeries);
begin
  assert(value.ClassName = 'TFhirImagingObjectSelectionStudySeries', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImagingObjectSelectionStudySeries');
  add(value);
end;

function TFhirImagingObjectSelectionStudySeriesList.Append: TFhirImagingObjectSelectionStudySeries;
begin
  result := TFhirImagingObjectSelectionStudySeries.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingObjectSelectionStudySeriesList.ClearItems;
begin
  Clear;
end;

function TFhirImagingObjectSelectionStudySeriesList.GetEnumerator : TFhirImagingObjectSelectionStudySeriesListEnumerator;
begin
  result := TFhirImagingObjectSelectionStudySeriesListEnumerator.Create(self.link);
end;

function TFhirImagingObjectSelectionStudySeriesList.Clone: TFhirImagingObjectSelectionStudySeriesList;
begin
  result := TFhirImagingObjectSelectionStudySeriesList(inherited Clone);
end;

function TFhirImagingObjectSelectionStudySeriesList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImagingObjectSelectionStudySeriesList.GetItemN(index: Integer): TFhirImagingObjectSelectionStudySeries;
begin
  result := TFhirImagingObjectSelectionStudySeries(ObjectByIndex[index]);
end;

function TFhirImagingObjectSelectionStudySeriesList.ItemClass: TFslObjectClass;
begin
  result := TFhirImagingObjectSelectionStudySeries;
end;
function TFhirImagingObjectSelectionStudySeriesList.IndexOf(value: TFhirImagingObjectSelectionStudySeries): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImagingObjectSelectionStudySeriesList.Insert(index: Integer): TFhirImagingObjectSelectionStudySeries;
begin
  result := TFhirImagingObjectSelectionStudySeries.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingObjectSelectionStudySeriesList.InsertItem(index: Integer; value: TFhirImagingObjectSelectionStudySeries);
begin
  assert(value is TFhirImagingObjectSelectionStudySeries);
  Inherited Insert(index, value);
end;

function TFhirImagingObjectSelectionStudySeriesList.Item(index: Integer): TFhirImagingObjectSelectionStudySeries;
begin
  result := TFhirImagingObjectSelectionStudySeries(ObjectByIndex[index]);
end;

function TFhirImagingObjectSelectionStudySeriesList.Link: TFhirImagingObjectSelectionStudySeriesList;
begin
  result := TFhirImagingObjectSelectionStudySeriesList(inherited Link);
end;

procedure TFhirImagingObjectSelectionStudySeriesList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImagingObjectSelectionStudySeriesList.SetItemByIndex(index: Integer; value: TFhirImagingObjectSelectionStudySeries);
begin
  assert(value is TFhirImagingObjectSelectionStudySeries);
  FhirImagingObjectSelectionStudySeries[index] := value;
end;

procedure TFhirImagingObjectSelectionStudySeriesList.SetItemN(index: Integer; value: TFhirImagingObjectSelectionStudySeries);
begin
  assert(value is TFhirImagingObjectSelectionStudySeries);
  ObjectByIndex[index] := value;
end;

{ TFhirImagingObjectSelectionStudySeriesInstance }

constructor TFhirImagingObjectSelectionStudySeriesInstance.Create;
begin
  inherited;
end;

destructor TFhirImagingObjectSelectionStudySeriesInstance.Destroy;
begin
  FSopClass.free;
  FUid.free;
  FUrl.free;
  FFramesList.Free;
  inherited;
end;

procedure TFhirImagingObjectSelectionStudySeriesInstance.Assign(oSource : TFslObject);
begin
  inherited;
  sopClassElement := TFhirImagingObjectSelectionStudySeriesInstance(oSource).sopClassElement.Clone;
  uidElement := TFhirImagingObjectSelectionStudySeriesInstance(oSource).uidElement.Clone;
  urlElement := TFhirImagingObjectSelectionStudySeriesInstance(oSource).urlElement.Clone;
  if (TFhirImagingObjectSelectionStudySeriesInstance(oSource).FFramesList = nil) then
  begin
    FFramesList.free;
    FFramesList := nil;
  end
  else
  begin
    if FFramesList = nil then
      FFramesList := TFhirImagingObjectSelectionStudySeriesInstanceFramesList.Create;
    FFramesList.Assign(TFhirImagingObjectSelectionStudySeriesInstance(oSource).FFramesList);
  end;
end;

procedure TFhirImagingObjectSelectionStudySeriesInstance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sopClass') Then
     list.add(self.link, 'sopClass', FSopClass.Link);
  if (child_name = 'uid') Then
     list.add(self.link, 'uid', FUid.Link);
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'frames') Then
    list.addAll(self, 'frames', FFramesList);
end;

procedure TFhirImagingObjectSelectionStudySeriesInstance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sopClass', 'oid', false, TFhirOid, FSopClass.Link));{2}
  oList.add(TFHIRProperty.create(self, 'uid', 'oid', false, TFhirOid, FUid.Link));{2}
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));{2}
  oList.add(TFHIRProperty.create(self, 'frames', '', true, TFhirImagingObjectSelectionStudySeriesInstanceFrames, FFramesList.Link)){3};
end;

function TFhirImagingObjectSelectionStudySeriesInstance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sopClass') then
  begin
    SopClassElement := asOid(propValue){5a};
    result := propValue;
  end
  else if (propName = 'uid') then
  begin
    UidElement := asOid(propValue){5a};
    result := propValue;
  end
  else if (propName = 'url') then
  begin
    UrlElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'frames') then
  begin
    FramesList.add(propValue as TFhirImagingObjectSelectionStudySeriesInstanceFrames){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImagingObjectSelectionStudySeriesInstance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'frames') then FramesList.insertItem(index, propValue as TFhirImagingObjectSelectionStudySeriesInstanceFrames){2a}
  else inherited;
end;

function TFhirImagingObjectSelectionStudySeriesInstance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sopClass') then result := TFhirOid.create() {5b}
  else if (propName = 'uid') then result := TFhirOid.create() {5b}
  else if (propName = 'url') then result := TFhirUri.create() {5b}
  else if (propName = 'frames') then result := FramesList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImagingObjectSelectionStudySeriesInstance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sopClass') then result := 'oid'
  else if (propName = 'uid') then result := 'oid'
  else if (propName = 'url') then result := 'uri'
  else if (propName = 'frames') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImagingObjectSelectionStudySeriesInstance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sopClass') then SopClassElement := nil
  else if (propName = 'uid') then UidElement := nil
  else if (propName = 'url') then UrlElement := nil
  else if (propName = 'frames') then deletePropertyValue('frames', FramesList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImagingObjectSelectionStudySeriesInstance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sopClass') then SopClassElement := asOid(new){5b}
  else if (propName = 'uid') then UidElement := asOid(new){5b}
  else if (propName = 'url') then UrlElement := asUri(new){5b}
  else if (propName = 'frames') then replacePropertyValue('frames', FramesList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImagingObjectSelectionStudySeriesInstance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'frames') then FramesList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImagingObjectSelectionStudySeriesInstance.fhirType : string;
begin
  result := 'instance';
end;

function TFhirImagingObjectSelectionStudySeriesInstance.Link : TFhirImagingObjectSelectionStudySeriesInstance;
begin
  result := TFhirImagingObjectSelectionStudySeriesInstance(inherited Link);
end;

function TFhirImagingObjectSelectionStudySeriesInstance.Clone : TFhirImagingObjectSelectionStudySeriesInstance;
begin
  result := TFhirImagingObjectSelectionStudySeriesInstance(inherited Clone);
end;

function TFhirImagingObjectSelectionStudySeriesInstance.equals(other : TObject) : boolean;
var
  o : TFhirImagingObjectSelectionStudySeriesInstance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImagingObjectSelectionStudySeriesInstance)) then
    result := false
  else
  begin
    o := TFhirImagingObjectSelectionStudySeriesInstance(other);
    result := compareDeep(sopClassElement, o.sopClassElement, true) and compareDeep(uidElement, o.uidElement, true) and
      compareDeep(urlElement, o.urlElement, true) and compareDeep(framesList, o.framesList, true);
  end;
end;

function TFhirImagingObjectSelectionStudySeriesInstance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSopClass) and isEmptyProp(FUid) and isEmptyProp(FUrl) and isEmptyProp(FframesList);
end;

procedure TFhirImagingObjectSelectionStudySeriesInstance.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sopClass');
  fields.add('uid');
  fields.add('url');
  fields.add('frames');
end;

{ TFhirImagingObjectSelectionStudySeriesInstance }

Procedure TFhirImagingObjectSelectionStudySeriesInstance.SetSopClass(value : TFhirOid);
begin
  FSopClass.free;
  FSopClass := value;
end;

Function TFhirImagingObjectSelectionStudySeriesInstance.GetSopClassST : String;
begin
  if FSopClass = nil then
    result := ''
  else
    result := FSopClass.value;
end;

Procedure TFhirImagingObjectSelectionStudySeriesInstance.SetSopClassST(value : String);
begin
  if value <> '' then
  begin
    if FSopClass = nil then
      FSopClass := TFhirOid.create;
    FSopClass.value := value
  end
  else if FSopClass <> nil then
    FSopClass.value := '';
end;

Procedure TFhirImagingObjectSelectionStudySeriesInstance.SetUid(value : TFhirOid);
begin
  FUid.free;
  FUid := value;
end;

Function TFhirImagingObjectSelectionStudySeriesInstance.GetUidST : String;
begin
  if FUid = nil then
    result := ''
  else
    result := FUid.value;
end;

Procedure TFhirImagingObjectSelectionStudySeriesInstance.SetUidST(value : String);
begin
  if value <> '' then
  begin
    if FUid = nil then
      FUid := TFhirOid.create;
    FUid.value := value
  end
  else if FUid <> nil then
    FUid.value := '';
end;

Procedure TFhirImagingObjectSelectionStudySeriesInstance.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirImagingObjectSelectionStudySeriesInstance.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

Procedure TFhirImagingObjectSelectionStudySeriesInstance.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

Function TFhirImagingObjectSelectionStudySeriesInstance.GetFramesList : TFhirImagingObjectSelectionStudySeriesInstanceFramesList;
begin
  if FFramesList = nil then
    FFramesList := TFhirImagingObjectSelectionStudySeriesInstanceFramesList.Create;
  result := FFramesList;
end;

Function TFhirImagingObjectSelectionStudySeriesInstance.GetHasFramesList : boolean;
begin
  result := (FFramesList <> nil) and (FFramesList.count > 0);
end;

function TFhirImagingObjectSelectionStudySeriesInstance.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSopClass.sizeInBytes);
  inc(result, FUid.sizeInBytes);
  inc(result, FUrl.sizeInBytes);
  inc(result, FframesList.sizeInBytes);
end;

{ TFhirImagingObjectSelectionStudySeriesInstanceListEnumerator }

Constructor TFhirImagingObjectSelectionStudySeriesInstanceListEnumerator.Create(list : TFhirImagingObjectSelectionStudySeriesInstanceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImagingObjectSelectionStudySeriesInstanceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImagingObjectSelectionStudySeriesInstanceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImagingObjectSelectionStudySeriesInstanceListEnumerator.GetCurrent : TFhirImagingObjectSelectionStudySeriesInstance;
begin
  Result := FList[FIndex];
end;

function TFhirImagingObjectSelectionStudySeriesInstanceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImagingObjectSelectionStudySeriesInstanceList }
procedure TFhirImagingObjectSelectionStudySeriesInstanceList.AddItem(value: TFhirImagingObjectSelectionStudySeriesInstance);
begin
  assert(value.ClassName = 'TFhirImagingObjectSelectionStudySeriesInstance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImagingObjectSelectionStudySeriesInstance');
  add(value);
end;

function TFhirImagingObjectSelectionStudySeriesInstanceList.Append: TFhirImagingObjectSelectionStudySeriesInstance;
begin
  result := TFhirImagingObjectSelectionStudySeriesInstance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingObjectSelectionStudySeriesInstanceList.ClearItems;
begin
  Clear;
end;

function TFhirImagingObjectSelectionStudySeriesInstanceList.GetEnumerator : TFhirImagingObjectSelectionStudySeriesInstanceListEnumerator;
begin
  result := TFhirImagingObjectSelectionStudySeriesInstanceListEnumerator.Create(self.link);
end;

function TFhirImagingObjectSelectionStudySeriesInstanceList.Clone: TFhirImagingObjectSelectionStudySeriesInstanceList;
begin
  result := TFhirImagingObjectSelectionStudySeriesInstanceList(inherited Clone);
end;

function TFhirImagingObjectSelectionStudySeriesInstanceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImagingObjectSelectionStudySeriesInstanceList.GetItemN(index: Integer): TFhirImagingObjectSelectionStudySeriesInstance;
begin
  result := TFhirImagingObjectSelectionStudySeriesInstance(ObjectByIndex[index]);
end;

function TFhirImagingObjectSelectionStudySeriesInstanceList.ItemClass: TFslObjectClass;
begin
  result := TFhirImagingObjectSelectionStudySeriesInstance;
end;
function TFhirImagingObjectSelectionStudySeriesInstanceList.IndexOf(value: TFhirImagingObjectSelectionStudySeriesInstance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImagingObjectSelectionStudySeriesInstanceList.Insert(index: Integer): TFhirImagingObjectSelectionStudySeriesInstance;
begin
  result := TFhirImagingObjectSelectionStudySeriesInstance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingObjectSelectionStudySeriesInstanceList.InsertItem(index: Integer; value: TFhirImagingObjectSelectionStudySeriesInstance);
begin
  assert(value is TFhirImagingObjectSelectionStudySeriesInstance);
  Inherited Insert(index, value);
end;

function TFhirImagingObjectSelectionStudySeriesInstanceList.Item(index: Integer): TFhirImagingObjectSelectionStudySeriesInstance;
begin
  result := TFhirImagingObjectSelectionStudySeriesInstance(ObjectByIndex[index]);
end;

function TFhirImagingObjectSelectionStudySeriesInstanceList.Link: TFhirImagingObjectSelectionStudySeriesInstanceList;
begin
  result := TFhirImagingObjectSelectionStudySeriesInstanceList(inherited Link);
end;

procedure TFhirImagingObjectSelectionStudySeriesInstanceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImagingObjectSelectionStudySeriesInstanceList.SetItemByIndex(index: Integer; value: TFhirImagingObjectSelectionStudySeriesInstance);
begin
  assert(value is TFhirImagingObjectSelectionStudySeriesInstance);
  FhirImagingObjectSelectionStudySeriesInstances[index] := value;
end;

procedure TFhirImagingObjectSelectionStudySeriesInstanceList.SetItemN(index: Integer; value: TFhirImagingObjectSelectionStudySeriesInstance);
begin
  assert(value is TFhirImagingObjectSelectionStudySeriesInstance);
  ObjectByIndex[index] := value;
end;

{ TFhirImagingObjectSelectionStudySeriesInstanceFrames }

constructor TFhirImagingObjectSelectionStudySeriesInstanceFrames.Create;
begin
  inherited;
end;

destructor TFhirImagingObjectSelectionStudySeriesInstanceFrames.Destroy;
begin
  FFrameNumbersList.Free;
  FUrl.free;
  inherited;
end;

procedure TFhirImagingObjectSelectionStudySeriesInstanceFrames.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirImagingObjectSelectionStudySeriesInstanceFrames(oSource).FFrameNumbersList = nil) then
  begin
    FFrameNumbersList.free;
    FFrameNumbersList := nil;
  end
  else
  begin
    if FFrameNumbersList = nil then
      FFrameNumbersList := TFhirUnsignedIntList.Create;
    FFrameNumbersList.Assign(TFhirImagingObjectSelectionStudySeriesInstanceFrames(oSource).FFrameNumbersList);
  end;
  urlElement := TFhirImagingObjectSelectionStudySeriesInstanceFrames(oSource).urlElement.Clone;
end;

procedure TFhirImagingObjectSelectionStudySeriesInstanceFrames.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'frameNumbers') Then
    list.addAll(self, 'frameNumbers', FFrameNumbersList);
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
end;

procedure TFhirImagingObjectSelectionStudySeriesInstanceFrames.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'frameNumbers', 'unsignedInt', true, TFhirUnsignedInt, FFrameNumbersList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));{2}
end;

function TFhirImagingObjectSelectionStudySeriesInstanceFrames.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'frameNumbers') then
  begin
    FrameNumbersList.add(asUnsignedInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'url') then
  begin
    UrlElement := asUri(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImagingObjectSelectionStudySeriesInstanceFrames.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'frameNumbers') then FrameNumbersList.insertItem(index, asUnsignedInt(propValue)){2}
  else inherited;
end;

function TFhirImagingObjectSelectionStudySeriesInstanceFrames.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'frameNumbers') then result := FrameNumbersList.new(){2}
  else if (propName = 'url') then result := TFhirUri.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImagingObjectSelectionStudySeriesInstanceFrames.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'frameNumbers') then result := 'unsignedInt'
  else if (propName = 'url') then result := 'uri'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImagingObjectSelectionStudySeriesInstanceFrames.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'frameNumbers') then deletePropertyValue('frameNumbers', FrameNumbersList, value) {2}
  else if (propName = 'url') then UrlElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImagingObjectSelectionStudySeriesInstanceFrames.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'frameNumbers') then replacePropertyValue('frameNumbers', FrameNumbersList, existing, new) {2}
  else if (propName = 'url') then UrlElement := asUri(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImagingObjectSelectionStudySeriesInstanceFrames.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'frameNumbers') then FrameNumbersList.move(source, destination){2}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImagingObjectSelectionStudySeriesInstanceFrames.fhirType : string;
begin
  result := 'frames';
end;

function TFhirImagingObjectSelectionStudySeriesInstanceFrames.Link : TFhirImagingObjectSelectionStudySeriesInstanceFrames;
begin
  result := TFhirImagingObjectSelectionStudySeriesInstanceFrames(inherited Link);
end;

function TFhirImagingObjectSelectionStudySeriesInstanceFrames.Clone : TFhirImagingObjectSelectionStudySeriesInstanceFrames;
begin
  result := TFhirImagingObjectSelectionStudySeriesInstanceFrames(inherited Clone);
end;

function TFhirImagingObjectSelectionStudySeriesInstanceFrames.equals(other : TObject) : boolean;
var
  o : TFhirImagingObjectSelectionStudySeriesInstanceFrames;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImagingObjectSelectionStudySeriesInstanceFrames)) then
    result := false
  else
  begin
    o := TFhirImagingObjectSelectionStudySeriesInstanceFrames(other);
    result := compareDeep(frameNumbersList, o.frameNumbersList, true) and compareDeep(urlElement, o.urlElement, true);
  end;
end;

function TFhirImagingObjectSelectionStudySeriesInstanceFrames.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FframeNumbersList) and isEmptyProp(FUrl);
end;

procedure TFhirImagingObjectSelectionStudySeriesInstanceFrames.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('frameNumbers');
  fields.add('url');
end;

{ TFhirImagingObjectSelectionStudySeriesInstanceFrames }

Function TFhirImagingObjectSelectionStudySeriesInstanceFrames.GetFrameNumbersList : TFhirUnsignedIntList;
begin
  if FFrameNumbersList = nil then
    FFrameNumbersList := TFhirUnsignedIntList.Create;
  result := FFrameNumbersList;
end;

Function TFhirImagingObjectSelectionStudySeriesInstanceFrames.GetHasFrameNumbersList : boolean;
begin
  result := (FFrameNumbersList <> nil) and (FFrameNumbersList.count > 0);
end;

Procedure TFhirImagingObjectSelectionStudySeriesInstanceFrames.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirImagingObjectSelectionStudySeriesInstanceFrames.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

Procedure TFhirImagingObjectSelectionStudySeriesInstanceFrames.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

function TFhirImagingObjectSelectionStudySeriesInstanceFrames.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FframeNumbersList.sizeInBytes);
  inc(result, FUrl.sizeInBytes);
end;

{ TFhirImagingObjectSelectionStudySeriesInstanceFramesListEnumerator }

Constructor TFhirImagingObjectSelectionStudySeriesInstanceFramesListEnumerator.Create(list : TFhirImagingObjectSelectionStudySeriesInstanceFramesList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImagingObjectSelectionStudySeriesInstanceFramesListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImagingObjectSelectionStudySeriesInstanceFramesListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImagingObjectSelectionStudySeriesInstanceFramesListEnumerator.GetCurrent : TFhirImagingObjectSelectionStudySeriesInstanceFrames;
begin
  Result := FList[FIndex];
end;

function TFhirImagingObjectSelectionStudySeriesInstanceFramesListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImagingObjectSelectionStudySeriesInstanceFramesList }
procedure TFhirImagingObjectSelectionStudySeriesInstanceFramesList.AddItem(value: TFhirImagingObjectSelectionStudySeriesInstanceFrames);
begin
  assert(value.ClassName = 'TFhirImagingObjectSelectionStudySeriesInstanceFrames', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImagingObjectSelectionStudySeriesInstanceFrames');
  add(value);
end;

function TFhirImagingObjectSelectionStudySeriesInstanceFramesList.Append: TFhirImagingObjectSelectionStudySeriesInstanceFrames;
begin
  result := TFhirImagingObjectSelectionStudySeriesInstanceFrames.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingObjectSelectionStudySeriesInstanceFramesList.ClearItems;
begin
  Clear;
end;

function TFhirImagingObjectSelectionStudySeriesInstanceFramesList.GetEnumerator : TFhirImagingObjectSelectionStudySeriesInstanceFramesListEnumerator;
begin
  result := TFhirImagingObjectSelectionStudySeriesInstanceFramesListEnumerator.Create(self.link);
end;

function TFhirImagingObjectSelectionStudySeriesInstanceFramesList.Clone: TFhirImagingObjectSelectionStudySeriesInstanceFramesList;
begin
  result := TFhirImagingObjectSelectionStudySeriesInstanceFramesList(inherited Clone);
end;

function TFhirImagingObjectSelectionStudySeriesInstanceFramesList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImagingObjectSelectionStudySeriesInstanceFramesList.GetItemN(index: Integer): TFhirImagingObjectSelectionStudySeriesInstanceFrames;
begin
  result := TFhirImagingObjectSelectionStudySeriesInstanceFrames(ObjectByIndex[index]);
end;

function TFhirImagingObjectSelectionStudySeriesInstanceFramesList.ItemClass: TFslObjectClass;
begin
  result := TFhirImagingObjectSelectionStudySeriesInstanceFrames;
end;
function TFhirImagingObjectSelectionStudySeriesInstanceFramesList.IndexOf(value: TFhirImagingObjectSelectionStudySeriesInstanceFrames): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImagingObjectSelectionStudySeriesInstanceFramesList.Insert(index: Integer): TFhirImagingObjectSelectionStudySeriesInstanceFrames;
begin
  result := TFhirImagingObjectSelectionStudySeriesInstanceFrames.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingObjectSelectionStudySeriesInstanceFramesList.InsertItem(index: Integer; value: TFhirImagingObjectSelectionStudySeriesInstanceFrames);
begin
  assert(value is TFhirImagingObjectSelectionStudySeriesInstanceFrames);
  Inherited Insert(index, value);
end;

function TFhirImagingObjectSelectionStudySeriesInstanceFramesList.Item(index: Integer): TFhirImagingObjectSelectionStudySeriesInstanceFrames;
begin
  result := TFhirImagingObjectSelectionStudySeriesInstanceFrames(ObjectByIndex[index]);
end;

function TFhirImagingObjectSelectionStudySeriesInstanceFramesList.Link: TFhirImagingObjectSelectionStudySeriesInstanceFramesList;
begin
  result := TFhirImagingObjectSelectionStudySeriesInstanceFramesList(inherited Link);
end;

procedure TFhirImagingObjectSelectionStudySeriesInstanceFramesList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImagingObjectSelectionStudySeriesInstanceFramesList.SetItemByIndex(index: Integer; value: TFhirImagingObjectSelectionStudySeriesInstanceFrames);
begin
  assert(value is TFhirImagingObjectSelectionStudySeriesInstanceFrames);
  FhirImagingObjectSelectionStudySeriesInstanceFrames[index] := value;
end;

procedure TFhirImagingObjectSelectionStudySeriesInstanceFramesList.SetItemN(index: Integer; value: TFhirImagingObjectSelectionStudySeriesInstanceFrames);
begin
  assert(value is TFhirImagingObjectSelectionStudySeriesInstanceFrames);
  ObjectByIndex[index] := value;
end;

{ TFhirImagingObjectSelection }

constructor TFhirImagingObjectSelection.Create;
begin
  inherited;
end;

destructor TFhirImagingObjectSelection.Destroy;
begin
  FUid.free;
  FPatient.free;
  FTitle.free;
  FDescription.free;
  FAuthor.free;
  FAuthoringTime.free;
  FStudyList.Free;
  inherited;
end;

function TFhirImagingObjectSelection.GetResourceType : TFhirResourceType;
begin
  result := frtImagingObjectSelection;
end;

procedure TFhirImagingObjectSelection.Assign(oSource : TFslObject);
begin
  inherited;
  uidElement := TFhirImagingObjectSelection(oSource).uidElement.Clone;
  patient := TFhirImagingObjectSelection(oSource).patient.Clone;
  title := TFhirImagingObjectSelection(oSource).title.Clone;
  descriptionElement := TFhirImagingObjectSelection(oSource).descriptionElement.Clone;
  author := TFhirImagingObjectSelection(oSource).author.Clone;
  authoringTimeElement := TFhirImagingObjectSelection(oSource).authoringTimeElement.Clone;
  if (TFhirImagingObjectSelection(oSource).FStudyList = nil) then
  begin
    FStudyList.free;
    FStudyList := nil;
  end
  else
  begin
    if FStudyList = nil then
      FStudyList := TFhirImagingObjectSelectionStudyList.Create;
    FStudyList.Assign(TFhirImagingObjectSelection(oSource).FStudyList);
  end;
end;

procedure TFhirImagingObjectSelection.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'uid') Then
     list.add(self.link, 'uid', FUid.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
  if (child_name = 'authoringTime') Then
     list.add(self.link, 'authoringTime', FAuthoringTime.Link);
  if (child_name = 'study') Then
    list.addAll(self, 'study', FStudyList);
end;

procedure TFhirImagingObjectSelection.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'uid', 'oid', false, TFhirOid, FUid.Link));{2}
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'title', 'CodeableConcept', false, TFhirCodeableConcept, FTitle.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'author', 'Reference(Practitioner|Device|Organization|Patient|RelatedPerson)', false, TFhirReference{Resource}, FAuthor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'authoringTime', 'dateTime', false, TFhirDateTime, FAuthoringTime.Link));{2}
  oList.add(TFHIRProperty.create(self, 'study', '', true, TFhirImagingObjectSelectionStudy, FStudyList.Link)){3};
end;

function TFhirImagingObjectSelection.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'uid') then
  begin
    UidElement := asOid(propValue){5a};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    Title := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'authoringTime') then
  begin
    AuthoringTimeElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'study') then
  begin
    StudyList.add(propValue as TFhirImagingObjectSelectionStudy){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirImagingObjectSelection.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'study') then StudyList.insertItem(index, propValue as TFhirImagingObjectSelectionStudy){2a}
  else inherited;
end;

function TFhirImagingObjectSelection.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'uid') then result := TFhirOid.create() {5b}
  else if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'title') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'author') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'authoringTime') then result := TFhirDateTime.create() {5b}
  else if (propName = 'study') then result := StudyList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImagingObjectSelection.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'uid') then result := 'oid'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'title') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'authoringTime') then result := 'dateTime'
  else if (propName = 'study') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImagingObjectSelection.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'uid') then UidElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'author') then AuthorElement := nil
  else if (propName = 'authoringTime') then AuthoringTimeElement := nil
  else if (propName = 'study') then deletePropertyValue('study', StudyList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImagingObjectSelection.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'uid') then UidElement := asOid(new){5b}
  else if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'title') then TitleElement := new as TFhirCodeableConcept{4}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'author') then AuthorElement := new as TFhirReference{Resource}{4}
  else if (propName = 'authoringTime') then AuthoringTimeElement := asDateTime(new){5b}
  else if (propName = 'study') then replacePropertyValue('study', StudyList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImagingObjectSelection.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'study') then StudyList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImagingObjectSelection.fhirType : string;
begin
  result := 'ImagingObjectSelection';
end;

function TFhirImagingObjectSelection.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUid) and isEmptyProp(FPatient) and isEmptyProp(FTitle) and isEmptyProp(FDescription) and isEmptyProp(FAuthor) and isEmptyProp(FAuthoringTime) and isEmptyProp(FstudyList);
end;

function TFhirImagingObjectSelection.equals(other : TObject) : boolean;
var
  o : TFhirImagingObjectSelection;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImagingObjectSelection)) then
    result := false
  else
  begin
    o := TFhirImagingObjectSelection(other);
    result := compareDeep(uidElement, o.uidElement, true) and compareDeep(patientElement, o.patientElement, true) and
      compareDeep(titleElement, o.titleElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and
      compareDeep(authorElement, o.authorElement, true) and compareDeep(authoringTimeElement, o.authoringTimeElement, true) and
      compareDeep(studyList, o.studyList, true);
  end;
end;

function TFhirImagingObjectSelection.Link : TFhirImagingObjectSelection;
begin
  result := TFhirImagingObjectSelection(inherited Link);
end;

function TFhirImagingObjectSelection.Clone : TFhirImagingObjectSelection;
begin
  result := TFhirImagingObjectSelection(inherited Clone);
end;

procedure TFhirImagingObjectSelection.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('uid');
  fields.add('patient');
  fields.add('title');
  fields.add('description');
  fields.add('author');
  fields.add('authoringTime');
  fields.add('study');
end;

{ TFhirImagingObjectSelection }

Procedure TFhirImagingObjectSelection.SetUid(value : TFhirOid);
begin
  FUid.free;
  FUid := value;
end;

Function TFhirImagingObjectSelection.GetUidST : String;
begin
  if FUid = nil then
    result := ''
  else
    result := FUid.value;
end;

Procedure TFhirImagingObjectSelection.SetUidST(value : String);
begin
  if value <> '' then
  begin
    if FUid = nil then
      FUid := TFhirOid.create;
    FUid.value := value
  end
  else if FUid <> nil then
    FUid.value := '';
end;

Procedure TFhirImagingObjectSelection.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Procedure TFhirImagingObjectSelection.SetTitle(value : TFhirCodeableConcept);
begin
  FTitle.free;
  FTitle := value;
end;

Procedure TFhirImagingObjectSelection.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirImagingObjectSelection.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirImagingObjectSelection.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirImagingObjectSelection.SetAuthor(value : TFhirReference{Resource});
begin
  FAuthor.free;
  FAuthor := value;
end;

Procedure TFhirImagingObjectSelection.SetAuthoringTime(value : TFhirDateTime);
begin
  FAuthoringTime.free;
  FAuthoringTime := value;
end;

Function TFhirImagingObjectSelection.GetAuthoringTimeST : TFslDateTime;
begin
  if FAuthoringTime = nil then
    result := TFslDateTime.makeNull
  else
    result := FAuthoringTime.value;
end;

Procedure TFhirImagingObjectSelection.SetAuthoringTimeST(value : TFslDateTime);
begin
  if FAuthoringTime = nil then
    FAuthoringTime := TFhirDateTime.create;
  FAuthoringTime.value := value
end;

Function TFhirImagingObjectSelection.GetStudyList : TFhirImagingObjectSelectionStudyList;
begin
  if FStudyList = nil then
    FStudyList := TFhirImagingObjectSelectionStudyList.Create;
  result := FStudyList;
end;

Function TFhirImagingObjectSelection.GetHasStudyList : boolean;
begin
  result := (FStudyList <> nil) and (FStudyList.count > 0);
end;

function TFhirImagingObjectSelection.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FUid.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FTitle.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FAuthor.sizeInBytes);
  inc(result, FAuthoringTime.sizeInBytes);
  inc(result, FstudyList.sizeInBytes);
end;

{ TFhirImagingObjectSelectionListEnumerator }

Constructor TFhirImagingObjectSelectionListEnumerator.Create(list : TFhirImagingObjectSelectionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImagingObjectSelectionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImagingObjectSelectionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImagingObjectSelectionListEnumerator.GetCurrent : TFhirImagingObjectSelection;
begin
  Result := FList[FIndex];
end;

function TFhirImagingObjectSelectionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImagingObjectSelectionList }
procedure TFhirImagingObjectSelectionList.AddItem(value: TFhirImagingObjectSelection);
begin
  assert(value.ClassName = 'TFhirImagingObjectSelection', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImagingObjectSelection');
  add(value);
end;

function TFhirImagingObjectSelectionList.Append: TFhirImagingObjectSelection;
begin
  result := TFhirImagingObjectSelection.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingObjectSelectionList.ClearItems;
begin
  Clear;
end;

function TFhirImagingObjectSelectionList.GetEnumerator : TFhirImagingObjectSelectionListEnumerator;
begin
  result := TFhirImagingObjectSelectionListEnumerator.Create(self.link);
end;

function TFhirImagingObjectSelectionList.Clone: TFhirImagingObjectSelectionList;
begin
  result := TFhirImagingObjectSelectionList(inherited Clone);
end;

function TFhirImagingObjectSelectionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImagingObjectSelectionList.GetItemN(index: Integer): TFhirImagingObjectSelection;
begin
  result := TFhirImagingObjectSelection(ObjectByIndex[index]);
end;

function TFhirImagingObjectSelectionList.ItemClass: TFslObjectClass;
begin
  result := TFhirImagingObjectSelection;
end;
function TFhirImagingObjectSelectionList.IndexOf(value: TFhirImagingObjectSelection): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImagingObjectSelectionList.Insert(index: Integer): TFhirImagingObjectSelection;
begin
  result := TFhirImagingObjectSelection.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingObjectSelectionList.InsertItem(index: Integer; value: TFhirImagingObjectSelection);
begin
  assert(value is TFhirImagingObjectSelection);
  Inherited Insert(index, value);
end;

function TFhirImagingObjectSelectionList.Item(index: Integer): TFhirImagingObjectSelection;
begin
  result := TFhirImagingObjectSelection(ObjectByIndex[index]);
end;

function TFhirImagingObjectSelectionList.Link: TFhirImagingObjectSelectionList;
begin
  result := TFhirImagingObjectSelectionList(inherited Link);
end;

procedure TFhirImagingObjectSelectionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImagingObjectSelectionList.SetItemByIndex(index: Integer; value: TFhirImagingObjectSelection);
begin
  assert(value is TFhirImagingObjectSelection);
  FhirImagingObjectSelections[index] := value;
end;

procedure TFhirImagingObjectSelectionList.SetItemN(index: Integer; value: TFhirImagingObjectSelection);
begin
  assert(value is TFhirImagingObjectSelection);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_IMAGINGOBJECTSELECTION}

{$IFDEF FHIR_IMAGINGSTUDY}

{ TFhirImagingStudySeries }

constructor TFhirImagingStudySeries.Create;
begin
  inherited;
end;

destructor TFhirImagingStudySeries.Destroy;
begin
  FNumber.free;
  FModality.free;
  FUid.free;
  FDescription.free;
  FNumberOfInstances.free;
  FAvailability.free;
  FUrl.free;
  FBodySite.free;
  FLaterality.free;
  FStarted.free;
  FInstanceList.Free;
  inherited;
end;

procedure TFhirImagingStudySeries.Assign(oSource : TFslObject);
begin
  inherited;
  numberElement := TFhirImagingStudySeries(oSource).numberElement.Clone;
  modality := TFhirImagingStudySeries(oSource).modality.Clone;
  uidElement := TFhirImagingStudySeries(oSource).uidElement.Clone;
  descriptionElement := TFhirImagingStudySeries(oSource).descriptionElement.Clone;
  numberOfInstancesElement := TFhirImagingStudySeries(oSource).numberOfInstancesElement.Clone;
  FAvailability := TFhirImagingStudySeries(oSource).FAvailability.Link;
  urlElement := TFhirImagingStudySeries(oSource).urlElement.Clone;
  bodySite := TFhirImagingStudySeries(oSource).bodySite.Clone;
  laterality := TFhirImagingStudySeries(oSource).laterality.Clone;
  startedElement := TFhirImagingStudySeries(oSource).startedElement.Clone;
  if (TFhirImagingStudySeries(oSource).FInstanceList = nil) then
  begin
    FInstanceList.free;
    FInstanceList := nil;
  end
  else
  begin
    if FInstanceList = nil then
      FInstanceList := TFhirImagingStudySeriesInstanceList.Create;
    FInstanceList.Assign(TFhirImagingStudySeries(oSource).FInstanceList);
  end;
end;

procedure TFhirImagingStudySeries.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'number') Then
     list.add(self.link, 'number', FNumber.Link);
  if (child_name = 'modality') Then
     list.add(self.link, 'modality', FModality.Link);
  if (child_name = 'uid') Then
     list.add(self.link, 'uid', FUid.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'numberOfInstances') Then
     list.add(self.link, 'numberOfInstances', FNumberOfInstances.Link);
  if (child_name = 'availability') Then
     list.add(self.link, 'availability', FAvailability.Link);
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'bodySite') Then
     list.add(self.link, 'bodySite', FBodySite.Link);
  if (child_name = 'laterality') Then
     list.add(self.link, 'laterality', FLaterality.Link);
  if (child_name = 'started') Then
     list.add(self.link, 'started', FStarted.Link);
  if (child_name = 'instance') Then
    list.addAll(self, 'instance', FInstanceList);
end;

procedure TFhirImagingStudySeries.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'number', 'unsignedInt', false, TFhirUnsignedInt, FNumber.Link));{2}
  oList.add(TFHIRProperty.create(self, 'modality', 'Coding', false, TFhirCoding, FModality.Link));{2}
  oList.add(TFHIRProperty.create(self, 'uid', 'oid', false, TFhirOid, FUid.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'numberOfInstances', 'unsignedInt', false, TFhirUnsignedInt, FNumberOfInstances.Link));{2}
  oList.add(TFHIRProperty.create(self, 'availability', 'code', false, TFHIREnum, FAvailability.Link));{1}
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));{2}
  oList.add(TFHIRProperty.create(self, 'bodySite', 'Coding', false, TFhirCoding, FBodySite.Link));{2}
  oList.add(TFHIRProperty.create(self, 'laterality', 'Coding', false, TFhirCoding, FLaterality.Link));{2}
  oList.add(TFHIRProperty.create(self, 'started', 'dateTime', false, TFhirDateTime, FStarted.Link));{2}
  oList.add(TFHIRProperty.create(self, 'instance', '', true, TFhirImagingStudySeriesInstance, FInstanceList.Link)){3};
end;

function TFhirImagingStudySeries.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'number') then
  begin
    NumberElement := asUnsignedInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'modality') then
  begin
    Modality := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'uid') then
  begin
    UidElement := asOid(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'numberOfInstances') then
  begin
    NumberOfInstancesElement := asUnsignedInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'availability') then
  begin
    AvailabilityElement := asEnum(SYSTEMS_TFhirInstanceAvailabilityEnum, CODES_TFhirInstanceAvailabilityEnum, propValue);
    result := propValue
  end
  else if (propName = 'url') then
  begin
    UrlElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySite := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'laterality') then
  begin
    Laterality := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'started') then
  begin
    StartedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'instance') then
  begin
    InstanceList.add(propValue as TFhirImagingStudySeriesInstance){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImagingStudySeries.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'instance') then InstanceList.insertItem(index, propValue as TFhirImagingStudySeriesInstance){2a}
  else inherited;
end;

function TFhirImagingStudySeries.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'number') then result := TFhirUnsignedInt.create() {5b}
  else if (propName = 'modality') then result := TFhirCoding.create(){4b}
  else if (propName = 'uid') then result := TFhirOid.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'numberOfInstances') then result := TFhirUnsignedInt.create() {5b}
  else if (propName = 'url') then result := TFhirUri.create() {5b}
  else if (propName = 'bodySite') then result := TFhirCoding.create(){4b}
  else if (propName = 'laterality') then result := TFhirCoding.create(){4b}
  else if (propName = 'started') then result := TFhirDateTime.create() {5b}
  else if (propName = 'instance') then result := InstanceList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImagingStudySeries.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'number') then result := 'unsignedInt'
  else if (propName = 'modality') then result := 'Coding'
  else if (propName = 'uid') then result := 'oid'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'numberOfInstances') then result := 'unsignedInt'
  else if (propName = 'availability') then result := 'code'
  else if (propName = 'url') then result := 'uri'
  else if (propName = 'bodySite') then result := 'Coding'
  else if (propName = 'laterality') then result := 'Coding'
  else if (propName = 'started') then result := 'dateTime'
  else if (propName = 'instance') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImagingStudySeries.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'number') then NumberElement := nil
  else if (propName = 'modality') then ModalityElement := nil
  else if (propName = 'uid') then UidElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'numberOfInstances') then NumberOfInstancesElement := nil
  else if (propName = 'availability') then AvailabilityElement := nil
  else if (propName = 'url') then UrlElement := nil
  else if (propName = 'bodySite') then BodySiteElement := nil
  else if (propName = 'laterality') then LateralityElement := nil
  else if (propName = 'started') then StartedElement := nil
  else if (propName = 'instance') then deletePropertyValue('instance', InstanceList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImagingStudySeries.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'number') then NumberElement := asUnsignedInt(new){5b}
  else if (propName = 'modality') then ModalityElement := new as TFhirCoding{4}
  else if (propName = 'uid') then UidElement := asOid(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'numberOfInstances') then NumberOfInstancesElement := asUnsignedInt(new){5b}
  else if (propName = 'availability') then AvailabilityElement := asEnum(SYSTEMS_TFhirInstanceAvailabilityEnum, CODES_TFhirInstanceAvailabilityEnum, new){4}
  else if (propName = 'url') then UrlElement := asUri(new){5b}
  else if (propName = 'bodySite') then BodySiteElement := new as TFhirCoding{4}
  else if (propName = 'laterality') then LateralityElement := new as TFhirCoding{4}
  else if (propName = 'started') then StartedElement := asDateTime(new){5b}
  else if (propName = 'instance') then replacePropertyValue('instance', InstanceList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImagingStudySeries.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'instance') then InstanceList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImagingStudySeries.fhirType : string;
begin
  result := 'series';
end;

function TFhirImagingStudySeries.Link : TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries(inherited Link);
end;

function TFhirImagingStudySeries.Clone : TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries(inherited Clone);
end;

function TFhirImagingStudySeries.equals(other : TObject) : boolean;
var
  o : TFhirImagingStudySeries;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImagingStudySeries)) then
    result := false
  else
  begin
    o := TFhirImagingStudySeries(other);
    result := compareDeep(numberElement, o.numberElement, true) and compareDeep(modalityElement, o.modalityElement, true) and
      compareDeep(uidElement, o.uidElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and
      compareDeep(numberOfInstancesElement, o.numberOfInstancesElement, true) and compareDeep(availabilityElement, o.availabilityElement, true) and
      compareDeep(urlElement, o.urlElement, true) and compareDeep(bodySiteElement, o.bodySiteElement, true) and
      compareDeep(lateralityElement, o.lateralityElement, true) and compareDeep(startedElement, o.startedElement, true) and
      compareDeep(instanceList, o.instanceList, true);
  end;
end;

function TFhirImagingStudySeries.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FNumber) and isEmptyProp(FModality) and isEmptyProp(FUid) and isEmptyProp(FDescription) and isEmptyProp(FNumberOfInstances) and isEmptyProp(FAvailability) and isEmptyProp(FUrl) and isEmptyProp(FBodySite) and isEmptyProp(FLaterality) and isEmptyProp(FStarted) and isEmptyProp(FinstanceList);
end;

procedure TFhirImagingStudySeries.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('number');
  fields.add('modality');
  fields.add('uid');
  fields.add('description');
  fields.add('numberOfInstances');
  fields.add('availability');
  fields.add('url');
  fields.add('bodySite');
  fields.add('laterality');
  fields.add('started');
  fields.add('instance');
end;

{ TFhirImagingStudySeries }

Procedure TFhirImagingStudySeries.SetNumber(value : TFhirUnsignedInt);
begin
  FNumber.free;
  FNumber := value;
end;

Function TFhirImagingStudySeries.GetNumberST : String;
begin
  if FNumber = nil then
    result := ''
  else
    result := FNumber.value;
end;

Procedure TFhirImagingStudySeries.SetNumberST(value : String);
begin
  if value <> '' then
  begin
    if FNumber = nil then
      FNumber := TFhirUnsignedInt.create;
    FNumber.value := value
  end
  else if FNumber <> nil then
    FNumber.value := '';
end;

Procedure TFhirImagingStudySeries.SetModality(value : TFhirCoding);
begin
  FModality.free;
  FModality := value;
end;

Procedure TFhirImagingStudySeries.SetUid(value : TFhirOid);
begin
  FUid.free;
  FUid := value;
end;

Function TFhirImagingStudySeries.GetUidST : String;
begin
  if FUid = nil then
    result := ''
  else
    result := FUid.value;
end;

Procedure TFhirImagingStudySeries.SetUidST(value : String);
begin
  if value <> '' then
  begin
    if FUid = nil then
      FUid := TFhirOid.create;
    FUid.value := value
  end
  else if FUid <> nil then
    FUid.value := '';
end;

Procedure TFhirImagingStudySeries.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirImagingStudySeries.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirImagingStudySeries.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirImagingStudySeries.SetNumberOfInstances(value : TFhirUnsignedInt);
begin
  FNumberOfInstances.free;
  FNumberOfInstances := value;
end;

Function TFhirImagingStudySeries.GetNumberOfInstancesST : String;
begin
  if FNumberOfInstances = nil then
    result := ''
  else
    result := FNumberOfInstances.value;
end;

Procedure TFhirImagingStudySeries.SetNumberOfInstancesST(value : String);
begin
  if value <> '' then
  begin
    if FNumberOfInstances = nil then
      FNumberOfInstances := TFhirUnsignedInt.create;
    FNumberOfInstances.value := value
  end
  else if FNumberOfInstances <> nil then
    FNumberOfInstances.value := '';
end;

Procedure TFhirImagingStudySeries.SetAvailability(value : TFhirEnum);
begin
  FAvailability.free;
  FAvailability := value;
end;

Function TFhirImagingStudySeries.GetAvailabilityST : TFhirInstanceAvailabilityEnum;
begin
  if FAvailability = nil then
    result := TFhirInstanceAvailabilityEnum(0)
  else
    result := TFhirInstanceAvailabilityEnum(StringArrayIndexOfSensitive(CODES_TFhirInstanceAvailabilityEnum, FAvailability.value));
end;

Procedure TFhirImagingStudySeries.SetAvailabilityST(value : TFhirInstanceAvailabilityEnum);
begin
  if ord(value) = 0 then
    AvailabilityElement := nil
  else
    AvailabilityElement := TFhirEnum.create(SYSTEMS_TFhirInstanceAvailabilityEnum[value], CODES_TFhirInstanceAvailabilityEnum[value]);
end;

Procedure TFhirImagingStudySeries.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirImagingStudySeries.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

Procedure TFhirImagingStudySeries.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

Procedure TFhirImagingStudySeries.SetBodySite(value : TFhirCoding);
begin
  FBodySite.free;
  FBodySite := value;
end;

Procedure TFhirImagingStudySeries.SetLaterality(value : TFhirCoding);
begin
  FLaterality.free;
  FLaterality := value;
end;

Procedure TFhirImagingStudySeries.SetStarted(value : TFhirDateTime);
begin
  FStarted.free;
  FStarted := value;
end;

Function TFhirImagingStudySeries.GetStartedST : TFslDateTime;
begin
  if FStarted = nil then
    result := TFslDateTime.makeNull
  else
    result := FStarted.value;
end;

Procedure TFhirImagingStudySeries.SetStartedST(value : TFslDateTime);
begin
  if FStarted = nil then
    FStarted := TFhirDateTime.create;
  FStarted.value := value
end;

Function TFhirImagingStudySeries.GetInstanceList : TFhirImagingStudySeriesInstanceList;
begin
  if FInstanceList = nil then
    FInstanceList := TFhirImagingStudySeriesInstanceList.Create;
  result := FInstanceList;
end;

Function TFhirImagingStudySeries.GetHasInstanceList : boolean;
begin
  result := (FInstanceList <> nil) and (FInstanceList.count > 0);
end;

function TFhirImagingStudySeries.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FNumber.sizeInBytes);
  inc(result, FModality.sizeInBytes);
  inc(result, FUid.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FNumberOfInstances.sizeInBytes);
  inc(result, FAvailability.sizeInBytes);
  inc(result, FUrl.sizeInBytes);
  inc(result, FBodySite.sizeInBytes);
  inc(result, FLaterality.sizeInBytes);
  inc(result, FStarted.sizeInBytes);
  inc(result, FinstanceList.sizeInBytes);
end;

{ TFhirImagingStudySeriesListEnumerator }

Constructor TFhirImagingStudySeriesListEnumerator.Create(list : TFhirImagingStudySeriesList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImagingStudySeriesListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImagingStudySeriesListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImagingStudySeriesListEnumerator.GetCurrent : TFhirImagingStudySeries;
begin
  Result := FList[FIndex];
end;

function TFhirImagingStudySeriesListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImagingStudySeriesList }
procedure TFhirImagingStudySeriesList.AddItem(value: TFhirImagingStudySeries);
begin
  assert(value.ClassName = 'TFhirImagingStudySeries', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImagingStudySeries');
  add(value);
end;

function TFhirImagingStudySeriesList.Append: TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingStudySeriesList.ClearItems;
begin
  Clear;
end;

function TFhirImagingStudySeriesList.GetEnumerator : TFhirImagingStudySeriesListEnumerator;
begin
  result := TFhirImagingStudySeriesListEnumerator.Create(self.link);
end;

function TFhirImagingStudySeriesList.Clone: TFhirImagingStudySeriesList;
begin
  result := TFhirImagingStudySeriesList(inherited Clone);
end;

function TFhirImagingStudySeriesList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImagingStudySeriesList.GetItemN(index: Integer): TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries(ObjectByIndex[index]);
end;

function TFhirImagingStudySeriesList.ItemClass: TFslObjectClass;
begin
  result := TFhirImagingStudySeries;
end;
function TFhirImagingStudySeriesList.IndexOf(value: TFhirImagingStudySeries): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImagingStudySeriesList.Insert(index: Integer): TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingStudySeriesList.InsertItem(index: Integer; value: TFhirImagingStudySeries);
begin
  assert(value is TFhirImagingStudySeries);
  Inherited Insert(index, value);
end;

function TFhirImagingStudySeriesList.Item(index: Integer): TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries(ObjectByIndex[index]);
end;

function TFhirImagingStudySeriesList.Link: TFhirImagingStudySeriesList;
begin
  result := TFhirImagingStudySeriesList(inherited Link);
end;

procedure TFhirImagingStudySeriesList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImagingStudySeriesList.SetItemByIndex(index: Integer; value: TFhirImagingStudySeries);
begin
  assert(value is TFhirImagingStudySeries);
  FhirImagingStudySeries[index] := value;
end;

procedure TFhirImagingStudySeriesList.SetItemN(index: Integer; value: TFhirImagingStudySeries);
begin
  assert(value is TFhirImagingStudySeries);
  ObjectByIndex[index] := value;
end;

{ TFhirImagingStudySeriesInstance }

constructor TFhirImagingStudySeriesInstance.Create;
begin
  inherited;
end;

destructor TFhirImagingStudySeriesInstance.Destroy;
begin
  FNumber.free;
  FUid.free;
  FSopClass.free;
  FType_.free;
  FTitle.free;
  FContentList.Free;
  inherited;
end;

procedure TFhirImagingStudySeriesInstance.Assign(oSource : TFslObject);
begin
  inherited;
  numberElement := TFhirImagingStudySeriesInstance(oSource).numberElement.Clone;
  uidElement := TFhirImagingStudySeriesInstance(oSource).uidElement.Clone;
  sopClassElement := TFhirImagingStudySeriesInstance(oSource).sopClassElement.Clone;
  type_Element := TFhirImagingStudySeriesInstance(oSource).type_Element.Clone;
  titleElement := TFhirImagingStudySeriesInstance(oSource).titleElement.Clone;
  if (TFhirImagingStudySeriesInstance(oSource).FContentList = nil) then
  begin
    FContentList.free;
    FContentList := nil;
  end
  else
  begin
    if FContentList = nil then
      FContentList := TFhirAttachmentList.Create;
    FContentList.Assign(TFhirImagingStudySeriesInstance(oSource).FContentList);
  end;
end;

procedure TFhirImagingStudySeriesInstance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'number') Then
     list.add(self.link, 'number', FNumber.Link);
  if (child_name = 'uid') Then
     list.add(self.link, 'uid', FUid.Link);
  if (child_name = 'sopClass') Then
     list.add(self.link, 'sopClass', FSopClass.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'content') Then
    list.addAll(self, 'content', FContentList);
end;

procedure TFhirImagingStudySeriesInstance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'number', 'unsignedInt', false, TFhirUnsignedInt, FNumber.Link));{2}
  oList.add(TFHIRProperty.create(self, 'uid', 'oid', false, TFhirOid, FUid.Link));{2}
  oList.add(TFHIRProperty.create(self, 'sopClass', 'oid', false, TFhirOid, FSopClass.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'string', false, TFhirString, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));{2}
  oList.add(TFHIRProperty.create(self, 'content', 'Attachment', true, TFhirAttachment, FContentList.Link)){3};
end;

function TFhirImagingStudySeriesInstance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'number') then
  begin
    NumberElement := asUnsignedInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'uid') then
  begin
    UidElement := asOid(propValue){5a};
    result := propValue;
  end
  else if (propName = 'sopClass') then
  begin
    SopClassElement := asOid(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'content') then
  begin
    ContentList.add(propValue as TFhirAttachment){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImagingStudySeriesInstance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'content') then ContentList.insertItem(index, propValue as TFhirAttachment){2a}
  else inherited;
end;

function TFhirImagingStudySeriesInstance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'number') then result := TFhirUnsignedInt.create() {5b}
  else if (propName = 'uid') then result := TFhirOid.create() {5b}
  else if (propName = 'sopClass') then result := TFhirOid.create() {5b}
  else if (propName = 'type') then result := TFhirString.create() {5b}
  else if (propName = 'title') then result := TFhirString.create() {5b}
  else if (propName = 'content') then result := ContentList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImagingStudySeriesInstance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'number') then result := 'unsignedInt'
  else if (propName = 'uid') then result := 'oid'
  else if (propName = 'sopClass') then result := 'oid'
  else if (propName = 'type') then result := 'string'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'content') then result := 'Attachment'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImagingStudySeriesInstance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'number') then NumberElement := nil
  else if (propName = 'uid') then UidElement := nil
  else if (propName = 'sopClass') then SopClassElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'content') then deletePropertyValue('content', ContentList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImagingStudySeriesInstance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'number') then NumberElement := asUnsignedInt(new){5b}
  else if (propName = 'uid') then UidElement := asOid(new){5b}
  else if (propName = 'sopClass') then SopClassElement := asOid(new){5b}
  else if (propName = 'type') then Type_Element := asString(new){5b}
  else if (propName = 'title') then TitleElement := asString(new){5b}
  else if (propName = 'content') then replacePropertyValue('content', ContentList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImagingStudySeriesInstance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'content') then ContentList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImagingStudySeriesInstance.fhirType : string;
begin
  result := 'instance';
end;

function TFhirImagingStudySeriesInstance.Link : TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance(inherited Link);
end;

function TFhirImagingStudySeriesInstance.Clone : TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance(inherited Clone);
end;

function TFhirImagingStudySeriesInstance.equals(other : TObject) : boolean;
var
  o : TFhirImagingStudySeriesInstance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImagingStudySeriesInstance)) then
    result := false
  else
  begin
    o := TFhirImagingStudySeriesInstance(other);
    result := compareDeep(numberElement, o.numberElement, true) and compareDeep(uidElement, o.uidElement, true) and
      compareDeep(sopClassElement, o.sopClassElement, true) and compareDeep(type_Element, o.type_Element, true) and
      compareDeep(titleElement, o.titleElement, true) and compareDeep(contentList, o.contentList, true);
  end;
end;

function TFhirImagingStudySeriesInstance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FNumber) and isEmptyProp(FUid) and isEmptyProp(FSopClass) and isEmptyProp(FType_) and isEmptyProp(FTitle) and isEmptyProp(FcontentList);
end;

procedure TFhirImagingStudySeriesInstance.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('number');
  fields.add('uid');
  fields.add('sopClass');
  fields.add('type');
  fields.add('title');
  fields.add('content');
end;

{ TFhirImagingStudySeriesInstance }

Procedure TFhirImagingStudySeriesInstance.SetNumber(value : TFhirUnsignedInt);
begin
  FNumber.free;
  FNumber := value;
end;

Function TFhirImagingStudySeriesInstance.GetNumberST : String;
begin
  if FNumber = nil then
    result := ''
  else
    result := FNumber.value;
end;

Procedure TFhirImagingStudySeriesInstance.SetNumberST(value : String);
begin
  if value <> '' then
  begin
    if FNumber = nil then
      FNumber := TFhirUnsignedInt.create;
    FNumber.value := value
  end
  else if FNumber <> nil then
    FNumber.value := '';
end;

Procedure TFhirImagingStudySeriesInstance.SetUid(value : TFhirOid);
begin
  FUid.free;
  FUid := value;
end;

Function TFhirImagingStudySeriesInstance.GetUidST : String;
begin
  if FUid = nil then
    result := ''
  else
    result := FUid.value;
end;

Procedure TFhirImagingStudySeriesInstance.SetUidST(value : String);
begin
  if value <> '' then
  begin
    if FUid = nil then
      FUid := TFhirOid.create;
    FUid.value := value
  end
  else if FUid <> nil then
    FUid.value := '';
end;

Procedure TFhirImagingStudySeriesInstance.SetSopClass(value : TFhirOid);
begin
  FSopClass.free;
  FSopClass := value;
end;

Function TFhirImagingStudySeriesInstance.GetSopClassST : String;
begin
  if FSopClass = nil then
    result := ''
  else
    result := FSopClass.value;
end;

Procedure TFhirImagingStudySeriesInstance.SetSopClassST(value : String);
begin
  if value <> '' then
  begin
    if FSopClass = nil then
      FSopClass := TFhirOid.create;
    FSopClass.value := value
  end
  else if FSopClass <> nil then
    FSopClass.value := '';
end;

Procedure TFhirImagingStudySeriesInstance.SetType_(value : TFhirString);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirImagingStudySeriesInstance.GetType_ST : String;
begin
  if FType_ = nil then
    result := ''
  else
    result := FType_.value;
end;

Procedure TFhirImagingStudySeriesInstance.SetType_ST(value : String);
begin
  if value <> '' then
  begin
    if FType_ = nil then
      FType_ := TFhirString.create;
    FType_.value := value
  end
  else if FType_ <> nil then
    FType_.value := '';
end;

Procedure TFhirImagingStudySeriesInstance.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

Function TFhirImagingStudySeriesInstance.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

Procedure TFhirImagingStudySeriesInstance.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

Function TFhirImagingStudySeriesInstance.GetContentList : TFhirAttachmentList;
begin
  if FContentList = nil then
    FContentList := TFhirAttachmentList.Create;
  result := FContentList;
end;

Function TFhirImagingStudySeriesInstance.GetHasContentList : boolean;
begin
  result := (FContentList <> nil) and (FContentList.count > 0);
end;

function TFhirImagingStudySeriesInstance.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FNumber.sizeInBytes);
  inc(result, FUid.sizeInBytes);
  inc(result, FSopClass.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FTitle.sizeInBytes);
  inc(result, FcontentList.sizeInBytes);
end;

{ TFhirImagingStudySeriesInstanceListEnumerator }

Constructor TFhirImagingStudySeriesInstanceListEnumerator.Create(list : TFhirImagingStudySeriesInstanceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImagingStudySeriesInstanceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImagingStudySeriesInstanceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImagingStudySeriesInstanceListEnumerator.GetCurrent : TFhirImagingStudySeriesInstance;
begin
  Result := FList[FIndex];
end;

function TFhirImagingStudySeriesInstanceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImagingStudySeriesInstanceList }
procedure TFhirImagingStudySeriesInstanceList.AddItem(value: TFhirImagingStudySeriesInstance);
begin
  assert(value.ClassName = 'TFhirImagingStudySeriesInstance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImagingStudySeriesInstance');
  add(value);
end;

function TFhirImagingStudySeriesInstanceList.Append: TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingStudySeriesInstanceList.ClearItems;
begin
  Clear;
end;

function TFhirImagingStudySeriesInstanceList.GetEnumerator : TFhirImagingStudySeriesInstanceListEnumerator;
begin
  result := TFhirImagingStudySeriesInstanceListEnumerator.Create(self.link);
end;

function TFhirImagingStudySeriesInstanceList.Clone: TFhirImagingStudySeriesInstanceList;
begin
  result := TFhirImagingStudySeriesInstanceList(inherited Clone);
end;

function TFhirImagingStudySeriesInstanceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImagingStudySeriesInstanceList.GetItemN(index: Integer): TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance(ObjectByIndex[index]);
end;

function TFhirImagingStudySeriesInstanceList.ItemClass: TFslObjectClass;
begin
  result := TFhirImagingStudySeriesInstance;
end;
function TFhirImagingStudySeriesInstanceList.IndexOf(value: TFhirImagingStudySeriesInstance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImagingStudySeriesInstanceList.Insert(index: Integer): TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingStudySeriesInstanceList.InsertItem(index: Integer; value: TFhirImagingStudySeriesInstance);
begin
  assert(value is TFhirImagingStudySeriesInstance);
  Inherited Insert(index, value);
end;

function TFhirImagingStudySeriesInstanceList.Item(index: Integer): TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance(ObjectByIndex[index]);
end;

function TFhirImagingStudySeriesInstanceList.Link: TFhirImagingStudySeriesInstanceList;
begin
  result := TFhirImagingStudySeriesInstanceList(inherited Link);
end;

procedure TFhirImagingStudySeriesInstanceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImagingStudySeriesInstanceList.SetItemByIndex(index: Integer; value: TFhirImagingStudySeriesInstance);
begin
  assert(value is TFhirImagingStudySeriesInstance);
  FhirImagingStudySeriesInstances[index] := value;
end;

procedure TFhirImagingStudySeriesInstanceList.SetItemN(index: Integer; value: TFhirImagingStudySeriesInstance);
begin
  assert(value is TFhirImagingStudySeriesInstance);
  ObjectByIndex[index] := value;
end;

{ TFhirImagingStudy }

constructor TFhirImagingStudy.Create;
begin
  inherited;
end;

destructor TFhirImagingStudy.Destroy;
begin
  FStarted.free;
  FPatient.free;
  FUid.free;
  FAccession.free;
  FIdentifierList.Free;
  FOrderList.Free;
  FModalityListList.Free;
  FReferrer.free;
  FAvailability.free;
  FUrl.free;
  FNumberOfSeries.free;
  FNumberOfInstances.free;
  FProcedure_List.Free;
  FInterpreter.free;
  FDescription.free;
  FSeriesList.Free;
  inherited;
end;

function TFhirImagingStudy.GetResourceType : TFhirResourceType;
begin
  result := frtImagingStudy;
end;

procedure TFhirImagingStudy.Assign(oSource : TFslObject);
begin
  inherited;
  startedElement := TFhirImagingStudy(oSource).startedElement.Clone;
  patient := TFhirImagingStudy(oSource).patient.Clone;
  uidElement := TFhirImagingStudy(oSource).uidElement.Clone;
  accession := TFhirImagingStudy(oSource).accession.Clone;
  if (TFhirImagingStudy(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirImagingStudy(oSource).FIdentifierList);
  end;
  if (TFhirImagingStudy(oSource).FOrderList = nil) then
  begin
    FOrderList.free;
    FOrderList := nil;
  end
  else
  begin
    if FOrderList = nil then
      FOrderList := TFhirReferenceList{TFhirDiagnosticOrder}.Create;
    FOrderList.Assign(TFhirImagingStudy(oSource).FOrderList);
  end;
  if (TFhirImagingStudy(oSource).FModalityListList = nil) then
  begin
    FModalityListList.free;
    FModalityListList := nil;
  end
  else
  begin
    if FModalityListList = nil then
      FModalityListList := TFhirCodingList.Create;
    FModalityListList.Assign(TFhirImagingStudy(oSource).FModalityListList);
  end;
  referrer := TFhirImagingStudy(oSource).referrer.Clone;
  FAvailability := TFhirImagingStudy(oSource).FAvailability.Link;
  urlElement := TFhirImagingStudy(oSource).urlElement.Clone;
  numberOfSeriesElement := TFhirImagingStudy(oSource).numberOfSeriesElement.Clone;
  numberOfInstancesElement := TFhirImagingStudy(oSource).numberOfInstancesElement.Clone;
  if (TFhirImagingStudy(oSource).FProcedure_List = nil) then
  begin
    FProcedure_List.free;
    FProcedure_List := nil;
  end
  else
  begin
    if FProcedure_List = nil then
      FProcedure_List := TFhirReferenceList{TFhirProcedure}.Create;
    FProcedure_List.Assign(TFhirImagingStudy(oSource).FProcedure_List);
  end;
  interpreter := TFhirImagingStudy(oSource).interpreter.Clone;
  descriptionElement := TFhirImagingStudy(oSource).descriptionElement.Clone;
  if (TFhirImagingStudy(oSource).FSeriesList = nil) then
  begin
    FSeriesList.free;
    FSeriesList := nil;
  end
  else
  begin
    if FSeriesList = nil then
      FSeriesList := TFhirImagingStudySeriesList.Create;
    FSeriesList.Assign(TFhirImagingStudy(oSource).FSeriesList);
  end;
end;

procedure TFhirImagingStudy.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'started') Then
     list.add(self.link, 'started', FStarted.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'uid') Then
     list.add(self.link, 'uid', FUid.Link);
  if (child_name = 'accession') Then
     list.add(self.link, 'accession', FAccession.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'order') Then
    list.addAll(self, 'order', FOrderList);
  if (child_name = 'modalityList') Then
    list.addAll(self, 'modalityList', FModalityListList);
  if (child_name = 'referrer') Then
     list.add(self.link, 'referrer', FReferrer.Link);
  if (child_name = 'availability') Then
     list.add(self.link, 'availability', FAvailability.Link);
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'numberOfSeries') Then
     list.add(self.link, 'numberOfSeries', FNumberOfSeries.Link);
  if (child_name = 'numberOfInstances') Then
     list.add(self.link, 'numberOfInstances', FNumberOfInstances.Link);
  if (child_name = 'procedure') Then
    list.addAll(self, 'procedure', FProcedure_List);
  if (child_name = 'interpreter') Then
     list.add(self.link, 'interpreter', FInterpreter.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'series') Then
    list.addAll(self, 'series', FSeriesList);
end;

procedure TFhirImagingStudy.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'started', 'dateTime', false, TFhirDateTime, FStarted.Link));{2}
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'uid', 'oid', false, TFhirOid, FUid.Link));{2}
  oList.add(TFHIRProperty.create(self, 'accession', 'Identifier', false, TFhirIdentifier, FAccession.Link));{2}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'order', 'Reference(DiagnosticOrder)', true, TFhirReference{TFhirDiagnosticOrder}, FOrderList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'modalityList', 'Coding', true, TFhirCoding, FModalityListList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'referrer', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FReferrer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'availability', 'code', false, TFHIREnum, FAvailability.Link));{1}
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));{2}
  oList.add(TFHIRProperty.create(self, 'numberOfSeries', 'unsignedInt', false, TFhirUnsignedInt, FNumberOfSeries.Link));{2}
  oList.add(TFHIRProperty.create(self, 'numberOfInstances', 'unsignedInt', false, TFhirUnsignedInt, FNumberOfInstances.Link));{2}
  oList.add(TFHIRProperty.create(self, 'procedure', 'Reference(Procedure)', true, TFhirReference{TFhirProcedure}, FProcedure_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'interpreter', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FInterpreter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'series', '', true, TFhirImagingStudySeries, FSeriesList.Link)){3};
end;

function TFhirImagingStudy.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'started') then
  begin
    StartedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'uid') then
  begin
    UidElement := asOid(propValue){5a};
    result := propValue;
  end
  else if (propName = 'accession') then
  begin
    Accession := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'order') then
  begin
    OrderList.add(propValue as TFhirReference{TFhirDiagnosticOrder}){2a};
    result := propValue;
  end
  else if (propName = 'modalityList') then
  begin
    ModalityListList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else if (propName = 'referrer') then
  begin
    Referrer := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'availability') then
  begin
    AvailabilityElement := asEnum(SYSTEMS_TFhirInstanceAvailabilityEnum, CODES_TFhirInstanceAvailabilityEnum, propValue);
    result := propValue
  end
  else if (propName = 'url') then
  begin
    UrlElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'numberOfSeries') then
  begin
    NumberOfSeriesElement := asUnsignedInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'numberOfInstances') then
  begin
    NumberOfInstancesElement := asUnsignedInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'procedure') then
  begin
    Procedure_List.add(propValue as TFhirReference{TFhirProcedure}){2a};
    result := propValue;
  end
  else if (propName = 'interpreter') then
  begin
    Interpreter := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'series') then
  begin
    SeriesList.add(propValue as TFhirImagingStudySeries){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirImagingStudy.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'order') then OrderList.insertItem(index, propValue as TFhirReference{TFhirDiagnosticOrder}){2a}
  else if (propName = 'modalityList') then ModalityListList.insertItem(index, propValue as TFhirCoding){2a}
  else if (propName = 'procedure') then Procedure_List.insertItem(index, propValue as TFhirReference{TFhirProcedure}){2a}
  else if (propName = 'series') then SeriesList.insertItem(index, propValue as TFhirImagingStudySeries){2a}
  else inherited;
end;

function TFhirImagingStudy.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'started') then result := TFhirDateTime.create() {5b}
  else if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'uid') then result := TFhirOid.create() {5b}
  else if (propName = 'accession') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'order') then result := OrderList.new(){2}
  else if (propName = 'modalityList') then result := ModalityListList.new(){2}
  else if (propName = 'referrer') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'url') then result := TFhirUri.create() {5b}
  else if (propName = 'numberOfSeries') then result := TFhirUnsignedInt.create() {5b}
  else if (propName = 'numberOfInstances') then result := TFhirUnsignedInt.create() {5b}
  else if (propName = 'procedure') then result := Procedure_List.new(){2}
  else if (propName = 'interpreter') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'series') then result := SeriesList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImagingStudy.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'started') then result := 'dateTime'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'uid') then result := 'oid'
  else if (propName = 'accession') then result := 'Identifier'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'order') then result := 'Reference'
  else if (propName = 'modalityList') then result := 'Coding'
  else if (propName = 'referrer') then result := 'Reference'
  else if (propName = 'availability') then result := 'code'
  else if (propName = 'url') then result := 'uri'
  else if (propName = 'numberOfSeries') then result := 'unsignedInt'
  else if (propName = 'numberOfInstances') then result := 'unsignedInt'
  else if (propName = 'procedure') then result := 'Reference'
  else if (propName = 'interpreter') then result := 'Reference'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'series') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImagingStudy.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'started') then StartedElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'uid') then UidElement := nil
  else if (propName = 'accession') then AccessionElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'order') then deletePropertyValue('order', OrderList, value) {2}
  else if (propName = 'modalityList') then deletePropertyValue('modalityList', ModalityListList, value) {2}
  else if (propName = 'referrer') then ReferrerElement := nil
  else if (propName = 'availability') then AvailabilityElement := nil
  else if (propName = 'url') then UrlElement := nil
  else if (propName = 'numberOfSeries') then NumberOfSeriesElement := nil
  else if (propName = 'numberOfInstances') then NumberOfInstancesElement := nil
  else if (propName = 'procedure') then deletePropertyValue('procedure', Procedure_List, value) {2}
  else if (propName = 'interpreter') then InterpreterElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'series') then deletePropertyValue('series', SeriesList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImagingStudy.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'started') then StartedElement := asDateTime(new){5b}
  else if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'uid') then UidElement := asOid(new){5b}
  else if (propName = 'accession') then AccessionElement := new as TFhirIdentifier{4}
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'order') then replacePropertyValue('order', OrderList, existing, new) {2}
  else if (propName = 'modalityList') then replacePropertyValue('modalityList', ModalityListList, existing, new) {2}
  else if (propName = 'referrer') then ReferrerElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'availability') then AvailabilityElement := asEnum(SYSTEMS_TFhirInstanceAvailabilityEnum, CODES_TFhirInstanceAvailabilityEnum, new){4}
  else if (propName = 'url') then UrlElement := asUri(new){5b}
  else if (propName = 'numberOfSeries') then NumberOfSeriesElement := asUnsignedInt(new){5b}
  else if (propName = 'numberOfInstances') then NumberOfInstancesElement := asUnsignedInt(new){5b}
  else if (propName = 'procedure') then replacePropertyValue('procedure', Procedure_List, existing, new) {2}
  else if (propName = 'interpreter') then InterpreterElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'series') then replacePropertyValue('series', SeriesList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImagingStudy.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'order') then OrderList.move(source, destination){2a}
  else if (propName = 'modalityList') then ModalityListList.move(source, destination){2a}
  else if (propName = 'procedure') then Procedure_List.move(source, destination){2a}
  else if (propName = 'series') then SeriesList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImagingStudy.fhirType : string;
begin
  result := 'ImagingStudy';
end;

function TFhirImagingStudy.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FStarted) and isEmptyProp(FPatient) and isEmptyProp(FUid) and isEmptyProp(FAccession) and isEmptyProp(FidentifierList) and isEmptyProp(ForderList) and isEmptyProp(FmodalityListList) and isEmptyProp(FReferrer) and isEmptyProp(FAvailability) and isEmptyProp(FUrl) and isEmptyProp(FNumberOfSeries) and isEmptyProp(FNumberOfInstances) and isEmptyProp(Fprocedure_List) and isEmptyProp(FInterpreter) and isEmptyProp(FDescription) and isEmptyProp(FseriesList);
end;

function TFhirImagingStudy.equals(other : TObject) : boolean;
var
  o : TFhirImagingStudy;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImagingStudy)) then
    result := false
  else
  begin
    o := TFhirImagingStudy(other);
    result := compareDeep(startedElement, o.startedElement, true) and compareDeep(patientElement, o.patientElement, true) and
      compareDeep(uidElement, o.uidElement, true) and compareDeep(accessionElement, o.accessionElement, true) and
      compareDeep(identifierList, o.identifierList, true) and compareDeep(orderList, o.orderList, true) and
      compareDeep(modalityListList, o.modalityListList, true) and compareDeep(referrerElement, o.referrerElement, true) and
      compareDeep(availabilityElement, o.availabilityElement, true) and compareDeep(urlElement, o.urlElement, true) and
      compareDeep(numberOfSeriesElement, o.numberOfSeriesElement, true) and compareDeep(numberOfInstancesElement, o.numberOfInstancesElement, true) and
      compareDeep(procedure_List, o.procedure_List, true) and compareDeep(interpreterElement, o.interpreterElement, true) and
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(seriesList, o.seriesList, true);
  end;
end;

function TFhirImagingStudy.Link : TFhirImagingStudy;
begin
  result := TFhirImagingStudy(inherited Link);
end;

function TFhirImagingStudy.Clone : TFhirImagingStudy;
begin
  result := TFhirImagingStudy(inherited Clone);
end;

procedure TFhirImagingStudy.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('started');
  fields.add('patient');
  fields.add('uid');
  fields.add('accession');
  fields.add('identifier');
  fields.add('order');
  fields.add('modalityList');
  fields.add('referrer');
  fields.add('availability');
  fields.add('url');
  fields.add('numberOfSeries');
  fields.add('numberOfInstances');
  fields.add('procedure');
  fields.add('interpreter');
  fields.add('description');
  fields.add('series');
end;

{ TFhirImagingStudy }

Procedure TFhirImagingStudy.SetStarted(value : TFhirDateTime);
begin
  FStarted.free;
  FStarted := value;
end;

Function TFhirImagingStudy.GetStartedST : TFslDateTime;
begin
  if FStarted = nil then
    result := TFslDateTime.makeNull
  else
    result := FStarted.value;
end;

Procedure TFhirImagingStudy.SetStartedST(value : TFslDateTime);
begin
  if FStarted = nil then
    FStarted := TFhirDateTime.create;
  FStarted.value := value
end;

Procedure TFhirImagingStudy.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Procedure TFhirImagingStudy.SetUid(value : TFhirOid);
begin
  FUid.free;
  FUid := value;
end;

Function TFhirImagingStudy.GetUidST : String;
begin
  if FUid = nil then
    result := ''
  else
    result := FUid.value;
end;

Procedure TFhirImagingStudy.SetUidST(value : String);
begin
  if value <> '' then
  begin
    if FUid = nil then
      FUid := TFhirOid.create;
    FUid.value := value
  end
  else if FUid <> nil then
    FUid.value := '';
end;

Procedure TFhirImagingStudy.SetAccession(value : TFhirIdentifier);
begin
  FAccession.free;
  FAccession := value;
end;

Function TFhirImagingStudy.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirImagingStudy.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Function TFhirImagingStudy.GetOrderList : TFhirReferenceList{TFhirDiagnosticOrder};
begin
  if FOrderList = nil then
    FOrderList := TFhirReferenceList{TFhirDiagnosticOrder}.Create;
  result := FOrderList;
end;

Function TFhirImagingStudy.GetHasOrderList : boolean;
begin
  result := (FOrderList <> nil) and (FOrderList.count > 0);
end;

Function TFhirImagingStudy.GetModalityListList : TFhirCodingList;
begin
  if FModalityListList = nil then
    FModalityListList := TFhirCodingList.Create;
  result := FModalityListList;
end;

Function TFhirImagingStudy.GetHasModalityListList : boolean;
begin
  result := (FModalityListList <> nil) and (FModalityListList.count > 0);
end;

Procedure TFhirImagingStudy.SetReferrer(value : TFhirReference{TFhirPractitioner});
begin
  FReferrer.free;
  FReferrer := value;
end;

Procedure TFhirImagingStudy.SetAvailability(value : TFhirEnum);
begin
  FAvailability.free;
  FAvailability := value;
end;

Function TFhirImagingStudy.GetAvailabilityST : TFhirInstanceAvailabilityEnum;
begin
  if FAvailability = nil then
    result := TFhirInstanceAvailabilityEnum(0)
  else
    result := TFhirInstanceAvailabilityEnum(StringArrayIndexOfSensitive(CODES_TFhirInstanceAvailabilityEnum, FAvailability.value));
end;

Procedure TFhirImagingStudy.SetAvailabilityST(value : TFhirInstanceAvailabilityEnum);
begin
  if ord(value) = 0 then
    AvailabilityElement := nil
  else
    AvailabilityElement := TFhirEnum.create(SYSTEMS_TFhirInstanceAvailabilityEnum[value], CODES_TFhirInstanceAvailabilityEnum[value]);
end;

Procedure TFhirImagingStudy.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirImagingStudy.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

Procedure TFhirImagingStudy.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

Procedure TFhirImagingStudy.SetNumberOfSeries(value : TFhirUnsignedInt);
begin
  FNumberOfSeries.free;
  FNumberOfSeries := value;
end;

Function TFhirImagingStudy.GetNumberOfSeriesST : String;
begin
  if FNumberOfSeries = nil then
    result := ''
  else
    result := FNumberOfSeries.value;
end;

Procedure TFhirImagingStudy.SetNumberOfSeriesST(value : String);
begin
  if value <> '' then
  begin
    if FNumberOfSeries = nil then
      FNumberOfSeries := TFhirUnsignedInt.create;
    FNumberOfSeries.value := value
  end
  else if FNumberOfSeries <> nil then
    FNumberOfSeries.value := '';
end;

Procedure TFhirImagingStudy.SetNumberOfInstances(value : TFhirUnsignedInt);
begin
  FNumberOfInstances.free;
  FNumberOfInstances := value;
end;

Function TFhirImagingStudy.GetNumberOfInstancesST : String;
begin
  if FNumberOfInstances = nil then
    result := ''
  else
    result := FNumberOfInstances.value;
end;

Procedure TFhirImagingStudy.SetNumberOfInstancesST(value : String);
begin
  if value <> '' then
  begin
    if FNumberOfInstances = nil then
      FNumberOfInstances := TFhirUnsignedInt.create;
    FNumberOfInstances.value := value
  end
  else if FNumberOfInstances <> nil then
    FNumberOfInstances.value := '';
end;

Function TFhirImagingStudy.GetProcedure_List : TFhirReferenceList{TFhirProcedure};
begin
  if FProcedure_List = nil then
    FProcedure_List := TFhirReferenceList{TFhirProcedure}.Create;
  result := FProcedure_List;
end;

Function TFhirImagingStudy.GetHasProcedure_List : boolean;
begin
  result := (FProcedure_List <> nil) and (FProcedure_List.count > 0);
end;

Procedure TFhirImagingStudy.SetInterpreter(value : TFhirReference{TFhirPractitioner});
begin
  FInterpreter.free;
  FInterpreter := value;
end;

Procedure TFhirImagingStudy.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirImagingStudy.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirImagingStudy.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Function TFhirImagingStudy.GetSeriesList : TFhirImagingStudySeriesList;
begin
  if FSeriesList = nil then
    FSeriesList := TFhirImagingStudySeriesList.Create;
  result := FSeriesList;
end;

Function TFhirImagingStudy.GetHasSeriesList : boolean;
begin
  result := (FSeriesList <> nil) and (FSeriesList.count > 0);
end;

function TFhirImagingStudy.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FStarted.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FUid.sizeInBytes);
  inc(result, FAccession.sizeInBytes);
  inc(result, FidentifierList.sizeInBytes);
  inc(result, ForderList.sizeInBytes);
  inc(result, FmodalityListList.sizeInBytes);
  inc(result, FReferrer.sizeInBytes);
  inc(result, FAvailability.sizeInBytes);
  inc(result, FUrl.sizeInBytes);
  inc(result, FNumberOfSeries.sizeInBytes);
  inc(result, FNumberOfInstances.sizeInBytes);
  inc(result, Fprocedure_List.sizeInBytes);
  inc(result, FInterpreter.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FseriesList.sizeInBytes);
end;

{ TFhirImagingStudyListEnumerator }

Constructor TFhirImagingStudyListEnumerator.Create(list : TFhirImagingStudyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImagingStudyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImagingStudyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImagingStudyListEnumerator.GetCurrent : TFhirImagingStudy;
begin
  Result := FList[FIndex];
end;

function TFhirImagingStudyListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImagingStudyList }
procedure TFhirImagingStudyList.AddItem(value: TFhirImagingStudy);
begin
  assert(value.ClassName = 'TFhirImagingStudy', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImagingStudy');
  add(value);
end;

function TFhirImagingStudyList.Append: TFhirImagingStudy;
begin
  result := TFhirImagingStudy.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingStudyList.ClearItems;
begin
  Clear;
end;

function TFhirImagingStudyList.GetEnumerator : TFhirImagingStudyListEnumerator;
begin
  result := TFhirImagingStudyListEnumerator.Create(self.link);
end;

function TFhirImagingStudyList.Clone: TFhirImagingStudyList;
begin
  result := TFhirImagingStudyList(inherited Clone);
end;

function TFhirImagingStudyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImagingStudyList.GetItemN(index: Integer): TFhirImagingStudy;
begin
  result := TFhirImagingStudy(ObjectByIndex[index]);
end;

function TFhirImagingStudyList.ItemClass: TFslObjectClass;
begin
  result := TFhirImagingStudy;
end;
function TFhirImagingStudyList.IndexOf(value: TFhirImagingStudy): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImagingStudyList.Insert(index: Integer): TFhirImagingStudy;
begin
  result := TFhirImagingStudy.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingStudyList.InsertItem(index: Integer; value: TFhirImagingStudy);
begin
  assert(value is TFhirImagingStudy);
  Inherited Insert(index, value);
end;

function TFhirImagingStudyList.Item(index: Integer): TFhirImagingStudy;
begin
  result := TFhirImagingStudy(ObjectByIndex[index]);
end;

function TFhirImagingStudyList.Link: TFhirImagingStudyList;
begin
  result := TFhirImagingStudyList(inherited Link);
end;

procedure TFhirImagingStudyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImagingStudyList.SetItemByIndex(index: Integer; value: TFhirImagingStudy);
begin
  assert(value is TFhirImagingStudy);
  FhirImagingStudies[index] := value;
end;

procedure TFhirImagingStudyList.SetItemN(index: Integer; value: TFhirImagingStudy);
begin
  assert(value is TFhirImagingStudy);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_IMAGINGSTUDY}

{$IFDEF FHIR_IMMUNIZATION}

{ TFhirImmunizationExplanation }

constructor TFhirImmunizationExplanation.Create;
begin
  inherited;
end;

destructor TFhirImmunizationExplanation.Destroy;
begin
  FReasonList.Free;
  FReasonNotGivenList.Free;
  inherited;
end;

procedure TFhirImmunizationExplanation.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirImmunizationExplanation(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableConceptList.Create;
    FReasonList.Assign(TFhirImmunizationExplanation(oSource).FReasonList);
  end;
  if (TFhirImmunizationExplanation(oSource).FReasonNotGivenList = nil) then
  begin
    FReasonNotGivenList.free;
    FReasonNotGivenList := nil;
  end
  else
  begin
    if FReasonNotGivenList = nil then
      FReasonNotGivenList := TFhirCodeableConceptList.Create;
    FReasonNotGivenList.Assign(TFhirImmunizationExplanation(oSource).FReasonNotGivenList);
  end;
end;

procedure TFhirImmunizationExplanation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'reasonNotGiven') Then
    list.addAll(self, 'reasonNotGiven', FReasonNotGivenList);
end;

procedure TFhirImmunizationExplanation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', true, TFhirCodeableConcept, FReasonList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reasonNotGiven', 'CodeableConcept', true, TFhirCodeableConcept, FReasonNotGivenList.Link)){3};
end;

function TFhirImmunizationExplanation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'reasonNotGiven') then
  begin
    ReasonNotGivenList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImmunizationExplanation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'reasonNotGiven') then ReasonNotGivenList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirImmunizationExplanation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'reason') then result := ReasonList.new(){2}
  else if (propName = 'reasonNotGiven') then result := ReasonNotGivenList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImmunizationExplanation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'reason') then result := 'CodeableConcept'
  else if (propName = 'reasonNotGiven') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImmunizationExplanation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value) {2}
  else if (propName = 'reasonNotGiven') then deletePropertyValue('reasonNotGiven', ReasonNotGivenList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImmunizationExplanation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new) {2}
  else if (propName = 'reasonNotGiven') then replacePropertyValue('reasonNotGiven', ReasonNotGivenList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImmunizationExplanation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'reason') then ReasonList.move(source, destination){2a}
  else if (propName = 'reasonNotGiven') then ReasonNotGivenList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImmunizationExplanation.fhirType : string;
begin
  result := 'explanation';
end;

function TFhirImmunizationExplanation.Link : TFhirImmunizationExplanation;
begin
  result := TFhirImmunizationExplanation(inherited Link);
end;

function TFhirImmunizationExplanation.Clone : TFhirImmunizationExplanation;
begin
  result := TFhirImmunizationExplanation(inherited Clone);
end;

function TFhirImmunizationExplanation.equals(other : TObject) : boolean;
var
  o : TFhirImmunizationExplanation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImmunizationExplanation)) then
    result := false
  else
  begin
    o := TFhirImmunizationExplanation(other);
    result := compareDeep(reasonList, o.reasonList, true) and compareDeep(reasonNotGivenList, o.reasonNotGivenList, true);
  end;
end;

function TFhirImmunizationExplanation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FreasonList) and isEmptyProp(FreasonNotGivenList);
end;

procedure TFhirImmunizationExplanation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('reason');
  fields.add('reasonNotGiven');
end;

{ TFhirImmunizationExplanation }

Function TFhirImmunizationExplanation.GetReasonList : TFhirCodeableConceptList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableConceptList.Create;
  result := FReasonList;
end;

Function TFhirImmunizationExplanation.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

Function TFhirImmunizationExplanation.GetReasonNotGivenList : TFhirCodeableConceptList;
begin
  if FReasonNotGivenList = nil then
    FReasonNotGivenList := TFhirCodeableConceptList.Create;
  result := FReasonNotGivenList;
end;

Function TFhirImmunizationExplanation.GetHasReasonNotGivenList : boolean;
begin
  result := (FReasonNotGivenList <> nil) and (FReasonNotGivenList.count > 0);
end;

function TFhirImmunizationExplanation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FreasonList.sizeInBytes);
  inc(result, FreasonNotGivenList.sizeInBytes);
end;

{ TFhirImmunizationExplanationListEnumerator }

Constructor TFhirImmunizationExplanationListEnumerator.Create(list : TFhirImmunizationExplanationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImmunizationExplanationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImmunizationExplanationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImmunizationExplanationListEnumerator.GetCurrent : TFhirImmunizationExplanation;
begin
  Result := FList[FIndex];
end;

function TFhirImmunizationExplanationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImmunizationExplanationList }
procedure TFhirImmunizationExplanationList.AddItem(value: TFhirImmunizationExplanation);
begin
  assert(value.ClassName = 'TFhirImmunizationExplanation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationExplanation');
  add(value);
end;

function TFhirImmunizationExplanationList.Append: TFhirImmunizationExplanation;
begin
  result := TFhirImmunizationExplanation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationExplanationList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationExplanationList.GetEnumerator : TFhirImmunizationExplanationListEnumerator;
begin
  result := TFhirImmunizationExplanationListEnumerator.Create(self.link);
end;

function TFhirImmunizationExplanationList.Clone: TFhirImmunizationExplanationList;
begin
  result := TFhirImmunizationExplanationList(inherited Clone);
end;

function TFhirImmunizationExplanationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationExplanationList.GetItemN(index: Integer): TFhirImmunizationExplanation;
begin
  result := TFhirImmunizationExplanation(ObjectByIndex[index]);
end;

function TFhirImmunizationExplanationList.ItemClass: TFslObjectClass;
begin
  result := TFhirImmunizationExplanation;
end;
function TFhirImmunizationExplanationList.IndexOf(value: TFhirImmunizationExplanation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImmunizationExplanationList.Insert(index: Integer): TFhirImmunizationExplanation;
begin
  result := TFhirImmunizationExplanation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationExplanationList.InsertItem(index: Integer; value: TFhirImmunizationExplanation);
begin
  assert(value is TFhirImmunizationExplanation);
  Inherited Insert(index, value);
end;

function TFhirImmunizationExplanationList.Item(index: Integer): TFhirImmunizationExplanation;
begin
  result := TFhirImmunizationExplanation(ObjectByIndex[index]);
end;

function TFhirImmunizationExplanationList.Link: TFhirImmunizationExplanationList;
begin
  result := TFhirImmunizationExplanationList(inherited Link);
end;

procedure TFhirImmunizationExplanationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationExplanationList.SetItemByIndex(index: Integer; value: TFhirImmunizationExplanation);
begin
  assert(value is TFhirImmunizationExplanation);
  FhirImmunizationExplanations[index] := value;
end;

procedure TFhirImmunizationExplanationList.SetItemN(index: Integer; value: TFhirImmunizationExplanation);
begin
  assert(value is TFhirImmunizationExplanation);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunizationReaction }

constructor TFhirImmunizationReaction.Create;
begin
  inherited;
end;

destructor TFhirImmunizationReaction.Destroy;
begin
  FDate.free;
  FDetail.free;
  FReported.free;
  inherited;
end;

procedure TFhirImmunizationReaction.Assign(oSource : TFslObject);
begin
  inherited;
  dateElement := TFhirImmunizationReaction(oSource).dateElement.Clone;
  detail := TFhirImmunizationReaction(oSource).detail.Clone;
  reportedElement := TFhirImmunizationReaction(oSource).reportedElement.Clone;
end;

procedure TFhirImmunizationReaction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'detail') Then
     list.add(self.link, 'detail', FDetail.Link);
  if (child_name = 'reported') Then
     list.add(self.link, 'reported', FReported.Link);
end;

procedure TFhirImmunizationReaction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'detail', 'Reference(Observation)', false, TFhirReference{TFhirObservation}, FDetail.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reported', 'boolean', false, TFhirBoolean, FReported.Link));{2}
end;

function TFhirImmunizationReaction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    Detail := propValue as TFhirReference{TFhirObservation}{4b};
    result := propValue;
  end
  else if (propName = 'reported') then
  begin
    ReportedElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImmunizationReaction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirImmunizationReaction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'detail') then result := TFhirReference{TFhirObservation}.create(){4b}
  else if (propName = 'reported') then result := TFhirBoolean.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImmunizationReaction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'date') then result := 'dateTime'
  else if (propName = 'detail') then result := 'Reference'
  else if (propName = 'reported') then result := 'boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImmunizationReaction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'date') then DateElement := nil
  else if (propName = 'detail') then DetailElement := nil
  else if (propName = 'reported') then ReportedElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImmunizationReaction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'detail') then DetailElement := new as TFhirReference{TFhirObservation}{4}
  else if (propName = 'reported') then ReportedElement := asBoolean(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImmunizationReaction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirImmunizationReaction.fhirType : string;
begin
  result := 'reaction';
end;

function TFhirImmunizationReaction.Link : TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction(inherited Link);
end;

function TFhirImmunizationReaction.Clone : TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction(inherited Clone);
end;

function TFhirImmunizationReaction.equals(other : TObject) : boolean;
var
  o : TFhirImmunizationReaction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImmunizationReaction)) then
    result := false
  else
  begin
    o := TFhirImmunizationReaction(other);
    result := compareDeep(dateElement, o.dateElement, true) and compareDeep(detailElement, o.detailElement, true) and
      compareDeep(reportedElement, o.reportedElement, true);
  end;
end;

function TFhirImmunizationReaction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDate) and isEmptyProp(FDetail) and isEmptyProp(FReported);
end;

procedure TFhirImmunizationReaction.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('date');
  fields.add('detail');
  fields.add('reported');
end;

{ TFhirImmunizationReaction }

Procedure TFhirImmunizationReaction.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirImmunizationReaction.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirImmunizationReaction.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirImmunizationReaction.SetDetail(value : TFhirReference{TFhirObservation});
begin
  FDetail.free;
  FDetail := value;
end;

Procedure TFhirImmunizationReaction.SetReported(value : TFhirBoolean);
begin
  FReported.free;
  FReported := value;
end;

Function TFhirImmunizationReaction.GetReportedST : Boolean;
begin
  if FReported = nil then
    result := false
  else
    result := FReported.value;
end;

Procedure TFhirImmunizationReaction.SetReportedST(value : Boolean);
begin
  if FReported = nil then
    FReported := TFhirBoolean.create;
  FReported.value := value
end;

function TFhirImmunizationReaction.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDate.sizeInBytes);
  inc(result, FDetail.sizeInBytes);
  inc(result, FReported.sizeInBytes);
end;

{ TFhirImmunizationReactionListEnumerator }

Constructor TFhirImmunizationReactionListEnumerator.Create(list : TFhirImmunizationReactionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImmunizationReactionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImmunizationReactionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImmunizationReactionListEnumerator.GetCurrent : TFhirImmunizationReaction;
begin
  Result := FList[FIndex];
end;

function TFhirImmunizationReactionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImmunizationReactionList }
procedure TFhirImmunizationReactionList.AddItem(value: TFhirImmunizationReaction);
begin
  assert(value.ClassName = 'TFhirImmunizationReaction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationReaction');
  add(value);
end;

function TFhirImmunizationReactionList.Append: TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationReactionList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationReactionList.GetEnumerator : TFhirImmunizationReactionListEnumerator;
begin
  result := TFhirImmunizationReactionListEnumerator.Create(self.link);
end;

function TFhirImmunizationReactionList.Clone: TFhirImmunizationReactionList;
begin
  result := TFhirImmunizationReactionList(inherited Clone);
end;

function TFhirImmunizationReactionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationReactionList.GetItemN(index: Integer): TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction(ObjectByIndex[index]);
end;

function TFhirImmunizationReactionList.ItemClass: TFslObjectClass;
begin
  result := TFhirImmunizationReaction;
end;
function TFhirImmunizationReactionList.IndexOf(value: TFhirImmunizationReaction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImmunizationReactionList.Insert(index: Integer): TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationReactionList.InsertItem(index: Integer; value: TFhirImmunizationReaction);
begin
  assert(value is TFhirImmunizationReaction);
  Inherited Insert(index, value);
end;

function TFhirImmunizationReactionList.Item(index: Integer): TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction(ObjectByIndex[index]);
end;

function TFhirImmunizationReactionList.Link: TFhirImmunizationReactionList;
begin
  result := TFhirImmunizationReactionList(inherited Link);
end;

procedure TFhirImmunizationReactionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationReactionList.SetItemByIndex(index: Integer; value: TFhirImmunizationReaction);
begin
  assert(value is TFhirImmunizationReaction);
  FhirImmunizationReactions[index] := value;
end;

procedure TFhirImmunizationReactionList.SetItemN(index: Integer; value: TFhirImmunizationReaction);
begin
  assert(value is TFhirImmunizationReaction);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunizationVaccinationProtocol }

constructor TFhirImmunizationVaccinationProtocol.Create;
begin
  inherited;
end;

destructor TFhirImmunizationVaccinationProtocol.Destroy;
begin
  FDoseSequence.free;
  FDescription.free;
  FAuthority.free;
  FSeries.free;
  FSeriesDoses.free;
  FTargetDiseaseList.Free;
  FDoseStatus.free;
  FDoseStatusReason.free;
  inherited;
end;

procedure TFhirImmunizationVaccinationProtocol.Assign(oSource : TFslObject);
begin
  inherited;
  doseSequenceElement := TFhirImmunizationVaccinationProtocol(oSource).doseSequenceElement.Clone;
  descriptionElement := TFhirImmunizationVaccinationProtocol(oSource).descriptionElement.Clone;
  authority := TFhirImmunizationVaccinationProtocol(oSource).authority.Clone;
  seriesElement := TFhirImmunizationVaccinationProtocol(oSource).seriesElement.Clone;
  seriesDosesElement := TFhirImmunizationVaccinationProtocol(oSource).seriesDosesElement.Clone;
  if (TFhirImmunizationVaccinationProtocol(oSource).FTargetDiseaseList = nil) then
  begin
    FTargetDiseaseList.free;
    FTargetDiseaseList := nil;
  end
  else
  begin
    if FTargetDiseaseList = nil then
      FTargetDiseaseList := TFhirCodeableConceptList.Create;
    FTargetDiseaseList.Assign(TFhirImmunizationVaccinationProtocol(oSource).FTargetDiseaseList);
  end;
  doseStatus := TFhirImmunizationVaccinationProtocol(oSource).doseStatus.Clone;
  doseStatusReason := TFhirImmunizationVaccinationProtocol(oSource).doseStatusReason.Clone;
end;

procedure TFhirImmunizationVaccinationProtocol.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'doseSequence') Then
     list.add(self.link, 'doseSequence', FDoseSequence.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'authority') Then
     list.add(self.link, 'authority', FAuthority.Link);
  if (child_name = 'series') Then
     list.add(self.link, 'series', FSeries.Link);
  if (child_name = 'seriesDoses') Then
     list.add(self.link, 'seriesDoses', FSeriesDoses.Link);
  if (child_name = 'targetDisease') Then
    list.addAll(self, 'targetDisease', FTargetDiseaseList);
  if (child_name = 'doseStatus') Then
     list.add(self.link, 'doseStatus', FDoseStatus.Link);
  if (child_name = 'doseStatusReason') Then
     list.add(self.link, 'doseStatusReason', FDoseStatusReason.Link);
end;

procedure TFhirImmunizationVaccinationProtocol.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'doseSequence', 'positiveInt', false, TFhirPositiveInt, FDoseSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'authority', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FAuthority.Link));{2}
  oList.add(TFHIRProperty.create(self, 'series', 'string', false, TFhirString, FSeries.Link));{2}
  oList.add(TFHIRProperty.create(self, 'seriesDoses', 'positiveInt', false, TFhirPositiveInt, FSeriesDoses.Link));{2}
  oList.add(TFHIRProperty.create(self, 'targetDisease', 'CodeableConcept', true, TFhirCodeableConcept, FTargetDiseaseList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'doseStatus', 'CodeableConcept', false, TFhirCodeableConcept, FDoseStatus.Link));{2}
  oList.add(TFHIRProperty.create(self, 'doseStatusReason', 'CodeableConcept', false, TFhirCodeableConcept, FDoseStatusReason.Link));{2}
end;

function TFhirImmunizationVaccinationProtocol.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'doseSequence') then
  begin
    DoseSequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'authority') then
  begin
    Authority := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'series') then
  begin
    SeriesElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'seriesDoses') then
  begin
    SeriesDosesElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'targetDisease') then
  begin
    TargetDiseaseList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'doseStatus') then
  begin
    DoseStatus := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'doseStatusReason') then
  begin
    DoseStatusReason := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImmunizationVaccinationProtocol.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'targetDisease') then TargetDiseaseList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirImmunizationVaccinationProtocol.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'doseSequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'authority') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'series') then result := TFhirString.create() {5b}
  else if (propName = 'seriesDoses') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'targetDisease') then result := TargetDiseaseList.new(){2}
  else if (propName = 'doseStatus') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'doseStatusReason') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImmunizationVaccinationProtocol.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'doseSequence') then result := 'positiveInt'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'authority') then result := 'Reference'
  else if (propName = 'series') then result := 'string'
  else if (propName = 'seriesDoses') then result := 'positiveInt'
  else if (propName = 'targetDisease') then result := 'CodeableConcept'
  else if (propName = 'doseStatus') then result := 'CodeableConcept'
  else if (propName = 'doseStatusReason') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImmunizationVaccinationProtocol.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'doseSequence') then DoseSequenceElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'authority') then AuthorityElement := nil
  else if (propName = 'series') then SeriesElement := nil
  else if (propName = 'seriesDoses') then SeriesDosesElement := nil
  else if (propName = 'targetDisease') then deletePropertyValue('targetDisease', TargetDiseaseList, value) {2}
  else if (propName = 'doseStatus') then DoseStatusElement := nil
  else if (propName = 'doseStatusReason') then DoseStatusReasonElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImmunizationVaccinationProtocol.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'doseSequence') then DoseSequenceElement := asPositiveInt(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'authority') then AuthorityElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'series') then SeriesElement := asString(new){5b}
  else if (propName = 'seriesDoses') then SeriesDosesElement := asPositiveInt(new){5b}
  else if (propName = 'targetDisease') then replacePropertyValue('targetDisease', TargetDiseaseList, existing, new) {2}
  else if (propName = 'doseStatus') then DoseStatusElement := new as TFhirCodeableConcept{4}
  else if (propName = 'doseStatusReason') then DoseStatusReasonElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImmunizationVaccinationProtocol.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'targetDisease') then TargetDiseaseList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImmunizationVaccinationProtocol.fhirType : string;
begin
  result := 'vaccinationProtocol';
end;

function TFhirImmunizationVaccinationProtocol.Link : TFhirImmunizationVaccinationProtocol;
begin
  result := TFhirImmunizationVaccinationProtocol(inherited Link);
end;

function TFhirImmunizationVaccinationProtocol.Clone : TFhirImmunizationVaccinationProtocol;
begin
  result := TFhirImmunizationVaccinationProtocol(inherited Clone);
end;

function TFhirImmunizationVaccinationProtocol.equals(other : TObject) : boolean;
var
  o : TFhirImmunizationVaccinationProtocol;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImmunizationVaccinationProtocol)) then
    result := false
  else
  begin
    o := TFhirImmunizationVaccinationProtocol(other);
    result := compareDeep(doseSequenceElement, o.doseSequenceElement, true) and
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(authorityElement, o.authorityElement, true) and
      compareDeep(seriesElement, o.seriesElement, true) and compareDeep(seriesDosesElement, o.seriesDosesElement, true) and
      compareDeep(targetDiseaseList, o.targetDiseaseList, true) and compareDeep(doseStatusElement, o.doseStatusElement, true) and
      compareDeep(doseStatusReasonElement, o.doseStatusReasonElement, true);
  end;
end;

function TFhirImmunizationVaccinationProtocol.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDoseSequence) and isEmptyProp(FDescription) and isEmptyProp(FAuthority) and isEmptyProp(FSeries) and isEmptyProp(FSeriesDoses) and isEmptyProp(FtargetDiseaseList) and isEmptyProp(FDoseStatus) and isEmptyProp(FDoseStatusReason);
end;

procedure TFhirImmunizationVaccinationProtocol.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('doseSequence');
  fields.add('description');
  fields.add('authority');
  fields.add('series');
  fields.add('seriesDoses');
  fields.add('targetDisease');
  fields.add('doseStatus');
  fields.add('doseStatusReason');
end;

{ TFhirImmunizationVaccinationProtocol }

Procedure TFhirImmunizationVaccinationProtocol.SetDoseSequence(value : TFhirPositiveInt);
begin
  FDoseSequence.free;
  FDoseSequence := value;
end;

Function TFhirImmunizationVaccinationProtocol.GetDoseSequenceST : String;
begin
  if FDoseSequence = nil then
    result := ''
  else
    result := FDoseSequence.value;
end;

Procedure TFhirImmunizationVaccinationProtocol.SetDoseSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FDoseSequence = nil then
      FDoseSequence := TFhirPositiveInt.create;
    FDoseSequence.value := value
  end
  else if FDoseSequence <> nil then
    FDoseSequence.value := '';
end;

Procedure TFhirImmunizationVaccinationProtocol.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirImmunizationVaccinationProtocol.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirImmunizationVaccinationProtocol.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirImmunizationVaccinationProtocol.SetAuthority(value : TFhirReference{TFhirOrganization});
begin
  FAuthority.free;
  FAuthority := value;
end;

Procedure TFhirImmunizationVaccinationProtocol.SetSeries(value : TFhirString);
begin
  FSeries.free;
  FSeries := value;
end;

Function TFhirImmunizationVaccinationProtocol.GetSeriesST : String;
begin
  if FSeries = nil then
    result := ''
  else
    result := FSeries.value;
end;

Procedure TFhirImmunizationVaccinationProtocol.SetSeriesST(value : String);
begin
  if value <> '' then
  begin
    if FSeries = nil then
      FSeries := TFhirString.create;
    FSeries.value := value
  end
  else if FSeries <> nil then
    FSeries.value := '';
end;

Procedure TFhirImmunizationVaccinationProtocol.SetSeriesDoses(value : TFhirPositiveInt);
begin
  FSeriesDoses.free;
  FSeriesDoses := value;
end;

Function TFhirImmunizationVaccinationProtocol.GetSeriesDosesST : String;
begin
  if FSeriesDoses = nil then
    result := ''
  else
    result := FSeriesDoses.value;
end;

Procedure TFhirImmunizationVaccinationProtocol.SetSeriesDosesST(value : String);
begin
  if value <> '' then
  begin
    if FSeriesDoses = nil then
      FSeriesDoses := TFhirPositiveInt.create;
    FSeriesDoses.value := value
  end
  else if FSeriesDoses <> nil then
    FSeriesDoses.value := '';
end;

Function TFhirImmunizationVaccinationProtocol.GetTargetDiseaseList : TFhirCodeableConceptList;
begin
  if FTargetDiseaseList = nil then
    FTargetDiseaseList := TFhirCodeableConceptList.Create;
  result := FTargetDiseaseList;
end;

Function TFhirImmunizationVaccinationProtocol.GetHasTargetDiseaseList : boolean;
begin
  result := (FTargetDiseaseList <> nil) and (FTargetDiseaseList.count > 0);
end;

Procedure TFhirImmunizationVaccinationProtocol.SetDoseStatus(value : TFhirCodeableConcept);
begin
  FDoseStatus.free;
  FDoseStatus := value;
end;

Procedure TFhirImmunizationVaccinationProtocol.SetDoseStatusReason(value : TFhirCodeableConcept);
begin
  FDoseStatusReason.free;
  FDoseStatusReason := value;
end;

function TFhirImmunizationVaccinationProtocol.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDoseSequence.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FAuthority.sizeInBytes);
  inc(result, FSeries.sizeInBytes);
  inc(result, FSeriesDoses.sizeInBytes);
  inc(result, FtargetDiseaseList.sizeInBytes);
  inc(result, FDoseStatus.sizeInBytes);
  inc(result, FDoseStatusReason.sizeInBytes);
end;

{ TFhirImmunizationVaccinationProtocolListEnumerator }

Constructor TFhirImmunizationVaccinationProtocolListEnumerator.Create(list : TFhirImmunizationVaccinationProtocolList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImmunizationVaccinationProtocolListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImmunizationVaccinationProtocolListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImmunizationVaccinationProtocolListEnumerator.GetCurrent : TFhirImmunizationVaccinationProtocol;
begin
  Result := FList[FIndex];
end;

function TFhirImmunizationVaccinationProtocolListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImmunizationVaccinationProtocolList }
procedure TFhirImmunizationVaccinationProtocolList.AddItem(value: TFhirImmunizationVaccinationProtocol);
begin
  assert(value.ClassName = 'TFhirImmunizationVaccinationProtocol', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationVaccinationProtocol');
  add(value);
end;

function TFhirImmunizationVaccinationProtocolList.Append: TFhirImmunizationVaccinationProtocol;
begin
  result := TFhirImmunizationVaccinationProtocol.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationVaccinationProtocolList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationVaccinationProtocolList.GetEnumerator : TFhirImmunizationVaccinationProtocolListEnumerator;
begin
  result := TFhirImmunizationVaccinationProtocolListEnumerator.Create(self.link);
end;

function TFhirImmunizationVaccinationProtocolList.Clone: TFhirImmunizationVaccinationProtocolList;
begin
  result := TFhirImmunizationVaccinationProtocolList(inherited Clone);
end;

function TFhirImmunizationVaccinationProtocolList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationVaccinationProtocolList.GetItemN(index: Integer): TFhirImmunizationVaccinationProtocol;
begin
  result := TFhirImmunizationVaccinationProtocol(ObjectByIndex[index]);
end;

function TFhirImmunizationVaccinationProtocolList.ItemClass: TFslObjectClass;
begin
  result := TFhirImmunizationVaccinationProtocol;
end;
function TFhirImmunizationVaccinationProtocolList.IndexOf(value: TFhirImmunizationVaccinationProtocol): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImmunizationVaccinationProtocolList.Insert(index: Integer): TFhirImmunizationVaccinationProtocol;
begin
  result := TFhirImmunizationVaccinationProtocol.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationVaccinationProtocolList.InsertItem(index: Integer; value: TFhirImmunizationVaccinationProtocol);
begin
  assert(value is TFhirImmunizationVaccinationProtocol);
  Inherited Insert(index, value);
end;

function TFhirImmunizationVaccinationProtocolList.Item(index: Integer): TFhirImmunizationVaccinationProtocol;
begin
  result := TFhirImmunizationVaccinationProtocol(ObjectByIndex[index]);
end;

function TFhirImmunizationVaccinationProtocolList.Link: TFhirImmunizationVaccinationProtocolList;
begin
  result := TFhirImmunizationVaccinationProtocolList(inherited Link);
end;

procedure TFhirImmunizationVaccinationProtocolList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationVaccinationProtocolList.SetItemByIndex(index: Integer; value: TFhirImmunizationVaccinationProtocol);
begin
  assert(value is TFhirImmunizationVaccinationProtocol);
  FhirImmunizationVaccinationProtocols[index] := value;
end;

procedure TFhirImmunizationVaccinationProtocolList.SetItemN(index: Integer; value: TFhirImmunizationVaccinationProtocol);
begin
  assert(value is TFhirImmunizationVaccinationProtocol);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunization }

constructor TFhirImmunization.Create;
begin
  inherited;
end;

destructor TFhirImmunization.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FDate.free;
  FVaccineCode.free;
  FPatient.free;
  FWasNotGiven.free;
  FReported.free;
  FPerformer.free;
  FRequester.free;
  FEncounter.free;
  FManufacturer.free;
  FLocation.free;
  FLotNumber.free;
  FExpirationDate.free;
  FSite.free;
  FRoute.free;
  FDoseQuantity.free;
  FNoteList.Free;
  FExplanation.free;
  FReactionList.Free;
  FVaccinationProtocolList.Free;
  inherited;
end;

function TFhirImmunization.GetResourceType : TFhirResourceType;
begin
  result := frtImmunization;
end;

procedure TFhirImmunization.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirImmunization(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirImmunization(oSource).FIdentifierList);
  end;
  FStatus := TFhirImmunization(oSource).FStatus.Link;
  dateElement := TFhirImmunization(oSource).dateElement.Clone;
  vaccineCode := TFhirImmunization(oSource).vaccineCode.Clone;
  patient := TFhirImmunization(oSource).patient.Clone;
  wasNotGivenElement := TFhirImmunization(oSource).wasNotGivenElement.Clone;
  reportedElement := TFhirImmunization(oSource).reportedElement.Clone;
  performer := TFhirImmunization(oSource).performer.Clone;
  requester := TFhirImmunization(oSource).requester.Clone;
  encounter := TFhirImmunization(oSource).encounter.Clone;
  manufacturer := TFhirImmunization(oSource).manufacturer.Clone;
  location := TFhirImmunization(oSource).location.Clone;
  lotNumberElement := TFhirImmunization(oSource).lotNumberElement.Clone;
  expirationDateElement := TFhirImmunization(oSource).expirationDateElement.Clone;
  site := TFhirImmunization(oSource).site.Clone;
  route := TFhirImmunization(oSource).route.Clone;
  doseQuantity := TFhirImmunization(oSource).doseQuantity.Clone;
  if (TFhirImmunization(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirImmunization(oSource).FNoteList);
  end;
  explanation := TFhirImmunization(oSource).explanation.Clone;
  if (TFhirImmunization(oSource).FReactionList = nil) then
  begin
    FReactionList.free;
    FReactionList := nil;
  end
  else
  begin
    if FReactionList = nil then
      FReactionList := TFhirImmunizationReactionList.Create;
    FReactionList.Assign(TFhirImmunization(oSource).FReactionList);
  end;
  if (TFhirImmunization(oSource).FVaccinationProtocolList = nil) then
  begin
    FVaccinationProtocolList.free;
    FVaccinationProtocolList := nil;
  end
  else
  begin
    if FVaccinationProtocolList = nil then
      FVaccinationProtocolList := TFhirImmunizationVaccinationProtocolList.Create;
    FVaccinationProtocolList.Assign(TFhirImmunization(oSource).FVaccinationProtocolList);
  end;
end;

procedure TFhirImmunization.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'vaccineCode') Then
     list.add(self.link, 'vaccineCode', FVaccineCode.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'wasNotGiven') Then
     list.add(self.link, 'wasNotGiven', FWasNotGiven.Link);
  if (child_name = 'reported') Then
     list.add(self.link, 'reported', FReported.Link);
  if (child_name = 'performer') Then
     list.add(self.link, 'performer', FPerformer.Link);
  if (child_name = 'requester') Then
     list.add(self.link, 'requester', FRequester.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'manufacturer') Then
     list.add(self.link, 'manufacturer', FManufacturer.Link);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'lotNumber') Then
     list.add(self.link, 'lotNumber', FLotNumber.Link);
  if (child_name = 'expirationDate') Then
     list.add(self.link, 'expirationDate', FExpirationDate.Link);
  if (child_name = 'site') Then
     list.add(self.link, 'site', FSite.Link);
  if (child_name = 'route') Then
     list.add(self.link, 'route', FRoute.Link);
  if (child_name = 'doseQuantity') Then
     list.add(self.link, 'doseQuantity', FDoseQuantity.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'explanation') Then
     list.add(self.link, 'explanation', FExplanation.Link);
  if (child_name = 'reaction') Then
    list.addAll(self, 'reaction', FReactionList);
  if (child_name = 'vaccinationProtocol') Then
    list.addAll(self, 'vaccinationProtocol', FVaccinationProtocolList);
end;

procedure TFhirImmunization.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'vaccineCode', 'CodeableConcept', false, TFhirCodeableConcept, FVaccineCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'wasNotGiven', 'boolean', false, TFhirBoolean, FWasNotGiven.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reported', 'boolean', false, TFhirBoolean, FReported.Link));{2}
  oList.add(TFHIRProperty.create(self, 'performer', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FPerformer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requester', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FRequester.Link));{2}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference(Encounter)', false, TFhirReference{TFhirEncounter}, FEncounter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'manufacturer', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FManufacturer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'location', 'Reference(Location)', false, TFhirReference{TFhirLocation}, FLocation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'lotNumber', 'string', false, TFhirString, FLotNumber.Link));{2}
  oList.add(TFHIRProperty.create(self, 'expirationDate', 'date', false, TFhirDate, FExpirationDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'site', 'CodeableConcept', false, TFhirCodeableConcept, FSite.Link));{2}
  oList.add(TFHIRProperty.create(self, 'route', 'CodeableConcept', false, TFhirCodeableConcept, FRoute.Link));{2}
  oList.add(TFHIRProperty.create(self, 'doseQuantity', 'Quantity', false, TFhirQuantity, FDoseQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'explanation', '', false, TFhirImmunizationExplanation, FExplanation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reaction', '', true, TFhirImmunizationReaction, FReactionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'vaccinationProtocol', '', true, TFhirImmunizationVaccinationProtocol, FVaccinationProtocolList.Link)){3};
end;

function TFhirImmunization.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirMedicationAdminStatusEnum, CODES_TFhirMedicationAdminStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'vaccineCode') then
  begin
    VaccineCode := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'wasNotGiven') then
  begin
    WasNotGivenElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'reported') then
  begin
    ReportedElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    Performer := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'requester') then
  begin
    Requester := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference{TFhirEncounter}{4b};
    result := propValue;
  end
  else if (propName = 'manufacturer') then
  begin
    Manufacturer := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirReference{TFhirLocation}{4b};
    result := propValue;
  end
  else if (propName = 'lotNumber') then
  begin
    LotNumberElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'expirationDate') then
  begin
    ExpirationDateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'site') then
  begin
    Site := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'route') then
  begin
    Route := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'doseQuantity') then
  begin
    DoseQuantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else if (propName = 'explanation') then
  begin
    Explanation := propValue as TFhirImmunizationExplanation{4b};
    result := propValue;
  end
  else if (propName = 'reaction') then
  begin
    ReactionList.add(propValue as TFhirImmunizationReaction){2a};
    result := propValue;
  end
  else if (propName = 'vaccinationProtocol') then
  begin
    VaccinationProtocolList.add(propValue as TFhirImmunizationVaccinationProtocol){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirImmunization.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else if (propName = 'reaction') then ReactionList.insertItem(index, propValue as TFhirImmunizationReaction){2a}
  else if (propName = 'vaccinationProtocol') then VaccinationProtocolList.insertItem(index, propValue as TFhirImmunizationVaccinationProtocol){2a}
  else inherited;
end;

function TFhirImmunization.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'vaccineCode') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'wasNotGiven') then result := TFhirBoolean.create() {5b}
  else if (propName = 'reported') then result := TFhirBoolean.create() {5b}
  else if (propName = 'performer') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'requester') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'encounter') then result := TFhirReference{TFhirEncounter}.create(){4b}
  else if (propName = 'manufacturer') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'location') then result := TFhirReference{TFhirLocation}.create(){4b}
  else if (propName = 'lotNumber') then result := TFhirString.create() {5b}
  else if (propName = 'expirationDate') then result := TFhirDate.create() {5b}
  else if (propName = 'site') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'route') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'doseQuantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'note') then result := NoteList.new(){2}
  else if (propName = 'explanation') then result := TFhirImmunizationExplanation.create(){4b}
  else if (propName = 'reaction') then result := ReactionList.new(){2}
  else if (propName = 'vaccinationProtocol') then result := VaccinationProtocolList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImmunization.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'vaccineCode') then result := 'CodeableConcept'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'wasNotGiven') then result := 'boolean'
  else if (propName = 'reported') then result := 'boolean'
  else if (propName = 'performer') then result := 'Reference'
  else if (propName = 'requester') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'manufacturer') then result := 'Reference'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'lotNumber') then result := 'string'
  else if (propName = 'expirationDate') then result := 'date'
  else if (propName = 'site') then result := 'CodeableConcept'
  else if (propName = 'route') then result := 'CodeableConcept'
  else if (propName = 'doseQuantity') then result := 'Quantity'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'explanation') then result := ''
  else if (propName = 'reaction') then result := ''
  else if (propName = 'vaccinationProtocol') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImmunization.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'vaccineCode') then VaccineCodeElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'wasNotGiven') then WasNotGivenElement := nil
  else if (propName = 'reported') then ReportedElement := nil
  else if (propName = 'performer') then PerformerElement := nil
  else if (propName = 'requester') then RequesterElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'manufacturer') then ManufacturerElement := nil
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'lotNumber') then LotNumberElement := nil
  else if (propName = 'expirationDate') then ExpirationDateElement := nil
  else if (propName = 'site') then SiteElement := nil
  else if (propName = 'route') then RouteElement := nil
  else if (propName = 'doseQuantity') then DoseQuantityElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else if (propName = 'explanation') then ExplanationElement := nil
  else if (propName = 'reaction') then deletePropertyValue('reaction', ReactionList, value) {2}
  else if (propName = 'vaccinationProtocol') then deletePropertyValue('vaccinationProtocol', VaccinationProtocolList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImmunization.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirMedicationAdminStatusEnum, CODES_TFhirMedicationAdminStatusEnum, new){4}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'vaccineCode') then VaccineCodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'wasNotGiven') then WasNotGivenElement := asBoolean(new){5b}
  else if (propName = 'reported') then ReportedElement := asBoolean(new){5b}
  else if (propName = 'performer') then PerformerElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'requester') then RequesterElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference{TFhirEncounter}{4}
  else if (propName = 'manufacturer') then ManufacturerElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'location') then LocationElement := new as TFhirReference{TFhirLocation}{4}
  else if (propName = 'lotNumber') then LotNumberElement := asString(new){5b}
  else if (propName = 'expirationDate') then ExpirationDateElement := asDate(new){5b}
  else if (propName = 'site') then SiteElement := new as TFhirCodeableConcept{4}
  else if (propName = 'route') then RouteElement := new as TFhirCodeableConcept{4}
  else if (propName = 'doseQuantity') then DoseQuantityElement := new as TFhirQuantity{4}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else if (propName = 'explanation') then ExplanationElement := new as TFhirImmunizationExplanation{4}
  else if (propName = 'reaction') then replacePropertyValue('reaction', ReactionList, existing, new) {2}
  else if (propName = 'vaccinationProtocol') then replacePropertyValue('vaccinationProtocol', VaccinationProtocolList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImmunization.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else if (propName = 'reaction') then ReactionList.move(source, destination){2a}
  else if (propName = 'vaccinationProtocol') then VaccinationProtocolList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImmunization.fhirType : string;
begin
  result := 'Immunization';
end;

function TFhirImmunization.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FDate) and isEmptyProp(FVaccineCode) and isEmptyProp(FPatient) and isEmptyProp(FWasNotGiven) and isEmptyProp(FReported) and isEmptyProp(FPerformer) and isEmptyProp(FRequester) and isEmptyProp(FEncounter) and isEmptyProp(FManufacturer) and isEmptyProp(FLocation) and isEmptyProp(FLotNumber) and isEmptyProp(FExpirationDate) and isEmptyProp(FSite) and isEmptyProp(FRoute) and isEmptyProp(FDoseQuantity) and isEmptyProp(FnoteList) and isEmptyProp(FExplanation) and isEmptyProp(FreactionList) and isEmptyProp(FvaccinationProtocolList);
end;

function TFhirImmunization.equals(other : TObject) : boolean;
var
  o : TFhirImmunization;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImmunization)) then
    result := false
  else
  begin
    o := TFhirImmunization(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(dateElement, o.dateElement, true) and compareDeep(vaccineCodeElement, o.vaccineCodeElement, true) and
      compareDeep(patientElement, o.patientElement, true) and compareDeep(wasNotGivenElement, o.wasNotGivenElement, true) and
      compareDeep(reportedElement, o.reportedElement, true) and compareDeep(performerElement, o.performerElement, true) and
      compareDeep(requesterElement, o.requesterElement, true) and compareDeep(encounterElement, o.encounterElement, true) and
      compareDeep(manufacturerElement, o.manufacturerElement, true) and compareDeep(locationElement, o.locationElement, true) and
      compareDeep(lotNumberElement, o.lotNumberElement, true) and compareDeep(expirationDateElement, o.expirationDateElement, true) and
      compareDeep(siteElement, o.siteElement, true) and compareDeep(routeElement, o.routeElement, true) and
      compareDeep(doseQuantityElement, o.doseQuantityElement, true) and compareDeep(noteList, o.noteList, true) and
      compareDeep(explanationElement, o.explanationElement, true) and compareDeep(reactionList, o.reactionList, true) and
      compareDeep(vaccinationProtocolList, o.vaccinationProtocolList, true);
  end;
end;

function TFhirImmunization.Link : TFhirImmunization;
begin
  result := TFhirImmunization(inherited Link);
end;

function TFhirImmunization.Clone : TFhirImmunization;
begin
  result := TFhirImmunization(inherited Clone);
end;

procedure TFhirImmunization.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('date');
  fields.add('vaccineCode');
  fields.add('patient');
  fields.add('wasNotGiven');
  fields.add('reported');
  fields.add('performer');
  fields.add('requester');
  fields.add('encounter');
  fields.add('manufacturer');
  fields.add('location');
  fields.add('lotNumber');
  fields.add('expirationDate');
  fields.add('site');
  fields.add('route');
  fields.add('doseQuantity');
  fields.add('note');
  fields.add('explanation');
  fields.add('reaction');
  fields.add('vaccinationProtocol');
end;

{ TFhirImmunization }

Function TFhirImmunization.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirImmunization.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirImmunization.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirImmunization.GetStatusST : TFhirMedicationAdminStatusEnum;
begin
  if FStatus = nil then
    result := TFhirMedicationAdminStatusEnum(0)
  else
    result := TFhirMedicationAdminStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirMedicationAdminStatusEnum, FStatus.value));
end;

Procedure TFhirImmunization.SetStatusST(value : TFhirMedicationAdminStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirMedicationAdminStatusEnum[value], CODES_TFhirMedicationAdminStatusEnum[value]);
end;

Procedure TFhirImmunization.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirImmunization.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirImmunization.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirImmunization.SetVaccineCode(value : TFhirCodeableConcept);
begin
  FVaccineCode.free;
  FVaccineCode := value;
end;

Procedure TFhirImmunization.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Procedure TFhirImmunization.SetWasNotGiven(value : TFhirBoolean);
begin
  FWasNotGiven.free;
  FWasNotGiven := value;
end;

Function TFhirImmunization.GetWasNotGivenST : Boolean;
begin
  if FWasNotGiven = nil then
    result := false
  else
    result := FWasNotGiven.value;
end;

Procedure TFhirImmunization.SetWasNotGivenST(value : Boolean);
begin
  if FWasNotGiven = nil then
    FWasNotGiven := TFhirBoolean.create;
  FWasNotGiven.value := value
end;

Procedure TFhirImmunization.SetReported(value : TFhirBoolean);
begin
  FReported.free;
  FReported := value;
end;

Function TFhirImmunization.GetReportedST : Boolean;
begin
  if FReported = nil then
    result := false
  else
    result := FReported.value;
end;

Procedure TFhirImmunization.SetReportedST(value : Boolean);
begin
  if FReported = nil then
    FReported := TFhirBoolean.create;
  FReported.value := value
end;

Procedure TFhirImmunization.SetPerformer(value : TFhirReference{TFhirPractitioner});
begin
  FPerformer.free;
  FPerformer := value;
end;

Procedure TFhirImmunization.SetRequester(value : TFhirReference{TFhirPractitioner});
begin
  FRequester.free;
  FRequester := value;
end;

Procedure TFhirImmunization.SetEncounter(value : TFhirReference{TFhirEncounter});
begin
  FEncounter.free;
  FEncounter := value;
end;

Procedure TFhirImmunization.SetManufacturer(value : TFhirReference{TFhirOrganization});
begin
  FManufacturer.free;
  FManufacturer := value;
end;

Procedure TFhirImmunization.SetLocation(value : TFhirReference{TFhirLocation});
begin
  FLocation.free;
  FLocation := value;
end;

Procedure TFhirImmunization.SetLotNumber(value : TFhirString);
begin
  FLotNumber.free;
  FLotNumber := value;
end;

Function TFhirImmunization.GetLotNumberST : String;
begin
  if FLotNumber = nil then
    result := ''
  else
    result := FLotNumber.value;
end;

Procedure TFhirImmunization.SetLotNumberST(value : String);
begin
  if value <> '' then
  begin
    if FLotNumber = nil then
      FLotNumber := TFhirString.create;
    FLotNumber.value := value
  end
  else if FLotNumber <> nil then
    FLotNumber.value := '';
end;

Procedure TFhirImmunization.SetExpirationDate(value : TFhirDate);
begin
  FExpirationDate.free;
  FExpirationDate := value;
end;

Function TFhirImmunization.GetExpirationDateST : TFslDateTime;
begin
  if FExpirationDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FExpirationDate.value;
end;

Procedure TFhirImmunization.SetExpirationDateST(value : TFslDateTime);
begin
  if FExpirationDate = nil then
    FExpirationDate := TFhirDate.create;
  FExpirationDate.value := value
end;

Procedure TFhirImmunization.SetSite(value : TFhirCodeableConcept);
begin
  FSite.free;
  FSite := value;
end;

Procedure TFhirImmunization.SetRoute(value : TFhirCodeableConcept);
begin
  FRoute.free;
  FRoute := value;
end;

Procedure TFhirImmunization.SetDoseQuantity(value : TFhirQuantity);
begin
  FDoseQuantity.free;
  FDoseQuantity := value;
end;

Function TFhirImmunization.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirImmunization.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

Procedure TFhirImmunization.SetExplanation(value : TFhirImmunizationExplanation);
begin
  FExplanation.free;
  FExplanation := value;
end;

Function TFhirImmunization.GetReactionList : TFhirImmunizationReactionList;
begin
  if FReactionList = nil then
    FReactionList := TFhirImmunizationReactionList.Create;
  result := FReactionList;
end;

Function TFhirImmunization.GetHasReactionList : boolean;
begin
  result := (FReactionList <> nil) and (FReactionList.count > 0);
end;

Function TFhirImmunization.GetVaccinationProtocolList : TFhirImmunizationVaccinationProtocolList;
begin
  if FVaccinationProtocolList = nil then
    FVaccinationProtocolList := TFhirImmunizationVaccinationProtocolList.Create;
  result := FVaccinationProtocolList;
end;

Function TFhirImmunization.GetHasVaccinationProtocolList : boolean;
begin
  result := (FVaccinationProtocolList <> nil) and (FVaccinationProtocolList.count > 0);
end;

function TFhirImmunization.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FVaccineCode.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FWasNotGiven.sizeInBytes);
  inc(result, FReported.sizeInBytes);
  inc(result, FPerformer.sizeInBytes);
  inc(result, FRequester.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FManufacturer.sizeInBytes);
  inc(result, FLocation.sizeInBytes);
  inc(result, FLotNumber.sizeInBytes);
  inc(result, FExpirationDate.sizeInBytes);
  inc(result, FSite.sizeInBytes);
  inc(result, FRoute.sizeInBytes);
  inc(result, FDoseQuantity.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FExplanation.sizeInBytes);
  inc(result, FreactionList.sizeInBytes);
  inc(result, FvaccinationProtocolList.sizeInBytes);
end;

{ TFhirImmunizationListEnumerator }

Constructor TFhirImmunizationListEnumerator.Create(list : TFhirImmunizationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImmunizationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImmunizationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImmunizationListEnumerator.GetCurrent : TFhirImmunization;
begin
  Result := FList[FIndex];
end;

function TFhirImmunizationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImmunizationList }
procedure TFhirImmunizationList.AddItem(value: TFhirImmunization);
begin
  assert(value.ClassName = 'TFhirImmunization', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunization');
  add(value);
end;

function TFhirImmunizationList.Append: TFhirImmunization;
begin
  result := TFhirImmunization.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationList.GetEnumerator : TFhirImmunizationListEnumerator;
begin
  result := TFhirImmunizationListEnumerator.Create(self.link);
end;

function TFhirImmunizationList.Clone: TFhirImmunizationList;
begin
  result := TFhirImmunizationList(inherited Clone);
end;

function TFhirImmunizationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationList.GetItemN(index: Integer): TFhirImmunization;
begin
  result := TFhirImmunization(ObjectByIndex[index]);
end;

function TFhirImmunizationList.ItemClass: TFslObjectClass;
begin
  result := TFhirImmunization;
end;
function TFhirImmunizationList.IndexOf(value: TFhirImmunization): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImmunizationList.Insert(index: Integer): TFhirImmunization;
begin
  result := TFhirImmunization.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationList.InsertItem(index: Integer; value: TFhirImmunization);
begin
  assert(value is TFhirImmunization);
  Inherited Insert(index, value);
end;

function TFhirImmunizationList.Item(index: Integer): TFhirImmunization;
begin
  result := TFhirImmunization(ObjectByIndex[index]);
end;

function TFhirImmunizationList.Link: TFhirImmunizationList;
begin
  result := TFhirImmunizationList(inherited Link);
end;

procedure TFhirImmunizationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationList.SetItemByIndex(index: Integer; value: TFhirImmunization);
begin
  assert(value is TFhirImmunization);
  FhirImmunizations[index] := value;
end;

procedure TFhirImmunizationList.SetItemN(index: Integer; value: TFhirImmunization);
begin
  assert(value is TFhirImmunization);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_IMMUNIZATION}

{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}

{ TFhirImmunizationRecommendationRecommendation }

constructor TFhirImmunizationRecommendationRecommendation.Create;
begin
  inherited;
end;

destructor TFhirImmunizationRecommendationRecommendation.Destroy;
begin
  FDate.free;
  FVaccineCode.free;
  FDoseNumber.free;
  FForecastStatus.free;
  FDateCriterionList.Free;
  FProtocol.free;
  FSupportingImmunizationList.Free;
  FSupportingPatientInformationList.Free;
  inherited;
end;

procedure TFhirImmunizationRecommendationRecommendation.Assign(oSource : TFslObject);
begin
  inherited;
  dateElement := TFhirImmunizationRecommendationRecommendation(oSource).dateElement.Clone;
  vaccineCode := TFhirImmunizationRecommendationRecommendation(oSource).vaccineCode.Clone;
  doseNumberElement := TFhirImmunizationRecommendationRecommendation(oSource).doseNumberElement.Clone;
  forecastStatus := TFhirImmunizationRecommendationRecommendation(oSource).forecastStatus.Clone;
  if (TFhirImmunizationRecommendationRecommendation(oSource).FDateCriterionList = nil) then
  begin
    FDateCriterionList.free;
    FDateCriterionList := nil;
  end
  else
  begin
    if FDateCriterionList = nil then
      FDateCriterionList := TFhirImmunizationRecommendationRecommendationDateCriterionList.Create;
    FDateCriterionList.Assign(TFhirImmunizationRecommendationRecommendation(oSource).FDateCriterionList);
  end;
  protocol := TFhirImmunizationRecommendationRecommendation(oSource).protocol.Clone;
  if (TFhirImmunizationRecommendationRecommendation(oSource).FSupportingImmunizationList = nil) then
  begin
    FSupportingImmunizationList.free;
    FSupportingImmunizationList := nil;
  end
  else
  begin
    if FSupportingImmunizationList = nil then
      FSupportingImmunizationList := TFhirReferenceList{TFhirImmunization}.Create;
    FSupportingImmunizationList.Assign(TFhirImmunizationRecommendationRecommendation(oSource).FSupportingImmunizationList);
  end;
  if (TFhirImmunizationRecommendationRecommendation(oSource).FSupportingPatientInformationList = nil) then
  begin
    FSupportingPatientInformationList.free;
    FSupportingPatientInformationList := nil;
  end
  else
  begin
    if FSupportingPatientInformationList = nil then
      FSupportingPatientInformationList := TFhirReferenceList{Resource}.Create;
    FSupportingPatientInformationList.Assign(TFhirImmunizationRecommendationRecommendation(oSource).FSupportingPatientInformationList);
  end;
end;

procedure TFhirImmunizationRecommendationRecommendation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'vaccineCode') Then
     list.add(self.link, 'vaccineCode', FVaccineCode.Link);
  if (child_name = 'doseNumber') Then
     list.add(self.link, 'doseNumber', FDoseNumber.Link);
  if (child_name = 'forecastStatus') Then
     list.add(self.link, 'forecastStatus', FForecastStatus.Link);
  if (child_name = 'dateCriterion') Then
    list.addAll(self, 'dateCriterion', FDateCriterionList);
  if (child_name = 'protocol') Then
     list.add(self.link, 'protocol', FProtocol.Link);
  if (child_name = 'supportingImmunization') Then
    list.addAll(self, 'supportingImmunization', FSupportingImmunizationList);
  if (child_name = 'supportingPatientInformation') Then
    list.addAll(self, 'supportingPatientInformation', FSupportingPatientInformationList);
end;

procedure TFhirImmunizationRecommendationRecommendation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'vaccineCode', 'CodeableConcept', false, TFhirCodeableConcept, FVaccineCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'doseNumber', 'positiveInt', false, TFhirPositiveInt, FDoseNumber.Link));{2}
  oList.add(TFHIRProperty.create(self, 'forecastStatus', 'CodeableConcept', false, TFhirCodeableConcept, FForecastStatus.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dateCriterion', '', true, TFhirImmunizationRecommendationRecommendationDateCriterion, FDateCriterionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'protocol', '', false, TFhirImmunizationRecommendationRecommendationProtocol, FProtocol.Link));{2}
  oList.add(TFHIRProperty.create(self, 'supportingImmunization', 'Reference(Immunization)', true, TFhirReference{TFhirImmunization}, FSupportingImmunizationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'supportingPatientInformation', 'Reference(Observation|AllergyIntolerance)', true, TFhirReference{Resource}, FSupportingPatientInformationList.Link)){3};
end;

function TFhirImmunizationRecommendationRecommendation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'vaccineCode') then
  begin
    VaccineCode := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'doseNumber') then
  begin
    DoseNumberElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'forecastStatus') then
  begin
    ForecastStatus := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'dateCriterion') then
  begin
    DateCriterionList.add(propValue as TFhirImmunizationRecommendationRecommendationDateCriterion){2a};
    result := propValue;
  end
  else if (propName = 'protocol') then
  begin
    Protocol := propValue as TFhirImmunizationRecommendationRecommendationProtocol{4b};
    result := propValue;
  end
  else if (propName = 'supportingImmunization') then
  begin
    SupportingImmunizationList.add(propValue as TFhirReference{TFhirImmunization}){2a};
    result := propValue;
  end
  else if (propName = 'supportingPatientInformation') then
  begin
    SupportingPatientInformationList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImmunizationRecommendationRecommendation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'dateCriterion') then DateCriterionList.insertItem(index, propValue as TFhirImmunizationRecommendationRecommendationDateCriterion){2a}
  else if (propName = 'supportingImmunization') then SupportingImmunizationList.insertItem(index, propValue as TFhirReference{TFhirImmunization}){2a}
  else if (propName = 'supportingPatientInformation') then SupportingPatientInformationList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else inherited;
end;

function TFhirImmunizationRecommendationRecommendation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'vaccineCode') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'doseNumber') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'forecastStatus') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'dateCriterion') then result := DateCriterionList.new(){2}
  else if (propName = 'protocol') then result := TFhirImmunizationRecommendationRecommendationProtocol.create(){4b}
  else if (propName = 'supportingImmunization') then result := SupportingImmunizationList.new(){2}
  else if (propName = 'supportingPatientInformation') then result := SupportingPatientInformationList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImmunizationRecommendationRecommendation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'date') then result := 'dateTime'
  else if (propName = 'vaccineCode') then result := 'CodeableConcept'
  else if (propName = 'doseNumber') then result := 'positiveInt'
  else if (propName = 'forecastStatus') then result := 'CodeableConcept'
  else if (propName = 'dateCriterion') then result := ''
  else if (propName = 'protocol') then result := ''
  else if (propName = 'supportingImmunization') then result := 'Reference'
  else if (propName = 'supportingPatientInformation') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImmunizationRecommendationRecommendation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'date') then DateElement := nil
  else if (propName = 'vaccineCode') then VaccineCodeElement := nil
  else if (propName = 'doseNumber') then DoseNumberElement := nil
  else if (propName = 'forecastStatus') then ForecastStatusElement := nil
  else if (propName = 'dateCriterion') then deletePropertyValue('dateCriterion', DateCriterionList, value) {2}
  else if (propName = 'protocol') then ProtocolElement := nil
  else if (propName = 'supportingImmunization') then deletePropertyValue('supportingImmunization', SupportingImmunizationList, value) {2}
  else if (propName = 'supportingPatientInformation') then deletePropertyValue('supportingPatientInformation', SupportingPatientInformationList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImmunizationRecommendationRecommendation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'vaccineCode') then VaccineCodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'doseNumber') then DoseNumberElement := asPositiveInt(new){5b}
  else if (propName = 'forecastStatus') then ForecastStatusElement := new as TFhirCodeableConcept{4}
  else if (propName = 'dateCriterion') then replacePropertyValue('dateCriterion', DateCriterionList, existing, new) {2}
  else if (propName = 'protocol') then ProtocolElement := new as TFhirImmunizationRecommendationRecommendationProtocol{4}
  else if (propName = 'supportingImmunization') then replacePropertyValue('supportingImmunization', SupportingImmunizationList, existing, new) {2}
  else if (propName = 'supportingPatientInformation') then replacePropertyValue('supportingPatientInformation', SupportingPatientInformationList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImmunizationRecommendationRecommendation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'dateCriterion') then DateCriterionList.move(source, destination){2a}
  else if (propName = 'supportingImmunization') then SupportingImmunizationList.move(source, destination){2a}
  else if (propName = 'supportingPatientInformation') then SupportingPatientInformationList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImmunizationRecommendationRecommendation.fhirType : string;
begin
  result := 'recommendation';
end;

function TFhirImmunizationRecommendationRecommendation.Link : TFhirImmunizationRecommendationRecommendation;
begin
  result := TFhirImmunizationRecommendationRecommendation(inherited Link);
end;

function TFhirImmunizationRecommendationRecommendation.Clone : TFhirImmunizationRecommendationRecommendation;
begin
  result := TFhirImmunizationRecommendationRecommendation(inherited Clone);
end;

function TFhirImmunizationRecommendationRecommendation.equals(other : TObject) : boolean;
var
  o : TFhirImmunizationRecommendationRecommendation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImmunizationRecommendationRecommendation)) then
    result := false
  else
  begin
    o := TFhirImmunizationRecommendationRecommendation(other);
    result := compareDeep(dateElement, o.dateElement, true) and compareDeep(vaccineCodeElement, o.vaccineCodeElement, true) and
      compareDeep(doseNumberElement, o.doseNumberElement, true) and compareDeep(forecastStatusElement, o.forecastStatusElement, true) and
      compareDeep(dateCriterionList, o.dateCriterionList, true) and compareDeep(protocolElement, o.protocolElement, true) and
      compareDeep(supportingImmunizationList, o.supportingImmunizationList, true) and
      compareDeep(supportingPatientInformationList, o.supportingPatientInformationList, true);
  end;
end;

function TFhirImmunizationRecommendationRecommendation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDate) and isEmptyProp(FVaccineCode) and isEmptyProp(FDoseNumber) and isEmptyProp(FForecastStatus) and isEmptyProp(FdateCriterionList) and isEmptyProp(FProtocol) and isEmptyProp(FsupportingImmunizationList) and isEmptyProp(FsupportingPatientInformationList);
end;

procedure TFhirImmunizationRecommendationRecommendation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('date');
  fields.add('vaccineCode');
  fields.add('doseNumber');
  fields.add('forecastStatus');
  fields.add('dateCriterion');
  fields.add('protocol');
  fields.add('supportingImmunization');
  fields.add('supportingPatientInformation');
end;

{ TFhirImmunizationRecommendationRecommendation }

Procedure TFhirImmunizationRecommendationRecommendation.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirImmunizationRecommendationRecommendation.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirImmunizationRecommendationRecommendation.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirImmunizationRecommendationRecommendation.SetVaccineCode(value : TFhirCodeableConcept);
begin
  FVaccineCode.free;
  FVaccineCode := value;
end;

Procedure TFhirImmunizationRecommendationRecommendation.SetDoseNumber(value : TFhirPositiveInt);
begin
  FDoseNumber.free;
  FDoseNumber := value;
end;

Function TFhirImmunizationRecommendationRecommendation.GetDoseNumberST : String;
begin
  if FDoseNumber = nil then
    result := ''
  else
    result := FDoseNumber.value;
end;

Procedure TFhirImmunizationRecommendationRecommendation.SetDoseNumberST(value : String);
begin
  if value <> '' then
  begin
    if FDoseNumber = nil then
      FDoseNumber := TFhirPositiveInt.create;
    FDoseNumber.value := value
  end
  else if FDoseNumber <> nil then
    FDoseNumber.value := '';
end;

Procedure TFhirImmunizationRecommendationRecommendation.SetForecastStatus(value : TFhirCodeableConcept);
begin
  FForecastStatus.free;
  FForecastStatus := value;
end;

Function TFhirImmunizationRecommendationRecommendation.GetDateCriterionList : TFhirImmunizationRecommendationRecommendationDateCriterionList;
begin
  if FDateCriterionList = nil then
    FDateCriterionList := TFhirImmunizationRecommendationRecommendationDateCriterionList.Create;
  result := FDateCriterionList;
end;

Function TFhirImmunizationRecommendationRecommendation.GetHasDateCriterionList : boolean;
begin
  result := (FDateCriterionList <> nil) and (FDateCriterionList.count > 0);
end;

Procedure TFhirImmunizationRecommendationRecommendation.SetProtocol(value : TFhirImmunizationRecommendationRecommendationProtocol);
begin
  FProtocol.free;
  FProtocol := value;
end;

Function TFhirImmunizationRecommendationRecommendation.GetSupportingImmunizationList : TFhirReferenceList{TFhirImmunization};
begin
  if FSupportingImmunizationList = nil then
    FSupportingImmunizationList := TFhirReferenceList{TFhirImmunization}.Create;
  result := FSupportingImmunizationList;
end;

Function TFhirImmunizationRecommendationRecommendation.GetHasSupportingImmunizationList : boolean;
begin
  result := (FSupportingImmunizationList <> nil) and (FSupportingImmunizationList.count > 0);
end;

Function TFhirImmunizationRecommendationRecommendation.GetSupportingPatientInformationList : TFhirReferenceList{Resource};
begin
  if FSupportingPatientInformationList = nil then
    FSupportingPatientInformationList := TFhirReferenceList{Resource}.Create;
  result := FSupportingPatientInformationList;
end;

Function TFhirImmunizationRecommendationRecommendation.GetHasSupportingPatientInformationList : boolean;
begin
  result := (FSupportingPatientInformationList <> nil) and (FSupportingPatientInformationList.count > 0);
end;

function TFhirImmunizationRecommendationRecommendation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDate.sizeInBytes);
  inc(result, FVaccineCode.sizeInBytes);
  inc(result, FDoseNumber.sizeInBytes);
  inc(result, FForecastStatus.sizeInBytes);
  inc(result, FdateCriterionList.sizeInBytes);
  inc(result, FProtocol.sizeInBytes);
  inc(result, FsupportingImmunizationList.sizeInBytes);
  inc(result, FsupportingPatientInformationList.sizeInBytes);
end;

{ TFhirImmunizationRecommendationRecommendationListEnumerator }

Constructor TFhirImmunizationRecommendationRecommendationListEnumerator.Create(list : TFhirImmunizationRecommendationRecommendationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImmunizationRecommendationRecommendationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImmunizationRecommendationRecommendationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImmunizationRecommendationRecommendationListEnumerator.GetCurrent : TFhirImmunizationRecommendationRecommendation;
begin
  Result := FList[FIndex];
end;

function TFhirImmunizationRecommendationRecommendationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImmunizationRecommendationRecommendationList }
procedure TFhirImmunizationRecommendationRecommendationList.AddItem(value: TFhirImmunizationRecommendationRecommendation);
begin
  assert(value.ClassName = 'TFhirImmunizationRecommendationRecommendation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationRecommendationRecommendation');
  add(value);
end;

function TFhirImmunizationRecommendationRecommendationList.Append: TFhirImmunizationRecommendationRecommendation;
begin
  result := TFhirImmunizationRecommendationRecommendation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationRecommendationRecommendationList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationRecommendationRecommendationList.GetEnumerator : TFhirImmunizationRecommendationRecommendationListEnumerator;
begin
  result := TFhirImmunizationRecommendationRecommendationListEnumerator.Create(self.link);
end;

function TFhirImmunizationRecommendationRecommendationList.Clone: TFhirImmunizationRecommendationRecommendationList;
begin
  result := TFhirImmunizationRecommendationRecommendationList(inherited Clone);
end;

function TFhirImmunizationRecommendationRecommendationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationRecommendationRecommendationList.GetItemN(index: Integer): TFhirImmunizationRecommendationRecommendation;
begin
  result := TFhirImmunizationRecommendationRecommendation(ObjectByIndex[index]);
end;

function TFhirImmunizationRecommendationRecommendationList.ItemClass: TFslObjectClass;
begin
  result := TFhirImmunizationRecommendationRecommendation;
end;
function TFhirImmunizationRecommendationRecommendationList.IndexOf(value: TFhirImmunizationRecommendationRecommendation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImmunizationRecommendationRecommendationList.Insert(index: Integer): TFhirImmunizationRecommendationRecommendation;
begin
  result := TFhirImmunizationRecommendationRecommendation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationRecommendationRecommendationList.InsertItem(index: Integer; value: TFhirImmunizationRecommendationRecommendation);
begin
  assert(value is TFhirImmunizationRecommendationRecommendation);
  Inherited Insert(index, value);
end;

function TFhirImmunizationRecommendationRecommendationList.Item(index: Integer): TFhirImmunizationRecommendationRecommendation;
begin
  result := TFhirImmunizationRecommendationRecommendation(ObjectByIndex[index]);
end;

function TFhirImmunizationRecommendationRecommendationList.Link: TFhirImmunizationRecommendationRecommendationList;
begin
  result := TFhirImmunizationRecommendationRecommendationList(inherited Link);
end;

procedure TFhirImmunizationRecommendationRecommendationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationRecommendationRecommendationList.SetItemByIndex(index: Integer; value: TFhirImmunizationRecommendationRecommendation);
begin
  assert(value is TFhirImmunizationRecommendationRecommendation);
  FhirImmunizationRecommendationRecommendations[index] := value;
end;

procedure TFhirImmunizationRecommendationRecommendationList.SetItemN(index: Integer; value: TFhirImmunizationRecommendationRecommendation);
begin
  assert(value is TFhirImmunizationRecommendationRecommendation);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunizationRecommendationRecommendationDateCriterion }

constructor TFhirImmunizationRecommendationRecommendationDateCriterion.Create;
begin
  inherited;
end;

destructor TFhirImmunizationRecommendationRecommendationDateCriterion.Destroy;
begin
  FCode.free;
  FValue.free;
  inherited;
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirImmunizationRecommendationRecommendationDateCriterion(oSource).code.Clone;
  valueElement := TFhirImmunizationRecommendationRecommendationDateCriterion(oSource).valueElement.Clone;
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value', 'dateTime', false, TFhirDateTime, FValue.Link));{2}
end;

function TFhirImmunizationRecommendationRecommendationDateCriterion.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirImmunizationRecommendationRecommendationDateCriterion.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'value') then result := TFhirDateTime.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterion.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'value') then result := 'dateTime'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'value') then ValueElement := asDateTime(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterion.fhirType : string;
begin
  result := 'dateCriterion';
end;

function TFhirImmunizationRecommendationRecommendationDateCriterion.Link : TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion(inherited Link);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterion.Clone : TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion(inherited Clone);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterion.equals(other : TObject) : boolean;
var
  o : TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImmunizationRecommendationRecommendationDateCriterion)) then
    result := false
  else
  begin
    o := TFhirImmunizationRecommendationRecommendationDateCriterion(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirImmunizationRecommendationRecommendationDateCriterion.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FValue);
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('value');
end;

{ TFhirImmunizationRecommendationRecommendationDateCriterion }

Procedure TFhirImmunizationRecommendationRecommendationDateCriterion.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirImmunizationRecommendationRecommendationDateCriterion.SetValue(value : TFhirDateTime);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirImmunizationRecommendationRecommendationDateCriterion.GetValueST : TFslDateTime;
begin
  if FValue = nil then
    result := TFslDateTime.makeNull
  else
    result := FValue.value;
end;

Procedure TFhirImmunizationRecommendationRecommendationDateCriterion.SetValueST(value : TFslDateTime);
begin
  if FValue = nil then
    FValue := TFhirDateTime.create;
  FValue.value := value
end;

function TFhirImmunizationRecommendationRecommendationDateCriterion.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator }

Constructor TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator.Create(list : TFhirImmunizationRecommendationRecommendationDateCriterionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator.GetCurrent : TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  Result := FList[FIndex];
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImmunizationRecommendationRecommendationDateCriterionList }
procedure TFhirImmunizationRecommendationRecommendationDateCriterionList.AddItem(value: TFhirImmunizationRecommendationRecommendationDateCriterion);
begin
  assert(value.ClassName = 'TFhirImmunizationRecommendationRecommendationDateCriterion', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationRecommendationRecommendationDateCriterion');
  add(value);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.Append: TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterionList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.GetEnumerator : TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator.Create(self.link);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.Clone: TFhirImmunizationRecommendationRecommendationDateCriterionList;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterionList(inherited Clone);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.GetItemN(index: Integer): TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion(ObjectByIndex[index]);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.ItemClass: TFslObjectClass;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion;
end;
function TFhirImmunizationRecommendationRecommendationDateCriterionList.IndexOf(value: TFhirImmunizationRecommendationRecommendationDateCriterion): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.Insert(index: Integer): TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterionList.InsertItem(index: Integer; value: TFhirImmunizationRecommendationRecommendationDateCriterion);
begin
  assert(value is TFhirImmunizationRecommendationRecommendationDateCriterion);
  Inherited Insert(index, value);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.Item(index: Integer): TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion(ObjectByIndex[index]);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.Link: TFhirImmunizationRecommendationRecommendationDateCriterionList;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterionList(inherited Link);
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterionList.SetItemByIndex(index: Integer; value: TFhirImmunizationRecommendationRecommendationDateCriterion);
begin
  assert(value is TFhirImmunizationRecommendationRecommendationDateCriterion);
  FhirImmunizationRecommendationRecommendationDateCriterions[index] := value;
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterionList.SetItemN(index: Integer; value: TFhirImmunizationRecommendationRecommendationDateCriterion);
begin
  assert(value is TFhirImmunizationRecommendationRecommendationDateCriterion);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunizationRecommendationRecommendationProtocol }

constructor TFhirImmunizationRecommendationRecommendationProtocol.Create;
begin
  inherited;
end;

destructor TFhirImmunizationRecommendationRecommendationProtocol.Destroy;
begin
  FDoseSequence.free;
  FDescription.free;
  FAuthority.free;
  FSeries.free;
  inherited;
end;

procedure TFhirImmunizationRecommendationRecommendationProtocol.Assign(oSource : TFslObject);
begin
  inherited;
  doseSequenceElement := TFhirImmunizationRecommendationRecommendationProtocol(oSource).doseSequenceElement.Clone;
  descriptionElement := TFhirImmunizationRecommendationRecommendationProtocol(oSource).descriptionElement.Clone;
  authority := TFhirImmunizationRecommendationRecommendationProtocol(oSource).authority.Clone;
  seriesElement := TFhirImmunizationRecommendationRecommendationProtocol(oSource).seriesElement.Clone;
end;

procedure TFhirImmunizationRecommendationRecommendationProtocol.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'doseSequence') Then
     list.add(self.link, 'doseSequence', FDoseSequence.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'authority') Then
     list.add(self.link, 'authority', FAuthority.Link);
  if (child_name = 'series') Then
     list.add(self.link, 'series', FSeries.Link);
end;

procedure TFhirImmunizationRecommendationRecommendationProtocol.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'doseSequence', 'integer', false, TFhirInteger, FDoseSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'authority', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FAuthority.Link));{2}
  oList.add(TFHIRProperty.create(self, 'series', 'string', false, TFhirString, FSeries.Link));{2}
end;

function TFhirImmunizationRecommendationRecommendationProtocol.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'doseSequence') then
  begin
    DoseSequenceElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'authority') then
  begin
    Authority := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'series') then
  begin
    SeriesElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImmunizationRecommendationRecommendationProtocol.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirImmunizationRecommendationRecommendationProtocol.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'doseSequence') then result := TFhirInteger.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'authority') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'series') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImmunizationRecommendationRecommendationProtocol.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'doseSequence') then result := 'integer'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'authority') then result := 'Reference'
  else if (propName = 'series') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImmunizationRecommendationRecommendationProtocol.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'doseSequence') then DoseSequenceElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'authority') then AuthorityElement := nil
  else if (propName = 'series') then SeriesElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImmunizationRecommendationRecommendationProtocol.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'doseSequence') then DoseSequenceElement := asInteger(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'authority') then AuthorityElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'series') then SeriesElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImmunizationRecommendationRecommendationProtocol.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirImmunizationRecommendationRecommendationProtocol.fhirType : string;
begin
  result := 'protocol';
end;

function TFhirImmunizationRecommendationRecommendationProtocol.Link : TFhirImmunizationRecommendationRecommendationProtocol;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocol(inherited Link);
end;

function TFhirImmunizationRecommendationRecommendationProtocol.Clone : TFhirImmunizationRecommendationRecommendationProtocol;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocol(inherited Clone);
end;

function TFhirImmunizationRecommendationRecommendationProtocol.equals(other : TObject) : boolean;
var
  o : TFhirImmunizationRecommendationRecommendationProtocol;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImmunizationRecommendationRecommendationProtocol)) then
    result := false
  else
  begin
    o := TFhirImmunizationRecommendationRecommendationProtocol(other);
    result := compareDeep(doseSequenceElement, o.doseSequenceElement, true) and
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(authorityElement, o.authorityElement, true) and
      compareDeep(seriesElement, o.seriesElement, true);
  end;
end;

function TFhirImmunizationRecommendationRecommendationProtocol.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDoseSequence) and isEmptyProp(FDescription) and isEmptyProp(FAuthority) and isEmptyProp(FSeries);
end;

procedure TFhirImmunizationRecommendationRecommendationProtocol.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('doseSequence');
  fields.add('description');
  fields.add('authority');
  fields.add('series');
end;

{ TFhirImmunizationRecommendationRecommendationProtocol }

Procedure TFhirImmunizationRecommendationRecommendationProtocol.SetDoseSequence(value : TFhirInteger);
begin
  FDoseSequence.free;
  FDoseSequence := value;
end;

Function TFhirImmunizationRecommendationRecommendationProtocol.GetDoseSequenceST : String;
begin
  if FDoseSequence = nil then
    result := ''
  else
    result := FDoseSequence.value;
end;

Procedure TFhirImmunizationRecommendationRecommendationProtocol.SetDoseSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FDoseSequence = nil then
      FDoseSequence := TFhirInteger.create;
    FDoseSequence.value := value
  end
  else if FDoseSequence <> nil then
    FDoseSequence.value := '';
end;

Procedure TFhirImmunizationRecommendationRecommendationProtocol.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirImmunizationRecommendationRecommendationProtocol.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirImmunizationRecommendationRecommendationProtocol.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirImmunizationRecommendationRecommendationProtocol.SetAuthority(value : TFhirReference{TFhirOrganization});
begin
  FAuthority.free;
  FAuthority := value;
end;

Procedure TFhirImmunizationRecommendationRecommendationProtocol.SetSeries(value : TFhirString);
begin
  FSeries.free;
  FSeries := value;
end;

Function TFhirImmunizationRecommendationRecommendationProtocol.GetSeriesST : String;
begin
  if FSeries = nil then
    result := ''
  else
    result := FSeries.value;
end;

Procedure TFhirImmunizationRecommendationRecommendationProtocol.SetSeriesST(value : String);
begin
  if value <> '' then
  begin
    if FSeries = nil then
      FSeries := TFhirString.create;
    FSeries.value := value
  end
  else if FSeries <> nil then
    FSeries.value := '';
end;

function TFhirImmunizationRecommendationRecommendationProtocol.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDoseSequence.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FAuthority.sizeInBytes);
  inc(result, FSeries.sizeInBytes);
end;

{ TFhirImmunizationRecommendationRecommendationProtocolListEnumerator }

Constructor TFhirImmunizationRecommendationRecommendationProtocolListEnumerator.Create(list : TFhirImmunizationRecommendationRecommendationProtocolList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImmunizationRecommendationRecommendationProtocolListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImmunizationRecommendationRecommendationProtocolListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImmunizationRecommendationRecommendationProtocolListEnumerator.GetCurrent : TFhirImmunizationRecommendationRecommendationProtocol;
begin
  Result := FList[FIndex];
end;

function TFhirImmunizationRecommendationRecommendationProtocolListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImmunizationRecommendationRecommendationProtocolList }
procedure TFhirImmunizationRecommendationRecommendationProtocolList.AddItem(value: TFhirImmunizationRecommendationRecommendationProtocol);
begin
  assert(value.ClassName = 'TFhirImmunizationRecommendationRecommendationProtocol', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationRecommendationRecommendationProtocol');
  add(value);
end;

function TFhirImmunizationRecommendationRecommendationProtocolList.Append: TFhirImmunizationRecommendationRecommendationProtocol;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocol.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationRecommendationRecommendationProtocolList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationRecommendationRecommendationProtocolList.GetEnumerator : TFhirImmunizationRecommendationRecommendationProtocolListEnumerator;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocolListEnumerator.Create(self.link);
end;

function TFhirImmunizationRecommendationRecommendationProtocolList.Clone: TFhirImmunizationRecommendationRecommendationProtocolList;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocolList(inherited Clone);
end;

function TFhirImmunizationRecommendationRecommendationProtocolList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationRecommendationRecommendationProtocolList.GetItemN(index: Integer): TFhirImmunizationRecommendationRecommendationProtocol;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocol(ObjectByIndex[index]);
end;

function TFhirImmunizationRecommendationRecommendationProtocolList.ItemClass: TFslObjectClass;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocol;
end;
function TFhirImmunizationRecommendationRecommendationProtocolList.IndexOf(value: TFhirImmunizationRecommendationRecommendationProtocol): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImmunizationRecommendationRecommendationProtocolList.Insert(index: Integer): TFhirImmunizationRecommendationRecommendationProtocol;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocol.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationRecommendationRecommendationProtocolList.InsertItem(index: Integer; value: TFhirImmunizationRecommendationRecommendationProtocol);
begin
  assert(value is TFhirImmunizationRecommendationRecommendationProtocol);
  Inherited Insert(index, value);
end;

function TFhirImmunizationRecommendationRecommendationProtocolList.Item(index: Integer): TFhirImmunizationRecommendationRecommendationProtocol;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocol(ObjectByIndex[index]);
end;

function TFhirImmunizationRecommendationRecommendationProtocolList.Link: TFhirImmunizationRecommendationRecommendationProtocolList;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocolList(inherited Link);
end;

procedure TFhirImmunizationRecommendationRecommendationProtocolList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationRecommendationRecommendationProtocolList.SetItemByIndex(index: Integer; value: TFhirImmunizationRecommendationRecommendationProtocol);
begin
  assert(value is TFhirImmunizationRecommendationRecommendationProtocol);
  FhirImmunizationRecommendationRecommendationProtocols[index] := value;
end;

procedure TFhirImmunizationRecommendationRecommendationProtocolList.SetItemN(index: Integer; value: TFhirImmunizationRecommendationRecommendationProtocol);
begin
  assert(value is TFhirImmunizationRecommendationRecommendationProtocol);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunizationRecommendation }

constructor TFhirImmunizationRecommendation.Create;
begin
  inherited;
end;

destructor TFhirImmunizationRecommendation.Destroy;
begin
  FIdentifierList.Free;
  FPatient.free;
  FRecommendationList.Free;
  inherited;
end;

function TFhirImmunizationRecommendation.GetResourceType : TFhirResourceType;
begin
  result := frtImmunizationRecommendation;
end;

procedure TFhirImmunizationRecommendation.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirImmunizationRecommendation(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirImmunizationRecommendation(oSource).FIdentifierList);
  end;
  patient := TFhirImmunizationRecommendation(oSource).patient.Clone;
  if (TFhirImmunizationRecommendation(oSource).FRecommendationList = nil) then
  begin
    FRecommendationList.free;
    FRecommendationList := nil;
  end
  else
  begin
    if FRecommendationList = nil then
      FRecommendationList := TFhirImmunizationRecommendationRecommendationList.Create;
    FRecommendationList.Assign(TFhirImmunizationRecommendation(oSource).FRecommendationList);
  end;
end;

procedure TFhirImmunizationRecommendation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'recommendation') Then
    list.addAll(self, 'recommendation', FRecommendationList);
end;

procedure TFhirImmunizationRecommendation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'recommendation', '', true, TFhirImmunizationRecommendationRecommendation, FRecommendationList.Link)){3};
end;

function TFhirImmunizationRecommendation.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'recommendation') then
  begin
    RecommendationList.add(propValue as TFhirImmunizationRecommendationRecommendation){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirImmunizationRecommendation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'recommendation') then RecommendationList.insertItem(index, propValue as TFhirImmunizationRecommendationRecommendation){2a}
  else inherited;
end;

function TFhirImmunizationRecommendation.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'recommendation') then result := RecommendationList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImmunizationRecommendation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'recommendation') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImmunizationRecommendation.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'recommendation') then deletePropertyValue('recommendation', RecommendationList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImmunizationRecommendation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'recommendation') then replacePropertyValue('recommendation', RecommendationList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImmunizationRecommendation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'recommendation') then RecommendationList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImmunizationRecommendation.fhirType : string;
begin
  result := 'ImmunizationRecommendation';
end;

function TFhirImmunizationRecommendation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FPatient) and isEmptyProp(FrecommendationList);
end;

function TFhirImmunizationRecommendation.equals(other : TObject) : boolean;
var
  o : TFhirImmunizationRecommendation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImmunizationRecommendation)) then
    result := false
  else
  begin
    o := TFhirImmunizationRecommendation(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(patientElement, o.patientElement, true) and
      compareDeep(recommendationList, o.recommendationList, true);
  end;
end;

function TFhirImmunizationRecommendation.Link : TFhirImmunizationRecommendation;
begin
  result := TFhirImmunizationRecommendation(inherited Link);
end;

function TFhirImmunizationRecommendation.Clone : TFhirImmunizationRecommendation;
begin
  result := TFhirImmunizationRecommendation(inherited Clone);
end;

procedure TFhirImmunizationRecommendation.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('patient');
  fields.add('recommendation');
end;

{ TFhirImmunizationRecommendation }

Function TFhirImmunizationRecommendation.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirImmunizationRecommendation.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirImmunizationRecommendation.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Function TFhirImmunizationRecommendation.GetRecommendationList : TFhirImmunizationRecommendationRecommendationList;
begin
  if FRecommendationList = nil then
    FRecommendationList := TFhirImmunizationRecommendationRecommendationList.Create;
  result := FRecommendationList;
end;

Function TFhirImmunizationRecommendation.GetHasRecommendationList : boolean;
begin
  result := (FRecommendationList <> nil) and (FRecommendationList.count > 0);
end;

function TFhirImmunizationRecommendation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FrecommendationList.sizeInBytes);
end;

{ TFhirImmunizationRecommendationListEnumerator }

Constructor TFhirImmunizationRecommendationListEnumerator.Create(list : TFhirImmunizationRecommendationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImmunizationRecommendationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImmunizationRecommendationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImmunizationRecommendationListEnumerator.GetCurrent : TFhirImmunizationRecommendation;
begin
  Result := FList[FIndex];
end;

function TFhirImmunizationRecommendationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImmunizationRecommendationList }
procedure TFhirImmunizationRecommendationList.AddItem(value: TFhirImmunizationRecommendation);
begin
  assert(value.ClassName = 'TFhirImmunizationRecommendation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationRecommendation');
  add(value);
end;

function TFhirImmunizationRecommendationList.Append: TFhirImmunizationRecommendation;
begin
  result := TFhirImmunizationRecommendation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationRecommendationList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationRecommendationList.GetEnumerator : TFhirImmunizationRecommendationListEnumerator;
begin
  result := TFhirImmunizationRecommendationListEnumerator.Create(self.link);
end;

function TFhirImmunizationRecommendationList.Clone: TFhirImmunizationRecommendationList;
begin
  result := TFhirImmunizationRecommendationList(inherited Clone);
end;

function TFhirImmunizationRecommendationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationRecommendationList.GetItemN(index: Integer): TFhirImmunizationRecommendation;
begin
  result := TFhirImmunizationRecommendation(ObjectByIndex[index]);
end;

function TFhirImmunizationRecommendationList.ItemClass: TFslObjectClass;
begin
  result := TFhirImmunizationRecommendation;
end;
function TFhirImmunizationRecommendationList.IndexOf(value: TFhirImmunizationRecommendation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImmunizationRecommendationList.Insert(index: Integer): TFhirImmunizationRecommendation;
begin
  result := TFhirImmunizationRecommendation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationRecommendationList.InsertItem(index: Integer; value: TFhirImmunizationRecommendation);
begin
  assert(value is TFhirImmunizationRecommendation);
  Inherited Insert(index, value);
end;

function TFhirImmunizationRecommendationList.Item(index: Integer): TFhirImmunizationRecommendation;
begin
  result := TFhirImmunizationRecommendation(ObjectByIndex[index]);
end;

function TFhirImmunizationRecommendationList.Link: TFhirImmunizationRecommendationList;
begin
  result := TFhirImmunizationRecommendationList(inherited Link);
end;

procedure TFhirImmunizationRecommendationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationRecommendationList.SetItemByIndex(index: Integer; value: TFhirImmunizationRecommendation);
begin
  assert(value is TFhirImmunizationRecommendation);
  FhirImmunizationRecommendations[index] := value;
end;

procedure TFhirImmunizationRecommendationList.SetItemN(index: Integer; value: TFhirImmunizationRecommendation);
begin
  assert(value is TFhirImmunizationRecommendation);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}

{$IFDEF FHIR_MEDIA}

{ TFhirMedia }

constructor TFhirMedia.Create;
begin
  inherited;
end;

destructor TFhirMedia.Destroy;
begin
  FType_.free;
  FSubtype.free;
  FIdentifierList.Free;
  FSubject.free;
  FOperator.free;
  FView.free;
  FDeviceName.free;
  FHeight.free;
  FWidth.free;
  FFrames.free;
  FDuration.free;
  FContent.free;
  inherited;
end;

function TFhirMedia.GetResourceType : TFhirResourceType;
begin
  result := frtMedia;
end;

procedure TFhirMedia.Assign(oSource : TFslObject);
begin
  inherited;
  FType_ := TFhirMedia(oSource).FType_.Link;
  subtype := TFhirMedia(oSource).subtype.Clone;
  if (TFhirMedia(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirMedia(oSource).FIdentifierList);
  end;
  subject := TFhirMedia(oSource).subject.Clone;
  operator := TFhirMedia(oSource).operator.Clone;
  view := TFhirMedia(oSource).view.Clone;
  deviceNameElement := TFhirMedia(oSource).deviceNameElement.Clone;
  heightElement := TFhirMedia(oSource).heightElement.Clone;
  widthElement := TFhirMedia(oSource).widthElement.Clone;
  framesElement := TFhirMedia(oSource).framesElement.Clone;
  durationElement := TFhirMedia(oSource).durationElement.Clone;
  content := TFhirMedia(oSource).content.Clone;
end;

procedure TFhirMedia.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subtype') Then
     list.add(self.link, 'subtype', FSubtype.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'operator') Then
     list.add(self.link, 'operator', FOperator.Link);
  if (child_name = 'view') Then
     list.add(self.link, 'view', FView.Link);
  if (child_name = 'deviceName') Then
     list.add(self.link, 'deviceName', FDeviceName.Link);
  if (child_name = 'height') Then
     list.add(self.link, 'height', FHeight.Link);
  if (child_name = 'width') Then
     list.add(self.link, 'width', FWidth.Link);
  if (child_name = 'frames') Then
     list.add(self.link, 'frames', FFrames.Link);
  if (child_name = 'duration') Then
     list.add(self.link, 'duration', FDuration.Link);
  if (child_name = 'content') Then
     list.add(self.link, 'content', FContent.Link);
end;

procedure TFhirMedia.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'subtype', 'CodeableConcept', false, TFhirCodeableConcept, FSubtype.Link));{2}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Practitioner|Group|Device|Specimen)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'operator', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FOperator.Link));{2}
  oList.add(TFHIRProperty.create(self, 'view', 'CodeableConcept', false, TFhirCodeableConcept, FView.Link));{2}
  oList.add(TFHIRProperty.create(self, 'deviceName', 'string', false, TFhirString, FDeviceName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'height', 'positiveInt', false, TFhirPositiveInt, FHeight.Link));{2}
  oList.add(TFHIRProperty.create(self, 'width', 'positiveInt', false, TFhirPositiveInt, FWidth.Link));{2}
  oList.add(TFHIRProperty.create(self, 'frames', 'positiveInt', false, TFhirPositiveInt, FFrames.Link));{2}
  oList.add(TFHIRProperty.create(self, 'duration', 'unsignedInt', false, TFhirUnsignedInt, FDuration.Link));{2}
  oList.add(TFHIRProperty.create(self, 'content', 'Attachment', false, TFhirAttachment, FContent.Link));{2}
end;

function TFhirMedia.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirDigitalMediaTypeEnum, CODES_TFhirDigitalMediaTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'subtype') then
  begin
    Subtype := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'operator') then
  begin
    Operator := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'view') then
  begin
    View := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'deviceName') then
  begin
    DeviceNameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'height') then
  begin
    HeightElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'width') then
  begin
    WidthElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'frames') then
  begin
    FramesElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'duration') then
  begin
    DurationElement := asUnsignedInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'content') then
  begin
    Content := propValue as TFhirAttachment{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirMedia.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else inherited;
end;

function TFhirMedia.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'subtype') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'operator') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'view') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'deviceName') then result := TFhirString.create() {5b}
  else if (propName = 'height') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'width') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'frames') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'duration') then result := TFhirUnsignedInt.create() {5b}
  else if (propName = 'content') then result := TFhirAttachment.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedia.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'subtype') then result := 'CodeableConcept'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'operator') then result := 'Reference'
  else if (propName = 'view') then result := 'CodeableConcept'
  else if (propName = 'deviceName') then result := 'string'
  else if (propName = 'height') then result := 'positiveInt'
  else if (propName = 'width') then result := 'positiveInt'
  else if (propName = 'frames') then result := 'positiveInt'
  else if (propName = 'duration') then result := 'unsignedInt'
  else if (propName = 'content') then result := 'Attachment'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedia.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'subtype') then SubtypeElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'operator') then OperatorElement := nil
  else if (propName = 'view') then ViewElement := nil
  else if (propName = 'deviceName') then DeviceNameElement := nil
  else if (propName = 'height') then HeightElement := nil
  else if (propName = 'width') then WidthElement := nil
  else if (propName = 'frames') then FramesElement := nil
  else if (propName = 'duration') then DurationElement := nil
  else if (propName = 'content') then ContentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedia.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirDigitalMediaTypeEnum, CODES_TFhirDigitalMediaTypeEnum, new){4}
  else if (propName = 'subtype') then SubtypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'operator') then OperatorElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'view') then ViewElement := new as TFhirCodeableConcept{4}
  else if (propName = 'deviceName') then DeviceNameElement := asString(new){5b}
  else if (propName = 'height') then HeightElement := asPositiveInt(new){5b}
  else if (propName = 'width') then WidthElement := asPositiveInt(new){5b}
  else if (propName = 'frames') then FramesElement := asPositiveInt(new){5b}
  else if (propName = 'duration') then DurationElement := asUnsignedInt(new){5b}
  else if (propName = 'content') then ContentElement := new as TFhirAttachment{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedia.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedia.fhirType : string;
begin
  result := 'Media';
end;

function TFhirMedia.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FSubtype) and isEmptyProp(FidentifierList) and isEmptyProp(FSubject) and isEmptyProp(FOperator) and isEmptyProp(FView) and isEmptyProp(FDeviceName) and isEmptyProp(FHeight) and isEmptyProp(FWidth) and isEmptyProp(FFrames) and isEmptyProp(FDuration) and isEmptyProp(FContent);
end;

function TFhirMedia.equals(other : TObject) : boolean;
var
  o : TFhirMedia;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedia)) then
    result := false
  else
  begin
    o := TFhirMedia(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(subtypeElement, o.subtypeElement, true) and
      compareDeep(identifierList, o.identifierList, true) and compareDeep(subjectElement, o.subjectElement, true) and
      compareDeep(operatorElement, o.operatorElement, true) and compareDeep(viewElement, o.viewElement, true) and
      compareDeep(deviceNameElement, o.deviceNameElement, true) and compareDeep(heightElement, o.heightElement, true) and
      compareDeep(widthElement, o.widthElement, true) and compareDeep(framesElement, o.framesElement, true) and
      compareDeep(durationElement, o.durationElement, true) and compareDeep(contentElement, o.contentElement, true);
  end;
end;

function TFhirMedia.Link : TFhirMedia;
begin
  result := TFhirMedia(inherited Link);
end;

function TFhirMedia.Clone : TFhirMedia;
begin
  result := TFhirMedia(inherited Clone);
end;

procedure TFhirMedia.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('type');
  fields.add('subtype');
  fields.add('identifier');
  fields.add('subject');
  fields.add('operator');
  fields.add('view');
  fields.add('deviceName');
  fields.add('height');
  fields.add('width');
  fields.add('frames');
  fields.add('duration');
  fields.add('content');
end;

{ TFhirMedia }

Procedure TFhirMedia.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirMedia.GetType_ST : TFhirDigitalMediaTypeEnum;
begin
  if FType_ = nil then
    result := TFhirDigitalMediaTypeEnum(0)
  else
    result := TFhirDigitalMediaTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirDigitalMediaTypeEnum, FType_.value));
end;

Procedure TFhirMedia.SetType_ST(value : TFhirDigitalMediaTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirDigitalMediaTypeEnum[value], CODES_TFhirDigitalMediaTypeEnum[value]);
end;

Procedure TFhirMedia.SetSubtype(value : TFhirCodeableConcept);
begin
  FSubtype.free;
  FSubtype := value;
end;

Function TFhirMedia.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirMedia.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirMedia.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirMedia.SetOperator(value : TFhirReference{TFhirPractitioner});
begin
  FOperator.free;
  FOperator := value;
end;

Procedure TFhirMedia.SetView(value : TFhirCodeableConcept);
begin
  FView.free;
  FView := value;
end;

Procedure TFhirMedia.SetDeviceName(value : TFhirString);
begin
  FDeviceName.free;
  FDeviceName := value;
end;

Function TFhirMedia.GetDeviceNameST : String;
begin
  if FDeviceName = nil then
    result := ''
  else
    result := FDeviceName.value;
end;

Procedure TFhirMedia.SetDeviceNameST(value : String);
begin
  if value <> '' then
  begin
    if FDeviceName = nil then
      FDeviceName := TFhirString.create;
    FDeviceName.value := value
  end
  else if FDeviceName <> nil then
    FDeviceName.value := '';
end;

Procedure TFhirMedia.SetHeight(value : TFhirPositiveInt);
begin
  FHeight.free;
  FHeight := value;
end;

Function TFhirMedia.GetHeightST : String;
begin
  if FHeight = nil then
    result := ''
  else
    result := FHeight.value;
end;

Procedure TFhirMedia.SetHeightST(value : String);
begin
  if value <> '' then
  begin
    if FHeight = nil then
      FHeight := TFhirPositiveInt.create;
    FHeight.value := value
  end
  else if FHeight <> nil then
    FHeight.value := '';
end;

Procedure TFhirMedia.SetWidth(value : TFhirPositiveInt);
begin
  FWidth.free;
  FWidth := value;
end;

Function TFhirMedia.GetWidthST : String;
begin
  if FWidth = nil then
    result := ''
  else
    result := FWidth.value;
end;

Procedure TFhirMedia.SetWidthST(value : String);
begin
  if value <> '' then
  begin
    if FWidth = nil then
      FWidth := TFhirPositiveInt.create;
    FWidth.value := value
  end
  else if FWidth <> nil then
    FWidth.value := '';
end;

Procedure TFhirMedia.SetFrames(value : TFhirPositiveInt);
begin
  FFrames.free;
  FFrames := value;
end;

Function TFhirMedia.GetFramesST : String;
begin
  if FFrames = nil then
    result := ''
  else
    result := FFrames.value;
end;

Procedure TFhirMedia.SetFramesST(value : String);
begin
  if value <> '' then
  begin
    if FFrames = nil then
      FFrames := TFhirPositiveInt.create;
    FFrames.value := value
  end
  else if FFrames <> nil then
    FFrames.value := '';
end;

Procedure TFhirMedia.SetDuration(value : TFhirUnsignedInt);
begin
  FDuration.free;
  FDuration := value;
end;

Function TFhirMedia.GetDurationST : String;
begin
  if FDuration = nil then
    result := ''
  else
    result := FDuration.value;
end;

Procedure TFhirMedia.SetDurationST(value : String);
begin
  if value <> '' then
  begin
    if FDuration = nil then
      FDuration := TFhirUnsignedInt.create;
    FDuration.value := value
  end
  else if FDuration <> nil then
    FDuration.value := '';
end;

Procedure TFhirMedia.SetContent(value : TFhirAttachment);
begin
  FContent.free;
  FContent := value;
end;

function TFhirMedia.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FSubtype.sizeInBytes);
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FOperator.sizeInBytes);
  inc(result, FView.sizeInBytes);
  inc(result, FDeviceName.sizeInBytes);
  inc(result, FHeight.sizeInBytes);
  inc(result, FWidth.sizeInBytes);
  inc(result, FFrames.sizeInBytes);
  inc(result, FDuration.sizeInBytes);
  inc(result, FContent.sizeInBytes);
end;

{ TFhirMediaListEnumerator }

Constructor TFhirMediaListEnumerator.Create(list : TFhirMediaList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMediaListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMediaListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMediaListEnumerator.GetCurrent : TFhirMedia;
begin
  Result := FList[FIndex];
end;

function TFhirMediaListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMediaList }
procedure TFhirMediaList.AddItem(value: TFhirMedia);
begin
  assert(value.ClassName = 'TFhirMedia', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedia');
  add(value);
end;

function TFhirMediaList.Append: TFhirMedia;
begin
  result := TFhirMedia.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMediaList.ClearItems;
begin
  Clear;
end;

function TFhirMediaList.GetEnumerator : TFhirMediaListEnumerator;
begin
  result := TFhirMediaListEnumerator.Create(self.link);
end;

function TFhirMediaList.Clone: TFhirMediaList;
begin
  result := TFhirMediaList(inherited Clone);
end;

function TFhirMediaList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMediaList.GetItemN(index: Integer): TFhirMedia;
begin
  result := TFhirMedia(ObjectByIndex[index]);
end;

function TFhirMediaList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedia;
end;
function TFhirMediaList.IndexOf(value: TFhirMedia): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMediaList.Insert(index: Integer): TFhirMedia;
begin
  result := TFhirMedia.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMediaList.InsertItem(index: Integer; value: TFhirMedia);
begin
  assert(value is TFhirMedia);
  Inherited Insert(index, value);
end;

function TFhirMediaList.Item(index: Integer): TFhirMedia;
begin
  result := TFhirMedia(ObjectByIndex[index]);
end;

function TFhirMediaList.Link: TFhirMediaList;
begin
  result := TFhirMediaList(inherited Link);
end;

procedure TFhirMediaList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMediaList.SetItemByIndex(index: Integer; value: TFhirMedia);
begin
  assert(value is TFhirMedia);
  FhirMedia[index] := value;
end;

procedure TFhirMediaList.SetItemN(index: Integer; value: TFhirMedia);
begin
  assert(value is TFhirMedia);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEDIA}

{$IFDEF FHIR_MEDICATIONADMINISTRATION}

{ TFhirMedicationAdministrationDosage }

constructor TFhirMedicationAdministrationDosage.Create;
begin
  inherited;
end;

destructor TFhirMedicationAdministrationDosage.Destroy;
begin
  FText.free;
  FSite.free;
  FRoute.free;
  FMethod.free;
  FQuantity.free;
  FRate.free;
  inherited;
end;

procedure TFhirMedicationAdministrationDosage.Assign(oSource : TFslObject);
begin
  inherited;
  textElement := TFhirMedicationAdministrationDosage(oSource).textElement.Clone;
  site := TFhirMedicationAdministrationDosage(oSource).site.Clone;
  route := TFhirMedicationAdministrationDosage(oSource).route.Clone;
  method := TFhirMedicationAdministrationDosage(oSource).method.Clone;
  quantity := TFhirMedicationAdministrationDosage(oSource).quantity.Clone;
  rate := TFhirMedicationAdministrationDosage(oSource).rate.Clone;
end;

procedure TFhirMedicationAdministrationDosage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'site[x]') or (child_name = 'site') Then
     list.add(self.link, 'site[x]', FSite.Link);
  if (child_name = 'route') Then
     list.add(self.link, 'route', FRoute.Link);
  if (child_name = 'method') Then
     list.add(self.link, 'method', FMethod.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'rate[x]') or (child_name = 'rate') Then
     list.add(self.link, 'rate[x]', FRate.Link);
end;

procedure TFhirMedicationAdministrationDosage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));{2}
  oList.add(TFHIRProperty.create(self, 'site[x]', 'CodeableConcept|Reference(BodySite)', false, TFhirType, FSite.Link));{2}
  oList.add(TFHIRProperty.create(self, 'route', 'CodeableConcept', false, TFhirCodeableConcept, FRoute.Link));{2}
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', false, TFhirCodeableConcept, FMethod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'rate[x]', 'Ratio|Range', false, TFhirType, FRate.Link));{2}
end;

function TFhirMedicationAdministrationDosage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'text') then
  begin
    TextElement := asString(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'site', ['CodeableConcept', 'Reference'])) then
  begin
    Site := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'route') then
  begin
    Route := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'method') then
  begin
    Method := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'rate', ['Ratio', 'Range'])) then
  begin
    Rate := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationAdministrationDosage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationAdministrationDosage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'text') then result := TFhirString.create() {5b}
  else if (isMatchingName(propName, 'site', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Site'){4x}
  else if (propName = 'route') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'method') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (isMatchingName(propName, 'rate', ['Ratio', 'Range'])) then raise EFHIRException.create('Cannot make property Rate'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationAdministrationDosage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'text') then result := 'string'
  else if (propName = 'site[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'route') then result := 'CodeableConcept'
  else if (propName = 'method') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'rate[x]') then result := 'Ratio|Range'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationAdministrationDosage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'text') then TextElement := nil
  else if (isMatchingName(propName, 'site', ['CodeableConcept', 'Reference'])) then SiteElement := nil{4x}
  else if (propName = 'route') then RouteElement := nil
  else if (propName = 'method') then MethodElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (isMatchingName(propName, 'rate', ['Ratio', 'Range'])) then RateElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationAdministrationDosage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'text') then TextElement := asString(new){5b}
  else if (isMatchingName(propName, 'site', ['CodeableConcept', 'Reference'])) then SiteElement := new as TFhirType{4x}
  else if (propName = 'route') then RouteElement := new as TFhirCodeableConcept{4}
  else if (propName = 'method') then MethodElement := new as TFhirCodeableConcept{4}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (isMatchingName(propName, 'rate', ['Ratio', 'Range'])) then RateElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationAdministrationDosage.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationAdministrationDosage.fhirType : string;
begin
  result := 'dosage';
end;

function TFhirMedicationAdministrationDosage.Link : TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage(inherited Link);
end;

function TFhirMedicationAdministrationDosage.Clone : TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage(inherited Clone);
end;

function TFhirMedicationAdministrationDosage.equals(other : TObject) : boolean;
var
  o : TFhirMedicationAdministrationDosage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationAdministrationDosage)) then
    result := false
  else
  begin
    o := TFhirMedicationAdministrationDosage(other);
    result := compareDeep(textElement, o.textElement, true) and compareDeep(siteElement, o.siteElement, true) and
      compareDeep(routeElement, o.routeElement, true) and compareDeep(methodElement, o.methodElement, true) and
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(rateElement, o.rateElement, true);
  end;
end;

function TFhirMedicationAdministrationDosage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FText) and isEmptyProp(FSite) and isEmptyProp(FRoute) and isEmptyProp(FMethod) and isEmptyProp(FQuantity) and isEmptyProp(FRate);
end;

procedure TFhirMedicationAdministrationDosage.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('text');
  fields.add('site[x]');
  fields.add('route');
  fields.add('method');
  fields.add('quantity');
  fields.add('rate[x]');
end;

{ TFhirMedicationAdministrationDosage }

Procedure TFhirMedicationAdministrationDosage.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

Function TFhirMedicationAdministrationDosage.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

Procedure TFhirMedicationAdministrationDosage.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

Procedure TFhirMedicationAdministrationDosage.SetSite(value : TFhirType);
begin
  FSite.free;
  FSite := value;
end;

Procedure TFhirMedicationAdministrationDosage.SetRoute(value : TFhirCodeableConcept);
begin
  FRoute.free;
  FRoute := value;
end;

Procedure TFhirMedicationAdministrationDosage.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value;
end;

Procedure TFhirMedicationAdministrationDosage.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirMedicationAdministrationDosage.SetRate(value : TFhirType);
begin
  FRate.free;
  FRate := value;
end;

function TFhirMedicationAdministrationDosage.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FText.sizeInBytes);
  inc(result, FSite.sizeInBytes);
  inc(result, FRoute.sizeInBytes);
  inc(result, FMethod.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FRate.sizeInBytes);
end;

{ TFhirMedicationAdministrationDosageListEnumerator }

Constructor TFhirMedicationAdministrationDosageListEnumerator.Create(list : TFhirMedicationAdministrationDosageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationAdministrationDosageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationAdministrationDosageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationAdministrationDosageListEnumerator.GetCurrent : TFhirMedicationAdministrationDosage;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationAdministrationDosageListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationAdministrationDosageList }
procedure TFhirMedicationAdministrationDosageList.AddItem(value: TFhirMedicationAdministrationDosage);
begin
  assert(value.ClassName = 'TFhirMedicationAdministrationDosage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationAdministrationDosage');
  add(value);
end;

function TFhirMedicationAdministrationDosageList.Append: TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationAdministrationDosageList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationAdministrationDosageList.GetEnumerator : TFhirMedicationAdministrationDosageListEnumerator;
begin
  result := TFhirMedicationAdministrationDosageListEnumerator.Create(self.link);
end;

function TFhirMedicationAdministrationDosageList.Clone: TFhirMedicationAdministrationDosageList;
begin
  result := TFhirMedicationAdministrationDosageList(inherited Clone);
end;

function TFhirMedicationAdministrationDosageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationAdministrationDosageList.GetItemN(index: Integer): TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage(ObjectByIndex[index]);
end;

function TFhirMedicationAdministrationDosageList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationAdministrationDosage;
end;
function TFhirMedicationAdministrationDosageList.IndexOf(value: TFhirMedicationAdministrationDosage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationAdministrationDosageList.Insert(index: Integer): TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationAdministrationDosageList.InsertItem(index: Integer; value: TFhirMedicationAdministrationDosage);
begin
  assert(value is TFhirMedicationAdministrationDosage);
  Inherited Insert(index, value);
end;

function TFhirMedicationAdministrationDosageList.Item(index: Integer): TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage(ObjectByIndex[index]);
end;

function TFhirMedicationAdministrationDosageList.Link: TFhirMedicationAdministrationDosageList;
begin
  result := TFhirMedicationAdministrationDosageList(inherited Link);
end;

procedure TFhirMedicationAdministrationDosageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationAdministrationDosageList.SetItemByIndex(index: Integer; value: TFhirMedicationAdministrationDosage);
begin
  assert(value is TFhirMedicationAdministrationDosage);
  FhirMedicationAdministrationDosages[index] := value;
end;

procedure TFhirMedicationAdministrationDosageList.SetItemN(index: Integer; value: TFhirMedicationAdministrationDosage);
begin
  assert(value is TFhirMedicationAdministrationDosage);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationAdministration }

constructor TFhirMedicationAdministration.Create;
begin
  inherited;
end;

destructor TFhirMedicationAdministration.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FPatient.free;
  FPractitioner.free;
  FEncounter.free;
  FPrescription.free;
  FWasNotGiven.free;
  FReasonNotGivenList.Free;
  FReasonGivenList.Free;
  FEffectiveTime.free;
  FMedication.free;
  FDeviceList.Free;
  FNote.free;
  FDosage.free;
  inherited;
end;

function TFhirMedicationAdministration.GetResourceType : TFhirResourceType;
begin
  result := frtMedicationAdministration;
end;

procedure TFhirMedicationAdministration.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedicationAdministration(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirMedicationAdministration(oSource).FIdentifierList);
  end;
  FStatus := TFhirMedicationAdministration(oSource).FStatus.Link;
  patient := TFhirMedicationAdministration(oSource).patient.Clone;
  practitioner := TFhirMedicationAdministration(oSource).practitioner.Clone;
  encounter := TFhirMedicationAdministration(oSource).encounter.Clone;
  prescription := TFhirMedicationAdministration(oSource).prescription.Clone;
  wasNotGivenElement := TFhirMedicationAdministration(oSource).wasNotGivenElement.Clone;
  if (TFhirMedicationAdministration(oSource).FReasonNotGivenList = nil) then
  begin
    FReasonNotGivenList.free;
    FReasonNotGivenList := nil;
  end
  else
  begin
    if FReasonNotGivenList = nil then
      FReasonNotGivenList := TFhirCodeableConceptList.Create;
    FReasonNotGivenList.Assign(TFhirMedicationAdministration(oSource).FReasonNotGivenList);
  end;
  if (TFhirMedicationAdministration(oSource).FReasonGivenList = nil) then
  begin
    FReasonGivenList.free;
    FReasonGivenList := nil;
  end
  else
  begin
    if FReasonGivenList = nil then
      FReasonGivenList := TFhirCodeableConceptList.Create;
    FReasonGivenList.Assign(TFhirMedicationAdministration(oSource).FReasonGivenList);
  end;
  effectiveTime := TFhirMedicationAdministration(oSource).effectiveTime.Clone;
  medication := TFhirMedicationAdministration(oSource).medication.Clone;
  if (TFhirMedicationAdministration(oSource).FDeviceList = nil) then
  begin
    FDeviceList.free;
    FDeviceList := nil;
  end
  else
  begin
    if FDeviceList = nil then
      FDeviceList := TFhirReferenceList{TFhirDevice}.Create;
    FDeviceList.Assign(TFhirMedicationAdministration(oSource).FDeviceList);
  end;
  noteElement := TFhirMedicationAdministration(oSource).noteElement.Clone;
  dosage := TFhirMedicationAdministration(oSource).dosage.Clone;
end;

procedure TFhirMedicationAdministration.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'practitioner') Then
     list.add(self.link, 'practitioner', FPractitioner.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'prescription') Then
     list.add(self.link, 'prescription', FPrescription.Link);
  if (child_name = 'wasNotGiven') Then
     list.add(self.link, 'wasNotGiven', FWasNotGiven.Link);
  if (child_name = 'reasonNotGiven') Then
    list.addAll(self, 'reasonNotGiven', FReasonNotGivenList);
  if (child_name = 'reasonGiven') Then
    list.addAll(self, 'reasonGiven', FReasonGivenList);
  if (child_name = 'effectiveTime[x]') or (child_name = 'effectiveTime') Then
     list.add(self.link, 'effectiveTime[x]', FEffectiveTime.Link);
  if (child_name = 'medication[x]') or (child_name = 'medication') Then
     list.add(self.link, 'medication[x]', FMedication.Link);
  if (child_name = 'device') Then
    list.addAll(self, 'device', FDeviceList);
  if (child_name = 'note') Then
     list.add(self.link, 'note', FNote.Link);
  if (child_name = 'dosage') Then
     list.add(self.link, 'dosage', FDosage.Link);
end;

procedure TFhirMedicationAdministration.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'practitioner', 'Reference(Practitioner|Patient|RelatedPerson)', false, TFhirReference{Resource}, FPractitioner.Link));{2}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference(Encounter)', false, TFhirReference{TFhirEncounter}, FEncounter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'prescription', 'Reference(MedicationOrder)', false, TFhirReference{TFhirMedicationOrder}, FPrescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'wasNotGiven', 'boolean', false, TFhirBoolean, FWasNotGiven.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reasonNotGiven', 'CodeableConcept', true, TFhirCodeableConcept, FReasonNotGivenList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reasonGiven', 'CodeableConcept', true, TFhirCodeableConcept, FReasonGivenList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'effectiveTime[x]', 'dateTime|Period', false, TFhirType, FEffectiveTime.Link));{2}
  oList.add(TFHIRProperty.create(self, 'medication[x]', 'CodeableConcept|Reference(Medication)', false, TFhirType, FMedication.Link));{2}
  oList.add(TFHIRProperty.create(self, 'device', 'Reference(Device)', true, TFhirReference{TFhirDevice}, FDeviceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'note', 'string', false, TFhirString, FNote.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dosage', '', false, TFhirMedicationAdministrationDosage, FDosage.Link));{2}
end;

function TFhirMedicationAdministration.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirMedicationAdminStatusEnum, CODES_TFhirMedicationAdminStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'practitioner') then
  begin
    Practitioner := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference{TFhirEncounter}{4b};
    result := propValue;
  end
  else if (propName = 'prescription') then
  begin
    Prescription := propValue as TFhirReference{TFhirMedicationOrder}{4b};
    result := propValue;
  end
  else if (propName = 'wasNotGiven') then
  begin
    WasNotGivenElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'reasonNotGiven') then
  begin
    ReasonNotGivenList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'reasonGiven') then
  begin
    ReasonGivenList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'effectiveTime', ['DateTime', 'Period'])) then
  begin
    EffectiveTime := propValue as TFhirType{4};
    result := propValue;
  end
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then
  begin
    Medication := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'device') then
  begin
    DeviceList.add(propValue as TFhirReference{TFhirDevice}){2a};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'dosage') then
  begin
    Dosage := propValue as TFhirMedicationAdministrationDosage{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirMedicationAdministration.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'reasonNotGiven') then ReasonNotGivenList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'reasonGiven') then ReasonGivenList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'device') then DeviceList.insertItem(index, propValue as TFhirReference{TFhirDevice}){2a}
  else inherited;
end;

function TFhirMedicationAdministration.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'practitioner') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'encounter') then result := TFhirReference{TFhirEncounter}.create(){4b}
  else if (propName = 'prescription') then result := TFhirReference{TFhirMedicationOrder}.create(){4b}
  else if (propName = 'wasNotGiven') then result := TFhirBoolean.create() {5b}
  else if (propName = 'reasonNotGiven') then result := ReasonNotGivenList.new(){2}
  else if (propName = 'reasonGiven') then result := ReasonGivenList.new(){2}
  else if (isMatchingName(propName, 'effectiveTime', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property EffectiveTime'){4x}
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Medication'){4x}
  else if (propName = 'device') then result := DeviceList.new(){2}
  else if (propName = 'note') then result := TFhirString.create() {5b}
  else if (propName = 'dosage') then result := TFhirMedicationAdministrationDosage.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationAdministration.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'practitioner') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'prescription') then result := 'Reference'
  else if (propName = 'wasNotGiven') then result := 'boolean'
  else if (propName = 'reasonNotGiven') then result := 'CodeableConcept'
  else if (propName = 'reasonGiven') then result := 'CodeableConcept'
  else if (propName = 'effectiveTime[x]') then result := 'dateTime|Period'
  else if (propName = 'medication[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'device') then result := 'Reference'
  else if (propName = 'note') then result := 'string'
  else if (propName = 'dosage') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationAdministration.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'practitioner') then PractitionerElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'prescription') then PrescriptionElement := nil
  else if (propName = 'wasNotGiven') then WasNotGivenElement := nil
  else if (propName = 'reasonNotGiven') then deletePropertyValue('reasonNotGiven', ReasonNotGivenList, value) {2}
  else if (propName = 'reasonGiven') then deletePropertyValue('reasonGiven', ReasonGivenList, value) {2}
  else if (isMatchingName(propName, 'effectiveTime', ['DateTime', 'Period'])) then EffectiveTimeElement := nil{4x}
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then MedicationElement := nil{4x}
  else if (propName = 'device') then deletePropertyValue('device', DeviceList, value) {2}
  else if (propName = 'note') then NoteElement := nil
  else if (propName = 'dosage') then DosageElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationAdministration.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirMedicationAdminStatusEnum, CODES_TFhirMedicationAdminStatusEnum, new){4}
  else if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'practitioner') then PractitionerElement := new as TFhirReference{Resource}{4}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference{TFhirEncounter}{4}
  else if (propName = 'prescription') then PrescriptionElement := new as TFhirReference{TFhirMedicationOrder}{4}
  else if (propName = 'wasNotGiven') then WasNotGivenElement := asBoolean(new){5b}
  else if (propName = 'reasonNotGiven') then replacePropertyValue('reasonNotGiven', ReasonNotGivenList, existing, new) {2}
  else if (propName = 'reasonGiven') then replacePropertyValue('reasonGiven', ReasonGivenList, existing, new) {2}
  else if (isMatchingName(propName, 'effectiveTime', ['DateTime', 'Period'])) then EffectiveTimeElement := new as TFhirType{4x}
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then MedicationElement := new as TFhirType{4x}
  else if (propName = 'device') then replacePropertyValue('device', DeviceList, existing, new) {2}
  else if (propName = 'note') then NoteElement := asString(new){5b}
  else if (propName = 'dosage') then DosageElement := new as TFhirMedicationAdministrationDosage{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationAdministration.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'reasonNotGiven') then ReasonNotGivenList.move(source, destination){2a}
  else if (propName = 'reasonGiven') then ReasonGivenList.move(source, destination){2a}
  else if (propName = 'device') then DeviceList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationAdministration.fhirType : string;
begin
  result := 'MedicationAdministration';
end;

function TFhirMedicationAdministration.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FPatient) and isEmptyProp(FPractitioner) and isEmptyProp(FEncounter) and isEmptyProp(FPrescription) and isEmptyProp(FWasNotGiven) and isEmptyProp(FreasonNotGivenList) and isEmptyProp(FreasonGivenList) and isEmptyProp(FEffectiveTime) and isEmptyProp(FMedication) and isEmptyProp(FdeviceList) and isEmptyProp(FNote) and isEmptyProp(FDosage);
end;

function TFhirMedicationAdministration.equals(other : TObject) : boolean;
var
  o : TFhirMedicationAdministration;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationAdministration)) then
    result := false
  else
  begin
    o := TFhirMedicationAdministration(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(patientElement, o.patientElement, true) and compareDeep(practitionerElement, o.practitionerElement, true) and
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(prescriptionElement, o.prescriptionElement, true) and
      compareDeep(wasNotGivenElement, o.wasNotGivenElement, true) and compareDeep(reasonNotGivenList, o.reasonNotGivenList, true) and
      compareDeep(reasonGivenList, o.reasonGivenList, true) and compareDeep(effectiveTimeElement, o.effectiveTimeElement, true) and
      compareDeep(medicationElement, o.medicationElement, true) and compareDeep(deviceList, o.deviceList, true) and
      compareDeep(noteElement, o.noteElement, true) and compareDeep(dosageElement, o.dosageElement, true);
  end;
end;

function TFhirMedicationAdministration.Link : TFhirMedicationAdministration;
begin
  result := TFhirMedicationAdministration(inherited Link);
end;

function TFhirMedicationAdministration.Clone : TFhirMedicationAdministration;
begin
  result := TFhirMedicationAdministration(inherited Clone);
end;

procedure TFhirMedicationAdministration.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('patient');
  fields.add('practitioner');
  fields.add('encounter');
  fields.add('prescription');
  fields.add('wasNotGiven');
  fields.add('reasonNotGiven');
  fields.add('reasonGiven');
  fields.add('effectiveTime[x]');
  fields.add('medication[x]');
  fields.add('device');
  fields.add('note');
  fields.add('dosage');
end;

{ TFhirMedicationAdministration }

Function TFhirMedicationAdministration.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirMedicationAdministration.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirMedicationAdministration.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirMedicationAdministration.GetStatusST : TFhirMedicationAdminStatusEnum;
begin
  if FStatus = nil then
    result := TFhirMedicationAdminStatusEnum(0)
  else
    result := TFhirMedicationAdminStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirMedicationAdminStatusEnum, FStatus.value));
end;

Procedure TFhirMedicationAdministration.SetStatusST(value : TFhirMedicationAdminStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirMedicationAdminStatusEnum[value], CODES_TFhirMedicationAdminStatusEnum[value]);
end;

Procedure TFhirMedicationAdministration.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Procedure TFhirMedicationAdministration.SetPractitioner(value : TFhirReference{Resource});
begin
  FPractitioner.free;
  FPractitioner := value;
end;

Procedure TFhirMedicationAdministration.SetEncounter(value : TFhirReference{TFhirEncounter});
begin
  FEncounter.free;
  FEncounter := value;
end;

Procedure TFhirMedicationAdministration.SetPrescription(value : TFhirReference{TFhirMedicationOrder});
begin
  FPrescription.free;
  FPrescription := value;
end;

Procedure TFhirMedicationAdministration.SetWasNotGiven(value : TFhirBoolean);
begin
  FWasNotGiven.free;
  FWasNotGiven := value;
end;

Function TFhirMedicationAdministration.GetWasNotGivenST : Boolean;
begin
  if FWasNotGiven = nil then
    result := false
  else
    result := FWasNotGiven.value;
end;

Procedure TFhirMedicationAdministration.SetWasNotGivenST(value : Boolean);
begin
  if FWasNotGiven = nil then
    FWasNotGiven := TFhirBoolean.create;
  FWasNotGiven.value := value
end;

Function TFhirMedicationAdministration.GetReasonNotGivenList : TFhirCodeableConceptList;
begin
  if FReasonNotGivenList = nil then
    FReasonNotGivenList := TFhirCodeableConceptList.Create;
  result := FReasonNotGivenList;
end;

Function TFhirMedicationAdministration.GetHasReasonNotGivenList : boolean;
begin
  result := (FReasonNotGivenList <> nil) and (FReasonNotGivenList.count > 0);
end;

Function TFhirMedicationAdministration.GetReasonGivenList : TFhirCodeableConceptList;
begin
  if FReasonGivenList = nil then
    FReasonGivenList := TFhirCodeableConceptList.Create;
  result := FReasonGivenList;
end;

Function TFhirMedicationAdministration.GetHasReasonGivenList : boolean;
begin
  result := (FReasonGivenList <> nil) and (FReasonGivenList.count > 0);
end;

Procedure TFhirMedicationAdministration.SetEffectiveTime(value : TFhirType);
begin
  FEffectiveTime.free;
  FEffectiveTime := value;
end;

Procedure TFhirMedicationAdministration.SetMedication(value : TFhirType);
begin
  FMedication.free;
  FMedication := value;
end;

Function TFhirMedicationAdministration.GetDeviceList : TFhirReferenceList{TFhirDevice};
begin
  if FDeviceList = nil then
    FDeviceList := TFhirReferenceList{TFhirDevice}.Create;
  result := FDeviceList;
end;

Function TFhirMedicationAdministration.GetHasDeviceList : boolean;
begin
  result := (FDeviceList <> nil) and (FDeviceList.count > 0);
end;

Procedure TFhirMedicationAdministration.SetNote(value : TFhirString);
begin
  FNote.free;
  FNote := value;
end;

Function TFhirMedicationAdministration.GetNoteST : String;
begin
  if FNote = nil then
    result := ''
  else
    result := FNote.value;
end;

Procedure TFhirMedicationAdministration.SetNoteST(value : String);
begin
  if value <> '' then
  begin
    if FNote = nil then
      FNote := TFhirString.create;
    FNote.value := value
  end
  else if FNote <> nil then
    FNote.value := '';
end;

Procedure TFhirMedicationAdministration.SetDosage(value : TFhirMedicationAdministrationDosage);
begin
  FDosage.free;
  FDosage := value;
end;

function TFhirMedicationAdministration.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FPractitioner.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FPrescription.sizeInBytes);
  inc(result, FWasNotGiven.sizeInBytes);
  inc(result, FreasonNotGivenList.sizeInBytes);
  inc(result, FreasonGivenList.sizeInBytes);
  inc(result, FEffectiveTime.sizeInBytes);
  inc(result, FMedication.sizeInBytes);
  inc(result, FdeviceList.sizeInBytes);
  inc(result, FNote.sizeInBytes);
  inc(result, FDosage.sizeInBytes);
end;

{ TFhirMedicationAdministrationListEnumerator }

Constructor TFhirMedicationAdministrationListEnumerator.Create(list : TFhirMedicationAdministrationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationAdministrationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationAdministrationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationAdministrationListEnumerator.GetCurrent : TFhirMedicationAdministration;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationAdministrationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationAdministrationList }
procedure TFhirMedicationAdministrationList.AddItem(value: TFhirMedicationAdministration);
begin
  assert(value.ClassName = 'TFhirMedicationAdministration', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationAdministration');
  add(value);
end;

function TFhirMedicationAdministrationList.Append: TFhirMedicationAdministration;
begin
  result := TFhirMedicationAdministration.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationAdministrationList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationAdministrationList.GetEnumerator : TFhirMedicationAdministrationListEnumerator;
begin
  result := TFhirMedicationAdministrationListEnumerator.Create(self.link);
end;

function TFhirMedicationAdministrationList.Clone: TFhirMedicationAdministrationList;
begin
  result := TFhirMedicationAdministrationList(inherited Clone);
end;

function TFhirMedicationAdministrationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationAdministrationList.GetItemN(index: Integer): TFhirMedicationAdministration;
begin
  result := TFhirMedicationAdministration(ObjectByIndex[index]);
end;

function TFhirMedicationAdministrationList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationAdministration;
end;
function TFhirMedicationAdministrationList.IndexOf(value: TFhirMedicationAdministration): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationAdministrationList.Insert(index: Integer): TFhirMedicationAdministration;
begin
  result := TFhirMedicationAdministration.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationAdministrationList.InsertItem(index: Integer; value: TFhirMedicationAdministration);
begin
  assert(value is TFhirMedicationAdministration);
  Inherited Insert(index, value);
end;

function TFhirMedicationAdministrationList.Item(index: Integer): TFhirMedicationAdministration;
begin
  result := TFhirMedicationAdministration(ObjectByIndex[index]);
end;

function TFhirMedicationAdministrationList.Link: TFhirMedicationAdministrationList;
begin
  result := TFhirMedicationAdministrationList(inherited Link);
end;

procedure TFhirMedicationAdministrationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationAdministrationList.SetItemByIndex(index: Integer; value: TFhirMedicationAdministration);
begin
  assert(value is TFhirMedicationAdministration);
  FhirMedicationAdministrations[index] := value;
end;

procedure TFhirMedicationAdministrationList.SetItemN(index: Integer; value: TFhirMedicationAdministration);
begin
  assert(value is TFhirMedicationAdministration);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEDICATIONADMINISTRATION}

{$IFDEF FHIR_MEDICATIONDISPENSE}

{ TFhirMedicationDispenseDosageInstruction }

constructor TFhirMedicationDispenseDosageInstruction.Create;
begin
  inherited;
end;

destructor TFhirMedicationDispenseDosageInstruction.Destroy;
begin
  FText.free;
  FAdditionalInstructions.free;
  FTiming.free;
  FAsNeeded.free;
  FSite.free;
  FRoute.free;
  FMethod.free;
  FDose.free;
  FRate.free;
  FMaxDosePerPeriod.free;
  inherited;
end;

procedure TFhirMedicationDispenseDosageInstruction.Assign(oSource : TFslObject);
begin
  inherited;
  textElement := TFhirMedicationDispenseDosageInstruction(oSource).textElement.Clone;
  additionalInstructions := TFhirMedicationDispenseDosageInstruction(oSource).additionalInstructions.Clone;
  timing := TFhirMedicationDispenseDosageInstruction(oSource).timing.Clone;
  asNeeded := TFhirMedicationDispenseDosageInstruction(oSource).asNeeded.Clone;
  site := TFhirMedicationDispenseDosageInstruction(oSource).site.Clone;
  route := TFhirMedicationDispenseDosageInstruction(oSource).route.Clone;
  method := TFhirMedicationDispenseDosageInstruction(oSource).method.Clone;
  dose := TFhirMedicationDispenseDosageInstruction(oSource).dose.Clone;
  rate := TFhirMedicationDispenseDosageInstruction(oSource).rate.Clone;
  maxDosePerPeriod := TFhirMedicationDispenseDosageInstruction(oSource).maxDosePerPeriod.Clone;
end;

procedure TFhirMedicationDispenseDosageInstruction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'additionalInstructions') Then
     list.add(self.link, 'additionalInstructions', FAdditionalInstructions.Link);
  if (child_name = 'timing') Then
     list.add(self.link, 'timing', FTiming.Link);
  if (child_name = 'asNeeded[x]') or (child_name = 'asNeeded') Then
     list.add(self.link, 'asNeeded[x]', FAsNeeded.Link);
  if (child_name = 'site[x]') or (child_name = 'site') Then
     list.add(self.link, 'site[x]', FSite.Link);
  if (child_name = 'route') Then
     list.add(self.link, 'route', FRoute.Link);
  if (child_name = 'method') Then
     list.add(self.link, 'method', FMethod.Link);
  if (child_name = 'dose[x]') or (child_name = 'dose') Then
     list.add(self.link, 'dose[x]', FDose.Link);
  if (child_name = 'rate[x]') or (child_name = 'rate') Then
     list.add(self.link, 'rate[x]', FRate.Link);
  if (child_name = 'maxDosePerPeriod') Then
     list.add(self.link, 'maxDosePerPeriod', FMaxDosePerPeriod.Link);
end;

procedure TFhirMedicationDispenseDosageInstruction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));{2}
  oList.add(TFHIRProperty.create(self, 'additionalInstructions', 'CodeableConcept', false, TFhirCodeableConcept, FAdditionalInstructions.Link));{2}
  oList.add(TFHIRProperty.create(self, 'timing', 'Timing', false, TFhirTiming, FTiming.Link));{2}
  oList.add(TFHIRProperty.create(self, 'asNeeded[x]', 'boolean|CodeableConcept', false, TFhirType, FAsNeeded.Link));{2}
  oList.add(TFHIRProperty.create(self, 'site[x]', 'CodeableConcept|Reference(BodySite)', false, TFhirType, FSite.Link));{2}
  oList.add(TFHIRProperty.create(self, 'route', 'CodeableConcept', false, TFhirCodeableConcept, FRoute.Link));{2}
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', false, TFhirCodeableConcept, FMethod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dose[x]', 'Range|Quantity', false, TFhirType, FDose.Link));{2}
  oList.add(TFHIRProperty.create(self, 'rate[x]', 'Ratio|Range', false, TFhirType, FRate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'maxDosePerPeriod', 'Ratio', false, TFhirRatio, FMaxDosePerPeriod.Link));{2}
end;

function TFhirMedicationDispenseDosageInstruction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'text') then
  begin
    TextElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'additionalInstructions') then
  begin
    AdditionalInstructions := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'timing') then
  begin
    Timing := propValue as TFhirTiming{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'asNeeded', ['Boolean', 'CodeableConcept'])) then
  begin
    AsNeeded := propValue as TFhirType{4};
    result := propValue;
  end
  else if (isMatchingName(propName, 'site', ['CodeableConcept', 'Reference'])) then
  begin
    Site := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'route') then
  begin
    Route := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'method') then
  begin
    Method := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'dose', ['Range', 'Quantity'])) then
  begin
    Dose := propValue as TFhirType{4};
    result := propValue;
  end
  else if (isMatchingName(propName, 'rate', ['Ratio', 'Range'])) then
  begin
    Rate := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'maxDosePerPeriod') then
  begin
    MaxDosePerPeriod := propValue as TFhirRatio{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationDispenseDosageInstruction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationDispenseDosageInstruction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'text') then result := TFhirString.create() {5b}
  else if (propName = 'additionalInstructions') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'timing') then result := TFhirTiming.create(){4b}
  else if (isMatchingName(propName, 'asNeeded', ['Boolean', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property AsNeeded'){4x}
  else if (isMatchingName(propName, 'site', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Site'){4x}
  else if (propName = 'route') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'method') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'dose', ['Range', 'Quantity'])) then raise EFHIRException.create('Cannot make property Dose'){4x}
  else if (isMatchingName(propName, 'rate', ['Ratio', 'Range'])) then raise EFHIRException.create('Cannot make property Rate'){4x}
  else if (propName = 'maxDosePerPeriod') then result := TFhirRatio.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationDispenseDosageInstruction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'text') then result := 'string'
  else if (propName = 'additionalInstructions') then result := 'CodeableConcept'
  else if (propName = 'timing') then result := 'Timing'
  else if (propName = 'asNeeded[x]') then result := 'boolean|CodeableConcept'
  else if (propName = 'site[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'route') then result := 'CodeableConcept'
  else if (propName = 'method') then result := 'CodeableConcept'
  else if (propName = 'dose[x]') then result := 'Range|Quantity'
  else if (propName = 'rate[x]') then result := 'Ratio|Range'
  else if (propName = 'maxDosePerPeriod') then result := 'Ratio'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationDispenseDosageInstruction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'text') then TextElement := nil
  else if (propName = 'additionalInstructions') then AdditionalInstructionsElement := nil
  else if (propName = 'timing') then TimingElement := nil
  else if (isMatchingName(propName, 'asNeeded', ['Boolean', 'CodeableConcept'])) then AsNeededElement := nil{4x}
  else if (isMatchingName(propName, 'site', ['CodeableConcept', 'Reference'])) then SiteElement := nil{4x}
  else if (propName = 'route') then RouteElement := nil
  else if (propName = 'method') then MethodElement := nil
  else if (isMatchingName(propName, 'dose', ['Range', 'Quantity'])) then DoseElement := nil{4x}
  else if (isMatchingName(propName, 'rate', ['Ratio', 'Range'])) then RateElement := nil{4x}
  else if (propName = 'maxDosePerPeriod') then MaxDosePerPeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationDispenseDosageInstruction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'text') then TextElement := asString(new){5b}
  else if (propName = 'additionalInstructions') then AdditionalInstructionsElement := new as TFhirCodeableConcept{4}
  else if (propName = 'timing') then TimingElement := new as TFhirTiming{4}
  else if (isMatchingName(propName, 'asNeeded', ['Boolean', 'CodeableConcept'])) then AsNeededElement := new as TFhirType{4x}
  else if (isMatchingName(propName, 'site', ['CodeableConcept', 'Reference'])) then SiteElement := new as TFhirType{4x}
  else if (propName = 'route') then RouteElement := new as TFhirCodeableConcept{4}
  else if (propName = 'method') then MethodElement := new as TFhirCodeableConcept{4}
  else if (isMatchingName(propName, 'dose', ['Range', 'Quantity'])) then DoseElement := new as TFhirType{4x}
  else if (isMatchingName(propName, 'rate', ['Ratio', 'Range'])) then RateElement := new as TFhirType{4x}
  else if (propName = 'maxDosePerPeriod') then MaxDosePerPeriodElement := new as TFhirRatio{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationDispenseDosageInstruction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationDispenseDosageInstruction.fhirType : string;
begin
  result := 'dosageInstruction';
end;

function TFhirMedicationDispenseDosageInstruction.Link : TFhirMedicationDispenseDosageInstruction;
begin
  result := TFhirMedicationDispenseDosageInstruction(inherited Link);
end;

function TFhirMedicationDispenseDosageInstruction.Clone : TFhirMedicationDispenseDosageInstruction;
begin
  result := TFhirMedicationDispenseDosageInstruction(inherited Clone);
end;

function TFhirMedicationDispenseDosageInstruction.equals(other : TObject) : boolean;
var
  o : TFhirMedicationDispenseDosageInstruction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationDispenseDosageInstruction)) then
    result := false
  else
  begin
    o := TFhirMedicationDispenseDosageInstruction(other);
    result := compareDeep(textElement, o.textElement, true) and compareDeep(additionalInstructionsElement, o.additionalInstructionsElement, true) and
      compareDeep(timingElement, o.timingElement, true) and compareDeep(asNeededElement, o.asNeededElement, true) and
      compareDeep(siteElement, o.siteElement, true) and compareDeep(routeElement, o.routeElement, true) and
      compareDeep(methodElement, o.methodElement, true) and compareDeep(doseElement, o.doseElement, true) and
      compareDeep(rateElement, o.rateElement, true) and compareDeep(maxDosePerPeriodElement, o.maxDosePerPeriodElement, true);
  end;
end;

function TFhirMedicationDispenseDosageInstruction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FText) and isEmptyProp(FAdditionalInstructions) and isEmptyProp(FTiming) and isEmptyProp(FAsNeeded) and isEmptyProp(FSite) and isEmptyProp(FRoute) and isEmptyProp(FMethod) and isEmptyProp(FDose) and isEmptyProp(FRate) and isEmptyProp(FMaxDosePerPeriod);
end;

procedure TFhirMedicationDispenseDosageInstruction.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('text');
  fields.add('additionalInstructions');
  fields.add('timing');
  fields.add('asNeeded[x]');
  fields.add('site[x]');
  fields.add('route');
  fields.add('method');
  fields.add('dose[x]');
  fields.add('rate[x]');
  fields.add('maxDosePerPeriod');
end;

{ TFhirMedicationDispenseDosageInstruction }

Procedure TFhirMedicationDispenseDosageInstruction.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

Function TFhirMedicationDispenseDosageInstruction.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

Procedure TFhirMedicationDispenseDosageInstruction.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

Procedure TFhirMedicationDispenseDosageInstruction.SetAdditionalInstructions(value : TFhirCodeableConcept);
begin
  FAdditionalInstructions.free;
  FAdditionalInstructions := value;
end;

Procedure TFhirMedicationDispenseDosageInstruction.SetTiming(value : TFhirTiming);
begin
  FTiming.free;
  FTiming := value;
end;

Procedure TFhirMedicationDispenseDosageInstruction.SetAsNeeded(value : TFhirType);
begin
  FAsNeeded.free;
  FAsNeeded := value;
end;

Procedure TFhirMedicationDispenseDosageInstruction.SetSite(value : TFhirType);
begin
  FSite.free;
  FSite := value;
end;

Procedure TFhirMedicationDispenseDosageInstruction.SetRoute(value : TFhirCodeableConcept);
begin
  FRoute.free;
  FRoute := value;
end;

Procedure TFhirMedicationDispenseDosageInstruction.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value;
end;

Procedure TFhirMedicationDispenseDosageInstruction.SetDose(value : TFhirType);
begin
  FDose.free;
  FDose := value;
end;

Procedure TFhirMedicationDispenseDosageInstruction.SetRate(value : TFhirType);
begin
  FRate.free;
  FRate := value;
end;

Procedure TFhirMedicationDispenseDosageInstruction.SetMaxDosePerPeriod(value : TFhirRatio);
begin
  FMaxDosePerPeriod.free;
  FMaxDosePerPeriod := value;
end;

function TFhirMedicationDispenseDosageInstruction.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FText.sizeInBytes);
  inc(result, FAdditionalInstructions.sizeInBytes);
  inc(result, FTiming.sizeInBytes);
  inc(result, FAsNeeded.sizeInBytes);
  inc(result, FSite.sizeInBytes);
  inc(result, FRoute.sizeInBytes);
  inc(result, FMethod.sizeInBytes);
  inc(result, FDose.sizeInBytes);
  inc(result, FRate.sizeInBytes);
  inc(result, FMaxDosePerPeriod.sizeInBytes);
end;

{ TFhirMedicationDispenseDosageInstructionListEnumerator }

Constructor TFhirMedicationDispenseDosageInstructionListEnumerator.Create(list : TFhirMedicationDispenseDosageInstructionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationDispenseDosageInstructionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationDispenseDosageInstructionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationDispenseDosageInstructionListEnumerator.GetCurrent : TFhirMedicationDispenseDosageInstruction;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationDispenseDosageInstructionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationDispenseDosageInstructionList }
procedure TFhirMedicationDispenseDosageInstructionList.AddItem(value: TFhirMedicationDispenseDosageInstruction);
begin
  assert(value.ClassName = 'TFhirMedicationDispenseDosageInstruction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationDispenseDosageInstruction');
  add(value);
end;

function TFhirMedicationDispenseDosageInstructionList.Append: TFhirMedicationDispenseDosageInstruction;
begin
  result := TFhirMedicationDispenseDosageInstruction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationDispenseDosageInstructionList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationDispenseDosageInstructionList.GetEnumerator : TFhirMedicationDispenseDosageInstructionListEnumerator;
begin
  result := TFhirMedicationDispenseDosageInstructionListEnumerator.Create(self.link);
end;

function TFhirMedicationDispenseDosageInstructionList.Clone: TFhirMedicationDispenseDosageInstructionList;
begin
  result := TFhirMedicationDispenseDosageInstructionList(inherited Clone);
end;

function TFhirMedicationDispenseDosageInstructionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationDispenseDosageInstructionList.GetItemN(index: Integer): TFhirMedicationDispenseDosageInstruction;
begin
  result := TFhirMedicationDispenseDosageInstruction(ObjectByIndex[index]);
end;

function TFhirMedicationDispenseDosageInstructionList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationDispenseDosageInstruction;
end;
function TFhirMedicationDispenseDosageInstructionList.IndexOf(value: TFhirMedicationDispenseDosageInstruction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationDispenseDosageInstructionList.Insert(index: Integer): TFhirMedicationDispenseDosageInstruction;
begin
  result := TFhirMedicationDispenseDosageInstruction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationDispenseDosageInstructionList.InsertItem(index: Integer; value: TFhirMedicationDispenseDosageInstruction);
begin
  assert(value is TFhirMedicationDispenseDosageInstruction);
  Inherited Insert(index, value);
end;

function TFhirMedicationDispenseDosageInstructionList.Item(index: Integer): TFhirMedicationDispenseDosageInstruction;
begin
  result := TFhirMedicationDispenseDosageInstruction(ObjectByIndex[index]);
end;

function TFhirMedicationDispenseDosageInstructionList.Link: TFhirMedicationDispenseDosageInstructionList;
begin
  result := TFhirMedicationDispenseDosageInstructionList(inherited Link);
end;

procedure TFhirMedicationDispenseDosageInstructionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationDispenseDosageInstructionList.SetItemByIndex(index: Integer; value: TFhirMedicationDispenseDosageInstruction);
begin
  assert(value is TFhirMedicationDispenseDosageInstruction);
  FhirMedicationDispenseDosageInstructions[index] := value;
end;

procedure TFhirMedicationDispenseDosageInstructionList.SetItemN(index: Integer; value: TFhirMedicationDispenseDosageInstruction);
begin
  assert(value is TFhirMedicationDispenseDosageInstruction);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationDispenseSubstitution }

constructor TFhirMedicationDispenseSubstitution.Create;
begin
  inherited;
end;

destructor TFhirMedicationDispenseSubstitution.Destroy;
begin
  FType_.free;
  FReasonList.Free;
  FResponsiblePartyList.Free;
  inherited;
end;

procedure TFhirMedicationDispenseSubstitution.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicationDispenseSubstitution(oSource).type_.Clone;
  if (TFhirMedicationDispenseSubstitution(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableConceptList.Create;
    FReasonList.Assign(TFhirMedicationDispenseSubstitution(oSource).FReasonList);
  end;
  if (TFhirMedicationDispenseSubstitution(oSource).FResponsiblePartyList = nil) then
  begin
    FResponsiblePartyList.free;
    FResponsiblePartyList := nil;
  end
  else
  begin
    if FResponsiblePartyList = nil then
      FResponsiblePartyList := TFhirReferenceList{TFhirPractitioner}.Create;
    FResponsiblePartyList.Assign(TFhirMedicationDispenseSubstitution(oSource).FResponsiblePartyList);
  end;
end;

procedure TFhirMedicationDispenseSubstitution.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'responsibleParty') Then
    list.addAll(self, 'responsibleParty', FResponsiblePartyList);
end;

procedure TFhirMedicationDispenseSubstitution.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', true, TFhirCodeableConcept, FReasonList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'responsibleParty', 'Reference(Practitioner)', true, TFhirReference{TFhirPractitioner}, FResponsiblePartyList.Link)){3};
end;

function TFhirMedicationDispenseSubstitution.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'responsibleParty') then
  begin
    ResponsiblePartyList.add(propValue as TFhirReference{TFhirPractitioner}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationDispenseSubstitution.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'responsibleParty') then ResponsiblePartyList.insertItem(index, propValue as TFhirReference{TFhirPractitioner}){2a}
  else inherited;
end;

function TFhirMedicationDispenseSubstitution.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'reason') then result := ReasonList.new(){2}
  else if (propName = 'responsibleParty') then result := ResponsiblePartyList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationDispenseSubstitution.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else if (propName = 'responsibleParty') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationDispenseSubstitution.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value) {2}
  else if (propName = 'responsibleParty') then deletePropertyValue('responsibleParty', ResponsiblePartyList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationDispenseSubstitution.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new) {2}
  else if (propName = 'responsibleParty') then replacePropertyValue('responsibleParty', ResponsiblePartyList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationDispenseSubstitution.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'reason') then ReasonList.move(source, destination){2a}
  else if (propName = 'responsibleParty') then ResponsiblePartyList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationDispenseSubstitution.fhirType : string;
begin
  result := 'substitution';
end;

function TFhirMedicationDispenseSubstitution.Link : TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution(inherited Link);
end;

function TFhirMedicationDispenseSubstitution.Clone : TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution(inherited Clone);
end;

function TFhirMedicationDispenseSubstitution.equals(other : TObject) : boolean;
var
  o : TFhirMedicationDispenseSubstitution;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationDispenseSubstitution)) then
    result := false
  else
  begin
    o := TFhirMedicationDispenseSubstitution(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(reasonList, o.reasonList, true) and
      compareDeep(responsiblePartyList, o.responsiblePartyList, true);
  end;
end;

function TFhirMedicationDispenseSubstitution.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FreasonList) and isEmptyProp(FresponsiblePartyList);
end;

procedure TFhirMedicationDispenseSubstitution.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('reason');
  fields.add('responsibleParty');
end;

{ TFhirMedicationDispenseSubstitution }

Procedure TFhirMedicationDispenseSubstitution.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirMedicationDispenseSubstitution.GetReasonList : TFhirCodeableConceptList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableConceptList.Create;
  result := FReasonList;
end;

Function TFhirMedicationDispenseSubstitution.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

Function TFhirMedicationDispenseSubstitution.GetResponsiblePartyList : TFhirReferenceList{TFhirPractitioner};
begin
  if FResponsiblePartyList = nil then
    FResponsiblePartyList := TFhirReferenceList{TFhirPractitioner}.Create;
  result := FResponsiblePartyList;
end;

Function TFhirMedicationDispenseSubstitution.GetHasResponsiblePartyList : boolean;
begin
  result := (FResponsiblePartyList <> nil) and (FResponsiblePartyList.count > 0);
end;

function TFhirMedicationDispenseSubstitution.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FreasonList.sizeInBytes);
  inc(result, FresponsiblePartyList.sizeInBytes);
end;

{ TFhirMedicationDispenseSubstitutionListEnumerator }

Constructor TFhirMedicationDispenseSubstitutionListEnumerator.Create(list : TFhirMedicationDispenseSubstitutionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationDispenseSubstitutionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationDispenseSubstitutionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationDispenseSubstitutionListEnumerator.GetCurrent : TFhirMedicationDispenseSubstitution;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationDispenseSubstitutionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationDispenseSubstitutionList }
procedure TFhirMedicationDispenseSubstitutionList.AddItem(value: TFhirMedicationDispenseSubstitution);
begin
  assert(value.ClassName = 'TFhirMedicationDispenseSubstitution', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationDispenseSubstitution');
  add(value);
end;

function TFhirMedicationDispenseSubstitutionList.Append: TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationDispenseSubstitutionList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationDispenseSubstitutionList.GetEnumerator : TFhirMedicationDispenseSubstitutionListEnumerator;
begin
  result := TFhirMedicationDispenseSubstitutionListEnumerator.Create(self.link);
end;

function TFhirMedicationDispenseSubstitutionList.Clone: TFhirMedicationDispenseSubstitutionList;
begin
  result := TFhirMedicationDispenseSubstitutionList(inherited Clone);
end;

function TFhirMedicationDispenseSubstitutionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationDispenseSubstitutionList.GetItemN(index: Integer): TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution(ObjectByIndex[index]);
end;

function TFhirMedicationDispenseSubstitutionList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationDispenseSubstitution;
end;
function TFhirMedicationDispenseSubstitutionList.IndexOf(value: TFhirMedicationDispenseSubstitution): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationDispenseSubstitutionList.Insert(index: Integer): TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationDispenseSubstitutionList.InsertItem(index: Integer; value: TFhirMedicationDispenseSubstitution);
begin
  assert(value is TFhirMedicationDispenseSubstitution);
  Inherited Insert(index, value);
end;

function TFhirMedicationDispenseSubstitutionList.Item(index: Integer): TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution(ObjectByIndex[index]);
end;

function TFhirMedicationDispenseSubstitutionList.Link: TFhirMedicationDispenseSubstitutionList;
begin
  result := TFhirMedicationDispenseSubstitutionList(inherited Link);
end;

procedure TFhirMedicationDispenseSubstitutionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationDispenseSubstitutionList.SetItemByIndex(index: Integer; value: TFhirMedicationDispenseSubstitution);
begin
  assert(value is TFhirMedicationDispenseSubstitution);
  FhirMedicationDispenseSubstitutions[index] := value;
end;

procedure TFhirMedicationDispenseSubstitutionList.SetItemN(index: Integer; value: TFhirMedicationDispenseSubstitution);
begin
  assert(value is TFhirMedicationDispenseSubstitution);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationDispense }

constructor TFhirMedicationDispense.Create;
begin
  inherited;
end;

destructor TFhirMedicationDispense.Destroy;
begin
  FIdentifier.free;
  FStatus.free;
  FPatient.free;
  FDispenser.free;
  FAuthorizingPrescriptionList.Free;
  FType_.free;
  FQuantity.free;
  FDaysSupply.free;
  FMedication.free;
  FWhenPrepared.free;
  FWhenHandedOver.free;
  FDestination.free;
  FReceiverList.Free;
  FNote.free;
  FDosageInstructionList.Free;
  FSubstitution.free;
  inherited;
end;

function TFhirMedicationDispense.GetResourceType : TFhirResourceType;
begin
  result := frtMedicationDispense;
end;

procedure TFhirMedicationDispense.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirMedicationDispense(oSource).identifier.Clone;
  FStatus := TFhirMedicationDispense(oSource).FStatus.Link;
  patient := TFhirMedicationDispense(oSource).patient.Clone;
  dispenser := TFhirMedicationDispense(oSource).dispenser.Clone;
  if (TFhirMedicationDispense(oSource).FAuthorizingPrescriptionList = nil) then
  begin
    FAuthorizingPrescriptionList.free;
    FAuthorizingPrescriptionList := nil;
  end
  else
  begin
    if FAuthorizingPrescriptionList = nil then
      FAuthorizingPrescriptionList := TFhirReferenceList{TFhirMedicationOrder}.Create;
    FAuthorizingPrescriptionList.Assign(TFhirMedicationDispense(oSource).FAuthorizingPrescriptionList);
  end;
  type_ := TFhirMedicationDispense(oSource).type_.Clone;
  quantity := TFhirMedicationDispense(oSource).quantity.Clone;
  daysSupply := TFhirMedicationDispense(oSource).daysSupply.Clone;
  medication := TFhirMedicationDispense(oSource).medication.Clone;
  whenPreparedElement := TFhirMedicationDispense(oSource).whenPreparedElement.Clone;
  whenHandedOverElement := TFhirMedicationDispense(oSource).whenHandedOverElement.Clone;
  destination := TFhirMedicationDispense(oSource).destination.Clone;
  if (TFhirMedicationDispense(oSource).FReceiverList = nil) then
  begin
    FReceiverList.free;
    FReceiverList := nil;
  end
  else
  begin
    if FReceiverList = nil then
      FReceiverList := TFhirReferenceList{Resource}.Create;
    FReceiverList.Assign(TFhirMedicationDispense(oSource).FReceiverList);
  end;
  noteElement := TFhirMedicationDispense(oSource).noteElement.Clone;
  if (TFhirMedicationDispense(oSource).FDosageInstructionList = nil) then
  begin
    FDosageInstructionList.free;
    FDosageInstructionList := nil;
  end
  else
  begin
    if FDosageInstructionList = nil then
      FDosageInstructionList := TFhirMedicationDispenseDosageInstructionList.Create;
    FDosageInstructionList.Assign(TFhirMedicationDispense(oSource).FDosageInstructionList);
  end;
  substitution := TFhirMedicationDispense(oSource).substitution.Clone;
end;

procedure TFhirMedicationDispense.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'dispenser') Then
     list.add(self.link, 'dispenser', FDispenser.Link);
  if (child_name = 'authorizingPrescription') Then
    list.addAll(self, 'authorizingPrescription', FAuthorizingPrescriptionList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'daysSupply') Then
     list.add(self.link, 'daysSupply', FDaysSupply.Link);
  if (child_name = 'medication[x]') or (child_name = 'medication') Then
     list.add(self.link, 'medication[x]', FMedication.Link);
  if (child_name = 'whenPrepared') Then
     list.add(self.link, 'whenPrepared', FWhenPrepared.Link);
  if (child_name = 'whenHandedOver') Then
     list.add(self.link, 'whenHandedOver', FWhenHandedOver.Link);
  if (child_name = 'destination') Then
     list.add(self.link, 'destination', FDestination.Link);
  if (child_name = 'receiver') Then
    list.addAll(self, 'receiver', FReceiverList);
  if (child_name = 'note') Then
     list.add(self.link, 'note', FNote.Link);
  if (child_name = 'dosageInstruction') Then
    list.addAll(self, 'dosageInstruction', FDosageInstructionList);
  if (child_name = 'substitution') Then
     list.add(self.link, 'substitution', FSubstitution.Link);
end;

procedure TFhirMedicationDispense.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dispenser', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FDispenser.Link));{2}
  oList.add(TFHIRProperty.create(self, 'authorizingPrescription', 'Reference(MedicationOrder)', true, TFhirReference{TFhirMedicationOrder}, FAuthorizingPrescriptionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'daysSupply', 'Quantity', false, TFhirQuantity, FDaysSupply.Link));{2}
  oList.add(TFHIRProperty.create(self, 'medication[x]', 'CodeableConcept|Reference(Medication)', false, TFhirType, FMedication.Link));{2}
  oList.add(TFHIRProperty.create(self, 'whenPrepared', 'dateTime', false, TFhirDateTime, FWhenPrepared.Link));{2}
  oList.add(TFHIRProperty.create(self, 'whenHandedOver', 'dateTime', false, TFhirDateTime, FWhenHandedOver.Link));{2}
  oList.add(TFHIRProperty.create(self, 'destination', 'Reference(Location)', false, TFhirReference{TFhirLocation}, FDestination.Link));{2}
  oList.add(TFHIRProperty.create(self, 'receiver', 'Reference(Patient|Practitioner)', true, TFhirReference{Resource}, FReceiverList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'note', 'string', false, TFhirString, FNote.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dosageInstruction', '', true, TFhirMedicationDispenseDosageInstruction, FDosageInstructionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'substitution', '', false, TFhirMedicationDispenseSubstitution, FSubstitution.Link));{2}
end;

function TFhirMedicationDispense.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirMedicationDispenseStatusEnum, CODES_TFhirMedicationDispenseStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'dispenser') then
  begin
    Dispenser := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'authorizingPrescription') then
  begin
    AuthorizingPrescriptionList.add(propValue as TFhirReference{TFhirMedicationOrder}){2a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'daysSupply') then
  begin
    DaysSupply := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then
  begin
    Medication := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'whenPrepared') then
  begin
    WhenPreparedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'whenHandedOver') then
  begin
    WhenHandedOverElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'destination') then
  begin
    Destination := propValue as TFhirReference{TFhirLocation}{4b};
    result := propValue;
  end
  else if (propName = 'receiver') then
  begin
    ReceiverList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'dosageInstruction') then
  begin
    DosageInstructionList.add(propValue as TFhirMedicationDispenseDosageInstruction){2a};
    result := propValue;
  end
  else if (propName = 'substitution') then
  begin
    Substitution := propValue as TFhirMedicationDispenseSubstitution{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirMedicationDispense.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'authorizingPrescription') then AuthorizingPrescriptionList.insertItem(index, propValue as TFhirReference{TFhirMedicationOrder}){2a}
  else if (propName = 'receiver') then ReceiverList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'dosageInstruction') then DosageInstructionList.insertItem(index, propValue as TFhirMedicationDispenseDosageInstruction){2a}
  else inherited;
end;

function TFhirMedicationDispense.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'dispenser') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'authorizingPrescription') then result := AuthorizingPrescriptionList.new(){2}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'daysSupply') then result := TFhirQuantity.create(){4b}
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Medication'){4x}
  else if (propName = 'whenPrepared') then result := TFhirDateTime.create() {5b}
  else if (propName = 'whenHandedOver') then result := TFhirDateTime.create() {5b}
  else if (propName = 'destination') then result := TFhirReference{TFhirLocation}.create(){4b}
  else if (propName = 'receiver') then result := ReceiverList.new(){2}
  else if (propName = 'note') then result := TFhirString.create() {5b}
  else if (propName = 'dosageInstruction') then result := DosageInstructionList.new(){2}
  else if (propName = 'substitution') then result := TFhirMedicationDispenseSubstitution.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationDispense.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'dispenser') then result := 'Reference'
  else if (propName = 'authorizingPrescription') then result := 'Reference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'daysSupply') then result := 'Quantity'
  else if (propName = 'medication[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'whenPrepared') then result := 'dateTime'
  else if (propName = 'whenHandedOver') then result := 'dateTime'
  else if (propName = 'destination') then result := 'Reference'
  else if (propName = 'receiver') then result := 'Reference'
  else if (propName = 'note') then result := 'string'
  else if (propName = 'dosageInstruction') then result := ''
  else if (propName = 'substitution') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationDispense.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'dispenser') then DispenserElement := nil
  else if (propName = 'authorizingPrescription') then deletePropertyValue('authorizingPrescription', AuthorizingPrescriptionList, value) {2}
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'daysSupply') then DaysSupplyElement := nil
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then MedicationElement := nil{4x}
  else if (propName = 'whenPrepared') then WhenPreparedElement := nil
  else if (propName = 'whenHandedOver') then WhenHandedOverElement := nil
  else if (propName = 'destination') then DestinationElement := nil
  else if (propName = 'receiver') then deletePropertyValue('receiver', ReceiverList, value) {2}
  else if (propName = 'note') then NoteElement := nil
  else if (propName = 'dosageInstruction') then deletePropertyValue('dosageInstruction', DosageInstructionList, value) {2}
  else if (propName = 'substitution') then SubstitutionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationDispense.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirMedicationDispenseStatusEnum, CODES_TFhirMedicationDispenseStatusEnum, new){4}
  else if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'dispenser') then DispenserElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'authorizingPrescription') then replacePropertyValue('authorizingPrescription', AuthorizingPrescriptionList, existing, new) {2}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'daysSupply') then DaysSupplyElement := new as TFhirQuantity{4}
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then MedicationElement := new as TFhirType{4x}
  else if (propName = 'whenPrepared') then WhenPreparedElement := asDateTime(new){5b}
  else if (propName = 'whenHandedOver') then WhenHandedOverElement := asDateTime(new){5b}
  else if (propName = 'destination') then DestinationElement := new as TFhirReference{TFhirLocation}{4}
  else if (propName = 'receiver') then replacePropertyValue('receiver', ReceiverList, existing, new) {2}
  else if (propName = 'note') then NoteElement := asString(new){5b}
  else if (propName = 'dosageInstruction') then replacePropertyValue('dosageInstruction', DosageInstructionList, existing, new) {2}
  else if (propName = 'substitution') then SubstitutionElement := new as TFhirMedicationDispenseSubstitution{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationDispense.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'authorizingPrescription') then AuthorizingPrescriptionList.move(source, destination){2a}
  else if (propName = 'receiver') then ReceiverList.move(source, destination){2a}
  else if (propName = 'dosageInstruction') then DosageInstructionList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationDispense.fhirType : string;
begin
  result := 'MedicationDispense';
end;

function TFhirMedicationDispense.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FStatus) and isEmptyProp(FPatient) and isEmptyProp(FDispenser) and isEmptyProp(FauthorizingPrescriptionList) and isEmptyProp(FType_) and isEmptyProp(FQuantity) and isEmptyProp(FDaysSupply) and isEmptyProp(FMedication) and isEmptyProp(FWhenPrepared) and isEmptyProp(FWhenHandedOver) and isEmptyProp(FDestination) and isEmptyProp(FreceiverList) and isEmptyProp(FNote) and isEmptyProp(FdosageInstructionList) and isEmptyProp(FSubstitution);
end;

function TFhirMedicationDispense.equals(other : TObject) : boolean;
var
  o : TFhirMedicationDispense;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationDispense)) then
    result := false
  else
  begin
    o := TFhirMedicationDispense(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(patientElement, o.patientElement, true) and compareDeep(dispenserElement, o.dispenserElement, true) and
      compareDeep(authorizingPrescriptionList, o.authorizingPrescriptionList, true) and
      compareDeep(type_Element, o.type_Element, true) and compareDeep(quantityElement, o.quantityElement, true) and
      compareDeep(daysSupplyElement, o.daysSupplyElement, true) and compareDeep(medicationElement, o.medicationElement, true) and
      compareDeep(whenPreparedElement, o.whenPreparedElement, true) and compareDeep(whenHandedOverElement, o.whenHandedOverElement, true) and
      compareDeep(destinationElement, o.destinationElement, true) and compareDeep(receiverList, o.receiverList, true) and
      compareDeep(noteElement, o.noteElement, true) and compareDeep(dosageInstructionList, o.dosageInstructionList, true) and
      compareDeep(substitutionElement, o.substitutionElement, true);
  end;
end;

function TFhirMedicationDispense.Link : TFhirMedicationDispense;
begin
  result := TFhirMedicationDispense(inherited Link);
end;

function TFhirMedicationDispense.Clone : TFhirMedicationDispense;
begin
  result := TFhirMedicationDispense(inherited Clone);
end;

procedure TFhirMedicationDispense.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('patient');
  fields.add('dispenser');
  fields.add('authorizingPrescription');
  fields.add('type');
  fields.add('quantity');
  fields.add('daysSupply');
  fields.add('medication[x]');
  fields.add('whenPrepared');
  fields.add('whenHandedOver');
  fields.add('destination');
  fields.add('receiver');
  fields.add('note');
  fields.add('dosageInstruction');
  fields.add('substitution');
end;

{ TFhirMedicationDispense }

Procedure TFhirMedicationDispense.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirMedicationDispense.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirMedicationDispense.GetStatusST : TFhirMedicationDispenseStatusEnum;
begin
  if FStatus = nil then
    result := TFhirMedicationDispenseStatusEnum(0)
  else
    result := TFhirMedicationDispenseStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirMedicationDispenseStatusEnum, FStatus.value));
end;

Procedure TFhirMedicationDispense.SetStatusST(value : TFhirMedicationDispenseStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirMedicationDispenseStatusEnum[value], CODES_TFhirMedicationDispenseStatusEnum[value]);
end;

Procedure TFhirMedicationDispense.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Procedure TFhirMedicationDispense.SetDispenser(value : TFhirReference{TFhirPractitioner});
begin
  FDispenser.free;
  FDispenser := value;
end;

Function TFhirMedicationDispense.GetAuthorizingPrescriptionList : TFhirReferenceList{TFhirMedicationOrder};
begin
  if FAuthorizingPrescriptionList = nil then
    FAuthorizingPrescriptionList := TFhirReferenceList{TFhirMedicationOrder}.Create;
  result := FAuthorizingPrescriptionList;
end;

Function TFhirMedicationDispense.GetHasAuthorizingPrescriptionList : boolean;
begin
  result := (FAuthorizingPrescriptionList <> nil) and (FAuthorizingPrescriptionList.count > 0);
end;

Procedure TFhirMedicationDispense.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirMedicationDispense.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirMedicationDispense.SetDaysSupply(value : TFhirQuantity);
begin
  FDaysSupply.free;
  FDaysSupply := value;
end;

Procedure TFhirMedicationDispense.SetMedication(value : TFhirType);
begin
  FMedication.free;
  FMedication := value;
end;

Procedure TFhirMedicationDispense.SetWhenPrepared(value : TFhirDateTime);
begin
  FWhenPrepared.free;
  FWhenPrepared := value;
end;

Function TFhirMedicationDispense.GetWhenPreparedST : TFslDateTime;
begin
  if FWhenPrepared = nil then
    result := TFslDateTime.makeNull
  else
    result := FWhenPrepared.value;
end;

Procedure TFhirMedicationDispense.SetWhenPreparedST(value : TFslDateTime);
begin
  if FWhenPrepared = nil then
    FWhenPrepared := TFhirDateTime.create;
  FWhenPrepared.value := value
end;

Procedure TFhirMedicationDispense.SetWhenHandedOver(value : TFhirDateTime);
begin
  FWhenHandedOver.free;
  FWhenHandedOver := value;
end;

Function TFhirMedicationDispense.GetWhenHandedOverST : TFslDateTime;
begin
  if FWhenHandedOver = nil then
    result := TFslDateTime.makeNull
  else
    result := FWhenHandedOver.value;
end;

Procedure TFhirMedicationDispense.SetWhenHandedOverST(value : TFslDateTime);
begin
  if FWhenHandedOver = nil then
    FWhenHandedOver := TFhirDateTime.create;
  FWhenHandedOver.value := value
end;

Procedure TFhirMedicationDispense.SetDestination(value : TFhirReference{TFhirLocation});
begin
  FDestination.free;
  FDestination := value;
end;

Function TFhirMedicationDispense.GetReceiverList : TFhirReferenceList{Resource};
begin
  if FReceiverList = nil then
    FReceiverList := TFhirReferenceList{Resource}.Create;
  result := FReceiverList;
end;

Function TFhirMedicationDispense.GetHasReceiverList : boolean;
begin
  result := (FReceiverList <> nil) and (FReceiverList.count > 0);
end;

Procedure TFhirMedicationDispense.SetNote(value : TFhirString);
begin
  FNote.free;
  FNote := value;
end;

Function TFhirMedicationDispense.GetNoteST : String;
begin
  if FNote = nil then
    result := ''
  else
    result := FNote.value;
end;

Procedure TFhirMedicationDispense.SetNoteST(value : String);
begin
  if value <> '' then
  begin
    if FNote = nil then
      FNote := TFhirString.create;
    FNote.value := value
  end
  else if FNote <> nil then
    FNote.value := '';
end;

Function TFhirMedicationDispense.GetDosageInstructionList : TFhirMedicationDispenseDosageInstructionList;
begin
  if FDosageInstructionList = nil then
    FDosageInstructionList := TFhirMedicationDispenseDosageInstructionList.Create;
  result := FDosageInstructionList;
end;

Function TFhirMedicationDispense.GetHasDosageInstructionList : boolean;
begin
  result := (FDosageInstructionList <> nil) and (FDosageInstructionList.count > 0);
end;

Procedure TFhirMedicationDispense.SetSubstitution(value : TFhirMedicationDispenseSubstitution);
begin
  FSubstitution.free;
  FSubstitution := value;
end;

function TFhirMedicationDispense.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FDispenser.sizeInBytes);
  inc(result, FauthorizingPrescriptionList.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FDaysSupply.sizeInBytes);
  inc(result, FMedication.sizeInBytes);
  inc(result, FWhenPrepared.sizeInBytes);
  inc(result, FWhenHandedOver.sizeInBytes);
  inc(result, FDestination.sizeInBytes);
  inc(result, FreceiverList.sizeInBytes);
  inc(result, FNote.sizeInBytes);
  inc(result, FdosageInstructionList.sizeInBytes);
  inc(result, FSubstitution.sizeInBytes);
end;

{ TFhirMedicationDispenseListEnumerator }

Constructor TFhirMedicationDispenseListEnumerator.Create(list : TFhirMedicationDispenseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationDispenseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationDispenseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationDispenseListEnumerator.GetCurrent : TFhirMedicationDispense;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationDispenseListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationDispenseList }
procedure TFhirMedicationDispenseList.AddItem(value: TFhirMedicationDispense);
begin
  assert(value.ClassName = 'TFhirMedicationDispense', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationDispense');
  add(value);
end;

function TFhirMedicationDispenseList.Append: TFhirMedicationDispense;
begin
  result := TFhirMedicationDispense.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationDispenseList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationDispenseList.GetEnumerator : TFhirMedicationDispenseListEnumerator;
begin
  result := TFhirMedicationDispenseListEnumerator.Create(self.link);
end;

function TFhirMedicationDispenseList.Clone: TFhirMedicationDispenseList;
begin
  result := TFhirMedicationDispenseList(inherited Clone);
end;

function TFhirMedicationDispenseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationDispenseList.GetItemN(index: Integer): TFhirMedicationDispense;
begin
  result := TFhirMedicationDispense(ObjectByIndex[index]);
end;

function TFhirMedicationDispenseList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationDispense;
end;
function TFhirMedicationDispenseList.IndexOf(value: TFhirMedicationDispense): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationDispenseList.Insert(index: Integer): TFhirMedicationDispense;
begin
  result := TFhirMedicationDispense.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationDispenseList.InsertItem(index: Integer; value: TFhirMedicationDispense);
begin
  assert(value is TFhirMedicationDispense);
  Inherited Insert(index, value);
end;

function TFhirMedicationDispenseList.Item(index: Integer): TFhirMedicationDispense;
begin
  result := TFhirMedicationDispense(ObjectByIndex[index]);
end;

function TFhirMedicationDispenseList.Link: TFhirMedicationDispenseList;
begin
  result := TFhirMedicationDispenseList(inherited Link);
end;

procedure TFhirMedicationDispenseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationDispenseList.SetItemByIndex(index: Integer; value: TFhirMedicationDispense);
begin
  assert(value is TFhirMedicationDispense);
  FhirMedicationDispenses[index] := value;
end;

procedure TFhirMedicationDispenseList.SetItemN(index: Integer; value: TFhirMedicationDispense);
begin
  assert(value is TFhirMedicationDispense);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEDICATIONDISPENSE}

{$IFDEF FHIR_MEDICATIONORDER}

{ TFhirMedicationOrderDosageInstruction }

constructor TFhirMedicationOrderDosageInstruction.Create;
begin
  inherited;
end;

destructor TFhirMedicationOrderDosageInstruction.Destroy;
begin
  FText.free;
  FAdditionalInstructions.free;
  FTiming.free;
  FAsNeeded.free;
  FSite.free;
  FRoute.free;
  FMethod.free;
  FDose.free;
  FRate.free;
  FMaxDosePerPeriod.free;
  inherited;
end;

procedure TFhirMedicationOrderDosageInstruction.Assign(oSource : TFslObject);
begin
  inherited;
  textElement := TFhirMedicationOrderDosageInstruction(oSource).textElement.Clone;
  additionalInstructions := TFhirMedicationOrderDosageInstruction(oSource).additionalInstructions.Clone;
  timing := TFhirMedicationOrderDosageInstruction(oSource).timing.Clone;
  asNeeded := TFhirMedicationOrderDosageInstruction(oSource).asNeeded.Clone;
  site := TFhirMedicationOrderDosageInstruction(oSource).site.Clone;
  route := TFhirMedicationOrderDosageInstruction(oSource).route.Clone;
  method := TFhirMedicationOrderDosageInstruction(oSource).method.Clone;
  dose := TFhirMedicationOrderDosageInstruction(oSource).dose.Clone;
  rate := TFhirMedicationOrderDosageInstruction(oSource).rate.Clone;
  maxDosePerPeriod := TFhirMedicationOrderDosageInstruction(oSource).maxDosePerPeriod.Clone;
end;

procedure TFhirMedicationOrderDosageInstruction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'additionalInstructions') Then
     list.add(self.link, 'additionalInstructions', FAdditionalInstructions.Link);
  if (child_name = 'timing') Then
     list.add(self.link, 'timing', FTiming.Link);
  if (child_name = 'asNeeded[x]') or (child_name = 'asNeeded') Then
     list.add(self.link, 'asNeeded[x]', FAsNeeded.Link);
  if (child_name = 'site[x]') or (child_name = 'site') Then
     list.add(self.link, 'site[x]', FSite.Link);
  if (child_name = 'route') Then
     list.add(self.link, 'route', FRoute.Link);
  if (child_name = 'method') Then
     list.add(self.link, 'method', FMethod.Link);
  if (child_name = 'dose[x]') or (child_name = 'dose') Then
     list.add(self.link, 'dose[x]', FDose.Link);
  if (child_name = 'rate[x]') or (child_name = 'rate') Then
     list.add(self.link, 'rate[x]', FRate.Link);
  if (child_name = 'maxDosePerPeriod') Then
     list.add(self.link, 'maxDosePerPeriod', FMaxDosePerPeriod.Link);
end;

procedure TFhirMedicationOrderDosageInstruction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));{2}
  oList.add(TFHIRProperty.create(self, 'additionalInstructions', 'CodeableConcept', false, TFhirCodeableConcept, FAdditionalInstructions.Link));{2}
  oList.add(TFHIRProperty.create(self, 'timing', 'Timing', false, TFhirTiming, FTiming.Link));{2}
  oList.add(TFHIRProperty.create(self, 'asNeeded[x]', 'boolean|CodeableConcept', false, TFhirType, FAsNeeded.Link));{2}
  oList.add(TFHIRProperty.create(self, 'site[x]', 'CodeableConcept|Reference(BodySite)', false, TFhirType, FSite.Link));{2}
  oList.add(TFHIRProperty.create(self, 'route', 'CodeableConcept', false, TFhirCodeableConcept, FRoute.Link));{2}
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', false, TFhirCodeableConcept, FMethod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dose[x]', 'Range|Quantity', false, TFhirType, FDose.Link));{2}
  oList.add(TFHIRProperty.create(self, 'rate[x]', 'Ratio|Range', false, TFhirType, FRate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'maxDosePerPeriod', 'Ratio', false, TFhirRatio, FMaxDosePerPeriod.Link));{2}
end;

function TFhirMedicationOrderDosageInstruction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'text') then
  begin
    TextElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'additionalInstructions') then
  begin
    AdditionalInstructions := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'timing') then
  begin
    Timing := propValue as TFhirTiming{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'asNeeded', ['Boolean', 'CodeableConcept'])) then
  begin
    AsNeeded := propValue as TFhirType{4};
    result := propValue;
  end
  else if (isMatchingName(propName, 'site', ['CodeableConcept', 'Reference'])) then
  begin
    Site := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'route') then
  begin
    Route := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'method') then
  begin
    Method := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'dose', ['Range', 'Quantity'])) then
  begin
    Dose := propValue as TFhirType{4};
    result := propValue;
  end
  else if (isMatchingName(propName, 'rate', ['Ratio', 'Range'])) then
  begin
    Rate := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'maxDosePerPeriod') then
  begin
    MaxDosePerPeriod := propValue as TFhirRatio{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationOrderDosageInstruction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationOrderDosageInstruction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'text') then result := TFhirString.create() {5b}
  else if (propName = 'additionalInstructions') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'timing') then result := TFhirTiming.create(){4b}
  else if (isMatchingName(propName, 'asNeeded', ['Boolean', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property AsNeeded'){4x}
  else if (isMatchingName(propName, 'site', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Site'){4x}
  else if (propName = 'route') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'method') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'dose', ['Range', 'Quantity'])) then raise EFHIRException.create('Cannot make property Dose'){4x}
  else if (isMatchingName(propName, 'rate', ['Ratio', 'Range'])) then raise EFHIRException.create('Cannot make property Rate'){4x}
  else if (propName = 'maxDosePerPeriod') then result := TFhirRatio.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationOrderDosageInstruction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'text') then result := 'string'
  else if (propName = 'additionalInstructions') then result := 'CodeableConcept'
  else if (propName = 'timing') then result := 'Timing'
  else if (propName = 'asNeeded[x]') then result := 'boolean|CodeableConcept'
  else if (propName = 'site[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'route') then result := 'CodeableConcept'
  else if (propName = 'method') then result := 'CodeableConcept'
  else if (propName = 'dose[x]') then result := 'Range|Quantity'
  else if (propName = 'rate[x]') then result := 'Ratio|Range'
  else if (propName = 'maxDosePerPeriod') then result := 'Ratio'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationOrderDosageInstruction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'text') then TextElement := nil
  else if (propName = 'additionalInstructions') then AdditionalInstructionsElement := nil
  else if (propName = 'timing') then TimingElement := nil
  else if (isMatchingName(propName, 'asNeeded', ['Boolean', 'CodeableConcept'])) then AsNeededElement := nil{4x}
  else if (isMatchingName(propName, 'site', ['CodeableConcept', 'Reference'])) then SiteElement := nil{4x}
  else if (propName = 'route') then RouteElement := nil
  else if (propName = 'method') then MethodElement := nil
  else if (isMatchingName(propName, 'dose', ['Range', 'Quantity'])) then DoseElement := nil{4x}
  else if (isMatchingName(propName, 'rate', ['Ratio', 'Range'])) then RateElement := nil{4x}
  else if (propName = 'maxDosePerPeriod') then MaxDosePerPeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationOrderDosageInstruction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'text') then TextElement := asString(new){5b}
  else if (propName = 'additionalInstructions') then AdditionalInstructionsElement := new as TFhirCodeableConcept{4}
  else if (propName = 'timing') then TimingElement := new as TFhirTiming{4}
  else if (isMatchingName(propName, 'asNeeded', ['Boolean', 'CodeableConcept'])) then AsNeededElement := new as TFhirType{4x}
  else if (isMatchingName(propName, 'site', ['CodeableConcept', 'Reference'])) then SiteElement := new as TFhirType{4x}
  else if (propName = 'route') then RouteElement := new as TFhirCodeableConcept{4}
  else if (propName = 'method') then MethodElement := new as TFhirCodeableConcept{4}
  else if (isMatchingName(propName, 'dose', ['Range', 'Quantity'])) then DoseElement := new as TFhirType{4x}
  else if (isMatchingName(propName, 'rate', ['Ratio', 'Range'])) then RateElement := new as TFhirType{4x}
  else if (propName = 'maxDosePerPeriod') then MaxDosePerPeriodElement := new as TFhirRatio{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationOrderDosageInstruction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationOrderDosageInstruction.fhirType : string;
begin
  result := 'dosageInstruction';
end;

function TFhirMedicationOrderDosageInstruction.Link : TFhirMedicationOrderDosageInstruction;
begin
  result := TFhirMedicationOrderDosageInstruction(inherited Link);
end;

function TFhirMedicationOrderDosageInstruction.Clone : TFhirMedicationOrderDosageInstruction;
begin
  result := TFhirMedicationOrderDosageInstruction(inherited Clone);
end;

function TFhirMedicationOrderDosageInstruction.equals(other : TObject) : boolean;
var
  o : TFhirMedicationOrderDosageInstruction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationOrderDosageInstruction)) then
    result := false
  else
  begin
    o := TFhirMedicationOrderDosageInstruction(other);
    result := compareDeep(textElement, o.textElement, true) and compareDeep(additionalInstructionsElement, o.additionalInstructionsElement, true) and
      compareDeep(timingElement, o.timingElement, true) and compareDeep(asNeededElement, o.asNeededElement, true) and
      compareDeep(siteElement, o.siteElement, true) and compareDeep(routeElement, o.routeElement, true) and
      compareDeep(methodElement, o.methodElement, true) and compareDeep(doseElement, o.doseElement, true) and
      compareDeep(rateElement, o.rateElement, true) and compareDeep(maxDosePerPeriodElement, o.maxDosePerPeriodElement, true);
  end;
end;

function TFhirMedicationOrderDosageInstruction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FText) and isEmptyProp(FAdditionalInstructions) and isEmptyProp(FTiming) and isEmptyProp(FAsNeeded) and isEmptyProp(FSite) and isEmptyProp(FRoute) and isEmptyProp(FMethod) and isEmptyProp(FDose) and isEmptyProp(FRate) and isEmptyProp(FMaxDosePerPeriod);
end;

procedure TFhirMedicationOrderDosageInstruction.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('text');
  fields.add('additionalInstructions');
  fields.add('timing');
  fields.add('asNeeded[x]');
  fields.add('site[x]');
  fields.add('route');
  fields.add('method');
  fields.add('dose[x]');
  fields.add('rate[x]');
  fields.add('maxDosePerPeriod');
end;

{ TFhirMedicationOrderDosageInstruction }

Procedure TFhirMedicationOrderDosageInstruction.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

Function TFhirMedicationOrderDosageInstruction.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

Procedure TFhirMedicationOrderDosageInstruction.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

Procedure TFhirMedicationOrderDosageInstruction.SetAdditionalInstructions(value : TFhirCodeableConcept);
begin
  FAdditionalInstructions.free;
  FAdditionalInstructions := value;
end;

Procedure TFhirMedicationOrderDosageInstruction.SetTiming(value : TFhirTiming);
begin
  FTiming.free;
  FTiming := value;
end;

Procedure TFhirMedicationOrderDosageInstruction.SetAsNeeded(value : TFhirType);
begin
  FAsNeeded.free;
  FAsNeeded := value;
end;

Procedure TFhirMedicationOrderDosageInstruction.SetSite(value : TFhirType);
begin
  FSite.free;
  FSite := value;
end;

Procedure TFhirMedicationOrderDosageInstruction.SetRoute(value : TFhirCodeableConcept);
begin
  FRoute.free;
  FRoute := value;
end;

Procedure TFhirMedicationOrderDosageInstruction.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value;
end;

Procedure TFhirMedicationOrderDosageInstruction.SetDose(value : TFhirType);
begin
  FDose.free;
  FDose := value;
end;

Procedure TFhirMedicationOrderDosageInstruction.SetRate(value : TFhirType);
begin
  FRate.free;
  FRate := value;
end;

Procedure TFhirMedicationOrderDosageInstruction.SetMaxDosePerPeriod(value : TFhirRatio);
begin
  FMaxDosePerPeriod.free;
  FMaxDosePerPeriod := value;
end;

function TFhirMedicationOrderDosageInstruction.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FText.sizeInBytes);
  inc(result, FAdditionalInstructions.sizeInBytes);
  inc(result, FTiming.sizeInBytes);
  inc(result, FAsNeeded.sizeInBytes);
  inc(result, FSite.sizeInBytes);
  inc(result, FRoute.sizeInBytes);
  inc(result, FMethod.sizeInBytes);
  inc(result, FDose.sizeInBytes);
  inc(result, FRate.sizeInBytes);
  inc(result, FMaxDosePerPeriod.sizeInBytes);
end;

{ TFhirMedicationOrderDosageInstructionListEnumerator }

Constructor TFhirMedicationOrderDosageInstructionListEnumerator.Create(list : TFhirMedicationOrderDosageInstructionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationOrderDosageInstructionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationOrderDosageInstructionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationOrderDosageInstructionListEnumerator.GetCurrent : TFhirMedicationOrderDosageInstruction;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationOrderDosageInstructionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationOrderDosageInstructionList }
procedure TFhirMedicationOrderDosageInstructionList.AddItem(value: TFhirMedicationOrderDosageInstruction);
begin
  assert(value.ClassName = 'TFhirMedicationOrderDosageInstruction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationOrderDosageInstruction');
  add(value);
end;

function TFhirMedicationOrderDosageInstructionList.Append: TFhirMedicationOrderDosageInstruction;
begin
  result := TFhirMedicationOrderDosageInstruction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationOrderDosageInstructionList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationOrderDosageInstructionList.GetEnumerator : TFhirMedicationOrderDosageInstructionListEnumerator;
begin
  result := TFhirMedicationOrderDosageInstructionListEnumerator.Create(self.link);
end;

function TFhirMedicationOrderDosageInstructionList.Clone: TFhirMedicationOrderDosageInstructionList;
begin
  result := TFhirMedicationOrderDosageInstructionList(inherited Clone);
end;

function TFhirMedicationOrderDosageInstructionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationOrderDosageInstructionList.GetItemN(index: Integer): TFhirMedicationOrderDosageInstruction;
begin
  result := TFhirMedicationOrderDosageInstruction(ObjectByIndex[index]);
end;

function TFhirMedicationOrderDosageInstructionList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationOrderDosageInstruction;
end;
function TFhirMedicationOrderDosageInstructionList.IndexOf(value: TFhirMedicationOrderDosageInstruction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationOrderDosageInstructionList.Insert(index: Integer): TFhirMedicationOrderDosageInstruction;
begin
  result := TFhirMedicationOrderDosageInstruction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationOrderDosageInstructionList.InsertItem(index: Integer; value: TFhirMedicationOrderDosageInstruction);
begin
  assert(value is TFhirMedicationOrderDosageInstruction);
  Inherited Insert(index, value);
end;

function TFhirMedicationOrderDosageInstructionList.Item(index: Integer): TFhirMedicationOrderDosageInstruction;
begin
  result := TFhirMedicationOrderDosageInstruction(ObjectByIndex[index]);
end;

function TFhirMedicationOrderDosageInstructionList.Link: TFhirMedicationOrderDosageInstructionList;
begin
  result := TFhirMedicationOrderDosageInstructionList(inherited Link);
end;

procedure TFhirMedicationOrderDosageInstructionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationOrderDosageInstructionList.SetItemByIndex(index: Integer; value: TFhirMedicationOrderDosageInstruction);
begin
  assert(value is TFhirMedicationOrderDosageInstruction);
  FhirMedicationOrderDosageInstructions[index] := value;
end;

procedure TFhirMedicationOrderDosageInstructionList.SetItemN(index: Integer; value: TFhirMedicationOrderDosageInstruction);
begin
  assert(value is TFhirMedicationOrderDosageInstruction);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationOrderDispenseRequest }

constructor TFhirMedicationOrderDispenseRequest.Create;
begin
  inherited;
end;

destructor TFhirMedicationOrderDispenseRequest.Destroy;
begin
  FMedication.free;
  FValidityPeriod.free;
  FNumberOfRepeatsAllowed.free;
  FQuantity.free;
  FExpectedSupplyDuration.free;
  inherited;
end;

procedure TFhirMedicationOrderDispenseRequest.Assign(oSource : TFslObject);
begin
  inherited;
  medication := TFhirMedicationOrderDispenseRequest(oSource).medication.Clone;
  validityPeriod := TFhirMedicationOrderDispenseRequest(oSource).validityPeriod.Clone;
  numberOfRepeatsAllowedElement := TFhirMedicationOrderDispenseRequest(oSource).numberOfRepeatsAllowedElement.Clone;
  quantity := TFhirMedicationOrderDispenseRequest(oSource).quantity.Clone;
  expectedSupplyDuration := TFhirMedicationOrderDispenseRequest(oSource).expectedSupplyDuration.Clone;
end;

procedure TFhirMedicationOrderDispenseRequest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'medication[x]') or (child_name = 'medication') Then
     list.add(self.link, 'medication[x]', FMedication.Link);
  if (child_name = 'validityPeriod') Then
     list.add(self.link, 'validityPeriod', FValidityPeriod.Link);
  if (child_name = 'numberOfRepeatsAllowed') Then
     list.add(self.link, 'numberOfRepeatsAllowed', FNumberOfRepeatsAllowed.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'expectedSupplyDuration') Then
     list.add(self.link, 'expectedSupplyDuration', FExpectedSupplyDuration.Link);
end;

procedure TFhirMedicationOrderDispenseRequest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'medication[x]', 'CodeableConcept|Reference(Medication)', false, TFhirType, FMedication.Link));{2}
  oList.add(TFHIRProperty.create(self, 'validityPeriod', 'Period', false, TFhirPeriod, FValidityPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'numberOfRepeatsAllowed', 'positiveInt', false, TFhirPositiveInt, FNumberOfRepeatsAllowed.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'expectedSupplyDuration', 'Quantity', false, TFhirQuantity, FExpectedSupplyDuration.Link));{2}
end;

function TFhirMedicationOrderDispenseRequest.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then
  begin
    Medication := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'validityPeriod') then
  begin
    ValidityPeriod := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'numberOfRepeatsAllowed') then
  begin
    NumberOfRepeatsAllowedElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'expectedSupplyDuration') then
  begin
    ExpectedSupplyDuration := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationOrderDispenseRequest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationOrderDispenseRequest.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Medication'){4x}
  else if (propName = 'validityPeriod') then result := TFhirPeriod.create(){4b}
  else if (propName = 'numberOfRepeatsAllowed') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'expectedSupplyDuration') then result := TFhirQuantity.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationOrderDispenseRequest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'medication[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'validityPeriod') then result := 'Period'
  else if (propName = 'numberOfRepeatsAllowed') then result := 'positiveInt'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'expectedSupplyDuration') then result := 'Quantity'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationOrderDispenseRequest.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then MedicationElement := nil{4x}
  else if (propName = 'validityPeriod') then ValidityPeriodElement := nil
  else if (propName = 'numberOfRepeatsAllowed') then NumberOfRepeatsAllowedElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'expectedSupplyDuration') then ExpectedSupplyDurationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationOrderDispenseRequest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then MedicationElement := new as TFhirType{4x}
  else if (propName = 'validityPeriod') then ValidityPeriodElement := new as TFhirPeriod{4}
  else if (propName = 'numberOfRepeatsAllowed') then NumberOfRepeatsAllowedElement := asPositiveInt(new){5b}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'expectedSupplyDuration') then ExpectedSupplyDurationElement := new as TFhirQuantity{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationOrderDispenseRequest.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationOrderDispenseRequest.fhirType : string;
begin
  result := 'dispenseRequest';
end;

function TFhirMedicationOrderDispenseRequest.Link : TFhirMedicationOrderDispenseRequest;
begin
  result := TFhirMedicationOrderDispenseRequest(inherited Link);
end;

function TFhirMedicationOrderDispenseRequest.Clone : TFhirMedicationOrderDispenseRequest;
begin
  result := TFhirMedicationOrderDispenseRequest(inherited Clone);
end;

function TFhirMedicationOrderDispenseRequest.equals(other : TObject) : boolean;
var
  o : TFhirMedicationOrderDispenseRequest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationOrderDispenseRequest)) then
    result := false
  else
  begin
    o := TFhirMedicationOrderDispenseRequest(other);
    result := compareDeep(medicationElement, o.medicationElement, true) and compareDeep(validityPeriodElement, o.validityPeriodElement, true) and
      compareDeep(numberOfRepeatsAllowedElement, o.numberOfRepeatsAllowedElement, true) and
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(expectedSupplyDurationElement, o.expectedSupplyDurationElement, true);
  end;
end;

function TFhirMedicationOrderDispenseRequest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMedication) and isEmptyProp(FValidityPeriod) and isEmptyProp(FNumberOfRepeatsAllowed) and isEmptyProp(FQuantity) and isEmptyProp(FExpectedSupplyDuration);
end;

procedure TFhirMedicationOrderDispenseRequest.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('medication[x]');
  fields.add('validityPeriod');
  fields.add('numberOfRepeatsAllowed');
  fields.add('quantity');
  fields.add('expectedSupplyDuration');
end;

{ TFhirMedicationOrderDispenseRequest }

Procedure TFhirMedicationOrderDispenseRequest.SetMedication(value : TFhirType);
begin
  FMedication.free;
  FMedication := value;
end;

Procedure TFhirMedicationOrderDispenseRequest.SetValidityPeriod(value : TFhirPeriod);
begin
  FValidityPeriod.free;
  FValidityPeriod := value;
end;

Procedure TFhirMedicationOrderDispenseRequest.SetNumberOfRepeatsAllowed(value : TFhirPositiveInt);
begin
  FNumberOfRepeatsAllowed.free;
  FNumberOfRepeatsAllowed := value;
end;

Function TFhirMedicationOrderDispenseRequest.GetNumberOfRepeatsAllowedST : String;
begin
  if FNumberOfRepeatsAllowed = nil then
    result := ''
  else
    result := FNumberOfRepeatsAllowed.value;
end;

Procedure TFhirMedicationOrderDispenseRequest.SetNumberOfRepeatsAllowedST(value : String);
begin
  if value <> '' then
  begin
    if FNumberOfRepeatsAllowed = nil then
      FNumberOfRepeatsAllowed := TFhirPositiveInt.create;
    FNumberOfRepeatsAllowed.value := value
  end
  else if FNumberOfRepeatsAllowed <> nil then
    FNumberOfRepeatsAllowed.value := '';
end;

Procedure TFhirMedicationOrderDispenseRequest.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirMedicationOrderDispenseRequest.SetExpectedSupplyDuration(value : TFhirQuantity);
begin
  FExpectedSupplyDuration.free;
  FExpectedSupplyDuration := value;
end;

function TFhirMedicationOrderDispenseRequest.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FMedication.sizeInBytes);
  inc(result, FValidityPeriod.sizeInBytes);
  inc(result, FNumberOfRepeatsAllowed.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FExpectedSupplyDuration.sizeInBytes);
end;

{ TFhirMedicationOrderDispenseRequestListEnumerator }

Constructor TFhirMedicationOrderDispenseRequestListEnumerator.Create(list : TFhirMedicationOrderDispenseRequestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationOrderDispenseRequestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationOrderDispenseRequestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationOrderDispenseRequestListEnumerator.GetCurrent : TFhirMedicationOrderDispenseRequest;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationOrderDispenseRequestListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationOrderDispenseRequestList }
procedure TFhirMedicationOrderDispenseRequestList.AddItem(value: TFhirMedicationOrderDispenseRequest);
begin
  assert(value.ClassName = 'TFhirMedicationOrderDispenseRequest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationOrderDispenseRequest');
  add(value);
end;

function TFhirMedicationOrderDispenseRequestList.Append: TFhirMedicationOrderDispenseRequest;
begin
  result := TFhirMedicationOrderDispenseRequest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationOrderDispenseRequestList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationOrderDispenseRequestList.GetEnumerator : TFhirMedicationOrderDispenseRequestListEnumerator;
begin
  result := TFhirMedicationOrderDispenseRequestListEnumerator.Create(self.link);
end;

function TFhirMedicationOrderDispenseRequestList.Clone: TFhirMedicationOrderDispenseRequestList;
begin
  result := TFhirMedicationOrderDispenseRequestList(inherited Clone);
end;

function TFhirMedicationOrderDispenseRequestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationOrderDispenseRequestList.GetItemN(index: Integer): TFhirMedicationOrderDispenseRequest;
begin
  result := TFhirMedicationOrderDispenseRequest(ObjectByIndex[index]);
end;

function TFhirMedicationOrderDispenseRequestList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationOrderDispenseRequest;
end;
function TFhirMedicationOrderDispenseRequestList.IndexOf(value: TFhirMedicationOrderDispenseRequest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationOrderDispenseRequestList.Insert(index: Integer): TFhirMedicationOrderDispenseRequest;
begin
  result := TFhirMedicationOrderDispenseRequest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationOrderDispenseRequestList.InsertItem(index: Integer; value: TFhirMedicationOrderDispenseRequest);
begin
  assert(value is TFhirMedicationOrderDispenseRequest);
  Inherited Insert(index, value);
end;

function TFhirMedicationOrderDispenseRequestList.Item(index: Integer): TFhirMedicationOrderDispenseRequest;
begin
  result := TFhirMedicationOrderDispenseRequest(ObjectByIndex[index]);
end;

function TFhirMedicationOrderDispenseRequestList.Link: TFhirMedicationOrderDispenseRequestList;
begin
  result := TFhirMedicationOrderDispenseRequestList(inherited Link);
end;

procedure TFhirMedicationOrderDispenseRequestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationOrderDispenseRequestList.SetItemByIndex(index: Integer; value: TFhirMedicationOrderDispenseRequest);
begin
  assert(value is TFhirMedicationOrderDispenseRequest);
  FhirMedicationOrderDispenseRequests[index] := value;
end;

procedure TFhirMedicationOrderDispenseRequestList.SetItemN(index: Integer; value: TFhirMedicationOrderDispenseRequest);
begin
  assert(value is TFhirMedicationOrderDispenseRequest);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationOrderSubstitution }

constructor TFhirMedicationOrderSubstitution.Create;
begin
  inherited;
end;

destructor TFhirMedicationOrderSubstitution.Destroy;
begin
  FType_.free;
  FReason.free;
  inherited;
end;

procedure TFhirMedicationOrderSubstitution.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicationOrderSubstitution(oSource).type_.Clone;
  reason := TFhirMedicationOrderSubstitution(oSource).reason.Clone;
end;

procedure TFhirMedicationOrderSubstitution.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'reason') Then
     list.add(self.link, 'reason', FReason.Link);
end;

procedure TFhirMedicationOrderSubstitution.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', false, TFhirCodeableConcept, FReason.Link));{2}
end;

function TFhirMedicationOrderSubstitution.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    Reason := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationOrderSubstitution.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationOrderSubstitution.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'reason') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationOrderSubstitution.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationOrderSubstitution.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'reason') then ReasonElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationOrderSubstitution.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'reason') then ReasonElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationOrderSubstitution.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationOrderSubstitution.fhirType : string;
begin
  result := 'substitution';
end;

function TFhirMedicationOrderSubstitution.Link : TFhirMedicationOrderSubstitution;
begin
  result := TFhirMedicationOrderSubstitution(inherited Link);
end;

function TFhirMedicationOrderSubstitution.Clone : TFhirMedicationOrderSubstitution;
begin
  result := TFhirMedicationOrderSubstitution(inherited Clone);
end;

function TFhirMedicationOrderSubstitution.equals(other : TObject) : boolean;
var
  o : TFhirMedicationOrderSubstitution;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationOrderSubstitution)) then
    result := false
  else
  begin
    o := TFhirMedicationOrderSubstitution(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(reasonElement, o.reasonElement, true);
  end;
end;

function TFhirMedicationOrderSubstitution.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FReason);
end;

procedure TFhirMedicationOrderSubstitution.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('reason');
end;

{ TFhirMedicationOrderSubstitution }

Procedure TFhirMedicationOrderSubstitution.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirMedicationOrderSubstitution.SetReason(value : TFhirCodeableConcept);
begin
  FReason.free;
  FReason := value;
end;

function TFhirMedicationOrderSubstitution.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FReason.sizeInBytes);
end;

{ TFhirMedicationOrderSubstitutionListEnumerator }

Constructor TFhirMedicationOrderSubstitutionListEnumerator.Create(list : TFhirMedicationOrderSubstitutionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationOrderSubstitutionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationOrderSubstitutionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationOrderSubstitutionListEnumerator.GetCurrent : TFhirMedicationOrderSubstitution;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationOrderSubstitutionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationOrderSubstitutionList }
procedure TFhirMedicationOrderSubstitutionList.AddItem(value: TFhirMedicationOrderSubstitution);
begin
  assert(value.ClassName = 'TFhirMedicationOrderSubstitution', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationOrderSubstitution');
  add(value);
end;

function TFhirMedicationOrderSubstitutionList.Append: TFhirMedicationOrderSubstitution;
begin
  result := TFhirMedicationOrderSubstitution.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationOrderSubstitutionList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationOrderSubstitutionList.GetEnumerator : TFhirMedicationOrderSubstitutionListEnumerator;
begin
  result := TFhirMedicationOrderSubstitutionListEnumerator.Create(self.link);
end;

function TFhirMedicationOrderSubstitutionList.Clone: TFhirMedicationOrderSubstitutionList;
begin
  result := TFhirMedicationOrderSubstitutionList(inherited Clone);
end;

function TFhirMedicationOrderSubstitutionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationOrderSubstitutionList.GetItemN(index: Integer): TFhirMedicationOrderSubstitution;
begin
  result := TFhirMedicationOrderSubstitution(ObjectByIndex[index]);
end;

function TFhirMedicationOrderSubstitutionList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationOrderSubstitution;
end;
function TFhirMedicationOrderSubstitutionList.IndexOf(value: TFhirMedicationOrderSubstitution): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationOrderSubstitutionList.Insert(index: Integer): TFhirMedicationOrderSubstitution;
begin
  result := TFhirMedicationOrderSubstitution.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationOrderSubstitutionList.InsertItem(index: Integer; value: TFhirMedicationOrderSubstitution);
begin
  assert(value is TFhirMedicationOrderSubstitution);
  Inherited Insert(index, value);
end;

function TFhirMedicationOrderSubstitutionList.Item(index: Integer): TFhirMedicationOrderSubstitution;
begin
  result := TFhirMedicationOrderSubstitution(ObjectByIndex[index]);
end;

function TFhirMedicationOrderSubstitutionList.Link: TFhirMedicationOrderSubstitutionList;
begin
  result := TFhirMedicationOrderSubstitutionList(inherited Link);
end;

procedure TFhirMedicationOrderSubstitutionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationOrderSubstitutionList.SetItemByIndex(index: Integer; value: TFhirMedicationOrderSubstitution);
begin
  assert(value is TFhirMedicationOrderSubstitution);
  FhirMedicationOrderSubstitutions[index] := value;
end;

procedure TFhirMedicationOrderSubstitutionList.SetItemN(index: Integer; value: TFhirMedicationOrderSubstitution);
begin
  assert(value is TFhirMedicationOrderSubstitution);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationOrder }

constructor TFhirMedicationOrder.Create;
begin
  inherited;
end;

destructor TFhirMedicationOrder.Destroy;
begin
  FIdentifierList.Free;
  FDateWritten.free;
  FStatus.free;
  FDateEnded.free;
  FReasonEnded.free;
  FPatient.free;
  FPrescriber.free;
  FEncounter.free;
  FReason.free;
  FNote.free;
  FMedication.free;
  FDosageInstructionList.Free;
  FDispenseRequest.free;
  FSubstitution.free;
  FPriorPrescription.free;
  inherited;
end;

function TFhirMedicationOrder.GetResourceType : TFhirResourceType;
begin
  result := frtMedicationOrder;
end;

procedure TFhirMedicationOrder.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedicationOrder(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirMedicationOrder(oSource).FIdentifierList);
  end;
  dateWrittenElement := TFhirMedicationOrder(oSource).dateWrittenElement.Clone;
  FStatus := TFhirMedicationOrder(oSource).FStatus.Link;
  dateEndedElement := TFhirMedicationOrder(oSource).dateEndedElement.Clone;
  reasonEnded := TFhirMedicationOrder(oSource).reasonEnded.Clone;
  patient := TFhirMedicationOrder(oSource).patient.Clone;
  prescriber := TFhirMedicationOrder(oSource).prescriber.Clone;
  encounter := TFhirMedicationOrder(oSource).encounter.Clone;
  reason := TFhirMedicationOrder(oSource).reason.Clone;
  noteElement := TFhirMedicationOrder(oSource).noteElement.Clone;
  medication := TFhirMedicationOrder(oSource).medication.Clone;
  if (TFhirMedicationOrder(oSource).FDosageInstructionList = nil) then
  begin
    FDosageInstructionList.free;
    FDosageInstructionList := nil;
  end
  else
  begin
    if FDosageInstructionList = nil then
      FDosageInstructionList := TFhirMedicationOrderDosageInstructionList.Create;
    FDosageInstructionList.Assign(TFhirMedicationOrder(oSource).FDosageInstructionList);
  end;
  dispenseRequest := TFhirMedicationOrder(oSource).dispenseRequest.Clone;
  substitution := TFhirMedicationOrder(oSource).substitution.Clone;
  priorPrescription := TFhirMedicationOrder(oSource).priorPrescription.Clone;
end;

procedure TFhirMedicationOrder.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'dateWritten') Then
     list.add(self.link, 'dateWritten', FDateWritten.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'dateEnded') Then
     list.add(self.link, 'dateEnded', FDateEnded.Link);
  if (child_name = 'reasonEnded') Then
     list.add(self.link, 'reasonEnded', FReasonEnded.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'prescriber') Then
     list.add(self.link, 'prescriber', FPrescriber.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'reason[x]') or (child_name = 'reason') Then
     list.add(self.link, 'reason[x]', FReason.Link);
  if (child_name = 'note') Then
     list.add(self.link, 'note', FNote.Link);
  if (child_name = 'medication[x]') or (child_name = 'medication') Then
     list.add(self.link, 'medication[x]', FMedication.Link);
  if (child_name = 'dosageInstruction') Then
    list.addAll(self, 'dosageInstruction', FDosageInstructionList);
  if (child_name = 'dispenseRequest') Then
     list.add(self.link, 'dispenseRequest', FDispenseRequest.Link);
  if (child_name = 'substitution') Then
     list.add(self.link, 'substitution', FSubstitution.Link);
  if (child_name = 'priorPrescription') Then
     list.add(self.link, 'priorPrescription', FPriorPrescription.Link);
end;

procedure TFhirMedicationOrder.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'dateWritten', 'dateTime', false, TFhirDateTime, FDateWritten.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'dateEnded', 'dateTime', false, TFhirDateTime, FDateEnded.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reasonEnded', 'CodeableConcept', false, TFhirCodeableConcept, FReasonEnded.Link));{2}
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'prescriber', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FPrescriber.Link));{2}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference(Encounter)', false, TFhirReference{TFhirEncounter}, FEncounter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason[x]', 'CodeableConcept|Reference(Condition)', false, TFhirType, FReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'note', 'string', false, TFhirString, FNote.Link));{2}
  oList.add(TFHIRProperty.create(self, 'medication[x]', 'CodeableConcept|Reference(Medication)', false, TFhirType, FMedication.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dosageInstruction', '', true, TFhirMedicationOrderDosageInstruction, FDosageInstructionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'dispenseRequest', '', false, TFhirMedicationOrderDispenseRequest, FDispenseRequest.Link));{2}
  oList.add(TFHIRProperty.create(self, 'substitution', '', false, TFhirMedicationOrderSubstitution, FSubstitution.Link));{2}
  oList.add(TFHIRProperty.create(self, 'priorPrescription', 'Reference(MedicationOrder)', false, TFhirReference{TFhirMedicationOrder}, FPriorPrescription.Link));{2}
end;

function TFhirMedicationOrder.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'dateWritten') then
  begin
    DateWrittenElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirMedicationOrderStatusEnum, CODES_TFhirMedicationOrderStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'dateEnded') then
  begin
    DateEndedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'reasonEnded') then
  begin
    ReasonEnded := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'prescriber') then
  begin
    Prescriber := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference{TFhirEncounter}{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then
  begin
    Reason := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteElement := asString(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then
  begin
    Medication := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'dosageInstruction') then
  begin
    DosageInstructionList.add(propValue as TFhirMedicationOrderDosageInstruction){2a};
    result := propValue;
  end
  else if (propName = 'dispenseRequest') then
  begin
    DispenseRequest := propValue as TFhirMedicationOrderDispenseRequest{4b};
    result := propValue;
  end
  else if (propName = 'substitution') then
  begin
    Substitution := propValue as TFhirMedicationOrderSubstitution{4b};
    result := propValue;
  end
  else if (propName = 'priorPrescription') then
  begin
    PriorPrescription := propValue as TFhirReference{TFhirMedicationOrder}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirMedicationOrder.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'dosageInstruction') then DosageInstructionList.insertItem(index, propValue as TFhirMedicationOrderDosageInstruction){2a}
  else inherited;
end;

function TFhirMedicationOrder.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'dateWritten') then result := TFhirDateTime.create() {5b}
  else if (propName = 'dateEnded') then result := TFhirDateTime.create() {5b}
  else if (propName = 'reasonEnded') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'prescriber') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'encounter') then result := TFhirReference{TFhirEncounter}.create(){4b}
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Reason'){4x}
  else if (propName = 'note') then result := TFhirString.create() {5b}
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Medication'){4x}
  else if (propName = 'dosageInstruction') then result := DosageInstructionList.new(){2}
  else if (propName = 'dispenseRequest') then result := TFhirMedicationOrderDispenseRequest.create(){4b}
  else if (propName = 'substitution') then result := TFhirMedicationOrderSubstitution.create(){4b}
  else if (propName = 'priorPrescription') then result := TFhirReference{TFhirMedicationOrder}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationOrder.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'dateWritten') then result := 'dateTime'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'dateEnded') then result := 'dateTime'
  else if (propName = 'reasonEnded') then result := 'CodeableConcept'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'prescriber') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'reason[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'note') then result := 'string'
  else if (propName = 'medication[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'dosageInstruction') then result := ''
  else if (propName = 'dispenseRequest') then result := ''
  else if (propName = 'substitution') then result := ''
  else if (propName = 'priorPrescription') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationOrder.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'dateWritten') then DateWrittenElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'dateEnded') then DateEndedElement := nil
  else if (propName = 'reasonEnded') then ReasonEndedElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'prescriber') then PrescriberElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then ReasonElement := nil{4x}
  else if (propName = 'note') then NoteElement := nil
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then MedicationElement := nil{4x}
  else if (propName = 'dosageInstruction') then deletePropertyValue('dosageInstruction', DosageInstructionList, value) {2}
  else if (propName = 'dispenseRequest') then DispenseRequestElement := nil
  else if (propName = 'substitution') then SubstitutionElement := nil
  else if (propName = 'priorPrescription') then PriorPrescriptionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationOrder.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'dateWritten') then DateWrittenElement := asDateTime(new){5b}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirMedicationOrderStatusEnum, CODES_TFhirMedicationOrderStatusEnum, new){4}
  else if (propName = 'dateEnded') then DateEndedElement := asDateTime(new){5b}
  else if (propName = 'reasonEnded') then ReasonEndedElement := new as TFhirCodeableConcept{4}
  else if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'prescriber') then PrescriberElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference{TFhirEncounter}{4}
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then ReasonElement := new as TFhirType{4x}
  else if (propName = 'note') then NoteElement := asString(new){5b}
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then MedicationElement := new as TFhirType{4x}
  else if (propName = 'dosageInstruction') then replacePropertyValue('dosageInstruction', DosageInstructionList, existing, new) {2}
  else if (propName = 'dispenseRequest') then DispenseRequestElement := new as TFhirMedicationOrderDispenseRequest{4}
  else if (propName = 'substitution') then SubstitutionElement := new as TFhirMedicationOrderSubstitution{4}
  else if (propName = 'priorPrescription') then PriorPrescriptionElement := new as TFhirReference{TFhirMedicationOrder}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationOrder.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'dosageInstruction') then DosageInstructionList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationOrder.fhirType : string;
begin
  result := 'MedicationOrder';
end;

function TFhirMedicationOrder.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FDateWritten) and isEmptyProp(FStatus) and isEmptyProp(FDateEnded) and isEmptyProp(FReasonEnded) and isEmptyProp(FPatient) and isEmptyProp(FPrescriber) and isEmptyProp(FEncounter) and isEmptyProp(FReason) and isEmptyProp(FNote) and isEmptyProp(FMedication) and isEmptyProp(FdosageInstructionList) and isEmptyProp(FDispenseRequest) and isEmptyProp(FSubstitution) and isEmptyProp(FPriorPrescription);
end;

function TFhirMedicationOrder.equals(other : TObject) : boolean;
var
  o : TFhirMedicationOrder;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationOrder)) then
    result := false
  else
  begin
    o := TFhirMedicationOrder(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(dateWrittenElement, o.dateWrittenElement, true) and
      compareDeep(statusElement, o.statusElement, true) and compareDeep(dateEndedElement, o.dateEndedElement, true) and
      compareDeep(reasonEndedElement, o.reasonEndedElement, true) and compareDeep(patientElement, o.patientElement, true) and
      compareDeep(prescriberElement, o.prescriberElement, true) and compareDeep(encounterElement, o.encounterElement, true) and
      compareDeep(reasonElement, o.reasonElement, true) and compareDeep(noteElement, o.noteElement, true) and
      compareDeep(medicationElement, o.medicationElement, true) and compareDeep(dosageInstructionList, o.dosageInstructionList, true) and
      compareDeep(dispenseRequestElement, o.dispenseRequestElement, true) and compareDeep(substitutionElement, o.substitutionElement, true) and
      compareDeep(priorPrescriptionElement, o.priorPrescriptionElement, true);
  end;
end;

function TFhirMedicationOrder.Link : TFhirMedicationOrder;
begin
  result := TFhirMedicationOrder(inherited Link);
end;

function TFhirMedicationOrder.Clone : TFhirMedicationOrder;
begin
  result := TFhirMedicationOrder(inherited Clone);
end;

procedure TFhirMedicationOrder.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('dateWritten');
  fields.add('status');
  fields.add('dateEnded');
  fields.add('reasonEnded');
  fields.add('patient');
  fields.add('prescriber');
  fields.add('encounter');
  fields.add('reason[x]');
  fields.add('note');
  fields.add('medication[x]');
  fields.add('dosageInstruction');
  fields.add('dispenseRequest');
  fields.add('substitution');
  fields.add('priorPrescription');
end;

{ TFhirMedicationOrder }

Function TFhirMedicationOrder.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirMedicationOrder.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirMedicationOrder.SetDateWritten(value : TFhirDateTime);
begin
  FDateWritten.free;
  FDateWritten := value;
end;

Function TFhirMedicationOrder.GetDateWrittenST : TFslDateTime;
begin
  if FDateWritten = nil then
    result := TFslDateTime.makeNull
  else
    result := FDateWritten.value;
end;

Procedure TFhirMedicationOrder.SetDateWrittenST(value : TFslDateTime);
begin
  if FDateWritten = nil then
    FDateWritten := TFhirDateTime.create;
  FDateWritten.value := value
end;

Procedure TFhirMedicationOrder.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirMedicationOrder.GetStatusST : TFhirMedicationOrderStatusEnum;
begin
  if FStatus = nil then
    result := TFhirMedicationOrderStatusEnum(0)
  else
    result := TFhirMedicationOrderStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirMedicationOrderStatusEnum, FStatus.value));
end;

Procedure TFhirMedicationOrder.SetStatusST(value : TFhirMedicationOrderStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirMedicationOrderStatusEnum[value], CODES_TFhirMedicationOrderStatusEnum[value]);
end;

Procedure TFhirMedicationOrder.SetDateEnded(value : TFhirDateTime);
begin
  FDateEnded.free;
  FDateEnded := value;
end;

Function TFhirMedicationOrder.GetDateEndedST : TFslDateTime;
begin
  if FDateEnded = nil then
    result := TFslDateTime.makeNull
  else
    result := FDateEnded.value;
end;

Procedure TFhirMedicationOrder.SetDateEndedST(value : TFslDateTime);
begin
  if FDateEnded = nil then
    FDateEnded := TFhirDateTime.create;
  FDateEnded.value := value
end;

Procedure TFhirMedicationOrder.SetReasonEnded(value : TFhirCodeableConcept);
begin
  FReasonEnded.free;
  FReasonEnded := value;
end;

Procedure TFhirMedicationOrder.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Procedure TFhirMedicationOrder.SetPrescriber(value : TFhirReference{TFhirPractitioner});
begin
  FPrescriber.free;
  FPrescriber := value;
end;

Procedure TFhirMedicationOrder.SetEncounter(value : TFhirReference{TFhirEncounter});
begin
  FEncounter.free;
  FEncounter := value;
end;

Procedure TFhirMedicationOrder.SetReason(value : TFhirType);
begin
  FReason.free;
  FReason := value;
end;

Procedure TFhirMedicationOrder.SetNote(value : TFhirString);
begin
  FNote.free;
  FNote := value;
end;

Function TFhirMedicationOrder.GetNoteST : String;
begin
  if FNote = nil then
    result := ''
  else
    result := FNote.value;
end;

Procedure TFhirMedicationOrder.SetNoteST(value : String);
begin
  if value <> '' then
  begin
    if FNote = nil then
      FNote := TFhirString.create;
    FNote.value := value
  end
  else if FNote <> nil then
    FNote.value := '';
end;

Procedure TFhirMedicationOrder.SetMedication(value : TFhirType);
begin
  FMedication.free;
  FMedication := value;
end;

Function TFhirMedicationOrder.GetDosageInstructionList : TFhirMedicationOrderDosageInstructionList;
begin
  if FDosageInstructionList = nil then
    FDosageInstructionList := TFhirMedicationOrderDosageInstructionList.Create;
  result := FDosageInstructionList;
end;

Function TFhirMedicationOrder.GetHasDosageInstructionList : boolean;
begin
  result := (FDosageInstructionList <> nil) and (FDosageInstructionList.count > 0);
end;

Procedure TFhirMedicationOrder.SetDispenseRequest(value : TFhirMedicationOrderDispenseRequest);
begin
  FDispenseRequest.free;
  FDispenseRequest := value;
end;

Procedure TFhirMedicationOrder.SetSubstitution(value : TFhirMedicationOrderSubstitution);
begin
  FSubstitution.free;
  FSubstitution := value;
end;

Procedure TFhirMedicationOrder.SetPriorPrescription(value : TFhirReference{TFhirMedicationOrder});
begin
  FPriorPrescription.free;
  FPriorPrescription := value;
end;

function TFhirMedicationOrder.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FDateWritten.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FDateEnded.sizeInBytes);
  inc(result, FReasonEnded.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FPrescriber.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FReason.sizeInBytes);
  inc(result, FNote.sizeInBytes);
  inc(result, FMedication.sizeInBytes);
  inc(result, FdosageInstructionList.sizeInBytes);
  inc(result, FDispenseRequest.sizeInBytes);
  inc(result, FSubstitution.sizeInBytes);
  inc(result, FPriorPrescription.sizeInBytes);
end;

{ TFhirMedicationOrderListEnumerator }

Constructor TFhirMedicationOrderListEnumerator.Create(list : TFhirMedicationOrderList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationOrderListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationOrderListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationOrderListEnumerator.GetCurrent : TFhirMedicationOrder;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationOrderListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationOrderList }
procedure TFhirMedicationOrderList.AddItem(value: TFhirMedicationOrder);
begin
  assert(value.ClassName = 'TFhirMedicationOrder', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationOrder');
  add(value);
end;

function TFhirMedicationOrderList.Append: TFhirMedicationOrder;
begin
  result := TFhirMedicationOrder.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationOrderList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationOrderList.GetEnumerator : TFhirMedicationOrderListEnumerator;
begin
  result := TFhirMedicationOrderListEnumerator.Create(self.link);
end;

function TFhirMedicationOrderList.Clone: TFhirMedicationOrderList;
begin
  result := TFhirMedicationOrderList(inherited Clone);
end;

function TFhirMedicationOrderList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationOrderList.GetItemN(index: Integer): TFhirMedicationOrder;
begin
  result := TFhirMedicationOrder(ObjectByIndex[index]);
end;

function TFhirMedicationOrderList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationOrder;
end;
function TFhirMedicationOrderList.IndexOf(value: TFhirMedicationOrder): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationOrderList.Insert(index: Integer): TFhirMedicationOrder;
begin
  result := TFhirMedicationOrder.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationOrderList.InsertItem(index: Integer; value: TFhirMedicationOrder);
begin
  assert(value is TFhirMedicationOrder);
  Inherited Insert(index, value);
end;

function TFhirMedicationOrderList.Item(index: Integer): TFhirMedicationOrder;
begin
  result := TFhirMedicationOrder(ObjectByIndex[index]);
end;

function TFhirMedicationOrderList.Link: TFhirMedicationOrderList;
begin
  result := TFhirMedicationOrderList(inherited Link);
end;

procedure TFhirMedicationOrderList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationOrderList.SetItemByIndex(index: Integer; value: TFhirMedicationOrder);
begin
  assert(value is TFhirMedicationOrder);
  FhirMedicationOrders[index] := value;
end;

procedure TFhirMedicationOrderList.SetItemN(index: Integer; value: TFhirMedicationOrder);
begin
  assert(value is TFhirMedicationOrder);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEDICATIONORDER}

{$IFDEF FHIR_MEDICATIONSTATEMENT}

{ TFhirMedicationStatementDosage }

constructor TFhirMedicationStatementDosage.Create;
begin
  inherited;
end;

destructor TFhirMedicationStatementDosage.Destroy;
begin
  FText.free;
  FTiming.free;
  FAsNeeded.free;
  FSite.free;
  FRoute.free;
  FMethod.free;
  FQuantity.free;
  FRate.free;
  FMaxDosePerPeriod.free;
  inherited;
end;

procedure TFhirMedicationStatementDosage.Assign(oSource : TFslObject);
begin
  inherited;
  textElement := TFhirMedicationStatementDosage(oSource).textElement.Clone;
  timing := TFhirMedicationStatementDosage(oSource).timing.Clone;
  asNeeded := TFhirMedicationStatementDosage(oSource).asNeeded.Clone;
  site := TFhirMedicationStatementDosage(oSource).site.Clone;
  route := TFhirMedicationStatementDosage(oSource).route.Clone;
  method := TFhirMedicationStatementDosage(oSource).method.Clone;
  quantity := TFhirMedicationStatementDosage(oSource).quantity.Clone;
  rate := TFhirMedicationStatementDosage(oSource).rate.Clone;
  maxDosePerPeriod := TFhirMedicationStatementDosage(oSource).maxDosePerPeriod.Clone;
end;

procedure TFhirMedicationStatementDosage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'timing') Then
     list.add(self.link, 'timing', FTiming.Link);
  if (child_name = 'asNeeded[x]') or (child_name = 'asNeeded') Then
     list.add(self.link, 'asNeeded[x]', FAsNeeded.Link);
  if (child_name = 'site[x]') or (child_name = 'site') Then
     list.add(self.link, 'site[x]', FSite.Link);
  if (child_name = 'route') Then
     list.add(self.link, 'route', FRoute.Link);
  if (child_name = 'method') Then
     list.add(self.link, 'method', FMethod.Link);
  if (child_name = 'quantity[x]') or (child_name = 'quantity') Then
     list.add(self.link, 'quantity[x]', FQuantity.Link);
  if (child_name = 'rate[x]') or (child_name = 'rate') Then
     list.add(self.link, 'rate[x]', FRate.Link);
  if (child_name = 'maxDosePerPeriod') Then
     list.add(self.link, 'maxDosePerPeriod', FMaxDosePerPeriod.Link);
end;

procedure TFhirMedicationStatementDosage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));{2}
  oList.add(TFHIRProperty.create(self, 'timing', 'Timing', false, TFhirTiming, FTiming.Link));{2}
  oList.add(TFHIRProperty.create(self, 'asNeeded[x]', 'boolean|CodeableConcept', false, TFhirType, FAsNeeded.Link));{2}
  oList.add(TFHIRProperty.create(self, 'site[x]', 'CodeableConcept|Reference(BodySite)', false, TFhirType, FSite.Link));{2}
  oList.add(TFHIRProperty.create(self, 'route', 'CodeableConcept', false, TFhirCodeableConcept, FRoute.Link));{2}
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', false, TFhirCodeableConcept, FMethod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity[x]', 'Quantity|Range', false, TFhirType, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'rate[x]', 'Ratio|Range', false, TFhirType, FRate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'maxDosePerPeriod', 'Ratio', false, TFhirRatio, FMaxDosePerPeriod.Link));{2}
end;

function TFhirMedicationStatementDosage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'text') then
  begin
    TextElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'timing') then
  begin
    Timing := propValue as TFhirTiming{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'asNeeded', ['Boolean', 'CodeableConcept'])) then
  begin
    AsNeeded := propValue as TFhirType{4};
    result := propValue;
  end
  else if (isMatchingName(propName, 'site', ['CodeableConcept', 'Reference'])) then
  begin
    Site := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'route') then
  begin
    Route := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'method') then
  begin
    Method := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'quantity', ['Quantity', 'Range'])) then
  begin
    Quantity := propValue as TFhirType{4};
    result := propValue;
  end
  else if (isMatchingName(propName, 'rate', ['Ratio', 'Range'])) then
  begin
    Rate := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'maxDosePerPeriod') then
  begin
    MaxDosePerPeriod := propValue as TFhirRatio{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationStatementDosage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationStatementDosage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'text') then result := TFhirString.create() {5b}
  else if (propName = 'timing') then result := TFhirTiming.create(){4b}
  else if (isMatchingName(propName, 'asNeeded', ['Boolean', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property AsNeeded'){4x}
  else if (isMatchingName(propName, 'site', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Site'){4x}
  else if (propName = 'route') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'method') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'quantity', ['Quantity', 'Range'])) then raise EFHIRException.create('Cannot make property Quantity'){4x}
  else if (isMatchingName(propName, 'rate', ['Ratio', 'Range'])) then raise EFHIRException.create('Cannot make property Rate'){4x}
  else if (propName = 'maxDosePerPeriod') then result := TFhirRatio.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationStatementDosage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'text') then result := 'string'
  else if (propName = 'timing') then result := 'Timing'
  else if (propName = 'asNeeded[x]') then result := 'boolean|CodeableConcept'
  else if (propName = 'site[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'route') then result := 'CodeableConcept'
  else if (propName = 'method') then result := 'CodeableConcept'
  else if (propName = 'quantity[x]') then result := 'Quantity|Range'
  else if (propName = 'rate[x]') then result := 'Ratio|Range'
  else if (propName = 'maxDosePerPeriod') then result := 'Ratio'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationStatementDosage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'text') then TextElement := nil
  else if (propName = 'timing') then TimingElement := nil
  else if (isMatchingName(propName, 'asNeeded', ['Boolean', 'CodeableConcept'])) then AsNeededElement := nil{4x}
  else if (isMatchingName(propName, 'site', ['CodeableConcept', 'Reference'])) then SiteElement := nil{4x}
  else if (propName = 'route') then RouteElement := nil
  else if (propName = 'method') then MethodElement := nil
  else if (isMatchingName(propName, 'quantity', ['Quantity', 'Range'])) then QuantityElement := nil{4x}
  else if (isMatchingName(propName, 'rate', ['Ratio', 'Range'])) then RateElement := nil{4x}
  else if (propName = 'maxDosePerPeriod') then MaxDosePerPeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationStatementDosage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'text') then TextElement := asString(new){5b}
  else if (propName = 'timing') then TimingElement := new as TFhirTiming{4}
  else if (isMatchingName(propName, 'asNeeded', ['Boolean', 'CodeableConcept'])) then AsNeededElement := new as TFhirType{4x}
  else if (isMatchingName(propName, 'site', ['CodeableConcept', 'Reference'])) then SiteElement := new as TFhirType{4x}
  else if (propName = 'route') then RouteElement := new as TFhirCodeableConcept{4}
  else if (propName = 'method') then MethodElement := new as TFhirCodeableConcept{4}
  else if (isMatchingName(propName, 'quantity', ['Quantity', 'Range'])) then QuantityElement := new as TFhirType{4x}
  else if (isMatchingName(propName, 'rate', ['Ratio', 'Range'])) then RateElement := new as TFhirType{4x}
  else if (propName = 'maxDosePerPeriod') then MaxDosePerPeriodElement := new as TFhirRatio{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationStatementDosage.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationStatementDosage.fhirType : string;
begin
  result := 'dosage';
end;

function TFhirMedicationStatementDosage.Link : TFhirMedicationStatementDosage;
begin
  result := TFhirMedicationStatementDosage(inherited Link);
end;

function TFhirMedicationStatementDosage.Clone : TFhirMedicationStatementDosage;
begin
  result := TFhirMedicationStatementDosage(inherited Clone);
end;

function TFhirMedicationStatementDosage.equals(other : TObject) : boolean;
var
  o : TFhirMedicationStatementDosage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationStatementDosage)) then
    result := false
  else
  begin
    o := TFhirMedicationStatementDosage(other);
    result := compareDeep(textElement, o.textElement, true) and compareDeep(timingElement, o.timingElement, true) and
      compareDeep(asNeededElement, o.asNeededElement, true) and compareDeep(siteElement, o.siteElement, true) and
      compareDeep(routeElement, o.routeElement, true) and compareDeep(methodElement, o.methodElement, true) and
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(rateElement, o.rateElement, true) and
      compareDeep(maxDosePerPeriodElement, o.maxDosePerPeriodElement, true);
  end;
end;

function TFhirMedicationStatementDosage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FText) and isEmptyProp(FTiming) and isEmptyProp(FAsNeeded) and isEmptyProp(FSite) and isEmptyProp(FRoute) and isEmptyProp(FMethod) and isEmptyProp(FQuantity) and isEmptyProp(FRate) and isEmptyProp(FMaxDosePerPeriod);
end;

procedure TFhirMedicationStatementDosage.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('text');
  fields.add('timing');
  fields.add('asNeeded[x]');
  fields.add('site[x]');
  fields.add('route');
  fields.add('method');
  fields.add('quantity[x]');
  fields.add('rate[x]');
  fields.add('maxDosePerPeriod');
end;

{ TFhirMedicationStatementDosage }

Procedure TFhirMedicationStatementDosage.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

Function TFhirMedicationStatementDosage.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

Procedure TFhirMedicationStatementDosage.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

Procedure TFhirMedicationStatementDosage.SetTiming(value : TFhirTiming);
begin
  FTiming.free;
  FTiming := value;
end;

Procedure TFhirMedicationStatementDosage.SetAsNeeded(value : TFhirType);
begin
  FAsNeeded.free;
  FAsNeeded := value;
end;

Procedure TFhirMedicationStatementDosage.SetSite(value : TFhirType);
begin
  FSite.free;
  FSite := value;
end;

Procedure TFhirMedicationStatementDosage.SetRoute(value : TFhirCodeableConcept);
begin
  FRoute.free;
  FRoute := value;
end;

Procedure TFhirMedicationStatementDosage.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value;
end;

Procedure TFhirMedicationStatementDosage.SetQuantity(value : TFhirType);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirMedicationStatementDosage.SetRate(value : TFhirType);
begin
  FRate.free;
  FRate := value;
end;

Procedure TFhirMedicationStatementDosage.SetMaxDosePerPeriod(value : TFhirRatio);
begin
  FMaxDosePerPeriod.free;
  FMaxDosePerPeriod := value;
end;

function TFhirMedicationStatementDosage.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FText.sizeInBytes);
  inc(result, FTiming.sizeInBytes);
  inc(result, FAsNeeded.sizeInBytes);
  inc(result, FSite.sizeInBytes);
  inc(result, FRoute.sizeInBytes);
  inc(result, FMethod.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FRate.sizeInBytes);
  inc(result, FMaxDosePerPeriod.sizeInBytes);
end;

{ TFhirMedicationStatementDosageListEnumerator }

Constructor TFhirMedicationStatementDosageListEnumerator.Create(list : TFhirMedicationStatementDosageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationStatementDosageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationStatementDosageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationStatementDosageListEnumerator.GetCurrent : TFhirMedicationStatementDosage;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationStatementDosageListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationStatementDosageList }
procedure TFhirMedicationStatementDosageList.AddItem(value: TFhirMedicationStatementDosage);
begin
  assert(value.ClassName = 'TFhirMedicationStatementDosage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationStatementDosage');
  add(value);
end;

function TFhirMedicationStatementDosageList.Append: TFhirMedicationStatementDosage;
begin
  result := TFhirMedicationStatementDosage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationStatementDosageList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationStatementDosageList.GetEnumerator : TFhirMedicationStatementDosageListEnumerator;
begin
  result := TFhirMedicationStatementDosageListEnumerator.Create(self.link);
end;

function TFhirMedicationStatementDosageList.Clone: TFhirMedicationStatementDosageList;
begin
  result := TFhirMedicationStatementDosageList(inherited Clone);
end;

function TFhirMedicationStatementDosageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationStatementDosageList.GetItemN(index: Integer): TFhirMedicationStatementDosage;
begin
  result := TFhirMedicationStatementDosage(ObjectByIndex[index]);
end;

function TFhirMedicationStatementDosageList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationStatementDosage;
end;
function TFhirMedicationStatementDosageList.IndexOf(value: TFhirMedicationStatementDosage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationStatementDosageList.Insert(index: Integer): TFhirMedicationStatementDosage;
begin
  result := TFhirMedicationStatementDosage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationStatementDosageList.InsertItem(index: Integer; value: TFhirMedicationStatementDosage);
begin
  assert(value is TFhirMedicationStatementDosage);
  Inherited Insert(index, value);
end;

function TFhirMedicationStatementDosageList.Item(index: Integer): TFhirMedicationStatementDosage;
begin
  result := TFhirMedicationStatementDosage(ObjectByIndex[index]);
end;

function TFhirMedicationStatementDosageList.Link: TFhirMedicationStatementDosageList;
begin
  result := TFhirMedicationStatementDosageList(inherited Link);
end;

procedure TFhirMedicationStatementDosageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationStatementDosageList.SetItemByIndex(index: Integer; value: TFhirMedicationStatementDosage);
begin
  assert(value is TFhirMedicationStatementDosage);
  FhirMedicationStatementDosages[index] := value;
end;

procedure TFhirMedicationStatementDosageList.SetItemN(index: Integer; value: TFhirMedicationStatementDosage);
begin
  assert(value is TFhirMedicationStatementDosage);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationStatement }

constructor TFhirMedicationStatement.Create;
begin
  inherited;
end;

destructor TFhirMedicationStatement.Destroy;
begin
  FIdentifierList.Free;
  FPatient.free;
  FInformationSource.free;
  FDateAsserted.free;
  FStatus.free;
  FWasNotTaken.free;
  FReasonNotTakenList.Free;
  FReasonForUse.free;
  FEffective.free;
  FNote.free;
  FSupportingInformationList.Free;
  FMedication.free;
  FDosageList.Free;
  inherited;
end;

function TFhirMedicationStatement.GetResourceType : TFhirResourceType;
begin
  result := frtMedicationStatement;
end;

procedure TFhirMedicationStatement.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedicationStatement(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirMedicationStatement(oSource).FIdentifierList);
  end;
  patient := TFhirMedicationStatement(oSource).patient.Clone;
  informationSource := TFhirMedicationStatement(oSource).informationSource.Clone;
  dateAssertedElement := TFhirMedicationStatement(oSource).dateAssertedElement.Clone;
  FStatus := TFhirMedicationStatement(oSource).FStatus.Link;
  wasNotTakenElement := TFhirMedicationStatement(oSource).wasNotTakenElement.Clone;
  if (TFhirMedicationStatement(oSource).FReasonNotTakenList = nil) then
  begin
    FReasonNotTakenList.free;
    FReasonNotTakenList := nil;
  end
  else
  begin
    if FReasonNotTakenList = nil then
      FReasonNotTakenList := TFhirCodeableConceptList.Create;
    FReasonNotTakenList.Assign(TFhirMedicationStatement(oSource).FReasonNotTakenList);
  end;
  reasonForUse := TFhirMedicationStatement(oSource).reasonForUse.Clone;
  effective := TFhirMedicationStatement(oSource).effective.Clone;
  noteElement := TFhirMedicationStatement(oSource).noteElement.Clone;
  if (TFhirMedicationStatement(oSource).FSupportingInformationList = nil) then
  begin
    FSupportingInformationList.free;
    FSupportingInformationList := nil;
  end
  else
  begin
    if FSupportingInformationList = nil then
      FSupportingInformationList := TFhirReferenceList{TFhirReference}.Create;
    FSupportingInformationList.Assign(TFhirMedicationStatement(oSource).FSupportingInformationList);
  end;
  medication := TFhirMedicationStatement(oSource).medication.Clone;
  if (TFhirMedicationStatement(oSource).FDosageList = nil) then
  begin
    FDosageList.free;
    FDosageList := nil;
  end
  else
  begin
    if FDosageList = nil then
      FDosageList := TFhirMedicationStatementDosageList.Create;
    FDosageList.Assign(TFhirMedicationStatement(oSource).FDosageList);
  end;
end;

procedure TFhirMedicationStatement.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'informationSource') Then
     list.add(self.link, 'informationSource', FInformationSource.Link);
  if (child_name = 'dateAsserted') Then
     list.add(self.link, 'dateAsserted', FDateAsserted.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'wasNotTaken') Then
     list.add(self.link, 'wasNotTaken', FWasNotTaken.Link);
  if (child_name = 'reasonNotTaken') Then
    list.addAll(self, 'reasonNotTaken', FReasonNotTakenList);
  if (child_name = 'reasonForUse[x]') or (child_name = 'reasonForUse') Then
     list.add(self.link, 'reasonForUse[x]', FReasonForUse.Link);
  if (child_name = 'effective[x]') or (child_name = 'effective') Then
     list.add(self.link, 'effective[x]', FEffective.Link);
  if (child_name = 'note') Then
     list.add(self.link, 'note', FNote.Link);
  if (child_name = 'supportingInformation') Then
    list.addAll(self, 'supportingInformation', FSupportingInformationList);
  if (child_name = 'medication[x]') or (child_name = 'medication') Then
     list.add(self.link, 'medication[x]', FMedication.Link);
  if (child_name = 'dosage') Then
    list.addAll(self, 'dosage', FDosageList);
end;

procedure TFhirMedicationStatement.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'informationSource', 'Reference(Patient|Practitioner|RelatedPerson)', false, TFhirReference{Resource}, FInformationSource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dateAsserted', 'dateTime', false, TFhirDateTime, FDateAsserted.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'wasNotTaken', 'boolean', false, TFhirBoolean, FWasNotTaken.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reasonNotTaken', 'CodeableConcept', true, TFhirCodeableConcept, FReasonNotTakenList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reasonForUse[x]', 'CodeableConcept|Reference(Condition)', false, TFhirType, FReasonForUse.Link));{2}
  oList.add(TFHIRProperty.create(self, 'effective[x]', 'dateTime|Period', false, TFhirType, FEffective.Link));{2}
  oList.add(TFHIRProperty.create(self, 'note', 'string', false, TFhirString, FNote.Link));{2}
  oList.add(TFHIRProperty.create(self, 'supportingInformation', 'Reference(Any)', true, TFhirReference{TFhirReference}, FSupportingInformationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'medication[x]', 'CodeableConcept|Reference(Medication)', false, TFhirType, FMedication.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dosage', '', true, TFhirMedicationStatementDosage, FDosageList.Link)){3};
end;

function TFhirMedicationStatement.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'informationSource') then
  begin
    InformationSource := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'dateAsserted') then
  begin
    DateAssertedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirMedicationStatementStatusEnum, CODES_TFhirMedicationStatementStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'wasNotTaken') then
  begin
    WasNotTakenElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'reasonNotTaken') then
  begin
    ReasonNotTakenList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'reasonForUse', ['CodeableConcept', 'Reference'])) then
  begin
    ReasonForUse := propValue as TFhirType{4};
    result := propValue;
  end
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then
  begin
    Effective := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'supportingInformation') then
  begin
    SupportingInformationList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then
  begin
    Medication := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'dosage') then
  begin
    DosageList.add(propValue as TFhirMedicationStatementDosage){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirMedicationStatement.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'reasonNotTaken') then ReasonNotTakenList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'supportingInformation') then SupportingInformationList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'dosage') then DosageList.insertItem(index, propValue as TFhirMedicationStatementDosage){2a}
  else inherited;
end;

function TFhirMedicationStatement.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'informationSource') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'dateAsserted') then result := TFhirDateTime.create() {5b}
  else if (propName = 'wasNotTaken') then result := TFhirBoolean.create() {5b}
  else if (propName = 'reasonNotTaken') then result := ReasonNotTakenList.new(){2}
  else if (isMatchingName(propName, 'reasonForUse', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property ReasonForUse'){4x}
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Effective'){4x}
  else if (propName = 'note') then result := TFhirString.create() {5b}
  else if (propName = 'supportingInformation') then result := SupportingInformationList.new(){2}
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Medication'){4x}
  else if (propName = 'dosage') then result := DosageList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationStatement.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'informationSource') then result := 'Reference'
  else if (propName = 'dateAsserted') then result := 'dateTime'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'wasNotTaken') then result := 'boolean'
  else if (propName = 'reasonNotTaken') then result := 'CodeableConcept'
  else if (propName = 'reasonForUse[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'effective[x]') then result := 'dateTime|Period'
  else if (propName = 'note') then result := 'string'
  else if (propName = 'supportingInformation') then result := 'Reference'
  else if (propName = 'medication[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'dosage') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationStatement.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'informationSource') then InformationSourceElement := nil
  else if (propName = 'dateAsserted') then DateAssertedElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'wasNotTaken') then WasNotTakenElement := nil
  else if (propName = 'reasonNotTaken') then deletePropertyValue('reasonNotTaken', ReasonNotTakenList, value) {2}
  else if (isMatchingName(propName, 'reasonForUse', ['CodeableConcept', 'Reference'])) then ReasonForUseElement := nil{4x}
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then EffectiveElement := nil{4x}
  else if (propName = 'note') then NoteElement := nil
  else if (propName = 'supportingInformation') then deletePropertyValue('supportingInformation', SupportingInformationList, value) {2}
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then MedicationElement := nil{4x}
  else if (propName = 'dosage') then deletePropertyValue('dosage', DosageList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationStatement.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'informationSource') then InformationSourceElement := new as TFhirReference{Resource}{4}
  else if (propName = 'dateAsserted') then DateAssertedElement := asDateTime(new){5b}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirMedicationStatementStatusEnum, CODES_TFhirMedicationStatementStatusEnum, new){4}
  else if (propName = 'wasNotTaken') then WasNotTakenElement := asBoolean(new){5b}
  else if (propName = 'reasonNotTaken') then replacePropertyValue('reasonNotTaken', ReasonNotTakenList, existing, new) {2}
  else if (isMatchingName(propName, 'reasonForUse', ['CodeableConcept', 'Reference'])) then ReasonForUseElement := new as TFhirType{4x}
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then EffectiveElement := new as TFhirType{4x}
  else if (propName = 'note') then NoteElement := asString(new){5b}
  else if (propName = 'supportingInformation') then replacePropertyValue('supportingInformation', SupportingInformationList, existing, new) {2}
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then MedicationElement := new as TFhirType{4x}
  else if (propName = 'dosage') then replacePropertyValue('dosage', DosageList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationStatement.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'reasonNotTaken') then ReasonNotTakenList.move(source, destination){2a}
  else if (propName = 'supportingInformation') then SupportingInformationList.move(source, destination){2a}
  else if (propName = 'dosage') then DosageList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationStatement.fhirType : string;
begin
  result := 'MedicationStatement';
end;

function TFhirMedicationStatement.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FPatient) and isEmptyProp(FInformationSource) and isEmptyProp(FDateAsserted) and isEmptyProp(FStatus) and isEmptyProp(FWasNotTaken) and isEmptyProp(FreasonNotTakenList) and isEmptyProp(FReasonForUse) and isEmptyProp(FEffective) and isEmptyProp(FNote) and isEmptyProp(FsupportingInformationList) and isEmptyProp(FMedication) and isEmptyProp(FdosageList);
end;

function TFhirMedicationStatement.equals(other : TObject) : boolean;
var
  o : TFhirMedicationStatement;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationStatement)) then
    result := false
  else
  begin
    o := TFhirMedicationStatement(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(patientElement, o.patientElement, true) and
      compareDeep(informationSourceElement, o.informationSourceElement, true) and compareDeep(dateAssertedElement, o.dateAssertedElement, true) and
      compareDeep(statusElement, o.statusElement, true) and compareDeep(wasNotTakenElement, o.wasNotTakenElement, true) and
      compareDeep(reasonNotTakenList, o.reasonNotTakenList, true) and compareDeep(reasonForUseElement, o.reasonForUseElement, true) and
      compareDeep(effectiveElement, o.effectiveElement, true) and compareDeep(noteElement, o.noteElement, true) and
      compareDeep(supportingInformationList, o.supportingInformationList, true) and
      compareDeep(medicationElement, o.medicationElement, true) and compareDeep(dosageList, o.dosageList, true);
  end;
end;

function TFhirMedicationStatement.Link : TFhirMedicationStatement;
begin
  result := TFhirMedicationStatement(inherited Link);
end;

function TFhirMedicationStatement.Clone : TFhirMedicationStatement;
begin
  result := TFhirMedicationStatement(inherited Clone);
end;

procedure TFhirMedicationStatement.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('patient');
  fields.add('informationSource');
  fields.add('dateAsserted');
  fields.add('status');
  fields.add('wasNotTaken');
  fields.add('reasonNotTaken');
  fields.add('reasonForUse[x]');
  fields.add('effective[x]');
  fields.add('note');
  fields.add('supportingInformation');
  fields.add('medication[x]');
  fields.add('dosage');
end;

{ TFhirMedicationStatement }

Function TFhirMedicationStatement.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirMedicationStatement.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirMedicationStatement.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Procedure TFhirMedicationStatement.SetInformationSource(value : TFhirReference{Resource});
begin
  FInformationSource.free;
  FInformationSource := value;
end;

Procedure TFhirMedicationStatement.SetDateAsserted(value : TFhirDateTime);
begin
  FDateAsserted.free;
  FDateAsserted := value;
end;

Function TFhirMedicationStatement.GetDateAssertedST : TFslDateTime;
begin
  if FDateAsserted = nil then
    result := TFslDateTime.makeNull
  else
    result := FDateAsserted.value;
end;

Procedure TFhirMedicationStatement.SetDateAssertedST(value : TFslDateTime);
begin
  if FDateAsserted = nil then
    FDateAsserted := TFhirDateTime.create;
  FDateAsserted.value := value
end;

Procedure TFhirMedicationStatement.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirMedicationStatement.GetStatusST : TFhirMedicationStatementStatusEnum;
begin
  if FStatus = nil then
    result := TFhirMedicationStatementStatusEnum(0)
  else
    result := TFhirMedicationStatementStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirMedicationStatementStatusEnum, FStatus.value));
end;

Procedure TFhirMedicationStatement.SetStatusST(value : TFhirMedicationStatementStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirMedicationStatementStatusEnum[value], CODES_TFhirMedicationStatementStatusEnum[value]);
end;

Procedure TFhirMedicationStatement.SetWasNotTaken(value : TFhirBoolean);
begin
  FWasNotTaken.free;
  FWasNotTaken := value;
end;

Function TFhirMedicationStatement.GetWasNotTakenST : Boolean;
begin
  if FWasNotTaken = nil then
    result := false
  else
    result := FWasNotTaken.value;
end;

Procedure TFhirMedicationStatement.SetWasNotTakenST(value : Boolean);
begin
  if FWasNotTaken = nil then
    FWasNotTaken := TFhirBoolean.create;
  FWasNotTaken.value := value
end;

Function TFhirMedicationStatement.GetReasonNotTakenList : TFhirCodeableConceptList;
begin
  if FReasonNotTakenList = nil then
    FReasonNotTakenList := TFhirCodeableConceptList.Create;
  result := FReasonNotTakenList;
end;

Function TFhirMedicationStatement.GetHasReasonNotTakenList : boolean;
begin
  result := (FReasonNotTakenList <> nil) and (FReasonNotTakenList.count > 0);
end;

Procedure TFhirMedicationStatement.SetReasonForUse(value : TFhirType);
begin
  FReasonForUse.free;
  FReasonForUse := value;
end;

Procedure TFhirMedicationStatement.SetEffective(value : TFhirType);
begin
  FEffective.free;
  FEffective := value;
end;

Procedure TFhirMedicationStatement.SetNote(value : TFhirString);
begin
  FNote.free;
  FNote := value;
end;

Function TFhirMedicationStatement.GetNoteST : String;
begin
  if FNote = nil then
    result := ''
  else
    result := FNote.value;
end;

Procedure TFhirMedicationStatement.SetNoteST(value : String);
begin
  if value <> '' then
  begin
    if FNote = nil then
      FNote := TFhirString.create;
    FNote.value := value
  end
  else if FNote <> nil then
    FNote.value := '';
end;

Function TFhirMedicationStatement.GetSupportingInformationList : TFhirReferenceList{TFhirReference};
begin
  if FSupportingInformationList = nil then
    FSupportingInformationList := TFhirReferenceList{TFhirReference}.Create;
  result := FSupportingInformationList;
end;

Function TFhirMedicationStatement.GetHasSupportingInformationList : boolean;
begin
  result := (FSupportingInformationList <> nil) and (FSupportingInformationList.count > 0);
end;

Procedure TFhirMedicationStatement.SetMedication(value : TFhirType);
begin
  FMedication.free;
  FMedication := value;
end;

Function TFhirMedicationStatement.GetDosageList : TFhirMedicationStatementDosageList;
begin
  if FDosageList = nil then
    FDosageList := TFhirMedicationStatementDosageList.Create;
  result := FDosageList;
end;

Function TFhirMedicationStatement.GetHasDosageList : boolean;
begin
  result := (FDosageList <> nil) and (FDosageList.count > 0);
end;

function TFhirMedicationStatement.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FInformationSource.sizeInBytes);
  inc(result, FDateAsserted.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FWasNotTaken.sizeInBytes);
  inc(result, FreasonNotTakenList.sizeInBytes);
  inc(result, FReasonForUse.sizeInBytes);
  inc(result, FEffective.sizeInBytes);
  inc(result, FNote.sizeInBytes);
  inc(result, FsupportingInformationList.sizeInBytes);
  inc(result, FMedication.sizeInBytes);
  inc(result, FdosageList.sizeInBytes);
end;

{ TFhirMedicationStatementListEnumerator }

Constructor TFhirMedicationStatementListEnumerator.Create(list : TFhirMedicationStatementList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationStatementListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationStatementListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationStatementListEnumerator.GetCurrent : TFhirMedicationStatement;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationStatementListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationStatementList }
procedure TFhirMedicationStatementList.AddItem(value: TFhirMedicationStatement);
begin
  assert(value.ClassName = 'TFhirMedicationStatement', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationStatement');
  add(value);
end;

function TFhirMedicationStatementList.Append: TFhirMedicationStatement;
begin
  result := TFhirMedicationStatement.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationStatementList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationStatementList.GetEnumerator : TFhirMedicationStatementListEnumerator;
begin
  result := TFhirMedicationStatementListEnumerator.Create(self.link);
end;

function TFhirMedicationStatementList.Clone: TFhirMedicationStatementList;
begin
  result := TFhirMedicationStatementList(inherited Clone);
end;

function TFhirMedicationStatementList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationStatementList.GetItemN(index: Integer): TFhirMedicationStatement;
begin
  result := TFhirMedicationStatement(ObjectByIndex[index]);
end;

function TFhirMedicationStatementList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationStatement;
end;
function TFhirMedicationStatementList.IndexOf(value: TFhirMedicationStatement): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationStatementList.Insert(index: Integer): TFhirMedicationStatement;
begin
  result := TFhirMedicationStatement.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationStatementList.InsertItem(index: Integer; value: TFhirMedicationStatement);
begin
  assert(value is TFhirMedicationStatement);
  Inherited Insert(index, value);
end;

function TFhirMedicationStatementList.Item(index: Integer): TFhirMedicationStatement;
begin
  result := TFhirMedicationStatement(ObjectByIndex[index]);
end;

function TFhirMedicationStatementList.Link: TFhirMedicationStatementList;
begin
  result := TFhirMedicationStatementList(inherited Link);
end;

procedure TFhirMedicationStatementList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationStatementList.SetItemByIndex(index: Integer; value: TFhirMedicationStatement);
begin
  assert(value is TFhirMedicationStatement);
  FhirMedicationStatements[index] := value;
end;

procedure TFhirMedicationStatementList.SetItemN(index: Integer; value: TFhirMedicationStatement);
begin
  assert(value is TFhirMedicationStatement);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEDICATIONSTATEMENT}

{$IFDEF FHIR_NUTRITIONORDER}

{ TFhirNutritionOrderOralDiet }

constructor TFhirNutritionOrderOralDiet.Create;
begin
  inherited;
end;

destructor TFhirNutritionOrderOralDiet.Destroy;
begin
  FType_List.Free;
  FScheduleList.Free;
  FNutrientList.Free;
  FTextureList.Free;
  FFluidConsistencyTypeList.Free;
  FInstruction.free;
  inherited;
end;

procedure TFhirNutritionOrderOralDiet.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirNutritionOrderOralDiet(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirNutritionOrderOralDiet(oSource).FType_List);
  end;
  if (TFhirNutritionOrderOralDiet(oSource).FScheduleList = nil) then
  begin
    FScheduleList.free;
    FScheduleList := nil;
  end
  else
  begin
    if FScheduleList = nil then
      FScheduleList := TFhirTimingList.Create;
    FScheduleList.Assign(TFhirNutritionOrderOralDiet(oSource).FScheduleList);
  end;
  if (TFhirNutritionOrderOralDiet(oSource).FNutrientList = nil) then
  begin
    FNutrientList.free;
    FNutrientList := nil;
  end
  else
  begin
    if FNutrientList = nil then
      FNutrientList := TFhirNutritionOrderOralDietNutrientList.Create;
    FNutrientList.Assign(TFhirNutritionOrderOralDiet(oSource).FNutrientList);
  end;
  if (TFhirNutritionOrderOralDiet(oSource).FTextureList = nil) then
  begin
    FTextureList.free;
    FTextureList := nil;
  end
  else
  begin
    if FTextureList = nil then
      FTextureList := TFhirNutritionOrderOralDietTextureList.Create;
    FTextureList.Assign(TFhirNutritionOrderOralDiet(oSource).FTextureList);
  end;
  if (TFhirNutritionOrderOralDiet(oSource).FFluidConsistencyTypeList = nil) then
  begin
    FFluidConsistencyTypeList.free;
    FFluidConsistencyTypeList := nil;
  end
  else
  begin
    if FFluidConsistencyTypeList = nil then
      FFluidConsistencyTypeList := TFhirCodeableConceptList.Create;
    FFluidConsistencyTypeList.Assign(TFhirNutritionOrderOralDiet(oSource).FFluidConsistencyTypeList);
  end;
  instructionElement := TFhirNutritionOrderOralDiet(oSource).instructionElement.Clone;
end;

procedure TFhirNutritionOrderOralDiet.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'schedule') Then
    list.addAll(self, 'schedule', FScheduleList);
  if (child_name = 'nutrient') Then
    list.addAll(self, 'nutrient', FNutrientList);
  if (child_name = 'texture') Then
    list.addAll(self, 'texture', FTextureList);
  if (child_name = 'fluidConsistencyType') Then
    list.addAll(self, 'fluidConsistencyType', FFluidConsistencyTypeList);
  if (child_name = 'instruction') Then
     list.add(self.link, 'instruction', FInstruction.Link);
end;

procedure TFhirNutritionOrderOralDiet.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'schedule', 'Timing', true, TFhirTiming, FScheduleList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'nutrient', '', true, TFhirNutritionOrderOralDietNutrient, FNutrientList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'texture', '', true, TFhirNutritionOrderOralDietTexture, FTextureList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'fluidConsistencyType', 'CodeableConcept', true, TFhirCodeableConcept, FFluidConsistencyTypeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'instruction', 'string', false, TFhirString, FInstruction.Link));{2}
end;

function TFhirNutritionOrderOralDiet.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'schedule') then
  begin
    ScheduleList.add(propValue as TFhirTiming){2a};
    result := propValue;
  end
  else if (propName = 'nutrient') then
  begin
    NutrientList.add(propValue as TFhirNutritionOrderOralDietNutrient){2a};
    result := propValue;
  end
  else if (propName = 'texture') then
  begin
    TextureList.add(propValue as TFhirNutritionOrderOralDietTexture){2a};
    result := propValue;
  end
  else if (propName = 'fluidConsistencyType') then
  begin
    FluidConsistencyTypeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'instruction') then
  begin
    InstructionElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionOrderOralDiet.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'schedule') then ScheduleList.insertItem(index, propValue as TFhirTiming){2a}
  else if (propName = 'nutrient') then NutrientList.insertItem(index, propValue as TFhirNutritionOrderOralDietNutrient){2a}
  else if (propName = 'texture') then TextureList.insertItem(index, propValue as TFhirNutritionOrderOralDietTexture){2a}
  else if (propName = 'fluidConsistencyType') then FluidConsistencyTypeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirNutritionOrderOralDiet.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := Type_List.new(){2}
  else if (propName = 'schedule') then result := ScheduleList.new(){2}
  else if (propName = 'nutrient') then result := NutrientList.new(){2}
  else if (propName = 'texture') then result := TextureList.new(){2}
  else if (propName = 'fluidConsistencyType') then result := FluidConsistencyTypeList.new(){2}
  else if (propName = 'instruction') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionOrderOralDiet.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'schedule') then result := 'Timing'
  else if (propName = 'nutrient') then result := ''
  else if (propName = 'texture') then result := ''
  else if (propName = 'fluidConsistencyType') then result := 'CodeableConcept'
  else if (propName = 'instruction') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionOrderOralDiet.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then deletePropertyValue('type', Type_List, value) {2}
  else if (propName = 'schedule') then deletePropertyValue('schedule', ScheduleList, value) {2}
  else if (propName = 'nutrient') then deletePropertyValue('nutrient', NutrientList, value) {2}
  else if (propName = 'texture') then deletePropertyValue('texture', TextureList, value) {2}
  else if (propName = 'fluidConsistencyType') then deletePropertyValue('fluidConsistencyType', FluidConsistencyTypeList, value) {2}
  else if (propName = 'instruction') then InstructionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionOrderOralDiet.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new) {2}
  else if (propName = 'schedule') then replacePropertyValue('schedule', ScheduleList, existing, new) {2}
  else if (propName = 'nutrient') then replacePropertyValue('nutrient', NutrientList, existing, new) {2}
  else if (propName = 'texture') then replacePropertyValue('texture', TextureList, existing, new) {2}
  else if (propName = 'fluidConsistencyType') then replacePropertyValue('fluidConsistencyType', FluidConsistencyTypeList, existing, new) {2}
  else if (propName = 'instruction') then InstructionElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionOrderOralDiet.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'type') then Type_List.move(source, destination){2a}
  else if (propName = 'schedule') then ScheduleList.move(source, destination){2a}
  else if (propName = 'nutrient') then NutrientList.move(source, destination){2a}
  else if (propName = 'texture') then TextureList.move(source, destination){2a}
  else if (propName = 'fluidConsistencyType') then FluidConsistencyTypeList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionOrderOralDiet.fhirType : string;
begin
  result := 'oralDiet';
end;

function TFhirNutritionOrderOralDiet.Link : TFhirNutritionOrderOralDiet;
begin
  result := TFhirNutritionOrderOralDiet(inherited Link);
end;

function TFhirNutritionOrderOralDiet.Clone : TFhirNutritionOrderOralDiet;
begin
  result := TFhirNutritionOrderOralDiet(inherited Clone);
end;

function TFhirNutritionOrderOralDiet.equals(other : TObject) : boolean;
var
  o : TFhirNutritionOrderOralDiet;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionOrderOralDiet)) then
    result := false
  else
  begin
    o := TFhirNutritionOrderOralDiet(other);
    result := compareDeep(type_List, o.type_List, true) and compareDeep(scheduleList, o.scheduleList, true) and
      compareDeep(nutrientList, o.nutrientList, true) and compareDeep(textureList, o.textureList, true) and
      compareDeep(fluidConsistencyTypeList, o.fluidConsistencyTypeList, true) and compareDeep(instructionElement, o.instructionElement, true);
  end;
end;

function TFhirNutritionOrderOralDiet.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(Ftype_List) and isEmptyProp(FscheduleList) and isEmptyProp(FnutrientList) and isEmptyProp(FtextureList) and isEmptyProp(FfluidConsistencyTypeList) and isEmptyProp(FInstruction);
end;

procedure TFhirNutritionOrderOralDiet.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('schedule');
  fields.add('nutrient');
  fields.add('texture');
  fields.add('fluidConsistencyType');
  fields.add('instruction');
end;

{ TFhirNutritionOrderOralDiet }

Function TFhirNutritionOrderOralDiet.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

Function TFhirNutritionOrderOralDiet.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

Function TFhirNutritionOrderOralDiet.GetScheduleList : TFhirTimingList;
begin
  if FScheduleList = nil then
    FScheduleList := TFhirTimingList.Create;
  result := FScheduleList;
end;

Function TFhirNutritionOrderOralDiet.GetHasScheduleList : boolean;
begin
  result := (FScheduleList <> nil) and (FScheduleList.count > 0);
end;

Function TFhirNutritionOrderOralDiet.GetNutrientList : TFhirNutritionOrderOralDietNutrientList;
begin
  if FNutrientList = nil then
    FNutrientList := TFhirNutritionOrderOralDietNutrientList.Create;
  result := FNutrientList;
end;

Function TFhirNutritionOrderOralDiet.GetHasNutrientList : boolean;
begin
  result := (FNutrientList <> nil) and (FNutrientList.count > 0);
end;

Function TFhirNutritionOrderOralDiet.GetTextureList : TFhirNutritionOrderOralDietTextureList;
begin
  if FTextureList = nil then
    FTextureList := TFhirNutritionOrderOralDietTextureList.Create;
  result := FTextureList;
end;

Function TFhirNutritionOrderOralDiet.GetHasTextureList : boolean;
begin
  result := (FTextureList <> nil) and (FTextureList.count > 0);
end;

Function TFhirNutritionOrderOralDiet.GetFluidConsistencyTypeList : TFhirCodeableConceptList;
begin
  if FFluidConsistencyTypeList = nil then
    FFluidConsistencyTypeList := TFhirCodeableConceptList.Create;
  result := FFluidConsistencyTypeList;
end;

Function TFhirNutritionOrderOralDiet.GetHasFluidConsistencyTypeList : boolean;
begin
  result := (FFluidConsistencyTypeList <> nil) and (FFluidConsistencyTypeList.count > 0);
end;

Procedure TFhirNutritionOrderOralDiet.SetInstruction(value : TFhirString);
begin
  FInstruction.free;
  FInstruction := value;
end;

Function TFhirNutritionOrderOralDiet.GetInstructionST : String;
begin
  if FInstruction = nil then
    result := ''
  else
    result := FInstruction.value;
end;

Procedure TFhirNutritionOrderOralDiet.SetInstructionST(value : String);
begin
  if value <> '' then
  begin
    if FInstruction = nil then
      FInstruction := TFhirString.create;
    FInstruction.value := value
  end
  else if FInstruction <> nil then
    FInstruction.value := '';
end;

function TFhirNutritionOrderOralDiet.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, Ftype_List.sizeInBytes);
  inc(result, FscheduleList.sizeInBytes);
  inc(result, FnutrientList.sizeInBytes);
  inc(result, FtextureList.sizeInBytes);
  inc(result, FfluidConsistencyTypeList.sizeInBytes);
  inc(result, FInstruction.sizeInBytes);
end;

{ TFhirNutritionOrderOralDietListEnumerator }

Constructor TFhirNutritionOrderOralDietListEnumerator.Create(list : TFhirNutritionOrderOralDietList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionOrderOralDietListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionOrderOralDietListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionOrderOralDietListEnumerator.GetCurrent : TFhirNutritionOrderOralDiet;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionOrderOralDietListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirNutritionOrderOralDietList }
procedure TFhirNutritionOrderOralDietList.AddItem(value: TFhirNutritionOrderOralDiet);
begin
  assert(value.ClassName = 'TFhirNutritionOrderOralDiet', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionOrderOralDiet');
  add(value);
end;

function TFhirNutritionOrderOralDietList.Append: TFhirNutritionOrderOralDiet;
begin
  result := TFhirNutritionOrderOralDiet.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderOralDietList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionOrderOralDietList.GetEnumerator : TFhirNutritionOrderOralDietListEnumerator;
begin
  result := TFhirNutritionOrderOralDietListEnumerator.Create(self.link);
end;

function TFhirNutritionOrderOralDietList.Clone: TFhirNutritionOrderOralDietList;
begin
  result := TFhirNutritionOrderOralDietList(inherited Clone);
end;

function TFhirNutritionOrderOralDietList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionOrderOralDietList.GetItemN(index: Integer): TFhirNutritionOrderOralDiet;
begin
  result := TFhirNutritionOrderOralDiet(ObjectByIndex[index]);
end;

function TFhirNutritionOrderOralDietList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionOrderOralDiet;
end;
function TFhirNutritionOrderOralDietList.IndexOf(value: TFhirNutritionOrderOralDiet): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionOrderOralDietList.Insert(index: Integer): TFhirNutritionOrderOralDiet;
begin
  result := TFhirNutritionOrderOralDiet.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderOralDietList.InsertItem(index: Integer; value: TFhirNutritionOrderOralDiet);
begin
  assert(value is TFhirNutritionOrderOralDiet);
  Inherited Insert(index, value);
end;

function TFhirNutritionOrderOralDietList.Item(index: Integer): TFhirNutritionOrderOralDiet;
begin
  result := TFhirNutritionOrderOralDiet(ObjectByIndex[index]);
end;

function TFhirNutritionOrderOralDietList.Link: TFhirNutritionOrderOralDietList;
begin
  result := TFhirNutritionOrderOralDietList(inherited Link);
end;

procedure TFhirNutritionOrderOralDietList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionOrderOralDietList.SetItemByIndex(index: Integer; value: TFhirNutritionOrderOralDiet);
begin
  assert(value is TFhirNutritionOrderOralDiet);
  FhirNutritionOrderOralDiets[index] := value;
end;

procedure TFhirNutritionOrderOralDietList.SetItemN(index: Integer; value: TFhirNutritionOrderOralDiet);
begin
  assert(value is TFhirNutritionOrderOralDiet);
  ObjectByIndex[index] := value;
end;

{ TFhirNutritionOrderOralDietNutrient }

constructor TFhirNutritionOrderOralDietNutrient.Create;
begin
  inherited;
end;

destructor TFhirNutritionOrderOralDietNutrient.Destroy;
begin
  FModifier.free;
  FAmount.free;
  inherited;
end;

procedure TFhirNutritionOrderOralDietNutrient.Assign(oSource : TFslObject);
begin
  inherited;
  modifier := TFhirNutritionOrderOralDietNutrient(oSource).modifier.Clone;
  amount := TFhirNutritionOrderOralDietNutrient(oSource).amount.Clone;
end;

procedure TFhirNutritionOrderOralDietNutrient.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'modifier') Then
     list.add(self.link, 'modifier', FModifier.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
end;

procedure TFhirNutritionOrderOralDietNutrient.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', false, TFhirCodeableConcept, FModifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amount', 'Quantity', false, TFhirQuantity, FAmount.Link));{2}
end;

function TFhirNutritionOrderOralDietNutrient.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'modifier') then
  begin
    Modifier := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionOrderOralDietNutrient.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirNutritionOrderOralDietNutrient.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'modifier') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'amount') then result := TFhirQuantity.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionOrderOralDietNutrient.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'amount') then result := 'Quantity'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionOrderOralDietNutrient.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'modifier') then ModifierElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionOrderOralDietNutrient.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'modifier') then ModifierElement := new as TFhirCodeableConcept{4}
  else if (propName = 'amount') then AmountElement := new as TFhirQuantity{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionOrderOralDietNutrient.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionOrderOralDietNutrient.fhirType : string;
begin
  result := 'nutrient';
end;

function TFhirNutritionOrderOralDietNutrient.Link : TFhirNutritionOrderOralDietNutrient;
begin
  result := TFhirNutritionOrderOralDietNutrient(inherited Link);
end;

function TFhirNutritionOrderOralDietNutrient.Clone : TFhirNutritionOrderOralDietNutrient;
begin
  result := TFhirNutritionOrderOralDietNutrient(inherited Clone);
end;

function TFhirNutritionOrderOralDietNutrient.equals(other : TObject) : boolean;
var
  o : TFhirNutritionOrderOralDietNutrient;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionOrderOralDietNutrient)) then
    result := false
  else
  begin
    o := TFhirNutritionOrderOralDietNutrient(other);
    result := compareDeep(modifierElement, o.modifierElement, true) and compareDeep(amountElement, o.amountElement, true);
  end;
end;

function TFhirNutritionOrderOralDietNutrient.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FModifier) and isEmptyProp(FAmount);
end;

procedure TFhirNutritionOrderOralDietNutrient.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('modifier');
  fields.add('amount');
end;

{ TFhirNutritionOrderOralDietNutrient }

Procedure TFhirNutritionOrderOralDietNutrient.SetModifier(value : TFhirCodeableConcept);
begin
  FModifier.free;
  FModifier := value;
end;

Procedure TFhirNutritionOrderOralDietNutrient.SetAmount(value : TFhirQuantity);
begin
  FAmount.free;
  FAmount := value;
end;

function TFhirNutritionOrderOralDietNutrient.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FModifier.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
end;

{ TFhirNutritionOrderOralDietNutrientListEnumerator }

Constructor TFhirNutritionOrderOralDietNutrientListEnumerator.Create(list : TFhirNutritionOrderOralDietNutrientList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionOrderOralDietNutrientListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionOrderOralDietNutrientListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionOrderOralDietNutrientListEnumerator.GetCurrent : TFhirNutritionOrderOralDietNutrient;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionOrderOralDietNutrientListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirNutritionOrderOralDietNutrientList }
procedure TFhirNutritionOrderOralDietNutrientList.AddItem(value: TFhirNutritionOrderOralDietNutrient);
begin
  assert(value.ClassName = 'TFhirNutritionOrderOralDietNutrient', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionOrderOralDietNutrient');
  add(value);
end;

function TFhirNutritionOrderOralDietNutrientList.Append: TFhirNutritionOrderOralDietNutrient;
begin
  result := TFhirNutritionOrderOralDietNutrient.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderOralDietNutrientList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionOrderOralDietNutrientList.GetEnumerator : TFhirNutritionOrderOralDietNutrientListEnumerator;
begin
  result := TFhirNutritionOrderOralDietNutrientListEnumerator.Create(self.link);
end;

function TFhirNutritionOrderOralDietNutrientList.Clone: TFhirNutritionOrderOralDietNutrientList;
begin
  result := TFhirNutritionOrderOralDietNutrientList(inherited Clone);
end;

function TFhirNutritionOrderOralDietNutrientList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionOrderOralDietNutrientList.GetItemN(index: Integer): TFhirNutritionOrderOralDietNutrient;
begin
  result := TFhirNutritionOrderOralDietNutrient(ObjectByIndex[index]);
end;

function TFhirNutritionOrderOralDietNutrientList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionOrderOralDietNutrient;
end;
function TFhirNutritionOrderOralDietNutrientList.IndexOf(value: TFhirNutritionOrderOralDietNutrient): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionOrderOralDietNutrientList.Insert(index: Integer): TFhirNutritionOrderOralDietNutrient;
begin
  result := TFhirNutritionOrderOralDietNutrient.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderOralDietNutrientList.InsertItem(index: Integer; value: TFhirNutritionOrderOralDietNutrient);
begin
  assert(value is TFhirNutritionOrderOralDietNutrient);
  Inherited Insert(index, value);
end;

function TFhirNutritionOrderOralDietNutrientList.Item(index: Integer): TFhirNutritionOrderOralDietNutrient;
begin
  result := TFhirNutritionOrderOralDietNutrient(ObjectByIndex[index]);
end;

function TFhirNutritionOrderOralDietNutrientList.Link: TFhirNutritionOrderOralDietNutrientList;
begin
  result := TFhirNutritionOrderOralDietNutrientList(inherited Link);
end;

procedure TFhirNutritionOrderOralDietNutrientList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionOrderOralDietNutrientList.SetItemByIndex(index: Integer; value: TFhirNutritionOrderOralDietNutrient);
begin
  assert(value is TFhirNutritionOrderOralDietNutrient);
  FhirNutritionOrderOralDietNutrients[index] := value;
end;

procedure TFhirNutritionOrderOralDietNutrientList.SetItemN(index: Integer; value: TFhirNutritionOrderOralDietNutrient);
begin
  assert(value is TFhirNutritionOrderOralDietNutrient);
  ObjectByIndex[index] := value;
end;

{ TFhirNutritionOrderOralDietTexture }

constructor TFhirNutritionOrderOralDietTexture.Create;
begin
  inherited;
end;

destructor TFhirNutritionOrderOralDietTexture.Destroy;
begin
  FModifier.free;
  FFoodType.free;
  inherited;
end;

procedure TFhirNutritionOrderOralDietTexture.Assign(oSource : TFslObject);
begin
  inherited;
  modifier := TFhirNutritionOrderOralDietTexture(oSource).modifier.Clone;
  foodType := TFhirNutritionOrderOralDietTexture(oSource).foodType.Clone;
end;

procedure TFhirNutritionOrderOralDietTexture.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'modifier') Then
     list.add(self.link, 'modifier', FModifier.Link);
  if (child_name = 'foodType') Then
     list.add(self.link, 'foodType', FFoodType.Link);
end;

procedure TFhirNutritionOrderOralDietTexture.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', false, TFhirCodeableConcept, FModifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'foodType', 'CodeableConcept', false, TFhirCodeableConcept, FFoodType.Link));{2}
end;

function TFhirNutritionOrderOralDietTexture.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'modifier') then
  begin
    Modifier := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'foodType') then
  begin
    FoodType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionOrderOralDietTexture.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirNutritionOrderOralDietTexture.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'modifier') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'foodType') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionOrderOralDietTexture.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'foodType') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionOrderOralDietTexture.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'modifier') then ModifierElement := nil
  else if (propName = 'foodType') then FoodTypeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionOrderOralDietTexture.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'modifier') then ModifierElement := new as TFhirCodeableConcept{4}
  else if (propName = 'foodType') then FoodTypeElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionOrderOralDietTexture.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionOrderOralDietTexture.fhirType : string;
begin
  result := 'texture';
end;

function TFhirNutritionOrderOralDietTexture.Link : TFhirNutritionOrderOralDietTexture;
begin
  result := TFhirNutritionOrderOralDietTexture(inherited Link);
end;

function TFhirNutritionOrderOralDietTexture.Clone : TFhirNutritionOrderOralDietTexture;
begin
  result := TFhirNutritionOrderOralDietTexture(inherited Clone);
end;

function TFhirNutritionOrderOralDietTexture.equals(other : TObject) : boolean;
var
  o : TFhirNutritionOrderOralDietTexture;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionOrderOralDietTexture)) then
    result := false
  else
  begin
    o := TFhirNutritionOrderOralDietTexture(other);
    result := compareDeep(modifierElement, o.modifierElement, true) and compareDeep(foodTypeElement, o.foodTypeElement, true);
  end;
end;

function TFhirNutritionOrderOralDietTexture.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FModifier) and isEmptyProp(FFoodType);
end;

procedure TFhirNutritionOrderOralDietTexture.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('modifier');
  fields.add('foodType');
end;

{ TFhirNutritionOrderOralDietTexture }

Procedure TFhirNutritionOrderOralDietTexture.SetModifier(value : TFhirCodeableConcept);
begin
  FModifier.free;
  FModifier := value;
end;

Procedure TFhirNutritionOrderOralDietTexture.SetFoodType(value : TFhirCodeableConcept);
begin
  FFoodType.free;
  FFoodType := value;
end;

function TFhirNutritionOrderOralDietTexture.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FModifier.sizeInBytes);
  inc(result, FFoodType.sizeInBytes);
end;

{ TFhirNutritionOrderOralDietTextureListEnumerator }

Constructor TFhirNutritionOrderOralDietTextureListEnumerator.Create(list : TFhirNutritionOrderOralDietTextureList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionOrderOralDietTextureListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionOrderOralDietTextureListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionOrderOralDietTextureListEnumerator.GetCurrent : TFhirNutritionOrderOralDietTexture;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionOrderOralDietTextureListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirNutritionOrderOralDietTextureList }
procedure TFhirNutritionOrderOralDietTextureList.AddItem(value: TFhirNutritionOrderOralDietTexture);
begin
  assert(value.ClassName = 'TFhirNutritionOrderOralDietTexture', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionOrderOralDietTexture');
  add(value);
end;

function TFhirNutritionOrderOralDietTextureList.Append: TFhirNutritionOrderOralDietTexture;
begin
  result := TFhirNutritionOrderOralDietTexture.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderOralDietTextureList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionOrderOralDietTextureList.GetEnumerator : TFhirNutritionOrderOralDietTextureListEnumerator;
begin
  result := TFhirNutritionOrderOralDietTextureListEnumerator.Create(self.link);
end;

function TFhirNutritionOrderOralDietTextureList.Clone: TFhirNutritionOrderOralDietTextureList;
begin
  result := TFhirNutritionOrderOralDietTextureList(inherited Clone);
end;

function TFhirNutritionOrderOralDietTextureList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionOrderOralDietTextureList.GetItemN(index: Integer): TFhirNutritionOrderOralDietTexture;
begin
  result := TFhirNutritionOrderOralDietTexture(ObjectByIndex[index]);
end;

function TFhirNutritionOrderOralDietTextureList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionOrderOralDietTexture;
end;
function TFhirNutritionOrderOralDietTextureList.IndexOf(value: TFhirNutritionOrderOralDietTexture): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionOrderOralDietTextureList.Insert(index: Integer): TFhirNutritionOrderOralDietTexture;
begin
  result := TFhirNutritionOrderOralDietTexture.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderOralDietTextureList.InsertItem(index: Integer; value: TFhirNutritionOrderOralDietTexture);
begin
  assert(value is TFhirNutritionOrderOralDietTexture);
  Inherited Insert(index, value);
end;

function TFhirNutritionOrderOralDietTextureList.Item(index: Integer): TFhirNutritionOrderOralDietTexture;
begin
  result := TFhirNutritionOrderOralDietTexture(ObjectByIndex[index]);
end;

function TFhirNutritionOrderOralDietTextureList.Link: TFhirNutritionOrderOralDietTextureList;
begin
  result := TFhirNutritionOrderOralDietTextureList(inherited Link);
end;

procedure TFhirNutritionOrderOralDietTextureList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionOrderOralDietTextureList.SetItemByIndex(index: Integer; value: TFhirNutritionOrderOralDietTexture);
begin
  assert(value is TFhirNutritionOrderOralDietTexture);
  FhirNutritionOrderOralDietTextures[index] := value;
end;

procedure TFhirNutritionOrderOralDietTextureList.SetItemN(index: Integer; value: TFhirNutritionOrderOralDietTexture);
begin
  assert(value is TFhirNutritionOrderOralDietTexture);
  ObjectByIndex[index] := value;
end;

{ TFhirNutritionOrderSupplement }

constructor TFhirNutritionOrderSupplement.Create;
begin
  inherited;
end;

destructor TFhirNutritionOrderSupplement.Destroy;
begin
  FType_.free;
  FProductName.free;
  FScheduleList.Free;
  FQuantity.free;
  FInstruction.free;
  inherited;
end;

procedure TFhirNutritionOrderSupplement.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirNutritionOrderSupplement(oSource).type_.Clone;
  productNameElement := TFhirNutritionOrderSupplement(oSource).productNameElement.Clone;
  if (TFhirNutritionOrderSupplement(oSource).FScheduleList = nil) then
  begin
    FScheduleList.free;
    FScheduleList := nil;
  end
  else
  begin
    if FScheduleList = nil then
      FScheduleList := TFhirTimingList.Create;
    FScheduleList.Assign(TFhirNutritionOrderSupplement(oSource).FScheduleList);
  end;
  quantity := TFhirNutritionOrderSupplement(oSource).quantity.Clone;
  instructionElement := TFhirNutritionOrderSupplement(oSource).instructionElement.Clone;
end;

procedure TFhirNutritionOrderSupplement.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'productName') Then
     list.add(self.link, 'productName', FProductName.Link);
  if (child_name = 'schedule') Then
    list.addAll(self, 'schedule', FScheduleList);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'instruction') Then
     list.add(self.link, 'instruction', FInstruction.Link);
end;

procedure TFhirNutritionOrderSupplement.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'productName', 'string', false, TFhirString, FProductName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'schedule', 'Timing', true, TFhirTiming, FScheduleList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'instruction', 'string', false, TFhirString, FInstruction.Link));{2}
end;

function TFhirNutritionOrderSupplement.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'productName') then
  begin
    ProductNameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'schedule') then
  begin
    ScheduleList.add(propValue as TFhirTiming){2a};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'instruction') then
  begin
    InstructionElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionOrderSupplement.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'schedule') then ScheduleList.insertItem(index, propValue as TFhirTiming){2a}
  else inherited;
end;

function TFhirNutritionOrderSupplement.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'productName') then result := TFhirString.create() {5b}
  else if (propName = 'schedule') then result := ScheduleList.new(){2}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'instruction') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionOrderSupplement.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'productName') then result := 'string'
  else if (propName = 'schedule') then result := 'Timing'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'instruction') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionOrderSupplement.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'productName') then ProductNameElement := nil
  else if (propName = 'schedule') then deletePropertyValue('schedule', ScheduleList, value) {2}
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'instruction') then InstructionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionOrderSupplement.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'productName') then ProductNameElement := asString(new){5b}
  else if (propName = 'schedule') then replacePropertyValue('schedule', ScheduleList, existing, new) {2}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'instruction') then InstructionElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionOrderSupplement.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'schedule') then ScheduleList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionOrderSupplement.fhirType : string;
begin
  result := 'supplement';
end;

function TFhirNutritionOrderSupplement.Link : TFhirNutritionOrderSupplement;
begin
  result := TFhirNutritionOrderSupplement(inherited Link);
end;

function TFhirNutritionOrderSupplement.Clone : TFhirNutritionOrderSupplement;
begin
  result := TFhirNutritionOrderSupplement(inherited Clone);
end;

function TFhirNutritionOrderSupplement.equals(other : TObject) : boolean;
var
  o : TFhirNutritionOrderSupplement;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionOrderSupplement)) then
    result := false
  else
  begin
    o := TFhirNutritionOrderSupplement(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(productNameElement, o.productNameElement, true) and
      compareDeep(scheduleList, o.scheduleList, true) and compareDeep(quantityElement, o.quantityElement, true) and
      compareDeep(instructionElement, o.instructionElement, true);
  end;
end;

function TFhirNutritionOrderSupplement.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FProductName) and isEmptyProp(FscheduleList) and isEmptyProp(FQuantity) and isEmptyProp(FInstruction);
end;

procedure TFhirNutritionOrderSupplement.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('productName');
  fields.add('schedule');
  fields.add('quantity');
  fields.add('instruction');
end;

{ TFhirNutritionOrderSupplement }

Procedure TFhirNutritionOrderSupplement.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirNutritionOrderSupplement.SetProductName(value : TFhirString);
begin
  FProductName.free;
  FProductName := value;
end;

Function TFhirNutritionOrderSupplement.GetProductNameST : String;
begin
  if FProductName = nil then
    result := ''
  else
    result := FProductName.value;
end;

Procedure TFhirNutritionOrderSupplement.SetProductNameST(value : String);
begin
  if value <> '' then
  begin
    if FProductName = nil then
      FProductName := TFhirString.create;
    FProductName.value := value
  end
  else if FProductName <> nil then
    FProductName.value := '';
end;

Function TFhirNutritionOrderSupplement.GetScheduleList : TFhirTimingList;
begin
  if FScheduleList = nil then
    FScheduleList := TFhirTimingList.Create;
  result := FScheduleList;
end;

Function TFhirNutritionOrderSupplement.GetHasScheduleList : boolean;
begin
  result := (FScheduleList <> nil) and (FScheduleList.count > 0);
end;

Procedure TFhirNutritionOrderSupplement.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirNutritionOrderSupplement.SetInstruction(value : TFhirString);
begin
  FInstruction.free;
  FInstruction := value;
end;

Function TFhirNutritionOrderSupplement.GetInstructionST : String;
begin
  if FInstruction = nil then
    result := ''
  else
    result := FInstruction.value;
end;

Procedure TFhirNutritionOrderSupplement.SetInstructionST(value : String);
begin
  if value <> '' then
  begin
    if FInstruction = nil then
      FInstruction := TFhirString.create;
    FInstruction.value := value
  end
  else if FInstruction <> nil then
    FInstruction.value := '';
end;

function TFhirNutritionOrderSupplement.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FProductName.sizeInBytes);
  inc(result, FscheduleList.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FInstruction.sizeInBytes);
end;

{ TFhirNutritionOrderSupplementListEnumerator }

Constructor TFhirNutritionOrderSupplementListEnumerator.Create(list : TFhirNutritionOrderSupplementList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionOrderSupplementListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionOrderSupplementListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionOrderSupplementListEnumerator.GetCurrent : TFhirNutritionOrderSupplement;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionOrderSupplementListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirNutritionOrderSupplementList }
procedure TFhirNutritionOrderSupplementList.AddItem(value: TFhirNutritionOrderSupplement);
begin
  assert(value.ClassName = 'TFhirNutritionOrderSupplement', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionOrderSupplement');
  add(value);
end;

function TFhirNutritionOrderSupplementList.Append: TFhirNutritionOrderSupplement;
begin
  result := TFhirNutritionOrderSupplement.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderSupplementList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionOrderSupplementList.GetEnumerator : TFhirNutritionOrderSupplementListEnumerator;
begin
  result := TFhirNutritionOrderSupplementListEnumerator.Create(self.link);
end;

function TFhirNutritionOrderSupplementList.Clone: TFhirNutritionOrderSupplementList;
begin
  result := TFhirNutritionOrderSupplementList(inherited Clone);
end;

function TFhirNutritionOrderSupplementList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionOrderSupplementList.GetItemN(index: Integer): TFhirNutritionOrderSupplement;
begin
  result := TFhirNutritionOrderSupplement(ObjectByIndex[index]);
end;

function TFhirNutritionOrderSupplementList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionOrderSupplement;
end;
function TFhirNutritionOrderSupplementList.IndexOf(value: TFhirNutritionOrderSupplement): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionOrderSupplementList.Insert(index: Integer): TFhirNutritionOrderSupplement;
begin
  result := TFhirNutritionOrderSupplement.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderSupplementList.InsertItem(index: Integer; value: TFhirNutritionOrderSupplement);
begin
  assert(value is TFhirNutritionOrderSupplement);
  Inherited Insert(index, value);
end;

function TFhirNutritionOrderSupplementList.Item(index: Integer): TFhirNutritionOrderSupplement;
begin
  result := TFhirNutritionOrderSupplement(ObjectByIndex[index]);
end;

function TFhirNutritionOrderSupplementList.Link: TFhirNutritionOrderSupplementList;
begin
  result := TFhirNutritionOrderSupplementList(inherited Link);
end;

procedure TFhirNutritionOrderSupplementList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionOrderSupplementList.SetItemByIndex(index: Integer; value: TFhirNutritionOrderSupplement);
begin
  assert(value is TFhirNutritionOrderSupplement);
  FhirNutritionOrderSupplements[index] := value;
end;

procedure TFhirNutritionOrderSupplementList.SetItemN(index: Integer; value: TFhirNutritionOrderSupplement);
begin
  assert(value is TFhirNutritionOrderSupplement);
  ObjectByIndex[index] := value;
end;

{ TFhirNutritionOrderEnteralFormula }

constructor TFhirNutritionOrderEnteralFormula.Create;
begin
  inherited;
end;

destructor TFhirNutritionOrderEnteralFormula.Destroy;
begin
  FBaseFormulaType.free;
  FBaseFormulaProductName.free;
  FAdditiveType.free;
  FAdditiveProductName.free;
  FCaloricDensity.free;
  FRouteofAdministration.free;
  FAdministrationList.Free;
  FMaxVolumeToDeliver.free;
  FAdministrationInstruction.free;
  inherited;
end;

procedure TFhirNutritionOrderEnteralFormula.Assign(oSource : TFslObject);
begin
  inherited;
  baseFormulaType := TFhirNutritionOrderEnteralFormula(oSource).baseFormulaType.Clone;
  baseFormulaProductNameElement := TFhirNutritionOrderEnteralFormula(oSource).baseFormulaProductNameElement.Clone;
  additiveType := TFhirNutritionOrderEnteralFormula(oSource).additiveType.Clone;
  additiveProductNameElement := TFhirNutritionOrderEnteralFormula(oSource).additiveProductNameElement.Clone;
  caloricDensity := TFhirNutritionOrderEnteralFormula(oSource).caloricDensity.Clone;
  routeofAdministration := TFhirNutritionOrderEnteralFormula(oSource).routeofAdministration.Clone;
  if (TFhirNutritionOrderEnteralFormula(oSource).FAdministrationList = nil) then
  begin
    FAdministrationList.free;
    FAdministrationList := nil;
  end
  else
  begin
    if FAdministrationList = nil then
      FAdministrationList := TFhirNutritionOrderEnteralFormulaAdministrationList.Create;
    FAdministrationList.Assign(TFhirNutritionOrderEnteralFormula(oSource).FAdministrationList);
  end;
  maxVolumeToDeliver := TFhirNutritionOrderEnteralFormula(oSource).maxVolumeToDeliver.Clone;
  administrationInstructionElement := TFhirNutritionOrderEnteralFormula(oSource).administrationInstructionElement.Clone;
end;

procedure TFhirNutritionOrderEnteralFormula.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'baseFormulaType') Then
     list.add(self.link, 'baseFormulaType', FBaseFormulaType.Link);
  if (child_name = 'baseFormulaProductName') Then
     list.add(self.link, 'baseFormulaProductName', FBaseFormulaProductName.Link);
  if (child_name = 'additiveType') Then
     list.add(self.link, 'additiveType', FAdditiveType.Link);
  if (child_name = 'additiveProductName') Then
     list.add(self.link, 'additiveProductName', FAdditiveProductName.Link);
  if (child_name = 'caloricDensity') Then
     list.add(self.link, 'caloricDensity', FCaloricDensity.Link);
  if (child_name = 'routeofAdministration') Then
     list.add(self.link, 'routeofAdministration', FRouteofAdministration.Link);
  if (child_name = 'administration') Then
    list.addAll(self, 'administration', FAdministrationList);
  if (child_name = 'maxVolumeToDeliver') Then
     list.add(self.link, 'maxVolumeToDeliver', FMaxVolumeToDeliver.Link);
  if (child_name = 'administrationInstruction') Then
     list.add(self.link, 'administrationInstruction', FAdministrationInstruction.Link);
end;

procedure TFhirNutritionOrderEnteralFormula.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'baseFormulaType', 'CodeableConcept', false, TFhirCodeableConcept, FBaseFormulaType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'baseFormulaProductName', 'string', false, TFhirString, FBaseFormulaProductName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'additiveType', 'CodeableConcept', false, TFhirCodeableConcept, FAdditiveType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'additiveProductName', 'string', false, TFhirString, FAdditiveProductName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'caloricDensity', 'Quantity', false, TFhirQuantity, FCaloricDensity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'routeofAdministration', 'CodeableConcept', false, TFhirCodeableConcept, FRouteofAdministration.Link));{2}
  oList.add(TFHIRProperty.create(self, 'administration', '', true, TFhirNutritionOrderEnteralFormulaAdministration, FAdministrationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'maxVolumeToDeliver', 'Quantity', false, TFhirQuantity, FMaxVolumeToDeliver.Link));{2}
  oList.add(TFHIRProperty.create(self, 'administrationInstruction', 'string', false, TFhirString, FAdministrationInstruction.Link));{2}
end;

function TFhirNutritionOrderEnteralFormula.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'baseFormulaType') then
  begin
    BaseFormulaType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'baseFormulaProductName') then
  begin
    BaseFormulaProductNameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'additiveType') then
  begin
    AdditiveType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'additiveProductName') then
  begin
    AdditiveProductNameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'caloricDensity') then
  begin
    CaloricDensity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'routeofAdministration') then
  begin
    RouteofAdministration := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'administration') then
  begin
    AdministrationList.add(propValue as TFhirNutritionOrderEnteralFormulaAdministration){2a};
    result := propValue;
  end
  else if (propName = 'maxVolumeToDeliver') then
  begin
    MaxVolumeToDeliver := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'administrationInstruction') then
  begin
    AdministrationInstructionElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionOrderEnteralFormula.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'administration') then AdministrationList.insertItem(index, propValue as TFhirNutritionOrderEnteralFormulaAdministration){2a}
  else inherited;
end;

function TFhirNutritionOrderEnteralFormula.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'baseFormulaType') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'baseFormulaProductName') then result := TFhirString.create() {5b}
  else if (propName = 'additiveType') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'additiveProductName') then result := TFhirString.create() {5b}
  else if (propName = 'caloricDensity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'routeofAdministration') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'administration') then result := AdministrationList.new(){2}
  else if (propName = 'maxVolumeToDeliver') then result := TFhirQuantity.create(){4b}
  else if (propName = 'administrationInstruction') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionOrderEnteralFormula.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'baseFormulaType') then result := 'CodeableConcept'
  else if (propName = 'baseFormulaProductName') then result := 'string'
  else if (propName = 'additiveType') then result := 'CodeableConcept'
  else if (propName = 'additiveProductName') then result := 'string'
  else if (propName = 'caloricDensity') then result := 'Quantity'
  else if (propName = 'routeofAdministration') then result := 'CodeableConcept'
  else if (propName = 'administration') then result := ''
  else if (propName = 'maxVolumeToDeliver') then result := 'Quantity'
  else if (propName = 'administrationInstruction') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionOrderEnteralFormula.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'baseFormulaType') then BaseFormulaTypeElement := nil
  else if (propName = 'baseFormulaProductName') then BaseFormulaProductNameElement := nil
  else if (propName = 'additiveType') then AdditiveTypeElement := nil
  else if (propName = 'additiveProductName') then AdditiveProductNameElement := nil
  else if (propName = 'caloricDensity') then CaloricDensityElement := nil
  else if (propName = 'routeofAdministration') then RouteofAdministrationElement := nil
  else if (propName = 'administration') then deletePropertyValue('administration', AdministrationList, value) {2}
  else if (propName = 'maxVolumeToDeliver') then MaxVolumeToDeliverElement := nil
  else if (propName = 'administrationInstruction') then AdministrationInstructionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionOrderEnteralFormula.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'baseFormulaType') then BaseFormulaTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'baseFormulaProductName') then BaseFormulaProductNameElement := asString(new){5b}
  else if (propName = 'additiveType') then AdditiveTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'additiveProductName') then AdditiveProductNameElement := asString(new){5b}
  else if (propName = 'caloricDensity') then CaloricDensityElement := new as TFhirQuantity{4}
  else if (propName = 'routeofAdministration') then RouteofAdministrationElement := new as TFhirCodeableConcept{4}
  else if (propName = 'administration') then replacePropertyValue('administration', AdministrationList, existing, new) {2}
  else if (propName = 'maxVolumeToDeliver') then MaxVolumeToDeliverElement := new as TFhirQuantity{4}
  else if (propName = 'administrationInstruction') then AdministrationInstructionElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionOrderEnteralFormula.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'administration') then AdministrationList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionOrderEnteralFormula.fhirType : string;
begin
  result := 'enteralFormula';
end;

function TFhirNutritionOrderEnteralFormula.Link : TFhirNutritionOrderEnteralFormula;
begin
  result := TFhirNutritionOrderEnteralFormula(inherited Link);
end;

function TFhirNutritionOrderEnteralFormula.Clone : TFhirNutritionOrderEnteralFormula;
begin
  result := TFhirNutritionOrderEnteralFormula(inherited Clone);
end;

function TFhirNutritionOrderEnteralFormula.equals(other : TObject) : boolean;
var
  o : TFhirNutritionOrderEnteralFormula;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionOrderEnteralFormula)) then
    result := false
  else
  begin
    o := TFhirNutritionOrderEnteralFormula(other);
    result := compareDeep(baseFormulaTypeElement, o.baseFormulaTypeElement, true) and
      compareDeep(baseFormulaProductNameElement, o.baseFormulaProductNameElement, true) and
      compareDeep(additiveTypeElement, o.additiveTypeElement, true) and compareDeep(additiveProductNameElement, o.additiveProductNameElement, true) and
      compareDeep(caloricDensityElement, o.caloricDensityElement, true) and compareDeep(routeofAdministrationElement, o.routeofAdministrationElement, true) and
      compareDeep(administrationList, o.administrationList, true) and compareDeep(maxVolumeToDeliverElement, o.maxVolumeToDeliverElement, true) and
      compareDeep(administrationInstructionElement, o.administrationInstructionElement, true);
  end;
end;

function TFhirNutritionOrderEnteralFormula.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FBaseFormulaType) and isEmptyProp(FBaseFormulaProductName) and isEmptyProp(FAdditiveType) and isEmptyProp(FAdditiveProductName) and isEmptyProp(FCaloricDensity) and isEmptyProp(FRouteofAdministration) and isEmptyProp(FadministrationList) and isEmptyProp(FMaxVolumeToDeliver) and isEmptyProp(FAdministrationInstruction);
end;

procedure TFhirNutritionOrderEnteralFormula.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('baseFormulaType');
  fields.add('baseFormulaProductName');
  fields.add('additiveType');
  fields.add('additiveProductName');
  fields.add('caloricDensity');
  fields.add('routeofAdministration');
  fields.add('administration');
  fields.add('maxVolumeToDeliver');
  fields.add('administrationInstruction');
end;

{ TFhirNutritionOrderEnteralFormula }

Procedure TFhirNutritionOrderEnteralFormula.SetBaseFormulaType(value : TFhirCodeableConcept);
begin
  FBaseFormulaType.free;
  FBaseFormulaType := value;
end;

Procedure TFhirNutritionOrderEnteralFormula.SetBaseFormulaProductName(value : TFhirString);
begin
  FBaseFormulaProductName.free;
  FBaseFormulaProductName := value;
end;

Function TFhirNutritionOrderEnteralFormula.GetBaseFormulaProductNameST : String;
begin
  if FBaseFormulaProductName = nil then
    result := ''
  else
    result := FBaseFormulaProductName.value;
end;

Procedure TFhirNutritionOrderEnteralFormula.SetBaseFormulaProductNameST(value : String);
begin
  if value <> '' then
  begin
    if FBaseFormulaProductName = nil then
      FBaseFormulaProductName := TFhirString.create;
    FBaseFormulaProductName.value := value
  end
  else if FBaseFormulaProductName <> nil then
    FBaseFormulaProductName.value := '';
end;

Procedure TFhirNutritionOrderEnteralFormula.SetAdditiveType(value : TFhirCodeableConcept);
begin
  FAdditiveType.free;
  FAdditiveType := value;
end;

Procedure TFhirNutritionOrderEnteralFormula.SetAdditiveProductName(value : TFhirString);
begin
  FAdditiveProductName.free;
  FAdditiveProductName := value;
end;

Function TFhirNutritionOrderEnteralFormula.GetAdditiveProductNameST : String;
begin
  if FAdditiveProductName = nil then
    result := ''
  else
    result := FAdditiveProductName.value;
end;

Procedure TFhirNutritionOrderEnteralFormula.SetAdditiveProductNameST(value : String);
begin
  if value <> '' then
  begin
    if FAdditiveProductName = nil then
      FAdditiveProductName := TFhirString.create;
    FAdditiveProductName.value := value
  end
  else if FAdditiveProductName <> nil then
    FAdditiveProductName.value := '';
end;

Procedure TFhirNutritionOrderEnteralFormula.SetCaloricDensity(value : TFhirQuantity);
begin
  FCaloricDensity.free;
  FCaloricDensity := value;
end;

Procedure TFhirNutritionOrderEnteralFormula.SetRouteofAdministration(value : TFhirCodeableConcept);
begin
  FRouteofAdministration.free;
  FRouteofAdministration := value;
end;

Function TFhirNutritionOrderEnteralFormula.GetAdministrationList : TFhirNutritionOrderEnteralFormulaAdministrationList;
begin
  if FAdministrationList = nil then
    FAdministrationList := TFhirNutritionOrderEnteralFormulaAdministrationList.Create;
  result := FAdministrationList;
end;

Function TFhirNutritionOrderEnteralFormula.GetHasAdministrationList : boolean;
begin
  result := (FAdministrationList <> nil) and (FAdministrationList.count > 0);
end;

Procedure TFhirNutritionOrderEnteralFormula.SetMaxVolumeToDeliver(value : TFhirQuantity);
begin
  FMaxVolumeToDeliver.free;
  FMaxVolumeToDeliver := value;
end;

Procedure TFhirNutritionOrderEnteralFormula.SetAdministrationInstruction(value : TFhirString);
begin
  FAdministrationInstruction.free;
  FAdministrationInstruction := value;
end;

Function TFhirNutritionOrderEnteralFormula.GetAdministrationInstructionST : String;
begin
  if FAdministrationInstruction = nil then
    result := ''
  else
    result := FAdministrationInstruction.value;
end;

Procedure TFhirNutritionOrderEnteralFormula.SetAdministrationInstructionST(value : String);
begin
  if value <> '' then
  begin
    if FAdministrationInstruction = nil then
      FAdministrationInstruction := TFhirString.create;
    FAdministrationInstruction.value := value
  end
  else if FAdministrationInstruction <> nil then
    FAdministrationInstruction.value := '';
end;

function TFhirNutritionOrderEnteralFormula.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FBaseFormulaType.sizeInBytes);
  inc(result, FBaseFormulaProductName.sizeInBytes);
  inc(result, FAdditiveType.sizeInBytes);
  inc(result, FAdditiveProductName.sizeInBytes);
  inc(result, FCaloricDensity.sizeInBytes);
  inc(result, FRouteofAdministration.sizeInBytes);
  inc(result, FadministrationList.sizeInBytes);
  inc(result, FMaxVolumeToDeliver.sizeInBytes);
  inc(result, FAdministrationInstruction.sizeInBytes);
end;

{ TFhirNutritionOrderEnteralFormulaListEnumerator }

Constructor TFhirNutritionOrderEnteralFormulaListEnumerator.Create(list : TFhirNutritionOrderEnteralFormulaList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionOrderEnteralFormulaListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionOrderEnteralFormulaListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionOrderEnteralFormulaListEnumerator.GetCurrent : TFhirNutritionOrderEnteralFormula;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionOrderEnteralFormulaListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirNutritionOrderEnteralFormulaList }
procedure TFhirNutritionOrderEnteralFormulaList.AddItem(value: TFhirNutritionOrderEnteralFormula);
begin
  assert(value.ClassName = 'TFhirNutritionOrderEnteralFormula', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionOrderEnteralFormula');
  add(value);
end;

function TFhirNutritionOrderEnteralFormulaList.Append: TFhirNutritionOrderEnteralFormula;
begin
  result := TFhirNutritionOrderEnteralFormula.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderEnteralFormulaList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionOrderEnteralFormulaList.GetEnumerator : TFhirNutritionOrderEnteralFormulaListEnumerator;
begin
  result := TFhirNutritionOrderEnteralFormulaListEnumerator.Create(self.link);
end;

function TFhirNutritionOrderEnteralFormulaList.Clone: TFhirNutritionOrderEnteralFormulaList;
begin
  result := TFhirNutritionOrderEnteralFormulaList(inherited Clone);
end;

function TFhirNutritionOrderEnteralFormulaList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionOrderEnteralFormulaList.GetItemN(index: Integer): TFhirNutritionOrderEnteralFormula;
begin
  result := TFhirNutritionOrderEnteralFormula(ObjectByIndex[index]);
end;

function TFhirNutritionOrderEnteralFormulaList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionOrderEnteralFormula;
end;
function TFhirNutritionOrderEnteralFormulaList.IndexOf(value: TFhirNutritionOrderEnteralFormula): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionOrderEnteralFormulaList.Insert(index: Integer): TFhirNutritionOrderEnteralFormula;
begin
  result := TFhirNutritionOrderEnteralFormula.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderEnteralFormulaList.InsertItem(index: Integer; value: TFhirNutritionOrderEnteralFormula);
begin
  assert(value is TFhirNutritionOrderEnteralFormula);
  Inherited Insert(index, value);
end;

function TFhirNutritionOrderEnteralFormulaList.Item(index: Integer): TFhirNutritionOrderEnteralFormula;
begin
  result := TFhirNutritionOrderEnteralFormula(ObjectByIndex[index]);
end;

function TFhirNutritionOrderEnteralFormulaList.Link: TFhirNutritionOrderEnteralFormulaList;
begin
  result := TFhirNutritionOrderEnteralFormulaList(inherited Link);
end;

procedure TFhirNutritionOrderEnteralFormulaList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionOrderEnteralFormulaList.SetItemByIndex(index: Integer; value: TFhirNutritionOrderEnteralFormula);
begin
  assert(value is TFhirNutritionOrderEnteralFormula);
  FhirNutritionOrderEnteralFormulas[index] := value;
end;

procedure TFhirNutritionOrderEnteralFormulaList.SetItemN(index: Integer; value: TFhirNutritionOrderEnteralFormula);
begin
  assert(value is TFhirNutritionOrderEnteralFormula);
  ObjectByIndex[index] := value;
end;

{ TFhirNutritionOrderEnteralFormulaAdministration }

constructor TFhirNutritionOrderEnteralFormulaAdministration.Create;
begin
  inherited;
end;

destructor TFhirNutritionOrderEnteralFormulaAdministration.Destroy;
begin
  FSchedule.free;
  FQuantity.free;
  FRate.free;
  inherited;
end;

procedure TFhirNutritionOrderEnteralFormulaAdministration.Assign(oSource : TFslObject);
begin
  inherited;
  schedule := TFhirNutritionOrderEnteralFormulaAdministration(oSource).schedule.Clone;
  quantity := TFhirNutritionOrderEnteralFormulaAdministration(oSource).quantity.Clone;
  rate := TFhirNutritionOrderEnteralFormulaAdministration(oSource).rate.Clone;
end;

procedure TFhirNutritionOrderEnteralFormulaAdministration.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'schedule') Then
     list.add(self.link, 'schedule', FSchedule.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'rate[x]') or (child_name = 'rate') Then
     list.add(self.link, 'rate[x]', FRate.Link);
end;

procedure TFhirNutritionOrderEnteralFormulaAdministration.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'schedule', 'Timing', false, TFhirTiming, FSchedule.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'rate[x]', 'Quantity|Ratio', false, TFhirType, FRate.Link));{2}
end;

function TFhirNutritionOrderEnteralFormulaAdministration.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'schedule') then
  begin
    Schedule := propValue as TFhirTiming{4b};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'rate', ['Quantity', 'Ratio'])) then
  begin
    Rate := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionOrderEnteralFormulaAdministration.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirNutritionOrderEnteralFormulaAdministration.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'schedule') then result := TFhirTiming.create(){4b}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (isMatchingName(propName, 'rate', ['Quantity', 'Ratio'])) then raise EFHIRException.create('Cannot make property Rate'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionOrderEnteralFormulaAdministration.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'schedule') then result := 'Timing'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'rate[x]') then result := 'Quantity|Ratio'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionOrderEnteralFormulaAdministration.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'schedule') then ScheduleElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (isMatchingName(propName, 'rate', ['Quantity', 'Ratio'])) then RateElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionOrderEnteralFormulaAdministration.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'schedule') then ScheduleElement := new as TFhirTiming{4}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (isMatchingName(propName, 'rate', ['Quantity', 'Ratio'])) then RateElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionOrderEnteralFormulaAdministration.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionOrderEnteralFormulaAdministration.fhirType : string;
begin
  result := 'administration';
end;

function TFhirNutritionOrderEnteralFormulaAdministration.Link : TFhirNutritionOrderEnteralFormulaAdministration;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministration(inherited Link);
end;

function TFhirNutritionOrderEnteralFormulaAdministration.Clone : TFhirNutritionOrderEnteralFormulaAdministration;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministration(inherited Clone);
end;

function TFhirNutritionOrderEnteralFormulaAdministration.equals(other : TObject) : boolean;
var
  o : TFhirNutritionOrderEnteralFormulaAdministration;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionOrderEnteralFormulaAdministration)) then
    result := false
  else
  begin
    o := TFhirNutritionOrderEnteralFormulaAdministration(other);
    result := compareDeep(scheduleElement, o.scheduleElement, true) and compareDeep(quantityElement, o.quantityElement, true) and
      compareDeep(rateElement, o.rateElement, true);
  end;
end;

function TFhirNutritionOrderEnteralFormulaAdministration.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSchedule) and isEmptyProp(FQuantity) and isEmptyProp(FRate);
end;

procedure TFhirNutritionOrderEnteralFormulaAdministration.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('schedule');
  fields.add('quantity');
  fields.add('rate[x]');
end;

{ TFhirNutritionOrderEnteralFormulaAdministration }

Procedure TFhirNutritionOrderEnteralFormulaAdministration.SetSchedule(value : TFhirTiming);
begin
  FSchedule.free;
  FSchedule := value;
end;

Procedure TFhirNutritionOrderEnteralFormulaAdministration.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirNutritionOrderEnteralFormulaAdministration.SetRate(value : TFhirType);
begin
  FRate.free;
  FRate := value;
end;

function TFhirNutritionOrderEnteralFormulaAdministration.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSchedule.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FRate.sizeInBytes);
end;

{ TFhirNutritionOrderEnteralFormulaAdministrationListEnumerator }

Constructor TFhirNutritionOrderEnteralFormulaAdministrationListEnumerator.Create(list : TFhirNutritionOrderEnteralFormulaAdministrationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionOrderEnteralFormulaAdministrationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionOrderEnteralFormulaAdministrationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionOrderEnteralFormulaAdministrationListEnumerator.GetCurrent : TFhirNutritionOrderEnteralFormulaAdministration;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionOrderEnteralFormulaAdministrationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirNutritionOrderEnteralFormulaAdministrationList }
procedure TFhirNutritionOrderEnteralFormulaAdministrationList.AddItem(value: TFhirNutritionOrderEnteralFormulaAdministration);
begin
  assert(value.ClassName = 'TFhirNutritionOrderEnteralFormulaAdministration', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionOrderEnteralFormulaAdministration');
  add(value);
end;

function TFhirNutritionOrderEnteralFormulaAdministrationList.Append: TFhirNutritionOrderEnteralFormulaAdministration;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministration.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderEnteralFormulaAdministrationList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionOrderEnteralFormulaAdministrationList.GetEnumerator : TFhirNutritionOrderEnteralFormulaAdministrationListEnumerator;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministrationListEnumerator.Create(self.link);
end;

function TFhirNutritionOrderEnteralFormulaAdministrationList.Clone: TFhirNutritionOrderEnteralFormulaAdministrationList;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministrationList(inherited Clone);
end;

function TFhirNutritionOrderEnteralFormulaAdministrationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionOrderEnteralFormulaAdministrationList.GetItemN(index: Integer): TFhirNutritionOrderEnteralFormulaAdministration;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministration(ObjectByIndex[index]);
end;

function TFhirNutritionOrderEnteralFormulaAdministrationList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministration;
end;
function TFhirNutritionOrderEnteralFormulaAdministrationList.IndexOf(value: TFhirNutritionOrderEnteralFormulaAdministration): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionOrderEnteralFormulaAdministrationList.Insert(index: Integer): TFhirNutritionOrderEnteralFormulaAdministration;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministration.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderEnteralFormulaAdministrationList.InsertItem(index: Integer; value: TFhirNutritionOrderEnteralFormulaAdministration);
begin
  assert(value is TFhirNutritionOrderEnteralFormulaAdministration);
  Inherited Insert(index, value);
end;

function TFhirNutritionOrderEnteralFormulaAdministrationList.Item(index: Integer): TFhirNutritionOrderEnteralFormulaAdministration;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministration(ObjectByIndex[index]);
end;

function TFhirNutritionOrderEnteralFormulaAdministrationList.Link: TFhirNutritionOrderEnteralFormulaAdministrationList;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministrationList(inherited Link);
end;

procedure TFhirNutritionOrderEnteralFormulaAdministrationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionOrderEnteralFormulaAdministrationList.SetItemByIndex(index: Integer; value: TFhirNutritionOrderEnteralFormulaAdministration);
begin
  assert(value is TFhirNutritionOrderEnteralFormulaAdministration);
  FhirNutritionOrderEnteralFormulaAdministrations[index] := value;
end;

procedure TFhirNutritionOrderEnteralFormulaAdministrationList.SetItemN(index: Integer; value: TFhirNutritionOrderEnteralFormulaAdministration);
begin
  assert(value is TFhirNutritionOrderEnteralFormulaAdministration);
  ObjectByIndex[index] := value;
end;

{ TFhirNutritionOrder }

constructor TFhirNutritionOrder.Create;
begin
  inherited;
end;

destructor TFhirNutritionOrder.Destroy;
begin
  FPatient.free;
  FOrderer.free;
  FIdentifierList.Free;
  FEncounter.free;
  FDateTime.free;
  FStatus.free;
  FAllergyIntoleranceList.Free;
  FFoodPreferenceModifierList.Free;
  FExcludeFoodModifierList.Free;
  FOralDiet.free;
  FSupplementList.Free;
  FEnteralFormula.free;
  inherited;
end;

function TFhirNutritionOrder.GetResourceType : TFhirResourceType;
begin
  result := frtNutritionOrder;
end;

procedure TFhirNutritionOrder.Assign(oSource : TFslObject);
begin
  inherited;
  patient := TFhirNutritionOrder(oSource).patient.Clone;
  orderer := TFhirNutritionOrder(oSource).orderer.Clone;
  if (TFhirNutritionOrder(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirNutritionOrder(oSource).FIdentifierList);
  end;
  encounter := TFhirNutritionOrder(oSource).encounter.Clone;
  dateTimeElement := TFhirNutritionOrder(oSource).dateTimeElement.Clone;
  FStatus := TFhirNutritionOrder(oSource).FStatus.Link;
  if (TFhirNutritionOrder(oSource).FAllergyIntoleranceList = nil) then
  begin
    FAllergyIntoleranceList.free;
    FAllergyIntoleranceList := nil;
  end
  else
  begin
    if FAllergyIntoleranceList = nil then
      FAllergyIntoleranceList := TFhirReferenceList{TFhirAllergyIntolerance}.Create;
    FAllergyIntoleranceList.Assign(TFhirNutritionOrder(oSource).FAllergyIntoleranceList);
  end;
  if (TFhirNutritionOrder(oSource).FFoodPreferenceModifierList = nil) then
  begin
    FFoodPreferenceModifierList.free;
    FFoodPreferenceModifierList := nil;
  end
  else
  begin
    if FFoodPreferenceModifierList = nil then
      FFoodPreferenceModifierList := TFhirCodeableConceptList.Create;
    FFoodPreferenceModifierList.Assign(TFhirNutritionOrder(oSource).FFoodPreferenceModifierList);
  end;
  if (TFhirNutritionOrder(oSource).FExcludeFoodModifierList = nil) then
  begin
    FExcludeFoodModifierList.free;
    FExcludeFoodModifierList := nil;
  end
  else
  begin
    if FExcludeFoodModifierList = nil then
      FExcludeFoodModifierList := TFhirCodeableConceptList.Create;
    FExcludeFoodModifierList.Assign(TFhirNutritionOrder(oSource).FExcludeFoodModifierList);
  end;
  oralDiet := TFhirNutritionOrder(oSource).oralDiet.Clone;
  if (TFhirNutritionOrder(oSource).FSupplementList = nil) then
  begin
    FSupplementList.free;
    FSupplementList := nil;
  end
  else
  begin
    if FSupplementList = nil then
      FSupplementList := TFhirNutritionOrderSupplementList.Create;
    FSupplementList.Assign(TFhirNutritionOrder(oSource).FSupplementList);
  end;
  enteralFormula := TFhirNutritionOrder(oSource).enteralFormula.Clone;
end;

procedure TFhirNutritionOrder.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'orderer') Then
     list.add(self.link, 'orderer', FOrderer.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'dateTime') Then
     list.add(self.link, 'dateTime', FDateTime.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'allergyIntolerance') Then
    list.addAll(self, 'allergyIntolerance', FAllergyIntoleranceList);
  if (child_name = 'foodPreferenceModifier') Then
    list.addAll(self, 'foodPreferenceModifier', FFoodPreferenceModifierList);
  if (child_name = 'excludeFoodModifier') Then
    list.addAll(self, 'excludeFoodModifier', FExcludeFoodModifierList);
  if (child_name = 'oralDiet') Then
     list.add(self.link, 'oralDiet', FOralDiet.Link);
  if (child_name = 'supplement') Then
    list.addAll(self, 'supplement', FSupplementList);
  if (child_name = 'enteralFormula') Then
     list.add(self.link, 'enteralFormula', FEnteralFormula.Link);
end;

procedure TFhirNutritionOrder.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'orderer', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FOrderer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference(Encounter)', false, TFhirReference{TFhirEncounter}, FEncounter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dateTime', 'dateTime', false, TFhirDateTime, FDateTime.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'allergyIntolerance', 'Reference(AllergyIntolerance)', true, TFhirReference{TFhirAllergyIntolerance}, FAllergyIntoleranceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'foodPreferenceModifier', 'CodeableConcept', true, TFhirCodeableConcept, FFoodPreferenceModifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'excludeFoodModifier', 'CodeableConcept', true, TFhirCodeableConcept, FExcludeFoodModifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'oralDiet', '', false, TFhirNutritionOrderOralDiet, FOralDiet.Link));{2}
  oList.add(TFHIRProperty.create(self, 'supplement', '', true, TFhirNutritionOrderSupplement, FSupplementList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'enteralFormula', '', false, TFhirNutritionOrderEnteralFormula, FEnteralFormula.Link));{2}
end;

function TFhirNutritionOrder.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'orderer') then
  begin
    Orderer := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference{TFhirEncounter}{4b};
    result := propValue;
  end
  else if (propName = 'dateTime') then
  begin
    DateTimeElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirNutritionOrderStatusEnum, CODES_TFhirNutritionOrderStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'allergyIntolerance') then
  begin
    AllergyIntoleranceList.add(propValue as TFhirReference{TFhirAllergyIntolerance}){2a};
    result := propValue;
  end
  else if (propName = 'foodPreferenceModifier') then
  begin
    FoodPreferenceModifierList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'excludeFoodModifier') then
  begin
    ExcludeFoodModifierList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'oralDiet') then
  begin
    OralDiet := propValue as TFhirNutritionOrderOralDiet{4b};
    result := propValue;
  end
  else if (propName = 'supplement') then
  begin
    SupplementList.add(propValue as TFhirNutritionOrderSupplement){2a};
    result := propValue;
  end
  else if (propName = 'enteralFormula') then
  begin
    EnteralFormula := propValue as TFhirNutritionOrderEnteralFormula{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirNutritionOrder.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'allergyIntolerance') then AllergyIntoleranceList.insertItem(index, propValue as TFhirReference{TFhirAllergyIntolerance}){2a}
  else if (propName = 'foodPreferenceModifier') then FoodPreferenceModifierList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'excludeFoodModifier') then ExcludeFoodModifierList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'supplement') then SupplementList.insertItem(index, propValue as TFhirNutritionOrderSupplement){2a}
  else inherited;
end;

function TFhirNutritionOrder.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'orderer') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'encounter') then result := TFhirReference{TFhirEncounter}.create(){4b}
  else if (propName = 'dateTime') then result := TFhirDateTime.create() {5b}
  else if (propName = 'allergyIntolerance') then result := AllergyIntoleranceList.new(){2}
  else if (propName = 'foodPreferenceModifier') then result := FoodPreferenceModifierList.new(){2}
  else if (propName = 'excludeFoodModifier') then result := ExcludeFoodModifierList.new(){2}
  else if (propName = 'oralDiet') then result := TFhirNutritionOrderOralDiet.create(){4b}
  else if (propName = 'supplement') then result := SupplementList.new(){2}
  else if (propName = 'enteralFormula') then result := TFhirNutritionOrderEnteralFormula.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionOrder.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'patient') then result := 'Reference'
  else if (propName = 'orderer') then result := 'Reference'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'dateTime') then result := 'dateTime'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'allergyIntolerance') then result := 'Reference'
  else if (propName = 'foodPreferenceModifier') then result := 'CodeableConcept'
  else if (propName = 'excludeFoodModifier') then result := 'CodeableConcept'
  else if (propName = 'oralDiet') then result := ''
  else if (propName = 'supplement') then result := ''
  else if (propName = 'enteralFormula') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionOrder.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'patient') then PatientElement := nil
  else if (propName = 'orderer') then OrdererElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'dateTime') then DateTimeElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'allergyIntolerance') then deletePropertyValue('allergyIntolerance', AllergyIntoleranceList, value) {2}
  else if (propName = 'foodPreferenceModifier') then deletePropertyValue('foodPreferenceModifier', FoodPreferenceModifierList, value) {2}
  else if (propName = 'excludeFoodModifier') then deletePropertyValue('excludeFoodModifier', ExcludeFoodModifierList, value) {2}
  else if (propName = 'oralDiet') then OralDietElement := nil
  else if (propName = 'supplement') then deletePropertyValue('supplement', SupplementList, value) {2}
  else if (propName = 'enteralFormula') then EnteralFormulaElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionOrder.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'orderer') then OrdererElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference{TFhirEncounter}{4}
  else if (propName = 'dateTime') then DateTimeElement := asDateTime(new){5b}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirNutritionOrderStatusEnum, CODES_TFhirNutritionOrderStatusEnum, new){4}
  else if (propName = 'allergyIntolerance') then replacePropertyValue('allergyIntolerance', AllergyIntoleranceList, existing, new) {2}
  else if (propName = 'foodPreferenceModifier') then replacePropertyValue('foodPreferenceModifier', FoodPreferenceModifierList, existing, new) {2}
  else if (propName = 'excludeFoodModifier') then replacePropertyValue('excludeFoodModifier', ExcludeFoodModifierList, existing, new) {2}
  else if (propName = 'oralDiet') then OralDietElement := new as TFhirNutritionOrderOralDiet{4}
  else if (propName = 'supplement') then replacePropertyValue('supplement', SupplementList, existing, new) {2}
  else if (propName = 'enteralFormula') then EnteralFormulaElement := new as TFhirNutritionOrderEnteralFormula{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionOrder.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'allergyIntolerance') then AllergyIntoleranceList.move(source, destination){2a}
  else if (propName = 'foodPreferenceModifier') then FoodPreferenceModifierList.move(source, destination){2a}
  else if (propName = 'excludeFoodModifier') then ExcludeFoodModifierList.move(source, destination){2a}
  else if (propName = 'supplement') then SupplementList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionOrder.fhirType : string;
begin
  result := 'NutritionOrder';
end;

function TFhirNutritionOrder.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPatient) and isEmptyProp(FOrderer) and isEmptyProp(FidentifierList) and isEmptyProp(FEncounter) and isEmptyProp(FDateTime) and isEmptyProp(FStatus) and isEmptyProp(FallergyIntoleranceList) and isEmptyProp(FfoodPreferenceModifierList) and isEmptyProp(FexcludeFoodModifierList) and isEmptyProp(FOralDiet) and isEmptyProp(FsupplementList) and isEmptyProp(FEnteralFormula);
end;

function TFhirNutritionOrder.equals(other : TObject) : boolean;
var
  o : TFhirNutritionOrder;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionOrder)) then
    result := false
  else
  begin
    o := TFhirNutritionOrder(other);
    result := compareDeep(patientElement, o.patientElement, true) and compareDeep(ordererElement, o.ordererElement, true) and
      compareDeep(identifierList, o.identifierList, true) and compareDeep(encounterElement, o.encounterElement, true) and
      compareDeep(dateTimeElement, o.dateTimeElement, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(allergyIntoleranceList, o.allergyIntoleranceList, true) and compareDeep(foodPreferenceModifierList, o.foodPreferenceModifierList, true) and
      compareDeep(excludeFoodModifierList, o.excludeFoodModifierList, true) and compareDeep(oralDietElement, o.oralDietElement, true) and
      compareDeep(supplementList, o.supplementList, true) and compareDeep(enteralFormulaElement, o.enteralFormulaElement, true);
  end;
end;

function TFhirNutritionOrder.Link : TFhirNutritionOrder;
begin
  result := TFhirNutritionOrder(inherited Link);
end;

function TFhirNutritionOrder.Clone : TFhirNutritionOrder;
begin
  result := TFhirNutritionOrder(inherited Clone);
end;

procedure TFhirNutritionOrder.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('patient');
  fields.add('orderer');
  fields.add('identifier');
  fields.add('encounter');
  fields.add('dateTime');
  fields.add('status');
  fields.add('allergyIntolerance');
  fields.add('foodPreferenceModifier');
  fields.add('excludeFoodModifier');
  fields.add('oralDiet');
  fields.add('supplement');
  fields.add('enteralFormula');
end;

{ TFhirNutritionOrder }

Procedure TFhirNutritionOrder.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Procedure TFhirNutritionOrder.SetOrderer(value : TFhirReference{TFhirPractitioner});
begin
  FOrderer.free;
  FOrderer := value;
end;

Function TFhirNutritionOrder.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirNutritionOrder.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirNutritionOrder.SetEncounter(value : TFhirReference{TFhirEncounter});
begin
  FEncounter.free;
  FEncounter := value;
end;

Procedure TFhirNutritionOrder.SetDateTime(value : TFhirDateTime);
begin
  FDateTime.free;
  FDateTime := value;
end;

Function TFhirNutritionOrder.GetDateTimeST : TFslDateTime;
begin
  if FDateTime = nil then
    result := TFslDateTime.makeNull
  else
    result := FDateTime.value;
end;

Procedure TFhirNutritionOrder.SetDateTimeST(value : TFslDateTime);
begin
  if FDateTime = nil then
    FDateTime := TFhirDateTime.create;
  FDateTime.value := value
end;

Procedure TFhirNutritionOrder.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirNutritionOrder.GetStatusST : TFhirNutritionOrderStatusEnum;
begin
  if FStatus = nil then
    result := TFhirNutritionOrderStatusEnum(0)
  else
    result := TFhirNutritionOrderStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirNutritionOrderStatusEnum, FStatus.value));
end;

Procedure TFhirNutritionOrder.SetStatusST(value : TFhirNutritionOrderStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirNutritionOrderStatusEnum[value], CODES_TFhirNutritionOrderStatusEnum[value]);
end;

Function TFhirNutritionOrder.GetAllergyIntoleranceList : TFhirReferenceList{TFhirAllergyIntolerance};
begin
  if FAllergyIntoleranceList = nil then
    FAllergyIntoleranceList := TFhirReferenceList{TFhirAllergyIntolerance}.Create;
  result := FAllergyIntoleranceList;
end;

Function TFhirNutritionOrder.GetHasAllergyIntoleranceList : boolean;
begin
  result := (FAllergyIntoleranceList <> nil) and (FAllergyIntoleranceList.count > 0);
end;

Function TFhirNutritionOrder.GetFoodPreferenceModifierList : TFhirCodeableConceptList;
begin
  if FFoodPreferenceModifierList = nil then
    FFoodPreferenceModifierList := TFhirCodeableConceptList.Create;
  result := FFoodPreferenceModifierList;
end;

Function TFhirNutritionOrder.GetHasFoodPreferenceModifierList : boolean;
begin
  result := (FFoodPreferenceModifierList <> nil) and (FFoodPreferenceModifierList.count > 0);
end;

Function TFhirNutritionOrder.GetExcludeFoodModifierList : TFhirCodeableConceptList;
begin
  if FExcludeFoodModifierList = nil then
    FExcludeFoodModifierList := TFhirCodeableConceptList.Create;
  result := FExcludeFoodModifierList;
end;

Function TFhirNutritionOrder.GetHasExcludeFoodModifierList : boolean;
begin
  result := (FExcludeFoodModifierList <> nil) and (FExcludeFoodModifierList.count > 0);
end;

Procedure TFhirNutritionOrder.SetOralDiet(value : TFhirNutritionOrderOralDiet);
begin
  FOralDiet.free;
  FOralDiet := value;
end;

Function TFhirNutritionOrder.GetSupplementList : TFhirNutritionOrderSupplementList;
begin
  if FSupplementList = nil then
    FSupplementList := TFhirNutritionOrderSupplementList.Create;
  result := FSupplementList;
end;

Function TFhirNutritionOrder.GetHasSupplementList : boolean;
begin
  result := (FSupplementList <> nil) and (FSupplementList.count > 0);
end;

Procedure TFhirNutritionOrder.SetEnteralFormula(value : TFhirNutritionOrderEnteralFormula);
begin
  FEnteralFormula.free;
  FEnteralFormula := value;
end;

function TFhirNutritionOrder.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FPatient.sizeInBytes);
  inc(result, FOrderer.sizeInBytes);
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FDateTime.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FallergyIntoleranceList.sizeInBytes);
  inc(result, FfoodPreferenceModifierList.sizeInBytes);
  inc(result, FexcludeFoodModifierList.sizeInBytes);
  inc(result, FOralDiet.sizeInBytes);
  inc(result, FsupplementList.sizeInBytes);
  inc(result, FEnteralFormula.sizeInBytes);
end;

{ TFhirNutritionOrderListEnumerator }

Constructor TFhirNutritionOrderListEnumerator.Create(list : TFhirNutritionOrderList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionOrderListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionOrderListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionOrderListEnumerator.GetCurrent : TFhirNutritionOrder;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionOrderListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirNutritionOrderList }
procedure TFhirNutritionOrderList.AddItem(value: TFhirNutritionOrder);
begin
  assert(value.ClassName = 'TFhirNutritionOrder', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionOrder');
  add(value);
end;

function TFhirNutritionOrderList.Append: TFhirNutritionOrder;
begin
  result := TFhirNutritionOrder.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionOrderList.GetEnumerator : TFhirNutritionOrderListEnumerator;
begin
  result := TFhirNutritionOrderListEnumerator.Create(self.link);
end;

function TFhirNutritionOrderList.Clone: TFhirNutritionOrderList;
begin
  result := TFhirNutritionOrderList(inherited Clone);
end;

function TFhirNutritionOrderList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionOrderList.GetItemN(index: Integer): TFhirNutritionOrder;
begin
  result := TFhirNutritionOrder(ObjectByIndex[index]);
end;

function TFhirNutritionOrderList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionOrder;
end;
function TFhirNutritionOrderList.IndexOf(value: TFhirNutritionOrder): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionOrderList.Insert(index: Integer): TFhirNutritionOrder;
begin
  result := TFhirNutritionOrder.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderList.InsertItem(index: Integer; value: TFhirNutritionOrder);
begin
  assert(value is TFhirNutritionOrder);
  Inherited Insert(index, value);
end;

function TFhirNutritionOrderList.Item(index: Integer): TFhirNutritionOrder;
begin
  result := TFhirNutritionOrder(ObjectByIndex[index]);
end;

function TFhirNutritionOrderList.Link: TFhirNutritionOrderList;
begin
  result := TFhirNutritionOrderList(inherited Link);
end;

procedure TFhirNutritionOrderList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionOrderList.SetItemByIndex(index: Integer; value: TFhirNutritionOrder);
begin
  assert(value is TFhirNutritionOrder);
  FhirNutritionOrders[index] := value;
end;

procedure TFhirNutritionOrderList.SetItemN(index: Integer; value: TFhirNutritionOrder);
begin
  assert(value is TFhirNutritionOrder);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_NUTRITIONORDER}

{$IFDEF FHIR_OBSERVATION}

{ TFhirObservationReferenceRange }

constructor TFhirObservationReferenceRange.Create;
begin
  inherited;
end;

destructor TFhirObservationReferenceRange.Destroy;
begin
  FLow.free;
  FHigh.free;
  FMeaning.free;
  FAge.free;
  FText.free;
  inherited;
end;

procedure TFhirObservationReferenceRange.Assign(oSource : TFslObject);
begin
  inherited;
  low := TFhirObservationReferenceRange(oSource).low.Clone;
  high := TFhirObservationReferenceRange(oSource).high.Clone;
  meaning := TFhirObservationReferenceRange(oSource).meaning.Clone;
  age := TFhirObservationReferenceRange(oSource).age.Clone;
  textElement := TFhirObservationReferenceRange(oSource).textElement.Clone;
end;

procedure TFhirObservationReferenceRange.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'low') Then
     list.add(self.link, 'low', FLow.Link);
  if (child_name = 'high') Then
     list.add(self.link, 'high', FHigh.Link);
  if (child_name = 'meaning') Then
     list.add(self.link, 'meaning', FMeaning.Link);
  if (child_name = 'age') Then
     list.add(self.link, 'age', FAge.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
end;

procedure TFhirObservationReferenceRange.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'low', 'Quantity', false, TFhirQuantity, FLow.Link));{2}
  oList.add(TFHIRProperty.create(self, 'high', 'Quantity', false, TFhirQuantity, FHigh.Link));{2}
  oList.add(TFHIRProperty.create(self, 'meaning', 'CodeableConcept', false, TFhirCodeableConcept, FMeaning.Link));{2}
  oList.add(TFHIRProperty.create(self, 'age', 'Range', false, TFhirRange, FAge.Link));{2}
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));{2}
end;

function TFhirObservationReferenceRange.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'low') then
  begin
    Low := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'high') then
  begin
    High := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'meaning') then
  begin
    Meaning := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'age') then
  begin
    Age := propValue as TFhirRange{4b};
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirObservationReferenceRange.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirObservationReferenceRange.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'low') then result := TFhirQuantity.create(){4b}
  else if (propName = 'high') then result := TFhirQuantity.create(){4b}
  else if (propName = 'meaning') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'age') then result := TFhirRange.create(){4b}
  else if (propName = 'text') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirObservationReferenceRange.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'low') then result := 'Quantity'
  else if (propName = 'high') then result := 'Quantity'
  else if (propName = 'meaning') then result := 'CodeableConcept'
  else if (propName = 'age') then result := 'Range'
  else if (propName = 'text') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirObservationReferenceRange.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'low') then LowElement := nil
  else if (propName = 'high') then HighElement := nil
  else if (propName = 'meaning') then MeaningElement := nil
  else if (propName = 'age') then AgeElement := nil
  else if (propName = 'text') then TextElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirObservationReferenceRange.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'low') then LowElement := new as TFhirQuantity{4}
  else if (propName = 'high') then HighElement := new as TFhirQuantity{4}
  else if (propName = 'meaning') then MeaningElement := new as TFhirCodeableConcept{4}
  else if (propName = 'age') then AgeElement := new as TFhirRange{4}
  else if (propName = 'text') then TextElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirObservationReferenceRange.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirObservationReferenceRange.fhirType : string;
begin
  result := 'referenceRange';
end;

function TFhirObservationReferenceRange.Link : TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange(inherited Link);
end;

function TFhirObservationReferenceRange.Clone : TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange(inherited Clone);
end;

function TFhirObservationReferenceRange.equals(other : TObject) : boolean;
var
  o : TFhirObservationReferenceRange;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirObservationReferenceRange)) then
    result := false
  else
  begin
    o := TFhirObservationReferenceRange(other);
    result := compareDeep(lowElement, o.lowElement, true) and compareDeep(highElement, o.highElement, true) and
      compareDeep(meaningElement, o.meaningElement, true) and compareDeep(ageElement, o.ageElement, true) and
      compareDeep(textElement, o.textElement, true);
  end;
end;

function TFhirObservationReferenceRange.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLow) and isEmptyProp(FHigh) and isEmptyProp(FMeaning) and isEmptyProp(FAge) and isEmptyProp(FText);
end;

procedure TFhirObservationReferenceRange.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('low');
  fields.add('high');
  fields.add('meaning');
  fields.add('age');
  fields.add('text');
end;

{ TFhirObservationReferenceRange }

Procedure TFhirObservationReferenceRange.SetLow(value : TFhirQuantity);
begin
  FLow.free;
  FLow := value;
end;

Procedure TFhirObservationReferenceRange.SetHigh(value : TFhirQuantity);
begin
  FHigh.free;
  FHigh := value;
end;

Procedure TFhirObservationReferenceRange.SetMeaning(value : TFhirCodeableConcept);
begin
  FMeaning.free;
  FMeaning := value;
end;

Procedure TFhirObservationReferenceRange.SetAge(value : TFhirRange);
begin
  FAge.free;
  FAge := value;
end;

Procedure TFhirObservationReferenceRange.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

Function TFhirObservationReferenceRange.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

Procedure TFhirObservationReferenceRange.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

function TFhirObservationReferenceRange.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FLow.sizeInBytes);
  inc(result, FHigh.sizeInBytes);
  inc(result, FMeaning.sizeInBytes);
  inc(result, FAge.sizeInBytes);
  inc(result, FText.sizeInBytes);
end;

{ TFhirObservationReferenceRangeListEnumerator }

Constructor TFhirObservationReferenceRangeListEnumerator.Create(list : TFhirObservationReferenceRangeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirObservationReferenceRangeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirObservationReferenceRangeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirObservationReferenceRangeListEnumerator.GetCurrent : TFhirObservationReferenceRange;
begin
  Result := FList[FIndex];
end;

function TFhirObservationReferenceRangeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirObservationReferenceRangeList }
procedure TFhirObservationReferenceRangeList.AddItem(value: TFhirObservationReferenceRange);
begin
  assert(value.ClassName = 'TFhirObservationReferenceRange', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirObservationReferenceRange');
  add(value);
end;

function TFhirObservationReferenceRangeList.Append: TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirObservationReferenceRangeList.ClearItems;
begin
  Clear;
end;

function TFhirObservationReferenceRangeList.GetEnumerator : TFhirObservationReferenceRangeListEnumerator;
begin
  result := TFhirObservationReferenceRangeListEnumerator.Create(self.link);
end;

function TFhirObservationReferenceRangeList.Clone: TFhirObservationReferenceRangeList;
begin
  result := TFhirObservationReferenceRangeList(inherited Clone);
end;

function TFhirObservationReferenceRangeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirObservationReferenceRangeList.GetItemN(index: Integer): TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange(ObjectByIndex[index]);
end;

function TFhirObservationReferenceRangeList.ItemClass: TFslObjectClass;
begin
  result := TFhirObservationReferenceRange;
end;
function TFhirObservationReferenceRangeList.IndexOf(value: TFhirObservationReferenceRange): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirObservationReferenceRangeList.Insert(index: Integer): TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirObservationReferenceRangeList.InsertItem(index: Integer; value: TFhirObservationReferenceRange);
begin
  assert(value is TFhirObservationReferenceRange);
  Inherited Insert(index, value);
end;

function TFhirObservationReferenceRangeList.Item(index: Integer): TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange(ObjectByIndex[index]);
end;

function TFhirObservationReferenceRangeList.Link: TFhirObservationReferenceRangeList;
begin
  result := TFhirObservationReferenceRangeList(inherited Link);
end;

procedure TFhirObservationReferenceRangeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirObservationReferenceRangeList.SetItemByIndex(index: Integer; value: TFhirObservationReferenceRange);
begin
  assert(value is TFhirObservationReferenceRange);
  FhirObservationReferenceRanges[index] := value;
end;

procedure TFhirObservationReferenceRangeList.SetItemN(index: Integer; value: TFhirObservationReferenceRange);
begin
  assert(value is TFhirObservationReferenceRange);
  ObjectByIndex[index] := value;
end;

{ TFhirObservationRelated }

constructor TFhirObservationRelated.Create;
begin
  inherited;
end;

destructor TFhirObservationRelated.Destroy;
begin
  FType_.free;
  FTarget.free;
  inherited;
end;

procedure TFhirObservationRelated.Assign(oSource : TFslObject);
begin
  inherited;
  FType_ := TFhirObservationRelated(oSource).FType_.Link;
  target := TFhirObservationRelated(oSource).target.Clone;
end;

procedure TFhirObservationRelated.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'target') Then
     list.add(self.link, 'target', FTarget.Link);
end;

procedure TFhirObservationRelated.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'target', 'Reference(Observation|QuestionnaireResponse)', false, TFhirReference{Resource}, FTarget.Link));{2}
end;

function TFhirObservationRelated.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirObservationRelationshiptypesEnum, CODES_TFhirObservationRelationshiptypesEnum, propValue);
    result := propValue
  end
  else if (propName = 'target') then
  begin
    Target := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirObservationRelated.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirObservationRelated.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'target') then result := TFhirReference{Resource}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirObservationRelated.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'target') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirObservationRelated.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'target') then TargetElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirObservationRelated.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirObservationRelationshiptypesEnum, CODES_TFhirObservationRelationshiptypesEnum, new){4}
  else if (propName = 'target') then TargetElement := new as TFhirReference{Resource}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirObservationRelated.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirObservationRelated.fhirType : string;
begin
  result := 'related';
end;

function TFhirObservationRelated.Link : TFhirObservationRelated;
begin
  result := TFhirObservationRelated(inherited Link);
end;

function TFhirObservationRelated.Clone : TFhirObservationRelated;
begin
  result := TFhirObservationRelated(inherited Clone);
end;

function TFhirObservationRelated.equals(other : TObject) : boolean;
var
  o : TFhirObservationRelated;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirObservationRelated)) then
    result := false
  else
  begin
    o := TFhirObservationRelated(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(targetElement, o.targetElement, true);
  end;
end;

function TFhirObservationRelated.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FTarget);
end;

procedure TFhirObservationRelated.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('target');
end;

{ TFhirObservationRelated }

Procedure TFhirObservationRelated.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirObservationRelated.GetType_ST : TFhirObservationRelationshiptypesEnum;
begin
  if FType_ = nil then
    result := TFhirObservationRelationshiptypesEnum(0)
  else
    result := TFhirObservationRelationshiptypesEnum(StringArrayIndexOfSensitive(CODES_TFhirObservationRelationshiptypesEnum, FType_.value));
end;

Procedure TFhirObservationRelated.SetType_ST(value : TFhirObservationRelationshiptypesEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirObservationRelationshiptypesEnum[value], CODES_TFhirObservationRelationshiptypesEnum[value]);
end;

Procedure TFhirObservationRelated.SetTarget(value : TFhirReference{Resource});
begin
  FTarget.free;
  FTarget := value;
end;

function TFhirObservationRelated.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FTarget.sizeInBytes);
end;

{ TFhirObservationRelatedListEnumerator }

Constructor TFhirObservationRelatedListEnumerator.Create(list : TFhirObservationRelatedList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirObservationRelatedListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirObservationRelatedListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirObservationRelatedListEnumerator.GetCurrent : TFhirObservationRelated;
begin
  Result := FList[FIndex];
end;

function TFhirObservationRelatedListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirObservationRelatedList }
procedure TFhirObservationRelatedList.AddItem(value: TFhirObservationRelated);
begin
  assert(value.ClassName = 'TFhirObservationRelated', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirObservationRelated');
  add(value);
end;

function TFhirObservationRelatedList.Append: TFhirObservationRelated;
begin
  result := TFhirObservationRelated.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirObservationRelatedList.ClearItems;
begin
  Clear;
end;

function TFhirObservationRelatedList.GetEnumerator : TFhirObservationRelatedListEnumerator;
begin
  result := TFhirObservationRelatedListEnumerator.Create(self.link);
end;

function TFhirObservationRelatedList.Clone: TFhirObservationRelatedList;
begin
  result := TFhirObservationRelatedList(inherited Clone);
end;

function TFhirObservationRelatedList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirObservationRelatedList.GetItemN(index: Integer): TFhirObservationRelated;
begin
  result := TFhirObservationRelated(ObjectByIndex[index]);
end;

function TFhirObservationRelatedList.ItemClass: TFslObjectClass;
begin
  result := TFhirObservationRelated;
end;
function TFhirObservationRelatedList.IndexOf(value: TFhirObservationRelated): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirObservationRelatedList.Insert(index: Integer): TFhirObservationRelated;
begin
  result := TFhirObservationRelated.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirObservationRelatedList.InsertItem(index: Integer; value: TFhirObservationRelated);
begin
  assert(value is TFhirObservationRelated);
  Inherited Insert(index, value);
end;

function TFhirObservationRelatedList.Item(index: Integer): TFhirObservationRelated;
begin
  result := TFhirObservationRelated(ObjectByIndex[index]);
end;

function TFhirObservationRelatedList.Link: TFhirObservationRelatedList;
begin
  result := TFhirObservationRelatedList(inherited Link);
end;

procedure TFhirObservationRelatedList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirObservationRelatedList.SetItemByIndex(index: Integer; value: TFhirObservationRelated);
begin
  assert(value is TFhirObservationRelated);
  FhirObservationRelateds[index] := value;
end;

procedure TFhirObservationRelatedList.SetItemN(index: Integer; value: TFhirObservationRelated);
begin
  assert(value is TFhirObservationRelated);
  ObjectByIndex[index] := value;
end;

{ TFhirObservationComponent }

constructor TFhirObservationComponent.Create;
begin
  inherited;
end;

destructor TFhirObservationComponent.Destroy;
begin
  FCode.free;
  FValue.free;
  FDataAbsentReason.free;
  FReferenceRangeList.Free;
  inherited;
end;

procedure TFhirObservationComponent.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirObservationComponent(oSource).code.Clone;
  value := TFhirObservationComponent(oSource).value.Clone;
  dataAbsentReason := TFhirObservationComponent(oSource).dataAbsentReason.Clone;
  if (TFhirObservationComponent(oSource).FReferenceRangeList = nil) then
  begin
    FReferenceRangeList.free;
    FReferenceRangeList := nil;
  end
  else
  begin
    if FReferenceRangeList = nil then
      FReferenceRangeList := TFhirObservationReferenceRangeList.Create;
    FReferenceRangeList.Assign(TFhirObservationComponent(oSource).FReferenceRangeList);
  end;
end;

procedure TFhirObservationComponent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
  if (child_name = 'dataAbsentReason') Then
     list.add(self.link, 'dataAbsentReason', FDataAbsentReason.Link);
  if (child_name = 'referenceRange') Then
    list.addAll(self, 'referenceRange', FReferenceRangeList);
end;

procedure TFhirObservationComponent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value[x]', 'Quantity|CodeableConcept|string|Range|Ratio|SampledData|Attachment|time|dateTime|Period', false, TFhirType, FValue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dataAbsentReason', 'CodeableConcept', false, TFhirCodeableConcept, FDataAbsentReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'referenceRange', '@Observation.referenceRange', true, TFhirObservationReferenceRange, FReferenceRangeList.Link)){3};
end;

function TFhirObservationComponent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Range', 'Ratio', 'SampledData', 'Attachment', 'Time', 'DateTime', 'Period'])) then
  begin
    Value := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'dataAbsentReason') then
  begin
    DataAbsentReason := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'referenceRange') then
  begin
    ReferenceRangeList.add(propValue as TFhirObservationReferenceRange){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirObservationComponent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'referenceRange') then ReferenceRangeList.insertItem(index, propValue as TFhirObservationReferenceRange){2a}
  else inherited;
end;

function TFhirObservationComponent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Range', 'Ratio', 'SampledData', 'Attachment', 'Time', 'DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Value'){4x}
  else if (propName = 'dataAbsentReason') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'referenceRange') then result := ReferenceRangeList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirObservationComponent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'Quantity|CodeableConcept|string|Range|Ratio|SampledData|Attachment|time|dateTime|Period'
  else if (propName = 'dataAbsentReason') then result := 'CodeableConcept'
  else if (propName = 'referenceRange') then result := '@Observation.referenceRange'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirObservationComponent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Range', 'Ratio', 'SampledData', 'Attachment', 'Time', 'DateTime', 'Period'])) then ValueElement := nil{4x}
  else if (propName = 'dataAbsentReason') then DataAbsentReasonElement := nil
  else if (propName = 'referenceRange') then deletePropertyValue('referenceRange', ReferenceRangeList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirObservationComponent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Range', 'Ratio', 'SampledData', 'Attachment', 'Time', 'DateTime', 'Period'])) then ValueElement := new as TFhirType{4x}
  else if (propName = 'dataAbsentReason') then DataAbsentReasonElement := new as TFhirCodeableConcept{4}
  else if (propName = 'referenceRange') then replacePropertyValue('referenceRange', ReferenceRangeList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirObservationComponent.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'referenceRange') then ReferenceRangeList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirObservationComponent.fhirType : string;
begin
  result := 'component';
end;

function TFhirObservationComponent.Link : TFhirObservationComponent;
begin
  result := TFhirObservationComponent(inherited Link);
end;

function TFhirObservationComponent.Clone : TFhirObservationComponent;
begin
  result := TFhirObservationComponent(inherited Clone);
end;

function TFhirObservationComponent.equals(other : TObject) : boolean;
var
  o : TFhirObservationComponent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirObservationComponent)) then
    result := false
  else
  begin
    o := TFhirObservationComponent(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(valueElement, o.valueElement, true) and
      compareDeep(dataAbsentReasonElement, o.dataAbsentReasonElement, true) and compareDeep(referenceRangeList, o.referenceRangeList, true);
  end;
end;

function TFhirObservationComponent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FValue) and isEmptyProp(FDataAbsentReason) and isEmptyProp(FreferenceRangeList);
end;

procedure TFhirObservationComponent.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('value[x]');
  fields.add('dataAbsentReason');
  fields.add('referenceRange');
end;

{ TFhirObservationComponent }

Procedure TFhirObservationComponent.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirObservationComponent.SetValue(value : TFhirType);
begin
  FValue.free;
  FValue := value;
end;

Procedure TFhirObservationComponent.SetDataAbsentReason(value : TFhirCodeableConcept);
begin
  FDataAbsentReason.free;
  FDataAbsentReason := value;
end;

Function TFhirObservationComponent.GetReferenceRangeList : TFhirObservationReferenceRangeList;
begin
  if FReferenceRangeList = nil then
    FReferenceRangeList := TFhirObservationReferenceRangeList.Create;
  result := FReferenceRangeList;
end;

Function TFhirObservationComponent.GetHasReferenceRangeList : boolean;
begin
  result := (FReferenceRangeList <> nil) and (FReferenceRangeList.count > 0);
end;

function TFhirObservationComponent.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FValue.sizeInBytes);
  inc(result, FDataAbsentReason.sizeInBytes);
  inc(result, FreferenceRangeList.sizeInBytes);
end;

{ TFhirObservationComponentListEnumerator }

Constructor TFhirObservationComponentListEnumerator.Create(list : TFhirObservationComponentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirObservationComponentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirObservationComponentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirObservationComponentListEnumerator.GetCurrent : TFhirObservationComponent;
begin
  Result := FList[FIndex];
end;

function TFhirObservationComponentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirObservationComponentList }
procedure TFhirObservationComponentList.AddItem(value: TFhirObservationComponent);
begin
  assert(value.ClassName = 'TFhirObservationComponent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirObservationComponent');
  add(value);
end;

function TFhirObservationComponentList.Append: TFhirObservationComponent;
begin
  result := TFhirObservationComponent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirObservationComponentList.ClearItems;
begin
  Clear;
end;

function TFhirObservationComponentList.GetEnumerator : TFhirObservationComponentListEnumerator;
begin
  result := TFhirObservationComponentListEnumerator.Create(self.link);
end;

function TFhirObservationComponentList.Clone: TFhirObservationComponentList;
begin
  result := TFhirObservationComponentList(inherited Clone);
end;

function TFhirObservationComponentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirObservationComponentList.GetItemN(index: Integer): TFhirObservationComponent;
begin
  result := TFhirObservationComponent(ObjectByIndex[index]);
end;

function TFhirObservationComponentList.ItemClass: TFslObjectClass;
begin
  result := TFhirObservationComponent;
end;
function TFhirObservationComponentList.IndexOf(value: TFhirObservationComponent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirObservationComponentList.Insert(index: Integer): TFhirObservationComponent;
begin
  result := TFhirObservationComponent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirObservationComponentList.InsertItem(index: Integer; value: TFhirObservationComponent);
begin
  assert(value is TFhirObservationComponent);
  Inherited Insert(index, value);
end;

function TFhirObservationComponentList.Item(index: Integer): TFhirObservationComponent;
begin
  result := TFhirObservationComponent(ObjectByIndex[index]);
end;

function TFhirObservationComponentList.Link: TFhirObservationComponentList;
begin
  result := TFhirObservationComponentList(inherited Link);
end;

procedure TFhirObservationComponentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirObservationComponentList.SetItemByIndex(index: Integer; value: TFhirObservationComponent);
begin
  assert(value is TFhirObservationComponent);
  FhirObservationComponents[index] := value;
end;

procedure TFhirObservationComponentList.SetItemN(index: Integer; value: TFhirObservationComponent);
begin
  assert(value is TFhirObservationComponent);
  ObjectByIndex[index] := value;
end;

{ TFhirObservation }

constructor TFhirObservation.Create;
begin
  inherited;
end;

destructor TFhirObservation.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FCategory.free;
  FCode.free;
  FSubject.free;
  FEncounter.free;
  FEffective.free;
  FIssued.free;
  FPerformerList.Free;
  FValue.free;
  FDataAbsentReason.free;
  FInterpretation.free;
  FComments.free;
  FBodySite.free;
  FMethod.free;
  FSpecimen.free;
  FDevice.free;
  FReferenceRangeList.Free;
  FRelatedList.Free;
  FComponentList.Free;
  inherited;
end;

function TFhirObservation.GetResourceType : TFhirResourceType;
begin
  result := frtObservation;
end;

procedure TFhirObservation.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirObservation(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirObservation(oSource).FIdentifierList);
  end;
  FStatus := TFhirObservation(oSource).FStatus.Link;
  category := TFhirObservation(oSource).category.Clone;
  code := TFhirObservation(oSource).code.Clone;
  subject := TFhirObservation(oSource).subject.Clone;
  encounter := TFhirObservation(oSource).encounter.Clone;
  effective := TFhirObservation(oSource).effective.Clone;
  issuedElement := TFhirObservation(oSource).issuedElement.Clone;
  if (TFhirObservation(oSource).FPerformerList = nil) then
  begin
    FPerformerList.free;
    FPerformerList := nil;
  end
  else
  begin
    if FPerformerList = nil then
      FPerformerList := TFhirReferenceList{Resource}.Create;
    FPerformerList.Assign(TFhirObservation(oSource).FPerformerList);
  end;
  value := TFhirObservation(oSource).value.Clone;
  dataAbsentReason := TFhirObservation(oSource).dataAbsentReason.Clone;
  interpretation := TFhirObservation(oSource).interpretation.Clone;
  commentsElement := TFhirObservation(oSource).commentsElement.Clone;
  bodySite := TFhirObservation(oSource).bodySite.Clone;
  method := TFhirObservation(oSource).method.Clone;
  specimen := TFhirObservation(oSource).specimen.Clone;
  device := TFhirObservation(oSource).device.Clone;
  if (TFhirObservation(oSource).FReferenceRangeList = nil) then
  begin
    FReferenceRangeList.free;
    FReferenceRangeList := nil;
  end
  else
  begin
    if FReferenceRangeList = nil then
      FReferenceRangeList := TFhirObservationReferenceRangeList.Create;
    FReferenceRangeList.Assign(TFhirObservation(oSource).FReferenceRangeList);
  end;
  if (TFhirObservation(oSource).FRelatedList = nil) then
  begin
    FRelatedList.free;
    FRelatedList := nil;
  end
  else
  begin
    if FRelatedList = nil then
      FRelatedList := TFhirObservationRelatedList.Create;
    FRelatedList.Assign(TFhirObservation(oSource).FRelatedList);
  end;
  if (TFhirObservation(oSource).FComponentList = nil) then
  begin
    FComponentList.free;
    FComponentList := nil;
  end
  else
  begin
    if FComponentList = nil then
      FComponentList := TFhirObservationComponentList.Create;
    FComponentList.Assign(TFhirObservation(oSource).FComponentList);
  end;
end;

procedure TFhirObservation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'effective[x]') or (child_name = 'effective') Then
     list.add(self.link, 'effective[x]', FEffective.Link);
  if (child_name = 'issued') Then
     list.add(self.link, 'issued', FIssued.Link);
  if (child_name = 'performer') Then
    list.addAll(self, 'performer', FPerformerList);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
  if (child_name = 'dataAbsentReason') Then
     list.add(self.link, 'dataAbsentReason', FDataAbsentReason.Link);
  if (child_name = 'interpretation') Then
     list.add(self.link, 'interpretation', FInterpretation.Link);
  if (child_name = 'comments') Then
     list.add(self.link, 'comments', FComments.Link);
  if (child_name = 'bodySite') Then
     list.add(self.link, 'bodySite', FBodySite.Link);
  if (child_name = 'method') Then
     list.add(self.link, 'method', FMethod.Link);
  if (child_name = 'specimen') Then
     list.add(self.link, 'specimen', FSpecimen.Link);
  if (child_name = 'device') Then
     list.add(self.link, 'device', FDevice.Link);
  if (child_name = 'referenceRange') Then
    list.addAll(self, 'referenceRange', FReferenceRangeList);
  if (child_name = 'related') Then
    list.addAll(self, 'related', FRelatedList);
  if (child_name = 'component') Then
    list.addAll(self, 'component', FComponentList);
end;

procedure TFhirObservation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Group|Device|Location)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference(Encounter)', false, TFhirReference{TFhirEncounter}, FEncounter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'effective[x]', 'dateTime|Period', false, TFhirType, FEffective.Link));{2}
  oList.add(TFHIRProperty.create(self, 'issued', 'instant', false, TFhirInstant, FIssued.Link));{2}
  oList.add(TFHIRProperty.create(self, 'performer', 'Reference(Practitioner|Organization|Patient|RelatedPerson)', true, TFhirReference{Resource}, FPerformerList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'value[x]', 'Quantity|CodeableConcept|string|Range|Ratio|SampledData|Attachment|time|dateTime|Period', false, TFhirType, FValue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dataAbsentReason', 'CodeableConcept', false, TFhirCodeableConcept, FDataAbsentReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'interpretation', 'CodeableConcept', false, TFhirCodeableConcept, FInterpretation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'comments', 'string', false, TFhirString, FComments.Link));{2}
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', false, TFhirCodeableConcept, FBodySite.Link));{2}
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', false, TFhirCodeableConcept, FMethod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'specimen', 'Reference(Specimen)', false, TFhirReference{TFhirSpecimen}, FSpecimen.Link));{2}
  oList.add(TFHIRProperty.create(self, 'device', 'Reference(Device|DeviceMetric)', false, TFhirReference{Resource}, FDevice.Link));{2}
  oList.add(TFHIRProperty.create(self, 'referenceRange', '', true, TFhirObservationReferenceRange, FReferenceRangeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'related', '', true, TFhirObservationRelated, FRelatedList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'component', '', true, TFhirObservationComponent, FComponentList.Link)){3};
end;

function TFhirObservation.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirObservationStatusEnum, CODES_TFhirObservationStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference{TFhirEncounter}{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then
  begin
    Effective := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'issued') then
  begin
    IssuedElement := asInstant(propValue){5a};
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    PerformerList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Range', 'Ratio', 'SampledData', 'Attachment', 'Time', 'DateTime', 'Period'])) then
  begin
    Value := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'dataAbsentReason') then
  begin
    DataAbsentReason := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'interpretation') then
  begin
    Interpretation := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'comments') then
  begin
    CommentsElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySite := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'method') then
  begin
    Method := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'specimen') then
  begin
    Specimen := propValue as TFhirReference{TFhirSpecimen}{4b};
    result := propValue;
  end
  else if (propName = 'device') then
  begin
    Device := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'referenceRange') then
  begin
    ReferenceRangeList.add(propValue as TFhirObservationReferenceRange){2a};
    result := propValue;
  end
  else if (propName = 'related') then
  begin
    RelatedList.add(propValue as TFhirObservationRelated){2a};
    result := propValue;
  end
  else if (propName = 'component') then
  begin
    ComponentList.add(propValue as TFhirObservationComponent){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirObservation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'performer') then PerformerList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'referenceRange') then ReferenceRangeList.insertItem(index, propValue as TFhirObservationReferenceRange){2a}
  else if (propName = 'related') then RelatedList.insertItem(index, propValue as TFhirObservationRelated){2a}
  else if (propName = 'component') then ComponentList.insertItem(index, propValue as TFhirObservationComponent){2a}
  else inherited;
end;

function TFhirObservation.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'encounter') then result := TFhirReference{TFhirEncounter}.create(){4b}
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Effective'){4x}
  else if (propName = 'issued') then result := TFhirInstant.create() {5b}
  else if (propName = 'performer') then result := PerformerList.new(){2}
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Range', 'Ratio', 'SampledData', 'Attachment', 'Time', 'DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Value'){4x}
  else if (propName = 'dataAbsentReason') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'interpretation') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'comments') then result := TFhirString.create() {5b}
  else if (propName = 'bodySite') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'method') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'specimen') then result := TFhirReference{TFhirSpecimen}.create(){4b}
  else if (propName = 'device') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'referenceRange') then result := ReferenceRangeList.new(){2}
  else if (propName = 'related') then result := RelatedList.new(){2}
  else if (propName = 'component') then result := ComponentList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirObservation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'effective[x]') then result := 'dateTime|Period'
  else if (propName = 'issued') then result := 'instant'
  else if (propName = 'performer') then result := 'Reference'
  else if (propName = 'value[x]') then result := 'Quantity|CodeableConcept|string|Range|Ratio|SampledData|Attachment|time|dateTime|Period'
  else if (propName = 'dataAbsentReason') then result := 'CodeableConcept'
  else if (propName = 'interpretation') then result := 'CodeableConcept'
  else if (propName = 'comments') then result := 'string'
  else if (propName = 'bodySite') then result := 'CodeableConcept'
  else if (propName = 'method') then result := 'CodeableConcept'
  else if (propName = 'specimen') then result := 'Reference'
  else if (propName = 'device') then result := 'Reference'
  else if (propName = 'referenceRange') then result := ''
  else if (propName = 'related') then result := ''
  else if (propName = 'component') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirObservation.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then EffectiveElement := nil{4x}
  else if (propName = 'issued') then IssuedElement := nil
  else if (propName = 'performer') then deletePropertyValue('performer', PerformerList, value) {2}
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Range', 'Ratio', 'SampledData', 'Attachment', 'Time', 'DateTime', 'Period'])) then ValueElement := nil{4x}
  else if (propName = 'dataAbsentReason') then DataAbsentReasonElement := nil
  else if (propName = 'interpretation') then InterpretationElement := nil
  else if (propName = 'comments') then CommentsElement := nil
  else if (propName = 'bodySite') then BodySiteElement := nil
  else if (propName = 'method') then MethodElement := nil
  else if (propName = 'specimen') then SpecimenElement := nil
  else if (propName = 'device') then DeviceElement := nil
  else if (propName = 'referenceRange') then deletePropertyValue('referenceRange', ReferenceRangeList, value) {2}
  else if (propName = 'related') then deletePropertyValue('related', RelatedList, value) {2}
  else if (propName = 'component') then deletePropertyValue('component', ComponentList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirObservation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirObservationStatusEnum, CODES_TFhirObservationStatusEnum, new){4}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference{TFhirEncounter}{4}
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then EffectiveElement := new as TFhirType{4x}
  else if (propName = 'issued') then IssuedElement := asInstant(new){5b}
  else if (propName = 'performer') then replacePropertyValue('performer', PerformerList, existing, new) {2}
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Range', 'Ratio', 'SampledData', 'Attachment', 'Time', 'DateTime', 'Period'])) then ValueElement := new as TFhirType{4x}
  else if (propName = 'dataAbsentReason') then DataAbsentReasonElement := new as TFhirCodeableConcept{4}
  else if (propName = 'interpretation') then InterpretationElement := new as TFhirCodeableConcept{4}
  else if (propName = 'comments') then CommentsElement := asString(new){5b}
  else if (propName = 'bodySite') then BodySiteElement := new as TFhirCodeableConcept{4}
  else if (propName = 'method') then MethodElement := new as TFhirCodeableConcept{4}
  else if (propName = 'specimen') then SpecimenElement := new as TFhirReference{TFhirSpecimen}{4}
  else if (propName = 'device') then DeviceElement := new as TFhirReference{Resource}{4}
  else if (propName = 'referenceRange') then replacePropertyValue('referenceRange', ReferenceRangeList, existing, new) {2}
  else if (propName = 'related') then replacePropertyValue('related', RelatedList, existing, new) {2}
  else if (propName = 'component') then replacePropertyValue('component', ComponentList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirObservation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'performer') then PerformerList.move(source, destination){2a}
  else if (propName = 'referenceRange') then ReferenceRangeList.move(source, destination){2a}
  else if (propName = 'related') then RelatedList.move(source, destination){2a}
  else if (propName = 'component') then ComponentList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirObservation.fhirType : string;
begin
  result := 'Observation';
end;

function TFhirObservation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FCategory) and isEmptyProp(FCode) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FEffective) and isEmptyProp(FIssued) and isEmptyProp(FperformerList) and isEmptyProp(FValue) and isEmptyProp(FDataAbsentReason) and isEmptyProp(FInterpretation) and isEmptyProp(FComments) and isEmptyProp(FBodySite) and isEmptyProp(FMethod) and isEmptyProp(FSpecimen) and isEmptyProp(FDevice) and isEmptyProp(FreferenceRangeList) and isEmptyProp(FrelatedList) and isEmptyProp(FcomponentList);
end;

function TFhirObservation.equals(other : TObject) : boolean;
var
  o : TFhirObservation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirObservation)) then
    result := false
  else
  begin
    o := TFhirObservation(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(categoryElement, o.categoryElement, true) and compareDeep(codeElement, o.codeElement, true) and
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(encounterElement, o.encounterElement, true) and
      compareDeep(effectiveElement, o.effectiveElement, true) and compareDeep(issuedElement, o.issuedElement, true) and
      compareDeep(performerList, o.performerList, true) and compareDeep(valueElement, o.valueElement, true) and
      compareDeep(dataAbsentReasonElement, o.dataAbsentReasonElement, true) and compareDeep(interpretationElement, o.interpretationElement, true) and
      compareDeep(commentsElement, o.commentsElement, true) and compareDeep(bodySiteElement, o.bodySiteElement, true) and
      compareDeep(methodElement, o.methodElement, true) and compareDeep(specimenElement, o.specimenElement, true) and
      compareDeep(deviceElement, o.deviceElement, true) and compareDeep(referenceRangeList, o.referenceRangeList, true) and
      compareDeep(relatedList, o.relatedList, true) and compareDeep(componentList, o.componentList, true);
  end;
end;

function TFhirObservation.Link : TFhirObservation;
begin
  result := TFhirObservation(inherited Link);
end;

function TFhirObservation.Clone : TFhirObservation;
begin
  result := TFhirObservation(inherited Clone);
end;

procedure TFhirObservation.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('category');
  fields.add('code');
  fields.add('subject');
  fields.add('encounter');
  fields.add('effective[x]');
  fields.add('issued');
  fields.add('performer');
  fields.add('value[x]');
  fields.add('dataAbsentReason');
  fields.add('interpretation');
  fields.add('comments');
  fields.add('bodySite');
  fields.add('method');
  fields.add('specimen');
  fields.add('device');
  fields.add('referenceRange');
  fields.add('related');
  fields.add('component');
end;

{ TFhirObservation }

Function TFhirObservation.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirObservation.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirObservation.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirObservation.GetStatusST : TFhirObservationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirObservationStatusEnum(0)
  else
    result := TFhirObservationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirObservationStatusEnum, FStatus.value));
end;

Procedure TFhirObservation.SetStatusST(value : TFhirObservationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirObservationStatusEnum[value], CODES_TFhirObservationStatusEnum[value]);
end;

Procedure TFhirObservation.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirObservation.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirObservation.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirObservation.SetEncounter(value : TFhirReference{TFhirEncounter});
begin
  FEncounter.free;
  FEncounter := value;
end;

Procedure TFhirObservation.SetEffective(value : TFhirType);
begin
  FEffective.free;
  FEffective := value;
end;

Procedure TFhirObservation.SetIssued(value : TFhirInstant);
begin
  FIssued.free;
  FIssued := value;
end;

Function TFhirObservation.GetIssuedST : TFslDateTime;
begin
  if FIssued = nil then
    result := TFslDateTime.makeNull
  else
    result := FIssued.value;
end;

Procedure TFhirObservation.SetIssuedST(value : TFslDateTime);
begin
  if FIssued = nil then
    FIssued := TFhirInstant.create;
  FIssued.value := value
end;

Function TFhirObservation.GetPerformerList : TFhirReferenceList{Resource};
begin
  if FPerformerList = nil then
    FPerformerList := TFhirReferenceList{Resource}.Create;
  result := FPerformerList;
end;

Function TFhirObservation.GetHasPerformerList : boolean;
begin
  result := (FPerformerList <> nil) and (FPerformerList.count > 0);
end;

Procedure TFhirObservation.SetValue(value : TFhirType);
begin
  FValue.free;
  FValue := value;
end;

Procedure TFhirObservation.SetDataAbsentReason(value : TFhirCodeableConcept);
begin
  FDataAbsentReason.free;
  FDataAbsentReason := value;
end;

Procedure TFhirObservation.SetInterpretation(value : TFhirCodeableConcept);
begin
  FInterpretation.free;
  FInterpretation := value;
end;

Procedure TFhirObservation.SetComments(value : TFhirString);
begin
  FComments.free;
  FComments := value;
end;

Function TFhirObservation.GetCommentsST : String;
begin
  if FComments = nil then
    result := ''
  else
    result := FComments.value;
end;

Procedure TFhirObservation.SetCommentsST(value : String);
begin
  if value <> '' then
  begin
    if FComments = nil then
      FComments := TFhirString.create;
    FComments.value := value
  end
  else if FComments <> nil then
    FComments.value := '';
end;

Procedure TFhirObservation.SetBodySite(value : TFhirCodeableConcept);
begin
  FBodySite.free;
  FBodySite := value;
end;

Procedure TFhirObservation.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value;
end;

Procedure TFhirObservation.SetSpecimen(value : TFhirReference{TFhirSpecimen});
begin
  FSpecimen.free;
  FSpecimen := value;
end;

Procedure TFhirObservation.SetDevice(value : TFhirReference{Resource});
begin
  FDevice.free;
  FDevice := value;
end;

Function TFhirObservation.GetReferenceRangeList : TFhirObservationReferenceRangeList;
begin
  if FReferenceRangeList = nil then
    FReferenceRangeList := TFhirObservationReferenceRangeList.Create;
  result := FReferenceRangeList;
end;

Function TFhirObservation.GetHasReferenceRangeList : boolean;
begin
  result := (FReferenceRangeList <> nil) and (FReferenceRangeList.count > 0);
end;

Function TFhirObservation.GetRelatedList : TFhirObservationRelatedList;
begin
  if FRelatedList = nil then
    FRelatedList := TFhirObservationRelatedList.Create;
  result := FRelatedList;
end;

Function TFhirObservation.GetHasRelatedList : boolean;
begin
  result := (FRelatedList <> nil) and (FRelatedList.count > 0);
end;

Function TFhirObservation.GetComponentList : TFhirObservationComponentList;
begin
  if FComponentList = nil then
    FComponentList := TFhirObservationComponentList.Create;
  result := FComponentList;
end;

Function TFhirObservation.GetHasComponentList : boolean;
begin
  result := (FComponentList <> nil) and (FComponentList.count > 0);
end;

function TFhirObservation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FEffective.sizeInBytes);
  inc(result, FIssued.sizeInBytes);
  inc(result, FperformerList.sizeInBytes);
  inc(result, FValue.sizeInBytes);
  inc(result, FDataAbsentReason.sizeInBytes);
  inc(result, FInterpretation.sizeInBytes);
  inc(result, FComments.sizeInBytes);
  inc(result, FBodySite.sizeInBytes);
  inc(result, FMethod.sizeInBytes);
  inc(result, FSpecimen.sizeInBytes);
  inc(result, FDevice.sizeInBytes);
  inc(result, FreferenceRangeList.sizeInBytes);
  inc(result, FrelatedList.sizeInBytes);
  inc(result, FcomponentList.sizeInBytes);
end;

{ TFhirObservationListEnumerator }

Constructor TFhirObservationListEnumerator.Create(list : TFhirObservationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirObservationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirObservationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirObservationListEnumerator.GetCurrent : TFhirObservation;
begin
  Result := FList[FIndex];
end;

function TFhirObservationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirObservationList }
procedure TFhirObservationList.AddItem(value: TFhirObservation);
begin
  assert(value.ClassName = 'TFhirObservation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirObservation');
  add(value);
end;

function TFhirObservationList.Append: TFhirObservation;
begin
  result := TFhirObservation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirObservationList.ClearItems;
begin
  Clear;
end;

function TFhirObservationList.GetEnumerator : TFhirObservationListEnumerator;
begin
  result := TFhirObservationListEnumerator.Create(self.link);
end;

function TFhirObservationList.Clone: TFhirObservationList;
begin
  result := TFhirObservationList(inherited Clone);
end;

function TFhirObservationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirObservationList.GetItemN(index: Integer): TFhirObservation;
begin
  result := TFhirObservation(ObjectByIndex[index]);
end;

function TFhirObservationList.ItemClass: TFslObjectClass;
begin
  result := TFhirObservation;
end;
function TFhirObservationList.IndexOf(value: TFhirObservation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirObservationList.Insert(index: Integer): TFhirObservation;
begin
  result := TFhirObservation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirObservationList.InsertItem(index: Integer; value: TFhirObservation);
begin
  assert(value is TFhirObservation);
  Inherited Insert(index, value);
end;

function TFhirObservationList.Item(index: Integer): TFhirObservation;
begin
  result := TFhirObservation(ObjectByIndex[index]);
end;

function TFhirObservationList.Link: TFhirObservationList;
begin
  result := TFhirObservationList(inherited Link);
end;

procedure TFhirObservationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirObservationList.SetItemByIndex(index: Integer; value: TFhirObservation);
begin
  assert(value is TFhirObservation);
  FhirObservations[index] := value;
end;

procedure TFhirObservationList.SetItemN(index: Integer; value: TFhirObservation);
begin
  assert(value is TFhirObservation);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_OBSERVATION}

{$IFDEF FHIR_PROCEDURE}

{ TFhirProcedurePerformer }

constructor TFhirProcedurePerformer.Create;
begin
  inherited;
end;

destructor TFhirProcedurePerformer.Destroy;
begin
  FActor.free;
  FRole.free;
  inherited;
end;

procedure TFhirProcedurePerformer.Assign(oSource : TFslObject);
begin
  inherited;
  actor := TFhirProcedurePerformer(oSource).actor.Clone;
  role := TFhirProcedurePerformer(oSource).role.Clone;
end;

procedure TFhirProcedurePerformer.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'actor') Then
     list.add(self.link, 'actor', FActor.Link);
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
end;

procedure TFhirProcedurePerformer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'actor', 'Reference(Practitioner|Organization|Patient|RelatedPerson)', false, TFhirReference{Resource}, FActor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));{2}
end;

function TFhirProcedurePerformer.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'actor') then
  begin
    Actor := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirProcedurePerformer.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirProcedurePerformer.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'actor') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'role') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirProcedurePerformer.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'actor') then result := 'Reference'
  else if (propName = 'role') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirProcedurePerformer.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'actor') then ActorElement := nil
  else if (propName = 'role') then RoleElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirProcedurePerformer.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'actor') then ActorElement := new as TFhirReference{Resource}{4}
  else if (propName = 'role') then RoleElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirProcedurePerformer.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirProcedurePerformer.fhirType : string;
begin
  result := 'performer';
end;

function TFhirProcedurePerformer.Link : TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer(inherited Link);
end;

function TFhirProcedurePerformer.Clone : TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer(inherited Clone);
end;

function TFhirProcedurePerformer.equals(other : TObject) : boolean;
var
  o : TFhirProcedurePerformer;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirProcedurePerformer)) then
    result := false
  else
  begin
    o := TFhirProcedurePerformer(other);
    result := compareDeep(actorElement, o.actorElement, true) and compareDeep(roleElement, o.roleElement, true);
  end;
end;

function TFhirProcedurePerformer.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FActor) and isEmptyProp(FRole);
end;

procedure TFhirProcedurePerformer.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('actor');
  fields.add('role');
end;

{ TFhirProcedurePerformer }

Procedure TFhirProcedurePerformer.SetActor(value : TFhirReference{Resource});
begin
  FActor.free;
  FActor := value;
end;

Procedure TFhirProcedurePerformer.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

function TFhirProcedurePerformer.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FActor.sizeInBytes);
  inc(result, FRole.sizeInBytes);
end;

{ TFhirProcedurePerformerListEnumerator }

Constructor TFhirProcedurePerformerListEnumerator.Create(list : TFhirProcedurePerformerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirProcedurePerformerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProcedurePerformerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirProcedurePerformerListEnumerator.GetCurrent : TFhirProcedurePerformer;
begin
  Result := FList[FIndex];
end;

function TFhirProcedurePerformerListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirProcedurePerformerList }
procedure TFhirProcedurePerformerList.AddItem(value: TFhirProcedurePerformer);
begin
  assert(value.ClassName = 'TFhirProcedurePerformer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProcedurePerformer');
  add(value);
end;

function TFhirProcedurePerformerList.Append: TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcedurePerformerList.ClearItems;
begin
  Clear;
end;

function TFhirProcedurePerformerList.GetEnumerator : TFhirProcedurePerformerListEnumerator;
begin
  result := TFhirProcedurePerformerListEnumerator.Create(self.link);
end;

function TFhirProcedurePerformerList.Clone: TFhirProcedurePerformerList;
begin
  result := TFhirProcedurePerformerList(inherited Clone);
end;

function TFhirProcedurePerformerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProcedurePerformerList.GetItemN(index: Integer): TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer(ObjectByIndex[index]);
end;

function TFhirProcedurePerformerList.ItemClass: TFslObjectClass;
begin
  result := TFhirProcedurePerformer;
end;
function TFhirProcedurePerformerList.IndexOf(value: TFhirProcedurePerformer): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirProcedurePerformerList.Insert(index: Integer): TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcedurePerformerList.InsertItem(index: Integer; value: TFhirProcedurePerformer);
begin
  assert(value is TFhirProcedurePerformer);
  Inherited Insert(index, value);
end;

function TFhirProcedurePerformerList.Item(index: Integer): TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer(ObjectByIndex[index]);
end;

function TFhirProcedurePerformerList.Link: TFhirProcedurePerformerList;
begin
  result := TFhirProcedurePerformerList(inherited Link);
end;

procedure TFhirProcedurePerformerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProcedurePerformerList.SetItemByIndex(index: Integer; value: TFhirProcedurePerformer);
begin
  assert(value is TFhirProcedurePerformer);
  FhirProcedurePerformers[index] := value;
end;

procedure TFhirProcedurePerformerList.SetItemN(index: Integer; value: TFhirProcedurePerformer);
begin
  assert(value is TFhirProcedurePerformer);
  ObjectByIndex[index] := value;
end;

{ TFhirProcedureFocalDevice }

constructor TFhirProcedureFocalDevice.Create;
begin
  inherited;
end;

destructor TFhirProcedureFocalDevice.Destroy;
begin
  FAction.free;
  FManipulated.free;
  inherited;
end;

procedure TFhirProcedureFocalDevice.Assign(oSource : TFslObject);
begin
  inherited;
  action := TFhirProcedureFocalDevice(oSource).action.Clone;
  manipulated := TFhirProcedureFocalDevice(oSource).manipulated.Clone;
end;

procedure TFhirProcedureFocalDevice.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'action') Then
     list.add(self.link, 'action', FAction.Link);
  if (child_name = 'manipulated') Then
     list.add(self.link, 'manipulated', FManipulated.Link);
end;

procedure TFhirProcedureFocalDevice.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'action', 'CodeableConcept', false, TFhirCodeableConcept, FAction.Link));{2}
  oList.add(TFHIRProperty.create(self, 'manipulated', 'Reference(Device)', false, TFhirReference{TFhirDevice}, FManipulated.Link));{2}
end;

function TFhirProcedureFocalDevice.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'action') then
  begin
    Action := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'manipulated') then
  begin
    Manipulated := propValue as TFhirReference{TFhirDevice}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirProcedureFocalDevice.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirProcedureFocalDevice.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'action') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'manipulated') then result := TFhirReference{TFhirDevice}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirProcedureFocalDevice.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'action') then result := 'CodeableConcept'
  else if (propName = 'manipulated') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirProcedureFocalDevice.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'action') then ActionElement := nil
  else if (propName = 'manipulated') then ManipulatedElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirProcedureFocalDevice.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'action') then ActionElement := new as TFhirCodeableConcept{4}
  else if (propName = 'manipulated') then ManipulatedElement := new as TFhirReference{TFhirDevice}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirProcedureFocalDevice.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirProcedureFocalDevice.fhirType : string;
begin
  result := 'focalDevice';
end;

function TFhirProcedureFocalDevice.Link : TFhirProcedureFocalDevice;
begin
  result := TFhirProcedureFocalDevice(inherited Link);
end;

function TFhirProcedureFocalDevice.Clone : TFhirProcedureFocalDevice;
begin
  result := TFhirProcedureFocalDevice(inherited Clone);
end;

function TFhirProcedureFocalDevice.equals(other : TObject) : boolean;
var
  o : TFhirProcedureFocalDevice;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirProcedureFocalDevice)) then
    result := false
  else
  begin
    o := TFhirProcedureFocalDevice(other);
    result := compareDeep(actionElement, o.actionElement, true) and compareDeep(manipulatedElement, o.manipulatedElement, true);
  end;
end;

function TFhirProcedureFocalDevice.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAction) and isEmptyProp(FManipulated);
end;

procedure TFhirProcedureFocalDevice.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('action');
  fields.add('manipulated');
end;

{ TFhirProcedureFocalDevice }

Procedure TFhirProcedureFocalDevice.SetAction(value : TFhirCodeableConcept);
begin
  FAction.free;
  FAction := value;
end;

Procedure TFhirProcedureFocalDevice.SetManipulated(value : TFhirReference{TFhirDevice});
begin
  FManipulated.free;
  FManipulated := value;
end;

function TFhirProcedureFocalDevice.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FAction.sizeInBytes);
  inc(result, FManipulated.sizeInBytes);
end;

{ TFhirProcedureFocalDeviceListEnumerator }

Constructor TFhirProcedureFocalDeviceListEnumerator.Create(list : TFhirProcedureFocalDeviceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirProcedureFocalDeviceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProcedureFocalDeviceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirProcedureFocalDeviceListEnumerator.GetCurrent : TFhirProcedureFocalDevice;
begin
  Result := FList[FIndex];
end;

function TFhirProcedureFocalDeviceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirProcedureFocalDeviceList }
procedure TFhirProcedureFocalDeviceList.AddItem(value: TFhirProcedureFocalDevice);
begin
  assert(value.ClassName = 'TFhirProcedureFocalDevice', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProcedureFocalDevice');
  add(value);
end;

function TFhirProcedureFocalDeviceList.Append: TFhirProcedureFocalDevice;
begin
  result := TFhirProcedureFocalDevice.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcedureFocalDeviceList.ClearItems;
begin
  Clear;
end;

function TFhirProcedureFocalDeviceList.GetEnumerator : TFhirProcedureFocalDeviceListEnumerator;
begin
  result := TFhirProcedureFocalDeviceListEnumerator.Create(self.link);
end;

function TFhirProcedureFocalDeviceList.Clone: TFhirProcedureFocalDeviceList;
begin
  result := TFhirProcedureFocalDeviceList(inherited Clone);
end;

function TFhirProcedureFocalDeviceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProcedureFocalDeviceList.GetItemN(index: Integer): TFhirProcedureFocalDevice;
begin
  result := TFhirProcedureFocalDevice(ObjectByIndex[index]);
end;

function TFhirProcedureFocalDeviceList.ItemClass: TFslObjectClass;
begin
  result := TFhirProcedureFocalDevice;
end;
function TFhirProcedureFocalDeviceList.IndexOf(value: TFhirProcedureFocalDevice): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirProcedureFocalDeviceList.Insert(index: Integer): TFhirProcedureFocalDevice;
begin
  result := TFhirProcedureFocalDevice.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcedureFocalDeviceList.InsertItem(index: Integer; value: TFhirProcedureFocalDevice);
begin
  assert(value is TFhirProcedureFocalDevice);
  Inherited Insert(index, value);
end;

function TFhirProcedureFocalDeviceList.Item(index: Integer): TFhirProcedureFocalDevice;
begin
  result := TFhirProcedureFocalDevice(ObjectByIndex[index]);
end;

function TFhirProcedureFocalDeviceList.Link: TFhirProcedureFocalDeviceList;
begin
  result := TFhirProcedureFocalDeviceList(inherited Link);
end;

procedure TFhirProcedureFocalDeviceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProcedureFocalDeviceList.SetItemByIndex(index: Integer; value: TFhirProcedureFocalDevice);
begin
  assert(value is TFhirProcedureFocalDevice);
  FhirProcedureFocalDevices[index] := value;
end;

procedure TFhirProcedureFocalDeviceList.SetItemN(index: Integer; value: TFhirProcedureFocalDevice);
begin
  assert(value is TFhirProcedureFocalDevice);
  ObjectByIndex[index] := value;
end;

{ TFhirProcedure }

constructor TFhirProcedure.Create;
begin
  inherited;
end;

destructor TFhirProcedure.Destroy;
begin
  FIdentifierList.Free;
  FSubject.free;
  FStatus.free;
  FCategory.free;
  FCode.free;
  FNotPerformed.free;
  FReasonNotPerformedList.Free;
  FBodySiteList.Free;
  FReason.free;
  FPerformerList.Free;
  FPerformed.free;
  FEncounter.free;
  FLocation.free;
  FOutcome.free;
  FReportList.Free;
  FComplicationList.Free;
  FFollowUpList.Free;
  FRequest.free;
  FNotesList.Free;
  FFocalDeviceList.Free;
  FUsedList.Free;
  inherited;
end;

function TFhirProcedure.GetResourceType : TFhirResourceType;
begin
  result := frtProcedure;
end;

procedure TFhirProcedure.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirProcedure(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirProcedure(oSource).FIdentifierList);
  end;
  subject := TFhirProcedure(oSource).subject.Clone;
  FStatus := TFhirProcedure(oSource).FStatus.Link;
  category := TFhirProcedure(oSource).category.Clone;
  code := TFhirProcedure(oSource).code.Clone;
  notPerformedElement := TFhirProcedure(oSource).notPerformedElement.Clone;
  if (TFhirProcedure(oSource).FReasonNotPerformedList = nil) then
  begin
    FReasonNotPerformedList.free;
    FReasonNotPerformedList := nil;
  end
  else
  begin
    if FReasonNotPerformedList = nil then
      FReasonNotPerformedList := TFhirCodeableConceptList.Create;
    FReasonNotPerformedList.Assign(TFhirProcedure(oSource).FReasonNotPerformedList);
  end;
  if (TFhirProcedure(oSource).FBodySiteList = nil) then
  begin
    FBodySiteList.free;
    FBodySiteList := nil;
  end
  else
  begin
    if FBodySiteList = nil then
      FBodySiteList := TFhirCodeableConceptList.Create;
    FBodySiteList.Assign(TFhirProcedure(oSource).FBodySiteList);
  end;
  reason := TFhirProcedure(oSource).reason.Clone;
  if (TFhirProcedure(oSource).FPerformerList = nil) then
  begin
    FPerformerList.free;
    FPerformerList := nil;
  end
  else
  begin
    if FPerformerList = nil then
      FPerformerList := TFhirProcedurePerformerList.Create;
    FPerformerList.Assign(TFhirProcedure(oSource).FPerformerList);
  end;
  performed := TFhirProcedure(oSource).performed.Clone;
  encounter := TFhirProcedure(oSource).encounter.Clone;
  location := TFhirProcedure(oSource).location.Clone;
  outcome := TFhirProcedure(oSource).outcome.Clone;
  if (TFhirProcedure(oSource).FReportList = nil) then
  begin
    FReportList.free;
    FReportList := nil;
  end
  else
  begin
    if FReportList = nil then
      FReportList := TFhirReferenceList{TFhirDiagnosticReport}.Create;
    FReportList.Assign(TFhirProcedure(oSource).FReportList);
  end;
  if (TFhirProcedure(oSource).FComplicationList = nil) then
  begin
    FComplicationList.free;
    FComplicationList := nil;
  end
  else
  begin
    if FComplicationList = nil then
      FComplicationList := TFhirCodeableConceptList.Create;
    FComplicationList.Assign(TFhirProcedure(oSource).FComplicationList);
  end;
  if (TFhirProcedure(oSource).FFollowUpList = nil) then
  begin
    FFollowUpList.free;
    FFollowUpList := nil;
  end
  else
  begin
    if FFollowUpList = nil then
      FFollowUpList := TFhirCodeableConceptList.Create;
    FFollowUpList.Assign(TFhirProcedure(oSource).FFollowUpList);
  end;
  request := TFhirProcedure(oSource).request.Clone;
  if (TFhirProcedure(oSource).FNotesList = nil) then
  begin
    FNotesList.free;
    FNotesList := nil;
  end
  else
  begin
    if FNotesList = nil then
      FNotesList := TFhirAnnotationList.Create;
    FNotesList.Assign(TFhirProcedure(oSource).FNotesList);
  end;
  if (TFhirProcedure(oSource).FFocalDeviceList = nil) then
  begin
    FFocalDeviceList.free;
    FFocalDeviceList := nil;
  end
  else
  begin
    if FFocalDeviceList = nil then
      FFocalDeviceList := TFhirProcedureFocalDeviceList.Create;
    FFocalDeviceList.Assign(TFhirProcedure(oSource).FFocalDeviceList);
  end;
  if (TFhirProcedure(oSource).FUsedList = nil) then
  begin
    FUsedList.free;
    FUsedList := nil;
  end
  else
  begin
    if FUsedList = nil then
      FUsedList := TFhirReferenceList{Resource}.Create;
    FUsedList.Assign(TFhirProcedure(oSource).FUsedList);
  end;
end;

procedure TFhirProcedure.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'notPerformed') Then
     list.add(self.link, 'notPerformed', FNotPerformed.Link);
  if (child_name = 'reasonNotPerformed') Then
    list.addAll(self, 'reasonNotPerformed', FReasonNotPerformedList);
  if (child_name = 'bodySite') Then
    list.addAll(self, 'bodySite', FBodySiteList);
  if (child_name = 'reason[x]') or (child_name = 'reason') Then
     list.add(self.link, 'reason[x]', FReason.Link);
  if (child_name = 'performer') Then
    list.addAll(self, 'performer', FPerformerList);
  if (child_name = 'performed[x]') or (child_name = 'performed') Then
     list.add(self.link, 'performed[x]', FPerformed.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'report') Then
    list.addAll(self, 'report', FReportList);
  if (child_name = 'complication') Then
    list.addAll(self, 'complication', FComplicationList);
  if (child_name = 'followUp') Then
    list.addAll(self, 'followUp', FFollowUpList);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'notes') Then
    list.addAll(self, 'notes', FNotesList);
  if (child_name = 'focalDevice') Then
    list.addAll(self, 'focalDevice', FFocalDeviceList);
  if (child_name = 'used') Then
    list.addAll(self, 'used', FUsedList);
end;

procedure TFhirProcedure.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Group)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'notPerformed', 'boolean', false, TFhirBoolean, FNotPerformed.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reasonNotPerformed', 'CodeableConcept', true, TFhirCodeableConcept, FReasonNotPerformedList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', true, TFhirCodeableConcept, FBodySiteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reason[x]', 'CodeableConcept|Reference(Condition)', false, TFhirType, FReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'performer', '', true, TFhirProcedurePerformer, FPerformerList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'performed[x]', 'dateTime|Period', false, TFhirType, FPerformed.Link));{2}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference(Encounter)', false, TFhirReference{TFhirEncounter}, FEncounter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'location', 'Reference(Location)', false, TFhirReference{TFhirLocation}, FLocation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'outcome', 'CodeableConcept', false, TFhirCodeableConcept, FOutcome.Link));{2}
  oList.add(TFHIRProperty.create(self, 'report', 'Reference(DiagnosticReport)', true, TFhirReference{TFhirDiagnosticReport}, FReportList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'complication', 'CodeableConcept', true, TFhirCodeableConcept, FComplicationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'followUp', 'CodeableConcept', true, TFhirCodeableConcept, FFollowUpList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'request', 'Reference(CarePlan|DiagnosticOrder|ProcedureRequest|ReferralRequest)', false, TFhirReference{Resource}, FRequest.Link));{2}
  oList.add(TFHIRProperty.create(self, 'notes', 'Annotation', true, TFhirAnnotation, FNotesList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'focalDevice', '', true, TFhirProcedureFocalDevice, FFocalDeviceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'used', 'Reference(Device|Medication|Substance)', true, TFhirReference{Resource}, FUsedList.Link)){3};
end;

function TFhirProcedure.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirProcedureStatusEnum, CODES_TFhirProcedureStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'notPerformed') then
  begin
    NotPerformedElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'reasonNotPerformed') then
  begin
    ReasonNotPerformedList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySiteList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then
  begin
    Reason := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    PerformerList.add(propValue as TFhirProcedurePerformer){2a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'performed', ['DateTime', 'Period'])) then
  begin
    Performed := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference{TFhirEncounter}{4b};
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirReference{TFhirLocation}{4b};
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    Outcome := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'report') then
  begin
    ReportList.add(propValue as TFhirReference{TFhirDiagnosticReport}){2a};
    result := propValue;
  end
  else if (propName = 'complication') then
  begin
    ComplicationList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'followUp') then
  begin
    FollowUpList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'notes') then
  begin
    NotesList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else if (propName = 'focalDevice') then
  begin
    FocalDeviceList.add(propValue as TFhirProcedureFocalDevice){2a};
    result := propValue;
  end
  else if (propName = 'used') then
  begin
    UsedList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirProcedure.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'reasonNotPerformed') then ReasonNotPerformedList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'bodySite') then BodySiteList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'performer') then PerformerList.insertItem(index, propValue as TFhirProcedurePerformer){2a}
  else if (propName = 'report') then ReportList.insertItem(index, propValue as TFhirReference{TFhirDiagnosticReport}){2a}
  else if (propName = 'complication') then ComplicationList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'followUp') then FollowUpList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'notes') then NotesList.insertItem(index, propValue as TFhirAnnotation){2a}
  else if (propName = 'focalDevice') then FocalDeviceList.insertItem(index, propValue as TFhirProcedureFocalDevice){2a}
  else if (propName = 'used') then UsedList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else inherited;
end;

function TFhirProcedure.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'notPerformed') then result := TFhirBoolean.create() {5b}
  else if (propName = 'reasonNotPerformed') then result := ReasonNotPerformedList.new(){2}
  else if (propName = 'bodySite') then result := BodySiteList.new(){2}
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Reason'){4x}
  else if (propName = 'performer') then result := PerformerList.new(){2}
  else if (isMatchingName(propName, 'performed', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Performed'){4x}
  else if (propName = 'encounter') then result := TFhirReference{TFhirEncounter}.create(){4b}
  else if (propName = 'location') then result := TFhirReference{TFhirLocation}.create(){4b}
  else if (propName = 'outcome') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'report') then result := ReportList.new(){2}
  else if (propName = 'complication') then result := ComplicationList.new(){2}
  else if (propName = 'followUp') then result := FollowUpList.new(){2}
  else if (propName = 'request') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'notes') then result := NotesList.new(){2}
  else if (propName = 'focalDevice') then result := FocalDeviceList.new(){2}
  else if (propName = 'used') then result := UsedList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirProcedure.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'notPerformed') then result := 'boolean'
  else if (propName = 'reasonNotPerformed') then result := 'CodeableConcept'
  else if (propName = 'bodySite') then result := 'CodeableConcept'
  else if (propName = 'reason[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'performer') then result := ''
  else if (propName = 'performed[x]') then result := 'dateTime|Period'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'outcome') then result := 'CodeableConcept'
  else if (propName = 'report') then result := 'Reference'
  else if (propName = 'complication') then result := 'CodeableConcept'
  else if (propName = 'followUp') then result := 'CodeableConcept'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'notes') then result := 'Annotation'
  else if (propName = 'focalDevice') then result := ''
  else if (propName = 'used') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirProcedure.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'notPerformed') then NotPerformedElement := nil
  else if (propName = 'reasonNotPerformed') then deletePropertyValue('reasonNotPerformed', ReasonNotPerformedList, value) {2}
  else if (propName = 'bodySite') then deletePropertyValue('bodySite', BodySiteList, value) {2}
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then ReasonElement := nil{4x}
  else if (propName = 'performer') then deletePropertyValue('performer', PerformerList, value) {2}
  else if (isMatchingName(propName, 'performed', ['DateTime', 'Period'])) then PerformedElement := nil{4x}
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'report') then deletePropertyValue('report', ReportList, value) {2}
  else if (propName = 'complication') then deletePropertyValue('complication', ComplicationList, value) {2}
  else if (propName = 'followUp') then deletePropertyValue('followUp', FollowUpList, value) {2}
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'notes') then deletePropertyValue('notes', NotesList, value) {2}
  else if (propName = 'focalDevice') then deletePropertyValue('focalDevice', FocalDeviceList, value) {2}
  else if (propName = 'used') then deletePropertyValue('used', UsedList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirProcedure.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirProcedureStatusEnum, CODES_TFhirProcedureStatusEnum, new){4}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'notPerformed') then NotPerformedElement := asBoolean(new){5b}
  else if (propName = 'reasonNotPerformed') then replacePropertyValue('reasonNotPerformed', ReasonNotPerformedList, existing, new) {2}
  else if (propName = 'bodySite') then replacePropertyValue('bodySite', BodySiteList, existing, new) {2}
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then ReasonElement := new as TFhirType{4x}
  else if (propName = 'performer') then replacePropertyValue('performer', PerformerList, existing, new) {2}
  else if (isMatchingName(propName, 'performed', ['DateTime', 'Period'])) then PerformedElement := new as TFhirType{4x}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference{TFhirEncounter}{4}
  else if (propName = 'location') then LocationElement := new as TFhirReference{TFhirLocation}{4}
  else if (propName = 'outcome') then OutcomeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'report') then replacePropertyValue('report', ReportList, existing, new) {2}
  else if (propName = 'complication') then replacePropertyValue('complication', ComplicationList, existing, new) {2}
  else if (propName = 'followUp') then replacePropertyValue('followUp', FollowUpList, existing, new) {2}
  else if (propName = 'request') then RequestElement := new as TFhirReference{Resource}{4}
  else if (propName = 'notes') then replacePropertyValue('notes', NotesList, existing, new) {2}
  else if (propName = 'focalDevice') then replacePropertyValue('focalDevice', FocalDeviceList, existing, new) {2}
  else if (propName = 'used') then replacePropertyValue('used', UsedList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirProcedure.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'reasonNotPerformed') then ReasonNotPerformedList.move(source, destination){2a}
  else if (propName = 'bodySite') then BodySiteList.move(source, destination){2a}
  else if (propName = 'performer') then PerformerList.move(source, destination){2a}
  else if (propName = 'report') then ReportList.move(source, destination){2a}
  else if (propName = 'complication') then ComplicationList.move(source, destination){2a}
  else if (propName = 'followUp') then FollowUpList.move(source, destination){2a}
  else if (propName = 'notes') then NotesList.move(source, destination){2a}
  else if (propName = 'focalDevice') then FocalDeviceList.move(source, destination){2a}
  else if (propName = 'used') then UsedList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirProcedure.fhirType : string;
begin
  result := 'Procedure';
end;

function TFhirProcedure.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FSubject) and isEmptyProp(FStatus) and isEmptyProp(FCategory) and isEmptyProp(FCode) and isEmptyProp(FNotPerformed) and isEmptyProp(FreasonNotPerformedList) and isEmptyProp(FbodySiteList) and isEmptyProp(FReason) and isEmptyProp(FperformerList) and isEmptyProp(FPerformed) and isEmptyProp(FEncounter) and isEmptyProp(FLocation) and isEmptyProp(FOutcome) and isEmptyProp(FreportList) and isEmptyProp(FcomplicationList) and isEmptyProp(FfollowUpList) and isEmptyProp(FRequest) and isEmptyProp(FnotesList) and isEmptyProp(FfocalDeviceList) and isEmptyProp(FusedList);
end;

function TFhirProcedure.equals(other : TObject) : boolean;
var
  o : TFhirProcedure;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirProcedure)) then
    result := false
  else
  begin
    o := TFhirProcedure(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(subjectElement, o.subjectElement, true) and
      compareDeep(statusElement, o.statusElement, true) and compareDeep(categoryElement, o.categoryElement, true) and
      compareDeep(codeElement, o.codeElement, true) and compareDeep(notPerformedElement, o.notPerformedElement, true) and
      compareDeep(reasonNotPerformedList, o.reasonNotPerformedList, true) and compareDeep(bodySiteList, o.bodySiteList, true) and
      compareDeep(reasonElement, o.reasonElement, true) and compareDeep(performerList, o.performerList, true) and
      compareDeep(performedElement, o.performedElement, true) and compareDeep(encounterElement, o.encounterElement, true) and
      compareDeep(locationElement, o.locationElement, true) and compareDeep(outcomeElement, o.outcomeElement, true) and
      compareDeep(reportList, o.reportList, true) and compareDeep(complicationList, o.complicationList, true) and
      compareDeep(followUpList, o.followUpList, true) and compareDeep(requestElement, o.requestElement, true) and
      compareDeep(notesList, o.notesList, true) and compareDeep(focalDeviceList, o.focalDeviceList, true) and
      compareDeep(usedList, o.usedList, true);
  end;
end;

function TFhirProcedure.Link : TFhirProcedure;
begin
  result := TFhirProcedure(inherited Link);
end;

function TFhirProcedure.Clone : TFhirProcedure;
begin
  result := TFhirProcedure(inherited Clone);
end;

procedure TFhirProcedure.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('subject');
  fields.add('status');
  fields.add('category');
  fields.add('code');
  fields.add('notPerformed');
  fields.add('reasonNotPerformed');
  fields.add('bodySite');
  fields.add('reason[x]');
  fields.add('performer');
  fields.add('performed[x]');
  fields.add('encounter');
  fields.add('location');
  fields.add('outcome');
  fields.add('report');
  fields.add('complication');
  fields.add('followUp');
  fields.add('request');
  fields.add('notes');
  fields.add('focalDevice');
  fields.add('used');
end;

{ TFhirProcedure }

Function TFhirProcedure.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirProcedure.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirProcedure.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirProcedure.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirProcedure.GetStatusST : TFhirProcedureStatusEnum;
begin
  if FStatus = nil then
    result := TFhirProcedureStatusEnum(0)
  else
    result := TFhirProcedureStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirProcedureStatusEnum, FStatus.value));
end;

Procedure TFhirProcedure.SetStatusST(value : TFhirProcedureStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirProcedureStatusEnum[value], CODES_TFhirProcedureStatusEnum[value]);
end;

Procedure TFhirProcedure.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirProcedure.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirProcedure.SetNotPerformed(value : TFhirBoolean);
begin
  FNotPerformed.free;
  FNotPerformed := value;
end;

Function TFhirProcedure.GetNotPerformedST : Boolean;
begin
  if FNotPerformed = nil then
    result := false
  else
    result := FNotPerformed.value;
end;

Procedure TFhirProcedure.SetNotPerformedST(value : Boolean);
begin
  if FNotPerformed = nil then
    FNotPerformed := TFhirBoolean.create;
  FNotPerformed.value := value
end;

Function TFhirProcedure.GetReasonNotPerformedList : TFhirCodeableConceptList;
begin
  if FReasonNotPerformedList = nil then
    FReasonNotPerformedList := TFhirCodeableConceptList.Create;
  result := FReasonNotPerformedList;
end;

Function TFhirProcedure.GetHasReasonNotPerformedList : boolean;
begin
  result := (FReasonNotPerformedList <> nil) and (FReasonNotPerformedList.count > 0);
end;

Function TFhirProcedure.GetBodySiteList : TFhirCodeableConceptList;
begin
  if FBodySiteList = nil then
    FBodySiteList := TFhirCodeableConceptList.Create;
  result := FBodySiteList;
end;

Function TFhirProcedure.GetHasBodySiteList : boolean;
begin
  result := (FBodySiteList <> nil) and (FBodySiteList.count > 0);
end;

Procedure TFhirProcedure.SetReason(value : TFhirType);
begin
  FReason.free;
  FReason := value;
end;

Function TFhirProcedure.GetPerformerList : TFhirProcedurePerformerList;
begin
  if FPerformerList = nil then
    FPerformerList := TFhirProcedurePerformerList.Create;
  result := FPerformerList;
end;

Function TFhirProcedure.GetHasPerformerList : boolean;
begin
  result := (FPerformerList <> nil) and (FPerformerList.count > 0);
end;

Procedure TFhirProcedure.SetPerformed(value : TFhirType);
begin
  FPerformed.free;
  FPerformed := value;
end;

Procedure TFhirProcedure.SetEncounter(value : TFhirReference{TFhirEncounter});
begin
  FEncounter.free;
  FEncounter := value;
end;

Procedure TFhirProcedure.SetLocation(value : TFhirReference{TFhirLocation});
begin
  FLocation.free;
  FLocation := value;
end;

Procedure TFhirProcedure.SetOutcome(value : TFhirCodeableConcept);
begin
  FOutcome.free;
  FOutcome := value;
end;

Function TFhirProcedure.GetReportList : TFhirReferenceList{TFhirDiagnosticReport};
begin
  if FReportList = nil then
    FReportList := TFhirReferenceList{TFhirDiagnosticReport}.Create;
  result := FReportList;
end;

Function TFhirProcedure.GetHasReportList : boolean;
begin
  result := (FReportList <> nil) and (FReportList.count > 0);
end;

Function TFhirProcedure.GetComplicationList : TFhirCodeableConceptList;
begin
  if FComplicationList = nil then
    FComplicationList := TFhirCodeableConceptList.Create;
  result := FComplicationList;
end;

Function TFhirProcedure.GetHasComplicationList : boolean;
begin
  result := (FComplicationList <> nil) and (FComplicationList.count > 0);
end;

Function TFhirProcedure.GetFollowUpList : TFhirCodeableConceptList;
begin
  if FFollowUpList = nil then
    FFollowUpList := TFhirCodeableConceptList.Create;
  result := FFollowUpList;
end;

Function TFhirProcedure.GetHasFollowUpList : boolean;
begin
  result := (FFollowUpList <> nil) and (FFollowUpList.count > 0);
end;

Procedure TFhirProcedure.SetRequest(value : TFhirReference{Resource});
begin
  FRequest.free;
  FRequest := value;
end;

Function TFhirProcedure.GetNotesList : TFhirAnnotationList;
begin
  if FNotesList = nil then
    FNotesList := TFhirAnnotationList.Create;
  result := FNotesList;
end;

Function TFhirProcedure.GetHasNotesList : boolean;
begin
  result := (FNotesList <> nil) and (FNotesList.count > 0);
end;

Function TFhirProcedure.GetFocalDeviceList : TFhirProcedureFocalDeviceList;
begin
  if FFocalDeviceList = nil then
    FFocalDeviceList := TFhirProcedureFocalDeviceList.Create;
  result := FFocalDeviceList;
end;

Function TFhirProcedure.GetHasFocalDeviceList : boolean;
begin
  result := (FFocalDeviceList <> nil) and (FFocalDeviceList.count > 0);
end;

Function TFhirProcedure.GetUsedList : TFhirReferenceList{Resource};
begin
  if FUsedList = nil then
    FUsedList := TFhirReferenceList{Resource}.Create;
  result := FUsedList;
end;

Function TFhirProcedure.GetHasUsedList : boolean;
begin
  result := (FUsedList <> nil) and (FUsedList.count > 0);
end;

function TFhirProcedure.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FNotPerformed.sizeInBytes);
  inc(result, FreasonNotPerformedList.sizeInBytes);
  inc(result, FbodySiteList.sizeInBytes);
  inc(result, FReason.sizeInBytes);
  inc(result, FperformerList.sizeInBytes);
  inc(result, FPerformed.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FLocation.sizeInBytes);
  inc(result, FOutcome.sizeInBytes);
  inc(result, FreportList.sizeInBytes);
  inc(result, FcomplicationList.sizeInBytes);
  inc(result, FfollowUpList.sizeInBytes);
  inc(result, FRequest.sizeInBytes);
  inc(result, FnotesList.sizeInBytes);
  inc(result, FfocalDeviceList.sizeInBytes);
  inc(result, FusedList.sizeInBytes);
end;

{ TFhirProcedureListEnumerator }

Constructor TFhirProcedureListEnumerator.Create(list : TFhirProcedureList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirProcedureListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProcedureListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirProcedureListEnumerator.GetCurrent : TFhirProcedure;
begin
  Result := FList[FIndex];
end;

function TFhirProcedureListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirProcedureList }
procedure TFhirProcedureList.AddItem(value: TFhirProcedure);
begin
  assert(value.ClassName = 'TFhirProcedure', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProcedure');
  add(value);
end;

function TFhirProcedureList.Append: TFhirProcedure;
begin
  result := TFhirProcedure.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcedureList.ClearItems;
begin
  Clear;
end;

function TFhirProcedureList.GetEnumerator : TFhirProcedureListEnumerator;
begin
  result := TFhirProcedureListEnumerator.Create(self.link);
end;

function TFhirProcedureList.Clone: TFhirProcedureList;
begin
  result := TFhirProcedureList(inherited Clone);
end;

function TFhirProcedureList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProcedureList.GetItemN(index: Integer): TFhirProcedure;
begin
  result := TFhirProcedure(ObjectByIndex[index]);
end;

function TFhirProcedureList.ItemClass: TFslObjectClass;
begin
  result := TFhirProcedure;
end;
function TFhirProcedureList.IndexOf(value: TFhirProcedure): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirProcedureList.Insert(index: Integer): TFhirProcedure;
begin
  result := TFhirProcedure.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcedureList.InsertItem(index: Integer; value: TFhirProcedure);
begin
  assert(value is TFhirProcedure);
  Inherited Insert(index, value);
end;

function TFhirProcedureList.Item(index: Integer): TFhirProcedure;
begin
  result := TFhirProcedure(ObjectByIndex[index]);
end;

function TFhirProcedureList.Link: TFhirProcedureList;
begin
  result := TFhirProcedureList(inherited Link);
end;

procedure TFhirProcedureList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProcedureList.SetItemByIndex(index: Integer; value: TFhirProcedure);
begin
  assert(value is TFhirProcedure);
  FhirProcedures[index] := value;
end;

procedure TFhirProcedureList.SetItemN(index: Integer; value: TFhirProcedure);
begin
  assert(value is TFhirProcedure);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PROCEDURE}

{$IFDEF FHIR_PROCEDUREREQUEST}

{ TFhirProcedureRequest }

constructor TFhirProcedureRequest.Create;
begin
  inherited;
end;

destructor TFhirProcedureRequest.Destroy;
begin
  FIdentifierList.Free;
  FSubject.free;
  FCode.free;
  FBodySiteList.Free;
  FReason.free;
  FScheduled.free;
  FEncounter.free;
  FPerformer.free;
  FStatus.free;
  FNotesList.Free;
  FAsNeeded.free;
  FOrderedOn.free;
  FOrderer.free;
  FPriority.free;
  inherited;
end;

function TFhirProcedureRequest.GetResourceType : TFhirResourceType;
begin
  result := frtProcedureRequest;
end;

procedure TFhirProcedureRequest.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirProcedureRequest(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirProcedureRequest(oSource).FIdentifierList);
  end;
  subject := TFhirProcedureRequest(oSource).subject.Clone;
  code := TFhirProcedureRequest(oSource).code.Clone;
  if (TFhirProcedureRequest(oSource).FBodySiteList = nil) then
  begin
    FBodySiteList.free;
    FBodySiteList := nil;
  end
  else
  begin
    if FBodySiteList = nil then
      FBodySiteList := TFhirCodeableConceptList.Create;
    FBodySiteList.Assign(TFhirProcedureRequest(oSource).FBodySiteList);
  end;
  reason := TFhirProcedureRequest(oSource).reason.Clone;
  scheduled := TFhirProcedureRequest(oSource).scheduled.Clone;
  encounter := TFhirProcedureRequest(oSource).encounter.Clone;
  performer := TFhirProcedureRequest(oSource).performer.Clone;
  FStatus := TFhirProcedureRequest(oSource).FStatus.Link;
  if (TFhirProcedureRequest(oSource).FNotesList = nil) then
  begin
    FNotesList.free;
    FNotesList := nil;
  end
  else
  begin
    if FNotesList = nil then
      FNotesList := TFhirAnnotationList.Create;
    FNotesList.Assign(TFhirProcedureRequest(oSource).FNotesList);
  end;
  asNeeded := TFhirProcedureRequest(oSource).asNeeded.Clone;
  orderedOnElement := TFhirProcedureRequest(oSource).orderedOnElement.Clone;
  orderer := TFhirProcedureRequest(oSource).orderer.Clone;
  FPriority := TFhirProcedureRequest(oSource).FPriority.Link;
end;

procedure TFhirProcedureRequest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'bodySite') Then
    list.addAll(self, 'bodySite', FBodySiteList);
  if (child_name = 'reason[x]') or (child_name = 'reason') Then
     list.add(self.link, 'reason[x]', FReason.Link);
  if (child_name = 'scheduled[x]') or (child_name = 'scheduled') Then
     list.add(self.link, 'scheduled[x]', FScheduled.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'performer') Then
     list.add(self.link, 'performer', FPerformer.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'notes') Then
    list.addAll(self, 'notes', FNotesList);
  if (child_name = 'asNeeded[x]') or (child_name = 'asNeeded') Then
     list.add(self.link, 'asNeeded[x]', FAsNeeded.Link);
  if (child_name = 'orderedOn') Then
     list.add(self.link, 'orderedOn', FOrderedOn.Link);
  if (child_name = 'orderer') Then
     list.add(self.link, 'orderer', FOrderer.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
end;

procedure TFhirProcedureRequest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Group)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', true, TFhirCodeableConcept, FBodySiteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reason[x]', 'CodeableConcept|Reference(Condition)', false, TFhirType, FReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'scheduled[x]', 'dateTime|Period|Timing', false, TFhirType, FScheduled.Link));{2}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference(Encounter)', false, TFhirReference{TFhirEncounter}, FEncounter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'performer', 'Reference(Practitioner|Organization|Patient|RelatedPerson)', false, TFhirReference{Resource}, FPerformer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'notes', 'Annotation', true, TFhirAnnotation, FNotesList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'asNeeded[x]', 'boolean|CodeableConcept', false, TFhirType, FAsNeeded.Link));{2}
  oList.add(TFHIRProperty.create(self, 'orderedOn', 'dateTime', false, TFhirDateTime, FOrderedOn.Link));{2}
  oList.add(TFHIRProperty.create(self, 'orderer', 'Reference(Practitioner|Patient|RelatedPerson|Device)', false, TFhirReference{Resource}, FOrderer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'priority', 'code', false, TFHIREnum, FPriority.Link));{1}
end;

function TFhirProcedureRequest.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySiteList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then
  begin
    Reason := propValue as TFhirType{4};
    result := propValue;
  end
  else if (isMatchingName(propName, 'scheduled', ['DateTime', 'Period', 'Timing'])) then
  begin
    Scheduled := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference{TFhirEncounter}{4b};
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    Performer := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirProcedureRequestStatusEnum, CODES_TFhirProcedureRequestStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'notes') then
  begin
    NotesList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'asNeeded', ['Boolean', 'CodeableConcept'])) then
  begin
    AsNeeded := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'orderedOn') then
  begin
    OrderedOnElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'orderer') then
  begin
    Orderer := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asEnum(SYSTEMS_TFhirProcedureRequestPriorityEnum, CODES_TFhirProcedureRequestPriorityEnum, propValue);
    result := propValue
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirProcedureRequest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'bodySite') then BodySiteList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'notes') then NotesList.insertItem(index, propValue as TFhirAnnotation){2a}
  else inherited;
end;

function TFhirProcedureRequest.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'bodySite') then result := BodySiteList.new(){2}
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Reason'){4x}
  else if (isMatchingName(propName, 'scheduled', ['DateTime', 'Period', 'Timing'])) then raise EFHIRException.create('Cannot make property Scheduled'){4x}
  else if (propName = 'encounter') then result := TFhirReference{TFhirEncounter}.create(){4b}
  else if (propName = 'performer') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'notes') then result := NotesList.new(){2}
  else if (isMatchingName(propName, 'asNeeded', ['Boolean', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property AsNeeded'){4x}
  else if (propName = 'orderedOn') then result := TFhirDateTime.create() {5b}
  else if (propName = 'orderer') then result := TFhirReference{Resource}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirProcedureRequest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'bodySite') then result := 'CodeableConcept'
  else if (propName = 'reason[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'scheduled[x]') then result := 'dateTime|Period|Timing'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'performer') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'notes') then result := 'Annotation'
  else if (propName = 'asNeeded[x]') then result := 'boolean|CodeableConcept'
  else if (propName = 'orderedOn') then result := 'dateTime'
  else if (propName = 'orderer') then result := 'Reference'
  else if (propName = 'priority') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirProcedureRequest.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'bodySite') then deletePropertyValue('bodySite', BodySiteList, value) {2}
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then ReasonElement := nil{4x}
  else if (isMatchingName(propName, 'scheduled', ['DateTime', 'Period', 'Timing'])) then ScheduledElement := nil{4x}
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'performer') then PerformerElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'notes') then deletePropertyValue('notes', NotesList, value) {2}
  else if (isMatchingName(propName, 'asNeeded', ['Boolean', 'CodeableConcept'])) then AsNeededElement := nil{4x}
  else if (propName = 'orderedOn') then OrderedOnElement := nil
  else if (propName = 'orderer') then OrdererElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirProcedureRequest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'bodySite') then replacePropertyValue('bodySite', BodySiteList, existing, new) {2}
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then ReasonElement := new as TFhirType{4x}
  else if (isMatchingName(propName, 'scheduled', ['DateTime', 'Period', 'Timing'])) then ScheduledElement := new as TFhirType{4x}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference{TFhirEncounter}{4}
  else if (propName = 'performer') then PerformerElement := new as TFhirReference{Resource}{4}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirProcedureRequestStatusEnum, CODES_TFhirProcedureRequestStatusEnum, new){4}
  else if (propName = 'notes') then replacePropertyValue('notes', NotesList, existing, new) {2}
  else if (isMatchingName(propName, 'asNeeded', ['Boolean', 'CodeableConcept'])) then AsNeededElement := new as TFhirType{4x}
  else if (propName = 'orderedOn') then OrderedOnElement := asDateTime(new){5b}
  else if (propName = 'orderer') then OrdererElement := new as TFhirReference{Resource}{4}
  else if (propName = 'priority') then PriorityElement := asEnum(SYSTEMS_TFhirProcedureRequestPriorityEnum, CODES_TFhirProcedureRequestPriorityEnum, new){4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirProcedureRequest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'bodySite') then BodySiteList.move(source, destination){2a}
  else if (propName = 'notes') then NotesList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirProcedureRequest.fhirType : string;
begin
  result := 'ProcedureRequest';
end;

function TFhirProcedureRequest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FSubject) and isEmptyProp(FCode) and isEmptyProp(FbodySiteList) and isEmptyProp(FReason) and isEmptyProp(FScheduled) and isEmptyProp(FEncounter) and isEmptyProp(FPerformer) and isEmptyProp(FStatus) and isEmptyProp(FnotesList) and isEmptyProp(FAsNeeded) and isEmptyProp(FOrderedOn) and isEmptyProp(FOrderer) and isEmptyProp(FPriority);
end;

function TFhirProcedureRequest.equals(other : TObject) : boolean;
var
  o : TFhirProcedureRequest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirProcedureRequest)) then
    result := false
  else
  begin
    o := TFhirProcedureRequest(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(subjectElement, o.subjectElement, true) and
      compareDeep(codeElement, o.codeElement, true) and compareDeep(bodySiteList, o.bodySiteList, true) and
      compareDeep(reasonElement, o.reasonElement, true) and compareDeep(scheduledElement, o.scheduledElement, true) and
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(performerElement, o.performerElement, true) and
      compareDeep(statusElement, o.statusElement, true) and compareDeep(notesList, o.notesList, true) and
      compareDeep(asNeededElement, o.asNeededElement, true) and compareDeep(orderedOnElement, o.orderedOnElement, true) and
      compareDeep(ordererElement, o.ordererElement, true) and compareDeep(priorityElement, o.priorityElement, true);
  end;
end;

function TFhirProcedureRequest.Link : TFhirProcedureRequest;
begin
  result := TFhirProcedureRequest(inherited Link);
end;

function TFhirProcedureRequest.Clone : TFhirProcedureRequest;
begin
  result := TFhirProcedureRequest(inherited Clone);
end;

procedure TFhirProcedureRequest.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('subject');
  fields.add('code');
  fields.add('bodySite');
  fields.add('reason[x]');
  fields.add('scheduled[x]');
  fields.add('encounter');
  fields.add('performer');
  fields.add('status');
  fields.add('notes');
  fields.add('asNeeded[x]');
  fields.add('orderedOn');
  fields.add('orderer');
  fields.add('priority');
end;

{ TFhirProcedureRequest }

Function TFhirProcedureRequest.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirProcedureRequest.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirProcedureRequest.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirProcedureRequest.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirProcedureRequest.GetBodySiteList : TFhirCodeableConceptList;
begin
  if FBodySiteList = nil then
    FBodySiteList := TFhirCodeableConceptList.Create;
  result := FBodySiteList;
end;

Function TFhirProcedureRequest.GetHasBodySiteList : boolean;
begin
  result := (FBodySiteList <> nil) and (FBodySiteList.count > 0);
end;

Procedure TFhirProcedureRequest.SetReason(value : TFhirType);
begin
  FReason.free;
  FReason := value;
end;

Procedure TFhirProcedureRequest.SetScheduled(value : TFhirType);
begin
  FScheduled.free;
  FScheduled := value;
end;

Procedure TFhirProcedureRequest.SetEncounter(value : TFhirReference{TFhirEncounter});
begin
  FEncounter.free;
  FEncounter := value;
end;

Procedure TFhirProcedureRequest.SetPerformer(value : TFhirReference{Resource});
begin
  FPerformer.free;
  FPerformer := value;
end;

Procedure TFhirProcedureRequest.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirProcedureRequest.GetStatusST : TFhirProcedureRequestStatusEnum;
begin
  if FStatus = nil then
    result := TFhirProcedureRequestStatusEnum(0)
  else
    result := TFhirProcedureRequestStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirProcedureRequestStatusEnum, FStatus.value));
end;

Procedure TFhirProcedureRequest.SetStatusST(value : TFhirProcedureRequestStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirProcedureRequestStatusEnum[value], CODES_TFhirProcedureRequestStatusEnum[value]);
end;

Function TFhirProcedureRequest.GetNotesList : TFhirAnnotationList;
begin
  if FNotesList = nil then
    FNotesList := TFhirAnnotationList.Create;
  result := FNotesList;
end;

Function TFhirProcedureRequest.GetHasNotesList : boolean;
begin
  result := (FNotesList <> nil) and (FNotesList.count > 0);
end;

Procedure TFhirProcedureRequest.SetAsNeeded(value : TFhirType);
begin
  FAsNeeded.free;
  FAsNeeded := value;
end;

Procedure TFhirProcedureRequest.SetOrderedOn(value : TFhirDateTime);
begin
  FOrderedOn.free;
  FOrderedOn := value;
end;

Function TFhirProcedureRequest.GetOrderedOnST : TFslDateTime;
begin
  if FOrderedOn = nil then
    result := TFslDateTime.makeNull
  else
    result := FOrderedOn.value;
end;

Procedure TFhirProcedureRequest.SetOrderedOnST(value : TFslDateTime);
begin
  if FOrderedOn = nil then
    FOrderedOn := TFhirDateTime.create;
  FOrderedOn.value := value
end;

Procedure TFhirProcedureRequest.SetOrderer(value : TFhirReference{Resource});
begin
  FOrderer.free;
  FOrderer := value;
end;

Procedure TFhirProcedureRequest.SetPriority(value : TFhirEnum);
begin
  FPriority.free;
  FPriority := value;
end;

Function TFhirProcedureRequest.GetPriorityST : TFhirProcedureRequestPriorityEnum;
begin
  if FPriority = nil then
    result := TFhirProcedureRequestPriorityEnum(0)
  else
    result := TFhirProcedureRequestPriorityEnum(StringArrayIndexOfSensitive(CODES_TFhirProcedureRequestPriorityEnum, FPriority.value));
end;

Procedure TFhirProcedureRequest.SetPriorityST(value : TFhirProcedureRequestPriorityEnum);
begin
  if ord(value) = 0 then
    PriorityElement := nil
  else
    PriorityElement := TFhirEnum.create(SYSTEMS_TFhirProcedureRequestPriorityEnum[value], CODES_TFhirProcedureRequestPriorityEnum[value]);
end;

function TFhirProcedureRequest.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FbodySiteList.sizeInBytes);
  inc(result, FReason.sizeInBytes);
  inc(result, FScheduled.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FPerformer.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FnotesList.sizeInBytes);
  inc(result, FAsNeeded.sizeInBytes);
  inc(result, FOrderedOn.sizeInBytes);
  inc(result, FOrderer.sizeInBytes);
  inc(result, FPriority.sizeInBytes);
end;

{ TFhirProcedureRequestListEnumerator }

Constructor TFhirProcedureRequestListEnumerator.Create(list : TFhirProcedureRequestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirProcedureRequestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProcedureRequestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirProcedureRequestListEnumerator.GetCurrent : TFhirProcedureRequest;
begin
  Result := FList[FIndex];
end;

function TFhirProcedureRequestListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirProcedureRequestList }
procedure TFhirProcedureRequestList.AddItem(value: TFhirProcedureRequest);
begin
  assert(value.ClassName = 'TFhirProcedureRequest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProcedureRequest');
  add(value);
end;

function TFhirProcedureRequestList.Append: TFhirProcedureRequest;
begin
  result := TFhirProcedureRequest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcedureRequestList.ClearItems;
begin
  Clear;
end;

function TFhirProcedureRequestList.GetEnumerator : TFhirProcedureRequestListEnumerator;
begin
  result := TFhirProcedureRequestListEnumerator.Create(self.link);
end;

function TFhirProcedureRequestList.Clone: TFhirProcedureRequestList;
begin
  result := TFhirProcedureRequestList(inherited Clone);
end;

function TFhirProcedureRequestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProcedureRequestList.GetItemN(index: Integer): TFhirProcedureRequest;
begin
  result := TFhirProcedureRequest(ObjectByIndex[index]);
end;

function TFhirProcedureRequestList.ItemClass: TFslObjectClass;
begin
  result := TFhirProcedureRequest;
end;
function TFhirProcedureRequestList.IndexOf(value: TFhirProcedureRequest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirProcedureRequestList.Insert(index: Integer): TFhirProcedureRequest;
begin
  result := TFhirProcedureRequest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcedureRequestList.InsertItem(index: Integer; value: TFhirProcedureRequest);
begin
  assert(value is TFhirProcedureRequest);
  Inherited Insert(index, value);
end;

function TFhirProcedureRequestList.Item(index: Integer): TFhirProcedureRequest;
begin
  result := TFhirProcedureRequest(ObjectByIndex[index]);
end;

function TFhirProcedureRequestList.Link: TFhirProcedureRequestList;
begin
  result := TFhirProcedureRequestList(inherited Link);
end;

procedure TFhirProcedureRequestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProcedureRequestList.SetItemByIndex(index: Integer; value: TFhirProcedureRequest);
begin
  assert(value is TFhirProcedureRequest);
  FhirProcedureRequests[index] := value;
end;

procedure TFhirProcedureRequestList.SetItemN(index: Integer; value: TFhirProcedureRequest);
begin
  assert(value is TFhirProcedureRequest);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PROCEDUREREQUEST}

{$IFDEF FHIR_QUESTIONNAIRERESPONSE}

{ TFhirQuestionnaireResponseGroup }

constructor TFhirQuestionnaireResponseGroup.Create;
begin
  inherited;
end;

destructor TFhirQuestionnaireResponseGroup.Destroy;
begin
  FLinkId.free;
  FTitle.free;
  FText.free;
  FSubject.free;
  FGroupList.Free;
  FQuestionList.Free;
  inherited;
end;

procedure TFhirQuestionnaireResponseGroup.Assign(oSource : TFslObject);
begin
  inherited;
  linkIdElement := TFhirQuestionnaireResponseGroup(oSource).linkIdElement.Clone;
  titleElement := TFhirQuestionnaireResponseGroup(oSource).titleElement.Clone;
  textElement := TFhirQuestionnaireResponseGroup(oSource).textElement.Clone;
  subject := TFhirQuestionnaireResponseGroup(oSource).subject.Clone;
  if (TFhirQuestionnaireResponseGroup(oSource).FGroupList = nil) then
  begin
    FGroupList.free;
    FGroupList := nil;
  end
  else
  begin
    if FGroupList = nil then
      FGroupList := TFhirQuestionnaireResponseGroupList.Create;
    FGroupList.Assign(TFhirQuestionnaireResponseGroup(oSource).FGroupList);
  end;
  if (TFhirQuestionnaireResponseGroup(oSource).FQuestionList = nil) then
  begin
    FQuestionList.free;
    FQuestionList := nil;
  end
  else
  begin
    if FQuestionList = nil then
      FQuestionList := TFhirQuestionnaireResponseGroupQuestionList.Create;
    FQuestionList.Assign(TFhirQuestionnaireResponseGroup(oSource).FQuestionList);
  end;
end;

procedure TFhirQuestionnaireResponseGroup.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'linkId') Then
     list.add(self.link, 'linkId', FLinkId.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'group') Then
    list.addAll(self, 'group', FGroupList);
  if (child_name = 'question') Then
    list.addAll(self, 'question', FQuestionList);
end;

procedure TFhirQuestionnaireResponseGroup.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'linkId', 'string', false, TFhirString, FLinkId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));{2}
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Any)', false, TFhirReference{TFhirReference}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'group', '@QuestionnaireResponse.group', true, TFhirQuestionnaireResponseGroup, FGroupList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'question', '', true, TFhirQuestionnaireResponseGroupQuestion, FQuestionList.Link)){3};
end;

function TFhirQuestionnaireResponseGroup.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'linkId') then
  begin
    LinkIdElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'group') then
  begin
    GroupList.add(propValue as TFhirQuestionnaireResponseGroup){2a};
    result := propValue;
  end
  else if (propName = 'question') then
  begin
    QuestionList.add(propValue as TFhirQuestionnaireResponseGroupQuestion){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirQuestionnaireResponseGroup.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'group') then GroupList.insertItem(index, propValue as TFhirQuestionnaireResponseGroup){2a}
  else if (propName = 'question') then QuestionList.insertItem(index, propValue as TFhirQuestionnaireResponseGroupQuestion){2a}
  else inherited;
end;

function TFhirQuestionnaireResponseGroup.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'linkId') then result := TFhirString.create() {5b}
  else if (propName = 'title') then result := TFhirString.create() {5b}
  else if (propName = 'text') then result := TFhirString.create() {5b}
  else if (propName = 'subject') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'group') then result := GroupList.new(){2}
  else if (propName = 'question') then result := QuestionList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirQuestionnaireResponseGroup.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'linkId') then result := 'string'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'text') then result := 'string'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'group') then result := '@QuestionnaireResponse.group'
  else if (propName = 'question') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirQuestionnaireResponseGroup.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'linkId') then LinkIdElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'text') then TextElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'group') then deletePropertyValue('group', GroupList, value) {2}
  else if (propName = 'question') then deletePropertyValue('question', QuestionList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirQuestionnaireResponseGroup.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'linkId') then LinkIdElement := asString(new){5b}
  else if (propName = 'title') then TitleElement := asString(new){5b}
  else if (propName = 'text') then TextElement := asString(new){5b}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'group') then replacePropertyValue('group', GroupList, existing, new) {2}
  else if (propName = 'question') then replacePropertyValue('question', QuestionList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirQuestionnaireResponseGroup.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'group') then GroupList.move(source, destination){2a}
  else if (propName = 'question') then QuestionList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirQuestionnaireResponseGroup.fhirType : string;
begin
  result := 'group';
end;

function TFhirQuestionnaireResponseGroup.Link : TFhirQuestionnaireResponseGroup;
begin
  result := TFhirQuestionnaireResponseGroup(inherited Link);
end;

function TFhirQuestionnaireResponseGroup.Clone : TFhirQuestionnaireResponseGroup;
begin
  result := TFhirQuestionnaireResponseGroup(inherited Clone);
end;

function TFhirQuestionnaireResponseGroup.equals(other : TObject) : boolean;
var
  o : TFhirQuestionnaireResponseGroup;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirQuestionnaireResponseGroup)) then
    result := false
  else
  begin
    o := TFhirQuestionnaireResponseGroup(other);
    result := compareDeep(linkIdElement, o.linkIdElement, true) and compareDeep(titleElement, o.titleElement, true) and
      compareDeep(textElement, o.textElement, true) and compareDeep(subjectElement, o.subjectElement, true) and
      compareDeep(groupList, o.groupList, true) and compareDeep(questionList, o.questionList, true);
  end;
end;

function TFhirQuestionnaireResponseGroup.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLinkId) and isEmptyProp(FTitle) and isEmptyProp(FText) and isEmptyProp(FSubject) and isEmptyProp(FgroupList) and isEmptyProp(FquestionList);
end;

procedure TFhirQuestionnaireResponseGroup.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('linkId');
  fields.add('title');
  fields.add('text');
  fields.add('subject');
  fields.add('group');
  fields.add('question');
end;

{ TFhirQuestionnaireResponseGroup }

Procedure TFhirQuestionnaireResponseGroup.SetLinkId(value : TFhirString);
begin
  FLinkId.free;
  FLinkId := value;
end;

Function TFhirQuestionnaireResponseGroup.GetLinkIdST : String;
begin
  if FLinkId = nil then
    result := ''
  else
    result := FLinkId.value;
end;

Procedure TFhirQuestionnaireResponseGroup.SetLinkIdST(value : String);
begin
  if value <> '' then
  begin
    if FLinkId = nil then
      FLinkId := TFhirString.create;
    FLinkId.value := value
  end
  else if FLinkId <> nil then
    FLinkId.value := '';
end;

Procedure TFhirQuestionnaireResponseGroup.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

Function TFhirQuestionnaireResponseGroup.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

Procedure TFhirQuestionnaireResponseGroup.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

Procedure TFhirQuestionnaireResponseGroup.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

Function TFhirQuestionnaireResponseGroup.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

Procedure TFhirQuestionnaireResponseGroup.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

Procedure TFhirQuestionnaireResponseGroup.SetSubject(value : TFhirReference{TFhirReference});
begin
  FSubject.free;
  FSubject := value;
end;

Function TFhirQuestionnaireResponseGroup.GetGroupList : TFhirQuestionnaireResponseGroupList;
begin
  if FGroupList = nil then
    FGroupList := TFhirQuestionnaireResponseGroupList.Create;
  result := FGroupList;
end;

Function TFhirQuestionnaireResponseGroup.GetHasGroupList : boolean;
begin
  result := (FGroupList <> nil) and (FGroupList.count > 0);
end;

Function TFhirQuestionnaireResponseGroup.GetQuestionList : TFhirQuestionnaireResponseGroupQuestionList;
begin
  if FQuestionList = nil then
    FQuestionList := TFhirQuestionnaireResponseGroupQuestionList.Create;
  result := FQuestionList;
end;

Function TFhirQuestionnaireResponseGroup.GetHasQuestionList : boolean;
begin
  result := (FQuestionList <> nil) and (FQuestionList.count > 0);
end;

function TFhirQuestionnaireResponseGroup.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FLinkId.sizeInBytes);
  inc(result, FTitle.sizeInBytes);
  inc(result, FText.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FgroupList.sizeInBytes);
  inc(result, FquestionList.sizeInBytes);
end;

{ TFhirQuestionnaireResponseGroupListEnumerator }

Constructor TFhirQuestionnaireResponseGroupListEnumerator.Create(list : TFhirQuestionnaireResponseGroupList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirQuestionnaireResponseGroupListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirQuestionnaireResponseGroupListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirQuestionnaireResponseGroupListEnumerator.GetCurrent : TFhirQuestionnaireResponseGroup;
begin
  Result := FList[FIndex];
end;

function TFhirQuestionnaireResponseGroupListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirQuestionnaireResponseGroupList }
procedure TFhirQuestionnaireResponseGroupList.AddItem(value: TFhirQuestionnaireResponseGroup);
begin
  assert(value.ClassName = 'TFhirQuestionnaireResponseGroup', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirQuestionnaireResponseGroup');
  add(value);
end;

function TFhirQuestionnaireResponseGroupList.Append: TFhirQuestionnaireResponseGroup;
begin
  result := TFhirQuestionnaireResponseGroup.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireResponseGroupList.ClearItems;
begin
  Clear;
end;

function TFhirQuestionnaireResponseGroupList.GetEnumerator : TFhirQuestionnaireResponseGroupListEnumerator;
begin
  result := TFhirQuestionnaireResponseGroupListEnumerator.Create(self.link);
end;

function TFhirQuestionnaireResponseGroupList.Clone: TFhirQuestionnaireResponseGroupList;
begin
  result := TFhirQuestionnaireResponseGroupList(inherited Clone);
end;

function TFhirQuestionnaireResponseGroupList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirQuestionnaireResponseGroupList.GetItemN(index: Integer): TFhirQuestionnaireResponseGroup;
begin
  result := TFhirQuestionnaireResponseGroup(ObjectByIndex[index]);
end;

function TFhirQuestionnaireResponseGroupList.ItemClass: TFslObjectClass;
begin
  result := TFhirQuestionnaireResponseGroup;
end;
function TFhirQuestionnaireResponseGroupList.IndexOf(value: TFhirQuestionnaireResponseGroup): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirQuestionnaireResponseGroupList.Insert(index: Integer): TFhirQuestionnaireResponseGroup;
begin
  result := TFhirQuestionnaireResponseGroup.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireResponseGroupList.InsertItem(index: Integer; value: TFhirQuestionnaireResponseGroup);
begin
  assert(value is TFhirQuestionnaireResponseGroup);
  Inherited Insert(index, value);
end;

function TFhirQuestionnaireResponseGroupList.Item(index: Integer): TFhirQuestionnaireResponseGroup;
begin
  result := TFhirQuestionnaireResponseGroup(ObjectByIndex[index]);
end;

function TFhirQuestionnaireResponseGroupList.Link: TFhirQuestionnaireResponseGroupList;
begin
  result := TFhirQuestionnaireResponseGroupList(inherited Link);
end;

procedure TFhirQuestionnaireResponseGroupList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirQuestionnaireResponseGroupList.SetItemByIndex(index: Integer; value: TFhirQuestionnaireResponseGroup);
begin
  assert(value is TFhirQuestionnaireResponseGroup);
  FhirQuestionnaireResponseGroups[index] := value;
end;

procedure TFhirQuestionnaireResponseGroupList.SetItemN(index: Integer; value: TFhirQuestionnaireResponseGroup);
begin
  assert(value is TFhirQuestionnaireResponseGroup);
  ObjectByIndex[index] := value;
end;

{ TFhirQuestionnaireResponseGroupQuestion }

constructor TFhirQuestionnaireResponseGroupQuestion.Create;
begin
  inherited;
end;

destructor TFhirQuestionnaireResponseGroupQuestion.Destroy;
begin
  FLinkId.free;
  FText.free;
  FAnswerList.Free;
  inherited;
end;

procedure TFhirQuestionnaireResponseGroupQuestion.Assign(oSource : TFslObject);
begin
  inherited;
  linkIdElement := TFhirQuestionnaireResponseGroupQuestion(oSource).linkIdElement.Clone;
  textElement := TFhirQuestionnaireResponseGroupQuestion(oSource).textElement.Clone;
  if (TFhirQuestionnaireResponseGroupQuestion(oSource).FAnswerList = nil) then
  begin
    FAnswerList.free;
    FAnswerList := nil;
  end
  else
  begin
    if FAnswerList = nil then
      FAnswerList := TFhirQuestionnaireResponseGroupQuestionAnswerList.Create;
    FAnswerList.Assign(TFhirQuestionnaireResponseGroupQuestion(oSource).FAnswerList);
  end;
end;

procedure TFhirQuestionnaireResponseGroupQuestion.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'linkId') Then
     list.add(self.link, 'linkId', FLinkId.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'answer') Then
    list.addAll(self, 'answer', FAnswerList);
end;

procedure TFhirQuestionnaireResponseGroupQuestion.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'linkId', 'string', false, TFhirString, FLinkId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));{2}
  oList.add(TFHIRProperty.create(self, 'answer', '', true, TFhirQuestionnaireResponseGroupQuestionAnswer, FAnswerList.Link)){3};
end;

function TFhirQuestionnaireResponseGroupQuestion.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'linkId') then
  begin
    LinkIdElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'answer') then
  begin
    AnswerList.add(propValue as TFhirQuestionnaireResponseGroupQuestionAnswer){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirQuestionnaireResponseGroupQuestion.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'answer') then AnswerList.insertItem(index, propValue as TFhirQuestionnaireResponseGroupQuestionAnswer){2a}
  else inherited;
end;

function TFhirQuestionnaireResponseGroupQuestion.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'linkId') then result := TFhirString.create() {5b}
  else if (propName = 'text') then result := TFhirString.create() {5b}
  else if (propName = 'answer') then result := AnswerList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirQuestionnaireResponseGroupQuestion.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'linkId') then result := 'string'
  else if (propName = 'text') then result := 'string'
  else if (propName = 'answer') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirQuestionnaireResponseGroupQuestion.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'linkId') then LinkIdElement := nil
  else if (propName = 'text') then TextElement := nil
  else if (propName = 'answer') then deletePropertyValue('answer', AnswerList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirQuestionnaireResponseGroupQuestion.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'linkId') then LinkIdElement := asString(new){5b}
  else if (propName = 'text') then TextElement := asString(new){5b}
  else if (propName = 'answer') then replacePropertyValue('answer', AnswerList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirQuestionnaireResponseGroupQuestion.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'answer') then AnswerList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirQuestionnaireResponseGroupQuestion.fhirType : string;
begin
  result := 'question';
end;

function TFhirQuestionnaireResponseGroupQuestion.Link : TFhirQuestionnaireResponseGroupQuestion;
begin
  result := TFhirQuestionnaireResponseGroupQuestion(inherited Link);
end;

function TFhirQuestionnaireResponseGroupQuestion.Clone : TFhirQuestionnaireResponseGroupQuestion;
begin
  result := TFhirQuestionnaireResponseGroupQuestion(inherited Clone);
end;

function TFhirQuestionnaireResponseGroupQuestion.equals(other : TObject) : boolean;
var
  o : TFhirQuestionnaireResponseGroupQuestion;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirQuestionnaireResponseGroupQuestion)) then
    result := false
  else
  begin
    o := TFhirQuestionnaireResponseGroupQuestion(other);
    result := compareDeep(linkIdElement, o.linkIdElement, true) and compareDeep(textElement, o.textElement, true) and
      compareDeep(answerList, o.answerList, true);
  end;
end;

function TFhirQuestionnaireResponseGroupQuestion.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLinkId) and isEmptyProp(FText) and isEmptyProp(FanswerList);
end;

procedure TFhirQuestionnaireResponseGroupQuestion.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('linkId');
  fields.add('text');
  fields.add('answer');
end;

{ TFhirQuestionnaireResponseGroupQuestion }

Procedure TFhirQuestionnaireResponseGroupQuestion.SetLinkId(value : TFhirString);
begin
  FLinkId.free;
  FLinkId := value;
end;

Function TFhirQuestionnaireResponseGroupQuestion.GetLinkIdST : String;
begin
  if FLinkId = nil then
    result := ''
  else
    result := FLinkId.value;
end;

Procedure TFhirQuestionnaireResponseGroupQuestion.SetLinkIdST(value : String);
begin
  if value <> '' then
  begin
    if FLinkId = nil then
      FLinkId := TFhirString.create;
    FLinkId.value := value
  end
  else if FLinkId <> nil then
    FLinkId.value := '';
end;

Procedure TFhirQuestionnaireResponseGroupQuestion.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

Function TFhirQuestionnaireResponseGroupQuestion.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

Procedure TFhirQuestionnaireResponseGroupQuestion.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

Function TFhirQuestionnaireResponseGroupQuestion.GetAnswerList : TFhirQuestionnaireResponseGroupQuestionAnswerList;
begin
  if FAnswerList = nil then
    FAnswerList := TFhirQuestionnaireResponseGroupQuestionAnswerList.Create;
  result := FAnswerList;
end;

Function TFhirQuestionnaireResponseGroupQuestion.GetHasAnswerList : boolean;
begin
  result := (FAnswerList <> nil) and (FAnswerList.count > 0);
end;

function TFhirQuestionnaireResponseGroupQuestion.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FLinkId.sizeInBytes);
  inc(result, FText.sizeInBytes);
  inc(result, FanswerList.sizeInBytes);
end;

{ TFhirQuestionnaireResponseGroupQuestionListEnumerator }

Constructor TFhirQuestionnaireResponseGroupQuestionListEnumerator.Create(list : TFhirQuestionnaireResponseGroupQuestionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirQuestionnaireResponseGroupQuestionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirQuestionnaireResponseGroupQuestionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirQuestionnaireResponseGroupQuestionListEnumerator.GetCurrent : TFhirQuestionnaireResponseGroupQuestion;
begin
  Result := FList[FIndex];
end;

function TFhirQuestionnaireResponseGroupQuestionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirQuestionnaireResponseGroupQuestionList }
procedure TFhirQuestionnaireResponseGroupQuestionList.AddItem(value: TFhirQuestionnaireResponseGroupQuestion);
begin
  assert(value.ClassName = 'TFhirQuestionnaireResponseGroupQuestion', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirQuestionnaireResponseGroupQuestion');
  add(value);
end;

function TFhirQuestionnaireResponseGroupQuestionList.Append: TFhirQuestionnaireResponseGroupQuestion;
begin
  result := TFhirQuestionnaireResponseGroupQuestion.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireResponseGroupQuestionList.ClearItems;
begin
  Clear;
end;

function TFhirQuestionnaireResponseGroupQuestionList.GetEnumerator : TFhirQuestionnaireResponseGroupQuestionListEnumerator;
begin
  result := TFhirQuestionnaireResponseGroupQuestionListEnumerator.Create(self.link);
end;

function TFhirQuestionnaireResponseGroupQuestionList.Clone: TFhirQuestionnaireResponseGroupQuestionList;
begin
  result := TFhirQuestionnaireResponseGroupQuestionList(inherited Clone);
end;

function TFhirQuestionnaireResponseGroupQuestionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirQuestionnaireResponseGroupQuestionList.GetItemN(index: Integer): TFhirQuestionnaireResponseGroupQuestion;
begin
  result := TFhirQuestionnaireResponseGroupQuestion(ObjectByIndex[index]);
end;

function TFhirQuestionnaireResponseGroupQuestionList.ItemClass: TFslObjectClass;
begin
  result := TFhirQuestionnaireResponseGroupQuestion;
end;
function TFhirQuestionnaireResponseGroupQuestionList.IndexOf(value: TFhirQuestionnaireResponseGroupQuestion): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirQuestionnaireResponseGroupQuestionList.Insert(index: Integer): TFhirQuestionnaireResponseGroupQuestion;
begin
  result := TFhirQuestionnaireResponseGroupQuestion.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireResponseGroupQuestionList.InsertItem(index: Integer; value: TFhirQuestionnaireResponseGroupQuestion);
begin
  assert(value is TFhirQuestionnaireResponseGroupQuestion);
  Inherited Insert(index, value);
end;

function TFhirQuestionnaireResponseGroupQuestionList.Item(index: Integer): TFhirQuestionnaireResponseGroupQuestion;
begin
  result := TFhirQuestionnaireResponseGroupQuestion(ObjectByIndex[index]);
end;

function TFhirQuestionnaireResponseGroupQuestionList.Link: TFhirQuestionnaireResponseGroupQuestionList;
begin
  result := TFhirQuestionnaireResponseGroupQuestionList(inherited Link);
end;

procedure TFhirQuestionnaireResponseGroupQuestionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirQuestionnaireResponseGroupQuestionList.SetItemByIndex(index: Integer; value: TFhirQuestionnaireResponseGroupQuestion);
begin
  assert(value is TFhirQuestionnaireResponseGroupQuestion);
  FhirQuestionnaireResponseGroupQuestions[index] := value;
end;

procedure TFhirQuestionnaireResponseGroupQuestionList.SetItemN(index: Integer; value: TFhirQuestionnaireResponseGroupQuestion);
begin
  assert(value is TFhirQuestionnaireResponseGroupQuestion);
  ObjectByIndex[index] := value;
end;

{ TFhirQuestionnaireResponseGroupQuestionAnswer }

constructor TFhirQuestionnaireResponseGroupQuestionAnswer.Create;
begin
  inherited;
end;

destructor TFhirQuestionnaireResponseGroupQuestionAnswer.Destroy;
begin
  FValue.free;
  FGroupList.Free;
  inherited;
end;

procedure TFhirQuestionnaireResponseGroupQuestionAnswer.Assign(oSource : TFslObject);
begin
  inherited;
  value := TFhirQuestionnaireResponseGroupQuestionAnswer(oSource).value.Clone;
  if (TFhirQuestionnaireResponseGroupQuestionAnswer(oSource).FGroupList = nil) then
  begin
    FGroupList.free;
    FGroupList := nil;
  end
  else
  begin
    if FGroupList = nil then
      FGroupList := TFhirQuestionnaireResponseGroupList.Create;
    FGroupList.Assign(TFhirQuestionnaireResponseGroupQuestionAnswer(oSource).FGroupList);
  end;
end;

procedure TFhirQuestionnaireResponseGroupQuestionAnswer.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
  if (child_name = 'group') Then
    list.addAll(self, 'group', FGroupList);
end;

procedure TFhirQuestionnaireResponseGroupQuestionAnswer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'value[x]', 'boolean|decimal|integer|date|dateTime|instant|time|string|uri|Attachment|Coding|Quantity|Reference(Any)', false, TFhirType, FValue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'group', '@QuestionnaireResponse.group', true, TFhirQuestionnaireResponseGroup, FGroupList.Link)){3};
end;

function TFhirQuestionnaireResponseGroupQuestionAnswer.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'value', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Instant', 'Time', 'String', 'Uri', 'Attachment', 'Coding', 'Quantity', 'Reference'])) then
  begin
    Value := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'group') then
  begin
    GroupList.add(propValue as TFhirQuestionnaireResponseGroup){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirQuestionnaireResponseGroupQuestionAnswer.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'group') then GroupList.insertItem(index, propValue as TFhirQuestionnaireResponseGroup){2a}
  else inherited;
end;

function TFhirQuestionnaireResponseGroupQuestionAnswer.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'value', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Instant', 'Time', 'String', 'Uri', 'Attachment', 'Coding', 'Quantity', 'Reference'])) then raise EFHIRException.create('Cannot make property Value'){4x}
  else if (propName = 'group') then result := GroupList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirQuestionnaireResponseGroupQuestionAnswer.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'value[x]') then result := 'boolean|decimal|integer|date|dateTime|instant|time|string|uri|Attachment|Coding|Quantity|Reference'
  else if (propName = 'group') then result := '@QuestionnaireResponse.group'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirQuestionnaireResponseGroupQuestionAnswer.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'value', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Instant', 'Time', 'String', 'Uri', 'Attachment', 'Coding', 'Quantity', 'Reference'])) then ValueElement := nil{4x}
  else if (propName = 'group') then deletePropertyValue('group', GroupList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirQuestionnaireResponseGroupQuestionAnswer.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'value', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Instant', 'Time', 'String', 'Uri', 'Attachment', 'Coding', 'Quantity', 'Reference'])) then ValueElement := new as TFhirType{4x}
  else if (propName = 'group') then replacePropertyValue('group', GroupList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirQuestionnaireResponseGroupQuestionAnswer.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'group') then GroupList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirQuestionnaireResponseGroupQuestionAnswer.fhirType : string;
begin
  result := 'answer';
end;

function TFhirQuestionnaireResponseGroupQuestionAnswer.Link : TFhirQuestionnaireResponseGroupQuestionAnswer;
begin
  result := TFhirQuestionnaireResponseGroupQuestionAnswer(inherited Link);
end;

function TFhirQuestionnaireResponseGroupQuestionAnswer.Clone : TFhirQuestionnaireResponseGroupQuestionAnswer;
begin
  result := TFhirQuestionnaireResponseGroupQuestionAnswer(inherited Clone);
end;

function TFhirQuestionnaireResponseGroupQuestionAnswer.equals(other : TObject) : boolean;
var
  o : TFhirQuestionnaireResponseGroupQuestionAnswer;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirQuestionnaireResponseGroupQuestionAnswer)) then
    result := false
  else
  begin
    o := TFhirQuestionnaireResponseGroupQuestionAnswer(other);
    result := compareDeep(valueElement, o.valueElement, true) and compareDeep(groupList, o.groupList, true);
  end;
end;

function TFhirQuestionnaireResponseGroupQuestionAnswer.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FValue) and isEmptyProp(FgroupList);
end;

procedure TFhirQuestionnaireResponseGroupQuestionAnswer.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('value[x]');
  fields.add('group');
end;

{ TFhirQuestionnaireResponseGroupQuestionAnswer }

Procedure TFhirQuestionnaireResponseGroupQuestionAnswer.SetValue(value : TFhirType);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirQuestionnaireResponseGroupQuestionAnswer.GetGroupList : TFhirQuestionnaireResponseGroupList;
begin
  if FGroupList = nil then
    FGroupList := TFhirQuestionnaireResponseGroupList.Create;
  result := FGroupList;
end;

Function TFhirQuestionnaireResponseGroupQuestionAnswer.GetHasGroupList : boolean;
begin
  result := (FGroupList <> nil) and (FGroupList.count > 0);
end;

function TFhirQuestionnaireResponseGroupQuestionAnswer.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FValue.sizeInBytes);
  inc(result, FgroupList.sizeInBytes);
end;

{ TFhirQuestionnaireResponseGroupQuestionAnswerListEnumerator }

Constructor TFhirQuestionnaireResponseGroupQuestionAnswerListEnumerator.Create(list : TFhirQuestionnaireResponseGroupQuestionAnswerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirQuestionnaireResponseGroupQuestionAnswerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirQuestionnaireResponseGroupQuestionAnswerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirQuestionnaireResponseGroupQuestionAnswerListEnumerator.GetCurrent : TFhirQuestionnaireResponseGroupQuestionAnswer;
begin
  Result := FList[FIndex];
end;

function TFhirQuestionnaireResponseGroupQuestionAnswerListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirQuestionnaireResponseGroupQuestionAnswerList }
procedure TFhirQuestionnaireResponseGroupQuestionAnswerList.AddItem(value: TFhirQuestionnaireResponseGroupQuestionAnswer);
begin
  assert(value.ClassName = 'TFhirQuestionnaireResponseGroupQuestionAnswer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirQuestionnaireResponseGroupQuestionAnswer');
  add(value);
end;

function TFhirQuestionnaireResponseGroupQuestionAnswerList.Append: TFhirQuestionnaireResponseGroupQuestionAnswer;
begin
  result := TFhirQuestionnaireResponseGroupQuestionAnswer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireResponseGroupQuestionAnswerList.ClearItems;
begin
  Clear;
end;

function TFhirQuestionnaireResponseGroupQuestionAnswerList.GetEnumerator : TFhirQuestionnaireResponseGroupQuestionAnswerListEnumerator;
begin
  result := TFhirQuestionnaireResponseGroupQuestionAnswerListEnumerator.Create(self.link);
end;

function TFhirQuestionnaireResponseGroupQuestionAnswerList.Clone: TFhirQuestionnaireResponseGroupQuestionAnswerList;
begin
  result := TFhirQuestionnaireResponseGroupQuestionAnswerList(inherited Clone);
end;

function TFhirQuestionnaireResponseGroupQuestionAnswerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirQuestionnaireResponseGroupQuestionAnswerList.GetItemN(index: Integer): TFhirQuestionnaireResponseGroupQuestionAnswer;
begin
  result := TFhirQuestionnaireResponseGroupQuestionAnswer(ObjectByIndex[index]);
end;

function TFhirQuestionnaireResponseGroupQuestionAnswerList.ItemClass: TFslObjectClass;
begin
  result := TFhirQuestionnaireResponseGroupQuestionAnswer;
end;
function TFhirQuestionnaireResponseGroupQuestionAnswerList.IndexOf(value: TFhirQuestionnaireResponseGroupQuestionAnswer): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirQuestionnaireResponseGroupQuestionAnswerList.Insert(index: Integer): TFhirQuestionnaireResponseGroupQuestionAnswer;
begin
  result := TFhirQuestionnaireResponseGroupQuestionAnswer.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireResponseGroupQuestionAnswerList.InsertItem(index: Integer; value: TFhirQuestionnaireResponseGroupQuestionAnswer);
begin
  assert(value is TFhirQuestionnaireResponseGroupQuestionAnswer);
  Inherited Insert(index, value);
end;

function TFhirQuestionnaireResponseGroupQuestionAnswerList.Item(index: Integer): TFhirQuestionnaireResponseGroupQuestionAnswer;
begin
  result := TFhirQuestionnaireResponseGroupQuestionAnswer(ObjectByIndex[index]);
end;

function TFhirQuestionnaireResponseGroupQuestionAnswerList.Link: TFhirQuestionnaireResponseGroupQuestionAnswerList;
begin
  result := TFhirQuestionnaireResponseGroupQuestionAnswerList(inherited Link);
end;

procedure TFhirQuestionnaireResponseGroupQuestionAnswerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirQuestionnaireResponseGroupQuestionAnswerList.SetItemByIndex(index: Integer; value: TFhirQuestionnaireResponseGroupQuestionAnswer);
begin
  assert(value is TFhirQuestionnaireResponseGroupQuestionAnswer);
  FhirQuestionnaireResponseGroupQuestionAnswers[index] := value;
end;

procedure TFhirQuestionnaireResponseGroupQuestionAnswerList.SetItemN(index: Integer; value: TFhirQuestionnaireResponseGroupQuestionAnswer);
begin
  assert(value is TFhirQuestionnaireResponseGroupQuestionAnswer);
  ObjectByIndex[index] := value;
end;

{ TFhirQuestionnaireResponse }

constructor TFhirQuestionnaireResponse.Create;
begin
  inherited;
end;

destructor TFhirQuestionnaireResponse.Destroy;
begin
  FIdentifier.free;
  FQuestionnaire.free;
  FStatus.free;
  FSubject.free;
  FAuthor.free;
  FAuthored.free;
  FSource.free;
  FEncounter.free;
  FGroup.free;
  inherited;
end;

function TFhirQuestionnaireResponse.GetResourceType : TFhirResourceType;
begin
  result := frtQuestionnaireResponse;
end;

procedure TFhirQuestionnaireResponse.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirQuestionnaireResponse(oSource).identifier.Clone;
  questionnaire := TFhirQuestionnaireResponse(oSource).questionnaire.Clone;
  FStatus := TFhirQuestionnaireResponse(oSource).FStatus.Link;
  subject := TFhirQuestionnaireResponse(oSource).subject.Clone;
  author := TFhirQuestionnaireResponse(oSource).author.Clone;
  authoredElement := TFhirQuestionnaireResponse(oSource).authoredElement.Clone;
  source := TFhirQuestionnaireResponse(oSource).source.Clone;
  encounter := TFhirQuestionnaireResponse(oSource).encounter.Clone;
  group := TFhirQuestionnaireResponse(oSource).group.Clone;
end;

procedure TFhirQuestionnaireResponse.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'questionnaire') Then
     list.add(self.link, 'questionnaire', FQuestionnaire.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
  if (child_name = 'authored') Then
     list.add(self.link, 'authored', FAuthored.Link);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'group') Then
     list.add(self.link, 'group', FGroup.Link);
end;

procedure TFhirQuestionnaireResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'questionnaire', 'Reference(Questionnaire)', false, TFhirReference{TFhirQuestionnaire}, FQuestionnaire.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Any)', false, TFhirReference{TFhirReference}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'author', 'Reference(Device|Practitioner|Patient|RelatedPerson)', false, TFhirReference{Resource}, FAuthor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'authored', 'dateTime', false, TFhirDateTime, FAuthored.Link));{2}
  oList.add(TFHIRProperty.create(self, 'source', 'Reference(Patient|Practitioner|RelatedPerson)', false, TFhirReference{Resource}, FSource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference(Encounter)', false, TFhirReference{TFhirEncounter}, FEncounter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'group', '', false, TFhirQuestionnaireResponseGroup, FGroup.Link));{2}
end;

function TFhirQuestionnaireResponse.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'questionnaire') then
  begin
    Questionnaire := propValue as TFhirReference{TFhirQuestionnaire}{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirQuestionnaireAnswersStatusEnum, CODES_TFhirQuestionnaireAnswersStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'authored') then
  begin
    AuthoredElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    Source := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference{TFhirEncounter}{4b};
    result := propValue;
  end
  else if (propName = 'group') then
  begin
    Group := propValue as TFhirQuestionnaireResponseGroup{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirQuestionnaireResponse.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirQuestionnaireResponse.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'questionnaire') then result := TFhirReference{TFhirQuestionnaire}.create(){4b}
  else if (propName = 'subject') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'author') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'authored') then result := TFhirDateTime.create() {5b}
  else if (propName = 'source') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'encounter') then result := TFhirReference{TFhirEncounter}.create(){4b}
  else if (propName = 'group') then result := TFhirQuestionnaireResponseGroup.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirQuestionnaireResponse.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'questionnaire') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'authored') then result := 'dateTime'
  else if (propName = 'source') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'group') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirQuestionnaireResponse.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'questionnaire') then QuestionnaireElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'author') then AuthorElement := nil
  else if (propName = 'authored') then AuthoredElement := nil
  else if (propName = 'source') then SourceElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'group') then GroupElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirQuestionnaireResponse.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'questionnaire') then QuestionnaireElement := new as TFhirReference{TFhirQuestionnaire}{4}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirQuestionnaireAnswersStatusEnum, CODES_TFhirQuestionnaireAnswersStatusEnum, new){4}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'author') then AuthorElement := new as TFhirReference{Resource}{4}
  else if (propName = 'authored') then AuthoredElement := asDateTime(new){5b}
  else if (propName = 'source') then SourceElement := new as TFhirReference{Resource}{4}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference{TFhirEncounter}{4}
  else if (propName = 'group') then GroupElement := new as TFhirQuestionnaireResponseGroup{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirQuestionnaireResponse.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirQuestionnaireResponse.fhirType : string;
begin
  result := 'QuestionnaireResponse';
end;

function TFhirQuestionnaireResponse.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FQuestionnaire) and isEmptyProp(FStatus) and isEmptyProp(FSubject) and isEmptyProp(FAuthor) and isEmptyProp(FAuthored) and isEmptyProp(FSource) and isEmptyProp(FEncounter) and isEmptyProp(FGroup);
end;

function TFhirQuestionnaireResponse.equals(other : TObject) : boolean;
var
  o : TFhirQuestionnaireResponse;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirQuestionnaireResponse)) then
    result := false
  else
  begin
    o := TFhirQuestionnaireResponse(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(questionnaireElement, o.questionnaireElement, true) and
      compareDeep(statusElement, o.statusElement, true) and compareDeep(subjectElement, o.subjectElement, true) and
      compareDeep(authorElement, o.authorElement, true) and compareDeep(authoredElement, o.authoredElement, true) and
      compareDeep(sourceElement, o.sourceElement, true) and compareDeep(encounterElement, o.encounterElement, true) and
      compareDeep(groupElement, o.groupElement, true);
  end;
end;

function TFhirQuestionnaireResponse.Link : TFhirQuestionnaireResponse;
begin
  result := TFhirQuestionnaireResponse(inherited Link);
end;

function TFhirQuestionnaireResponse.Clone : TFhirQuestionnaireResponse;
begin
  result := TFhirQuestionnaireResponse(inherited Clone);
end;

procedure TFhirQuestionnaireResponse.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('questionnaire');
  fields.add('status');
  fields.add('subject');
  fields.add('author');
  fields.add('authored');
  fields.add('source');
  fields.add('encounter');
  fields.add('group');
end;

{ TFhirQuestionnaireResponse }

Procedure TFhirQuestionnaireResponse.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirQuestionnaireResponse.SetQuestionnaire(value : TFhirReference{TFhirQuestionnaire});
begin
  FQuestionnaire.free;
  FQuestionnaire := value;
end;

Procedure TFhirQuestionnaireResponse.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirQuestionnaireResponse.GetStatusST : TFhirQuestionnaireAnswersStatusEnum;
begin
  if FStatus = nil then
    result := TFhirQuestionnaireAnswersStatusEnum(0)
  else
    result := TFhirQuestionnaireAnswersStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirQuestionnaireAnswersStatusEnum, FStatus.value));
end;

Procedure TFhirQuestionnaireResponse.SetStatusST(value : TFhirQuestionnaireAnswersStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirQuestionnaireAnswersStatusEnum[value], CODES_TFhirQuestionnaireAnswersStatusEnum[value]);
end;

Procedure TFhirQuestionnaireResponse.SetSubject(value : TFhirReference{TFhirReference});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirQuestionnaireResponse.SetAuthor(value : TFhirReference{Resource});
begin
  FAuthor.free;
  FAuthor := value;
end;

Procedure TFhirQuestionnaireResponse.SetAuthored(value : TFhirDateTime);
begin
  FAuthored.free;
  FAuthored := value;
end;

Function TFhirQuestionnaireResponse.GetAuthoredST : TFslDateTime;
begin
  if FAuthored = nil then
    result := TFslDateTime.makeNull
  else
    result := FAuthored.value;
end;

Procedure TFhirQuestionnaireResponse.SetAuthoredST(value : TFslDateTime);
begin
  if FAuthored = nil then
    FAuthored := TFhirDateTime.create;
  FAuthored.value := value
end;

Procedure TFhirQuestionnaireResponse.SetSource(value : TFhirReference{Resource});
begin
  FSource.free;
  FSource := value;
end;

Procedure TFhirQuestionnaireResponse.SetEncounter(value : TFhirReference{TFhirEncounter});
begin
  FEncounter.free;
  FEncounter := value;
end;

Procedure TFhirQuestionnaireResponse.SetGroup(value : TFhirQuestionnaireResponseGroup);
begin
  FGroup.free;
  FGroup := value;
end;

function TFhirQuestionnaireResponse.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FQuestionnaire.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FAuthor.sizeInBytes);
  inc(result, FAuthored.sizeInBytes);
  inc(result, FSource.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FGroup.sizeInBytes);
end;

{ TFhirQuestionnaireResponseListEnumerator }

Constructor TFhirQuestionnaireResponseListEnumerator.Create(list : TFhirQuestionnaireResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirQuestionnaireResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirQuestionnaireResponseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirQuestionnaireResponseListEnumerator.GetCurrent : TFhirQuestionnaireResponse;
begin
  Result := FList[FIndex];
end;

function TFhirQuestionnaireResponseListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirQuestionnaireResponseList }
procedure TFhirQuestionnaireResponseList.AddItem(value: TFhirQuestionnaireResponse);
begin
  assert(value.ClassName = 'TFhirQuestionnaireResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirQuestionnaireResponse');
  add(value);
end;

function TFhirQuestionnaireResponseList.Append: TFhirQuestionnaireResponse;
begin
  result := TFhirQuestionnaireResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireResponseList.ClearItems;
begin
  Clear;
end;

function TFhirQuestionnaireResponseList.GetEnumerator : TFhirQuestionnaireResponseListEnumerator;
begin
  result := TFhirQuestionnaireResponseListEnumerator.Create(self.link);
end;

function TFhirQuestionnaireResponseList.Clone: TFhirQuestionnaireResponseList;
begin
  result := TFhirQuestionnaireResponseList(inherited Clone);
end;

function TFhirQuestionnaireResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirQuestionnaireResponseList.GetItemN(index: Integer): TFhirQuestionnaireResponse;
begin
  result := TFhirQuestionnaireResponse(ObjectByIndex[index]);
end;

function TFhirQuestionnaireResponseList.ItemClass: TFslObjectClass;
begin
  result := TFhirQuestionnaireResponse;
end;
function TFhirQuestionnaireResponseList.IndexOf(value: TFhirQuestionnaireResponse): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirQuestionnaireResponseList.Insert(index: Integer): TFhirQuestionnaireResponse;
begin
  result := TFhirQuestionnaireResponse.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireResponseList.InsertItem(index: Integer; value: TFhirQuestionnaireResponse);
begin
  assert(value is TFhirQuestionnaireResponse);
  Inherited Insert(index, value);
end;

function TFhirQuestionnaireResponseList.Item(index: Integer): TFhirQuestionnaireResponse;
begin
  result := TFhirQuestionnaireResponse(ObjectByIndex[index]);
end;

function TFhirQuestionnaireResponseList.Link: TFhirQuestionnaireResponseList;
begin
  result := TFhirQuestionnaireResponseList(inherited Link);
end;

procedure TFhirQuestionnaireResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirQuestionnaireResponseList.SetItemByIndex(index: Integer; value: TFhirQuestionnaireResponse);
begin
  assert(value is TFhirQuestionnaireResponse);
  FhirQuestionnaireResponses[index] := value;
end;

procedure TFhirQuestionnaireResponseList.SetItemN(index: Integer; value: TFhirQuestionnaireResponse);
begin
  assert(value is TFhirQuestionnaireResponse);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_QUESTIONNAIRERESPONSE}

{$IFDEF FHIR_REFERRALREQUEST}

{ TFhirReferralRequest }

constructor TFhirReferralRequest.Create;
begin
  inherited;
end;

destructor TFhirReferralRequest.Destroy;
begin
  FStatus.free;
  FIdentifierList.Free;
  FDate.free;
  FType_.free;
  FSpecialty.free;
  FPriority.free;
  FPatient.free;
  FRequester.free;
  FRecipientList.Free;
  FEncounter.free;
  FDateSent.free;
  FReason.free;
  FDescription.free;
  FServiceRequestedList.Free;
  FSupportingInformationList.Free;
  FFulfillmentTime.free;
  inherited;
end;

function TFhirReferralRequest.GetResourceType : TFhirResourceType;
begin
  result := frtReferralRequest;
end;

procedure TFhirReferralRequest.Assign(oSource : TFslObject);
begin
  inherited;
  FStatus := TFhirReferralRequest(oSource).FStatus.Link;
  if (TFhirReferralRequest(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirReferralRequest(oSource).FIdentifierList);
  end;
  dateElement := TFhirReferralRequest(oSource).dateElement.Clone;
  type_ := TFhirReferralRequest(oSource).type_.Clone;
  specialty := TFhirReferralRequest(oSource).specialty.Clone;
  priority := TFhirReferralRequest(oSource).priority.Clone;
  patient := TFhirReferralRequest(oSource).patient.Clone;
  requester := TFhirReferralRequest(oSource).requester.Clone;
  if (TFhirReferralRequest(oSource).FRecipientList = nil) then
  begin
    FRecipientList.free;
    FRecipientList := nil;
  end
  else
  begin
    if FRecipientList = nil then
      FRecipientList := TFhirReferenceList{Resource}.Create;
    FRecipientList.Assign(TFhirReferralRequest(oSource).FRecipientList);
  end;
  encounter := TFhirReferralRequest(oSource).encounter.Clone;
  dateSentElement := TFhirReferralRequest(oSource).dateSentElement.Clone;
  reason := TFhirReferralRequest(oSource).reason.Clone;
  descriptionElement := TFhirReferralRequest(oSource).descriptionElement.Clone;
  if (TFhirReferralRequest(oSource).FServiceRequestedList = nil) then
  begin
    FServiceRequestedList.free;
    FServiceRequestedList := nil;
  end
  else
  begin
    if FServiceRequestedList = nil then
      FServiceRequestedList := TFhirCodeableConceptList.Create;
    FServiceRequestedList.Assign(TFhirReferralRequest(oSource).FServiceRequestedList);
  end;
  if (TFhirReferralRequest(oSource).FSupportingInformationList = nil) then
  begin
    FSupportingInformationList.free;
    FSupportingInformationList := nil;
  end
  else
  begin
    if FSupportingInformationList = nil then
      FSupportingInformationList := TFhirReferenceList{TFhirReference}.Create;
    FSupportingInformationList.Assign(TFhirReferralRequest(oSource).FSupportingInformationList);
  end;
  fulfillmentTime := TFhirReferralRequest(oSource).fulfillmentTime.Clone;
end;

procedure TFhirReferralRequest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'specialty') Then
     list.add(self.link, 'specialty', FSpecialty.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'requester') Then
     list.add(self.link, 'requester', FRequester.Link);
  if (child_name = 'recipient') Then
    list.addAll(self, 'recipient', FRecipientList);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'dateSent') Then
     list.add(self.link, 'dateSent', FDateSent.Link);
  if (child_name = 'reason') Then
     list.add(self.link, 'reason', FReason.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'serviceRequested') Then
    list.addAll(self, 'serviceRequested', FServiceRequestedList);
  if (child_name = 'supportingInformation') Then
    list.addAll(self, 'supportingInformation', FSupportingInformationList);
  if (child_name = 'fulfillmentTime') Then
     list.add(self.link, 'fulfillmentTime', FFulfillmentTime.Link);
end;

procedure TFhirReferralRequest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'specialty', 'CodeableConcept', false, TFhirCodeableConcept, FSpecialty.Link));{2}
  oList.add(TFHIRProperty.create(self, 'priority', 'CodeableConcept', false, TFhirCodeableConcept, FPriority.Link));{2}
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requester', 'Reference(Practitioner|Organization|Patient)', false, TFhirReference{Resource}, FRequester.Link));{2}
  oList.add(TFHIRProperty.create(self, 'recipient', 'Reference(Practitioner|Organization)', true, TFhirReference{Resource}, FRecipientList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference(Encounter)', false, TFhirReference{TFhirEncounter}, FEncounter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dateSent', 'dateTime', false, TFhirDateTime, FDateSent.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', false, TFhirCodeableConcept, FReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'serviceRequested', 'CodeableConcept', true, TFhirCodeableConcept, FServiceRequestedList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'supportingInformation', 'Reference(Any)', true, TFhirReference{TFhirReference}, FSupportingInformationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'fulfillmentTime', 'Period', false, TFhirPeriod, FFulfillmentTime.Link));{2}
end;

function TFhirReferralRequest.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirReferralstatusEnum, CODES_TFhirReferralstatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'specialty') then
  begin
    Specialty := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    Priority := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'requester') then
  begin
    Requester := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'recipient') then
  begin
    RecipientList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference{TFhirEncounter}{4b};
    result := propValue;
  end
  else if (propName = 'dateSent') then
  begin
    DateSentElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    Reason := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'serviceRequested') then
  begin
    ServiceRequestedList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'supportingInformation') then
  begin
    SupportingInformationList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'fulfillmentTime') then
  begin
    FulfillmentTime := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirReferralRequest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'recipient') then RecipientList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'serviceRequested') then ServiceRequestedList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'supportingInformation') then SupportingInformationList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else inherited;
end;

function TFhirReferralRequest.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'specialty') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'priority') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'requester') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'recipient') then result := RecipientList.new(){2}
  else if (propName = 'encounter') then result := TFhirReference{TFhirEncounter}.create(){4b}
  else if (propName = 'dateSent') then result := TFhirDateTime.create() {5b}
  else if (propName = 'reason') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'serviceRequested') then result := ServiceRequestedList.new(){2}
  else if (propName = 'supportingInformation') then result := SupportingInformationList.new(){2}
  else if (propName = 'fulfillmentTime') then result := TFhirPeriod.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirReferralRequest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'status') then result := 'code'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'specialty') then result := 'CodeableConcept'
  else if (propName = 'priority') then result := 'CodeableConcept'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'requester') then result := 'Reference'
  else if (propName = 'recipient') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'dateSent') then result := 'dateTime'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'serviceRequested') then result := 'CodeableConcept'
  else if (propName = 'supportingInformation') then result := 'Reference'
  else if (propName = 'fulfillmentTime') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirReferralRequest.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'specialty') then SpecialtyElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'requester') then RequesterElement := nil
  else if (propName = 'recipient') then deletePropertyValue('recipient', RecipientList, value) {2}
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'dateSent') then DateSentElement := nil
  else if (propName = 'reason') then ReasonElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'serviceRequested') then deletePropertyValue('serviceRequested', ServiceRequestedList, value) {2}
  else if (propName = 'supportingInformation') then deletePropertyValue('supportingInformation', SupportingInformationList, value) {2}
  else if (propName = 'fulfillmentTime') then FulfillmentTimeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirReferralRequest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirReferralstatusEnum, CODES_TFhirReferralstatusEnum, new){4}
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'specialty') then SpecialtyElement := new as TFhirCodeableConcept{4}
  else if (propName = 'priority') then PriorityElement := new as TFhirCodeableConcept{4}
  else if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'requester') then RequesterElement := new as TFhirReference{Resource}{4}
  else if (propName = 'recipient') then replacePropertyValue('recipient', RecipientList, existing, new) {2}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference{TFhirEncounter}{4}
  else if (propName = 'dateSent') then DateSentElement := asDateTime(new){5b}
  else if (propName = 'reason') then ReasonElement := new as TFhirCodeableConcept{4}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'serviceRequested') then replacePropertyValue('serviceRequested', ServiceRequestedList, existing, new) {2}
  else if (propName = 'supportingInformation') then replacePropertyValue('supportingInformation', SupportingInformationList, existing, new) {2}
  else if (propName = 'fulfillmentTime') then FulfillmentTimeElement := new as TFhirPeriod{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirReferralRequest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'recipient') then RecipientList.move(source, destination){2a}
  else if (propName = 'serviceRequested') then ServiceRequestedList.move(source, destination){2a}
  else if (propName = 'supportingInformation') then SupportingInformationList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirReferralRequest.fhirType : string;
begin
  result := 'ReferralRequest';
end;

function TFhirReferralRequest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FStatus) and isEmptyProp(FidentifierList) and isEmptyProp(FDate) and isEmptyProp(FType_) and isEmptyProp(FSpecialty) and isEmptyProp(FPriority) and isEmptyProp(FPatient) and isEmptyProp(FRequester) and isEmptyProp(FrecipientList) and isEmptyProp(FEncounter) and isEmptyProp(FDateSent) and isEmptyProp(FReason) and isEmptyProp(FDescription) and isEmptyProp(FserviceRequestedList) and isEmptyProp(FsupportingInformationList) and isEmptyProp(FFulfillmentTime);
end;

function TFhirReferralRequest.equals(other : TObject) : boolean;
var
  o : TFhirReferralRequest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirReferralRequest)) then
    result := false
  else
  begin
    o := TFhirReferralRequest(other);
    result := compareDeep(statusElement, o.statusElement, true) and compareDeep(identifierList, o.identifierList, true) and
      compareDeep(dateElement, o.dateElement, true) and compareDeep(type_Element, o.type_Element, true) and
      compareDeep(specialtyElement, o.specialtyElement, true) and compareDeep(priorityElement, o.priorityElement, true) and
      compareDeep(patientElement, o.patientElement, true) and compareDeep(requesterElement, o.requesterElement, true) and
      compareDeep(recipientList, o.recipientList, true) and compareDeep(encounterElement, o.encounterElement, true) and
      compareDeep(dateSentElement, o.dateSentElement, true) and compareDeep(reasonElement, o.reasonElement, true) and
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(serviceRequestedList, o.serviceRequestedList, true) and
      compareDeep(supportingInformationList, o.supportingInformationList, true) and
      compareDeep(fulfillmentTimeElement, o.fulfillmentTimeElement, true);
  end;
end;

function TFhirReferralRequest.Link : TFhirReferralRequest;
begin
  result := TFhirReferralRequest(inherited Link);
end;

function TFhirReferralRequest.Clone : TFhirReferralRequest;
begin
  result := TFhirReferralRequest(inherited Clone);
end;

procedure TFhirReferralRequest.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('status');
  fields.add('identifier');
  fields.add('date');
  fields.add('type');
  fields.add('specialty');
  fields.add('priority');
  fields.add('patient');
  fields.add('requester');
  fields.add('recipient');
  fields.add('encounter');
  fields.add('dateSent');
  fields.add('reason');
  fields.add('description');
  fields.add('serviceRequested');
  fields.add('supportingInformation');
  fields.add('fulfillmentTime');
end;

{ TFhirReferralRequest }

Procedure TFhirReferralRequest.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirReferralRequest.GetStatusST : TFhirReferralstatusEnum;
begin
  if FStatus = nil then
    result := TFhirReferralstatusEnum(0)
  else
    result := TFhirReferralstatusEnum(StringArrayIndexOfSensitive(CODES_TFhirReferralstatusEnum, FStatus.value));
end;

Procedure TFhirReferralRequest.SetStatusST(value : TFhirReferralstatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirReferralstatusEnum[value], CODES_TFhirReferralstatusEnum[value]);
end;

Function TFhirReferralRequest.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirReferralRequest.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirReferralRequest.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirReferralRequest.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirReferralRequest.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirReferralRequest.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirReferralRequest.SetSpecialty(value : TFhirCodeableConcept);
begin
  FSpecialty.free;
  FSpecialty := value;
end;

Procedure TFhirReferralRequest.SetPriority(value : TFhirCodeableConcept);
begin
  FPriority.free;
  FPriority := value;
end;

Procedure TFhirReferralRequest.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Procedure TFhirReferralRequest.SetRequester(value : TFhirReference{Resource});
begin
  FRequester.free;
  FRequester := value;
end;

Function TFhirReferralRequest.GetRecipientList : TFhirReferenceList{Resource};
begin
  if FRecipientList = nil then
    FRecipientList := TFhirReferenceList{Resource}.Create;
  result := FRecipientList;
end;

Function TFhirReferralRequest.GetHasRecipientList : boolean;
begin
  result := (FRecipientList <> nil) and (FRecipientList.count > 0);
end;

Procedure TFhirReferralRequest.SetEncounter(value : TFhirReference{TFhirEncounter});
begin
  FEncounter.free;
  FEncounter := value;
end;

Procedure TFhirReferralRequest.SetDateSent(value : TFhirDateTime);
begin
  FDateSent.free;
  FDateSent := value;
end;

Function TFhirReferralRequest.GetDateSentST : TFslDateTime;
begin
  if FDateSent = nil then
    result := TFslDateTime.makeNull
  else
    result := FDateSent.value;
end;

Procedure TFhirReferralRequest.SetDateSentST(value : TFslDateTime);
begin
  if FDateSent = nil then
    FDateSent := TFhirDateTime.create;
  FDateSent.value := value
end;

Procedure TFhirReferralRequest.SetReason(value : TFhirCodeableConcept);
begin
  FReason.free;
  FReason := value;
end;

Procedure TFhirReferralRequest.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirReferralRequest.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirReferralRequest.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Function TFhirReferralRequest.GetServiceRequestedList : TFhirCodeableConceptList;
begin
  if FServiceRequestedList = nil then
    FServiceRequestedList := TFhirCodeableConceptList.Create;
  result := FServiceRequestedList;
end;

Function TFhirReferralRequest.GetHasServiceRequestedList : boolean;
begin
  result := (FServiceRequestedList <> nil) and (FServiceRequestedList.count > 0);
end;

Function TFhirReferralRequest.GetSupportingInformationList : TFhirReferenceList{TFhirReference};
begin
  if FSupportingInformationList = nil then
    FSupportingInformationList := TFhirReferenceList{TFhirReference}.Create;
  result := FSupportingInformationList;
end;

Function TFhirReferralRequest.GetHasSupportingInformationList : boolean;
begin
  result := (FSupportingInformationList <> nil) and (FSupportingInformationList.count > 0);
end;

Procedure TFhirReferralRequest.SetFulfillmentTime(value : TFhirPeriod);
begin
  FFulfillmentTime.free;
  FFulfillmentTime := value;
end;

function TFhirReferralRequest.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FStatus.sizeInBytes);
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FSpecialty.sizeInBytes);
  inc(result, FPriority.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FRequester.sizeInBytes);
  inc(result, FrecipientList.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FDateSent.sizeInBytes);
  inc(result, FReason.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FserviceRequestedList.sizeInBytes);
  inc(result, FsupportingInformationList.sizeInBytes);
  inc(result, FFulfillmentTime.sizeInBytes);
end;

{ TFhirReferralRequestListEnumerator }

Constructor TFhirReferralRequestListEnumerator.Create(list : TFhirReferralRequestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirReferralRequestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirReferralRequestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirReferralRequestListEnumerator.GetCurrent : TFhirReferralRequest;
begin
  Result := FList[FIndex];
end;

function TFhirReferralRequestListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirReferralRequestList }
procedure TFhirReferralRequestList.AddItem(value: TFhirReferralRequest);
begin
  assert(value.ClassName = 'TFhirReferralRequest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirReferralRequest');
  add(value);
end;

function TFhirReferralRequestList.Append: TFhirReferralRequest;
begin
  result := TFhirReferralRequest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirReferralRequestList.ClearItems;
begin
  Clear;
end;

function TFhirReferralRequestList.GetEnumerator : TFhirReferralRequestListEnumerator;
begin
  result := TFhirReferralRequestListEnumerator.Create(self.link);
end;

function TFhirReferralRequestList.Clone: TFhirReferralRequestList;
begin
  result := TFhirReferralRequestList(inherited Clone);
end;

function TFhirReferralRequestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirReferralRequestList.GetItemN(index: Integer): TFhirReferralRequest;
begin
  result := TFhirReferralRequest(ObjectByIndex[index]);
end;

function TFhirReferralRequestList.ItemClass: TFslObjectClass;
begin
  result := TFhirReferralRequest;
end;
function TFhirReferralRequestList.IndexOf(value: TFhirReferralRequest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirReferralRequestList.Insert(index: Integer): TFhirReferralRequest;
begin
  result := TFhirReferralRequest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirReferralRequestList.InsertItem(index: Integer; value: TFhirReferralRequest);
begin
  assert(value is TFhirReferralRequest);
  Inherited Insert(index, value);
end;

function TFhirReferralRequestList.Item(index: Integer): TFhirReferralRequest;
begin
  result := TFhirReferralRequest(ObjectByIndex[index]);
end;

function TFhirReferralRequestList.Link: TFhirReferralRequestList;
begin
  result := TFhirReferralRequestList(inherited Link);
end;

procedure TFhirReferralRequestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirReferralRequestList.SetItemByIndex(index: Integer; value: TFhirReferralRequest);
begin
  assert(value is TFhirReferralRequest);
  FhirReferralRequests[index] := value;
end;

procedure TFhirReferralRequestList.SetItemN(index: Integer; value: TFhirReferralRequest);
begin
  assert(value is TFhirReferralRequest);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_REFERRALREQUEST}

{$IFDEF FHIR_RISKASSESSMENT}

{ TFhirRiskAssessmentPrediction }

constructor TFhirRiskAssessmentPrediction.Create;
begin
  inherited;
end;

destructor TFhirRiskAssessmentPrediction.Destroy;
begin
  FOutcome.free;
  FProbability.free;
  FRelativeRisk.free;
  FWhen.free;
  FRationale.free;
  inherited;
end;

procedure TFhirRiskAssessmentPrediction.Assign(oSource : TFslObject);
begin
  inherited;
  outcome := TFhirRiskAssessmentPrediction(oSource).outcome.Clone;
  probability := TFhirRiskAssessmentPrediction(oSource).probability.Clone;
  relativeRiskElement := TFhirRiskAssessmentPrediction(oSource).relativeRiskElement.Clone;
  when := TFhirRiskAssessmentPrediction(oSource).when.Clone;
  rationaleElement := TFhirRiskAssessmentPrediction(oSource).rationaleElement.Clone;
end;

procedure TFhirRiskAssessmentPrediction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'probability[x]') or (child_name = 'probability') Then
     list.add(self.link, 'probability[x]', FProbability.Link);
  if (child_name = 'relativeRisk') Then
     list.add(self.link, 'relativeRisk', FRelativeRisk.Link);
  if (child_name = 'when[x]') or (child_name = 'when') Then
     list.add(self.link, 'when[x]', FWhen.Link);
  if (child_name = 'rationale') Then
     list.add(self.link, 'rationale', FRationale.Link);
end;

procedure TFhirRiskAssessmentPrediction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'outcome', 'CodeableConcept', false, TFhirCodeableConcept, FOutcome.Link));{2}
  oList.add(TFHIRProperty.create(self, 'probability[x]', 'decimal|Range|CodeableConcept', false, TFhirType, FProbability.Link));{2}
  oList.add(TFHIRProperty.create(self, 'relativeRisk', 'decimal', false, TFhirDecimal, FRelativeRisk.Link));{2}
  oList.add(TFHIRProperty.create(self, 'when[x]', 'Period|Range', false, TFhirType, FWhen.Link));{2}
  oList.add(TFHIRProperty.create(self, 'rationale', 'string', false, TFhirString, FRationale.Link));{2}
end;

function TFhirRiskAssessmentPrediction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'outcome') then
  begin
    Outcome := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'probability', ['Decimal', 'Range', 'CodeableConcept'])) then
  begin
    Probability := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'relativeRisk') then
  begin
    RelativeRiskElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'when', ['Period', 'Range'])) then
  begin
    When := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'rationale') then
  begin
    RationaleElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRiskAssessmentPrediction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirRiskAssessmentPrediction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'outcome') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'probability', ['Decimal', 'Range', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property Probability'){4x}
  else if (propName = 'relativeRisk') then result := TFhirDecimal.create() {5b}
  else if (isMatchingName(propName, 'when', ['Period', 'Range'])) then raise EFHIRException.create('Cannot make property When'){4x}
  else if (propName = 'rationale') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirRiskAssessmentPrediction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'outcome') then result := 'CodeableConcept'
  else if (propName = 'probability[x]') then result := 'decimal|Range|CodeableConcept'
  else if (propName = 'relativeRisk') then result := 'decimal'
  else if (propName = 'when[x]') then result := 'Period|Range'
  else if (propName = 'rationale') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRiskAssessmentPrediction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'outcome') then OutcomeElement := nil
  else if (isMatchingName(propName, 'probability', ['Decimal', 'Range', 'CodeableConcept'])) then ProbabilityElement := nil{4x}
  else if (propName = 'relativeRisk') then RelativeRiskElement := nil
  else if (isMatchingName(propName, 'when', ['Period', 'Range'])) then WhenElement := nil{4x}
  else if (propName = 'rationale') then RationaleElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRiskAssessmentPrediction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'outcome') then OutcomeElement := new as TFhirCodeableConcept{4}
  else if (isMatchingName(propName, 'probability', ['Decimal', 'Range', 'CodeableConcept'])) then ProbabilityElement := new as TFhirType{4x}
  else if (propName = 'relativeRisk') then RelativeRiskElement := asDecimal(new){5b}
  else if (isMatchingName(propName, 'when', ['Period', 'Range'])) then WhenElement := new as TFhirType{4x}
  else if (propName = 'rationale') then RationaleElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRiskAssessmentPrediction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirRiskAssessmentPrediction.fhirType : string;
begin
  result := 'prediction';
end;

function TFhirRiskAssessmentPrediction.Link : TFhirRiskAssessmentPrediction;
begin
  result := TFhirRiskAssessmentPrediction(inherited Link);
end;

function TFhirRiskAssessmentPrediction.Clone : TFhirRiskAssessmentPrediction;
begin
  result := TFhirRiskAssessmentPrediction(inherited Clone);
end;

function TFhirRiskAssessmentPrediction.equals(other : TObject) : boolean;
var
  o : TFhirRiskAssessmentPrediction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRiskAssessmentPrediction)) then
    result := false
  else
  begin
    o := TFhirRiskAssessmentPrediction(other);
    result := compareDeep(outcomeElement, o.outcomeElement, true) and compareDeep(probabilityElement, o.probabilityElement, true) and
      compareDeep(relativeRiskElement, o.relativeRiskElement, true) and compareDeep(whenElement, o.whenElement, true) and
      compareDeep(rationaleElement, o.rationaleElement, true);
  end;
end;

function TFhirRiskAssessmentPrediction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FOutcome) and isEmptyProp(FProbability) and isEmptyProp(FRelativeRisk) and isEmptyProp(FWhen) and isEmptyProp(FRationale);
end;

procedure TFhirRiskAssessmentPrediction.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('outcome');
  fields.add('probability[x]');
  fields.add('relativeRisk');
  fields.add('when[x]');
  fields.add('rationale');
end;

{ TFhirRiskAssessmentPrediction }

Procedure TFhirRiskAssessmentPrediction.SetOutcome(value : TFhirCodeableConcept);
begin
  FOutcome.free;
  FOutcome := value;
end;

Procedure TFhirRiskAssessmentPrediction.SetProbability(value : TFhirType);
begin
  FProbability.free;
  FProbability := value;
end;

Procedure TFhirRiskAssessmentPrediction.SetRelativeRisk(value : TFhirDecimal);
begin
  FRelativeRisk.free;
  FRelativeRisk := value;
end;

Function TFhirRiskAssessmentPrediction.GetRelativeRiskST : String;
begin
  if FRelativeRisk = nil then
    result := ''
  else
    result := FRelativeRisk.value;
end;

Procedure TFhirRiskAssessmentPrediction.SetRelativeRiskST(value : String);
begin
  if value <> '' then
  begin
    if FRelativeRisk = nil then
      FRelativeRisk := TFhirDecimal.create;
    FRelativeRisk.value := value
  end
  else if FRelativeRisk <> nil then
    FRelativeRisk.value := '';
end;

Procedure TFhirRiskAssessmentPrediction.SetWhen(value : TFhirType);
begin
  FWhen.free;
  FWhen := value;
end;

Procedure TFhirRiskAssessmentPrediction.SetRationale(value : TFhirString);
begin
  FRationale.free;
  FRationale := value;
end;

Function TFhirRiskAssessmentPrediction.GetRationaleST : String;
begin
  if FRationale = nil then
    result := ''
  else
    result := FRationale.value;
end;

Procedure TFhirRiskAssessmentPrediction.SetRationaleST(value : String);
begin
  if value <> '' then
  begin
    if FRationale = nil then
      FRationale := TFhirString.create;
    FRationale.value := value
  end
  else if FRationale <> nil then
    FRationale.value := '';
end;

function TFhirRiskAssessmentPrediction.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FOutcome.sizeInBytes);
  inc(result, FProbability.sizeInBytes);
  inc(result, FRelativeRisk.sizeInBytes);
  inc(result, FWhen.sizeInBytes);
  inc(result, FRationale.sizeInBytes);
end;

{ TFhirRiskAssessmentPredictionListEnumerator }

Constructor TFhirRiskAssessmentPredictionListEnumerator.Create(list : TFhirRiskAssessmentPredictionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRiskAssessmentPredictionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRiskAssessmentPredictionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRiskAssessmentPredictionListEnumerator.GetCurrent : TFhirRiskAssessmentPrediction;
begin
  Result := FList[FIndex];
end;

function TFhirRiskAssessmentPredictionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirRiskAssessmentPredictionList }
procedure TFhirRiskAssessmentPredictionList.AddItem(value: TFhirRiskAssessmentPrediction);
begin
  assert(value.ClassName = 'TFhirRiskAssessmentPrediction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRiskAssessmentPrediction');
  add(value);
end;

function TFhirRiskAssessmentPredictionList.Append: TFhirRiskAssessmentPrediction;
begin
  result := TFhirRiskAssessmentPrediction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRiskAssessmentPredictionList.ClearItems;
begin
  Clear;
end;

function TFhirRiskAssessmentPredictionList.GetEnumerator : TFhirRiskAssessmentPredictionListEnumerator;
begin
  result := TFhirRiskAssessmentPredictionListEnumerator.Create(self.link);
end;

function TFhirRiskAssessmentPredictionList.Clone: TFhirRiskAssessmentPredictionList;
begin
  result := TFhirRiskAssessmentPredictionList(inherited Clone);
end;

function TFhirRiskAssessmentPredictionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRiskAssessmentPredictionList.GetItemN(index: Integer): TFhirRiskAssessmentPrediction;
begin
  result := TFhirRiskAssessmentPrediction(ObjectByIndex[index]);
end;

function TFhirRiskAssessmentPredictionList.ItemClass: TFslObjectClass;
begin
  result := TFhirRiskAssessmentPrediction;
end;
function TFhirRiskAssessmentPredictionList.IndexOf(value: TFhirRiskAssessmentPrediction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRiskAssessmentPredictionList.Insert(index: Integer): TFhirRiskAssessmentPrediction;
begin
  result := TFhirRiskAssessmentPrediction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRiskAssessmentPredictionList.InsertItem(index: Integer; value: TFhirRiskAssessmentPrediction);
begin
  assert(value is TFhirRiskAssessmentPrediction);
  Inherited Insert(index, value);
end;

function TFhirRiskAssessmentPredictionList.Item(index: Integer): TFhirRiskAssessmentPrediction;
begin
  result := TFhirRiskAssessmentPrediction(ObjectByIndex[index]);
end;

function TFhirRiskAssessmentPredictionList.Link: TFhirRiskAssessmentPredictionList;
begin
  result := TFhirRiskAssessmentPredictionList(inherited Link);
end;

procedure TFhirRiskAssessmentPredictionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRiskAssessmentPredictionList.SetItemByIndex(index: Integer; value: TFhirRiskAssessmentPrediction);
begin
  assert(value is TFhirRiskAssessmentPrediction);
  FhirRiskAssessmentPredictions[index] := value;
end;

procedure TFhirRiskAssessmentPredictionList.SetItemN(index: Integer; value: TFhirRiskAssessmentPrediction);
begin
  assert(value is TFhirRiskAssessmentPrediction);
  ObjectByIndex[index] := value;
end;

{ TFhirRiskAssessment }

constructor TFhirRiskAssessment.Create;
begin
  inherited;
end;

destructor TFhirRiskAssessment.Destroy;
begin
  FSubject.free;
  FDate.free;
  FCondition.free;
  FEncounter.free;
  FPerformer.free;
  FIdentifier.free;
  FMethod.free;
  FBasisList.Free;
  FPredictionList.Free;
  FMitigation.free;
  inherited;
end;

function TFhirRiskAssessment.GetResourceType : TFhirResourceType;
begin
  result := frtRiskAssessment;
end;

procedure TFhirRiskAssessment.Assign(oSource : TFslObject);
begin
  inherited;
  subject := TFhirRiskAssessment(oSource).subject.Clone;
  dateElement := TFhirRiskAssessment(oSource).dateElement.Clone;
  condition := TFhirRiskAssessment(oSource).condition.Clone;
  encounter := TFhirRiskAssessment(oSource).encounter.Clone;
  performer := TFhirRiskAssessment(oSource).performer.Clone;
  identifier := TFhirRiskAssessment(oSource).identifier.Clone;
  method := TFhirRiskAssessment(oSource).method.Clone;
  if (TFhirRiskAssessment(oSource).FBasisList = nil) then
  begin
    FBasisList.free;
    FBasisList := nil;
  end
  else
  begin
    if FBasisList = nil then
      FBasisList := TFhirReferenceList{TFhirReference}.Create;
    FBasisList.Assign(TFhirRiskAssessment(oSource).FBasisList);
  end;
  if (TFhirRiskAssessment(oSource).FPredictionList = nil) then
  begin
    FPredictionList.free;
    FPredictionList := nil;
  end
  else
  begin
    if FPredictionList = nil then
      FPredictionList := TFhirRiskAssessmentPredictionList.Create;
    FPredictionList.Assign(TFhirRiskAssessment(oSource).FPredictionList);
  end;
  mitigationElement := TFhirRiskAssessment(oSource).mitigationElement.Clone;
end;

procedure TFhirRiskAssessment.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'condition') Then
     list.add(self.link, 'condition', FCondition.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'performer') Then
     list.add(self.link, 'performer', FPerformer.Link);
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'method') Then
     list.add(self.link, 'method', FMethod.Link);
  if (child_name = 'basis') Then
    list.addAll(self, 'basis', FBasisList);
  if (child_name = 'prediction') Then
    list.addAll(self, 'prediction', FPredictionList);
  if (child_name = 'mitigation') Then
     list.add(self.link, 'mitigation', FMitigation.Link);
end;

procedure TFhirRiskAssessment.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Group)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'condition', 'Reference(Condition)', false, TFhirReference{TFhirCondition}, FCondition.Link));{2}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference(Encounter)', false, TFhirReference{TFhirEncounter}, FEncounter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'performer', 'Reference(Practitioner|Device)', false, TFhirReference{Resource}, FPerformer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', false, TFhirCodeableConcept, FMethod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'basis', 'Reference(Any)', true, TFhirReference{TFhirReference}, FBasisList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'prediction', '', true, TFhirRiskAssessmentPrediction, FPredictionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'mitigation', 'string', false, TFhirString, FMitigation.Link));{2}
end;

function TFhirRiskAssessment.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'condition') then
  begin
    Condition := propValue as TFhirReference{TFhirCondition}{4b};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference{TFhirEncounter}{4b};
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    Performer := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'method') then
  begin
    Method := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'basis') then
  begin
    BasisList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'prediction') then
  begin
    PredictionList.add(propValue as TFhirRiskAssessmentPrediction){2a};
    result := propValue;
  end
  else if (propName = 'mitigation') then
  begin
    MitigationElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirRiskAssessment.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'basis') then BasisList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'prediction') then PredictionList.insertItem(index, propValue as TFhirRiskAssessmentPrediction){2a}
  else inherited;
end;

function TFhirRiskAssessment.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'condition') then result := TFhirReference{TFhirCondition}.create(){4b}
  else if (propName = 'encounter') then result := TFhirReference{TFhirEncounter}.create(){4b}
  else if (propName = 'performer') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'method') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'basis') then result := BasisList.new(){2}
  else if (propName = 'prediction') then result := PredictionList.new(){2}
  else if (propName = 'mitigation') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirRiskAssessment.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'subject') then result := 'Reference'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'condition') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'performer') then result := 'Reference'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'method') then result := 'CodeableConcept'
  else if (propName = 'basis') then result := 'Reference'
  else if (propName = 'prediction') then result := ''
  else if (propName = 'mitigation') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRiskAssessment.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'condition') then ConditionElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'performer') then PerformerElement := nil
  else if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'method') then MethodElement := nil
  else if (propName = 'basis') then deletePropertyValue('basis', BasisList, value) {2}
  else if (propName = 'prediction') then deletePropertyValue('prediction', PredictionList, value) {2}
  else if (propName = 'mitigation') then MitigationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRiskAssessment.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'condition') then ConditionElement := new as TFhirReference{TFhirCondition}{4}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference{TFhirEncounter}{4}
  else if (propName = 'performer') then PerformerElement := new as TFhirReference{Resource}{4}
  else if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'method') then MethodElement := new as TFhirCodeableConcept{4}
  else if (propName = 'basis') then replacePropertyValue('basis', BasisList, existing, new) {2}
  else if (propName = 'prediction') then replacePropertyValue('prediction', PredictionList, existing, new) {2}
  else if (propName = 'mitigation') then MitigationElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRiskAssessment.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'basis') then BasisList.move(source, destination){2a}
  else if (propName = 'prediction') then PredictionList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirRiskAssessment.fhirType : string;
begin
  result := 'RiskAssessment';
end;

function TFhirRiskAssessment.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSubject) and isEmptyProp(FDate) and isEmptyProp(FCondition) and isEmptyProp(FEncounter) and isEmptyProp(FPerformer) and isEmptyProp(FIdentifier) and isEmptyProp(FMethod) and isEmptyProp(FbasisList) and isEmptyProp(FpredictionList) and isEmptyProp(FMitigation);
end;

function TFhirRiskAssessment.equals(other : TObject) : boolean;
var
  o : TFhirRiskAssessment;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRiskAssessment)) then
    result := false
  else
  begin
    o := TFhirRiskAssessment(other);
    result := compareDeep(subjectElement, o.subjectElement, true) and compareDeep(dateElement, o.dateElement, true) and
      compareDeep(conditionElement, o.conditionElement, true) and compareDeep(encounterElement, o.encounterElement, true) and
      compareDeep(performerElement, o.performerElement, true) and compareDeep(identifierElement, o.identifierElement, true) and
      compareDeep(methodElement, o.methodElement, true) and compareDeep(basisList, o.basisList, true) and
      compareDeep(predictionList, o.predictionList, true) and compareDeep(mitigationElement, o.mitigationElement, true);
  end;
end;

function TFhirRiskAssessment.Link : TFhirRiskAssessment;
begin
  result := TFhirRiskAssessment(inherited Link);
end;

function TFhirRiskAssessment.Clone : TFhirRiskAssessment;
begin
  result := TFhirRiskAssessment(inherited Clone);
end;

procedure TFhirRiskAssessment.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('subject');
  fields.add('date');
  fields.add('condition');
  fields.add('encounter');
  fields.add('performer');
  fields.add('identifier');
  fields.add('method');
  fields.add('basis');
  fields.add('prediction');
  fields.add('mitigation');
end;

{ TFhirRiskAssessment }

Procedure TFhirRiskAssessment.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirRiskAssessment.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirRiskAssessment.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirRiskAssessment.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirRiskAssessment.SetCondition(value : TFhirReference{TFhirCondition});
begin
  FCondition.free;
  FCondition := value;
end;

Procedure TFhirRiskAssessment.SetEncounter(value : TFhirReference{TFhirEncounter});
begin
  FEncounter.free;
  FEncounter := value;
end;

Procedure TFhirRiskAssessment.SetPerformer(value : TFhirReference{Resource});
begin
  FPerformer.free;
  FPerformer := value;
end;

Procedure TFhirRiskAssessment.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirRiskAssessment.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value;
end;

Function TFhirRiskAssessment.GetBasisList : TFhirReferenceList{TFhirReference};
begin
  if FBasisList = nil then
    FBasisList := TFhirReferenceList{TFhirReference}.Create;
  result := FBasisList;
end;

Function TFhirRiskAssessment.GetHasBasisList : boolean;
begin
  result := (FBasisList <> nil) and (FBasisList.count > 0);
end;

Function TFhirRiskAssessment.GetPredictionList : TFhirRiskAssessmentPredictionList;
begin
  if FPredictionList = nil then
    FPredictionList := TFhirRiskAssessmentPredictionList.Create;
  result := FPredictionList;
end;

Function TFhirRiskAssessment.GetHasPredictionList : boolean;
begin
  result := (FPredictionList <> nil) and (FPredictionList.count > 0);
end;

Procedure TFhirRiskAssessment.SetMitigation(value : TFhirString);
begin
  FMitigation.free;
  FMitigation := value;
end;

Function TFhirRiskAssessment.GetMitigationST : String;
begin
  if FMitigation = nil then
    result := ''
  else
    result := FMitigation.value;
end;

Procedure TFhirRiskAssessment.SetMitigationST(value : String);
begin
  if value <> '' then
  begin
    if FMitigation = nil then
      FMitigation := TFhirString.create;
    FMitigation.value := value
  end
  else if FMitigation <> nil then
    FMitigation.value := '';
end;

function TFhirRiskAssessment.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSubject.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FCondition.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FPerformer.sizeInBytes);
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FMethod.sizeInBytes);
  inc(result, FbasisList.sizeInBytes);
  inc(result, FpredictionList.sizeInBytes);
  inc(result, FMitigation.sizeInBytes);
end;

{ TFhirRiskAssessmentListEnumerator }

Constructor TFhirRiskAssessmentListEnumerator.Create(list : TFhirRiskAssessmentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRiskAssessmentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRiskAssessmentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRiskAssessmentListEnumerator.GetCurrent : TFhirRiskAssessment;
begin
  Result := FList[FIndex];
end;

function TFhirRiskAssessmentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirRiskAssessmentList }
procedure TFhirRiskAssessmentList.AddItem(value: TFhirRiskAssessment);
begin
  assert(value.ClassName = 'TFhirRiskAssessment', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRiskAssessment');
  add(value);
end;

function TFhirRiskAssessmentList.Append: TFhirRiskAssessment;
begin
  result := TFhirRiskAssessment.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRiskAssessmentList.ClearItems;
begin
  Clear;
end;

function TFhirRiskAssessmentList.GetEnumerator : TFhirRiskAssessmentListEnumerator;
begin
  result := TFhirRiskAssessmentListEnumerator.Create(self.link);
end;

function TFhirRiskAssessmentList.Clone: TFhirRiskAssessmentList;
begin
  result := TFhirRiskAssessmentList(inherited Clone);
end;

function TFhirRiskAssessmentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRiskAssessmentList.GetItemN(index: Integer): TFhirRiskAssessment;
begin
  result := TFhirRiskAssessment(ObjectByIndex[index]);
end;

function TFhirRiskAssessmentList.ItemClass: TFslObjectClass;
begin
  result := TFhirRiskAssessment;
end;
function TFhirRiskAssessmentList.IndexOf(value: TFhirRiskAssessment): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRiskAssessmentList.Insert(index: Integer): TFhirRiskAssessment;
begin
  result := TFhirRiskAssessment.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRiskAssessmentList.InsertItem(index: Integer; value: TFhirRiskAssessment);
begin
  assert(value is TFhirRiskAssessment);
  Inherited Insert(index, value);
end;

function TFhirRiskAssessmentList.Item(index: Integer): TFhirRiskAssessment;
begin
  result := TFhirRiskAssessment(ObjectByIndex[index]);
end;

function TFhirRiskAssessmentList.Link: TFhirRiskAssessmentList;
begin
  result := TFhirRiskAssessmentList(inherited Link);
end;

procedure TFhirRiskAssessmentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRiskAssessmentList.SetItemByIndex(index: Integer; value: TFhirRiskAssessment);
begin
  assert(value is TFhirRiskAssessment);
  FhirRiskAssessments[index] := value;
end;

procedure TFhirRiskAssessmentList.SetItemN(index: Integer; value: TFhirRiskAssessment);
begin
  assert(value is TFhirRiskAssessment);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_RISKASSESSMENT}

{$IFDEF FHIR_SPECIMEN}

{ TFhirSpecimenCollection }

constructor TFhirSpecimenCollection.Create;
begin
  inherited;
end;

destructor TFhirSpecimenCollection.Destroy;
begin
  FCollector.free;
  FCommentList.Free;
  FCollected.free;
  FQuantity.free;
  FMethod.free;
  FBodySite.free;
  inherited;
end;

procedure TFhirSpecimenCollection.Assign(oSource : TFslObject);
begin
  inherited;
  collector := TFhirSpecimenCollection(oSource).collector.Clone;
  if (TFhirSpecimenCollection(oSource).FCommentList = nil) then
  begin
    FCommentList.free;
    FCommentList := nil;
  end
  else
  begin
    if FCommentList = nil then
      FCommentList := TFhirStringList.Create;
    FCommentList.Assign(TFhirSpecimenCollection(oSource).FCommentList);
  end;
  collected := TFhirSpecimenCollection(oSource).collected.Clone;
  quantity := TFhirSpecimenCollection(oSource).quantity.Clone;
  method := TFhirSpecimenCollection(oSource).method.Clone;
  bodySite := TFhirSpecimenCollection(oSource).bodySite.Clone;
end;

procedure TFhirSpecimenCollection.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'collector') Then
     list.add(self.link, 'collector', FCollector.Link);
  if (child_name = 'comment') Then
    list.addAll(self, 'comment', FCommentList);
  if (child_name = 'collected[x]') or (child_name = 'collected') Then
     list.add(self.link, 'collected[x]', FCollected.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'method') Then
     list.add(self.link, 'method', FMethod.Link);
  if (child_name = 'bodySite') Then
     list.add(self.link, 'bodySite', FBodySite.Link);
end;

procedure TFhirSpecimenCollection.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'collector', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FCollector.Link));{2}
  oList.add(TFHIRProperty.create(self, 'comment', 'string', true, TFhirString, FCommentList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'collected[x]', 'dateTime|Period', false, TFhirType, FCollected.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', false, TFhirCodeableConcept, FMethod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', false, TFhirCodeableConcept, FBodySite.Link));{2}
end;

function TFhirSpecimenCollection.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'collector') then
  begin
    Collector := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentList.add(asString(propValue)){2};     result := propValue;

  end
  else if (isMatchingName(propName, 'collected', ['DateTime', 'Period'])) then
  begin
    Collected := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'method') then
  begin
    Method := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySite := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSpecimenCollection.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'comment') then CommentList.insertItem(index, asString(propValue)){2}
  else inherited;
end;

function TFhirSpecimenCollection.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'collector') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'comment') then result := CommentList.new(){2}
  else if (isMatchingName(propName, 'collected', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Collected'){4x}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'method') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'bodySite') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSpecimenCollection.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'collector') then result := 'Reference'
  else if (propName = 'comment') then result := 'string'
  else if (propName = 'collected[x]') then result := 'dateTime|Period'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'method') then result := 'CodeableConcept'
  else if (propName = 'bodySite') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSpecimenCollection.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'collector') then CollectorElement := nil
  else if (propName = 'comment') then deletePropertyValue('comment', CommentList, value) {2}
  else if (isMatchingName(propName, 'collected', ['DateTime', 'Period'])) then CollectedElement := nil{4x}
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'method') then MethodElement := nil
  else if (propName = 'bodySite') then BodySiteElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSpecimenCollection.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'collector') then CollectorElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'comment') then replacePropertyValue('comment', CommentList, existing, new) {2}
  else if (isMatchingName(propName, 'collected', ['DateTime', 'Period'])) then CollectedElement := new as TFhirType{4x}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'method') then MethodElement := new as TFhirCodeableConcept{4}
  else if (propName = 'bodySite') then BodySiteElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSpecimenCollection.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'comment') then CommentList.move(source, destination){2}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSpecimenCollection.fhirType : string;
begin
  result := 'collection';
end;

function TFhirSpecimenCollection.Link : TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection(inherited Link);
end;

function TFhirSpecimenCollection.Clone : TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection(inherited Clone);
end;

function TFhirSpecimenCollection.equals(other : TObject) : boolean;
var
  o : TFhirSpecimenCollection;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSpecimenCollection)) then
    result := false
  else
  begin
    o := TFhirSpecimenCollection(other);
    result := compareDeep(collectorElement, o.collectorElement, true) and compareDeep(commentList, o.commentList, true) and
      compareDeep(collectedElement, o.collectedElement, true) and compareDeep(quantityElement, o.quantityElement, true) and
      compareDeep(methodElement, o.methodElement, true) and compareDeep(bodySiteElement, o.bodySiteElement, true);
  end;
end;

function TFhirSpecimenCollection.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCollector) and isEmptyProp(FcommentList) and isEmptyProp(FCollected) and isEmptyProp(FQuantity) and isEmptyProp(FMethod) and isEmptyProp(FBodySite);
end;

procedure TFhirSpecimenCollection.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('collector');
  fields.add('comment');
  fields.add('collected[x]');
  fields.add('quantity');
  fields.add('method');
  fields.add('bodySite');
end;

{ TFhirSpecimenCollection }

Procedure TFhirSpecimenCollection.SetCollector(value : TFhirReference{TFhirPractitioner});
begin
  FCollector.free;
  FCollector := value;
end;

Function TFhirSpecimenCollection.GetCommentList : TFhirStringList;
begin
  if FCommentList = nil then
    FCommentList := TFhirStringList.Create;
  result := FCommentList;
end;

Function TFhirSpecimenCollection.GetHasCommentList : boolean;
begin
  result := (FCommentList <> nil) and (FCommentList.count > 0);
end;

Procedure TFhirSpecimenCollection.SetCollected(value : TFhirType);
begin
  FCollected.free;
  FCollected := value;
end;

Procedure TFhirSpecimenCollection.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirSpecimenCollection.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value;
end;

Procedure TFhirSpecimenCollection.SetBodySite(value : TFhirCodeableConcept);
begin
  FBodySite.free;
  FBodySite := value;
end;

function TFhirSpecimenCollection.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCollector.sizeInBytes);
  inc(result, FcommentList.sizeInBytes);
  inc(result, FCollected.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FMethod.sizeInBytes);
  inc(result, FBodySite.sizeInBytes);
end;

{ TFhirSpecimenCollectionListEnumerator }

Constructor TFhirSpecimenCollectionListEnumerator.Create(list : TFhirSpecimenCollectionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSpecimenCollectionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSpecimenCollectionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSpecimenCollectionListEnumerator.GetCurrent : TFhirSpecimenCollection;
begin
  Result := FList[FIndex];
end;

function TFhirSpecimenCollectionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSpecimenCollectionList }
procedure TFhirSpecimenCollectionList.AddItem(value: TFhirSpecimenCollection);
begin
  assert(value.ClassName = 'TFhirSpecimenCollection', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSpecimenCollection');
  add(value);
end;

function TFhirSpecimenCollectionList.Append: TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSpecimenCollectionList.ClearItems;
begin
  Clear;
end;

function TFhirSpecimenCollectionList.GetEnumerator : TFhirSpecimenCollectionListEnumerator;
begin
  result := TFhirSpecimenCollectionListEnumerator.Create(self.link);
end;

function TFhirSpecimenCollectionList.Clone: TFhirSpecimenCollectionList;
begin
  result := TFhirSpecimenCollectionList(inherited Clone);
end;

function TFhirSpecimenCollectionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSpecimenCollectionList.GetItemN(index: Integer): TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection(ObjectByIndex[index]);
end;

function TFhirSpecimenCollectionList.ItemClass: TFslObjectClass;
begin
  result := TFhirSpecimenCollection;
end;
function TFhirSpecimenCollectionList.IndexOf(value: TFhirSpecimenCollection): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSpecimenCollectionList.Insert(index: Integer): TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSpecimenCollectionList.InsertItem(index: Integer; value: TFhirSpecimenCollection);
begin
  assert(value is TFhirSpecimenCollection);
  Inherited Insert(index, value);
end;

function TFhirSpecimenCollectionList.Item(index: Integer): TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection(ObjectByIndex[index]);
end;

function TFhirSpecimenCollectionList.Link: TFhirSpecimenCollectionList;
begin
  result := TFhirSpecimenCollectionList(inherited Link);
end;

procedure TFhirSpecimenCollectionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSpecimenCollectionList.SetItemByIndex(index: Integer; value: TFhirSpecimenCollection);
begin
  assert(value is TFhirSpecimenCollection);
  FhirSpecimenCollections[index] := value;
end;

procedure TFhirSpecimenCollectionList.SetItemN(index: Integer; value: TFhirSpecimenCollection);
begin
  assert(value is TFhirSpecimenCollection);
  ObjectByIndex[index] := value;
end;

{ TFhirSpecimenTreatment }

constructor TFhirSpecimenTreatment.Create;
begin
  inherited;
end;

destructor TFhirSpecimenTreatment.Destroy;
begin
  FDescription.free;
  FProcedure_.free;
  FAdditiveList.Free;
  inherited;
end;

procedure TFhirSpecimenTreatment.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirSpecimenTreatment(oSource).descriptionElement.Clone;
  procedure_ := TFhirSpecimenTreatment(oSource).procedure_.Clone;
  if (TFhirSpecimenTreatment(oSource).FAdditiveList = nil) then
  begin
    FAdditiveList.free;
    FAdditiveList := nil;
  end
  else
  begin
    if FAdditiveList = nil then
      FAdditiveList := TFhirReferenceList{TFhirSubstance}.Create;
    FAdditiveList.Assign(TFhirSpecimenTreatment(oSource).FAdditiveList);
  end;
end;

procedure TFhirSpecimenTreatment.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'procedure') Then
     list.add(self.link, 'procedure', FProcedure_.Link);
  if (child_name = 'additive') Then
    list.addAll(self, 'additive', FAdditiveList);
end;

procedure TFhirSpecimenTreatment.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'procedure', 'CodeableConcept', false, TFhirCodeableConcept, FProcedure_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'additive', 'Reference(Substance)', true, TFhirReference{TFhirSubstance}, FAdditiveList.Link)){3};
end;

function TFhirSpecimenTreatment.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'procedure') then
  begin
    Procedure_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'additive') then
  begin
    AdditiveList.add(propValue as TFhirReference{TFhirSubstance}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSpecimenTreatment.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'additive') then AdditiveList.insertItem(index, propValue as TFhirReference{TFhirSubstance}){2a}
  else inherited;
end;

function TFhirSpecimenTreatment.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'procedure') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'additive') then result := AdditiveList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSpecimenTreatment.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'procedure') then result := 'CodeableConcept'
  else if (propName = 'additive') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSpecimenTreatment.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'procedure') then Procedure_Element := nil
  else if (propName = 'additive') then deletePropertyValue('additive', AdditiveList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSpecimenTreatment.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'procedure') then Procedure_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'additive') then replacePropertyValue('additive', AdditiveList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSpecimenTreatment.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'additive') then AdditiveList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSpecimenTreatment.fhirType : string;
begin
  result := 'treatment';
end;

function TFhirSpecimenTreatment.Link : TFhirSpecimenTreatment;
begin
  result := TFhirSpecimenTreatment(inherited Link);
end;

function TFhirSpecimenTreatment.Clone : TFhirSpecimenTreatment;
begin
  result := TFhirSpecimenTreatment(inherited Clone);
end;

function TFhirSpecimenTreatment.equals(other : TObject) : boolean;
var
  o : TFhirSpecimenTreatment;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSpecimenTreatment)) then
    result := false
  else
  begin
    o := TFhirSpecimenTreatment(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(procedure_Element, o.procedure_Element, true) and
      compareDeep(additiveList, o.additiveList, true);
  end;
end;

function TFhirSpecimenTreatment.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FProcedure_) and isEmptyProp(FadditiveList);
end;

procedure TFhirSpecimenTreatment.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('description');
  fields.add('procedure');
  fields.add('additive');
end;

{ TFhirSpecimenTreatment }

Procedure TFhirSpecimenTreatment.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirSpecimenTreatment.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirSpecimenTreatment.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirSpecimenTreatment.SetProcedure_(value : TFhirCodeableConcept);
begin
  FProcedure_.free;
  FProcedure_ := value;
end;

Function TFhirSpecimenTreatment.GetAdditiveList : TFhirReferenceList{TFhirSubstance};
begin
  if FAdditiveList = nil then
    FAdditiveList := TFhirReferenceList{TFhirSubstance}.Create;
  result := FAdditiveList;
end;

Function TFhirSpecimenTreatment.GetHasAdditiveList : boolean;
begin
  result := (FAdditiveList <> nil) and (FAdditiveList.count > 0);
end;

function TFhirSpecimenTreatment.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDescription.sizeInBytes);
  inc(result, FProcedure_.sizeInBytes);
  inc(result, FadditiveList.sizeInBytes);
end;

{ TFhirSpecimenTreatmentListEnumerator }

Constructor TFhirSpecimenTreatmentListEnumerator.Create(list : TFhirSpecimenTreatmentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSpecimenTreatmentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSpecimenTreatmentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSpecimenTreatmentListEnumerator.GetCurrent : TFhirSpecimenTreatment;
begin
  Result := FList[FIndex];
end;

function TFhirSpecimenTreatmentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSpecimenTreatmentList }
procedure TFhirSpecimenTreatmentList.AddItem(value: TFhirSpecimenTreatment);
begin
  assert(value.ClassName = 'TFhirSpecimenTreatment', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSpecimenTreatment');
  add(value);
end;

function TFhirSpecimenTreatmentList.Append: TFhirSpecimenTreatment;
begin
  result := TFhirSpecimenTreatment.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSpecimenTreatmentList.ClearItems;
begin
  Clear;
end;

function TFhirSpecimenTreatmentList.GetEnumerator : TFhirSpecimenTreatmentListEnumerator;
begin
  result := TFhirSpecimenTreatmentListEnumerator.Create(self.link);
end;

function TFhirSpecimenTreatmentList.Clone: TFhirSpecimenTreatmentList;
begin
  result := TFhirSpecimenTreatmentList(inherited Clone);
end;

function TFhirSpecimenTreatmentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSpecimenTreatmentList.GetItemN(index: Integer): TFhirSpecimenTreatment;
begin
  result := TFhirSpecimenTreatment(ObjectByIndex[index]);
end;

function TFhirSpecimenTreatmentList.ItemClass: TFslObjectClass;
begin
  result := TFhirSpecimenTreatment;
end;
function TFhirSpecimenTreatmentList.IndexOf(value: TFhirSpecimenTreatment): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSpecimenTreatmentList.Insert(index: Integer): TFhirSpecimenTreatment;
begin
  result := TFhirSpecimenTreatment.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSpecimenTreatmentList.InsertItem(index: Integer; value: TFhirSpecimenTreatment);
begin
  assert(value is TFhirSpecimenTreatment);
  Inherited Insert(index, value);
end;

function TFhirSpecimenTreatmentList.Item(index: Integer): TFhirSpecimenTreatment;
begin
  result := TFhirSpecimenTreatment(ObjectByIndex[index]);
end;

function TFhirSpecimenTreatmentList.Link: TFhirSpecimenTreatmentList;
begin
  result := TFhirSpecimenTreatmentList(inherited Link);
end;

procedure TFhirSpecimenTreatmentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSpecimenTreatmentList.SetItemByIndex(index: Integer; value: TFhirSpecimenTreatment);
begin
  assert(value is TFhirSpecimenTreatment);
  FhirSpecimenTreatments[index] := value;
end;

procedure TFhirSpecimenTreatmentList.SetItemN(index: Integer; value: TFhirSpecimenTreatment);
begin
  assert(value is TFhirSpecimenTreatment);
  ObjectByIndex[index] := value;
end;

{ TFhirSpecimenContainer }

constructor TFhirSpecimenContainer.Create;
begin
  inherited;
end;

destructor TFhirSpecimenContainer.Destroy;
begin
  FIdentifierList.Free;
  FDescription.free;
  FType_.free;
  FCapacity.free;
  FSpecimenQuantity.free;
  FAdditive.free;
  inherited;
end;

procedure TFhirSpecimenContainer.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirSpecimenContainer(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirSpecimenContainer(oSource).FIdentifierList);
  end;
  descriptionElement := TFhirSpecimenContainer(oSource).descriptionElement.Clone;
  type_ := TFhirSpecimenContainer(oSource).type_.Clone;
  capacity := TFhirSpecimenContainer(oSource).capacity.Clone;
  specimenQuantity := TFhirSpecimenContainer(oSource).specimenQuantity.Clone;
  additive := TFhirSpecimenContainer(oSource).additive.Clone;
end;

procedure TFhirSpecimenContainer.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'capacity') Then
     list.add(self.link, 'capacity', FCapacity.Link);
  if (child_name = 'specimenQuantity') Then
     list.add(self.link, 'specimenQuantity', FSpecimenQuantity.Link);
  if (child_name = 'additive[x]') or (child_name = 'additive') Then
     list.add(self.link, 'additive[x]', FAdditive.Link);
end;

procedure TFhirSpecimenContainer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'capacity', 'Quantity', false, TFhirQuantity, FCapacity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'specimenQuantity', 'Quantity', false, TFhirQuantity, FSpecimenQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'additive[x]', 'CodeableConcept|Reference(Substance)', false, TFhirType, FAdditive.Link));{2}
end;

function TFhirSpecimenContainer.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'capacity') then
  begin
    Capacity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'specimenQuantity') then
  begin
    SpecimenQuantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'additive', ['CodeableConcept', 'Reference'])) then
  begin
    Additive := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSpecimenContainer.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else inherited;
end;

function TFhirSpecimenContainer.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'capacity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'specimenQuantity') then result := TFhirQuantity.create(){4b}
  else if (isMatchingName(propName, 'additive', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Additive'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSpecimenContainer.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'capacity') then result := 'Quantity'
  else if (propName = 'specimenQuantity') then result := 'Quantity'
  else if (propName = 'additive[x]') then result := 'CodeableConcept|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSpecimenContainer.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'capacity') then CapacityElement := nil
  else if (propName = 'specimenQuantity') then SpecimenQuantityElement := nil
  else if (isMatchingName(propName, 'additive', ['CodeableConcept', 'Reference'])) then AdditiveElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSpecimenContainer.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'capacity') then CapacityElement := new as TFhirQuantity{4}
  else if (propName = 'specimenQuantity') then SpecimenQuantityElement := new as TFhirQuantity{4}
  else if (isMatchingName(propName, 'additive', ['CodeableConcept', 'Reference'])) then AdditiveElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSpecimenContainer.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSpecimenContainer.fhirType : string;
begin
  result := 'container';
end;

function TFhirSpecimenContainer.Link : TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer(inherited Link);
end;

function TFhirSpecimenContainer.Clone : TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer(inherited Clone);
end;

function TFhirSpecimenContainer.equals(other : TObject) : boolean;
var
  o : TFhirSpecimenContainer;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSpecimenContainer)) then
    result := false
  else
  begin
    o := TFhirSpecimenContainer(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(descriptionElement, o.descriptionElement, true) and
      compareDeep(type_Element, o.type_Element, true) and compareDeep(capacityElement, o.capacityElement, true) and
      compareDeep(specimenQuantityElement, o.specimenQuantityElement, true) and compareDeep(additiveElement, o.additiveElement, true);
  end;
end;

function TFhirSpecimenContainer.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FDescription) and isEmptyProp(FType_) and isEmptyProp(FCapacity) and isEmptyProp(FSpecimenQuantity) and isEmptyProp(FAdditive);
end;

procedure TFhirSpecimenContainer.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('description');
  fields.add('type');
  fields.add('capacity');
  fields.add('specimenQuantity');
  fields.add('additive[x]');
end;

{ TFhirSpecimenContainer }

Function TFhirSpecimenContainer.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirSpecimenContainer.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirSpecimenContainer.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirSpecimenContainer.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirSpecimenContainer.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirSpecimenContainer.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirSpecimenContainer.SetCapacity(value : TFhirQuantity);
begin
  FCapacity.free;
  FCapacity := value;
end;

Procedure TFhirSpecimenContainer.SetSpecimenQuantity(value : TFhirQuantity);
begin
  FSpecimenQuantity.free;
  FSpecimenQuantity := value;
end;

Procedure TFhirSpecimenContainer.SetAdditive(value : TFhirType);
begin
  FAdditive.free;
  FAdditive := value;
end;

function TFhirSpecimenContainer.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FCapacity.sizeInBytes);
  inc(result, FSpecimenQuantity.sizeInBytes);
  inc(result, FAdditive.sizeInBytes);
end;

{ TFhirSpecimenContainerListEnumerator }

Constructor TFhirSpecimenContainerListEnumerator.Create(list : TFhirSpecimenContainerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSpecimenContainerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSpecimenContainerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSpecimenContainerListEnumerator.GetCurrent : TFhirSpecimenContainer;
begin
  Result := FList[FIndex];
end;

function TFhirSpecimenContainerListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSpecimenContainerList }
procedure TFhirSpecimenContainerList.AddItem(value: TFhirSpecimenContainer);
begin
  assert(value.ClassName = 'TFhirSpecimenContainer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSpecimenContainer');
  add(value);
end;

function TFhirSpecimenContainerList.Append: TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSpecimenContainerList.ClearItems;
begin
  Clear;
end;

function TFhirSpecimenContainerList.GetEnumerator : TFhirSpecimenContainerListEnumerator;
begin
  result := TFhirSpecimenContainerListEnumerator.Create(self.link);
end;

function TFhirSpecimenContainerList.Clone: TFhirSpecimenContainerList;
begin
  result := TFhirSpecimenContainerList(inherited Clone);
end;

function TFhirSpecimenContainerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSpecimenContainerList.GetItemN(index: Integer): TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer(ObjectByIndex[index]);
end;

function TFhirSpecimenContainerList.ItemClass: TFslObjectClass;
begin
  result := TFhirSpecimenContainer;
end;
function TFhirSpecimenContainerList.IndexOf(value: TFhirSpecimenContainer): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSpecimenContainerList.Insert(index: Integer): TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSpecimenContainerList.InsertItem(index: Integer; value: TFhirSpecimenContainer);
begin
  assert(value is TFhirSpecimenContainer);
  Inherited Insert(index, value);
end;

function TFhirSpecimenContainerList.Item(index: Integer): TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer(ObjectByIndex[index]);
end;

function TFhirSpecimenContainerList.Link: TFhirSpecimenContainerList;
begin
  result := TFhirSpecimenContainerList(inherited Link);
end;

procedure TFhirSpecimenContainerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSpecimenContainerList.SetItemByIndex(index: Integer; value: TFhirSpecimenContainer);
begin
  assert(value is TFhirSpecimenContainer);
  FhirSpecimenContainers[index] := value;
end;

procedure TFhirSpecimenContainerList.SetItemN(index: Integer; value: TFhirSpecimenContainer);
begin
  assert(value is TFhirSpecimenContainer);
  ObjectByIndex[index] := value;
end;

{ TFhirSpecimen }

constructor TFhirSpecimen.Create;
begin
  inherited;
end;

destructor TFhirSpecimen.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FType_.free;
  FParentList.Free;
  FSubject.free;
  FAccessionIdentifier.free;
  FReceivedTime.free;
  FCollection.free;
  FTreatmentList.Free;
  FContainerList.Free;
  inherited;
end;

function TFhirSpecimen.GetResourceType : TFhirResourceType;
begin
  result := frtSpecimen;
end;

procedure TFhirSpecimen.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirSpecimen(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirSpecimen(oSource).FIdentifierList);
  end;
  FStatus := TFhirSpecimen(oSource).FStatus.Link;
  type_ := TFhirSpecimen(oSource).type_.Clone;
  if (TFhirSpecimen(oSource).FParentList = nil) then
  begin
    FParentList.free;
    FParentList := nil;
  end
  else
  begin
    if FParentList = nil then
      FParentList := TFhirReferenceList{TFhirSpecimen}.Create;
    FParentList.Assign(TFhirSpecimen(oSource).FParentList);
  end;
  subject := TFhirSpecimen(oSource).subject.Clone;
  accessionIdentifier := TFhirSpecimen(oSource).accessionIdentifier.Clone;
  receivedTimeElement := TFhirSpecimen(oSource).receivedTimeElement.Clone;
  collection := TFhirSpecimen(oSource).collection.Clone;
  if (TFhirSpecimen(oSource).FTreatmentList = nil) then
  begin
    FTreatmentList.free;
    FTreatmentList := nil;
  end
  else
  begin
    if FTreatmentList = nil then
      FTreatmentList := TFhirSpecimenTreatmentList.Create;
    FTreatmentList.Assign(TFhirSpecimen(oSource).FTreatmentList);
  end;
  if (TFhirSpecimen(oSource).FContainerList = nil) then
  begin
    FContainerList.free;
    FContainerList := nil;
  end
  else
  begin
    if FContainerList = nil then
      FContainerList := TFhirSpecimenContainerList.Create;
    FContainerList.Assign(TFhirSpecimen(oSource).FContainerList);
  end;
end;

procedure TFhirSpecimen.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'parent') Then
    list.addAll(self, 'parent', FParentList);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'accessionIdentifier') Then
     list.add(self.link, 'accessionIdentifier', FAccessionIdentifier.Link);
  if (child_name = 'receivedTime') Then
     list.add(self.link, 'receivedTime', FReceivedTime.Link);
  if (child_name = 'collection') Then
     list.add(self.link, 'collection', FCollection.Link);
  if (child_name = 'treatment') Then
    list.addAll(self, 'treatment', FTreatmentList);
  if (child_name = 'container') Then
    list.addAll(self, 'container', FContainerList);
end;

procedure TFhirSpecimen.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'parent', 'Reference(Specimen)', true, TFhirReference{TFhirSpecimen}, FParentList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Group|Device|Substance)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'accessionIdentifier', 'Identifier', false, TFhirIdentifier, FAccessionIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'receivedTime', 'dateTime', false, TFhirDateTime, FReceivedTime.Link));{2}
  oList.add(TFHIRProperty.create(self, 'collection', '', false, TFhirSpecimenCollection, FCollection.Link));{2}
  oList.add(TFHIRProperty.create(self, 'treatment', '', true, TFhirSpecimenTreatment, FTreatmentList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'container', '', true, TFhirSpecimenContainer, FContainerList.Link)){3};
end;

function TFhirSpecimen.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirSpecimenStatusEnum, CODES_TFhirSpecimenStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'parent') then
  begin
    ParentList.add(propValue as TFhirReference{TFhirSpecimen}){2a};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'accessionIdentifier') then
  begin
    AccessionIdentifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'receivedTime') then
  begin
    ReceivedTimeElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'collection') then
  begin
    Collection := propValue as TFhirSpecimenCollection{4b};
    result := propValue;
  end
  else if (propName = 'treatment') then
  begin
    TreatmentList.add(propValue as TFhirSpecimenTreatment){2a};
    result := propValue;
  end
  else if (propName = 'container') then
  begin
    ContainerList.add(propValue as TFhirSpecimenContainer){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirSpecimen.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'parent') then ParentList.insertItem(index, propValue as TFhirReference{TFhirSpecimen}){2a}
  else if (propName = 'treatment') then TreatmentList.insertItem(index, propValue as TFhirSpecimenTreatment){2a}
  else if (propName = 'container') then ContainerList.insertItem(index, propValue as TFhirSpecimenContainer){2a}
  else inherited;
end;

function TFhirSpecimen.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'parent') then result := ParentList.new(){2}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'accessionIdentifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'receivedTime') then result := TFhirDateTime.create() {5b}
  else if (propName = 'collection') then result := TFhirSpecimenCollection.create(){4b}
  else if (propName = 'treatment') then result := TreatmentList.new(){2}
  else if (propName = 'container') then result := ContainerList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSpecimen.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'parent') then result := 'Reference'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'accessionIdentifier') then result := 'Identifier'
  else if (propName = 'receivedTime') then result := 'dateTime'
  else if (propName = 'collection') then result := ''
  else if (propName = 'treatment') then result := ''
  else if (propName = 'container') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSpecimen.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'parent') then deletePropertyValue('parent', ParentList, value) {2}
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'accessionIdentifier') then AccessionIdentifierElement := nil
  else if (propName = 'receivedTime') then ReceivedTimeElement := nil
  else if (propName = 'collection') then CollectionElement := nil
  else if (propName = 'treatment') then deletePropertyValue('treatment', TreatmentList, value) {2}
  else if (propName = 'container') then deletePropertyValue('container', ContainerList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSpecimen.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirSpecimenStatusEnum, CODES_TFhirSpecimenStatusEnum, new){4}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'parent') then replacePropertyValue('parent', ParentList, existing, new) {2}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'accessionIdentifier') then AccessionIdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'receivedTime') then ReceivedTimeElement := asDateTime(new){5b}
  else if (propName = 'collection') then CollectionElement := new as TFhirSpecimenCollection{4}
  else if (propName = 'treatment') then replacePropertyValue('treatment', TreatmentList, existing, new) {2}
  else if (propName = 'container') then replacePropertyValue('container', ContainerList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSpecimen.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'parent') then ParentList.move(source, destination){2a}
  else if (propName = 'treatment') then TreatmentList.move(source, destination){2a}
  else if (propName = 'container') then ContainerList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSpecimen.fhirType : string;
begin
  result := 'Specimen';
end;

function TFhirSpecimen.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FType_) and isEmptyProp(FparentList) and isEmptyProp(FSubject) and isEmptyProp(FAccessionIdentifier) and isEmptyProp(FReceivedTime) and isEmptyProp(FCollection) and isEmptyProp(FtreatmentList) and isEmptyProp(FcontainerList);
end;

function TFhirSpecimen.equals(other : TObject) : boolean;
var
  o : TFhirSpecimen;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSpecimen)) then
    result := false
  else
  begin
    o := TFhirSpecimen(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(type_Element, o.type_Element, true) and compareDeep(parentList, o.parentList, true) and
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(accessionIdentifierElement, o.accessionIdentifierElement, true) and
      compareDeep(receivedTimeElement, o.receivedTimeElement, true) and compareDeep(collectionElement, o.collectionElement, true) and
      compareDeep(treatmentList, o.treatmentList, true) and compareDeep(containerList, o.containerList, true);
  end;
end;

function TFhirSpecimen.Link : TFhirSpecimen;
begin
  result := TFhirSpecimen(inherited Link);
end;

function TFhirSpecimen.Clone : TFhirSpecimen;
begin
  result := TFhirSpecimen(inherited Clone);
end;

procedure TFhirSpecimen.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('type');
  fields.add('parent');
  fields.add('subject');
  fields.add('accessionIdentifier');
  fields.add('receivedTime');
  fields.add('collection');
  fields.add('treatment');
  fields.add('container');
end;

{ TFhirSpecimen }

Function TFhirSpecimen.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirSpecimen.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirSpecimen.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirSpecimen.GetStatusST : TFhirSpecimenStatusEnum;
begin
  if FStatus = nil then
    result := TFhirSpecimenStatusEnum(0)
  else
    result := TFhirSpecimenStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirSpecimenStatusEnum, FStatus.value));
end;

Procedure TFhirSpecimen.SetStatusST(value : TFhirSpecimenStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirSpecimenStatusEnum[value], CODES_TFhirSpecimenStatusEnum[value]);
end;

Procedure TFhirSpecimen.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirSpecimen.GetParentList : TFhirReferenceList{TFhirSpecimen};
begin
  if FParentList = nil then
    FParentList := TFhirReferenceList{TFhirSpecimen}.Create;
  result := FParentList;
end;

Function TFhirSpecimen.GetHasParentList : boolean;
begin
  result := (FParentList <> nil) and (FParentList.count > 0);
end;

Procedure TFhirSpecimen.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirSpecimen.SetAccessionIdentifier(value : TFhirIdentifier);
begin
  FAccessionIdentifier.free;
  FAccessionIdentifier := value;
end;

Procedure TFhirSpecimen.SetReceivedTime(value : TFhirDateTime);
begin
  FReceivedTime.free;
  FReceivedTime := value;
end;

Function TFhirSpecimen.GetReceivedTimeST : TFslDateTime;
begin
  if FReceivedTime = nil then
    result := TFslDateTime.makeNull
  else
    result := FReceivedTime.value;
end;

Procedure TFhirSpecimen.SetReceivedTimeST(value : TFslDateTime);
begin
  if FReceivedTime = nil then
    FReceivedTime := TFhirDateTime.create;
  FReceivedTime.value := value
end;

Procedure TFhirSpecimen.SetCollection(value : TFhirSpecimenCollection);
begin
  FCollection.free;
  FCollection := value;
end;

Function TFhirSpecimen.GetTreatmentList : TFhirSpecimenTreatmentList;
begin
  if FTreatmentList = nil then
    FTreatmentList := TFhirSpecimenTreatmentList.Create;
  result := FTreatmentList;
end;

Function TFhirSpecimen.GetHasTreatmentList : boolean;
begin
  result := (FTreatmentList <> nil) and (FTreatmentList.count > 0);
end;

Function TFhirSpecimen.GetContainerList : TFhirSpecimenContainerList;
begin
  if FContainerList = nil then
    FContainerList := TFhirSpecimenContainerList.Create;
  result := FContainerList;
end;

Function TFhirSpecimen.GetHasContainerList : boolean;
begin
  result := (FContainerList <> nil) and (FContainerList.count > 0);
end;

function TFhirSpecimen.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FparentList.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FAccessionIdentifier.sizeInBytes);
  inc(result, FReceivedTime.sizeInBytes);
  inc(result, FCollection.sizeInBytes);
  inc(result, FtreatmentList.sizeInBytes);
  inc(result, FcontainerList.sizeInBytes);
end;

{ TFhirSpecimenListEnumerator }

Constructor TFhirSpecimenListEnumerator.Create(list : TFhirSpecimenList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSpecimenListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSpecimenListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSpecimenListEnumerator.GetCurrent : TFhirSpecimen;
begin
  Result := FList[FIndex];
end;

function TFhirSpecimenListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSpecimenList }
procedure TFhirSpecimenList.AddItem(value: TFhirSpecimen);
begin
  assert(value.ClassName = 'TFhirSpecimen', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSpecimen');
  add(value);
end;

function TFhirSpecimenList.Append: TFhirSpecimen;
begin
  result := TFhirSpecimen.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSpecimenList.ClearItems;
begin
  Clear;
end;

function TFhirSpecimenList.GetEnumerator : TFhirSpecimenListEnumerator;
begin
  result := TFhirSpecimenListEnumerator.Create(self.link);
end;

function TFhirSpecimenList.Clone: TFhirSpecimenList;
begin
  result := TFhirSpecimenList(inherited Clone);
end;

function TFhirSpecimenList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSpecimenList.GetItemN(index: Integer): TFhirSpecimen;
begin
  result := TFhirSpecimen(ObjectByIndex[index]);
end;

function TFhirSpecimenList.ItemClass: TFslObjectClass;
begin
  result := TFhirSpecimen;
end;
function TFhirSpecimenList.IndexOf(value: TFhirSpecimen): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSpecimenList.Insert(index: Integer): TFhirSpecimen;
begin
  result := TFhirSpecimen.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSpecimenList.InsertItem(index: Integer; value: TFhirSpecimen);
begin
  assert(value is TFhirSpecimen);
  Inherited Insert(index, value);
end;

function TFhirSpecimenList.Item(index: Integer): TFhirSpecimen;
begin
  result := TFhirSpecimen(ObjectByIndex[index]);
end;

function TFhirSpecimenList.Link: TFhirSpecimenList;
begin
  result := TFhirSpecimenList(inherited Link);
end;

procedure TFhirSpecimenList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSpecimenList.SetItemByIndex(index: Integer; value: TFhirSpecimen);
begin
  assert(value is TFhirSpecimen);
  FhirSpecimen[index] := value;
end;

procedure TFhirSpecimenList.SetItemN(index: Integer; value: TFhirSpecimen);
begin
  assert(value is TFhirSpecimen);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SPECIMEN}

{$IFDEF FHIR_SUPPLYDELIVERY}

{ TFhirSupplyDelivery }

constructor TFhirSupplyDelivery.Create;
begin
  inherited;
end;

destructor TFhirSupplyDelivery.Destroy;
begin
  FIdentifier.free;
  FStatus.free;
  FPatient.free;
  FType_.free;
  FQuantity.free;
  FSuppliedItem.free;
  FSupplier.free;
  FWhenPrepared.free;
  FTime.free;
  FDestination.free;
  FReceiverList.Free;
  inherited;
end;

function TFhirSupplyDelivery.GetResourceType : TFhirResourceType;
begin
  result := frtSupplyDelivery;
end;

procedure TFhirSupplyDelivery.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirSupplyDelivery(oSource).identifier.Clone;
  FStatus := TFhirSupplyDelivery(oSource).FStatus.Link;
  patient := TFhirSupplyDelivery(oSource).patient.Clone;
  type_ := TFhirSupplyDelivery(oSource).type_.Clone;
  quantity := TFhirSupplyDelivery(oSource).quantity.Clone;
  suppliedItem := TFhirSupplyDelivery(oSource).suppliedItem.Clone;
  supplier := TFhirSupplyDelivery(oSource).supplier.Clone;
  whenPrepared := TFhirSupplyDelivery(oSource).whenPrepared.Clone;
  timeElement := TFhirSupplyDelivery(oSource).timeElement.Clone;
  destination := TFhirSupplyDelivery(oSource).destination.Clone;
  if (TFhirSupplyDelivery(oSource).FReceiverList = nil) then
  begin
    FReceiverList.free;
    FReceiverList := nil;
  end
  else
  begin
    if FReceiverList = nil then
      FReceiverList := TFhirReferenceList{TFhirPractitioner}.Create;
    FReceiverList.Assign(TFhirSupplyDelivery(oSource).FReceiverList);
  end;
end;

procedure TFhirSupplyDelivery.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'suppliedItem') Then
     list.add(self.link, 'suppliedItem', FSuppliedItem.Link);
  if (child_name = 'supplier') Then
     list.add(self.link, 'supplier', FSupplier.Link);
  if (child_name = 'whenPrepared') Then
     list.add(self.link, 'whenPrepared', FWhenPrepared.Link);
  if (child_name = 'time') Then
     list.add(self.link, 'time', FTime.Link);
  if (child_name = 'destination') Then
     list.add(self.link, 'destination', FDestination.Link);
  if (child_name = 'receiver') Then
    list.addAll(self, 'receiver', FReceiverList);
end;

procedure TFhirSupplyDelivery.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'suppliedItem', 'Reference(Medication|Substance|Device)', false, TFhirReference{Resource}, FSuppliedItem.Link));{2}
  oList.add(TFHIRProperty.create(self, 'supplier', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FSupplier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'whenPrepared', 'Period', false, TFhirPeriod, FWhenPrepared.Link));{2}
  oList.add(TFHIRProperty.create(self, 'time', 'dateTime', false, TFhirDateTime, FTime.Link));{2}
  oList.add(TFHIRProperty.create(self, 'destination', 'Reference(Location)', false, TFhirReference{TFhirLocation}, FDestination.Link));{2}
  oList.add(TFHIRProperty.create(self, 'receiver', 'Reference(Practitioner)', true, TFhirReference{TFhirPractitioner}, FReceiverList.Link)){3};
end;

function TFhirSupplyDelivery.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirSupplydeliveryStatusEnum, CODES_TFhirSupplydeliveryStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'suppliedItem') then
  begin
    SuppliedItem := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'supplier') then
  begin
    Supplier := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'whenPrepared') then
  begin
    WhenPrepared := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'time') then
  begin
    TimeElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'destination') then
  begin
    Destination := propValue as TFhirReference{TFhirLocation}{4b};
    result := propValue;
  end
  else if (propName = 'receiver') then
  begin
    ReceiverList.add(propValue as TFhirReference{TFhirPractitioner}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirSupplyDelivery.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'receiver') then ReceiverList.insertItem(index, propValue as TFhirReference{TFhirPractitioner}){2a}
  else inherited;
end;

function TFhirSupplyDelivery.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'suppliedItem') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'supplier') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'whenPrepared') then result := TFhirPeriod.create(){4b}
  else if (propName = 'time') then result := TFhirDateTime.create() {5b}
  else if (propName = 'destination') then result := TFhirReference{TFhirLocation}.create(){4b}
  else if (propName = 'receiver') then result := ReceiverList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSupplyDelivery.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'suppliedItem') then result := 'Reference'
  else if (propName = 'supplier') then result := 'Reference'
  else if (propName = 'whenPrepared') then result := 'Period'
  else if (propName = 'time') then result := 'dateTime'
  else if (propName = 'destination') then result := 'Reference'
  else if (propName = 'receiver') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSupplyDelivery.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'suppliedItem') then SuppliedItemElement := nil
  else if (propName = 'supplier') then SupplierElement := nil
  else if (propName = 'whenPrepared') then WhenPreparedElement := nil
  else if (propName = 'time') then TimeElement := nil
  else if (propName = 'destination') then DestinationElement := nil
  else if (propName = 'receiver') then deletePropertyValue('receiver', ReceiverList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSupplyDelivery.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirSupplydeliveryStatusEnum, CODES_TFhirSupplydeliveryStatusEnum, new){4}
  else if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'suppliedItem') then SuppliedItemElement := new as TFhirReference{Resource}{4}
  else if (propName = 'supplier') then SupplierElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'whenPrepared') then WhenPreparedElement := new as TFhirPeriod{4}
  else if (propName = 'time') then TimeElement := asDateTime(new){5b}
  else if (propName = 'destination') then DestinationElement := new as TFhirReference{TFhirLocation}{4}
  else if (propName = 'receiver') then replacePropertyValue('receiver', ReceiverList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSupplyDelivery.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'receiver') then ReceiverList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSupplyDelivery.fhirType : string;
begin
  result := 'SupplyDelivery';
end;

function TFhirSupplyDelivery.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FStatus) and isEmptyProp(FPatient) and isEmptyProp(FType_) and isEmptyProp(FQuantity) and isEmptyProp(FSuppliedItem) and isEmptyProp(FSupplier) and isEmptyProp(FWhenPrepared) and isEmptyProp(FTime) and isEmptyProp(FDestination) and isEmptyProp(FreceiverList);
end;

function TFhirSupplyDelivery.equals(other : TObject) : boolean;
var
  o : TFhirSupplyDelivery;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSupplyDelivery)) then
    result := false
  else
  begin
    o := TFhirSupplyDelivery(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(patientElement, o.patientElement, true) and compareDeep(type_Element, o.type_Element, true) and
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(suppliedItemElement, o.suppliedItemElement, true) and
      compareDeep(supplierElement, o.supplierElement, true) and compareDeep(whenPreparedElement, o.whenPreparedElement, true) and
      compareDeep(timeElement, o.timeElement, true) and compareDeep(destinationElement, o.destinationElement, true) and
      compareDeep(receiverList, o.receiverList, true);
  end;
end;

function TFhirSupplyDelivery.Link : TFhirSupplyDelivery;
begin
  result := TFhirSupplyDelivery(inherited Link);
end;

function TFhirSupplyDelivery.Clone : TFhirSupplyDelivery;
begin
  result := TFhirSupplyDelivery(inherited Clone);
end;

procedure TFhirSupplyDelivery.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('patient');
  fields.add('type');
  fields.add('quantity');
  fields.add('suppliedItem');
  fields.add('supplier');
  fields.add('whenPrepared');
  fields.add('time');
  fields.add('destination');
  fields.add('receiver');
end;

{ TFhirSupplyDelivery }

Procedure TFhirSupplyDelivery.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirSupplyDelivery.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirSupplyDelivery.GetStatusST : TFhirSupplydeliveryStatusEnum;
begin
  if FStatus = nil then
    result := TFhirSupplydeliveryStatusEnum(0)
  else
    result := TFhirSupplydeliveryStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirSupplydeliveryStatusEnum, FStatus.value));
end;

Procedure TFhirSupplyDelivery.SetStatusST(value : TFhirSupplydeliveryStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirSupplydeliveryStatusEnum[value], CODES_TFhirSupplydeliveryStatusEnum[value]);
end;

Procedure TFhirSupplyDelivery.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Procedure TFhirSupplyDelivery.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirSupplyDelivery.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirSupplyDelivery.SetSuppliedItem(value : TFhirReference{Resource});
begin
  FSuppliedItem.free;
  FSuppliedItem := value;
end;

Procedure TFhirSupplyDelivery.SetSupplier(value : TFhirReference{TFhirPractitioner});
begin
  FSupplier.free;
  FSupplier := value;
end;

Procedure TFhirSupplyDelivery.SetWhenPrepared(value : TFhirPeriod);
begin
  FWhenPrepared.free;
  FWhenPrepared := value;
end;

Procedure TFhirSupplyDelivery.SetTime(value : TFhirDateTime);
begin
  FTime.free;
  FTime := value;
end;

Function TFhirSupplyDelivery.GetTimeST : TFslDateTime;
begin
  if FTime = nil then
    result := TFslDateTime.makeNull
  else
    result := FTime.value;
end;

Procedure TFhirSupplyDelivery.SetTimeST(value : TFslDateTime);
begin
  if FTime = nil then
    FTime := TFhirDateTime.create;
  FTime.value := value
end;

Procedure TFhirSupplyDelivery.SetDestination(value : TFhirReference{TFhirLocation});
begin
  FDestination.free;
  FDestination := value;
end;

Function TFhirSupplyDelivery.GetReceiverList : TFhirReferenceList{TFhirPractitioner};
begin
  if FReceiverList = nil then
    FReceiverList := TFhirReferenceList{TFhirPractitioner}.Create;
  result := FReceiverList;
end;

Function TFhirSupplyDelivery.GetHasReceiverList : boolean;
begin
  result := (FReceiverList <> nil) and (FReceiverList.count > 0);
end;

function TFhirSupplyDelivery.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FSuppliedItem.sizeInBytes);
  inc(result, FSupplier.sizeInBytes);
  inc(result, FWhenPrepared.sizeInBytes);
  inc(result, FTime.sizeInBytes);
  inc(result, FDestination.sizeInBytes);
  inc(result, FreceiverList.sizeInBytes);
end;

{ TFhirSupplyDeliveryListEnumerator }

Constructor TFhirSupplyDeliveryListEnumerator.Create(list : TFhirSupplyDeliveryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSupplyDeliveryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSupplyDeliveryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSupplyDeliveryListEnumerator.GetCurrent : TFhirSupplyDelivery;
begin
  Result := FList[FIndex];
end;

function TFhirSupplyDeliveryListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSupplyDeliveryList }
procedure TFhirSupplyDeliveryList.AddItem(value: TFhirSupplyDelivery);
begin
  assert(value.ClassName = 'TFhirSupplyDelivery', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSupplyDelivery');
  add(value);
end;

function TFhirSupplyDeliveryList.Append: TFhirSupplyDelivery;
begin
  result := TFhirSupplyDelivery.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSupplyDeliveryList.ClearItems;
begin
  Clear;
end;

function TFhirSupplyDeliveryList.GetEnumerator : TFhirSupplyDeliveryListEnumerator;
begin
  result := TFhirSupplyDeliveryListEnumerator.Create(self.link);
end;

function TFhirSupplyDeliveryList.Clone: TFhirSupplyDeliveryList;
begin
  result := TFhirSupplyDeliveryList(inherited Clone);
end;

function TFhirSupplyDeliveryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSupplyDeliveryList.GetItemN(index: Integer): TFhirSupplyDelivery;
begin
  result := TFhirSupplyDelivery(ObjectByIndex[index]);
end;

function TFhirSupplyDeliveryList.ItemClass: TFslObjectClass;
begin
  result := TFhirSupplyDelivery;
end;
function TFhirSupplyDeliveryList.IndexOf(value: TFhirSupplyDelivery): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSupplyDeliveryList.Insert(index: Integer): TFhirSupplyDelivery;
begin
  result := TFhirSupplyDelivery.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSupplyDeliveryList.InsertItem(index: Integer; value: TFhirSupplyDelivery);
begin
  assert(value is TFhirSupplyDelivery);
  Inherited Insert(index, value);
end;

function TFhirSupplyDeliveryList.Item(index: Integer): TFhirSupplyDelivery;
begin
  result := TFhirSupplyDelivery(ObjectByIndex[index]);
end;

function TFhirSupplyDeliveryList.Link: TFhirSupplyDeliveryList;
begin
  result := TFhirSupplyDeliveryList(inherited Link);
end;

procedure TFhirSupplyDeliveryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSupplyDeliveryList.SetItemByIndex(index: Integer; value: TFhirSupplyDelivery);
begin
  assert(value is TFhirSupplyDelivery);
  FhirSupplyDeliveries[index] := value;
end;

procedure TFhirSupplyDeliveryList.SetItemN(index: Integer; value: TFhirSupplyDelivery);
begin
  assert(value is TFhirSupplyDelivery);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SUPPLYDELIVERY}

{$IFDEF FHIR_SUPPLYREQUEST}

{ TFhirSupplyRequestWhen }

constructor TFhirSupplyRequestWhen.Create;
begin
  inherited;
end;

destructor TFhirSupplyRequestWhen.Destroy;
begin
  FCode.free;
  FSchedule.free;
  inherited;
end;

procedure TFhirSupplyRequestWhen.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirSupplyRequestWhen(oSource).code.Clone;
  schedule := TFhirSupplyRequestWhen(oSource).schedule.Clone;
end;

procedure TFhirSupplyRequestWhen.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'schedule') Then
     list.add(self.link, 'schedule', FSchedule.Link);
end;

procedure TFhirSupplyRequestWhen.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'schedule', 'Timing', false, TFhirTiming, FSchedule.Link));{2}
end;

function TFhirSupplyRequestWhen.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'schedule') then
  begin
    Schedule := propValue as TFhirTiming{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSupplyRequestWhen.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSupplyRequestWhen.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'schedule') then result := TFhirTiming.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSupplyRequestWhen.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'schedule') then result := 'Timing'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSupplyRequestWhen.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'schedule') then ScheduleElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSupplyRequestWhen.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'schedule') then ScheduleElement := new as TFhirTiming{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSupplyRequestWhen.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSupplyRequestWhen.fhirType : string;
begin
  result := 'when';
end;

function TFhirSupplyRequestWhen.Link : TFhirSupplyRequestWhen;
begin
  result := TFhirSupplyRequestWhen(inherited Link);
end;

function TFhirSupplyRequestWhen.Clone : TFhirSupplyRequestWhen;
begin
  result := TFhirSupplyRequestWhen(inherited Clone);
end;

function TFhirSupplyRequestWhen.equals(other : TObject) : boolean;
var
  o : TFhirSupplyRequestWhen;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSupplyRequestWhen)) then
    result := false
  else
  begin
    o := TFhirSupplyRequestWhen(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(scheduleElement, o.scheduleElement, true);
  end;
end;

function TFhirSupplyRequestWhen.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FSchedule);
end;

procedure TFhirSupplyRequestWhen.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('schedule');
end;

{ TFhirSupplyRequestWhen }

Procedure TFhirSupplyRequestWhen.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirSupplyRequestWhen.SetSchedule(value : TFhirTiming);
begin
  FSchedule.free;
  FSchedule := value;
end;

function TFhirSupplyRequestWhen.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FSchedule.sizeInBytes);
end;

{ TFhirSupplyRequestWhenListEnumerator }

Constructor TFhirSupplyRequestWhenListEnumerator.Create(list : TFhirSupplyRequestWhenList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSupplyRequestWhenListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSupplyRequestWhenListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSupplyRequestWhenListEnumerator.GetCurrent : TFhirSupplyRequestWhen;
begin
  Result := FList[FIndex];
end;

function TFhirSupplyRequestWhenListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSupplyRequestWhenList }
procedure TFhirSupplyRequestWhenList.AddItem(value: TFhirSupplyRequestWhen);
begin
  assert(value.ClassName = 'TFhirSupplyRequestWhen', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSupplyRequestWhen');
  add(value);
end;

function TFhirSupplyRequestWhenList.Append: TFhirSupplyRequestWhen;
begin
  result := TFhirSupplyRequestWhen.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSupplyRequestWhenList.ClearItems;
begin
  Clear;
end;

function TFhirSupplyRequestWhenList.GetEnumerator : TFhirSupplyRequestWhenListEnumerator;
begin
  result := TFhirSupplyRequestWhenListEnumerator.Create(self.link);
end;

function TFhirSupplyRequestWhenList.Clone: TFhirSupplyRequestWhenList;
begin
  result := TFhirSupplyRequestWhenList(inherited Clone);
end;

function TFhirSupplyRequestWhenList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSupplyRequestWhenList.GetItemN(index: Integer): TFhirSupplyRequestWhen;
begin
  result := TFhirSupplyRequestWhen(ObjectByIndex[index]);
end;

function TFhirSupplyRequestWhenList.ItemClass: TFslObjectClass;
begin
  result := TFhirSupplyRequestWhen;
end;
function TFhirSupplyRequestWhenList.IndexOf(value: TFhirSupplyRequestWhen): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSupplyRequestWhenList.Insert(index: Integer): TFhirSupplyRequestWhen;
begin
  result := TFhirSupplyRequestWhen.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSupplyRequestWhenList.InsertItem(index: Integer; value: TFhirSupplyRequestWhen);
begin
  assert(value is TFhirSupplyRequestWhen);
  Inherited Insert(index, value);
end;

function TFhirSupplyRequestWhenList.Item(index: Integer): TFhirSupplyRequestWhen;
begin
  result := TFhirSupplyRequestWhen(ObjectByIndex[index]);
end;

function TFhirSupplyRequestWhenList.Link: TFhirSupplyRequestWhenList;
begin
  result := TFhirSupplyRequestWhenList(inherited Link);
end;

procedure TFhirSupplyRequestWhenList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSupplyRequestWhenList.SetItemByIndex(index: Integer; value: TFhirSupplyRequestWhen);
begin
  assert(value is TFhirSupplyRequestWhen);
  FhirSupplyRequestWhens[index] := value;
end;

procedure TFhirSupplyRequestWhenList.SetItemN(index: Integer; value: TFhirSupplyRequestWhen);
begin
  assert(value is TFhirSupplyRequestWhen);
  ObjectByIndex[index] := value;
end;

{ TFhirSupplyRequest }

constructor TFhirSupplyRequest.Create;
begin
  inherited;
end;

destructor TFhirSupplyRequest.Destroy;
begin
  FPatient.free;
  FSource.free;
  FDate.free;
  FIdentifier.free;
  FStatus.free;
  FKind.free;
  FOrderedItem.free;
  FSupplierList.Free;
  FReason.free;
  FWhen.free;
  inherited;
end;

function TFhirSupplyRequest.GetResourceType : TFhirResourceType;
begin
  result := frtSupplyRequest;
end;

procedure TFhirSupplyRequest.Assign(oSource : TFslObject);
begin
  inherited;
  patient := TFhirSupplyRequest(oSource).patient.Clone;
  source := TFhirSupplyRequest(oSource).source.Clone;
  dateElement := TFhirSupplyRequest(oSource).dateElement.Clone;
  identifier := TFhirSupplyRequest(oSource).identifier.Clone;
  FStatus := TFhirSupplyRequest(oSource).FStatus.Link;
  kind := TFhirSupplyRequest(oSource).kind.Clone;
  orderedItem := TFhirSupplyRequest(oSource).orderedItem.Clone;
  if (TFhirSupplyRequest(oSource).FSupplierList = nil) then
  begin
    FSupplierList.free;
    FSupplierList := nil;
  end
  else
  begin
    if FSupplierList = nil then
      FSupplierList := TFhirReferenceList{TFhirOrganization}.Create;
    FSupplierList.Assign(TFhirSupplyRequest(oSource).FSupplierList);
  end;
  reason := TFhirSupplyRequest(oSource).reason.Clone;
  when := TFhirSupplyRequest(oSource).when.Clone;
end;

procedure TFhirSupplyRequest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'kind') Then
     list.add(self.link, 'kind', FKind.Link);
  if (child_name = 'orderedItem') Then
     list.add(self.link, 'orderedItem', FOrderedItem.Link);
  if (child_name = 'supplier') Then
    list.addAll(self, 'supplier', FSupplierList);
  if (child_name = 'reason[x]') or (child_name = 'reason') Then
     list.add(self.link, 'reason[x]', FReason.Link);
  if (child_name = 'when') Then
     list.add(self.link, 'when', FWhen.Link);
end;

procedure TFhirSupplyRequest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'source', 'Reference(Practitioner|Organization|Patient)', false, TFhirReference{Resource}, FSource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'kind', 'CodeableConcept', false, TFhirCodeableConcept, FKind.Link));{2}
  oList.add(TFHIRProperty.create(self, 'orderedItem', 'Reference(Medication|Substance|Device)', false, TFhirReference{Resource}, FOrderedItem.Link));{2}
  oList.add(TFHIRProperty.create(self, 'supplier', 'Reference(Organization)', true, TFhirReference{TFhirOrganization}, FSupplierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reason[x]', 'CodeableConcept|Reference(Any)', false, TFhirType, FReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'when', '', false, TFhirSupplyRequestWhen, FWhen.Link));{2}
end;

function TFhirSupplyRequest.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    Source := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirSupplyrequestStatusEnum, CODES_TFhirSupplyrequestStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'kind') then
  begin
    Kind := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'orderedItem') then
  begin
    OrderedItem := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'supplier') then
  begin
    SupplierList.add(propValue as TFhirReference{TFhirOrganization}){2a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then
  begin
    Reason := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'when') then
  begin
    When := propValue as TFhirSupplyRequestWhen{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirSupplyRequest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'supplier') then SupplierList.insertItem(index, propValue as TFhirReference{TFhirOrganization}){2a}
  else inherited;
end;

function TFhirSupplyRequest.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'source') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'kind') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'orderedItem') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'supplier') then result := SupplierList.new(){2}
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Reason'){4x}
  else if (propName = 'when') then result := TFhirSupplyRequestWhen.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSupplyRequest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'patient') then result := 'Reference'
  else if (propName = 'source') then result := 'Reference'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'kind') then result := 'CodeableConcept'
  else if (propName = 'orderedItem') then result := 'Reference'
  else if (propName = 'supplier') then result := 'Reference'
  else if (propName = 'reason[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'when') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSupplyRequest.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'patient') then PatientElement := nil
  else if (propName = 'source') then SourceElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'kind') then KindElement := nil
  else if (propName = 'orderedItem') then OrderedItemElement := nil
  else if (propName = 'supplier') then deletePropertyValue('supplier', SupplierList, value) {2}
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then ReasonElement := nil{4x}
  else if (propName = 'when') then WhenElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSupplyRequest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'source') then SourceElement := new as TFhirReference{Resource}{4}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirSupplyrequestStatusEnum, CODES_TFhirSupplyrequestStatusEnum, new){4}
  else if (propName = 'kind') then KindElement := new as TFhirCodeableConcept{4}
  else if (propName = 'orderedItem') then OrderedItemElement := new as TFhirReference{Resource}{4}
  else if (propName = 'supplier') then replacePropertyValue('supplier', SupplierList, existing, new) {2}
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then ReasonElement := new as TFhirType{4x}
  else if (propName = 'when') then WhenElement := new as TFhirSupplyRequestWhen{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSupplyRequest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'supplier') then SupplierList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSupplyRequest.fhirType : string;
begin
  result := 'SupplyRequest';
end;

function TFhirSupplyRequest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPatient) and isEmptyProp(FSource) and isEmptyProp(FDate) and isEmptyProp(FIdentifier) and isEmptyProp(FStatus) and isEmptyProp(FKind) and isEmptyProp(FOrderedItem) and isEmptyProp(FsupplierList) and isEmptyProp(FReason) and isEmptyProp(FWhen);
end;

function TFhirSupplyRequest.equals(other : TObject) : boolean;
var
  o : TFhirSupplyRequest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSupplyRequest)) then
    result := false
  else
  begin
    o := TFhirSupplyRequest(other);
    result := compareDeep(patientElement, o.patientElement, true) and compareDeep(sourceElement, o.sourceElement, true) and
      compareDeep(dateElement, o.dateElement, true) and compareDeep(identifierElement, o.identifierElement, true) and
      compareDeep(statusElement, o.statusElement, true) and compareDeep(kindElement, o.kindElement, true) and
      compareDeep(orderedItemElement, o.orderedItemElement, true) and compareDeep(supplierList, o.supplierList, true) and
      compareDeep(reasonElement, o.reasonElement, true) and compareDeep(whenElement, o.whenElement, true);
  end;
end;

function TFhirSupplyRequest.Link : TFhirSupplyRequest;
begin
  result := TFhirSupplyRequest(inherited Link);
end;

function TFhirSupplyRequest.Clone : TFhirSupplyRequest;
begin
  result := TFhirSupplyRequest(inherited Clone);
end;

procedure TFhirSupplyRequest.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('patient');
  fields.add('source');
  fields.add('date');
  fields.add('identifier');
  fields.add('status');
  fields.add('kind');
  fields.add('orderedItem');
  fields.add('supplier');
  fields.add('reason[x]');
  fields.add('when');
end;

{ TFhirSupplyRequest }

Procedure TFhirSupplyRequest.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Procedure TFhirSupplyRequest.SetSource(value : TFhirReference{Resource});
begin
  FSource.free;
  FSource := value;
end;

Procedure TFhirSupplyRequest.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirSupplyRequest.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirSupplyRequest.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirSupplyRequest.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirSupplyRequest.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirSupplyRequest.GetStatusST : TFhirSupplyrequestStatusEnum;
begin
  if FStatus = nil then
    result := TFhirSupplyrequestStatusEnum(0)
  else
    result := TFhirSupplyrequestStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirSupplyrequestStatusEnum, FStatus.value));
end;

Procedure TFhirSupplyRequest.SetStatusST(value : TFhirSupplyrequestStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirSupplyrequestStatusEnum[value], CODES_TFhirSupplyrequestStatusEnum[value]);
end;

Procedure TFhirSupplyRequest.SetKind(value : TFhirCodeableConcept);
begin
  FKind.free;
  FKind := value;
end;

Procedure TFhirSupplyRequest.SetOrderedItem(value : TFhirReference{Resource});
begin
  FOrderedItem.free;
  FOrderedItem := value;
end;

Function TFhirSupplyRequest.GetSupplierList : TFhirReferenceList{TFhirOrganization};
begin
  if FSupplierList = nil then
    FSupplierList := TFhirReferenceList{TFhirOrganization}.Create;
  result := FSupplierList;
end;

Function TFhirSupplyRequest.GetHasSupplierList : boolean;
begin
  result := (FSupplierList <> nil) and (FSupplierList.count > 0);
end;

Procedure TFhirSupplyRequest.SetReason(value : TFhirType);
begin
  FReason.free;
  FReason := value;
end;

Procedure TFhirSupplyRequest.SetWhen(value : TFhirSupplyRequestWhen);
begin
  FWhen.free;
  FWhen := value;
end;

function TFhirSupplyRequest.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FPatient.sizeInBytes);
  inc(result, FSource.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FKind.sizeInBytes);
  inc(result, FOrderedItem.sizeInBytes);
  inc(result, FsupplierList.sizeInBytes);
  inc(result, FReason.sizeInBytes);
  inc(result, FWhen.sizeInBytes);
end;

{ TFhirSupplyRequestListEnumerator }

Constructor TFhirSupplyRequestListEnumerator.Create(list : TFhirSupplyRequestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSupplyRequestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSupplyRequestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSupplyRequestListEnumerator.GetCurrent : TFhirSupplyRequest;
begin
  Result := FList[FIndex];
end;

function TFhirSupplyRequestListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSupplyRequestList }
procedure TFhirSupplyRequestList.AddItem(value: TFhirSupplyRequest);
begin
  assert(value.ClassName = 'TFhirSupplyRequest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSupplyRequest');
  add(value);
end;

function TFhirSupplyRequestList.Append: TFhirSupplyRequest;
begin
  result := TFhirSupplyRequest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSupplyRequestList.ClearItems;
begin
  Clear;
end;

function TFhirSupplyRequestList.GetEnumerator : TFhirSupplyRequestListEnumerator;
begin
  result := TFhirSupplyRequestListEnumerator.Create(self.link);
end;

function TFhirSupplyRequestList.Clone: TFhirSupplyRequestList;
begin
  result := TFhirSupplyRequestList(inherited Clone);
end;

function TFhirSupplyRequestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSupplyRequestList.GetItemN(index: Integer): TFhirSupplyRequest;
begin
  result := TFhirSupplyRequest(ObjectByIndex[index]);
end;

function TFhirSupplyRequestList.ItemClass: TFslObjectClass;
begin
  result := TFhirSupplyRequest;
end;
function TFhirSupplyRequestList.IndexOf(value: TFhirSupplyRequest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSupplyRequestList.Insert(index: Integer): TFhirSupplyRequest;
begin
  result := TFhirSupplyRequest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSupplyRequestList.InsertItem(index: Integer; value: TFhirSupplyRequest);
begin
  assert(value is TFhirSupplyRequest);
  Inherited Insert(index, value);
end;

function TFhirSupplyRequestList.Item(index: Integer): TFhirSupplyRequest;
begin
  result := TFhirSupplyRequest(ObjectByIndex[index]);
end;

function TFhirSupplyRequestList.Link: TFhirSupplyRequestList;
begin
  result := TFhirSupplyRequestList(inherited Link);
end;

procedure TFhirSupplyRequestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSupplyRequestList.SetItemByIndex(index: Integer; value: TFhirSupplyRequest);
begin
  assert(value is TFhirSupplyRequest);
  FhirSupplyRequests[index] := value;
end;

procedure TFhirSupplyRequestList.SetItemN(index: Integer; value: TFhirSupplyRequest);
begin
  assert(value is TFhirSupplyRequest);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SUPPLYREQUEST}

{$IFDEF FHIR_VISIONPRESCRIPTION}

{ TFhirVisionPrescriptionDispense }

constructor TFhirVisionPrescriptionDispense.Create;
begin
  inherited;
end;

destructor TFhirVisionPrescriptionDispense.Destroy;
begin
  FProduct.free;
  FEye.free;
  FSphere.free;
  FCylinder.free;
  FAxis.free;
  FPrism.free;
  FBase.free;
  FAdd.free;
  FPower.free;
  FBackCurve.free;
  FDiameter.free;
  FDuration.free;
  FColor.free;
  FBrand.free;
  FNotes.free;
  inherited;
end;

procedure TFhirVisionPrescriptionDispense.Assign(oSource : TFslObject);
begin
  inherited;
  product := TFhirVisionPrescriptionDispense(oSource).product.Clone;
  FEye := TFhirVisionPrescriptionDispense(oSource).FEye.Link;
  sphereElement := TFhirVisionPrescriptionDispense(oSource).sphereElement.Clone;
  cylinderElement := TFhirVisionPrescriptionDispense(oSource).cylinderElement.Clone;
  axisElement := TFhirVisionPrescriptionDispense(oSource).axisElement.Clone;
  prismElement := TFhirVisionPrescriptionDispense(oSource).prismElement.Clone;
  FBase := TFhirVisionPrescriptionDispense(oSource).FBase.Link;
  addElement := TFhirVisionPrescriptionDispense(oSource).addElement.Clone;
  powerElement := TFhirVisionPrescriptionDispense(oSource).powerElement.Clone;
  backCurveElement := TFhirVisionPrescriptionDispense(oSource).backCurveElement.Clone;
  diameterElement := TFhirVisionPrescriptionDispense(oSource).diameterElement.Clone;
  duration := TFhirVisionPrescriptionDispense(oSource).duration.Clone;
  colorElement := TFhirVisionPrescriptionDispense(oSource).colorElement.Clone;
  brandElement := TFhirVisionPrescriptionDispense(oSource).brandElement.Clone;
  notesElement := TFhirVisionPrescriptionDispense(oSource).notesElement.Clone;
end;

procedure TFhirVisionPrescriptionDispense.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'product') Then
     list.add(self.link, 'product', FProduct.Link);
  if (child_name = 'eye') Then
     list.add(self.link, 'eye', FEye.Link);
  if (child_name = 'sphere') Then
     list.add(self.link, 'sphere', FSphere.Link);
  if (child_name = 'cylinder') Then
     list.add(self.link, 'cylinder', FCylinder.Link);
  if (child_name = 'axis') Then
     list.add(self.link, 'axis', FAxis.Link);
  if (child_name = 'prism') Then
     list.add(self.link, 'prism', FPrism.Link);
  if (child_name = 'base') Then
     list.add(self.link, 'base', FBase.Link);
  if (child_name = 'add') Then
     list.add(self.link, 'add', FAdd.Link);
  if (child_name = 'power') Then
     list.add(self.link, 'power', FPower.Link);
  if (child_name = 'backCurve') Then
     list.add(self.link, 'backCurve', FBackCurve.Link);
  if (child_name = 'diameter') Then
     list.add(self.link, 'diameter', FDiameter.Link);
  if (child_name = 'duration') Then
     list.add(self.link, 'duration', FDuration.Link);
  if (child_name = 'color') Then
     list.add(self.link, 'color', FColor.Link);
  if (child_name = 'brand') Then
     list.add(self.link, 'brand', FBrand.Link);
  if (child_name = 'notes') Then
     list.add(self.link, 'notes', FNotes.Link);
end;

procedure TFhirVisionPrescriptionDispense.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'product', 'Coding', false, TFhirCoding, FProduct.Link));{2}
  oList.add(TFHIRProperty.create(self, 'eye', 'code', false, TFHIREnum, FEye.Link));{1}
  oList.add(TFHIRProperty.create(self, 'sphere', 'decimal', false, TFhirDecimal, FSphere.Link));{2}
  oList.add(TFHIRProperty.create(self, 'cylinder', 'decimal', false, TFhirDecimal, FCylinder.Link));{2}
  oList.add(TFHIRProperty.create(self, 'axis', 'integer', false, TFhirInteger, FAxis.Link));{2}
  oList.add(TFHIRProperty.create(self, 'prism', 'decimal', false, TFhirDecimal, FPrism.Link));{2}
  oList.add(TFHIRProperty.create(self, 'base', 'code', false, TFHIREnum, FBase.Link));{1}
  oList.add(TFHIRProperty.create(self, 'add', 'decimal', false, TFhirDecimal, FAdd.Link));{2}
  oList.add(TFHIRProperty.create(self, 'power', 'decimal', false, TFhirDecimal, FPower.Link));{2}
  oList.add(TFHIRProperty.create(self, 'backCurve', 'decimal', false, TFhirDecimal, FBackCurve.Link));{2}
  oList.add(TFHIRProperty.create(self, 'diameter', 'decimal', false, TFhirDecimal, FDiameter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'duration', 'Quantity', false, TFhirQuantity, FDuration.Link));{2}
  oList.add(TFHIRProperty.create(self, 'color', 'string', false, TFhirString, FColor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'brand', 'string', false, TFhirString, FBrand.Link));{2}
  oList.add(TFHIRProperty.create(self, 'notes', 'string', false, TFhirString, FNotes.Link));{2}
end;

function TFhirVisionPrescriptionDispense.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'product') then
  begin
    Product := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'eye') then
  begin
    EyeElement := asEnum(SYSTEMS_TFhirVisionEyeCodesEnum, CODES_TFhirVisionEyeCodesEnum, propValue);
    result := propValue
  end
  else if (propName = 'sphere') then
  begin
    SphereElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'cylinder') then
  begin
    CylinderElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'axis') then
  begin
    AxisElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'prism') then
  begin
    PrismElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'base') then
  begin
    BaseElement := asEnum(SYSTEMS_TFhirVisionBaseCodesEnum, CODES_TFhirVisionBaseCodesEnum, propValue);
    result := propValue
  end
  else if (propName = 'add') then
  begin
    AddElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'power') then
  begin
    PowerElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'backCurve') then
  begin
    BackCurveElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'diameter') then
  begin
    DiameterElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'duration') then
  begin
    Duration := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'color') then
  begin
    ColorElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'brand') then
  begin
    BrandElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'notes') then
  begin
    NotesElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirVisionPrescriptionDispense.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirVisionPrescriptionDispense.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'product') then result := TFhirCoding.create(){4b}
  else if (propName = 'sphere') then result := TFhirDecimal.create() {5b}
  else if (propName = 'cylinder') then result := TFhirDecimal.create() {5b}
  else if (propName = 'axis') then result := TFhirInteger.create() {5b}
  else if (propName = 'prism') then result := TFhirDecimal.create() {5b}
  else if (propName = 'add') then result := TFhirDecimal.create() {5b}
  else if (propName = 'power') then result := TFhirDecimal.create() {5b}
  else if (propName = 'backCurve') then result := TFhirDecimal.create() {5b}
  else if (propName = 'diameter') then result := TFhirDecimal.create() {5b}
  else if (propName = 'duration') then result := TFhirQuantity.create(){4b}
  else if (propName = 'color') then result := TFhirString.create() {5b}
  else if (propName = 'brand') then result := TFhirString.create() {5b}
  else if (propName = 'notes') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirVisionPrescriptionDispense.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'product') then result := 'Coding'
  else if (propName = 'eye') then result := 'code'
  else if (propName = 'sphere') then result := 'decimal'
  else if (propName = 'cylinder') then result := 'decimal'
  else if (propName = 'axis') then result := 'integer'
  else if (propName = 'prism') then result := 'decimal'
  else if (propName = 'base') then result := 'code'
  else if (propName = 'add') then result := 'decimal'
  else if (propName = 'power') then result := 'decimal'
  else if (propName = 'backCurve') then result := 'decimal'
  else if (propName = 'diameter') then result := 'decimal'
  else if (propName = 'duration') then result := 'Quantity'
  else if (propName = 'color') then result := 'string'
  else if (propName = 'brand') then result := 'string'
  else if (propName = 'notes') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirVisionPrescriptionDispense.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'product') then ProductElement := nil
  else if (propName = 'eye') then EyeElement := nil
  else if (propName = 'sphere') then SphereElement := nil
  else if (propName = 'cylinder') then CylinderElement := nil
  else if (propName = 'axis') then AxisElement := nil
  else if (propName = 'prism') then PrismElement := nil
  else if (propName = 'base') then BaseElement := nil
  else if (propName = 'add') then AddElement := nil
  else if (propName = 'power') then PowerElement := nil
  else if (propName = 'backCurve') then BackCurveElement := nil
  else if (propName = 'diameter') then DiameterElement := nil
  else if (propName = 'duration') then DurationElement := nil
  else if (propName = 'color') then ColorElement := nil
  else if (propName = 'brand') then BrandElement := nil
  else if (propName = 'notes') then NotesElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirVisionPrescriptionDispense.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'product') then ProductElement := new as TFhirCoding{4}
  else if (propName = 'eye') then EyeElement := asEnum(SYSTEMS_TFhirVisionEyeCodesEnum, CODES_TFhirVisionEyeCodesEnum, new){4}
  else if (propName = 'sphere') then SphereElement := asDecimal(new){5b}
  else if (propName = 'cylinder') then CylinderElement := asDecimal(new){5b}
  else if (propName = 'axis') then AxisElement := asInteger(new){5b}
  else if (propName = 'prism') then PrismElement := asDecimal(new){5b}
  else if (propName = 'base') then BaseElement := asEnum(SYSTEMS_TFhirVisionBaseCodesEnum, CODES_TFhirVisionBaseCodesEnum, new){4}
  else if (propName = 'add') then AddElement := asDecimal(new){5b}
  else if (propName = 'power') then PowerElement := asDecimal(new){5b}
  else if (propName = 'backCurve') then BackCurveElement := asDecimal(new){5b}
  else if (propName = 'diameter') then DiameterElement := asDecimal(new){5b}
  else if (propName = 'duration') then DurationElement := new as TFhirQuantity{4}
  else if (propName = 'color') then ColorElement := asString(new){5b}
  else if (propName = 'brand') then BrandElement := asString(new){5b}
  else if (propName = 'notes') then NotesElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirVisionPrescriptionDispense.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirVisionPrescriptionDispense.fhirType : string;
begin
  result := 'dispense';
end;

function TFhirVisionPrescriptionDispense.Link : TFhirVisionPrescriptionDispense;
begin
  result := TFhirVisionPrescriptionDispense(inherited Link);
end;

function TFhirVisionPrescriptionDispense.Clone : TFhirVisionPrescriptionDispense;
begin
  result := TFhirVisionPrescriptionDispense(inherited Clone);
end;

function TFhirVisionPrescriptionDispense.equals(other : TObject) : boolean;
var
  o : TFhirVisionPrescriptionDispense;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirVisionPrescriptionDispense)) then
    result := false
  else
  begin
    o := TFhirVisionPrescriptionDispense(other);
    result := compareDeep(productElement, o.productElement, true) and compareDeep(eyeElement, o.eyeElement, true) and
      compareDeep(sphereElement, o.sphereElement, true) and compareDeep(cylinderElement, o.cylinderElement, true) and
      compareDeep(axisElement, o.axisElement, true) and compareDeep(prismElement, o.prismElement, true) and
      compareDeep(baseElement, o.baseElement, true) and compareDeep(addElement, o.addElement, true) and
      compareDeep(powerElement, o.powerElement, true) and compareDeep(backCurveElement, o.backCurveElement, true) and
      compareDeep(diameterElement, o.diameterElement, true) and compareDeep(durationElement, o.durationElement, true) and
      compareDeep(colorElement, o.colorElement, true) and compareDeep(brandElement, o.brandElement, true) and
      compareDeep(notesElement, o.notesElement, true);
  end;
end;

function TFhirVisionPrescriptionDispense.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FProduct) and isEmptyProp(FEye) and isEmptyProp(FSphere) and isEmptyProp(FCylinder) and isEmptyProp(FAxis) and isEmptyProp(FPrism) and isEmptyProp(FBase) and isEmptyProp(FAdd) and isEmptyProp(FPower) and isEmptyProp(FBackCurve) and isEmptyProp(FDiameter) and isEmptyProp(FDuration) and isEmptyProp(FColor) and isEmptyProp(FBrand) and isEmptyProp(FNotes);
end;

procedure TFhirVisionPrescriptionDispense.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('product');
  fields.add('eye');
  fields.add('sphere');
  fields.add('cylinder');
  fields.add('axis');
  fields.add('prism');
  fields.add('base');
  fields.add('add');
  fields.add('power');
  fields.add('backCurve');
  fields.add('diameter');
  fields.add('duration');
  fields.add('color');
  fields.add('brand');
  fields.add('notes');
end;

{ TFhirVisionPrescriptionDispense }

Procedure TFhirVisionPrescriptionDispense.SetProduct(value : TFhirCoding);
begin
  FProduct.free;
  FProduct := value;
end;

Procedure TFhirVisionPrescriptionDispense.SetEye(value : TFhirEnum);
begin
  FEye.free;
  FEye := value;
end;

Function TFhirVisionPrescriptionDispense.GetEyeST : TFhirVisionEyeCodesEnum;
begin
  if FEye = nil then
    result := TFhirVisionEyeCodesEnum(0)
  else
    result := TFhirVisionEyeCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirVisionEyeCodesEnum, FEye.value));
end;

Procedure TFhirVisionPrescriptionDispense.SetEyeST(value : TFhirVisionEyeCodesEnum);
begin
  if ord(value) = 0 then
    EyeElement := nil
  else
    EyeElement := TFhirEnum.create(SYSTEMS_TFhirVisionEyeCodesEnum[value], CODES_TFhirVisionEyeCodesEnum[value]);
end;

Procedure TFhirVisionPrescriptionDispense.SetSphere(value : TFhirDecimal);
begin
  FSphere.free;
  FSphere := value;
end;

Function TFhirVisionPrescriptionDispense.GetSphereST : String;
begin
  if FSphere = nil then
    result := ''
  else
    result := FSphere.value;
end;

Procedure TFhirVisionPrescriptionDispense.SetSphereST(value : String);
begin
  if value <> '' then
  begin
    if FSphere = nil then
      FSphere := TFhirDecimal.create;
    FSphere.value := value
  end
  else if FSphere <> nil then
    FSphere.value := '';
end;

Procedure TFhirVisionPrescriptionDispense.SetCylinder(value : TFhirDecimal);
begin
  FCylinder.free;
  FCylinder := value;
end;

Function TFhirVisionPrescriptionDispense.GetCylinderST : String;
begin
  if FCylinder = nil then
    result := ''
  else
    result := FCylinder.value;
end;

Procedure TFhirVisionPrescriptionDispense.SetCylinderST(value : String);
begin
  if value <> '' then
  begin
    if FCylinder = nil then
      FCylinder := TFhirDecimal.create;
    FCylinder.value := value
  end
  else if FCylinder <> nil then
    FCylinder.value := '';
end;

Procedure TFhirVisionPrescriptionDispense.SetAxis(value : TFhirInteger);
begin
  FAxis.free;
  FAxis := value;
end;

Function TFhirVisionPrescriptionDispense.GetAxisST : String;
begin
  if FAxis = nil then
    result := ''
  else
    result := FAxis.value;
end;

Procedure TFhirVisionPrescriptionDispense.SetAxisST(value : String);
begin
  if value <> '' then
  begin
    if FAxis = nil then
      FAxis := TFhirInteger.create;
    FAxis.value := value
  end
  else if FAxis <> nil then
    FAxis.value := '';
end;

Procedure TFhirVisionPrescriptionDispense.SetPrism(value : TFhirDecimal);
begin
  FPrism.free;
  FPrism := value;
end;

Function TFhirVisionPrescriptionDispense.GetPrismST : String;
begin
  if FPrism = nil then
    result := ''
  else
    result := FPrism.value;
end;

Procedure TFhirVisionPrescriptionDispense.SetPrismST(value : String);
begin
  if value <> '' then
  begin
    if FPrism = nil then
      FPrism := TFhirDecimal.create;
    FPrism.value := value
  end
  else if FPrism <> nil then
    FPrism.value := '';
end;

Procedure TFhirVisionPrescriptionDispense.SetBase(value : TFhirEnum);
begin
  FBase.free;
  FBase := value;
end;

Function TFhirVisionPrescriptionDispense.GetBaseST : TFhirVisionBaseCodesEnum;
begin
  if FBase = nil then
    result := TFhirVisionBaseCodesEnum(0)
  else
    result := TFhirVisionBaseCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirVisionBaseCodesEnum, FBase.value));
end;

Procedure TFhirVisionPrescriptionDispense.SetBaseST(value : TFhirVisionBaseCodesEnum);
begin
  if ord(value) = 0 then
    BaseElement := nil
  else
    BaseElement := TFhirEnum.create(SYSTEMS_TFhirVisionBaseCodesEnum[value], CODES_TFhirVisionBaseCodesEnum[value]);
end;

Procedure TFhirVisionPrescriptionDispense.SetAdd(value : TFhirDecimal);
begin
  FAdd.free;
  FAdd := value;
end;

Function TFhirVisionPrescriptionDispense.GetAddST : String;
begin
  if FAdd = nil then
    result := ''
  else
    result := FAdd.value;
end;

Procedure TFhirVisionPrescriptionDispense.SetAddST(value : String);
begin
  if value <> '' then
  begin
    if FAdd = nil then
      FAdd := TFhirDecimal.create;
    FAdd.value := value
  end
  else if FAdd <> nil then
    FAdd.value := '';
end;

Procedure TFhirVisionPrescriptionDispense.SetPower(value : TFhirDecimal);
begin
  FPower.free;
  FPower := value;
end;

Function TFhirVisionPrescriptionDispense.GetPowerST : String;
begin
  if FPower = nil then
    result := ''
  else
    result := FPower.value;
end;

Procedure TFhirVisionPrescriptionDispense.SetPowerST(value : String);
begin
  if value <> '' then
  begin
    if FPower = nil then
      FPower := TFhirDecimal.create;
    FPower.value := value
  end
  else if FPower <> nil then
    FPower.value := '';
end;

Procedure TFhirVisionPrescriptionDispense.SetBackCurve(value : TFhirDecimal);
begin
  FBackCurve.free;
  FBackCurve := value;
end;

Function TFhirVisionPrescriptionDispense.GetBackCurveST : String;
begin
  if FBackCurve = nil then
    result := ''
  else
    result := FBackCurve.value;
end;

Procedure TFhirVisionPrescriptionDispense.SetBackCurveST(value : String);
begin
  if value <> '' then
  begin
    if FBackCurve = nil then
      FBackCurve := TFhirDecimal.create;
    FBackCurve.value := value
  end
  else if FBackCurve <> nil then
    FBackCurve.value := '';
end;

Procedure TFhirVisionPrescriptionDispense.SetDiameter(value : TFhirDecimal);
begin
  FDiameter.free;
  FDiameter := value;
end;

Function TFhirVisionPrescriptionDispense.GetDiameterST : String;
begin
  if FDiameter = nil then
    result := ''
  else
    result := FDiameter.value;
end;

Procedure TFhirVisionPrescriptionDispense.SetDiameterST(value : String);
begin
  if value <> '' then
  begin
    if FDiameter = nil then
      FDiameter := TFhirDecimal.create;
    FDiameter.value := value
  end
  else if FDiameter <> nil then
    FDiameter.value := '';
end;

Procedure TFhirVisionPrescriptionDispense.SetDuration(value : TFhirQuantity);
begin
  FDuration.free;
  FDuration := value;
end;

Procedure TFhirVisionPrescriptionDispense.SetColor(value : TFhirString);
begin
  FColor.free;
  FColor := value;
end;

Function TFhirVisionPrescriptionDispense.GetColorST : String;
begin
  if FColor = nil then
    result := ''
  else
    result := FColor.value;
end;

Procedure TFhirVisionPrescriptionDispense.SetColorST(value : String);
begin
  if value <> '' then
  begin
    if FColor = nil then
      FColor := TFhirString.create;
    FColor.value := value
  end
  else if FColor <> nil then
    FColor.value := '';
end;

Procedure TFhirVisionPrescriptionDispense.SetBrand(value : TFhirString);
begin
  FBrand.free;
  FBrand := value;
end;

Function TFhirVisionPrescriptionDispense.GetBrandST : String;
begin
  if FBrand = nil then
    result := ''
  else
    result := FBrand.value;
end;

Procedure TFhirVisionPrescriptionDispense.SetBrandST(value : String);
begin
  if value <> '' then
  begin
    if FBrand = nil then
      FBrand := TFhirString.create;
    FBrand.value := value
  end
  else if FBrand <> nil then
    FBrand.value := '';
end;

Procedure TFhirVisionPrescriptionDispense.SetNotes(value : TFhirString);
begin
  FNotes.free;
  FNotes := value;
end;

Function TFhirVisionPrescriptionDispense.GetNotesST : String;
begin
  if FNotes = nil then
    result := ''
  else
    result := FNotes.value;
end;

Procedure TFhirVisionPrescriptionDispense.SetNotesST(value : String);
begin
  if value <> '' then
  begin
    if FNotes = nil then
      FNotes := TFhirString.create;
    FNotes.value := value
  end
  else if FNotes <> nil then
    FNotes.value := '';
end;

function TFhirVisionPrescriptionDispense.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FProduct.sizeInBytes);
  inc(result, FEye.sizeInBytes);
  inc(result, FSphere.sizeInBytes);
  inc(result, FCylinder.sizeInBytes);
  inc(result, FAxis.sizeInBytes);
  inc(result, FPrism.sizeInBytes);
  inc(result, FBase.sizeInBytes);
  inc(result, FAdd.sizeInBytes);
  inc(result, FPower.sizeInBytes);
  inc(result, FBackCurve.sizeInBytes);
  inc(result, FDiameter.sizeInBytes);
  inc(result, FDuration.sizeInBytes);
  inc(result, FColor.sizeInBytes);
  inc(result, FBrand.sizeInBytes);
  inc(result, FNotes.sizeInBytes);
end;

{ TFhirVisionPrescriptionDispenseListEnumerator }

Constructor TFhirVisionPrescriptionDispenseListEnumerator.Create(list : TFhirVisionPrescriptionDispenseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirVisionPrescriptionDispenseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirVisionPrescriptionDispenseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirVisionPrescriptionDispenseListEnumerator.GetCurrent : TFhirVisionPrescriptionDispense;
begin
  Result := FList[FIndex];
end;

function TFhirVisionPrescriptionDispenseListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirVisionPrescriptionDispenseList }
procedure TFhirVisionPrescriptionDispenseList.AddItem(value: TFhirVisionPrescriptionDispense);
begin
  assert(value.ClassName = 'TFhirVisionPrescriptionDispense', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirVisionPrescriptionDispense');
  add(value);
end;

function TFhirVisionPrescriptionDispenseList.Append: TFhirVisionPrescriptionDispense;
begin
  result := TFhirVisionPrescriptionDispense.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVisionPrescriptionDispenseList.ClearItems;
begin
  Clear;
end;

function TFhirVisionPrescriptionDispenseList.GetEnumerator : TFhirVisionPrescriptionDispenseListEnumerator;
begin
  result := TFhirVisionPrescriptionDispenseListEnumerator.Create(self.link);
end;

function TFhirVisionPrescriptionDispenseList.Clone: TFhirVisionPrescriptionDispenseList;
begin
  result := TFhirVisionPrescriptionDispenseList(inherited Clone);
end;

function TFhirVisionPrescriptionDispenseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirVisionPrescriptionDispenseList.GetItemN(index: Integer): TFhirVisionPrescriptionDispense;
begin
  result := TFhirVisionPrescriptionDispense(ObjectByIndex[index]);
end;

function TFhirVisionPrescriptionDispenseList.ItemClass: TFslObjectClass;
begin
  result := TFhirVisionPrescriptionDispense;
end;
function TFhirVisionPrescriptionDispenseList.IndexOf(value: TFhirVisionPrescriptionDispense): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirVisionPrescriptionDispenseList.Insert(index: Integer): TFhirVisionPrescriptionDispense;
begin
  result := TFhirVisionPrescriptionDispense.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVisionPrescriptionDispenseList.InsertItem(index: Integer; value: TFhirVisionPrescriptionDispense);
begin
  assert(value is TFhirVisionPrescriptionDispense);
  Inherited Insert(index, value);
end;

function TFhirVisionPrescriptionDispenseList.Item(index: Integer): TFhirVisionPrescriptionDispense;
begin
  result := TFhirVisionPrescriptionDispense(ObjectByIndex[index]);
end;

function TFhirVisionPrescriptionDispenseList.Link: TFhirVisionPrescriptionDispenseList;
begin
  result := TFhirVisionPrescriptionDispenseList(inherited Link);
end;

procedure TFhirVisionPrescriptionDispenseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirVisionPrescriptionDispenseList.SetItemByIndex(index: Integer; value: TFhirVisionPrescriptionDispense);
begin
  assert(value is TFhirVisionPrescriptionDispense);
  FhirVisionPrescriptionDispenses[index] := value;
end;

procedure TFhirVisionPrescriptionDispenseList.SetItemN(index: Integer; value: TFhirVisionPrescriptionDispense);
begin
  assert(value is TFhirVisionPrescriptionDispense);
  ObjectByIndex[index] := value;
end;

{ TFhirVisionPrescription }

constructor TFhirVisionPrescription.Create;
begin
  inherited;
end;

destructor TFhirVisionPrescription.Destroy;
begin
  FIdentifierList.Free;
  FDateWritten.free;
  FPatient.free;
  FPrescriber.free;
  FEncounter.free;
  FReason.free;
  FDispenseList.Free;
  inherited;
end;

function TFhirVisionPrescription.GetResourceType : TFhirResourceType;
begin
  result := frtVisionPrescription;
end;

procedure TFhirVisionPrescription.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirVisionPrescription(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirVisionPrescription(oSource).FIdentifierList);
  end;
  dateWrittenElement := TFhirVisionPrescription(oSource).dateWrittenElement.Clone;
  patient := TFhirVisionPrescription(oSource).patient.Clone;
  prescriber := TFhirVisionPrescription(oSource).prescriber.Clone;
  encounter := TFhirVisionPrescription(oSource).encounter.Clone;
  reason := TFhirVisionPrescription(oSource).reason.Clone;
  if (TFhirVisionPrescription(oSource).FDispenseList = nil) then
  begin
    FDispenseList.free;
    FDispenseList := nil;
  end
  else
  begin
    if FDispenseList = nil then
      FDispenseList := TFhirVisionPrescriptionDispenseList.Create;
    FDispenseList.Assign(TFhirVisionPrescription(oSource).FDispenseList);
  end;
end;

procedure TFhirVisionPrescription.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'dateWritten') Then
     list.add(self.link, 'dateWritten', FDateWritten.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'prescriber') Then
     list.add(self.link, 'prescriber', FPrescriber.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'reason[x]') or (child_name = 'reason') Then
     list.add(self.link, 'reason[x]', FReason.Link);
  if (child_name = 'dispense') Then
    list.addAll(self, 'dispense', FDispenseList);
end;

procedure TFhirVisionPrescription.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'dateWritten', 'dateTime', false, TFhirDateTime, FDateWritten.Link));{2}
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'prescriber', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FPrescriber.Link));{2}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference(Encounter)', false, TFhirReference{TFhirEncounter}, FEncounter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason[x]', 'CodeableConcept|Reference(Condition)', false, TFhirType, FReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dispense', '', true, TFhirVisionPrescriptionDispense, FDispenseList.Link)){3};
end;

function TFhirVisionPrescription.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'dateWritten') then
  begin
    DateWrittenElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'prescriber') then
  begin
    Prescriber := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference{TFhirEncounter}{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then
  begin
    Reason := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'dispense') then
  begin
    DispenseList.add(propValue as TFhirVisionPrescriptionDispense){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirVisionPrescription.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'dispense') then DispenseList.insertItem(index, propValue as TFhirVisionPrescriptionDispense){2a}
  else inherited;
end;

function TFhirVisionPrescription.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'dateWritten') then result := TFhirDateTime.create() {5b}
  else if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'prescriber') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'encounter') then result := TFhirReference{TFhirEncounter}.create(){4b}
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Reason'){4x}
  else if (propName = 'dispense') then result := DispenseList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirVisionPrescription.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'dateWritten') then result := 'dateTime'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'prescriber') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'reason[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'dispense') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirVisionPrescription.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'dateWritten') then DateWrittenElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'prescriber') then PrescriberElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then ReasonElement := nil{4x}
  else if (propName = 'dispense') then deletePropertyValue('dispense', DispenseList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirVisionPrescription.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'dateWritten') then DateWrittenElement := asDateTime(new){5b}
  else if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'prescriber') then PrescriberElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference{TFhirEncounter}{4}
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then ReasonElement := new as TFhirType{4x}
  else if (propName = 'dispense') then replacePropertyValue('dispense', DispenseList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirVisionPrescription.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'dispense') then DispenseList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirVisionPrescription.fhirType : string;
begin
  result := 'VisionPrescription';
end;

function TFhirVisionPrescription.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FDateWritten) and isEmptyProp(FPatient) and isEmptyProp(FPrescriber) and isEmptyProp(FEncounter) and isEmptyProp(FReason) and isEmptyProp(FdispenseList);
end;

function TFhirVisionPrescription.equals(other : TObject) : boolean;
var
  o : TFhirVisionPrescription;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirVisionPrescription)) then
    result := false
  else
  begin
    o := TFhirVisionPrescription(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(dateWrittenElement, o.dateWrittenElement, true) and
      compareDeep(patientElement, o.patientElement, true) and compareDeep(prescriberElement, o.prescriberElement, true) and
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(reasonElement, o.reasonElement, true) and
      compareDeep(dispenseList, o.dispenseList, true);
  end;
end;

function TFhirVisionPrescription.Link : TFhirVisionPrescription;
begin
  result := TFhirVisionPrescription(inherited Link);
end;

function TFhirVisionPrescription.Clone : TFhirVisionPrescription;
begin
  result := TFhirVisionPrescription(inherited Clone);
end;

procedure TFhirVisionPrescription.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('dateWritten');
  fields.add('patient');
  fields.add('prescriber');
  fields.add('encounter');
  fields.add('reason[x]');
  fields.add('dispense');
end;

{ TFhirVisionPrescription }

Function TFhirVisionPrescription.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirVisionPrescription.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirVisionPrescription.SetDateWritten(value : TFhirDateTime);
begin
  FDateWritten.free;
  FDateWritten := value;
end;

Function TFhirVisionPrescription.GetDateWrittenST : TFslDateTime;
begin
  if FDateWritten = nil then
    result := TFslDateTime.makeNull
  else
    result := FDateWritten.value;
end;

Procedure TFhirVisionPrescription.SetDateWrittenST(value : TFslDateTime);
begin
  if FDateWritten = nil then
    FDateWritten := TFhirDateTime.create;
  FDateWritten.value := value
end;

Procedure TFhirVisionPrescription.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Procedure TFhirVisionPrescription.SetPrescriber(value : TFhirReference{TFhirPractitioner});
begin
  FPrescriber.free;
  FPrescriber := value;
end;

Procedure TFhirVisionPrescription.SetEncounter(value : TFhirReference{TFhirEncounter});
begin
  FEncounter.free;
  FEncounter := value;
end;

Procedure TFhirVisionPrescription.SetReason(value : TFhirType);
begin
  FReason.free;
  FReason := value;
end;

Function TFhirVisionPrescription.GetDispenseList : TFhirVisionPrescriptionDispenseList;
begin
  if FDispenseList = nil then
    FDispenseList := TFhirVisionPrescriptionDispenseList.Create;
  result := FDispenseList;
end;

Function TFhirVisionPrescription.GetHasDispenseList : boolean;
begin
  result := (FDispenseList <> nil) and (FDispenseList.count > 0);
end;

function TFhirVisionPrescription.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FDateWritten.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FPrescriber.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FReason.sizeInBytes);
  inc(result, FdispenseList.sizeInBytes);
end;

{ TFhirVisionPrescriptionListEnumerator }

Constructor TFhirVisionPrescriptionListEnumerator.Create(list : TFhirVisionPrescriptionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirVisionPrescriptionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirVisionPrescriptionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirVisionPrescriptionListEnumerator.GetCurrent : TFhirVisionPrescription;
begin
  Result := FList[FIndex];
end;

function TFhirVisionPrescriptionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirVisionPrescriptionList }
procedure TFhirVisionPrescriptionList.AddItem(value: TFhirVisionPrescription);
begin
  assert(value.ClassName = 'TFhirVisionPrescription', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirVisionPrescription');
  add(value);
end;

function TFhirVisionPrescriptionList.Append: TFhirVisionPrescription;
begin
  result := TFhirVisionPrescription.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVisionPrescriptionList.ClearItems;
begin
  Clear;
end;

function TFhirVisionPrescriptionList.GetEnumerator : TFhirVisionPrescriptionListEnumerator;
begin
  result := TFhirVisionPrescriptionListEnumerator.Create(self.link);
end;

function TFhirVisionPrescriptionList.Clone: TFhirVisionPrescriptionList;
begin
  result := TFhirVisionPrescriptionList(inherited Clone);
end;

function TFhirVisionPrescriptionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirVisionPrescriptionList.GetItemN(index: Integer): TFhirVisionPrescription;
begin
  result := TFhirVisionPrescription(ObjectByIndex[index]);
end;

function TFhirVisionPrescriptionList.ItemClass: TFslObjectClass;
begin
  result := TFhirVisionPrescription;
end;
function TFhirVisionPrescriptionList.IndexOf(value: TFhirVisionPrescription): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirVisionPrescriptionList.Insert(index: Integer): TFhirVisionPrescription;
begin
  result := TFhirVisionPrescription.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVisionPrescriptionList.InsertItem(index: Integer; value: TFhirVisionPrescription);
begin
  assert(value is TFhirVisionPrescription);
  Inherited Insert(index, value);
end;

function TFhirVisionPrescriptionList.Item(index: Integer): TFhirVisionPrescription;
begin
  result := TFhirVisionPrescription(ObjectByIndex[index]);
end;

function TFhirVisionPrescriptionList.Link: TFhirVisionPrescriptionList;
begin
  result := TFhirVisionPrescriptionList(inherited Link);
end;

procedure TFhirVisionPrescriptionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirVisionPrescriptionList.SetItemByIndex(index: Integer; value: TFhirVisionPrescription);
begin
  assert(value is TFhirVisionPrescription);
  FhirVisionPrescriptions[index] := value;
end;

procedure TFhirVisionPrescriptionList.SetItemN(index: Integer; value: TFhirVisionPrescription);
begin
  assert(value is TFhirVisionPrescription);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_VISIONPRESCRIPTION}

end.

