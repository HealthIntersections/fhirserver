unit fhir2_resources_canonical;

{
  Copyright (c) 2011+, HL7 and Health Intersections Pty Ltd (http://www.healthintersections.com.au)
  All rights reserved.

  Redistribution and use in source and binary forms, with or without modification,
  are permitted provided that the following conditions are met:

   * Redistributions of source code must retain the above copyright notice, this
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice,
     this list of conditions and the following disclaimer in the documentation
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to
     endorse or promote products derived from this software without specific
     prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.

}

{$I fhir.inc}
{$I fhir2.inc}

interface

// FHIR v1.0.2 generated 2015-10-24T07:41:03+11:00

uses
  SysUtils, Classes,
  fsl_base, fsl_utilities, fsl_stream,
  fhir_objects, fhir_utilities, 
  fhir2_base, fhir2_types, fhir2_resources_base;

Type
{$IFDEF FHIR_CONCEPTMAP}
  TFhirConceptMapContact = class;
  TFhirConceptMapContactList = class;
  TFhirConceptMapElement = class;
  TFhirConceptMapElementList = class;
  TFhirConceptMapElementTarget = class;
  TFhirConceptMapElementTargetList = class;
  TFhirConceptMapElementTargetDependsOn = class;
  TFhirConceptMapElementTargetDependsOnList = class;
  TFhirConceptMap = class;
  TFhirConceptMapList = class;
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONFORMANCE}
  TFhirConformanceContact = class;
  TFhirConformanceContactList = class;
  TFhirConformanceSoftware = class;
  TFhirConformanceSoftwareList = class;
  TFhirConformanceImplementation = class;
  TFhirConformanceImplementationList = class;
  TFhirConformanceRest = class;
  TFhirConformanceRestList = class;
  TFhirConformanceRestSecurity = class;
  TFhirConformanceRestSecurityList = class;
  TFhirConformanceRestSecurityCertificate = class;
  TFhirConformanceRestSecurityCertificateList = class;
  TFhirConformanceRestResource = class;
  TFhirConformanceRestResourceList = class;
  TFhirConformanceRestResourceInteraction = class;
  TFhirConformanceRestResourceInteractionList = class;
  TFhirConformanceRestResourceSearchParam = class;
  TFhirConformanceRestResourceSearchParamList = class;
  TFhirConformanceRestInteraction = class;
  TFhirConformanceRestInteractionList = class;
  TFhirConformanceRestOperation = class;
  TFhirConformanceRestOperationList = class;
  TFhirConformanceMessaging = class;
  TFhirConformanceMessagingList = class;
  TFhirConformanceMessagingEndpoint = class;
  TFhirConformanceMessagingEndpointList = class;
  TFhirConformanceMessagingEvent = class;
  TFhirConformanceMessagingEventList = class;
  TFhirConformanceDocument = class;
  TFhirConformanceDocumentList = class;
  TFhirConformance = class;
  TFhirConformanceList = class;
{$ENDIF FHIR_CONFORMANCE}
{$IFDEF FHIR_DATAELEMENT}
  TFhirDataElementContact = class;
  TFhirDataElementContactList = class;
  TFhirDataElementMapping = class;
  TFhirDataElementMappingList = class;
  TFhirDataElement = class;
  TFhirDataElementList = class;
{$ENDIF FHIR_DATAELEMENT}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
  TFhirImplementationGuideContact = class;
  TFhirImplementationGuideContactList = class;
  TFhirImplementationGuideDependency = class;
  TFhirImplementationGuideDependencyList = class;
  TFhirImplementationGuidePackage = class;
  TFhirImplementationGuidePackageList = class;
  TFhirImplementationGuidePackageResource = class;
  TFhirImplementationGuidePackageResourceList = class;
  TFhirImplementationGuideGlobal = class;
  TFhirImplementationGuideGlobalList = class;
  TFhirImplementationGuidePage = class;
  TFhirImplementationGuidePageList = class;
  TFhirImplementationGuide = class;
  TFhirImplementationGuideList = class;
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_NAMINGSYSTEM}
  TFhirNamingSystemContact = class;
  TFhirNamingSystemContactList = class;
  TFhirNamingSystemUniqueId = class;
  TFhirNamingSystemUniqueIdList = class;
  TFhirNamingSystem = class;
  TFhirNamingSystemList = class;
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_OPERATIONDEFINITION}
  TFhirOperationDefinitionContact = class;
  TFhirOperationDefinitionContactList = class;
  TFhirOperationDefinitionParameter = class;
  TFhirOperationDefinitionParameterList = class;
  TFhirOperationDefinitionParameterBinding = class;
  TFhirOperationDefinitionParameterBindingList = class;
  TFhirOperationDefinition = class;
  TFhirOperationDefinitionList = class;
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_QUESTIONNAIRE}
  TFhirQuestionnaireGroup = class;
  TFhirQuestionnaireGroupList = class;
  TFhirQuestionnaireGroupQuestion = class;
  TFhirQuestionnaireGroupQuestionList = class;
  TFhirQuestionnaire = class;
  TFhirQuestionnaireList = class;
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_SEARCHPARAMETER}
  TFhirSearchParameterContact = class;
  TFhirSearchParameterContactList = class;
  TFhirSearchParameter = class;
  TFhirSearchParameterList = class;
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_STRUCTUREDEFINITION}
  TFhirStructureDefinitionContact = class;
  TFhirStructureDefinitionContactList = class;
  TFhirStructureDefinitionMapping = class;
  TFhirStructureDefinitionMappingList = class;
  TFhirStructureDefinitionSnapshot = class;
  TFhirStructureDefinitionSnapshotList = class;
  TFhirStructureDefinitionDifferential = class;
  TFhirStructureDefinitionDifferentialList = class;
  TFhirStructureDefinition = class;
  TFhirStructureDefinitionList = class;
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_TESTSCRIPT}
  TFhirTestScriptContact = class;
  TFhirTestScriptContactList = class;
  TFhirTestScriptMetadata = class;
  TFhirTestScriptMetadataList = class;
  TFhirTestScriptMetadataLink = class;
  TFhirTestScriptMetadataLinkList = class;
  TFhirTestScriptMetadataCapability = class;
  TFhirTestScriptMetadataCapabilityList = class;
  TFhirTestScriptFixture = class;
  TFhirTestScriptFixtureList = class;
  TFhirTestScriptVariable = class;
  TFhirTestScriptVariableList = class;
  TFhirTestScriptSetup = class;
  TFhirTestScriptSetupList = class;
  TFhirTestScriptSetupAction = class;
  TFhirTestScriptSetupActionList = class;
  TFhirTestScriptSetupActionOperation = class;
  TFhirTestScriptSetupActionOperationList = class;
  TFhirTestScriptSetupActionOperationRequestHeader = class;
  TFhirTestScriptSetupActionOperationRequestHeaderList = class;
  TFhirTestScriptSetupActionAssert = class;
  TFhirTestScriptSetupActionAssertList = class;
  TFhirTestScriptTest = class;
  TFhirTestScriptTestList = class;
  TFhirTestScriptTestAction = class;
  TFhirTestScriptTestActionList = class;
  TFhirTestScriptTeardown = class;
  TFhirTestScriptTeardownList = class;
  TFhirTestScriptTeardownAction = class;
  TFhirTestScriptTeardownActionList = class;
  TFhirTestScript = class;
  TFhirTestScriptList = class;
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
  TFhirValueSetContact = class;
  TFhirValueSetContactList = class;
  TFhirValueSetCodeSystem = class;
  TFhirValueSetCodeSystemList = class;
  TFhirValueSetCodeSystemConcept = class;
  TFhirValueSetCodeSystemConceptList = class;
  TFhirValueSetCodeSystemConceptDesignation = class;
  TFhirValueSetCodeSystemConceptDesignationList = class;
  TFhirValueSetCompose = class;
  TFhirValueSetComposeList = class;
  TFhirValueSetComposeInclude = class;
  TFhirValueSetComposeIncludeList = class;
  TFhirValueSetComposeIncludeConcept = class;
  TFhirValueSetComposeIncludeConceptList = class;
  TFhirValueSetComposeIncludeFilter = class;
  TFhirValueSetComposeIncludeFilterList = class;
  TFhirValueSetExpansion = class;
  TFhirValueSetExpansionList = class;
  TFhirValueSetExpansionParameter = class;
  TFhirValueSetExpansionParameterList = class;
  TFhirValueSetExpansionContains = class;
  TFhirValueSetExpansionContainsList = class;
  TFhirValueSet = class;
  TFhirValueSetList = class;
{$ENDIF FHIR_VALUESET}

  TFHIRMetadataResource = class abstract (TFHIRDomainResource)
  protected
    function GetUrl: String; virtual; abstract;
    function GetVersion: String; virtual; abstract;
  public
    function link : TFHIRMetadataResource; overload;
    property URL : String read GetUrl;
    property Version : String read GetVersion;
  end;

{$IFDEF FHIR_CONCEPTMAP}

  // Contacts to assist a user in finding and communicating with the publisher.
  TFhirConceptMapContact = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FtelecomList : TFhirContactPointList;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConceptMapContact; overload;
    function Clone : TFhirConceptMapContact; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The name of an individual to contact regarding the concept map.
    property name : String read GetNameST write SetNameST;
    // The name of an individual to contact regarding the concept map.
    property nameElement : TFhirString read FName write SetName;

    // Contact details for individual (if a name was provided) or the publisher.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

  end;

  TFhirConceptMapContactListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConceptMapContactList;
    function GetCurrent : TFhirConceptMapContact;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConceptMapContactList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConceptMapContact read GetCurrent;
  end;

  TFhirConceptMapContactList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConceptMapContact;
    procedure SetItemN(index : Integer; value : TFhirConceptMapContact);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConceptMapContactList; Overload;
    function Clone : TFhirConceptMapContactList; Overload;
    function GetEnumerator : TFhirConceptMapContactListEnumerator;
    

    //  Add a FhirConceptMapContact to the end of the list.
    function Append : TFhirConceptMapContact;

    
    // Add an already existing FhirConceptMapContact to the end of the list.
    procedure AddItem(value : TFhirConceptMapContact); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConceptMapContact) : Integer;
    

    // Insert FhirConceptMapContact before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConceptMapContact;
    

    // Insert an existing FhirConceptMapContact before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConceptMapContact);
    
    // Get the iIndexth FhirConceptMapContact. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConceptMapContact);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConceptMapContact;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirConceptMapContacts[index : Integer] : TFhirConceptMapContact read GetItemN write SetItemN; default;
  End;

  // Mappings for an individual concept in the source to one or more concepts in the target.
  TFhirConceptMapElement = class (TFhirBackboneElement)
  protected
    FCodeSystem : TFhirUri;
    FCode : TFhirCode;
    FtargetList : TFhirConceptMapElementTargetList;
    Procedure SetCodeSystem(value : TFhirUri);
    Function GetCodeSystemST : String;
    Procedure SetCodeSystemST(value : String);
    Procedure SetCode(value : TFhirCode);
    Function GetCodeST : String;
    Procedure SetCodeST(value : String);
    function GetTargetList : TFhirConceptMapElementTargetList;
    function GetHasTargetList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConceptMapElement; overload;
    function Clone : TFhirConceptMapElement; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URI that identifies the Code System (if the source is a value set that crosses more than one code system).
    property codeSystem : String read GetCodeSystemST write SetCodeSystemST;
    // An absolute URI that identifies the Code System (if the source is a value set that crosses more than one code system).
    property codeSystemElement : TFhirUri read FCodeSystem write SetCodeSystem;

    // Typed access to Identity (code or path) or the element/item being mapped.
    property code : String read GetCodeST write SetCodeST;
    // Identity (code or path) or the element/item being mapped.
    property codeElement : TFhirCode read FCode write SetCode;

    // A concept from the target value set that this concept maps to.
    property targetList : TFhirConceptMapElementTargetList read GetTargetList;
    property hasTargetList : boolean read GetHasTargetList;

  end;

  TFhirConceptMapElementListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConceptMapElementList;
    function GetCurrent : TFhirConceptMapElement;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConceptMapElementList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConceptMapElement read GetCurrent;
  end;

  TFhirConceptMapElementList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConceptMapElement;
    procedure SetItemN(index : Integer; value : TFhirConceptMapElement);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConceptMapElementList; Overload;
    function Clone : TFhirConceptMapElementList; Overload;
    function GetEnumerator : TFhirConceptMapElementListEnumerator;
    

    //  Add a FhirConceptMapElement to the end of the list.
    function Append : TFhirConceptMapElement;

    
    // Add an already existing FhirConceptMapElement to the end of the list.
    procedure AddItem(value : TFhirConceptMapElement); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConceptMapElement) : Integer;
    

    // Insert FhirConceptMapElement before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConceptMapElement;
    

    // Insert an existing FhirConceptMapElement before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConceptMapElement);
    
    // Get the iIndexth FhirConceptMapElement. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConceptMapElement);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConceptMapElement;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirConceptMapElements[index : Integer] : TFhirConceptMapElement read GetItemN write SetItemN; default;
  End;

  // A concept from the target value set that this concept maps to.
  TFhirConceptMapElementTarget = class (TFhirBackboneElement)
  protected
    FCodeSystem : TFhirUri;
    FCode : TFhirCode;
    FEquivalence : TFhirEnum;
    FComments : TFhirString;
    FdependsOnList : TFhirConceptMapElementTargetDependsOnList;
    FproductList : TFhirConceptMapElementTargetDependsOnList;
    Procedure SetCodeSystem(value : TFhirUri);
    Function GetCodeSystemST : String;
    Procedure SetCodeSystemST(value : String);
    Procedure SetCode(value : TFhirCode);
    Function GetCodeST : String;
    Procedure SetCodeST(value : String);
    Procedure SetEquivalence(value : TFhirEnum);
    Function GetEquivalenceST : TFhirConceptMapEquivalenceEnum;
    Procedure SetEquivalenceST(value : TFhirConceptMapEquivalenceEnum);
    Procedure SetComments(value : TFhirString);
    Function GetCommentsST : String;
    Procedure SetCommentsST(value : String);
    function GetDependsOnList : TFhirConceptMapElementTargetDependsOnList;
    function GetHasDependsOnList : Boolean;
    function GetProductList : TFhirConceptMapElementTargetDependsOnList;
    function GetHasProductList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConceptMapElementTarget; overload;
    function Clone : TFhirConceptMapElementTarget; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URI that identifies the code system of the target code (if the target is a value set that cross code systems).
    property codeSystem : String read GetCodeSystemST write SetCodeSystemST;
    // An absolute URI that identifies the code system of the target code (if the target is a value set that cross code systems).
    property codeSystemElement : TFhirUri read FCodeSystem write SetCodeSystem;

    // Typed access to Identity (code or path) or the element/item that the map refers to.
    property code : String read GetCodeST write SetCodeST;
    // Identity (code or path) or the element/item that the map refers to.
    property codeElement : TFhirCode read FCode write SetCode;

    // The equivalence between the source and target concepts (counting for the dependencies and products). The equivalence is read from target to source (e.g. the target is 'wider' than the source).
    property equivalence : TFhirConceptMapEquivalenceEnum read GetEquivalenceST write SetEquivalenceST;
    property equivalenceElement : TFhirEnum read FEquivalence write SetEquivalence;

    // Typed access to A description of status/issues in mapping that conveys additional information not represented in  the structured data.
    property comments : String read GetCommentsST write SetCommentsST;
    // A description of status/issues in mapping that conveys additional information not represented in  the structured data.
    property commentsElement : TFhirString read FComments write SetComments;

    // A set of additional dependencies for this mapping to hold. This mapping is only applicable if the specified element can be resolved, and it has the specified value.
    property dependsOnList : TFhirConceptMapElementTargetDependsOnList read GetDependsOnList;
    property hasDependsOnList : boolean read GetHasDependsOnList;

    // A set of additional outcomes from this mapping to other elements. To properly execute this mapping, the specified element must be mapped to some data element or source that is in context. The mapping may still be useful without a place for the additional data elements, but the equivalence cannot be relied on.
    property productList : TFhirConceptMapElementTargetDependsOnList read GetProductList;
    property hasProductList : boolean read GetHasProductList;

  end;

  TFhirConceptMapElementTargetListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConceptMapElementTargetList;
    function GetCurrent : TFhirConceptMapElementTarget;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConceptMapElementTargetList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConceptMapElementTarget read GetCurrent;
  end;

  TFhirConceptMapElementTargetList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConceptMapElementTarget;
    procedure SetItemN(index : Integer; value : TFhirConceptMapElementTarget);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConceptMapElementTargetList; Overload;
    function Clone : TFhirConceptMapElementTargetList; Overload;
    function GetEnumerator : TFhirConceptMapElementTargetListEnumerator;
    

    //  Add a FhirConceptMapElementTarget to the end of the list.
    function Append : TFhirConceptMapElementTarget;

    
    // Add an already existing FhirConceptMapElementTarget to the end of the list.
    procedure AddItem(value : TFhirConceptMapElementTarget); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConceptMapElementTarget) : Integer;
    

    // Insert FhirConceptMapElementTarget before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConceptMapElementTarget;
    

    // Insert an existing FhirConceptMapElementTarget before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConceptMapElementTarget);
    
    // Get the iIndexth FhirConceptMapElementTarget. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConceptMapElementTarget);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConceptMapElementTarget;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirConceptMapElementTargets[index : Integer] : TFhirConceptMapElementTarget read GetItemN write SetItemN; default;
  End;

  // A set of additional dependencies for this mapping to hold. This mapping is only applicable if the specified element can be resolved, and it has the specified value.
  TFhirConceptMapElementTargetDependsOn = class (TFhirBackboneElement)
  protected
    FElement : TFhirUri;
    FCodeSystem : TFhirUri;
    FCode : TFhirString;
    Procedure SetElement(value : TFhirUri);
    Function GetElementST : String;
    Procedure SetElementST(value : String);
    Procedure SetCodeSystem(value : TFhirUri);
    Function GetCodeSystemST : String;
    Procedure SetCodeSystemST(value : String);
    Procedure SetCode(value : TFhirString);
    Function GetCodeST : String;
    Procedure SetCodeST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConceptMapElementTargetDependsOn; overload;
    function Clone : TFhirConceptMapElementTargetDependsOn; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A reference to a specific concept that holds a coded value. This can be an element in a FHIR resource, or a specific reference to a data element in a different specification (e.g. HL7 v2) or a general reference to a kind of data field, or a reference to a value set with an appropriately narrow definition.
    property element : String read GetElementST write SetElementST;
    // A reference to a specific concept that holds a coded value. This can be an element in a FHIR resource, or a specific reference to a data element in a different specification (e.g. HL7 v2) or a general reference to a kind of data field, or a reference to a value set with an appropriately narrow definition.
    property elementElement : TFhirUri read FElement write SetElement;

    // Typed access to An absolute URI that identifies the code system of the dependency code (if the source/dependency is a value set that crosses code systems).
    property codeSystem : String read GetCodeSystemST write SetCodeSystemST;
    // An absolute URI that identifies the code system of the dependency code (if the source/dependency is a value set that crosses code systems).
    property codeSystemElement : TFhirUri read FCodeSystem write SetCodeSystem;

    // Typed access to Identity (code or path) or the element/item/ValueSet that the map depends on / refers to.
    property code : String read GetCodeST write SetCodeST;
    // Identity (code or path) or the element/item/ValueSet that the map depends on / refers to.
    property codeElement : TFhirString read FCode write SetCode;

  end;

  TFhirConceptMapElementTargetDependsOnListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConceptMapElementTargetDependsOnList;
    function GetCurrent : TFhirConceptMapElementTargetDependsOn;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConceptMapElementTargetDependsOnList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConceptMapElementTargetDependsOn read GetCurrent;
  end;

  TFhirConceptMapElementTargetDependsOnList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConceptMapElementTargetDependsOn;
    procedure SetItemN(index : Integer; value : TFhirConceptMapElementTargetDependsOn);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConceptMapElementTargetDependsOnList; Overload;
    function Clone : TFhirConceptMapElementTargetDependsOnList; Overload;
    function GetEnumerator : TFhirConceptMapElementTargetDependsOnListEnumerator;
    

    //  Add a FhirConceptMapElementTargetDependsOn to the end of the list.
    function Append : TFhirConceptMapElementTargetDependsOn;

    
    // Add an already existing FhirConceptMapElementTargetDependsOn to the end of the list.
    procedure AddItem(value : TFhirConceptMapElementTargetDependsOn); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConceptMapElementTargetDependsOn) : Integer;
    

    // Insert FhirConceptMapElementTargetDependsOn before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConceptMapElementTargetDependsOn;
    

    // Insert an existing FhirConceptMapElementTargetDependsOn before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConceptMapElementTargetDependsOn);
    
    // Get the iIndexth FhirConceptMapElementTargetDependsOn. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConceptMapElementTargetDependsOn);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConceptMapElementTargetDependsOn;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirConceptMapElementTargetDependsOns[index : Integer] : TFhirConceptMapElementTargetDependsOn read GetItemN write SetItemN; default;
  End;

  // A statement of relationships from one set of concepts to one or more other concepts - either code systems or data elements, or classes in class models.
  TFhirConceptMap = class (TFhirDomainResource)
  protected
    FUrl : TFhirUri;
    FIdentifier : TFhirIdentifier;
    FVersion : TFhirString;
    FName : TFhirString;
    FStatus : TFhirEnum;
    FExperimental : TFhirBoolean;
    FPublisher : TFhirString;
    FcontactList : TFhirConceptMapContactList;
    FDate : TFhirDateTime;
    FDescription : TFhirString;
    FuseContextList : TFhirCodeableConceptList;
    FRequirements : TFhirString;
    FCopyright : TFhirString;
    FSource : TFhirType;
    FTarget : TFhirType;
    FelementList : TFhirConceptMapElementList;
    Procedure SetUrl(value : TFhirUri);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetVersion(value : TFhirString);
    Function GetVersionST : String;
    Procedure SetVersionST(value : String);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirConformanceResourceStatusEnum;
    Procedure SetStatusST(value : TFhirConformanceResourceStatusEnum);
    Procedure SetExperimental(value : TFhirBoolean);
    Function GetExperimentalST : Boolean;
    Procedure SetExperimentalST(value : Boolean);
    Procedure SetPublisher(value : TFhirString);
    Function GetPublisherST : String;
    Procedure SetPublisherST(value : String);
    function GetContactList : TFhirConceptMapContactList;
    function GetHasContactList : Boolean;
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    function GetUseContextList : TFhirCodeableConceptList;
    function GetHasUseContextList : Boolean;
    Procedure SetRequirements(value : TFhirString);
    Function GetRequirementsST : String;
    Procedure SetRequirementsST(value : String);
    Procedure SetCopyright(value : TFhirString);
    Function GetCopyrightST : String;
    Procedure SetCopyrightST(value : String);
    Procedure SetSource(value : TFhirType);
    Procedure SetTarget(value : TFhirType);
    function GetElementList : TFhirConceptMapElementList;
    function GetHasElementList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConceptMap; overload;
    function Clone : TFhirConceptMap; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URL that is used to identify this concept map when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this concept map is (or will be) {$IFNDEF FPC}published{$ENDIF}.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URL that is used to identify this concept map when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this concept map is (or will be) {$IFNDEF FPC}published{$ENDIF}.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to Formal identifier that is used to identify this concept map when it is represented in other formats, or referenced in a specification, model, design or an instance. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Formal identifier that is used to identify this concept map when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to The identifier that is used to identify this version of the concept map when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the profile author manually and the value should be a timestamp.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the concept map when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the profile author manually and the value should be a timestamp.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A free text natural language name describing the concept map.
    property name : String read GetNameST write SetNameST;
    // A free text natural language name describing the concept map.
    property nameElement : TFhirString read FName write SetName;

    // The status of the concept map.
    property status : TFhirConformanceResourceStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to This ConceptMap was authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // This ConceptMap was authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The name of the individual or organization that {$IFNDEF FPC}published{$ENDIF} the concept map.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the individual or organization that {$IFNDEF FPC}published{$ENDIF} the concept map.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contacts to assist a user in finding and communicating with the publisher.
    property contactList : TFhirConceptMapContactList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to The date this version of the concept map was {$IFNDEF FPC}published{$ENDIF}. The date must change when the business version changes, if it does, and it must change if the status code changes. In addition, it should change when the substantive content of the concept map changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date this version of the concept map was {$IFNDEF FPC}published{$ENDIF}. The date must change when the business version changes, if it does, and it must change if the status code changes. In addition, it should change when the substantive content of the concept map changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to A free text natural language description of the use of the concept map - reason for definition, conditions of use, etc.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the use of the concept map - reason for definition, conditions of use, etc.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These terms may be used to assist with indexing and searching of concept map instances.
    property useContextList : TFhirCodeableConceptList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // Typed access to Explains why this concept map is needed and why it has been constrained as it has.
    property requirements : String read GetRequirementsST write SetRequirementsST;
    // Explains why this concept map is needed and why it has been constrained as it has.
    property requirementsElement : TFhirString read FRequirements write SetRequirements;

    // Typed access to A copyright statement relating to the concept map and/or its contents.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the concept map and/or its contents.
    property copyrightElement : TFhirString read FCopyright write SetCopyright;

    // Typed access to The source value set that specifies the concepts that are being mapped. (defined for API consistency)
    property source : TFhirType read FSource write SetSource;
    // The source value set that specifies the concepts that are being mapped.
    property sourceElement : TFhirType read FSource write SetSource;

    // Typed access to The target value set provides context to the mappings. Note that the mapping is made between concepts, not between value sets, but the value set provides important context about how the concept mapping choices are made. (defined for API consistency)
    property target : TFhirType read FTarget write SetTarget;
    // The target value set provides context to the mappings. Note that the mapping is made between concepts, not between value sets, but the value set provides important context about how the concept mapping choices are made.
    property targetElement : TFhirType read FTarget write SetTarget;

    // Mappings for an individual concept in the source to one or more concepts in the target.
    property elementList : TFhirConceptMapElementList read GetElementList;
    property hasElementList : boolean read GetHasElementList;

  end;

  TFhirConceptMapListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConceptMapList;
    function GetCurrent : TFhirConceptMap;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConceptMapList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConceptMap read GetCurrent;
  end;

  TFhirConceptMapList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConceptMap;
    procedure SetItemN(index : Integer; value : TFhirConceptMap);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConceptMapList; Overload;
    function Clone : TFhirConceptMapList; Overload;
    function GetEnumerator : TFhirConceptMapListEnumerator;
    

    //  Add a FhirConceptMap to the end of the list.
    function Append : TFhirConceptMap;

    
    // Add an already existing FhirConceptMap to the end of the list.
    procedure AddItem(value : TFhirConceptMap); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConceptMap) : Integer;
    

    // Insert FhirConceptMap before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConceptMap;
    

    // Insert an existing FhirConceptMap before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConceptMap);
    
    // Get the iIndexth FhirConceptMap. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConceptMap);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConceptMap;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirConceptMaps[index : Integer] : TFhirConceptMap read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CONCEPTMAP}

{$IFDEF FHIR_CONFORMANCE}

  // Contacts to assist a user in finding and communicating with the publisher.
  TFhirConformanceContact = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FtelecomList : TFhirContactPointList;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConformanceContact; overload;
    function Clone : TFhirConformanceContact; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The name of an individual to contact regarding the conformance.
    property name : String read GetNameST write SetNameST;
    // The name of an individual to contact regarding the conformance.
    property nameElement : TFhirString read FName write SetName;

    // Contact details for individual (if a name was provided) or the publisher.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

  end;

  TFhirConformanceContactListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConformanceContactList;
    function GetCurrent : TFhirConformanceContact;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConformanceContactList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConformanceContact read GetCurrent;
  end;

  TFhirConformanceContactList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConformanceContact;
    procedure SetItemN(index : Integer; value : TFhirConformanceContact);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConformanceContactList; Overload;
    function Clone : TFhirConformanceContactList; Overload;
    function GetEnumerator : TFhirConformanceContactListEnumerator;
    

    //  Add a FhirConformanceContact to the end of the list.
    function Append : TFhirConformanceContact;

    
    // Add an already existing FhirConformanceContact to the end of the list.
    procedure AddItem(value : TFhirConformanceContact); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConformanceContact) : Integer;
    

    // Insert FhirConformanceContact before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConformanceContact;
    

    // Insert an existing FhirConformanceContact before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConformanceContact);
    
    // Get the iIndexth FhirConformanceContact. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceContact);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConformanceContact;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirConformanceContacts[index : Integer] : TFhirConformanceContact read GetItemN write SetItemN; default;
  End;

  // Software that is covered by this conformance statement.  It is used when the conformance statement describes the capabilities of a particular software version, independent of an installation.
  TFhirConformanceSoftware = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FVersion : TFhirString;
    FReleaseDate : TFhirDateTime;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetVersion(value : TFhirString);
    Function GetVersionST : String;
    Procedure SetVersionST(value : String);
    Procedure SetReleaseDate(value : TFhirDateTime);
    Function GetReleaseDateST : TFslDateTime;
    Procedure SetReleaseDateST(value : TFslDateTime);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConformanceSoftware; overload;
    function Clone : TFhirConformanceSoftware; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Name software is known by.
    property name : String read GetNameST write SetNameST;
    // Name software is known by.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to The version identifier for the software covered by this statement.
    property version : String read GetVersionST write SetVersionST;
    // The version identifier for the software covered by this statement.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to Date this version of the software released.
    property releaseDate : TFslDateTime read GetReleaseDateST write SetReleaseDateST;
    // Date this version of the software released.
    property releaseDateElement : TFhirDateTime read FReleaseDate write SetReleaseDate;

  end;

  TFhirConformanceSoftwareListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConformanceSoftwareList;
    function GetCurrent : TFhirConformanceSoftware;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConformanceSoftwareList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConformanceSoftware read GetCurrent;
  end;

  TFhirConformanceSoftwareList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConformanceSoftware;
    procedure SetItemN(index : Integer; value : TFhirConformanceSoftware);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConformanceSoftwareList; Overload;
    function Clone : TFhirConformanceSoftwareList; Overload;
    function GetEnumerator : TFhirConformanceSoftwareListEnumerator;
    

    //  Add a FhirConformanceSoftware to the end of the list.
    function Append : TFhirConformanceSoftware;

    
    // Add an already existing FhirConformanceSoftware to the end of the list.
    procedure AddItem(value : TFhirConformanceSoftware); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConformanceSoftware) : Integer;
    

    // Insert FhirConformanceSoftware before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConformanceSoftware;
    

    // Insert an existing FhirConformanceSoftware before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConformanceSoftware);
    
    // Get the iIndexth FhirConformanceSoftware. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceSoftware);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConformanceSoftware;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirConformanceSoftwares[index : Integer] : TFhirConformanceSoftware read GetItemN write SetItemN; default;
  End;

  // Identifies a specific implementation instance that is described by the conformance statement - i.e. a particular installation, rather than the capabilities of a software program.
  TFhirConformanceImplementation = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FUrl : TFhirUri;
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetUrl(value : TFhirUri);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConformanceImplementation; overload;
    function Clone : TFhirConformanceImplementation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Information about the specific installation that this conformance statement relates to.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Information about the specific installation that this conformance statement relates to.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to An absolute base URL for the implementation.  This forms the base for REST interfaces as well as the mailbox and document interfaces.
    property url : String read GetUrlST write SetUrlST;
    // An absolute base URL for the implementation.  This forms the base for REST interfaces as well as the mailbox and document interfaces.
    property urlElement : TFhirUri read FUrl write SetUrl;

  end;

  TFhirConformanceImplementationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConformanceImplementationList;
    function GetCurrent : TFhirConformanceImplementation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConformanceImplementationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConformanceImplementation read GetCurrent;
  end;

  TFhirConformanceImplementationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConformanceImplementation;
    procedure SetItemN(index : Integer; value : TFhirConformanceImplementation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConformanceImplementationList; Overload;
    function Clone : TFhirConformanceImplementationList; Overload;
    function GetEnumerator : TFhirConformanceImplementationListEnumerator;
    

    //  Add a FhirConformanceImplementation to the end of the list.
    function Append : TFhirConformanceImplementation;

    
    // Add an already existing FhirConformanceImplementation to the end of the list.
    procedure AddItem(value : TFhirConformanceImplementation); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConformanceImplementation) : Integer;
    

    // Insert FhirConformanceImplementation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConformanceImplementation;
    

    // Insert an existing FhirConformanceImplementation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConformanceImplementation);
    
    // Get the iIndexth FhirConformanceImplementation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceImplementation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConformanceImplementation;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirConformanceImplementations[index : Integer] : TFhirConformanceImplementation read GetItemN write SetItemN; default;
  End;

  // A definition of the restful capabilities of the solution, if any.
  TFhirConformanceRest = class (TFhirBackboneElement)
  protected
    FMode : TFhirEnum;
    FDocumentation : TFhirString;
    FSecurity : TFhirConformanceRestSecurity;
    FresourceList : TFhirConformanceRestResourceList;
    FinteractionList : TFhirConformanceRestInteractionList;
    FTransactionMode : TFhirEnum;
    FsearchParamList : TFhirConformanceRestResourceSearchParamList;
    FoperationList : TFhirConformanceRestOperationList;
    FcompartmentList : TFhirUriList;
    Procedure SetMode(value : TFhirEnum);
    Function GetModeST : TFhirRestfulConformanceModeEnum;
    Procedure SetModeST(value : TFhirRestfulConformanceModeEnum);
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);
    Procedure SetSecurity(value : TFhirConformanceRestSecurity);
    function GetResourceList : TFhirConformanceRestResourceList;
    function GetHasResourceList : Boolean;
    function GetInteractionList : TFhirConformanceRestInteractionList;
    function GetHasInteractionList : Boolean;
    Procedure SetTransactionMode(value : TFhirEnum);
    Function GetTransactionModeST : TFhirTransactionModeEnum;
    Procedure SetTransactionModeST(value : TFhirTransactionModeEnum);
    function GetSearchParamList : TFhirConformanceRestResourceSearchParamList;
    function GetHasSearchParamList : Boolean;
    function GetOperationList : TFhirConformanceRestOperationList;
    function GetHasOperationList : Boolean;
    function GetCompartmentList : TFhirUriList;
    function GetHasCompartmentList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConformanceRest; overload;
    function Clone : TFhirConformanceRest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifies whether this portion of the statement is describing ability to initiate or receive restful operations.
    property mode : TFhirRestfulConformanceModeEnum read GetModeST write SetModeST;
    property modeElement : TFhirEnum read FMode write SetMode;

    // Typed access to Information about the system's restful capabilities that apply across all applications, such as security.
    property documentation : String read GetDocumentationST write SetDocumentationST;
    // Information about the system's restful capabilities that apply across all applications, such as security.
    property documentationElement : TFhirString read FDocumentation write SetDocumentation;

    // Typed access to Information about security implementation from an interface perspective - what a client needs to know. (defined for API consistency)
    property security : TFhirConformanceRestSecurity read FSecurity write SetSecurity;
    // Information about security implementation from an interface perspective - what a client needs to know.
    property securityElement : TFhirConformanceRestSecurity read FSecurity write SetSecurity;

    // A specification of the restful capabilities of the solution for a specific resource type.
    property resourceList : TFhirConformanceRestResourceList read GetResourceList;
    property hasResourceList : boolean read GetHasResourceList;

    // A specification of restful operations supported by the system.
    property interactionList : TFhirConformanceRestInteractionList read GetInteractionList;
    property hasInteractionList : boolean read GetHasInteractionList;

    // A code that indicates how transactions are supported.
    property transactionMode : TFhirTransactionModeEnum read GetTransactionModeST write SetTransactionModeST;
    property transactionModeElement : TFhirEnum read FTransactionMode write SetTransactionMode;

    // Search parameters that are supported for searching all resources for implementations to support and/or make use of - either references to ones defined in the specification, or additional ones defined for/by the implementation.
    property searchParamList : TFhirConformanceRestResourceSearchParamList read GetSearchParamList;
    property hasSearchParamList : boolean read GetHasSearchParamList;

    // Definition of an operation or a named query and with its parameters and their meaning and type.
    property operationList : TFhirConformanceRestOperationList read GetOperationList;
    property hasOperationList : boolean read GetHasOperationList;

    // An absolute URI which is a reference to the definition of a compartment hosted by the system.
    property compartmentList : TFhirUriList read GetCompartmentList;
    property hasCompartmentList : boolean read GetHasCompartmentList;

  end;

  TFhirConformanceRestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConformanceRestList;
    function GetCurrent : TFhirConformanceRest;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConformanceRestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConformanceRest read GetCurrent;
  end;

  TFhirConformanceRestList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConformanceRest;
    procedure SetItemN(index : Integer; value : TFhirConformanceRest);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConformanceRestList; Overload;
    function Clone : TFhirConformanceRestList; Overload;
    function GetEnumerator : TFhirConformanceRestListEnumerator;
    

    //  Add a FhirConformanceRest to the end of the list.
    function Append : TFhirConformanceRest;

    
    // Add an already existing FhirConformanceRest to the end of the list.
    procedure AddItem(value : TFhirConformanceRest); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConformanceRest) : Integer;
    

    // Insert FhirConformanceRest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConformanceRest;
    

    // Insert an existing FhirConformanceRest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConformanceRest);
    
    // Get the iIndexth FhirConformanceRest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceRest);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConformanceRest;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirConformanceRests[index : Integer] : TFhirConformanceRest read GetItemN write SetItemN; default;
  End;

  // Information about security implementation from an interface perspective - what a client needs to know.
  TFhirConformanceRestSecurity = class (TFhirBackboneElement)
  protected
    FCors : TFhirBoolean;
    FserviceList : TFhirCodeableConceptList;
    FDescription : TFhirString;
    FcertificateList : TFhirConformanceRestSecurityCertificateList;
    Procedure SetCors(value : TFhirBoolean);
    Function GetCorsST : Boolean;
    Procedure SetCorsST(value : Boolean);
    function GetServiceList : TFhirCodeableConceptList;
    function GetHasServiceList : Boolean;
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    function GetCertificateList : TFhirConformanceRestSecurityCertificateList;
    function GetHasCertificateList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConformanceRestSecurity; overload;
    function Clone : TFhirConformanceRestSecurity; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Server adds CORS headers when responding to requests - this enables javascript applications to use the server.
    property cors : Boolean read GetCorsST write SetCorsST;
    // Server adds CORS headers when responding to requests - this enables javascript applications to use the server.
    property corsElement : TFhirBoolean read FCors write SetCors;

    // Types of security services are supported/required by the system.
    property serviceList : TFhirCodeableConceptList read GetServiceList;
    property hasServiceList : boolean read GetHasServiceList;

    // Typed access to General description of how security works.
    property description : String read GetDescriptionST write SetDescriptionST;
    // General description of how security works.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Certificates associated with security profiles.
    property certificateList : TFhirConformanceRestSecurityCertificateList read GetCertificateList;
    property hasCertificateList : boolean read GetHasCertificateList;

  end;

  TFhirConformanceRestSecurityListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConformanceRestSecurityList;
    function GetCurrent : TFhirConformanceRestSecurity;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConformanceRestSecurityList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConformanceRestSecurity read GetCurrent;
  end;

  TFhirConformanceRestSecurityList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConformanceRestSecurity;
    procedure SetItemN(index : Integer; value : TFhirConformanceRestSecurity);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConformanceRestSecurityList; Overload;
    function Clone : TFhirConformanceRestSecurityList; Overload;
    function GetEnumerator : TFhirConformanceRestSecurityListEnumerator;
    

    //  Add a FhirConformanceRestSecurity to the end of the list.
    function Append : TFhirConformanceRestSecurity;

    
    // Add an already existing FhirConformanceRestSecurity to the end of the list.
    procedure AddItem(value : TFhirConformanceRestSecurity); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConformanceRestSecurity) : Integer;
    

    // Insert FhirConformanceRestSecurity before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConformanceRestSecurity;
    

    // Insert an existing FhirConformanceRestSecurity before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConformanceRestSecurity);
    
    // Get the iIndexth FhirConformanceRestSecurity. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceRestSecurity);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConformanceRestSecurity;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirConformanceRestSecurities[index : Integer] : TFhirConformanceRestSecurity read GetItemN write SetItemN; default;
  End;

  // Certificates associated with security profiles.
  TFhirConformanceRestSecurityCertificate = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCode;
    FBlob : TFhirBase64Binary;
    Procedure SetType_(value : TFhirCode);
    Function GetType_ST : String;
    Procedure SetType_ST(value : String);
    Procedure SetBlob(value : TFhirBase64Binary);
    Function GetBlobST : TBytes;
    Procedure SetBlobST(value : TBytes);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConformanceRestSecurityCertificate; overload;
    function Clone : TFhirConformanceRestSecurityCertificate; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Mime type for certificate.
    property type_ : String read GetType_ST write SetType_ST;
    // Mime type for certificate.
    property type_Element : TFhirCode read FType_ write SetType_;

    // Typed access to Actual certificate.
    property blob : TBytes read GetBlobST write SetBlobST;
    // Actual certificate.
    property blobElement : TFhirBase64Binary read FBlob write SetBlob;

  end;

  TFhirConformanceRestSecurityCertificateListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConformanceRestSecurityCertificateList;
    function GetCurrent : TFhirConformanceRestSecurityCertificate;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConformanceRestSecurityCertificateList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConformanceRestSecurityCertificate read GetCurrent;
  end;

  TFhirConformanceRestSecurityCertificateList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConformanceRestSecurityCertificate;
    procedure SetItemN(index : Integer; value : TFhirConformanceRestSecurityCertificate);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConformanceRestSecurityCertificateList; Overload;
    function Clone : TFhirConformanceRestSecurityCertificateList; Overload;
    function GetEnumerator : TFhirConformanceRestSecurityCertificateListEnumerator;
    

    //  Add a FhirConformanceRestSecurityCertificate to the end of the list.
    function Append : TFhirConformanceRestSecurityCertificate;

    
    // Add an already existing FhirConformanceRestSecurityCertificate to the end of the list.
    procedure AddItem(value : TFhirConformanceRestSecurityCertificate); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConformanceRestSecurityCertificate) : Integer;
    

    // Insert FhirConformanceRestSecurityCertificate before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConformanceRestSecurityCertificate;
    

    // Insert an existing FhirConformanceRestSecurityCertificate before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConformanceRestSecurityCertificate);
    
    // Get the iIndexth FhirConformanceRestSecurityCertificate. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceRestSecurityCertificate);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConformanceRestSecurityCertificate;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirConformanceRestSecurityCertificates[index : Integer] : TFhirConformanceRestSecurityCertificate read GetItemN write SetItemN; default;
  End;

  // A specification of the restful capabilities of the solution for a specific resource type.
  TFhirConformanceRestResource = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FProfile : TFhirReference{TFhirStructureDefinition};
    FinteractionList : TFhirConformanceRestResourceInteractionList;
    FVersioning : TFhirEnum;
    FReadHistory : TFhirBoolean;
    FUpdateCreate : TFhirBoolean;
    FConditionalCreate : TFhirBoolean;
    FConditionalUpdate : TFhirBoolean;
    FConditionalDelete : TFhirEnum;
    FsearchIncludeList : TFhirStringList;
    FsearchRevIncludeList : TFhirStringList;
    FsearchParamList : TFhirConformanceRestResourceSearchParamList;
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirResourceTypesEnum;
    Procedure SetType_ST(value : TFhirResourceTypesEnum);
    Procedure SetProfile(value : TFhirReference{TFhirStructureDefinition});
    function GetInteractionList : TFhirConformanceRestResourceInteractionList;
    function GetHasInteractionList : Boolean;
    Procedure SetVersioning(value : TFhirEnum);
    Function GetVersioningST : TFhirVersioningPolicyEnum;
    Procedure SetVersioningST(value : TFhirVersioningPolicyEnum);
    Procedure SetReadHistory(value : TFhirBoolean);
    Function GetReadHistoryST : Boolean;
    Procedure SetReadHistoryST(value : Boolean);
    Procedure SetUpdateCreate(value : TFhirBoolean);
    Function GetUpdateCreateST : Boolean;
    Procedure SetUpdateCreateST(value : Boolean);
    Procedure SetConditionalCreate(value : TFhirBoolean);
    Function GetConditionalCreateST : Boolean;
    Procedure SetConditionalCreateST(value : Boolean);
    Procedure SetConditionalUpdate(value : TFhirBoolean);
    Function GetConditionalUpdateST : Boolean;
    Procedure SetConditionalUpdateST(value : Boolean);
    Procedure SetConditionalDelete(value : TFhirEnum);
    Function GetConditionalDeleteST : TFhirConditionalDeleteStatusEnum;
    Procedure SetConditionalDeleteST(value : TFhirConditionalDeleteStatusEnum);
    function GetSearchIncludeList : TFhirStringList;
    function GetHasSearchIncludeList : Boolean;
    function GetSearchRevIncludeList : TFhirStringList;
    function GetHasSearchRevIncludeList : Boolean;
    function GetSearchParamList : TFhirConformanceRestResourceSearchParamList;
    function GetHasSearchParamList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConformanceRestResource; overload;
    function Clone : TFhirConformanceRestResource; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A type of resource exposed via the restful interface.
    property type_ : TFhirResourceTypesEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to A specification of the profile that describes the solution's overall support for the resource, including any constraints on cardinality, bindings, lengths or other limitations. See further discussion in [Using Profiles]. (defined for API consistency)
    property profile : TFhirReference{TFhirStructureDefinition} read FProfile write SetProfile;
    // A specification of the profile that describes the solution's overall support for the resource, including any constraints on cardinality, bindings, lengths or other limitations. See further discussion in [Using Profiles].
    property profileElement : TFhirReference{TFhirStructureDefinition} read FProfile write SetProfile;

    // Identifies a restful operation supported by the solution.
    property interactionList : TFhirConformanceRestResourceInteractionList read GetInteractionList;
    property hasInteractionList : boolean read GetHasInteractionList;

    // This field is set to no-version to specify that the system does not support (server) or use (client) versioning for this resource type. If this has some other value, the server must at least correctly track and populate the versionId meta-property on resources. If the value is 'versioned-update', then the server supports all the versioning features, including using e-tags for version integrity in the API.
    property versioning : TFhirVersioningPolicyEnum read GetVersioningST write SetVersioningST;
    property versioningElement : TFhirEnum read FVersioning write SetVersioning;

    // Typed access to A flag for whether the server is able to return past versions as part of the vRead operation.
    property readHistory : Boolean read GetReadHistoryST write SetReadHistoryST;
    // A flag for whether the server is able to return past versions as part of the vRead operation.
    property readHistoryElement : TFhirBoolean read FReadHistory write SetReadHistory;

    // Typed access to A flag to indicate that the server allows or needs to allow the client to create new identities on the server (e.g. that is, the client PUTs to a location where there is no existing resource). Allowing this operation means that the server allows the client to create new identities on the server.
    property updateCreate : Boolean read GetUpdateCreateST write SetUpdateCreateST;
    // A flag to indicate that the server allows or needs to allow the client to create new identities on the server (e.g. that is, the client PUTs to a location where there is no existing resource). Allowing this operation means that the server allows the client to create new identities on the server.
    property updateCreateElement : TFhirBoolean read FUpdateCreate write SetUpdateCreate;

    // Typed access to A flag that indicates that the server supports conditional create.
    property conditionalCreate : Boolean read GetConditionalCreateST write SetConditionalCreateST;
    // A flag that indicates that the server supports conditional create.
    property conditionalCreateElement : TFhirBoolean read FConditionalCreate write SetConditionalCreate;

    // Typed access to A flag that indicates that the server supports conditional update.
    property conditionalUpdate : Boolean read GetConditionalUpdateST write SetConditionalUpdateST;
    // A flag that indicates that the server supports conditional update.
    property conditionalUpdateElement : TFhirBoolean read FConditionalUpdate write SetConditionalUpdate;

    // A code that indicates how the server supports conditional delete.
    property conditionalDelete : TFhirConditionalDeleteStatusEnum read GetConditionalDeleteST write SetConditionalDeleteST;
    property conditionalDeleteElement : TFhirEnum read FConditionalDelete write SetConditionalDelete;

    // A list of _include values supported by the server.
    property searchIncludeList : TFhirStringList read GetSearchIncludeList;
    property hasSearchIncludeList : boolean read GetHasSearchIncludeList;

    // A list of _revinclude (reverse include) values supported by the server.
    property searchRevIncludeList : TFhirStringList read GetSearchRevIncludeList;
    property hasSearchRevIncludeList : boolean read GetHasSearchRevIncludeList;

    // Search parameters for implementations to support and/or make use of - either references to ones defined in the specification, or additional ones defined for/by the implementation.
    property searchParamList : TFhirConformanceRestResourceSearchParamList read GetSearchParamList;
    property hasSearchParamList : boolean read GetHasSearchParamList;

  end;

  TFhirConformanceRestResourceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConformanceRestResourceList;
    function GetCurrent : TFhirConformanceRestResource;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConformanceRestResourceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConformanceRestResource read GetCurrent;
  end;

  TFhirConformanceRestResourceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConformanceRestResource;
    procedure SetItemN(index : Integer; value : TFhirConformanceRestResource);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConformanceRestResourceList; Overload;
    function Clone : TFhirConformanceRestResourceList; Overload;
    function GetEnumerator : TFhirConformanceRestResourceListEnumerator;
    

    //  Add a FhirConformanceRestResource to the end of the list.
    function Append : TFhirConformanceRestResource;

    
    // Add an already existing FhirConformanceRestResource to the end of the list.
    procedure AddItem(value : TFhirConformanceRestResource); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConformanceRestResource) : Integer;
    

    // Insert FhirConformanceRestResource before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConformanceRestResource;
    

    // Insert an existing FhirConformanceRestResource before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConformanceRestResource);
    
    // Get the iIndexth FhirConformanceRestResource. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceRestResource);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConformanceRestResource;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirConformanceRestResources[index : Integer] : TFhirConformanceRestResource read GetItemN write SetItemN; default;
  End;

  // Identifies a restful operation supported by the solution.
  TFhirConformanceRestResourceInteraction = class (TFhirBackboneElement)
  protected
    FCode : TFhirEnum;
    FDocumentation : TFhirString;
    Procedure SetCode(value : TFhirEnum);
    Function GetCodeST : TFhirTypeRestfulInteractionEnum;
    Procedure SetCodeST(value : TFhirTypeRestfulInteractionEnum);
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConformanceRestResourceInteraction; overload;
    function Clone : TFhirConformanceRestResourceInteraction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Coded identifier of the operation, supported by the system resource.
    property code : TFhirTypeRestfulInteractionEnum read GetCodeST write SetCodeST;
    property codeElement : TFhirEnum read FCode write SetCode;

    // Typed access to Guidance specific to the implementation of this operation, such as 'delete is a logical delete' or 'updates are only allowed with version id' or 'creates permitted from pre-authorized certificates only'.
    property documentation : String read GetDocumentationST write SetDocumentationST;
    // Guidance specific to the implementation of this operation, such as 'delete is a logical delete' or 'updates are only allowed with version id' or 'creates permitted from pre-authorized certificates only'.
    property documentationElement : TFhirString read FDocumentation write SetDocumentation;

  end;

  TFhirConformanceRestResourceInteractionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConformanceRestResourceInteractionList;
    function GetCurrent : TFhirConformanceRestResourceInteraction;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConformanceRestResourceInteractionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConformanceRestResourceInteraction read GetCurrent;
  end;

  TFhirConformanceRestResourceInteractionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConformanceRestResourceInteraction;
    procedure SetItemN(index : Integer; value : TFhirConformanceRestResourceInteraction);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConformanceRestResourceInteractionList; Overload;
    function Clone : TFhirConformanceRestResourceInteractionList; Overload;
    function GetEnumerator : TFhirConformanceRestResourceInteractionListEnumerator;
    

    //  Add a FhirConformanceRestResourceInteraction to the end of the list.
    function Append : TFhirConformanceRestResourceInteraction;

    
    // Add an already existing FhirConformanceRestResourceInteraction to the end of the list.
    procedure AddItem(value : TFhirConformanceRestResourceInteraction); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConformanceRestResourceInteraction) : Integer;
    

    // Insert FhirConformanceRestResourceInteraction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConformanceRestResourceInteraction;
    

    // Insert an existing FhirConformanceRestResourceInteraction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConformanceRestResourceInteraction);
    
    // Get the iIndexth FhirConformanceRestResourceInteraction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceRestResourceInteraction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConformanceRestResourceInteraction;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirConformanceRestResourceInteractions[index : Integer] : TFhirConformanceRestResourceInteraction read GetItemN write SetItemN; default;
  End;

  // Search parameters for implementations to support and/or make use of - either references to ones defined in the specification, or additional ones defined for/by the implementation.
  TFhirConformanceRestResourceSearchParam = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FDefinition : TFhirUri;
    FType_ : TFhirEnum;
    FDocumentation : TFhirString;
    FTarget : TFhirEnumList;
    FModifier : TFhirEnumList;
    FchainList : TFhirStringList;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetDefinition(value : TFhirUri);
    Function GetDefinitionST : String;
    Procedure SetDefinitionST(value : String);
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirSearchParamTypeEnum;
    Procedure SetType_ST(value : TFhirSearchParamTypeEnum);
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);
    function GetTarget : TFhirEnumList;
    function GetHasTarget : Boolean;
    function GetModifier : TFhirEnumList;
    function GetHasModifier : Boolean;
    Function GetModifierST : TFhirSearchModifierCodeEnumList;
    Procedure SetModifierST(value : TFhirSearchModifierCodeEnumList);
    function GetChainList : TFhirStringList;
    function GetHasChainList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConformanceRestResourceSearchParam; overload;
    function Clone : TFhirConformanceRestResourceSearchParam; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The name of the search parameter used in the interface.
    property name : String read GetNameST write SetNameST;
    // The name of the search parameter used in the interface.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to An absolute URI that is a formal reference to where this parameter was first defined, so that a client can be confident of the meaning of the search parameter (a reference to [[[SearchParameter.url]]]).
    property definition : String read GetDefinitionST write SetDefinitionST;
    // An absolute URI that is a formal reference to where this parameter was first defined, so that a client can be confident of the meaning of the search parameter (a reference to [[[SearchParameter.url]]]).
    property definitionElement : TFhirUri read FDefinition write SetDefinition;

    // The type of value a search parameter refers to, and how the content is interpreted.
    property type_ : TFhirSearchParamTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to This allows documentation of any distinct behaviors about how the search parameter is used.  For example, text matching algorithms.
    property documentation : String read GetDocumentationST write SetDocumentationST;
    // This allows documentation of any distinct behaviors about how the search parameter is used.  For example, text matching algorithms.
    property documentationElement : TFhirString read FDocumentation write SetDocumentation;

    property target : TFhirEnumList read GetTarget;
    property targetList : TFhirEnumList read GetTarget;
    property hasTarget : boolean read GetHasTarget;
    // A modifier supported for the search parameter.
    property modifier : TFhirSearchModifierCodeEnumList read GetModifierST write SetModifierST;
    property modifierList : TFhirEnumList read GetModifier;
    property hasModifier : boolean read GetHasModifier;
    // Contains the names of any search parameters which may be chained to the containing search parameter. Chained parameters may be added to search parameters of type reference, and specify that resources will only be returned if they contain a reference to a resource which matches the chained parameter value. Values for this field should be drawn from Conformance.rest.resource.searchParam.name on the target resource type.
    property chainList : TFhirStringList read GetChainList;
    property hasChainList : boolean read GetHasChainList;

  end;

  TFhirConformanceRestResourceSearchParamListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConformanceRestResourceSearchParamList;
    function GetCurrent : TFhirConformanceRestResourceSearchParam;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConformanceRestResourceSearchParamList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConformanceRestResourceSearchParam read GetCurrent;
  end;

  TFhirConformanceRestResourceSearchParamList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConformanceRestResourceSearchParam;
    procedure SetItemN(index : Integer; value : TFhirConformanceRestResourceSearchParam);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConformanceRestResourceSearchParamList; Overload;
    function Clone : TFhirConformanceRestResourceSearchParamList; Overload;
    function GetEnumerator : TFhirConformanceRestResourceSearchParamListEnumerator;
    

    //  Add a FhirConformanceRestResourceSearchParam to the end of the list.
    function Append : TFhirConformanceRestResourceSearchParam;

    
    // Add an already existing FhirConformanceRestResourceSearchParam to the end of the list.
    procedure AddItem(value : TFhirConformanceRestResourceSearchParam); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConformanceRestResourceSearchParam) : Integer;
    

    // Insert FhirConformanceRestResourceSearchParam before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConformanceRestResourceSearchParam;
    

    // Insert an existing FhirConformanceRestResourceSearchParam before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConformanceRestResourceSearchParam);
    
    // Get the iIndexth FhirConformanceRestResourceSearchParam. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceRestResourceSearchParam);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConformanceRestResourceSearchParam;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirConformanceRestResourceSearchParams[index : Integer] : TFhirConformanceRestResourceSearchParam read GetItemN write SetItemN; default;
  End;

  // A specification of restful operations supported by the system.
  TFhirConformanceRestInteraction = class (TFhirBackboneElement)
  protected
    FCode : TFhirEnum;
    FDocumentation : TFhirString;
    Procedure SetCode(value : TFhirEnum);
    Function GetCodeST : TFhirSystemRestfulInteractionEnum;
    Procedure SetCodeST(value : TFhirSystemRestfulInteractionEnum);
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConformanceRestInteraction; overload;
    function Clone : TFhirConformanceRestInteraction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A coded identifier of the operation, supported by the system.
    property code : TFhirSystemRestfulInteractionEnum read GetCodeST write SetCodeST;
    property codeElement : TFhirEnum read FCode write SetCode;

    // Typed access to Guidance specific to the implementation of this operation, such as limitations on the kind of transactions allowed, or information about system wide search is implemented.
    property documentation : String read GetDocumentationST write SetDocumentationST;
    // Guidance specific to the implementation of this operation, such as limitations on the kind of transactions allowed, or information about system wide search is implemented.
    property documentationElement : TFhirString read FDocumentation write SetDocumentation;

  end;

  TFhirConformanceRestInteractionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConformanceRestInteractionList;
    function GetCurrent : TFhirConformanceRestInteraction;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConformanceRestInteractionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConformanceRestInteraction read GetCurrent;
  end;

  TFhirConformanceRestInteractionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConformanceRestInteraction;
    procedure SetItemN(index : Integer; value : TFhirConformanceRestInteraction);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConformanceRestInteractionList; Overload;
    function Clone : TFhirConformanceRestInteractionList; Overload;
    function GetEnumerator : TFhirConformanceRestInteractionListEnumerator;
    

    //  Add a FhirConformanceRestInteraction to the end of the list.
    function Append : TFhirConformanceRestInteraction;

    
    // Add an already existing FhirConformanceRestInteraction to the end of the list.
    procedure AddItem(value : TFhirConformanceRestInteraction); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConformanceRestInteraction) : Integer;
    

    // Insert FhirConformanceRestInteraction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConformanceRestInteraction;
    

    // Insert an existing FhirConformanceRestInteraction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConformanceRestInteraction);
    
    // Get the iIndexth FhirConformanceRestInteraction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceRestInteraction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConformanceRestInteraction;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirConformanceRestInteractions[index : Integer] : TFhirConformanceRestInteraction read GetItemN write SetItemN; default;
  End;

  // Definition of an operation or a named query and with its parameters and their meaning and type.
  TFhirConformanceRestOperation = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FDefinition : TFhirReference{TFhirOperationDefinition};
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetDefinition(value : TFhirReference{TFhirOperationDefinition});
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConformanceRestOperation; overload;
    function Clone : TFhirConformanceRestOperation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The name of a query, which is used in the _query parameter when the query is called.
    property name : String read GetNameST write SetNameST;
    // The name of a query, which is used in the _query parameter when the query is called.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Where the formal definition can be found. (defined for API consistency)
    property definition : TFhirReference{TFhirOperationDefinition} read FDefinition write SetDefinition;
    // Where the formal definition can be found.
    property definitionElement : TFhirReference{TFhirOperationDefinition} read FDefinition write SetDefinition;

  end;

  TFhirConformanceRestOperationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConformanceRestOperationList;
    function GetCurrent : TFhirConformanceRestOperation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConformanceRestOperationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConformanceRestOperation read GetCurrent;
  end;

  TFhirConformanceRestOperationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConformanceRestOperation;
    procedure SetItemN(index : Integer; value : TFhirConformanceRestOperation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConformanceRestOperationList; Overload;
    function Clone : TFhirConformanceRestOperationList; Overload;
    function GetEnumerator : TFhirConformanceRestOperationListEnumerator;
    

    //  Add a FhirConformanceRestOperation to the end of the list.
    function Append : TFhirConformanceRestOperation;

    
    // Add an already existing FhirConformanceRestOperation to the end of the list.
    procedure AddItem(value : TFhirConformanceRestOperation); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConformanceRestOperation) : Integer;
    

    // Insert FhirConformanceRestOperation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConformanceRestOperation;
    

    // Insert an existing FhirConformanceRestOperation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConformanceRestOperation);
    
    // Get the iIndexth FhirConformanceRestOperation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceRestOperation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConformanceRestOperation;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirConformanceRestOperations[index : Integer] : TFhirConformanceRestOperation read GetItemN write SetItemN; default;
  End;

  // A description of the messaging capabilities of the solution.
  TFhirConformanceMessaging = class (TFhirBackboneElement)
  protected
    FendpointList : TFhirConformanceMessagingEndpointList;
    FReliableCache : TFhirUnsignedInt;
    FDocumentation : TFhirString;
    FeventList : TFhirConformanceMessagingEventList;
    function GetEndpointList : TFhirConformanceMessagingEndpointList;
    function GetHasEndpointList : Boolean;
    Procedure SetReliableCache(value : TFhirUnsignedInt);
    Function GetReliableCacheST : String;
    Procedure SetReliableCacheST(value : String);
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);
    function GetEventList : TFhirConformanceMessagingEventList;
    function GetHasEventList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConformanceMessaging; overload;
    function Clone : TFhirConformanceMessaging; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // An endpoint (network accessible address) to which messages and/or replies are to be sent.
    property endpointList : TFhirConformanceMessagingEndpointList read GetEndpointList;
    property hasEndpointList : boolean read GetHasEndpointList;

    // Typed access to Length if the receiver's reliable messaging cache in minutes (if a receiver) or how long the cache length on the receiver should be (if a sender).
    property reliableCache : String read GetReliableCacheST write SetReliableCacheST;
    // Length if the receiver's reliable messaging cache in minutes (if a receiver) or how long the cache length on the receiver should be (if a sender).
    property reliableCacheElement : TFhirUnsignedInt read FReliableCache write SetReliableCache;

    // Typed access to Documentation about the system's messaging capabilities for this endpoint not otherwise documented by the conformance statement.  For example, process for becoming an authorized messaging exchange partner.
    property documentation : String read GetDocumentationST write SetDocumentationST;
    // Documentation about the system's messaging capabilities for this endpoint not otherwise documented by the conformance statement.  For example, process for becoming an authorized messaging exchange partner.
    property documentationElement : TFhirString read FDocumentation write SetDocumentation;

    // A description of the solution's support for an event at this end-point.
    property eventList : TFhirConformanceMessagingEventList read GetEventList;
    property hasEventList : boolean read GetHasEventList;

  end;

  TFhirConformanceMessagingListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConformanceMessagingList;
    function GetCurrent : TFhirConformanceMessaging;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConformanceMessagingList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConformanceMessaging read GetCurrent;
  end;

  TFhirConformanceMessagingList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConformanceMessaging;
    procedure SetItemN(index : Integer; value : TFhirConformanceMessaging);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConformanceMessagingList; Overload;
    function Clone : TFhirConformanceMessagingList; Overload;
    function GetEnumerator : TFhirConformanceMessagingListEnumerator;
    

    //  Add a FhirConformanceMessaging to the end of the list.
    function Append : TFhirConformanceMessaging;

    
    // Add an already existing FhirConformanceMessaging to the end of the list.
    procedure AddItem(value : TFhirConformanceMessaging); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConformanceMessaging) : Integer;
    

    // Insert FhirConformanceMessaging before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConformanceMessaging;
    

    // Insert an existing FhirConformanceMessaging before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConformanceMessaging);
    
    // Get the iIndexth FhirConformanceMessaging. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceMessaging);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConformanceMessaging;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirConformanceMessagings[index : Integer] : TFhirConformanceMessaging read GetItemN write SetItemN; default;
  End;

  // An endpoint (network accessible address) to which messages and/or replies are to be sent.
  TFhirConformanceMessagingEndpoint = class (TFhirBackboneElement)
  protected
    FProtocol : TFhirCoding;
    FAddress : TFhirUri;
    Procedure SetProtocol(value : TFhirCoding);
    Procedure SetAddress(value : TFhirUri);
    Function GetAddressST : String;
    Procedure SetAddressST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConformanceMessagingEndpoint; overload;
    function Clone : TFhirConformanceMessagingEndpoint; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A list of the messaging transport protocol(s) identifiers, supported by this endpoint. (defined for API consistency)
    property protocol : TFhirCoding read FProtocol write SetProtocol;
    // A list of the messaging transport protocol(s) identifiers, supported by this endpoint.
    property protocolElement : TFhirCoding read FProtocol write SetProtocol;

    // Typed access to The network address of the end-point. For solutions that do not use network addresses for routing, it can be just an identifier.
    property address : String read GetAddressST write SetAddressST;
    // The network address of the end-point. For solutions that do not use network addresses for routing, it can be just an identifier.
    property addressElement : TFhirUri read FAddress write SetAddress;

  end;

  TFhirConformanceMessagingEndpointListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConformanceMessagingEndpointList;
    function GetCurrent : TFhirConformanceMessagingEndpoint;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConformanceMessagingEndpointList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConformanceMessagingEndpoint read GetCurrent;
  end;

  TFhirConformanceMessagingEndpointList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConformanceMessagingEndpoint;
    procedure SetItemN(index : Integer; value : TFhirConformanceMessagingEndpoint);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConformanceMessagingEndpointList; Overload;
    function Clone : TFhirConformanceMessagingEndpointList; Overload;
    function GetEnumerator : TFhirConformanceMessagingEndpointListEnumerator;
    

    //  Add a FhirConformanceMessagingEndpoint to the end of the list.
    function Append : TFhirConformanceMessagingEndpoint;

    
    // Add an already existing FhirConformanceMessagingEndpoint to the end of the list.
    procedure AddItem(value : TFhirConformanceMessagingEndpoint); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConformanceMessagingEndpoint) : Integer;
    

    // Insert FhirConformanceMessagingEndpoint before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConformanceMessagingEndpoint;
    

    // Insert an existing FhirConformanceMessagingEndpoint before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConformanceMessagingEndpoint);
    
    // Get the iIndexth FhirConformanceMessagingEndpoint. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceMessagingEndpoint);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConformanceMessagingEndpoint;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirConformanceMessagingEndpoints[index : Integer] : TFhirConformanceMessagingEndpoint read GetItemN write SetItemN; default;
  End;

  // A description of the solution's support for an event at this end-point.
  TFhirConformanceMessagingEvent = class (TFhirBackboneElement)
  protected
    FCode : TFhirCoding;
    FCategory : TFhirEnum;
    FMode : TFhirEnum;
    FFocus : TFhirEnum;
    FRequest : TFhirReference{TFhirStructureDefinition};
    FResponse : TFhirReference{TFhirStructureDefinition};
    FDocumentation : TFhirString;
    Procedure SetCode(value : TFhirCoding);
    Procedure SetCategory(value : TFhirEnum);
    Function GetCategoryST : TFhirMessageSignificanceCategoryEnum;
    Procedure SetCategoryST(value : TFhirMessageSignificanceCategoryEnum);
    Procedure SetMode(value : TFhirEnum);
    Function GetModeST : TFhirMessageConformanceEventModeEnum;
    Procedure SetModeST(value : TFhirMessageConformanceEventModeEnum);
    Procedure SetFocus(value : TFhirEnum);
    Function GetFocusST : TFhirResourceTypesEnum;
    Procedure SetFocusST(value : TFhirResourceTypesEnum);
    Procedure SetRequest(value : TFhirReference{TFhirStructureDefinition});
    Procedure SetResponse(value : TFhirReference{TFhirStructureDefinition});
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConformanceMessagingEvent; overload;
    function Clone : TFhirConformanceMessagingEvent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A coded identifier of a supported messaging event. (defined for API consistency)
    property code : TFhirCoding read FCode write SetCode;
    // A coded identifier of a supported messaging event.
    property codeElement : TFhirCoding read FCode write SetCode;

    // The impact of the content of the message.
    property category : TFhirMessageSignificanceCategoryEnum read GetCategoryST write SetCategoryST;
    property categoryElement : TFhirEnum read FCategory write SetCategory;

    // The mode of this event declaration - whether application is sender or receiver.
    property mode : TFhirMessageConformanceEventModeEnum read GetModeST write SetModeST;
    property modeElement : TFhirEnum read FMode write SetMode;

    // A resource associated with the event.  This is the resource that defines the event.
    property focus : TFhirResourceTypesEnum read GetFocusST write SetFocusST;
    property focusElement : TFhirEnum read FFocus write SetFocus;

    // Typed access to Information about the request for this event. (defined for API consistency)
    property request : TFhirReference{TFhirStructureDefinition} read FRequest write SetRequest;
    // Information about the request for this event.
    property requestElement : TFhirReference{TFhirStructureDefinition} read FRequest write SetRequest;

    // Typed access to Information about the response for this event. (defined for API consistency)
    property response : TFhirReference{TFhirStructureDefinition} read FResponse write SetResponse;
    // Information about the response for this event.
    property responseElement : TFhirReference{TFhirStructureDefinition} read FResponse write SetResponse;

    // Typed access to Guidance on how this event is handled, such as internal system trigger points, business rules, etc.
    property documentation : String read GetDocumentationST write SetDocumentationST;
    // Guidance on how this event is handled, such as internal system trigger points, business rules, etc.
    property documentationElement : TFhirString read FDocumentation write SetDocumentation;

  end;

  TFhirConformanceMessagingEventListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConformanceMessagingEventList;
    function GetCurrent : TFhirConformanceMessagingEvent;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConformanceMessagingEventList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConformanceMessagingEvent read GetCurrent;
  end;

  TFhirConformanceMessagingEventList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConformanceMessagingEvent;
    procedure SetItemN(index : Integer; value : TFhirConformanceMessagingEvent);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConformanceMessagingEventList; Overload;
    function Clone : TFhirConformanceMessagingEventList; Overload;
    function GetEnumerator : TFhirConformanceMessagingEventListEnumerator;
    

    //  Add a FhirConformanceMessagingEvent to the end of the list.
    function Append : TFhirConformanceMessagingEvent;

    
    // Add an already existing FhirConformanceMessagingEvent to the end of the list.
    procedure AddItem(value : TFhirConformanceMessagingEvent); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConformanceMessagingEvent) : Integer;
    

    // Insert FhirConformanceMessagingEvent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConformanceMessagingEvent;
    

    // Insert an existing FhirConformanceMessagingEvent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConformanceMessagingEvent);
    
    // Get the iIndexth FhirConformanceMessagingEvent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceMessagingEvent);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConformanceMessagingEvent;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirConformanceMessagingEvents[index : Integer] : TFhirConformanceMessagingEvent read GetItemN write SetItemN; default;
  End;

  // A document definition.
  TFhirConformanceDocument = class (TFhirBackboneElement)
  protected
    FMode : TFhirEnum;
    FDocumentation : TFhirString;
    FProfile : TFhirReference{TFhirStructureDefinition};
    Procedure SetMode(value : TFhirEnum);
    Function GetModeST : TFhirDocumentModeEnum;
    Procedure SetModeST(value : TFhirDocumentModeEnum);
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);
    Procedure SetProfile(value : TFhirReference{TFhirStructureDefinition});
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConformanceDocument; overload;
    function Clone : TFhirConformanceDocument; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Mode of this document declaration - whether application is producer or consumer.
    property mode : TFhirDocumentModeEnum read GetModeST write SetModeST;
    property modeElement : TFhirEnum read FMode write SetMode;

    // Typed access to A description of how the application supports or uses the specified document profile.  For example, when are documents created, what action is taken with consumed documents, etc.
    property documentation : String read GetDocumentationST write SetDocumentationST;
    // A description of how the application supports or uses the specified document profile.  For example, when are documents created, what action is taken with consumed documents, etc.
    property documentationElement : TFhirString read FDocumentation write SetDocumentation;

    // Typed access to A constraint on a resource used in the document. (defined for API consistency)
    property profile : TFhirReference{TFhirStructureDefinition} read FProfile write SetProfile;
    // A constraint on a resource used in the document.
    property profileElement : TFhirReference{TFhirStructureDefinition} read FProfile write SetProfile;

  end;

  TFhirConformanceDocumentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConformanceDocumentList;
    function GetCurrent : TFhirConformanceDocument;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConformanceDocumentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConformanceDocument read GetCurrent;
  end;

  TFhirConformanceDocumentList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConformanceDocument;
    procedure SetItemN(index : Integer; value : TFhirConformanceDocument);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConformanceDocumentList; Overload;
    function Clone : TFhirConformanceDocumentList; Overload;
    function GetEnumerator : TFhirConformanceDocumentListEnumerator;
    

    //  Add a FhirConformanceDocument to the end of the list.
    function Append : TFhirConformanceDocument;

    
    // Add an already existing FhirConformanceDocument to the end of the list.
    procedure AddItem(value : TFhirConformanceDocument); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConformanceDocument) : Integer;
    

    // Insert FhirConformanceDocument before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConformanceDocument;
    

    // Insert an existing FhirConformanceDocument before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConformanceDocument);
    
    // Get the iIndexth FhirConformanceDocument. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConformanceDocument);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConformanceDocument;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirConformanceDocuments[index : Integer] : TFhirConformanceDocument read GetItemN write SetItemN; default;
  End;

  // A conformance statement is a set of capabilities of a FHIR Server that may be used as a statement of actual server functionality or a statement of required or desired server implementation.
  TFhirConformance = class (TFhirDomainResource)
  protected
    FUrl : TFhirUri;
    FVersion : TFhirString;
    FName : TFhirString;
    FStatus : TFhirEnum;
    FExperimental : TFhirBoolean;
    FPublisher : TFhirString;
    FcontactList : TFhirConformanceContactList;
    FDate : TFhirDateTime;
    FDescription : TFhirString;
    FRequirements : TFhirString;
    FCopyright : TFhirString;
    FKind : TFhirEnum;
    FSoftware : TFhirConformanceSoftware;
    FImplementation_ : TFhirConformanceImplementation;
    FFhirVersion : TFhirId;
    FAcceptUnknown : TFhirEnum;
    FformatList : TFhirCodeList;
    FprofileList : TFhirReferenceList{TFhirStructureDefinition};
    FrestList : TFhirConformanceRestList;
    FmessagingList : TFhirConformanceMessagingList;
    FdocumentList : TFhirConformanceDocumentList;
    Procedure SetUrl(value : TFhirUri);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);
    Procedure SetVersion(value : TFhirString);
    Function GetVersionST : String;
    Procedure SetVersionST(value : String);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirConformanceResourceStatusEnum;
    Procedure SetStatusST(value : TFhirConformanceResourceStatusEnum);
    Procedure SetExperimental(value : TFhirBoolean);
    Function GetExperimentalST : Boolean;
    Procedure SetExperimentalST(value : Boolean);
    Procedure SetPublisher(value : TFhirString);
    Function GetPublisherST : String;
    Procedure SetPublisherST(value : String);
    function GetContactList : TFhirConformanceContactList;
    function GetHasContactList : Boolean;
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetRequirements(value : TFhirString);
    Function GetRequirementsST : String;
    Procedure SetRequirementsST(value : String);
    Procedure SetCopyright(value : TFhirString);
    Function GetCopyrightST : String;
    Procedure SetCopyrightST(value : String);
    Procedure SetKind(value : TFhirEnum);
    Function GetKindST : TFhirConformanceStatementKindEnum;
    Procedure SetKindST(value : TFhirConformanceStatementKindEnum);
    Procedure SetSoftware(value : TFhirConformanceSoftware);
    Procedure SetImplementation_(value : TFhirConformanceImplementation);
    Procedure SetFhirVersion(value : TFhirId);
    Function GetFhirVersionST : String;
    Procedure SetFhirVersionST(value : String);
    Procedure SetAcceptUnknown(value : TFhirEnum);
    Function GetAcceptUnknownST : TFhirUnknownContentCodeEnum;
    Procedure SetAcceptUnknownST(value : TFhirUnknownContentCodeEnum);
    function GetFormatList : TFhirCodeList;
    function GetHasFormatList : Boolean;
    function GetProfileList : TFhirReferenceList{TFhirStructureDefinition};
    function GetHasProfileList : Boolean;
    function GetRestList : TFhirConformanceRestList;
    function GetHasRestList : Boolean;
    function GetMessagingList : TFhirConformanceMessagingList;
    function GetHasMessagingList : Boolean;
    function GetDocumentList : TFhirConformanceDocumentList;
    function GetHasDocumentList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConformance; overload;
    function Clone : TFhirConformance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URL that is used to identify this conformance statement when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this conformance statement is (or will be) {$IFNDEF FPC}published{$ENDIF}.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URL that is used to identify this conformance statement when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this conformance statement is (or will be) {$IFNDEF FPC}published{$ENDIF}.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to The identifier that is used to identify this version of the conformance statement when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the profile author manually and the value should be a timestamp.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the conformance statement when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the profile author manually and the value should be a timestamp.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A free text natural language name identifying the conformance statement.
    property name : String read GetNameST write SetNameST;
    // A free text natural language name identifying the conformance statement.
    property nameElement : TFhirString read FName write SetName;

    // The status of this conformance statement.
    property status : TFhirConformanceResourceStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A flag to indicate that this conformance statement is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A flag to indicate that this conformance statement is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The name of the individual or organization that {$IFNDEF FPC}published{$ENDIF} the conformance.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the individual or organization that {$IFNDEF FPC}published{$ENDIF} the conformance.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contacts to assist a user in finding and communicating with the publisher.
    property contactList : TFhirConformanceContactList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to The date  (and optionally time) when the conformance statement was {$IFNDEF FPC}published{$ENDIF}. The date must change when the business version changes, if it does, and it must change if the status code changes. In addition, it should change when the substantive content of the conformance statement changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the conformance statement was {$IFNDEF FPC}published{$ENDIF}. The date must change when the business version changes, if it does, and it must change if the status code changes. In addition, it should change when the substantive content of the conformance statement changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to A free text natural language description of the conformance statement and its use. Typically, this is used when the conformance statement describes a desired rather than an actual solution, for example as a formal expression of requirements as part of an RFP.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the conformance statement and its use. Typically, this is used when the conformance statement describes a desired rather than an actual solution, for example as a formal expression of requirements as part of an RFP.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Explains why this conformance statement is needed and why it's been constrained as it has.
    property requirements : String read GetRequirementsST write SetRequirementsST;
    // Explains why this conformance statement is needed and why it's been constrained as it has.
    property requirementsElement : TFhirString read FRequirements write SetRequirements;

    // Typed access to A copyright statement relating to the conformance statement and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the details of the system described by the conformance statement.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the conformance statement and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the details of the system described by the conformance statement.
    property copyrightElement : TFhirString read FCopyright write SetCopyright;

    // The way that this statement is intended to be used, to describe an actual running instance of software, a particular product (kind not instance of software) or a class of implementation (e.g. a desired purchase).
    property kind : TFhirConformanceStatementKindEnum read GetKindST write SetKindST;
    property kindElement : TFhirEnum read FKind write SetKind;

    // Typed access to Software that is covered by this conformance statement.  It is used when the conformance statement describes the capabilities of a particular software version, independent of an installation. (defined for API consistency)
    property software : TFhirConformanceSoftware read FSoftware write SetSoftware;
    // Software that is covered by this conformance statement.  It is used when the conformance statement describes the capabilities of a particular software version, independent of an installation.
    property softwareElement : TFhirConformanceSoftware read FSoftware write SetSoftware;

    // Typed access to Identifies a specific implementation instance that is described by the conformance statement - i.e. a particular installation, rather than the capabilities of a software program. (defined for API consistency)
    property implementation_ : TFhirConformanceImplementation read FImplementation_ write SetImplementation_;
    // Identifies a specific implementation instance that is described by the conformance statement - i.e. a particular installation, rather than the capabilities of a software program.
    property implementation_Element : TFhirConformanceImplementation read FImplementation_ write SetImplementation_;

    // Typed access to The version of the FHIR specification on which this conformance statement is based.
    property fhirVersion : String read GetFhirVersionST write SetFhirVersionST;
    // The version of the FHIR specification on which this conformance statement is based.
    property fhirVersionElement : TFhirId read FFhirVersion write SetFhirVersion;

    // A code that indicates whether the application accepts unknown elements or extensions when reading resources.
    property acceptUnknown : TFhirUnknownContentCodeEnum read GetAcceptUnknownST write SetAcceptUnknownST;
    property acceptUnknownElement : TFhirEnum read FAcceptUnknown write SetAcceptUnknown;

    // A list of the formats supported by this implementation using their content types.
    property formatList : TFhirCodeList read GetFormatList;
    property hasFormatList : boolean read GetHasFormatList;

    // A list of profiles that represent different use cases supported by the system. For a server, "supported by the system" means the system hosts/produces a set of resources that are conformant to a particular profile, and allows clients that use its services to search using this profile and to find appropriate data. For a client, it means the system will search by this profile and process data according to the guidance implicit in the profile. See further discussion in [Using Profiles].
    property profileList : TFhirReferenceList{TFhirStructureDefinition} read GetProfileList;
    property hasProfileList : boolean read GetHasProfileList;

    // A definition of the restful capabilities of the solution, if any.
    property restList : TFhirConformanceRestList read GetRestList;
    property hasRestList : boolean read GetHasRestList;

    // A description of the messaging capabilities of the solution.
    property messagingList : TFhirConformanceMessagingList read GetMessagingList;
    property hasMessagingList : boolean read GetHasMessagingList;

    // A document definition.
    property documentList : TFhirConformanceDocumentList read GetDocumentList;
    property hasDocumentList : boolean read GetHasDocumentList;

  end;

  TFhirConformanceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConformanceList;
    function GetCurrent : TFhirConformance;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConformanceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConformance read GetCurrent;
  end;

  TFhirConformanceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConformance;
    procedure SetItemN(index : Integer; value : TFhirConformance);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConformanceList; Overload;
    function Clone : TFhirConformanceList; Overload;
    function GetEnumerator : TFhirConformanceListEnumerator;
    

    //  Add a FhirConformance to the end of the list.
    function Append : TFhirConformance;

    
    // Add an already existing FhirConformance to the end of the list.
    procedure AddItem(value : TFhirConformance); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConformance) : Integer;
    

    // Insert FhirConformance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConformance;
    

    // Insert an existing FhirConformance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConformance);
    
    // Get the iIndexth FhirConformance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConformance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConformance;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirConformances[index : Integer] : TFhirConformance read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CONFORMANCE}

{$IFDEF FHIR_DATAELEMENT}

  // Contacts to assist a user in finding and communicating with the publisher.
  TFhirDataElementContact = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FtelecomList : TFhirContactPointList;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDataElementContact; overload;
    function Clone : TFhirDataElementContact; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The name of an individual to contact regarding the data element.
    property name : String read GetNameST write SetNameST;
    // The name of an individual to contact regarding the data element.
    property nameElement : TFhirString read FName write SetName;

    // Contact details for individual (if a name was provided) or the publisher.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

  end;

  TFhirDataElementContactListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDataElementContactList;
    function GetCurrent : TFhirDataElementContact;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDataElementContactList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDataElementContact read GetCurrent;
  end;

  TFhirDataElementContactList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDataElementContact;
    procedure SetItemN(index : Integer; value : TFhirDataElementContact);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDataElementContactList; Overload;
    function Clone : TFhirDataElementContactList; Overload;
    function GetEnumerator : TFhirDataElementContactListEnumerator;
    

    //  Add a FhirDataElementContact to the end of the list.
    function Append : TFhirDataElementContact;

    
    // Add an already existing FhirDataElementContact to the end of the list.
    procedure AddItem(value : TFhirDataElementContact); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDataElementContact) : Integer;
    

    // Insert FhirDataElementContact before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDataElementContact;
    

    // Insert an existing FhirDataElementContact before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDataElementContact);
    
    // Get the iIndexth FhirDataElementContact. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDataElementContact);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDataElementContact;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirDataElementContacts[index : Integer] : TFhirDataElementContact read GetItemN write SetItemN; default;
  End;

  // Identifies a specification (other than a terminology) that the elements which make up the DataElement have some correspondence with.
  TFhirDataElementMapping = class (TFhirBackboneElement)
  protected
    FIdentity : TFhirId;
    FUri : TFhirUri;
    FName : TFhirString;
    FComments : TFhirString;
    Procedure SetIdentity(value : TFhirId);
    Function GetIdentityST : String;
    Procedure SetIdentityST(value : String);
    Procedure SetUri(value : TFhirUri);
    Function GetUriST : String;
    Procedure SetUriST(value : String);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetComments(value : TFhirString);
    Function GetCommentsST : String;
    Procedure SetCommentsST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDataElementMapping; overload;
    function Clone : TFhirDataElementMapping; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An internal id that is used to identify this mapping set when specific mappings are made on a per-element basis.
    property identity : String read GetIdentityST write SetIdentityST;
    // An internal id that is used to identify this mapping set when specific mappings are made on a per-element basis.
    property identityElement : TFhirId read FIdentity write SetIdentity;

    // Typed access to An absolute URI that identifies the specification that this mapping is expressed to.
    property uri : String read GetUriST write SetUriST;
    // An absolute URI that identifies the specification that this mapping is expressed to.
    property uriElement : TFhirUri read FUri write SetUri;

    // Typed access to A name for the specification that is being mapped to.
    property name : String read GetNameST write SetNameST;
    // A name for the specification that is being mapped to.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Comments about this mapping, including version notes, issues, scope limitations, and other important notes for usage.
    property comments : String read GetCommentsST write SetCommentsST;
    // Comments about this mapping, including version notes, issues, scope limitations, and other important notes for usage.
    property commentsElement : TFhirString read FComments write SetComments;

  end;

  TFhirDataElementMappingListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDataElementMappingList;
    function GetCurrent : TFhirDataElementMapping;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDataElementMappingList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDataElementMapping read GetCurrent;
  end;

  TFhirDataElementMappingList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDataElementMapping;
    procedure SetItemN(index : Integer; value : TFhirDataElementMapping);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDataElementMappingList; Overload;
    function Clone : TFhirDataElementMappingList; Overload;
    function GetEnumerator : TFhirDataElementMappingListEnumerator;
    

    //  Add a FhirDataElementMapping to the end of the list.
    function Append : TFhirDataElementMapping;

    
    // Add an already existing FhirDataElementMapping to the end of the list.
    procedure AddItem(value : TFhirDataElementMapping); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDataElementMapping) : Integer;
    

    // Insert FhirDataElementMapping before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDataElementMapping;
    

    // Insert an existing FhirDataElementMapping before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDataElementMapping);
    
    // Get the iIndexth FhirDataElementMapping. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDataElementMapping);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDataElementMapping;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirDataElementMappings[index : Integer] : TFhirDataElementMapping read GetItemN write SetItemN; default;
  End;

  // The formal description of a single piece of information that can be gathered and reported.
  TFhirDataElement = class (TFhirDomainResource)
  protected
    FUrl : TFhirUri;
    FidentifierList : TFhirIdentifierList;
    FVersion : TFhirString;
    FName : TFhirString;
    FStatus : TFhirEnum;
    FExperimental : TFhirBoolean;
    FPublisher : TFhirString;
    FcontactList : TFhirDataElementContactList;
    FDate : TFhirDateTime;
    FuseContextList : TFhirCodeableConceptList;
    FCopyright : TFhirString;
    FStringency : TFhirEnum;
    FmappingList : TFhirDataElementMappingList;
    FelementList : TFhirElementDefinitionList;
    Procedure SetUrl(value : TFhirUri);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetVersion(value : TFhirString);
    Function GetVersionST : String;
    Procedure SetVersionST(value : String);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirConformanceResourceStatusEnum;
    Procedure SetStatusST(value : TFhirConformanceResourceStatusEnum);
    Procedure SetExperimental(value : TFhirBoolean);
    Function GetExperimentalST : Boolean;
    Procedure SetExperimentalST(value : Boolean);
    Procedure SetPublisher(value : TFhirString);
    Function GetPublisherST : String;
    Procedure SetPublisherST(value : String);
    function GetContactList : TFhirDataElementContactList;
    function GetHasContactList : Boolean;
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    function GetUseContextList : TFhirCodeableConceptList;
    function GetHasUseContextList : Boolean;
    Procedure SetCopyright(value : TFhirString);
    Function GetCopyrightST : String;
    Procedure SetCopyrightST(value : String);
    Procedure SetStringency(value : TFhirEnum);
    Function GetStringencyST : TFhirDataelementStringencyEnum;
    Procedure SetStringencyST(value : TFhirDataelementStringencyEnum);
    function GetMappingList : TFhirDataElementMappingList;
    function GetHasMappingList : Boolean;
    function GetElementList : TFhirElementDefinitionList;
    function GetHasElementList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDataElement; overload;
    function Clone : TFhirDataElement; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URL that is used to identify this data element when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this data element is (or will be) {$IFNDEF FPC}published{$ENDIF}.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URL that is used to identify this data element when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this data element is (or will be) {$IFNDEF FPC}published{$ENDIF}.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Formal identifier that is used to identify this data element when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier that is used to identify this version of the data element when it is referenced in a StructureDefinition, Questionnaire or instance. This is an arbitrary value managed by the definition author manually.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the data element when it is referenced in a StructureDefinition, Questionnaire or instance. This is an arbitrary value managed by the definition author manually.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to The term used by humans to refer to the data element.  Should ideally be unique within the context in which the data element is expected to be used.
    property name : String read GetNameST write SetNameST;
    // The term used by humans to refer to the data element.  Should ideally be unique within the context in which the data element is expected to be used.
    property nameElement : TFhirString read FName write SetName;

    // The status of the data element.
    property status : TFhirConformanceResourceStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A flag to indicate that this search data element definition is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A flag to indicate that this search data element definition is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The name of the individual or organization that {$IFNDEF FPC}published{$ENDIF} the data element.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the individual or organization that {$IFNDEF FPC}published{$ENDIF} the data element.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contacts to assist a user in finding and communicating with the publisher.
    property contactList : TFhirDataElementContactList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to The date this version of the data element was {$IFNDEF FPC}published{$ENDIF}. The date must change when the business version changes, if it does, and it must change if the status code changes. In addition, it should change when the substantive content of the data element  changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date this version of the data element was {$IFNDEF FPC}published{$ENDIF}. The date must change when the business version changes, if it does, and it must change if the status code changes. In addition, it should change when the substantive content of the data element  changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These terms may be used to assist with indexing and searching of data element definitions.
    property useContextList : TFhirCodeableConceptList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // Typed access to A copyright statement relating to the definition of the data element. Copyright statements are generally legal restrictions on the use and publishing of the details of the definition of the data element.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the definition of the data element. Copyright statements are generally legal restrictions on the use and publishing of the details of the definition of the data element.
    property copyrightElement : TFhirString read FCopyright write SetCopyright;

    // Identifies how precise the data element is in its definition.
    property stringency : TFhirDataelementStringencyEnum read GetStringencyST write SetStringencyST;
    property stringencyElement : TFhirEnum read FStringency write SetStringency;

    // Identifies a specification (other than a terminology) that the elements which make up the DataElement have some correspondence with.
    property mappingList : TFhirDataElementMappingList read GetMappingList;
    property hasMappingList : boolean read GetHasMappingList;

    // Defines the structure, type, allowed values and other constraining characteristics of the data element.
    property elementList : TFhirElementDefinitionList read GetElementList;
    property hasElementList : boolean read GetHasElementList;

  end;

  TFhirDataElementListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDataElementList;
    function GetCurrent : TFhirDataElement;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDataElementList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDataElement read GetCurrent;
  end;

  TFhirDataElementList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDataElement;
    procedure SetItemN(index : Integer; value : TFhirDataElement);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDataElementList; Overload;
    function Clone : TFhirDataElementList; Overload;
    function GetEnumerator : TFhirDataElementListEnumerator;
    

    //  Add a FhirDataElement to the end of the list.
    function Append : TFhirDataElement;

    
    // Add an already existing FhirDataElement to the end of the list.
    procedure AddItem(value : TFhirDataElement); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDataElement) : Integer;
    

    // Insert FhirDataElement before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDataElement;
    

    // Insert an existing FhirDataElement before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDataElement);
    
    // Get the iIndexth FhirDataElement. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDataElement);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDataElement;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirDataElements[index : Integer] : TFhirDataElement read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_DATAELEMENT}

{$IFDEF FHIR_IMPLEMENTATIONGUIDE}

  // Contacts to assist a user in finding and communicating with the publisher.
  TFhirImplementationGuideContact = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FtelecomList : TFhirContactPointList;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImplementationGuideContact; overload;
    function Clone : TFhirImplementationGuideContact; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The name of an individual to contact regarding the implementation guide.
    property name : String read GetNameST write SetNameST;
    // The name of an individual to contact regarding the implementation guide.
    property nameElement : TFhirString read FName write SetName;

    // Contact details for individual (if a name was provided) or the publisher.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

  end;

  TFhirImplementationGuideContactListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImplementationGuideContactList;
    function GetCurrent : TFhirImplementationGuideContact;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImplementationGuideContactList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImplementationGuideContact read GetCurrent;
  end;

  TFhirImplementationGuideContactList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImplementationGuideContact;
    procedure SetItemN(index : Integer; value : TFhirImplementationGuideContact);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImplementationGuideContactList; Overload;
    function Clone : TFhirImplementationGuideContactList; Overload;
    function GetEnumerator : TFhirImplementationGuideContactListEnumerator;
    

    //  Add a FhirImplementationGuideContact to the end of the list.
    function Append : TFhirImplementationGuideContact;

    
    // Add an already existing FhirImplementationGuideContact to the end of the list.
    procedure AddItem(value : TFhirImplementationGuideContact); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImplementationGuideContact) : Integer;
    

    // Insert FhirImplementationGuideContact before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImplementationGuideContact;
    

    // Insert an existing FhirImplementationGuideContact before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImplementationGuideContact);
    
    // Get the iIndexth FhirImplementationGuideContact. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImplementationGuideContact);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImplementationGuideContact;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirImplementationGuideContacts[index : Integer] : TFhirImplementationGuideContact read GetItemN write SetItemN; default;
  End;

  // Another implementation guide that this implementation depends on. Typically, an implementation guide uses value sets, profiles etc.defined in other implementation guides.
  TFhirImplementationGuideDependency = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FUri : TFhirUri;
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirGuideDependencyTypeEnum;
    Procedure SetType_ST(value : TFhirGuideDependencyTypeEnum);
    Procedure SetUri(value : TFhirUri);
    Function GetUriST : String;
    Procedure SetUriST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImplementationGuideDependency; overload;
    function Clone : TFhirImplementationGuideDependency; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // How the dependency is represented when the guide is {$IFNDEF FPC}published{$ENDIF}.
    property type_ : TFhirGuideDependencyTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to Where the dependency is located.
    property uri : String read GetUriST write SetUriST;
    // Where the dependency is located.
    property uriElement : TFhirUri read FUri write SetUri;

  end;

  TFhirImplementationGuideDependencyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImplementationGuideDependencyList;
    function GetCurrent : TFhirImplementationGuideDependency;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImplementationGuideDependencyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImplementationGuideDependency read GetCurrent;
  end;

  TFhirImplementationGuideDependencyList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImplementationGuideDependency;
    procedure SetItemN(index : Integer; value : TFhirImplementationGuideDependency);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImplementationGuideDependencyList; Overload;
    function Clone : TFhirImplementationGuideDependencyList; Overload;
    function GetEnumerator : TFhirImplementationGuideDependencyListEnumerator;
    

    //  Add a FhirImplementationGuideDependency to the end of the list.
    function Append : TFhirImplementationGuideDependency;

    
    // Add an already existing FhirImplementationGuideDependency to the end of the list.
    procedure AddItem(value : TFhirImplementationGuideDependency); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImplementationGuideDependency) : Integer;
    

    // Insert FhirImplementationGuideDependency before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImplementationGuideDependency;
    

    // Insert an existing FhirImplementationGuideDependency before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImplementationGuideDependency);
    
    // Get the iIndexth FhirImplementationGuideDependency. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImplementationGuideDependency);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImplementationGuideDependency;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirImplementationGuideDependencies[index : Integer] : TFhirImplementationGuideDependency read GetItemN write SetItemN; default;
  End;

  // A logical group of resources. Logical groups can be used when building pages.
  TFhirImplementationGuidePackage = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FDescription : TFhirString;
    FresourceList : TFhirImplementationGuidePackageResourceList;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    function GetResourceList : TFhirImplementationGuidePackageResourceList;
    function GetHasResourceList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImplementationGuidePackage; overload;
    function Clone : TFhirImplementationGuidePackage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The name for the group, as used in page.package.
    property name : String read GetNameST write SetNameST;
    // The name for the group, as used in page.package.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Human readable text describing the package.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Human readable text describing the package.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // A resource that is part of the implementation guide. Conformance resources (value set, structure definition, conformance statements etc.) are obvious candidates for inclusion, but any kind of resource can be included as an example resource.
    property resourceList : TFhirImplementationGuidePackageResourceList read GetResourceList;
    property hasResourceList : boolean read GetHasResourceList;

  end;

  TFhirImplementationGuidePackageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImplementationGuidePackageList;
    function GetCurrent : TFhirImplementationGuidePackage;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImplementationGuidePackageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImplementationGuidePackage read GetCurrent;
  end;

  TFhirImplementationGuidePackageList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImplementationGuidePackage;
    procedure SetItemN(index : Integer; value : TFhirImplementationGuidePackage);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImplementationGuidePackageList; Overload;
    function Clone : TFhirImplementationGuidePackageList; Overload;
    function GetEnumerator : TFhirImplementationGuidePackageListEnumerator;
    

    //  Add a FhirImplementationGuidePackage to the end of the list.
    function Append : TFhirImplementationGuidePackage;

    
    // Add an already existing FhirImplementationGuidePackage to the end of the list.
    procedure AddItem(value : TFhirImplementationGuidePackage); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImplementationGuidePackage) : Integer;
    

    // Insert FhirImplementationGuidePackage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImplementationGuidePackage;
    

    // Insert an existing FhirImplementationGuidePackage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImplementationGuidePackage);
    
    // Get the iIndexth FhirImplementationGuidePackage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImplementationGuidePackage);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImplementationGuidePackage;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirImplementationGuidePackages[index : Integer] : TFhirImplementationGuidePackage read GetItemN write SetItemN; default;
  End;

  // A resource that is part of the implementation guide. Conformance resources (value set, structure definition, conformance statements etc.) are obvious candidates for inclusion, but any kind of resource can be included as an example resource.
  TFhirImplementationGuidePackageResource = class (TFhirBackboneElement)
  protected
    FPurpose : TFhirEnum;
    FName : TFhirString;
    FDescription : TFhirString;
    FAcronym : TFhirString;
    FSource : TFhirType;
    FExampleFor : TFhirReference{TFhirStructureDefinition};
    Procedure SetPurpose(value : TFhirEnum);
    Function GetPurposeST : TFhirGuideResourcePurposeEnum;
    Procedure SetPurposeST(value : TFhirGuideResourcePurposeEnum);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetAcronym(value : TFhirString);
    Function GetAcronymST : String;
    Procedure SetAcronymST(value : String);
    Procedure SetSource(value : TFhirType);
    Procedure SetExampleFor(value : TFhirReference{TFhirStructureDefinition});
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImplementationGuidePackageResource; overload;
    function Clone : TFhirImplementationGuidePackageResource; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Why the resource is included in the guide.
    property purpose : TFhirGuideResourcePurposeEnum read GetPurposeST write SetPurposeST;
    property purposeElement : TFhirEnum read FPurpose write SetPurpose;

    // Typed access to A human assigned name for the resource. All resources SHOULD have a name, but the name may be extracted from the resource (e.g. ValueSet.name).
    property name : String read GetNameST write SetNameST;
    // A human assigned name for the resource. All resources SHOULD have a name, but the name may be extracted from the resource (e.g. ValueSet.name).
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A description of the reason that a resource has been included in the implementation guide.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A description of the reason that a resource has been included in the implementation guide.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to A short code that may be used to identify the resource throughout the implementation guide.
    property acronym : String read GetAcronymST write SetAcronymST;
    // A short code that may be used to identify the resource throughout the implementation guide.
    property acronymElement : TFhirString read FAcronym write SetAcronym;

    // Typed access to Where this resource is found. (defined for API consistency)
    property source : TFhirType read FSource write SetSource;
    // Where this resource is found.
    property sourceElement : TFhirType read FSource write SetSource;

    // Typed access to Another resource that this resource is an example for. This is mostly used for resources that are included as examples of StructureDefinitions. (defined for API consistency)
    property exampleFor : TFhirReference{TFhirStructureDefinition} read FExampleFor write SetExampleFor;
    // Another resource that this resource is an example for. This is mostly used for resources that are included as examples of StructureDefinitions.
    property exampleForElement : TFhirReference{TFhirStructureDefinition} read FExampleFor write SetExampleFor;

  end;

  TFhirImplementationGuidePackageResourceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImplementationGuidePackageResourceList;
    function GetCurrent : TFhirImplementationGuidePackageResource;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImplementationGuidePackageResourceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImplementationGuidePackageResource read GetCurrent;
  end;

  TFhirImplementationGuidePackageResourceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImplementationGuidePackageResource;
    procedure SetItemN(index : Integer; value : TFhirImplementationGuidePackageResource);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImplementationGuidePackageResourceList; Overload;
    function Clone : TFhirImplementationGuidePackageResourceList; Overload;
    function GetEnumerator : TFhirImplementationGuidePackageResourceListEnumerator;
    

    //  Add a FhirImplementationGuidePackageResource to the end of the list.
    function Append : TFhirImplementationGuidePackageResource;

    
    // Add an already existing FhirImplementationGuidePackageResource to the end of the list.
    procedure AddItem(value : TFhirImplementationGuidePackageResource); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImplementationGuidePackageResource) : Integer;
    

    // Insert FhirImplementationGuidePackageResource before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImplementationGuidePackageResource;
    

    // Insert an existing FhirImplementationGuidePackageResource before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImplementationGuidePackageResource);
    
    // Get the iIndexth FhirImplementationGuidePackageResource. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImplementationGuidePackageResource);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImplementationGuidePackageResource;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirImplementationGuidePackageResources[index : Integer] : TFhirImplementationGuidePackageResource read GetItemN write SetItemN; default;
  End;

  // A set of profiles that all resources covered by this implementation guide must conform to.
  TFhirImplementationGuideGlobal = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FProfile : TFhirReference{TFhirStructureDefinition};
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirResourceTypesEnum;
    Procedure SetType_ST(value : TFhirResourceTypesEnum);
    Procedure SetProfile(value : TFhirReference{TFhirStructureDefinition});
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImplementationGuideGlobal; overload;
    function Clone : TFhirImplementationGuideGlobal; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The type of resource that all instances must conform to.
    property type_ : TFhirResourceTypesEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to A reference to the profile that all instances must conform to. (defined for API consistency)
    property profile : TFhirReference{TFhirStructureDefinition} read FProfile write SetProfile;
    // A reference to the profile that all instances must conform to.
    property profileElement : TFhirReference{TFhirStructureDefinition} read FProfile write SetProfile;

  end;

  TFhirImplementationGuideGlobalListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImplementationGuideGlobalList;
    function GetCurrent : TFhirImplementationGuideGlobal;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImplementationGuideGlobalList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImplementationGuideGlobal read GetCurrent;
  end;

  TFhirImplementationGuideGlobalList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImplementationGuideGlobal;
    procedure SetItemN(index : Integer; value : TFhirImplementationGuideGlobal);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImplementationGuideGlobalList; Overload;
    function Clone : TFhirImplementationGuideGlobalList; Overload;
    function GetEnumerator : TFhirImplementationGuideGlobalListEnumerator;
    

    //  Add a FhirImplementationGuideGlobal to the end of the list.
    function Append : TFhirImplementationGuideGlobal;

    
    // Add an already existing FhirImplementationGuideGlobal to the end of the list.
    procedure AddItem(value : TFhirImplementationGuideGlobal); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImplementationGuideGlobal) : Integer;
    

    // Insert FhirImplementationGuideGlobal before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImplementationGuideGlobal;
    

    // Insert an existing FhirImplementationGuideGlobal before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImplementationGuideGlobal);
    
    // Get the iIndexth FhirImplementationGuideGlobal. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImplementationGuideGlobal);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImplementationGuideGlobal;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirImplementationGuideGlobals[index : Integer] : TFhirImplementationGuideGlobal read GetItemN write SetItemN; default;
  End;

  // A page / section in the implementation guide. The root page is the implementation guide home page.
  TFhirImplementationGuidePage = class (TFhirBackboneElement)
  protected
    FSource : TFhirUri;
    FName : TFhirString;
    FKind : TFhirEnum;
    FType_ : TFhirEnumList;
    FpackageList : TFhirStringList;
    FFormat : TFhirCode;
    FpageList : TFhirImplementationGuidePageList;
    Procedure SetSource(value : TFhirUri);
    Function GetSourceST : String;
    Procedure SetSourceST(value : String);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetKind(value : TFhirEnum);
    Function GetKindST : TFhirGuidePageKindEnum;
    Procedure SetKindST(value : TFhirGuidePageKindEnum);
    function GetType_ : TFhirEnumList;
    function GetHasType_ : Boolean;
    function GetPackageList : TFhirStringList;
    function GetHasPackageList : Boolean;
    Procedure SetFormat(value : TFhirCode);
    Function GetFormatST : String;
    Procedure SetFormatST(value : String);
    function GetPageList : TFhirImplementationGuidePageList;
    function GetHasPageList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImplementationGuidePage; overload;
    function Clone : TFhirImplementationGuidePage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The source address for the page.
    property source : String read GetSourceST write SetSourceST;
    // The source address for the page.
    property sourceElement : TFhirUri read FSource write SetSource;

    // Typed access to A short name used to represent this page in navigational structures such as table of contents, bread crumbs, etc.
    property name : String read GetNameST write SetNameST;
    // A short name used to represent this page in navigational structures such as table of contents, bread crumbs, etc.
    property nameElement : TFhirString read FName write SetName;

    // The kind of page that this is. Some pages are autogenerated (list, example), and other kinds are of interest so that tools can navigate the user to the page of interest.
    property kind : TFhirGuidePageKindEnum read GetKindST write SetKindST;
    property kindElement : TFhirEnum read FKind write SetKind;

    property type_ : TFhirEnumList read GetType_;
    property type_List : TFhirEnumList read GetType_;
    property hasType_ : boolean read GetHasType_;
    // For constructed pages, a list of packages to include in the page (or else empty for everything).
    property packageList : TFhirStringList read GetPackageList;
    property hasPackageList : boolean read GetHasPackageList;

    // Typed access to The format of the page.
    property format : String read GetFormatST write SetFormatST;
    // The format of the page.
    property formatElement : TFhirCode read FFormat write SetFormat;

    // Nested Pages/Sections under this page.
    property pageList : TFhirImplementationGuidePageList read GetPageList;
    property hasPageList : boolean read GetHasPageList;

  end;

  TFhirImplementationGuidePageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImplementationGuidePageList;
    function GetCurrent : TFhirImplementationGuidePage;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImplementationGuidePageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImplementationGuidePage read GetCurrent;
  end;

  TFhirImplementationGuidePageList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImplementationGuidePage;
    procedure SetItemN(index : Integer; value : TFhirImplementationGuidePage);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImplementationGuidePageList; Overload;
    function Clone : TFhirImplementationGuidePageList; Overload;
    function GetEnumerator : TFhirImplementationGuidePageListEnumerator;
    

    //  Add a FhirImplementationGuidePage to the end of the list.
    function Append : TFhirImplementationGuidePage;

    
    // Add an already existing FhirImplementationGuidePage to the end of the list.
    procedure AddItem(value : TFhirImplementationGuidePage); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImplementationGuidePage) : Integer;
    

    // Insert FhirImplementationGuidePage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImplementationGuidePage;
    

    // Insert an existing FhirImplementationGuidePage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImplementationGuidePage);
    
    // Get the iIndexth FhirImplementationGuidePage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImplementationGuidePage);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImplementationGuidePage;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirImplementationGuidePages[index : Integer] : TFhirImplementationGuidePage read GetItemN write SetItemN; default;
  End;

  // A set of rules or how FHIR is used to solve a particular problem. This resource is used to gather all the parts of an implementation guide into a logical whole, and to publish a computable definition of all the parts.
  TFhirImplementationGuide = class (TFhirDomainResource)
  protected
    FUrl : TFhirUri;
    FVersion : TFhirString;
    FName : TFhirString;
    FStatus : TFhirEnum;
    FExperimental : TFhirBoolean;
    FPublisher : TFhirString;
    FcontactList : TFhirImplementationGuideContactList;
    FDate : TFhirDateTime;
    FDescription : TFhirString;
    FuseContextList : TFhirCodeableConceptList;
    FCopyright : TFhirString;
    FFhirVersion : TFhirId;
    FdependencyList : TFhirImplementationGuideDependencyList;
    FpackageList : TFhirImplementationGuidePackageList;
    FglobalList : TFhirImplementationGuideGlobalList;
    FbinaryList : TFhirUriList;
    FPage : TFhirImplementationGuidePage;
    Procedure SetUrl(value : TFhirUri);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);
    Procedure SetVersion(value : TFhirString);
    Function GetVersionST : String;
    Procedure SetVersionST(value : String);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirConformanceResourceStatusEnum;
    Procedure SetStatusST(value : TFhirConformanceResourceStatusEnum);
    Procedure SetExperimental(value : TFhirBoolean);
    Function GetExperimentalST : Boolean;
    Procedure SetExperimentalST(value : Boolean);
    Procedure SetPublisher(value : TFhirString);
    Function GetPublisherST : String;
    Procedure SetPublisherST(value : String);
    function GetContactList : TFhirImplementationGuideContactList;
    function GetHasContactList : Boolean;
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    function GetUseContextList : TFhirCodeableConceptList;
    function GetHasUseContextList : Boolean;
    Procedure SetCopyright(value : TFhirString);
    Function GetCopyrightST : String;
    Procedure SetCopyrightST(value : String);
    Procedure SetFhirVersion(value : TFhirId);
    Function GetFhirVersionST : String;
    Procedure SetFhirVersionST(value : String);
    function GetDependencyList : TFhirImplementationGuideDependencyList;
    function GetHasDependencyList : Boolean;
    function GetPackageList : TFhirImplementationGuidePackageList;
    function GetHasPackageList : Boolean;
    function GetGlobalList : TFhirImplementationGuideGlobalList;
    function GetHasGlobalList : Boolean;
    function GetBinaryList : TFhirUriList;
    function GetHasBinaryList : Boolean;
    Procedure SetPage(value : TFhirImplementationGuidePage);
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImplementationGuide; overload;
    function Clone : TFhirImplementationGuide; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URL that is used to identify this implementation guide when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this implementation guide is (or will be) {$IFNDEF FPC}published{$ENDIF}.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URL that is used to identify this implementation guide when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this implementation guide is (or will be) {$IFNDEF FPC}published{$ENDIF}.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to The identifier that is used to identify this version of the Implementation Guide when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the Implementation Guide author manually.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the Implementation Guide when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the Implementation Guide author manually.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A free text natural language name identifying the Implementation Guide.
    property name : String read GetNameST write SetNameST;
    // A free text natural language name identifying the Implementation Guide.
    property nameElement : TFhirString read FName write SetName;

    // The status of the Implementation Guide.
    property status : TFhirConformanceResourceStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to This Implementation Guide was authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // This Implementation Guide was authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The name of the individual or organization that {$IFNDEF FPC}published{$ENDIF} the implementation guide.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the individual or organization that {$IFNDEF FPC}published{$ENDIF} the implementation guide.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contacts to assist a user in finding and communicating with the publisher.
    property contactList : TFhirImplementationGuideContactList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to The date this version of the implementation guide was {$IFNDEF FPC}published{$ENDIF}. The date must change when the business version changes, if it does, and it must change if the status code changes. In addition, it should change when the substantive content of the implementation guide changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date this version of the implementation guide was {$IFNDEF FPC}published{$ENDIF}. The date must change when the business version changes, if it does, and it must change if the status code changes. In addition, it should change when the substantive content of the implementation guide changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to A free text natural language description of the Implementation Guide and its use.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the Implementation Guide and its use.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These terms may be used to assist with indexing and searching of implementation guides. The most common use of this element is to represent the country / jurisdiction for which this implementation guide was defined.
    property useContextList : TFhirCodeableConceptList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // Typed access to A copyright statement relating to the implementation guide and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the details of the constraints and mappings.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the implementation guide and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the details of the constraints and mappings.
    property copyrightElement : TFhirString read FCopyright write SetCopyright;

    // Typed access to The version of the FHIR specification on which this ImplementationGuide is based - this is the formal version of the specification, without the revision number, e.g. [publication].[major].[minor], which is 1.0.2 for this version.
    property fhirVersion : String read GetFhirVersionST write SetFhirVersionST;
    // The version of the FHIR specification on which this ImplementationGuide is based - this is the formal version of the specification, without the revision number, e.g. [publication].[major].[minor], which is 1.0.2 for this version.
    property fhirVersionElement : TFhirId read FFhirVersion write SetFhirVersion;

    // Another implementation guide that this implementation depends on. Typically, an implementation guide uses value sets, profiles etc.defined in other implementation guides.
    property dependencyList : TFhirImplementationGuideDependencyList read GetDependencyList;
    property hasDependencyList : boolean read GetHasDependencyList;

    // A logical group of resources. Logical groups can be used when building pages.
    property packageList : TFhirImplementationGuidePackageList read GetPackageList;
    property hasPackageList : boolean read GetHasPackageList;

    // A set of profiles that all resources covered by this implementation guide must conform to.
    property globalList : TFhirImplementationGuideGlobalList read GetGlobalList;
    property hasGlobalList : boolean read GetHasGlobalList;

    // A binary file that is included in the  implementation guide when it is {$IFNDEF FPC}published{$ENDIF}.
    property binaryList : TFhirUriList read GetBinaryList;
    property hasBinaryList : boolean read GetHasBinaryList;

    // Typed access to A page / section in the implementation guide. The root page is the implementation guide home page. (defined for API consistency)
    property page : TFhirImplementationGuidePage read FPage write SetPage;
    // A page / section in the implementation guide. The root page is the implementation guide home page.
    property pageElement : TFhirImplementationGuidePage read FPage write SetPage;

  end;

  TFhirImplementationGuideListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImplementationGuideList;
    function GetCurrent : TFhirImplementationGuide;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImplementationGuideList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImplementationGuide read GetCurrent;
  end;

  TFhirImplementationGuideList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImplementationGuide;
    procedure SetItemN(index : Integer; value : TFhirImplementationGuide);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImplementationGuideList; Overload;
    function Clone : TFhirImplementationGuideList; Overload;
    function GetEnumerator : TFhirImplementationGuideListEnumerator;
    

    //  Add a FhirImplementationGuide to the end of the list.
    function Append : TFhirImplementationGuide;

    
    // Add an already existing FhirImplementationGuide to the end of the list.
    procedure AddItem(value : TFhirImplementationGuide); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImplementationGuide) : Integer;
    

    // Insert FhirImplementationGuide before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImplementationGuide;
    

    // Insert an existing FhirImplementationGuide before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImplementationGuide);
    
    // Get the iIndexth FhirImplementationGuide. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImplementationGuide);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImplementationGuide;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirImplementationGuides[index : Integer] : TFhirImplementationGuide read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_IMPLEMENTATIONGUIDE}

{$IFDEF FHIR_NAMINGSYSTEM}

  // Contacts to assist a user in finding and communicating with the publisher.
  TFhirNamingSystemContact = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FtelecomList : TFhirContactPointList;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNamingSystemContact; overload;
    function Clone : TFhirNamingSystemContact; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The name of an individual to contact regarding the naming system.
    property name : String read GetNameST write SetNameST;
    // The name of an individual to contact regarding the naming system.
    property nameElement : TFhirString read FName write SetName;

    // Contact details for individual (if a name was provided) or the publisher.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

  end;

  TFhirNamingSystemContactListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNamingSystemContactList;
    function GetCurrent : TFhirNamingSystemContact;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirNamingSystemContactList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNamingSystemContact read GetCurrent;
  end;

  TFhirNamingSystemContactList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirNamingSystemContact;
    procedure SetItemN(index : Integer; value : TFhirNamingSystemContact);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirNamingSystemContactList; Overload;
    function Clone : TFhirNamingSystemContactList; Overload;
    function GetEnumerator : TFhirNamingSystemContactListEnumerator;
    

    //  Add a FhirNamingSystemContact to the end of the list.
    function Append : TFhirNamingSystemContact;

    
    // Add an already existing FhirNamingSystemContact to the end of the list.
    procedure AddItem(value : TFhirNamingSystemContact); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNamingSystemContact) : Integer;
    

    // Insert FhirNamingSystemContact before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNamingSystemContact;
    

    // Insert an existing FhirNamingSystemContact before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNamingSystemContact);
    
    // Get the iIndexth FhirNamingSystemContact. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNamingSystemContact);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirNamingSystemContact;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirNamingSystemContacts[index : Integer] : TFhirNamingSystemContact read GetItemN write SetItemN; default;
  End;

  // Indicates how the system may be identified when referenced in electronic exchange.
  TFhirNamingSystemUniqueId = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FValue : TFhirString;
    FPreferred : TFhirBoolean;
    FPeriod : TFhirPeriod;
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirNamingsystemIdentifierTypeEnum;
    Procedure SetType_ST(value : TFhirNamingsystemIdentifierTypeEnum);
    Procedure SetValue(value : TFhirString);
    Function GetValueST : String;
    Procedure SetValueST(value : String);
    Procedure SetPreferred(value : TFhirBoolean);
    Function GetPreferredST : Boolean;
    Procedure SetPreferredST(value : Boolean);
    Procedure SetPeriod(value : TFhirPeriod);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNamingSystemUniqueId; overload;
    function Clone : TFhirNamingSystemUniqueId; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifies the unique identifier scheme used for this particular identifier.
    property type_ : TFhirNamingsystemIdentifierTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The string that should be sent over the wire to identify the code system or identifier system.
    property value : String read GetValueST write SetValueST;
    // The string that should be sent over the wire to identify the code system or identifier system.
    property valueElement : TFhirString read FValue write SetValue;

    // Typed access to Indicates whether this identifier is the "preferred" identifier of this type.
    property preferred : Boolean read GetPreferredST write SetPreferredST;
    // Indicates whether this identifier is the "preferred" identifier of this type.
    property preferredElement : TFhirBoolean read FPreferred write SetPreferred;

    // Typed access to Identifies the period of time over which this identifier is considered appropriate to refer to the naming system.  Outside of this window, the identifier might be non-deterministic. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Identifies the period of time over which this identifier is considered appropriate to refer to the naming system.  Outside of this window, the identifier might be non-deterministic.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirNamingSystemUniqueIdListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNamingSystemUniqueIdList;
    function GetCurrent : TFhirNamingSystemUniqueId;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirNamingSystemUniqueIdList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNamingSystemUniqueId read GetCurrent;
  end;

  TFhirNamingSystemUniqueIdList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirNamingSystemUniqueId;
    procedure SetItemN(index : Integer; value : TFhirNamingSystemUniqueId);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirNamingSystemUniqueIdList; Overload;
    function Clone : TFhirNamingSystemUniqueIdList; Overload;
    function GetEnumerator : TFhirNamingSystemUniqueIdListEnumerator;
    

    //  Add a FhirNamingSystemUniqueId to the end of the list.
    function Append : TFhirNamingSystemUniqueId;

    
    // Add an already existing FhirNamingSystemUniqueId to the end of the list.
    procedure AddItem(value : TFhirNamingSystemUniqueId); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNamingSystemUniqueId) : Integer;
    

    // Insert FhirNamingSystemUniqueId before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNamingSystemUniqueId;
    

    // Insert an existing FhirNamingSystemUniqueId before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNamingSystemUniqueId);
    
    // Get the iIndexth FhirNamingSystemUniqueId. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNamingSystemUniqueId);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirNamingSystemUniqueId;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirNamingSystemUniqueIds[index : Integer] : TFhirNamingSystemUniqueId read GetItemN write SetItemN; default;
  End;

  // A curated namespace that issues unique symbols within that namespace for the identification of concepts, people, devices, etc.  Represents a "System" used within the Identifier and Coding data types.
  TFhirNamingSystem = class (TFhirDomainResource)
  protected
    FName : TFhirString;
    FStatus : TFhirEnum;
    FKind : TFhirEnum;
    FPublisher : TFhirString;
    FcontactList : TFhirNamingSystemContactList;
    FResponsible : TFhirString;
    FDate : TFhirDateTime;
    FType_ : TFhirCodeableConcept;
    FDescription : TFhirString;
    FuseContextList : TFhirCodeableConceptList;
    FUsage : TFhirString;
    FuniqueIdList : TFhirNamingSystemUniqueIdList;
    FReplacedBy : TFhirReference{TFhirNamingSystem};
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirConformanceResourceStatusEnum;
    Procedure SetStatusST(value : TFhirConformanceResourceStatusEnum);
    Procedure SetKind(value : TFhirEnum);
    Function GetKindST : TFhirNamingsystemTypeEnum;
    Procedure SetKindST(value : TFhirNamingsystemTypeEnum);
    Procedure SetPublisher(value : TFhirString);
    Function GetPublisherST : String;
    Procedure SetPublisherST(value : String);
    function GetContactList : TFhirNamingSystemContactList;
    function GetHasContactList : Boolean;
    Procedure SetResponsible(value : TFhirString);
    Function GetResponsibleST : String;
    Procedure SetResponsibleST(value : String);
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    function GetUseContextList : TFhirCodeableConceptList;
    function GetHasUseContextList : Boolean;
    Procedure SetUsage(value : TFhirString);
    Function GetUsageST : String;
    Procedure SetUsageST(value : String);
    function GetUniqueIdList : TFhirNamingSystemUniqueIdList;
    function GetHasUniqueIdList : Boolean;
    Procedure SetReplacedBy(value : TFhirReference{TFhirNamingSystem});
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNamingSystem; overload;
    function Clone : TFhirNamingSystem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The descriptive name of this particular identifier type or code system.
    property name : String read GetNameST write SetNameST;
    // The descriptive name of this particular identifier type or code system.
    property nameElement : TFhirString read FName write SetName;

    // Indicates whether the naming system is "ready for use" or not.
    property status : TFhirConformanceResourceStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Indicates the purpose for the naming system - what kinds of things does it make unique?
    property kind : TFhirNamingsystemTypeEnum read GetKindST write SetKindST;
    property kindElement : TFhirEnum read FKind write SetKind;

    // Typed access to The name of the individual or organization that {$IFNDEF FPC}published{$ENDIF} the naming system.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the individual or organization that {$IFNDEF FPC}published{$ENDIF} the naming system.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contacts to assist a user in finding and communicating with the publisher.
    property contactList : TFhirNamingSystemContactList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to The name of the organization that is responsible for issuing identifiers or codes for this namespace and ensuring their non-collision.
    property responsible : String read GetResponsibleST write SetResponsibleST;
    // The name of the organization that is responsible for issuing identifiers or codes for this namespace and ensuring their non-collision.
    property responsibleElement : TFhirString read FResponsible write SetResponsible;

    // Typed access to The date  (and optionally time) when the system was registered or {$IFNDEF FPC}published{$ENDIF}. The date must change when the business version changes, if it does, and it must change if the status code changes. In addition, it should change when the substantive content of the registration changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the system was registered or {$IFNDEF FPC}published{$ENDIF}. The date must change when the business version changes, if it does, and it must change if the status code changes. In addition, it should change when the substantive content of the registration changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to Categorizes a naming system for easier search by grouping related naming systems. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Categorizes a naming system for easier search by grouping related naming systems.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Details about what the namespace identifies including scope, granularity, version labeling, etc.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Details about what the namespace identifies including scope, granularity, version labeling, etc.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These terms may be used to assist with indexing and searching of naming systems.
    property useContextList : TFhirCodeableConceptList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // Typed access to Provides guidance on the use of the namespace, including the handling of formatting characters, use of upper vs. lower case, etc.
    property usage : String read GetUsageST write SetUsageST;
    // Provides guidance on the use of the namespace, including the handling of formatting characters, use of upper vs. lower case, etc.
    property usageElement : TFhirString read FUsage write SetUsage;

    // Indicates how the system may be identified when referenced in electronic exchange.
    property uniqueIdList : TFhirNamingSystemUniqueIdList read GetUniqueIdList;
    property hasUniqueIdList : boolean read GetHasUniqueIdList;

    // Typed access to For naming systems that are retired, indicates the naming system that should be used in their place (if any). (defined for API consistency)
    property replacedBy : TFhirReference{TFhirNamingSystem} read FReplacedBy write SetReplacedBy;
    // For naming systems that are retired, indicates the naming system that should be used in their place (if any).
    property replacedByElement : TFhirReference{TFhirNamingSystem} read FReplacedBy write SetReplacedBy;

  end;

  TFhirNamingSystemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNamingSystemList;
    function GetCurrent : TFhirNamingSystem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirNamingSystemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNamingSystem read GetCurrent;
  end;

  TFhirNamingSystemList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirNamingSystem;
    procedure SetItemN(index : Integer; value : TFhirNamingSystem);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirNamingSystemList; Overload;
    function Clone : TFhirNamingSystemList; Overload;
    function GetEnumerator : TFhirNamingSystemListEnumerator;
    

    //  Add a FhirNamingSystem to the end of the list.
    function Append : TFhirNamingSystem;

    
    // Add an already existing FhirNamingSystem to the end of the list.
    procedure AddItem(value : TFhirNamingSystem); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNamingSystem) : Integer;
    

    // Insert FhirNamingSystem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNamingSystem;
    

    // Insert an existing FhirNamingSystem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNamingSystem);
    
    // Get the iIndexth FhirNamingSystem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNamingSystem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirNamingSystem;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirNamingSystems[index : Integer] : TFhirNamingSystem read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_NAMINGSYSTEM}

{$IFDEF FHIR_OPERATIONDEFINITION}

  // Contacts to assist a user in finding and communicating with the publisher.
  TFhirOperationDefinitionContact = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FtelecomList : TFhirContactPointList;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirOperationDefinitionContact; overload;
    function Clone : TFhirOperationDefinitionContact; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The name of an individual to contact regarding the operation definition.
    property name : String read GetNameST write SetNameST;
    // The name of an individual to contact regarding the operation definition.
    property nameElement : TFhirString read FName write SetName;

    // Contact details for individual (if a name was provided) or the publisher.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

  end;

  TFhirOperationDefinitionContactListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirOperationDefinitionContactList;
    function GetCurrent : TFhirOperationDefinitionContact;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirOperationDefinitionContactList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirOperationDefinitionContact read GetCurrent;
  end;

  TFhirOperationDefinitionContactList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirOperationDefinitionContact;
    procedure SetItemN(index : Integer; value : TFhirOperationDefinitionContact);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirOperationDefinitionContactList; Overload;
    function Clone : TFhirOperationDefinitionContactList; Overload;
    function GetEnumerator : TFhirOperationDefinitionContactListEnumerator;
    

    //  Add a FhirOperationDefinitionContact to the end of the list.
    function Append : TFhirOperationDefinitionContact;

    
    // Add an already existing FhirOperationDefinitionContact to the end of the list.
    procedure AddItem(value : TFhirOperationDefinitionContact); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirOperationDefinitionContact) : Integer;
    

    // Insert FhirOperationDefinitionContact before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirOperationDefinitionContact;
    

    // Insert an existing FhirOperationDefinitionContact before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirOperationDefinitionContact);
    
    // Get the iIndexth FhirOperationDefinitionContact. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirOperationDefinitionContact);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirOperationDefinitionContact;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirOperationDefinitionContacts[index : Integer] : TFhirOperationDefinitionContact read GetItemN write SetItemN; default;
  End;

  // The parameters for the operation/query.
  TFhirOperationDefinitionParameter = class (TFhirBackboneElement)
  protected
    FName : TFhirCode;
    FUse : TFhirEnum;
    FMin : TFhirInteger;
    FMax : TFhirString;
    FDocumentation : TFhirString;
    FType_ : TFhirEnum;
    FProfile : TFhirReference{TFhirStructureDefinition};
    FBinding : TFhirOperationDefinitionParameterBinding;
    FpartList : TFhirOperationDefinitionParameterList;
    Procedure SetName(value : TFhirCode);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetUse(value : TFhirEnum);
    Function GetUseST : TFhirOperationParameterUseEnum;
    Procedure SetUseST(value : TFhirOperationParameterUseEnum);
    Procedure SetMin(value : TFhirInteger);
    Function GetMinST : String;
    Procedure SetMinST(value : String);
    Procedure SetMax(value : TFhirString);
    Function GetMaxST : String;
    Procedure SetMaxST(value : String);
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirOperationParameterTypeEnum;
    Procedure SetType_ST(value : TFhirOperationParameterTypeEnum);
    Procedure SetProfile(value : TFhirReference{TFhirStructureDefinition});
    Procedure SetBinding(value : TFhirOperationDefinitionParameterBinding);
    function GetPartList : TFhirOperationDefinitionParameterList;
    function GetHasPartList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirOperationDefinitionParameter; overload;
    function Clone : TFhirOperationDefinitionParameter; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The name of used to identify the parameter.
    property name : String read GetNameST write SetNameST;
    // The name of used to identify the parameter.
    property nameElement : TFhirCode read FName write SetName;

    // Whether this is an input or an output parameter.
    property use : TFhirOperationParameterUseEnum read GetUseST write SetUseST;
    property useElement : TFhirEnum read FUse write SetUse;

    // Typed access to The minimum number of times this parameter SHALL appear in the request or response.
    property min : String read GetMinST write SetMinST;
    // The minimum number of times this parameter SHALL appear in the request or response.
    property minElement : TFhirInteger read FMin write SetMin;

    // Typed access to The maximum number of times this element is permitted to appear in the request or response.
    property max : String read GetMaxST write SetMaxST;
    // The maximum number of times this element is permitted to appear in the request or response.
    property maxElement : TFhirString read FMax write SetMax;

    // Typed access to Describes the meaning or use of this parameter.
    property documentation : String read GetDocumentationST write SetDocumentationST;
    // Describes the meaning or use of this parameter.
    property documentationElement : TFhirString read FDocumentation write SetDocumentation;

    // The type for this parameter.
    property type_ : TFhirOperationParameterTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to A profile the specifies the rules that this parameter must conform to. (defined for API consistency)
    property profile : TFhirReference{TFhirStructureDefinition} read FProfile write SetProfile;
    // A profile the specifies the rules that this parameter must conform to.
    property profileElement : TFhirReference{TFhirStructureDefinition} read FProfile write SetProfile;

    // Typed access to Binds to a value set if this parameter is coded (code, Coding, CodeableConcept). (defined for API consistency)
    property binding : TFhirOperationDefinitionParameterBinding read FBinding write SetBinding;
    // Binds to a value set if this parameter is coded (code, Coding, CodeableConcept).
    property bindingElement : TFhirOperationDefinitionParameterBinding read FBinding write SetBinding;

    // The parts of a Tuple Parameter.
    property partList : TFhirOperationDefinitionParameterList read GetPartList;
    property hasPartList : boolean read GetHasPartList;

  end;

  TFhirOperationDefinitionParameterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirOperationDefinitionParameterList;
    function GetCurrent : TFhirOperationDefinitionParameter;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirOperationDefinitionParameterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirOperationDefinitionParameter read GetCurrent;
  end;

  TFhirOperationDefinitionParameterList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirOperationDefinitionParameter;
    procedure SetItemN(index : Integer; value : TFhirOperationDefinitionParameter);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirOperationDefinitionParameterList; Overload;
    function Clone : TFhirOperationDefinitionParameterList; Overload;
    function GetEnumerator : TFhirOperationDefinitionParameterListEnumerator;
    

    //  Add a FhirOperationDefinitionParameter to the end of the list.
    function Append : TFhirOperationDefinitionParameter;

    
    // Add an already existing FhirOperationDefinitionParameter to the end of the list.
    procedure AddItem(value : TFhirOperationDefinitionParameter); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirOperationDefinitionParameter) : Integer;
    

    // Insert FhirOperationDefinitionParameter before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirOperationDefinitionParameter;
    

    // Insert an existing FhirOperationDefinitionParameter before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirOperationDefinitionParameter);
    
    // Get the iIndexth FhirOperationDefinitionParameter. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirOperationDefinitionParameter);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirOperationDefinitionParameter;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirOperationDefinitionParameters[index : Integer] : TFhirOperationDefinitionParameter read GetItemN write SetItemN; default;
  End;

  // Binds to a value set if this parameter is coded (code, Coding, CodeableConcept).
  TFhirOperationDefinitionParameterBinding = class (TFhirBackboneElement)
  protected
    FStrength : TFhirEnum;
    FValueSet : TFhirType;
    Procedure SetStrength(value : TFhirEnum);
    Function GetStrengthST : TFhirBindingStrengthEnum;
    Procedure SetStrengthST(value : TFhirBindingStrengthEnum);
    Procedure SetValueSet(value : TFhirType);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirOperationDefinitionParameterBinding; overload;
    function Clone : TFhirOperationDefinitionParameterBinding; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Indicates the degree of conformance expectations associated with this binding - that is, the degree to which the provided value set must be adhered to in the instances.
    property strength : TFhirBindingStrengthEnum read GetStrengthST write SetStrengthST;
    property strengthElement : TFhirEnum read FStrength write SetStrength;

    // Typed access to Points to the value set or external definition (e.g. implicit value set) that identifies the set of codes to be used. (defined for API consistency)
    property valueSet : TFhirType read FValueSet write SetValueSet;
    // Points to the value set or external definition (e.g. implicit value set) that identifies the set of codes to be used.
    property valueSetElement : TFhirType read FValueSet write SetValueSet;

  end;

  TFhirOperationDefinitionParameterBindingListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirOperationDefinitionParameterBindingList;
    function GetCurrent : TFhirOperationDefinitionParameterBinding;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirOperationDefinitionParameterBindingList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirOperationDefinitionParameterBinding read GetCurrent;
  end;

  TFhirOperationDefinitionParameterBindingList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirOperationDefinitionParameterBinding;
    procedure SetItemN(index : Integer; value : TFhirOperationDefinitionParameterBinding);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirOperationDefinitionParameterBindingList; Overload;
    function Clone : TFhirOperationDefinitionParameterBindingList; Overload;
    function GetEnumerator : TFhirOperationDefinitionParameterBindingListEnumerator;
    

    //  Add a FhirOperationDefinitionParameterBinding to the end of the list.
    function Append : TFhirOperationDefinitionParameterBinding;

    
    // Add an already existing FhirOperationDefinitionParameterBinding to the end of the list.
    procedure AddItem(value : TFhirOperationDefinitionParameterBinding); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirOperationDefinitionParameterBinding) : Integer;
    

    // Insert FhirOperationDefinitionParameterBinding before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirOperationDefinitionParameterBinding;
    

    // Insert an existing FhirOperationDefinitionParameterBinding before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirOperationDefinitionParameterBinding);
    
    // Get the iIndexth FhirOperationDefinitionParameterBinding. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirOperationDefinitionParameterBinding);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirOperationDefinitionParameterBinding;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirOperationDefinitionParameterBindings[index : Integer] : TFhirOperationDefinitionParameterBinding read GetItemN write SetItemN; default;
  End;

  // A formal computable definition of an operation (on the RESTful interface) or a named query (using the search interaction).
  TFhirOperationDefinition = class (TFhirDomainResource)
  protected
    FUrl : TFhirUri;
    FVersion : TFhirString;
    FName : TFhirString;
    FStatus : TFhirEnum;
    FKind : TFhirEnum;
    FExperimental : TFhirBoolean;
    FPublisher : TFhirString;
    FcontactList : TFhirOperationDefinitionContactList;
    FDate : TFhirDateTime;
    FDescription : TFhirString;
    FRequirements : TFhirString;
    FIdempotent : TFhirBoolean;
    FCode : TFhirCode;
    FNotes : TFhirString;
    FBase : TFhirReference{TFhirOperationDefinition};
    FSystem : TFhirBoolean;
    FType_ : TFhirEnumList;
    FInstance : TFhirBoolean;
    FparameterList : TFhirOperationDefinitionParameterList;
    Procedure SetUrl(value : TFhirUri);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);
    Procedure SetVersion(value : TFhirString);
    Function GetVersionST : String;
    Procedure SetVersionST(value : String);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirConformanceResourceStatusEnum;
    Procedure SetStatusST(value : TFhirConformanceResourceStatusEnum);
    Procedure SetKind(value : TFhirEnum);
    Function GetKindST : TFhirOperationKindEnum;
    Procedure SetKindST(value : TFhirOperationKindEnum);
    Procedure SetExperimental(value : TFhirBoolean);
    Function GetExperimentalST : Boolean;
    Procedure SetExperimentalST(value : Boolean);
    Procedure SetPublisher(value : TFhirString);
    Function GetPublisherST : String;
    Procedure SetPublisherST(value : String);
    function GetContactList : TFhirOperationDefinitionContactList;
    function GetHasContactList : Boolean;
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetRequirements(value : TFhirString);
    Function GetRequirementsST : String;
    Procedure SetRequirementsST(value : String);
    Procedure SetIdempotent(value : TFhirBoolean);
    Function GetIdempotentST : Boolean;
    Procedure SetIdempotentST(value : Boolean);
    Procedure SetCode(value : TFhirCode);
    Function GetCodeST : String;
    Procedure SetCodeST(value : String);
    Procedure SetNotes(value : TFhirString);
    Function GetNotesST : String;
    Procedure SetNotesST(value : String);
    Procedure SetBase(value : TFhirReference{TFhirOperationDefinition});
    Procedure SetSystem(value : TFhirBoolean);
    Function GetSystemST : Boolean;
    Procedure SetSystemST(value : Boolean);
    function GetType_ : TFhirEnumList;
    function GetHasType_ : Boolean;
    Procedure SetInstance(value : TFhirBoolean);
    Function GetInstanceST : Boolean;
    Procedure SetInstanceST(value : Boolean);
    function GetParameterList : TFhirOperationDefinitionParameterList;
    function GetHasParameterList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirOperationDefinition; overload;
    function Clone : TFhirOperationDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URL that is used to identify this operation definition when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this operation definition is (or will be) {$IFNDEF FPC}published{$ENDIF}.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URL that is used to identify this operation definition when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this operation definition is (or will be) {$IFNDEF FPC}published{$ENDIF}.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to The identifier that is used to identify this version of the profile when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the profile author manually and the value should be a timestamp.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the profile when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the profile author manually and the value should be a timestamp.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A free text natural language name identifying the operation.
    property name : String read GetNameST write SetNameST;
    // A free text natural language name identifying the operation.
    property nameElement : TFhirString read FName write SetName;

    // The status of the profile.
    property status : TFhirConformanceResourceStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Whether this is an operation or a named query.
    property kind : TFhirOperationKindEnum read GetKindST write SetKindST;
    property kindElement : TFhirEnum read FKind write SetKind;

    // Typed access to This profile was authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // This profile was authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The name of the individual or organization that {$IFNDEF FPC}published{$ENDIF} the operation definition.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the individual or organization that {$IFNDEF FPC}published{$ENDIF} the operation definition.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contacts to assist a user in finding and communicating with the publisher.
    property contactList : TFhirOperationDefinitionContactList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to The date this version of the operation definition was {$IFNDEF FPC}published{$ENDIF}. The date must change when the business version changes, if it does, and it must change if the status code changes. In addition, it should change when the substantive content of the Operation Definition changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date this version of the operation definition was {$IFNDEF FPC}published{$ENDIF}. The date must change when the business version changes, if it does, and it must change if the status code changes. In addition, it should change when the substantive content of the Operation Definition changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to A free text natural language description of the profile and its use.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the profile and its use.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Explains why this operation definition is needed and why it's been constrained as it has.
    property requirements : String read GetRequirementsST write SetRequirementsST;
    // Explains why this operation definition is needed and why it's been constrained as it has.
    property requirementsElement : TFhirString read FRequirements write SetRequirements;

    // Typed access to Operations that are idempotent (see [HTTP specification definition of idempotent](http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html)) may be invoked by performing an HTTP GET operation instead of a POST.
    property idempotent : Boolean read GetIdempotentST write SetIdempotentST;
    // Operations that are idempotent (see [HTTP specification definition of idempotent](http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html)) may be invoked by performing an HTTP GET operation instead of a POST.
    property idempotentElement : TFhirBoolean read FIdempotent write SetIdempotent;

    // Typed access to The name used to invoke the operation.
    property code : String read GetCodeST write SetCodeST;
    // The name used to invoke the operation.
    property codeElement : TFhirCode read FCode write SetCode;

    // Typed access to Additional information about how to use this operation or named query.
    property notes : String read GetNotesST write SetNotesST;
    // Additional information about how to use this operation or named query.
    property notesElement : TFhirString read FNotes write SetNotes;

    // Typed access to Indicates that this operation definition is a constraining profile on the base. (defined for API consistency)
    property base : TFhirReference{TFhirOperationDefinition} read FBase write SetBase;
    // Indicates that this operation definition is a constraining profile on the base.
    property baseElement : TFhirReference{TFhirOperationDefinition} read FBase write SetBase;

    // Typed access to Indicates whether this operation or named query can be invoked at the system level (e.g. without needing to choose a resource type for the context).
    property system : Boolean read GetSystemST write SetSystemST;
    // Indicates whether this operation or named query can be invoked at the system level (e.g. without needing to choose a resource type for the context).
    property systemElement : TFhirBoolean read FSystem write SetSystem;

    property type_ : TFhirEnumList read GetType_;
    property type_List : TFhirEnumList read GetType_;
    property hasType_ : boolean read GetHasType_;
    // Typed access to Indicates whether this operation can be invoked on a particular instance of one of the given types.
    property instance : Boolean read GetInstanceST write SetInstanceST;
    // Indicates whether this operation can be invoked on a particular instance of one of the given types.
    property instanceElement : TFhirBoolean read FInstance write SetInstance;

    // The parameters for the operation/query.
    property parameterList : TFhirOperationDefinitionParameterList read GetParameterList;
    property hasParameterList : boolean read GetHasParameterList;

  end;

  TFhirOperationDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirOperationDefinitionList;
    function GetCurrent : TFhirOperationDefinition;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirOperationDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirOperationDefinition read GetCurrent;
  end;

  TFhirOperationDefinitionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirOperationDefinition;
    procedure SetItemN(index : Integer; value : TFhirOperationDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirOperationDefinitionList; Overload;
    function Clone : TFhirOperationDefinitionList; Overload;
    function GetEnumerator : TFhirOperationDefinitionListEnumerator;
    

    //  Add a FhirOperationDefinition to the end of the list.
    function Append : TFhirOperationDefinition;

    
    // Add an already existing FhirOperationDefinition to the end of the list.
    procedure AddItem(value : TFhirOperationDefinition); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirOperationDefinition) : Integer;
    

    // Insert FhirOperationDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirOperationDefinition;
    

    // Insert an existing FhirOperationDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirOperationDefinition);
    
    // Get the iIndexth FhirOperationDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirOperationDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirOperationDefinition;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirOperationDefinitions[index : Integer] : TFhirOperationDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_OPERATIONDEFINITION}

{$IFDEF FHIR_QUESTIONNAIRE}

  // A collection of related questions (or further groupings of questions).
  TFhirQuestionnaireGroup = class (TFhirBackboneElement)
  protected
    FLinkId : TFhirString;
    FTitle : TFhirString;
    FconceptList : TFhirCodingList;
    FText : TFhirString;
    FRequired : TFhirBoolean;
    FRepeats : TFhirBoolean;
    FgroupList : TFhirQuestionnaireGroupList;
    FquestionList : TFhirQuestionnaireGroupQuestionList;
    Procedure SetLinkId(value : TFhirString);
    Function GetLinkIdST : String;
    Procedure SetLinkIdST(value : String);
    Procedure SetTitle(value : TFhirString);
    Function GetTitleST : String;
    Procedure SetTitleST(value : String);
    function GetConceptList : TFhirCodingList;
    function GetHasConceptList : Boolean;
    Procedure SetText(value : TFhirString);
    Function GetTextST : String;
    Procedure SetTextST(value : String);
    Procedure SetRequired(value : TFhirBoolean);
    Function GetRequiredST : Boolean;
    Procedure SetRequiredST(value : Boolean);
    Procedure SetRepeats(value : TFhirBoolean);
    Function GetRepeatsST : Boolean;
    Procedure SetRepeatsST(value : Boolean);
    function GetGroupList : TFhirQuestionnaireGroupList;
    function GetHasGroupList : Boolean;
    function GetQuestionList : TFhirQuestionnaireGroupQuestionList;
    function GetHasQuestionList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirQuestionnaireGroup; overload;
    function Clone : TFhirQuestionnaireGroup; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An identifier that is unique within the Questionnaire allowing linkage to the equivalent group in a QuestionnaireResponse resource.
    property linkId : String read GetLinkIdST write SetLinkIdST;
    // An identifier that is unique within the Questionnaire allowing linkage to the equivalent group in a QuestionnaireResponse resource.
    property linkIdElement : TFhirString read FLinkId write SetLinkId;

    // Typed access to The human-readable name for this section of the questionnaire.
    property title : String read GetTitleST write SetTitleST;
    // The human-readable name for this section of the questionnaire.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Identifies a how this group of questions is known in a particular terminology such as LOINC.
    property conceptList : TFhirCodingList read GetConceptList;
    property hasConceptList : boolean read GetHasConceptList;

    // Typed access to Additional text for the group, used for display purposes.
    property text : String read GetTextST write SetTextST;
    // Additional text for the group, used for display purposes.
    property textElement : TFhirString read FText write SetText;

    // Typed access to If true, indicates that the group must be present and have required questions within it answered.  If false, the group may be skipped when answering the questionnaire.
    property required : Boolean read GetRequiredST write SetRequiredST;
    // If true, indicates that the group must be present and have required questions within it answered.  If false, the group may be skipped when answering the questionnaire.
    property requiredElement : TFhirBoolean read FRequired write SetRequired;

    // Typed access to Whether the group may occur multiple times in the instance, containing multiple sets of answers.
    property repeats : Boolean read GetRepeatsST write SetRepeatsST;
    // Whether the group may occur multiple times in the instance, containing multiple sets of answers.
    property repeatsElement : TFhirBoolean read FRepeats write SetRepeats;

    // A sub-group within a group. The ordering of groups within this group is relevant.
    property groupList : TFhirQuestionnaireGroupList read GetGroupList;
    property hasGroupList : boolean read GetHasGroupList;

    // Set of questions within this group. The order of questions within the group is relevant.
    property questionList : TFhirQuestionnaireGroupQuestionList read GetQuestionList;
    property hasQuestionList : boolean read GetHasQuestionList;

  end;

  TFhirQuestionnaireGroupListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirQuestionnaireGroupList;
    function GetCurrent : TFhirQuestionnaireGroup;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirQuestionnaireGroupList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirQuestionnaireGroup read GetCurrent;
  end;

  TFhirQuestionnaireGroupList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirQuestionnaireGroup;
    procedure SetItemN(index : Integer; value : TFhirQuestionnaireGroup);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirQuestionnaireGroupList; Overload;
    function Clone : TFhirQuestionnaireGroupList; Overload;
    function GetEnumerator : TFhirQuestionnaireGroupListEnumerator;
    

    //  Add a FhirQuestionnaireGroup to the end of the list.
    function Append : TFhirQuestionnaireGroup;

    
    // Add an already existing FhirQuestionnaireGroup to the end of the list.
    procedure AddItem(value : TFhirQuestionnaireGroup); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirQuestionnaireGroup) : Integer;
    

    // Insert FhirQuestionnaireGroup before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirQuestionnaireGroup;
    

    // Insert an existing FhirQuestionnaireGroup before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirQuestionnaireGroup);
    
    // Get the iIndexth FhirQuestionnaireGroup. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirQuestionnaireGroup);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirQuestionnaireGroup;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirQuestionnaireGroups[index : Integer] : TFhirQuestionnaireGroup read GetItemN write SetItemN; default;
  End;

  // Set of questions within this group. The order of questions within the group is relevant.
  TFhirQuestionnaireGroupQuestion = class (TFhirBackboneElement)
  protected
    FLinkId : TFhirString;
    FconceptList : TFhirCodingList;
    FText : TFhirString;
    FType_ : TFhirEnum;
    FRequired : TFhirBoolean;
    FRepeats : TFhirBoolean;
    FOptions : TFhirReference{TFhirValueSet};
    FoptionList : TFhirCodingList;
    FgroupList : TFhirQuestionnaireGroupList;
    Procedure SetLinkId(value : TFhirString);
    Function GetLinkIdST : String;
    Procedure SetLinkIdST(value : String);
    function GetConceptList : TFhirCodingList;
    function GetHasConceptList : Boolean;
    Procedure SetText(value : TFhirString);
    Function GetTextST : String;
    Procedure SetTextST(value : String);
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirAnswerFormatEnum;
    Procedure SetType_ST(value : TFhirAnswerFormatEnum);
    Procedure SetRequired(value : TFhirBoolean);
    Function GetRequiredST : Boolean;
    Procedure SetRequiredST(value : Boolean);
    Procedure SetRepeats(value : TFhirBoolean);
    Function GetRepeatsST : Boolean;
    Procedure SetRepeatsST(value : Boolean);
    Procedure SetOptions(value : TFhirReference{TFhirValueSet});
    function GetOptionList : TFhirCodingList;
    function GetHasOptionList : Boolean;
    function GetGroupList : TFhirQuestionnaireGroupList;
    function GetHasGroupList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirQuestionnaireGroupQuestion; overload;
    function Clone : TFhirQuestionnaireGroupQuestion; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An identifier that is unique within the questionnaire allowing linkage to the equivalent group in a [[[QuestionnaireResponse]]] resource.
    property linkId : String read GetLinkIdST write SetLinkIdST;
    // An identifier that is unique within the questionnaire allowing linkage to the equivalent group in a [[[QuestionnaireResponse]]] resource.
    property linkIdElement : TFhirString read FLinkId write SetLinkId;

    // Identifies a how this question is known in a particular terminology such as LOINC.
    property conceptList : TFhirCodingList read GetConceptList;
    property hasConceptList : boolean read GetHasConceptList;

    // Typed access to The actual question as shown to the user to prompt them for an answer.
    property text : String read GetTextST write SetTextST;
    // The actual question as shown to the user to prompt them for an answer.
    property textElement : TFhirString read FText write SetText;

    // The expected format of the answer, e.g. the type of input (string, integer) or whether a (multiple) choice is expected.
    property type_ : TFhirAnswerFormatEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to If true, indicates that the question must be answered and have required groups within it also present.  If false, the question and any contained groups may be skipped when answering the questionnaire.
    property required : Boolean read GetRequiredST write SetRequiredST;
    // If true, indicates that the question must be answered and have required groups within it also present.  If false, the question and any contained groups may be skipped when answering the questionnaire.
    property requiredElement : TFhirBoolean read FRequired write SetRequired;

    // Typed access to If true, the question may have more than one answer.
    property repeats : Boolean read GetRepeatsST write SetRepeatsST;
    // If true, the question may have more than one answer.
    property repeatsElement : TFhirBoolean read FRepeats write SetRepeats;

    // Typed access to Reference to a value set containing a list of codes representing permitted answers for the question. (defined for API consistency)
    property options : TFhirReference{TFhirValueSet} read FOptions write SetOptions;
    // Reference to a value set containing a list of codes representing permitted answers for the question.
    property optionsElement : TFhirReference{TFhirValueSet} read FOptions write SetOptions;

    // For a "choice" question, identifies one of the permitted answers for the question.
    property optionList : TFhirCodingList read GetOptionList;
    property hasOptionList : boolean read GetHasOptionList;

    // Nested group, containing nested question for this question. The order of groups within the question is relevant.
    property groupList : TFhirQuestionnaireGroupList read GetGroupList;
    property hasGroupList : boolean read GetHasGroupList;

  end;

  TFhirQuestionnaireGroupQuestionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirQuestionnaireGroupQuestionList;
    function GetCurrent : TFhirQuestionnaireGroupQuestion;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirQuestionnaireGroupQuestionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirQuestionnaireGroupQuestion read GetCurrent;
  end;

  TFhirQuestionnaireGroupQuestionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirQuestionnaireGroupQuestion;
    procedure SetItemN(index : Integer; value : TFhirQuestionnaireGroupQuestion);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirQuestionnaireGroupQuestionList; Overload;
    function Clone : TFhirQuestionnaireGroupQuestionList; Overload;
    function GetEnumerator : TFhirQuestionnaireGroupQuestionListEnumerator;
    

    //  Add a FhirQuestionnaireGroupQuestion to the end of the list.
    function Append : TFhirQuestionnaireGroupQuestion;

    
    // Add an already existing FhirQuestionnaireGroupQuestion to the end of the list.
    procedure AddItem(value : TFhirQuestionnaireGroupQuestion); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirQuestionnaireGroupQuestion) : Integer;
    

    // Insert FhirQuestionnaireGroupQuestion before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirQuestionnaireGroupQuestion;
    

    // Insert an existing FhirQuestionnaireGroupQuestion before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirQuestionnaireGroupQuestion);
    
    // Get the iIndexth FhirQuestionnaireGroupQuestion. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirQuestionnaireGroupQuestion);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirQuestionnaireGroupQuestion;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirQuestionnaireGroupQuestions[index : Integer] : TFhirQuestionnaireGroupQuestion read GetItemN write SetItemN; default;
  End;

  // A structured set of questions intended to guide the collection of answers. The questions are ordered and grouped into coherent subsets, corresponding to the structure of the grouping of the underlying questions.
  TFhirQuestionnaire = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FVersion : TFhirString;
    FStatus : TFhirEnum;
    FDate : TFhirDateTime;
    FPublisher : TFhirString;
    FtelecomList : TFhirContactPointList;
    FSubjectType : TFhirEnumList;
    FGroup : TFhirQuestionnaireGroup;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetVersion(value : TFhirString);
    Function GetVersionST : String;
    Procedure SetVersionST(value : String);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirQuestionnaireStatusEnum;
    Procedure SetStatusST(value : TFhirQuestionnaireStatusEnum);
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetPublisher(value : TFhirString);
    Function GetPublisherST : String;
    Procedure SetPublisherST(value : String);
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    function GetSubjectType : TFhirEnumList;
    function GetHasSubjectType : Boolean;
    Procedure SetGroup(value : TFhirQuestionnaireGroup);
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirQuestionnaire; overload;
    function Clone : TFhirQuestionnaire; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // This records identifiers associated with this question set that are defined by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate (e.g. in CDA documents, or in written / printed documentation).
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The version number assigned by the publisher for business reasons.  It may remain the same when the resource is updated.
    property version : String read GetVersionST write SetVersionST;
    // The version number assigned by the publisher for business reasons.  It may remain the same when the resource is updated.
    property versionElement : TFhirString read FVersion write SetVersion;

    // The lifecycle status of the questionnaire as a whole.
    property status : TFhirQuestionnaireStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The date that this questionnaire was last changed.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date that this questionnaire was last changed.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to Organization or person responsible for developing and maintaining the questionnaire.
    property publisher : String read GetPublisherST write SetPublisherST;
    // Organization or person responsible for developing and maintaining the questionnaire.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    property subjectType : TFhirEnumList read GetSubjectType;
    property subjectTypeList : TFhirEnumList read GetSubjectType;
    property hasSubjectType : boolean read GetHasSubjectType;
    // Typed access to A collection of related questions (or further groupings of questions). (defined for API consistency)
    property group : TFhirQuestionnaireGroup read FGroup write SetGroup;
    // A collection of related questions (or further groupings of questions).
    property groupElement : TFhirQuestionnaireGroup read FGroup write SetGroup;

  end;

  TFhirQuestionnaireListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirQuestionnaireList;
    function GetCurrent : TFhirQuestionnaire;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirQuestionnaireList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirQuestionnaire read GetCurrent;
  end;

  TFhirQuestionnaireList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirQuestionnaire;
    procedure SetItemN(index : Integer; value : TFhirQuestionnaire);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirQuestionnaireList; Overload;
    function Clone : TFhirQuestionnaireList; Overload;
    function GetEnumerator : TFhirQuestionnaireListEnumerator;
    

    //  Add a FhirQuestionnaire to the end of the list.
    function Append : TFhirQuestionnaire;

    
    // Add an already existing FhirQuestionnaire to the end of the list.
    procedure AddItem(value : TFhirQuestionnaire); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirQuestionnaire) : Integer;
    

    // Insert FhirQuestionnaire before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirQuestionnaire;
    

    // Insert an existing FhirQuestionnaire before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirQuestionnaire);
    
    // Get the iIndexth FhirQuestionnaire. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirQuestionnaire);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirQuestionnaire;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirQuestionnaires[index : Integer] : TFhirQuestionnaire read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_QUESTIONNAIRE}

{$IFDEF FHIR_SEARCHPARAMETER}

  // Contacts to assist a user in finding and communicating with the publisher.
  TFhirSearchParameterContact = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FtelecomList : TFhirContactPointList;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSearchParameterContact; overload;
    function Clone : TFhirSearchParameterContact; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The name of an individual to contact regarding the search parameter.
    property name : String read GetNameST write SetNameST;
    // The name of an individual to contact regarding the search parameter.
    property nameElement : TFhirString read FName write SetName;

    // Contact details for individual (if a name was provided) or the publisher.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

  end;

  TFhirSearchParameterContactListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSearchParameterContactList;
    function GetCurrent : TFhirSearchParameterContact;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSearchParameterContactList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSearchParameterContact read GetCurrent;
  end;

  TFhirSearchParameterContactList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSearchParameterContact;
    procedure SetItemN(index : Integer; value : TFhirSearchParameterContact);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSearchParameterContactList; Overload;
    function Clone : TFhirSearchParameterContactList; Overload;
    function GetEnumerator : TFhirSearchParameterContactListEnumerator;
    

    //  Add a FhirSearchParameterContact to the end of the list.
    function Append : TFhirSearchParameterContact;

    
    // Add an already existing FhirSearchParameterContact to the end of the list.
    procedure AddItem(value : TFhirSearchParameterContact); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSearchParameterContact) : Integer;
    

    // Insert FhirSearchParameterContact before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSearchParameterContact;
    

    // Insert an existing FhirSearchParameterContact before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSearchParameterContact);
    
    // Get the iIndexth FhirSearchParameterContact. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSearchParameterContact);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSearchParameterContact;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSearchParameterContacts[index : Integer] : TFhirSearchParameterContact read GetItemN write SetItemN; default;
  End;

  // A search parameter that defines a named search item that can be used to search/filter on a resource.
  TFhirSearchParameter = class (TFhirDomainResource)
  protected
    FUrl : TFhirUri;
    FName : TFhirString;
    FStatus : TFhirEnum;
    FExperimental : TFhirBoolean;
    FPublisher : TFhirString;
    FcontactList : TFhirSearchParameterContactList;
    FDate : TFhirDateTime;
    FRequirements : TFhirString;
    FCode : TFhirCode;
    FBase : TFhirEnum;
    FType_ : TFhirEnum;
    FDescription : TFhirString;
    FXpath : TFhirString;
    FXpathUsage : TFhirEnum;
    FTarget : TFhirEnumList;
    Procedure SetUrl(value : TFhirUri);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirConformanceResourceStatusEnum;
    Procedure SetStatusST(value : TFhirConformanceResourceStatusEnum);
    Procedure SetExperimental(value : TFhirBoolean);
    Function GetExperimentalST : Boolean;
    Procedure SetExperimentalST(value : Boolean);
    Procedure SetPublisher(value : TFhirString);
    Function GetPublisherST : String;
    Procedure SetPublisherST(value : String);
    function GetContactList : TFhirSearchParameterContactList;
    function GetHasContactList : Boolean;
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetRequirements(value : TFhirString);
    Function GetRequirementsST : String;
    Procedure SetRequirementsST(value : String);
    Procedure SetCode(value : TFhirCode);
    Function GetCodeST : String;
    Procedure SetCodeST(value : String);
    Procedure SetBase(value : TFhirEnum);
    Function GetBaseST : TFhirResourceTypesEnum;
    Procedure SetBaseST(value : TFhirResourceTypesEnum);
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirSearchParamTypeEnum;
    Procedure SetType_ST(value : TFhirSearchParamTypeEnum);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetXpath(value : TFhirString);
    Function GetXpathST : String;
    Procedure SetXpathST(value : String);
    Procedure SetXpathUsage(value : TFhirEnum);
    Function GetXpathUsageST : TFhirSearchXpathUsageEnum;
    Procedure SetXpathUsageST(value : TFhirSearchXpathUsageEnum);
    function GetTarget : TFhirEnumList;
    function GetHasTarget : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSearchParameter; overload;
    function Clone : TFhirSearchParameter; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URL that is used to identify this search parameter when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this search parameter is (or will be) {$IFNDEF FPC}published{$ENDIF}.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URL that is used to identify this search parameter when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this search parameter is (or will be) {$IFNDEF FPC}published{$ENDIF}.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to A free text natural language name identifying the search parameter.
    property name : String read GetNameST write SetNameST;
    // A free text natural language name identifying the search parameter.
    property nameElement : TFhirString read FName write SetName;

    // The status of this search parameter definition.
    property status : TFhirConformanceResourceStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A flag to indicate that this search parameter definition is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A flag to indicate that this search parameter definition is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The name of the individual or organization that {$IFNDEF FPC}published{$ENDIF} the search parameter.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the individual or organization that {$IFNDEF FPC}published{$ENDIF} the search parameter.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contacts to assist a user in finding and communicating with the publisher.
    property contactList : TFhirSearchParameterContactList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to The date  (and optionally time) when the search parameter definition was {$IFNDEF FPC}published{$ENDIF}. The date must change when the business version changes, if it does, and it must change if the status code changes. In addition, it should change when the substantive content of the search parameter changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the search parameter definition was {$IFNDEF FPC}published{$ENDIF}. The date must change when the business version changes, if it does, and it must change if the status code changes. In addition, it should change when the substantive content of the search parameter changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The Scope and Usage that this search parameter was created to meet.
    property requirements : String read GetRequirementsST write SetRequirementsST;
    // The Scope and Usage that this search parameter was created to meet.
    property requirementsElement : TFhirString read FRequirements write SetRequirements;

    // Typed access to The code used in the URL or the parameter name in a parameters resource for this search parameter.
    property code : String read GetCodeST write SetCodeST;
    // The code used in the URL or the parameter name in a parameters resource for this search parameter.
    property codeElement : TFhirCode read FCode write SetCode;

    // The base resource type that this search parameter refers to.
    property base : TFhirResourceTypesEnum read GetBaseST write SetBaseST;
    property baseElement : TFhirEnum read FBase write SetBase;

    // The type of value a search parameter refers to, and how the content is interpreted.
    property type_ : TFhirSearchParamTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to A description of the search parameters and how it used.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A description of the search parameters and how it used.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to An XPath expression that returns a set of elements for the search parameter.
    property xpath : String read GetXpathST write SetXpathST;
    // An XPath expression that returns a set of elements for the search parameter.
    property xpathElement : TFhirString read FXpath write SetXpath;

    // How the search parameter relates to the set of elements returned by evaluating the xpath query.
    property xpathUsage : TFhirSearchXpathUsageEnum read GetXpathUsageST write SetXpathUsageST;
    property xpathUsageElement : TFhirEnum read FXpathUsage write SetXpathUsage;

    property target : TFhirEnumList read GetTarget;
    property targetList : TFhirEnumList read GetTarget;
    property hasTarget : boolean read GetHasTarget;
  end;

  TFhirSearchParameterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSearchParameterList;
    function GetCurrent : TFhirSearchParameter;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSearchParameterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSearchParameter read GetCurrent;
  end;

  TFhirSearchParameterList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSearchParameter;
    procedure SetItemN(index : Integer; value : TFhirSearchParameter);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSearchParameterList; Overload;
    function Clone : TFhirSearchParameterList; Overload;
    function GetEnumerator : TFhirSearchParameterListEnumerator;
    

    //  Add a FhirSearchParameter to the end of the list.
    function Append : TFhirSearchParameter;

    
    // Add an already existing FhirSearchParameter to the end of the list.
    procedure AddItem(value : TFhirSearchParameter); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSearchParameter) : Integer;
    

    // Insert FhirSearchParameter before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSearchParameter;
    

    // Insert an existing FhirSearchParameter before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSearchParameter);
    
    // Get the iIndexth FhirSearchParameter. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSearchParameter);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSearchParameter;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSearchParameters[index : Integer] : TFhirSearchParameter read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SEARCHPARAMETER}

{$IFDEF FHIR_STRUCTUREDEFINITION}

  // Contacts to assist a user in finding and communicating with the publisher.
  TFhirStructureDefinitionContact = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FtelecomList : TFhirContactPointList;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirStructureDefinitionContact; overload;
    function Clone : TFhirStructureDefinitionContact; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The name of an individual to contact regarding the structure definition.
    property name : String read GetNameST write SetNameST;
    // The name of an individual to contact regarding the structure definition.
    property nameElement : TFhirString read FName write SetName;

    // Contact details for individual (if a name was provided) or the publisher.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

  end;

  TFhirStructureDefinitionContactListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirStructureDefinitionContactList;
    function GetCurrent : TFhirStructureDefinitionContact;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirStructureDefinitionContactList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirStructureDefinitionContact read GetCurrent;
  end;

  TFhirStructureDefinitionContactList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirStructureDefinitionContact;
    procedure SetItemN(index : Integer; value : TFhirStructureDefinitionContact);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirStructureDefinitionContactList; Overload;
    function Clone : TFhirStructureDefinitionContactList; Overload;
    function GetEnumerator : TFhirStructureDefinitionContactListEnumerator;
    

    //  Add a FhirStructureDefinitionContact to the end of the list.
    function Append : TFhirStructureDefinitionContact;

    
    // Add an already existing FhirStructureDefinitionContact to the end of the list.
    procedure AddItem(value : TFhirStructureDefinitionContact); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirStructureDefinitionContact) : Integer;
    

    // Insert FhirStructureDefinitionContact before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirStructureDefinitionContact;
    

    // Insert an existing FhirStructureDefinitionContact before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirStructureDefinitionContact);
    
    // Get the iIndexth FhirStructureDefinitionContact. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirStructureDefinitionContact);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirStructureDefinitionContact;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirStructureDefinitionContacts[index : Integer] : TFhirStructureDefinitionContact read GetItemN write SetItemN; default;
  End;

  // An external specification that the content is mapped to.
  TFhirStructureDefinitionMapping = class (TFhirBackboneElement)
  protected
    FIdentity : TFhirId;
    FUri : TFhirUri;
    FName : TFhirString;
    FComments : TFhirString;
    Procedure SetIdentity(value : TFhirId);
    Function GetIdentityST : String;
    Procedure SetIdentityST(value : String);
    Procedure SetUri(value : TFhirUri);
    Function GetUriST : String;
    Procedure SetUriST(value : String);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetComments(value : TFhirString);
    Function GetCommentsST : String;
    Procedure SetCommentsST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirStructureDefinitionMapping; overload;
    function Clone : TFhirStructureDefinitionMapping; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An Internal id that is used to identify this mapping set when specific mappings are made.
    property identity : String read GetIdentityST write SetIdentityST;
    // An Internal id that is used to identify this mapping set when specific mappings are made.
    property identityElement : TFhirId read FIdentity write SetIdentity;

    // Typed access to An absolute URI that identifies the specification that this mapping is expressed to.
    property uri : String read GetUriST write SetUriST;
    // An absolute URI that identifies the specification that this mapping is expressed to.
    property uriElement : TFhirUri read FUri write SetUri;

    // Typed access to A name for the specification that is being mapped to.
    property name : String read GetNameST write SetNameST;
    // A name for the specification that is being mapped to.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Comments about this mapping, including version notes, issues, scope limitations, and other important notes for usage.
    property comments : String read GetCommentsST write SetCommentsST;
    // Comments about this mapping, including version notes, issues, scope limitations, and other important notes for usage.
    property commentsElement : TFhirString read FComments write SetComments;

  end;

  TFhirStructureDefinitionMappingListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirStructureDefinitionMappingList;
    function GetCurrent : TFhirStructureDefinitionMapping;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirStructureDefinitionMappingList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirStructureDefinitionMapping read GetCurrent;
  end;

  TFhirStructureDefinitionMappingList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirStructureDefinitionMapping;
    procedure SetItemN(index : Integer; value : TFhirStructureDefinitionMapping);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirStructureDefinitionMappingList; Overload;
    function Clone : TFhirStructureDefinitionMappingList; Overload;
    function GetEnumerator : TFhirStructureDefinitionMappingListEnumerator;
    

    //  Add a FhirStructureDefinitionMapping to the end of the list.
    function Append : TFhirStructureDefinitionMapping;

    
    // Add an already existing FhirStructureDefinitionMapping to the end of the list.
    procedure AddItem(value : TFhirStructureDefinitionMapping); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirStructureDefinitionMapping) : Integer;
    

    // Insert FhirStructureDefinitionMapping before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirStructureDefinitionMapping;
    

    // Insert an existing FhirStructureDefinitionMapping before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirStructureDefinitionMapping);
    
    // Get the iIndexth FhirStructureDefinitionMapping. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirStructureDefinitionMapping);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirStructureDefinitionMapping;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirStructureDefinitionMappings[index : Integer] : TFhirStructureDefinitionMapping read GetItemN write SetItemN; default;
  End;

  // A snapshot view is expressed in a stand alone form that can be used and interpreted without considering the base StructureDefinition.
  TFhirStructureDefinitionSnapshot = class (TFhirBackboneElement)
  protected
    FelementList : TFhirElementDefinitionList;
    function GetElementList : TFhirElementDefinitionList;
    function GetHasElementList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirStructureDefinitionSnapshot; overload;
    function Clone : TFhirStructureDefinitionSnapshot; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Captures constraints on each element within the resource.
    property elementList : TFhirElementDefinitionList read GetElementList;
    property hasElementList : boolean read GetHasElementList;

  end;

  TFhirStructureDefinitionSnapshotListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirStructureDefinitionSnapshotList;
    function GetCurrent : TFhirStructureDefinitionSnapshot;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirStructureDefinitionSnapshotList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirStructureDefinitionSnapshot read GetCurrent;
  end;

  TFhirStructureDefinitionSnapshotList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirStructureDefinitionSnapshot;
    procedure SetItemN(index : Integer; value : TFhirStructureDefinitionSnapshot);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirStructureDefinitionSnapshotList; Overload;
    function Clone : TFhirStructureDefinitionSnapshotList; Overload;
    function GetEnumerator : TFhirStructureDefinitionSnapshotListEnumerator;
    

    //  Add a FhirStructureDefinitionSnapshot to the end of the list.
    function Append : TFhirStructureDefinitionSnapshot;

    
    // Add an already existing FhirStructureDefinitionSnapshot to the end of the list.
    procedure AddItem(value : TFhirStructureDefinitionSnapshot); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirStructureDefinitionSnapshot) : Integer;
    

    // Insert FhirStructureDefinitionSnapshot before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirStructureDefinitionSnapshot;
    

    // Insert an existing FhirStructureDefinitionSnapshot before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirStructureDefinitionSnapshot);
    
    // Get the iIndexth FhirStructureDefinitionSnapshot. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirStructureDefinitionSnapshot);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirStructureDefinitionSnapshot;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirStructureDefinitionSnapshots[index : Integer] : TFhirStructureDefinitionSnapshot read GetItemN write SetItemN; default;
  End;

  // A differential view is expressed relative to the base StructureDefinition - a statement of differences that it applies.
  TFhirStructureDefinitionDifferential = class (TFhirBackboneElement)
  protected
    FelementList : TFhirElementDefinitionList;
    function GetElementList : TFhirElementDefinitionList;
    function GetHasElementList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirStructureDefinitionDifferential; overload;
    function Clone : TFhirStructureDefinitionDifferential; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Captures constraints on each element within the resource.
    property elementList : TFhirElementDefinitionList read GetElementList;
    property hasElementList : boolean read GetHasElementList;

  end;

  TFhirStructureDefinitionDifferentialListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirStructureDefinitionDifferentialList;
    function GetCurrent : TFhirStructureDefinitionDifferential;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirStructureDefinitionDifferentialList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirStructureDefinitionDifferential read GetCurrent;
  end;

  TFhirStructureDefinitionDifferentialList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirStructureDefinitionDifferential;
    procedure SetItemN(index : Integer; value : TFhirStructureDefinitionDifferential);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirStructureDefinitionDifferentialList; Overload;
    function Clone : TFhirStructureDefinitionDifferentialList; Overload;
    function GetEnumerator : TFhirStructureDefinitionDifferentialListEnumerator;
    

    //  Add a FhirStructureDefinitionDifferential to the end of the list.
    function Append : TFhirStructureDefinitionDifferential;

    
    // Add an already existing FhirStructureDefinitionDifferential to the end of the list.
    procedure AddItem(value : TFhirStructureDefinitionDifferential); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirStructureDefinitionDifferential) : Integer;
    

    // Insert FhirStructureDefinitionDifferential before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirStructureDefinitionDifferential;
    

    // Insert an existing FhirStructureDefinitionDifferential before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirStructureDefinitionDifferential);
    
    // Get the iIndexth FhirStructureDefinitionDifferential. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirStructureDefinitionDifferential);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirStructureDefinitionDifferential;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirStructureDefinitionDifferentials[index : Integer] : TFhirStructureDefinitionDifferential read GetItemN write SetItemN; default;
  End;

  // A definition of a FHIR structure. This resource is used to describe the underlying resources, data types defined in FHIR, and also for describing extensions, and constraints on resources and data types.
  TFhirStructureDefinition = class (TFhirDomainResource)
  protected
    FUrl : TFhirUri;
    FidentifierList : TFhirIdentifierList;
    FVersion : TFhirString;
    FName : TFhirString;
    FDisplay : TFhirString;
    FStatus : TFhirEnum;
    FExperimental : TFhirBoolean;
    FPublisher : TFhirString;
    FcontactList : TFhirStructureDefinitionContactList;
    FDate : TFhirDateTime;
    FDescription : TFhirString;
    FuseContextList : TFhirCodeableConceptList;
    FRequirements : TFhirString;
    FCopyright : TFhirString;
    FcodeList : TFhirCodingList;
    FFhirVersion : TFhirId;
    FmappingList : TFhirStructureDefinitionMappingList;
    FKind : TFhirEnum;
    FConstrainedType : TFhirCode;
    FAbstract : TFhirBoolean;
    FContextType : TFhirEnum;
    FcontextList : TFhirStringList;
    FBase : TFhirUri;
    FSnapshot : TFhirStructureDefinitionSnapshot;
    FDifferential : TFhirStructureDefinitionDifferential;
    Procedure SetUrl(value : TFhirUri);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetVersion(value : TFhirString);
    Function GetVersionST : String;
    Procedure SetVersionST(value : String);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetDisplay(value : TFhirString);
    Function GetDisplayST : String;
    Procedure SetDisplayST(value : String);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirConformanceResourceStatusEnum;
    Procedure SetStatusST(value : TFhirConformanceResourceStatusEnum);
    Procedure SetExperimental(value : TFhirBoolean);
    Function GetExperimentalST : Boolean;
    Procedure SetExperimentalST(value : Boolean);
    Procedure SetPublisher(value : TFhirString);
    Function GetPublisherST : String;
    Procedure SetPublisherST(value : String);
    function GetContactList : TFhirStructureDefinitionContactList;
    function GetHasContactList : Boolean;
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    function GetUseContextList : TFhirCodeableConceptList;
    function GetHasUseContextList : Boolean;
    Procedure SetRequirements(value : TFhirString);
    Function GetRequirementsST : String;
    Procedure SetRequirementsST(value : String);
    Procedure SetCopyright(value : TFhirString);
    Function GetCopyrightST : String;
    Procedure SetCopyrightST(value : String);
    function GetCodeList : TFhirCodingList;
    function GetHasCodeList : Boolean;
    Procedure SetFhirVersion(value : TFhirId);
    Function GetFhirVersionST : String;
    Procedure SetFhirVersionST(value : String);
    function GetMappingList : TFhirStructureDefinitionMappingList;
    function GetHasMappingList : Boolean;
    Procedure SetKind(value : TFhirEnum);
    Function GetKindST : TFhirStructureDefinitionKindEnum;
    Procedure SetKindST(value : TFhirStructureDefinitionKindEnum);
    Procedure SetConstrainedType(value : TFhirCode);
    Function GetConstrainedTypeST : String;
    Procedure SetConstrainedTypeST(value : String);
    Procedure SetAbstract(value : TFhirBoolean);
    Function GetAbstractST : Boolean;
    Procedure SetAbstractST(value : Boolean);
    Procedure SetContextType(value : TFhirEnum);
    Function GetContextTypeST : TFhirExtensionContextEnum;
    Procedure SetContextTypeST(value : TFhirExtensionContextEnum);
    function GetContextList : TFhirStringList;
    function GetHasContextList : Boolean;
    Procedure SetBase(value : TFhirUri);
    Function GetBaseST : String;
    Procedure SetBaseST(value : String);
    Procedure SetSnapshot(value : TFhirStructureDefinitionSnapshot);
    Procedure SetDifferential(value : TFhirStructureDefinitionDifferential);
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirStructureDefinition; overload;
    function Clone : TFhirStructureDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URL that is used to identify this structure definition when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this structure definition is (or will be) {$IFNDEF FPC}published{$ENDIF}.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URL that is used to identify this structure definition when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this structure definition is (or will be) {$IFNDEF FPC}published{$ENDIF}.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Formal identifier that is used to identify this StructureDefinition when it is represented in other formats, or referenced in a specification, model, design or an instance  (should be globally unique OID, UUID, or URI), (if it's not possible to use the literal URI).
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier that is used to identify this version of the StructureDefinition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the StructureDefinition author manually.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the StructureDefinition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the StructureDefinition author manually.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A free text natural language name identifying the StructureDefinition.
    property name : String read GetNameST write SetNameST;
    // A free text natural language name identifying the StructureDefinition.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Defined so that applications can use this name when displaying the value of the extension to the user.
    property display : String read GetDisplayST write SetDisplayST;
    // Defined so that applications can use this name when displaying the value of the extension to the user.
    property displayElement : TFhirString read FDisplay write SetDisplay;

    // The status of the StructureDefinition.
    property status : TFhirConformanceResourceStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to This StructureDefinition was authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // This StructureDefinition was authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The name of the individual or organization that {$IFNDEF FPC}published{$ENDIF} the structure definition.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the individual or organization that {$IFNDEF FPC}published{$ENDIF} the structure definition.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contacts to assist a user in finding and communicating with the publisher.
    property contactList : TFhirStructureDefinitionContactList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to The date this version of the structure definition was {$IFNDEF FPC}published{$ENDIF}. The date must change when the business version changes, if it does, and it must change if the status code changes. In addition, it should change when the substantive content of the structure definition changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date this version of the structure definition was {$IFNDEF FPC}published{$ENDIF}. The date must change when the business version changes, if it does, and it must change if the status code changes. In addition, it should change when the substantive content of the structure definition changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to A free text natural language description of the StructureDefinition and its use.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the StructureDefinition and its use.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These terms may be used to assist with indexing and searching of structure definitions.
    property useContextList : TFhirCodeableConceptList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // Typed access to Explains why this structure definition is needed and why it's been constrained as it has.
    property requirements : String read GetRequirementsST write SetRequirementsST;
    // Explains why this structure definition is needed and why it's been constrained as it has.
    property requirementsElement : TFhirString read FRequirements write SetRequirements;

    // Typed access to A copyright statement relating to the structure definition and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the details of the constraints and mappings.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the structure definition and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the details of the constraints and mappings.
    property copyrightElement : TFhirString read FCopyright write SetCopyright;

    // A set of terms from external terminologies that may be used to assist with indexing and searching of templates.
    property codeList : TFhirCodingList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // Typed access to The version of the FHIR specification on which this StructureDefinition is based - this is the formal version of the specification, without the revision number, e.g. [publication].[major].[minor], which is 1.0.2 for this version.
    property fhirVersion : String read GetFhirVersionST write SetFhirVersionST;
    // The version of the FHIR specification on which this StructureDefinition is based - this is the formal version of the specification, without the revision number, e.g. [publication].[major].[minor], which is 1.0.2 for this version.
    property fhirVersionElement : TFhirId read FFhirVersion write SetFhirVersion;

    // An external specification that the content is mapped to.
    property mappingList : TFhirStructureDefinitionMappingList read GetMappingList;
    property hasMappingList : boolean read GetHasMappingList;

    // Defines the kind of structure that this definition is describing.
    property kind : TFhirStructureDefinitionKindEnum read GetKindST write SetKindST;
    property kindElement : TFhirEnum read FKind write SetKind;

    // Typed access to The type of type that is being constrained - a data type, an extension, a resource, including abstract ones. If this field is present, it indicates that the structure definition is a constraint. If it is not present, then the structure definition is the definition of a base structure.
    property constrainedType : String read GetConstrainedTypeST write SetConstrainedTypeST;
    // The type of type that is being constrained - a data type, an extension, a resource, including abstract ones. If this field is present, it indicates that the structure definition is a constraint. If it is not present, then the structure definition is the definition of a base structure.
    property constrainedTypeElement : TFhirCode read FConstrainedType write SetConstrainedType;

    // Typed access to Whether structure this definition describes is abstract or not  - that is, whether an actual exchanged item can ever be of this type.
    property abstract : Boolean read GetAbstractST write SetAbstractST;
    // Whether structure this definition describes is abstract or not  - that is, whether an actual exchanged item can ever be of this type.
    property abstractElement : TFhirBoolean read FAbstract write SetAbstract;

    // If this is an extension, Identifies the context within FHIR resources where the extension can be used.
    property contextType : TFhirExtensionContextEnum read GetContextTypeST write SetContextTypeST;
    property contextTypeElement : TFhirEnum read FContextType write SetContextType;

    // Identifies the types of resource or data type elements to which the extension can be applied.
    property contextList : TFhirStringList read GetContextList;
    property hasContextList : boolean read GetHasContextList;

    // Typed access to An absolute URI that is the base structure from which this set of constraints is derived.
    property base : String read GetBaseST write SetBaseST;
    // An absolute URI that is the base structure from which this set of constraints is derived.
    property baseElement : TFhirUri read FBase write SetBase;

    // Typed access to A snapshot view is expressed in a stand alone form that can be used and interpreted without considering the base StructureDefinition. (defined for API consistency)
    property snapshot : TFhirStructureDefinitionSnapshot read FSnapshot write SetSnapshot;
    // A snapshot view is expressed in a stand alone form that can be used and interpreted without considering the base StructureDefinition.
    property snapshotElement : TFhirStructureDefinitionSnapshot read FSnapshot write SetSnapshot;

    // Typed access to A differential view is expressed relative to the base StructureDefinition - a statement of differences that it applies. (defined for API consistency)
    property differential : TFhirStructureDefinitionDifferential read FDifferential write SetDifferential;
    // A differential view is expressed relative to the base StructureDefinition - a statement of differences that it applies.
    property differentialElement : TFhirStructureDefinitionDifferential read FDifferential write SetDifferential;

  end;

  TFhirStructureDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirStructureDefinitionList;
    function GetCurrent : TFhirStructureDefinition;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirStructureDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirStructureDefinition read GetCurrent;
  end;

  TFhirStructureDefinitionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirStructureDefinition;
    procedure SetItemN(index : Integer; value : TFhirStructureDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirStructureDefinitionList; Overload;
    function Clone : TFhirStructureDefinitionList; Overload;
    function GetEnumerator : TFhirStructureDefinitionListEnumerator;
    

    //  Add a FhirStructureDefinition to the end of the list.
    function Append : TFhirStructureDefinition;

    
    // Add an already existing FhirStructureDefinition to the end of the list.
    procedure AddItem(value : TFhirStructureDefinition); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirStructureDefinition) : Integer;
    

    // Insert FhirStructureDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirStructureDefinition;
    

    // Insert an existing FhirStructureDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirStructureDefinition);
    
    // Get the iIndexth FhirStructureDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirStructureDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirStructureDefinition;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirStructureDefinitions[index : Integer] : TFhirStructureDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_STRUCTUREDEFINITION}

{$IFDEF FHIR_TESTSCRIPT}

  // Contacts to assist a user in finding and communicating with the publisher.
  TFhirTestScriptContact = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FtelecomList : TFhirContactPointList;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptContact; overload;
    function Clone : TFhirTestScriptContact; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The name of an individual to contact regarding the Test Script.
    property name : String read GetNameST write SetNameST;
    // The name of an individual to contact regarding the Test Script.
    property nameElement : TFhirString read FName write SetName;

    // Contact details for individual (if a name was provided) or the publisher.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

  end;

  TFhirTestScriptContactListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptContactList;
    function GetCurrent : TFhirTestScriptContact;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptContactList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptContact read GetCurrent;
  end;

  TFhirTestScriptContactList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestScriptContact;
    procedure SetItemN(index : Integer; value : TFhirTestScriptContact);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestScriptContactList; Overload;
    function Clone : TFhirTestScriptContactList; Overload;
    function GetEnumerator : TFhirTestScriptContactListEnumerator;
    

    //  Add a FhirTestScriptContact to the end of the list.
    function Append : TFhirTestScriptContact;

    
    // Add an already existing FhirTestScriptContact to the end of the list.
    procedure AddItem(value : TFhirTestScriptContact); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptContact) : Integer;
    

    // Insert FhirTestScriptContact before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptContact;
    

    // Insert an existing FhirTestScriptContact before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptContact);
    
    // Get the iIndexth FhirTestScriptContact. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptContact);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptContact;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirTestScriptContacts[index : Integer] : TFhirTestScriptContact read GetItemN write SetItemN; default;
  End;

  // The required capability must exist and are assumed to function correctly on the FHIR server being tested.
  TFhirTestScriptMetadata = class (TFhirBackboneElement)
  protected
    Flink_List : TFhirTestScriptMetadataLinkList;
    FcapabilityList : TFhirTestScriptMetadataCapabilityList;
    function GetLink_List : TFhirTestScriptMetadataLinkList;
    function GetHasLink_List : Boolean;
    function GetCapabilityList : TFhirTestScriptMetadataCapabilityList;
    function GetHasCapabilityList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptMetadata; overload;
    function Clone : TFhirTestScriptMetadata; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A link to the FHIR specification that this test is covering.
    property link_List : TFhirTestScriptMetadataLinkList read GetLink_List;
    property hasLink_List : boolean read GetHasLink_List;

    // Capabilities that must exist and are assumed to function correctly on the FHIR server being tested.
    property capabilityList : TFhirTestScriptMetadataCapabilityList read GetCapabilityList;
    property hasCapabilityList : boolean read GetHasCapabilityList;

  end;

  TFhirTestScriptMetadataListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptMetadataList;
    function GetCurrent : TFhirTestScriptMetadata;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptMetadataList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptMetadata read GetCurrent;
  end;

  TFhirTestScriptMetadataList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestScriptMetadata;
    procedure SetItemN(index : Integer; value : TFhirTestScriptMetadata);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestScriptMetadataList; Overload;
    function Clone : TFhirTestScriptMetadataList; Overload;
    function GetEnumerator : TFhirTestScriptMetadataListEnumerator;
    

    //  Add a FhirTestScriptMetadata to the end of the list.
    function Append : TFhirTestScriptMetadata;

    
    // Add an already existing FhirTestScriptMetadata to the end of the list.
    procedure AddItem(value : TFhirTestScriptMetadata); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptMetadata) : Integer;
    

    // Insert FhirTestScriptMetadata before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptMetadata;
    

    // Insert an existing FhirTestScriptMetadata before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptMetadata);
    
    // Get the iIndexth FhirTestScriptMetadata. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptMetadata);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptMetadata;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirTestScriptMetadata[index : Integer] : TFhirTestScriptMetadata read GetItemN write SetItemN; default;
  End;

  // A link to the FHIR specification that this test is covering.
  TFhirTestScriptMetadataLink = class (TFhirBackboneElement)
  protected
    FUrl : TFhirUri;
    FDescription : TFhirString;
    Procedure SetUrl(value : TFhirUri);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptMetadataLink; overload;
    function Clone : TFhirTestScriptMetadataLink; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to URL to a particular requirement or feature within the FHIR specification.
    property url : String read GetUrlST write SetUrlST;
    // URL to a particular requirement or feature within the FHIR specification.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to Short description of the link.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Short description of the link.
    property descriptionElement : TFhirString read FDescription write SetDescription;

  end;

  TFhirTestScriptMetadataLinkListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptMetadataLinkList;
    function GetCurrent : TFhirTestScriptMetadataLink;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptMetadataLinkList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptMetadataLink read GetCurrent;
  end;

  TFhirTestScriptMetadataLinkList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestScriptMetadataLink;
    procedure SetItemN(index : Integer; value : TFhirTestScriptMetadataLink);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestScriptMetadataLinkList; Overload;
    function Clone : TFhirTestScriptMetadataLinkList; Overload;
    function GetEnumerator : TFhirTestScriptMetadataLinkListEnumerator;
    

    //  Add a FhirTestScriptMetadataLink to the end of the list.
    function Append : TFhirTestScriptMetadataLink;

    
    // Add an already existing FhirTestScriptMetadataLink to the end of the list.
    procedure AddItem(value : TFhirTestScriptMetadataLink); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptMetadataLink) : Integer;
    

    // Insert FhirTestScriptMetadataLink before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptMetadataLink;
    

    // Insert an existing FhirTestScriptMetadataLink before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptMetadataLink);
    
    // Get the iIndexth FhirTestScriptMetadataLink. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptMetadataLink);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptMetadataLink;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirTestScriptMetadataLinks[index : Integer] : TFhirTestScriptMetadataLink read GetItemN write SetItemN; default;
  End;

  // Capabilities that must exist and are assumed to function correctly on the FHIR server being tested.
  TFhirTestScriptMetadataCapability = class (TFhirBackboneElement)
  protected
    FRequired : TFhirBoolean;
    FValidated : TFhirBoolean;
    FDescription : TFhirString;
    FDestination : TFhirInteger;
    Flink_List : TFhirUriList;
    FConformance : TFhirReference{TFhirConformance};
    Procedure SetRequired(value : TFhirBoolean);
    Function GetRequiredST : Boolean;
    Procedure SetRequiredST(value : Boolean);
    Procedure SetValidated(value : TFhirBoolean);
    Function GetValidatedST : Boolean;
    Procedure SetValidatedST(value : Boolean);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetDestination(value : TFhirInteger);
    Function GetDestinationST : String;
    Procedure SetDestinationST(value : String);
    function GetLink_List : TFhirUriList;
    function GetHasLink_List : Boolean;
    Procedure SetConformance(value : TFhirReference{TFhirConformance});
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptMetadataCapability; overload;
    function Clone : TFhirTestScriptMetadataCapability; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Whether or not the test execution will require the given capabilities of the server in order for this test script to execute.
    property required : Boolean read GetRequiredST write SetRequiredST;
    // Whether or not the test execution will require the given capabilities of the server in order for this test script to execute.
    property requiredElement : TFhirBoolean read FRequired write SetRequired;

    // Typed access to Whether or not the test execution will validate the given capabilities of the server in order for this test script to execute.
    property validated : Boolean read GetValidatedST write SetValidatedST;
    // Whether or not the test execution will validate the given capabilities of the server in order for this test script to execute.
    property validatedElement : TFhirBoolean read FValidated write SetValidated;

    // Typed access to Description of the capabilities that this test script is requiring the server to support.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Description of the capabilities that this test script is requiring the server to support.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Which server these requirements apply to.
    property destination : String read GetDestinationST write SetDestinationST;
    // Which server these requirements apply to.
    property destinationElement : TFhirInteger read FDestination write SetDestination;

    // Links to the FHIR specification that describes this interaction and the resources involved in more detail.
    property link_List : TFhirUriList read GetLink_List;
    property hasLink_List : boolean read GetHasLink_List;

    // Typed access to Minimum conformance required of server for test script to execute successfully.   If server does not meet at a minimum the reference conformance definition, then all tests in this script are skipped. (defined for API consistency)
    property conformance : TFhirReference{TFhirConformance} read FConformance write SetConformance;
    // Minimum conformance required of server for test script to execute successfully.   If server does not meet at a minimum the reference conformance definition, then all tests in this script are skipped.
    property conformanceElement : TFhirReference{TFhirConformance} read FConformance write SetConformance;

  end;

  TFhirTestScriptMetadataCapabilityListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptMetadataCapabilityList;
    function GetCurrent : TFhirTestScriptMetadataCapability;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptMetadataCapabilityList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptMetadataCapability read GetCurrent;
  end;

  TFhirTestScriptMetadataCapabilityList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestScriptMetadataCapability;
    procedure SetItemN(index : Integer; value : TFhirTestScriptMetadataCapability);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestScriptMetadataCapabilityList; Overload;
    function Clone : TFhirTestScriptMetadataCapabilityList; Overload;
    function GetEnumerator : TFhirTestScriptMetadataCapabilityListEnumerator;
    

    //  Add a FhirTestScriptMetadataCapability to the end of the list.
    function Append : TFhirTestScriptMetadataCapability;

    
    // Add an already existing FhirTestScriptMetadataCapability to the end of the list.
    procedure AddItem(value : TFhirTestScriptMetadataCapability); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptMetadataCapability) : Integer;
    

    // Insert FhirTestScriptMetadataCapability before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptMetadataCapability;
    

    // Insert an existing FhirTestScriptMetadataCapability before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptMetadataCapability);
    
    // Get the iIndexth FhirTestScriptMetadataCapability. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptMetadataCapability);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptMetadataCapability;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirTestScriptMetadataCapabilities[index : Integer] : TFhirTestScriptMetadataCapability read GetItemN write SetItemN; default;
  End;

  // Fixture in the test script - by reference (uri). All fixtures are required for the test script to execute.
  TFhirTestScriptFixture = class (TFhirBackboneElement)
  protected
    FAutocreate : TFhirBoolean;
    FAutodelete : TFhirBoolean;
    FResource : TFhirReference{TFhirReference};
    Procedure SetAutocreate(value : TFhirBoolean);
    Function GetAutocreateST : Boolean;
    Procedure SetAutocreateST(value : Boolean);
    Procedure SetAutodelete(value : TFhirBoolean);
    Function GetAutodeleteST : Boolean;
    Procedure SetAutodeleteST(value : Boolean);
    Procedure SetResource(value : TFhirReference{TFhirReference});
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptFixture; overload;
    function Clone : TFhirTestScriptFixture; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Whether or not to implicitly create the fixture during setup. If true, the fixture is automatically created on each server being tested during setup, therefore no create operation is required for this fixture in the TestScript.setup section.
    property autocreate : Boolean read GetAutocreateST write SetAutocreateST;
    // Whether or not to implicitly create the fixture during setup. If true, the fixture is automatically created on each server being tested during setup, therefore no create operation is required for this fixture in the TestScript.setup section.
    property autocreateElement : TFhirBoolean read FAutocreate write SetAutocreate;

    // Typed access to Whether or not to implicitly delete the fixture during teardown If true, the fixture is automatically deleted on each server being tested during teardown, therefore no delete operation is required for this fixture in the TestScript.teardown section.
    property autodelete : Boolean read GetAutodeleteST write SetAutodeleteST;
    // Whether or not to implicitly delete the fixture during teardown If true, the fixture is automatically deleted on each server being tested during teardown, therefore no delete operation is required for this fixture in the TestScript.teardown section.
    property autodeleteElement : TFhirBoolean read FAutodelete write SetAutodelete;

    // Typed access to Reference to the resource (containing the contents of the resource needed for operations). (defined for API consistency)
    property resource : TFhirReference{TFhirReference} read FResource write SetResource;
    // Reference to the resource (containing the contents of the resource needed for operations).
    property resourceElement : TFhirReference{TFhirReference} read FResource write SetResource;

  end;

  TFhirTestScriptFixtureListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptFixtureList;
    function GetCurrent : TFhirTestScriptFixture;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptFixtureList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptFixture read GetCurrent;
  end;

  TFhirTestScriptFixtureList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestScriptFixture;
    procedure SetItemN(index : Integer; value : TFhirTestScriptFixture);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestScriptFixtureList; Overload;
    function Clone : TFhirTestScriptFixtureList; Overload;
    function GetEnumerator : TFhirTestScriptFixtureListEnumerator;
    

    //  Add a FhirTestScriptFixture to the end of the list.
    function Append : TFhirTestScriptFixture;

    
    // Add an already existing FhirTestScriptFixture to the end of the list.
    procedure AddItem(value : TFhirTestScriptFixture); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptFixture) : Integer;
    

    // Insert FhirTestScriptFixture before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptFixture;
    

    // Insert an existing FhirTestScriptFixture before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptFixture);
    
    // Get the iIndexth FhirTestScriptFixture. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptFixture);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptFixture;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirTestScriptFixtures[index : Integer] : TFhirTestScriptFixture read GetItemN write SetItemN; default;
  End;

  // Variable is set based either on element value in response body or on header field value in the response headers.
  TFhirTestScriptVariable = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FHeaderField : TFhirString;
    FPath : TFhirString;
    FSourceId : TFhirId;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetHeaderField(value : TFhirString);
    Function GetHeaderFieldST : String;
    Procedure SetHeaderFieldST(value : String);
    Procedure SetPath(value : TFhirString);
    Function GetPathST : String;
    Procedure SetPathST(value : String);
    Procedure SetSourceId(value : TFhirId);
    Function GetSourceIdST : String;
    Procedure SetSourceIdST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptVariable; overload;
    function Clone : TFhirTestScriptVariable; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Descriptive name for this variable.
    property name : String read GetNameST write SetNameST;
    // Descriptive name for this variable.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Will be used to grab the HTTP header field value from the headers that sourceId is pointing to.
    property headerField : String read GetHeaderFieldST write SetHeaderFieldST;
    // Will be used to grab the HTTP header field value from the headers that sourceId is pointing to.
    property headerFieldElement : TFhirString read FHeaderField write SetHeaderField;

    // Typed access to XPath or JSONPath against the fixture body.  When variables are defined, either headerField must be specified or path, but not both.
    property path : String read GetPathST write SetPathST;
    // XPath or JSONPath against the fixture body.  When variables are defined, either headerField must be specified or path, but not both.
    property pathElement : TFhirString read FPath write SetPath;

    // Typed access to Fixture to evaluate the XPath/JSONPath expression or the headerField  against within this variable.
    property sourceId : String read GetSourceIdST write SetSourceIdST;
    // Fixture to evaluate the XPath/JSONPath expression or the headerField  against within this variable.
    property sourceIdElement : TFhirId read FSourceId write SetSourceId;

  end;

  TFhirTestScriptVariableListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptVariableList;
    function GetCurrent : TFhirTestScriptVariable;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptVariableList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptVariable read GetCurrent;
  end;

  TFhirTestScriptVariableList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestScriptVariable;
    procedure SetItemN(index : Integer; value : TFhirTestScriptVariable);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestScriptVariableList; Overload;
    function Clone : TFhirTestScriptVariableList; Overload;
    function GetEnumerator : TFhirTestScriptVariableListEnumerator;
    

    //  Add a FhirTestScriptVariable to the end of the list.
    function Append : TFhirTestScriptVariable;

    
    // Add an already existing FhirTestScriptVariable to the end of the list.
    procedure AddItem(value : TFhirTestScriptVariable); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptVariable) : Integer;
    

    // Insert FhirTestScriptVariable before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptVariable;
    

    // Insert an existing FhirTestScriptVariable before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptVariable);
    
    // Get the iIndexth FhirTestScriptVariable. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptVariable);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptVariable;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirTestScriptVariables[index : Integer] : TFhirTestScriptVariable read GetItemN write SetItemN; default;
  End;

  // A series of required setup operations before tests are executed.
  TFhirTestScriptSetup = class (TFhirBackboneElement)
  protected
    FMetadata : TFhirTestScriptMetadata;
    FactionList : TFhirTestScriptSetupActionList;
    Procedure SetMetadata(value : TFhirTestScriptMetadata);
    function GetActionList : TFhirTestScriptSetupActionList;
    function GetHasActionList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptSetup; overload;
    function Clone : TFhirTestScriptSetup; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Capabilities that must exist and are assumed to function correctly on the FHIR server being tested. (defined for API consistency)
    property metadata : TFhirTestScriptMetadata read FMetadata write SetMetadata;
    // Capabilities that must exist and are assumed to function correctly on the FHIR server being tested.
    property metadataElement : TFhirTestScriptMetadata read FMetadata write SetMetadata;

    // Action would contain either an operation or an assertion.
    property actionList : TFhirTestScriptSetupActionList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

  end;

  TFhirTestScriptSetupListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptSetupList;
    function GetCurrent : TFhirTestScriptSetup;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptSetupList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptSetup read GetCurrent;
  end;

  TFhirTestScriptSetupList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestScriptSetup;
    procedure SetItemN(index : Integer; value : TFhirTestScriptSetup);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestScriptSetupList; Overload;
    function Clone : TFhirTestScriptSetupList; Overload;
    function GetEnumerator : TFhirTestScriptSetupListEnumerator;
    

    //  Add a FhirTestScriptSetup to the end of the list.
    function Append : TFhirTestScriptSetup;

    
    // Add an already existing FhirTestScriptSetup to the end of the list.
    procedure AddItem(value : TFhirTestScriptSetup); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptSetup) : Integer;
    

    // Insert FhirTestScriptSetup before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptSetup;
    

    // Insert an existing FhirTestScriptSetup before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptSetup);
    
    // Get the iIndexth FhirTestScriptSetup. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptSetup);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptSetup;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirTestScriptSetups[index : Integer] : TFhirTestScriptSetup read GetItemN write SetItemN; default;
  End;

  // Action would contain either an operation or an assertion.
  TFhirTestScriptSetupAction = class (TFhirBackboneElement)
  protected
    FOperation : TFhirTestScriptSetupActionOperation;
    FAssert : TFhirTestScriptSetupActionAssert;
    Procedure SetOperation(value : TFhirTestScriptSetupActionOperation);
    Procedure SetAssert(value : TFhirTestScriptSetupActionAssert);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptSetupAction; overload;
    function Clone : TFhirTestScriptSetupAction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The operation to perform. (defined for API consistency)
    property operation : TFhirTestScriptSetupActionOperation read FOperation write SetOperation;
    // The operation to perform.
    property operationElement : TFhirTestScriptSetupActionOperation read FOperation write SetOperation;

    // Typed access to Evaluates the results of previous operations to determine if the server under test behaves appropriately. (defined for API consistency)
    property assert : TFhirTestScriptSetupActionAssert read FAssert write SetAssert;
    // Evaluates the results of previous operations to determine if the server under test behaves appropriately.
    property assertElement : TFhirTestScriptSetupActionAssert read FAssert write SetAssert;

  end;

  TFhirTestScriptSetupActionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptSetupActionList;
    function GetCurrent : TFhirTestScriptSetupAction;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptSetupActionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptSetupAction read GetCurrent;
  end;

  TFhirTestScriptSetupActionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestScriptSetupAction;
    procedure SetItemN(index : Integer; value : TFhirTestScriptSetupAction);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestScriptSetupActionList; Overload;
    function Clone : TFhirTestScriptSetupActionList; Overload;
    function GetEnumerator : TFhirTestScriptSetupActionListEnumerator;
    

    //  Add a FhirTestScriptSetupAction to the end of the list.
    function Append : TFhirTestScriptSetupAction;

    
    // Add an already existing FhirTestScriptSetupAction to the end of the list.
    procedure AddItem(value : TFhirTestScriptSetupAction); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptSetupAction) : Integer;
    

    // Insert FhirTestScriptSetupAction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptSetupAction;
    

    // Insert an existing FhirTestScriptSetupAction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptSetupAction);
    
    // Get the iIndexth FhirTestScriptSetupAction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptSetupAction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptSetupAction;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirTestScriptSetupActions[index : Integer] : TFhirTestScriptSetupAction read GetItemN write SetItemN; default;
  End;

  // The operation to perform.
  TFhirTestScriptSetupActionOperation = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCoding;
    FResource : TFhirCode;
    FLabel_ : TFhirString;
    FDescription : TFhirString;
    FAccept : TFhirEnum;
    FContentType : TFhirEnum;
    FDestination : TFhirInteger;
    FEncodeRequestUrl : TFhirBoolean;
    FParams : TFhirString;
    FrequestHeaderList : TFhirTestScriptSetupActionOperationRequestHeaderList;
    FResponseId : TFhirId;
    FSourceId : TFhirId;
    FTargetId : TFhirId;
    FUrl : TFhirString;
    Procedure SetType_(value : TFhirCoding);
    Procedure SetResource(value : TFhirCode);
    Function GetResourceST : String;
    Procedure SetResourceST(value : String);
    Procedure SetLabel_(value : TFhirString);
    Function GetLabel_ST : String;
    Procedure SetLabel_ST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetAccept(value : TFhirEnum);
    Function GetAcceptST : TFhirContentTypeEnum;
    Procedure SetAcceptST(value : TFhirContentTypeEnum);
    Procedure SetContentType(value : TFhirEnum);
    Function GetContentTypeST : TFhirContentTypeEnum;
    Procedure SetContentTypeST(value : TFhirContentTypeEnum);
    Procedure SetDestination(value : TFhirInteger);
    Function GetDestinationST : String;
    Procedure SetDestinationST(value : String);
    Procedure SetEncodeRequestUrl(value : TFhirBoolean);
    Function GetEncodeRequestUrlST : Boolean;
    Procedure SetEncodeRequestUrlST(value : Boolean);
    Procedure SetParams(value : TFhirString);
    Function GetParamsST : String;
    Procedure SetParamsST(value : String);
    function GetRequestHeaderList : TFhirTestScriptSetupActionOperationRequestHeaderList;
    function GetHasRequestHeaderList : Boolean;
    Procedure SetResponseId(value : TFhirId);
    Function GetResponseIdST : String;
    Procedure SetResponseIdST(value : String);
    Procedure SetSourceId(value : TFhirId);
    Function GetSourceIdST : String;
    Procedure SetSourceIdST(value : String);
    Procedure SetTargetId(value : TFhirId);
    Function GetTargetIdST : String;
    Procedure SetTargetIdST(value : String);
    Procedure SetUrl(value : TFhirString);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptSetupActionOperation; overload;
    function Clone : TFhirTestScriptSetupActionOperation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Server interaction or operation type. (defined for API consistency)
    property type_ : TFhirCoding read FType_ write SetType_;
    // Server interaction or operation type.
    property type_Element : TFhirCoding read FType_ write SetType_;

    // Typed access to The type of the resource.  See http://hl7-fhir.github.io/resourcelist.html.
    property resource : String read GetResourceST write SetResourceST;
    // The type of the resource.  See http://hl7-fhir.github.io/resourcelist.html.
    property resourceElement : TFhirCode read FResource write SetResource;

    // Typed access to The label would be used for tracking/logging purposes by test engines.
    property label_ : String read GetLabel_ST write SetLabel_ST;
    // The label would be used for tracking/logging purposes by test engines.
    property label_Element : TFhirString read FLabel_ write SetLabel_;

    // Typed access to The description would be used by test engines for tracking and reporting purposes.
    property description : String read GetDescriptionST write SetDescriptionST;
    // The description would be used by test engines for tracking and reporting purposes.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // The content-type or mime-type to use for RESTful operation in the 'Accept' header.
    property accept : TFhirContentTypeEnum read GetAcceptST write SetAcceptST;
    property acceptElement : TFhirEnum read FAccept write SetAccept;

    // The content-type or mime-type to use for RESTful operation in the 'Content-Type' header.
    property contentType : TFhirContentTypeEnum read GetContentTypeST write SetContentTypeST;
    property contentTypeElement : TFhirEnum read FContentType write SetContentType;

    // Typed access to Which server to perform the operation on.
    property destination : String read GetDestinationST write SetDestinationST;
    // Which server to perform the operation on.
    property destinationElement : TFhirInteger read FDestination write SetDestination;

    // Typed access to Whether or not to implicitly send the request url in encoded format. The default is true to match the standard RESTful client behavior. Set to false when communicating with a server that does not support encoded url paths.
    property encodeRequestUrl : Boolean read GetEncodeRequestUrlST write SetEncodeRequestUrlST;
    // Whether or not to implicitly send the request url in encoded format. The default is true to match the standard RESTful client behavior. Set to false when communicating with a server that does not support encoded url paths.
    property encodeRequestUrlElement : TFhirBoolean read FEncodeRequestUrl write SetEncodeRequestUrl;

    // Typed access to Path plus parameters after [type].  Used to set parts of the request URL explicitly.
    property params : String read GetParamsST write SetParamsST;
    // Path plus parameters after [type].  Used to set parts of the request URL explicitly.
    property paramsElement : TFhirString read FParams write SetParams;

    // Header elements would be used to set HTTP headers.
    property requestHeaderList : TFhirTestScriptSetupActionOperationRequestHeaderList read GetRequestHeaderList;
    property hasRequestHeaderList : boolean read GetHasRequestHeaderList;

    // Typed access to The fixture id (maybe new) to map to the response.
    property responseId : String read GetResponseIdST write SetResponseIdST;
    // The fixture id (maybe new) to map to the response.
    property responseIdElement : TFhirId read FResponseId write SetResponseId;

    // Typed access to The id of the fixture used as the body of a PUT or POST request.
    property sourceId : String read GetSourceIdST write SetSourceIdST;
    // The id of the fixture used as the body of a PUT or POST request.
    property sourceIdElement : TFhirId read FSourceId write SetSourceId;

    // Typed access to Id of fixture used for extracting the [id],  [type], and [vid] for GET requests.
    property targetId : String read GetTargetIdST write SetTargetIdST;
    // Id of fixture used for extracting the [id],  [type], and [vid] for GET requests.
    property targetIdElement : TFhirId read FTargetId write SetTargetId;

    // Typed access to Complete request URL.
    property url : String read GetUrlST write SetUrlST;
    // Complete request URL.
    property urlElement : TFhirString read FUrl write SetUrl;

  end;

  TFhirTestScriptSetupActionOperationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptSetupActionOperationList;
    function GetCurrent : TFhirTestScriptSetupActionOperation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptSetupActionOperationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptSetupActionOperation read GetCurrent;
  end;

  TFhirTestScriptSetupActionOperationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestScriptSetupActionOperation;
    procedure SetItemN(index : Integer; value : TFhirTestScriptSetupActionOperation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestScriptSetupActionOperationList; Overload;
    function Clone : TFhirTestScriptSetupActionOperationList; Overload;
    function GetEnumerator : TFhirTestScriptSetupActionOperationListEnumerator;
    

    //  Add a FhirTestScriptSetupActionOperation to the end of the list.
    function Append : TFhirTestScriptSetupActionOperation;

    
    // Add an already existing FhirTestScriptSetupActionOperation to the end of the list.
    procedure AddItem(value : TFhirTestScriptSetupActionOperation); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptSetupActionOperation) : Integer;
    

    // Insert FhirTestScriptSetupActionOperation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptSetupActionOperation;
    

    // Insert an existing FhirTestScriptSetupActionOperation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptSetupActionOperation);
    
    // Get the iIndexth FhirTestScriptSetupActionOperation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptSetupActionOperation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptSetupActionOperation;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirTestScriptSetupActionOperations[index : Integer] : TFhirTestScriptSetupActionOperation read GetItemN write SetItemN; default;
  End;

  // Header elements would be used to set HTTP headers.
  TFhirTestScriptSetupActionOperationRequestHeader = class (TFhirBackboneElement)
  protected
    FField : TFhirString;
    FValue : TFhirString;
    Procedure SetField(value : TFhirString);
    Function GetFieldST : String;
    Procedure SetFieldST(value : String);
    Procedure SetValue(value : TFhirString);
    Function GetValueST : String;
    Procedure SetValueST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptSetupActionOperationRequestHeader; overload;
    function Clone : TFhirTestScriptSetupActionOperationRequestHeader; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The HTTP header field e.g. "Accept".
    property field : String read GetFieldST write SetFieldST;
    // The HTTP header field e.g. "Accept".
    property fieldElement : TFhirString read FField write SetField;

    // Typed access to The value of the header e.g. "application/xml".
    property value : String read GetValueST write SetValueST;
    // The value of the header e.g. "application/xml".
    property valueElement : TFhirString read FValue write SetValue;

  end;

  TFhirTestScriptSetupActionOperationRequestHeaderListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptSetupActionOperationRequestHeaderList;
    function GetCurrent : TFhirTestScriptSetupActionOperationRequestHeader;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptSetupActionOperationRequestHeaderList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptSetupActionOperationRequestHeader read GetCurrent;
  end;

  TFhirTestScriptSetupActionOperationRequestHeaderList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestScriptSetupActionOperationRequestHeader;
    procedure SetItemN(index : Integer; value : TFhirTestScriptSetupActionOperationRequestHeader);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestScriptSetupActionOperationRequestHeaderList; Overload;
    function Clone : TFhirTestScriptSetupActionOperationRequestHeaderList; Overload;
    function GetEnumerator : TFhirTestScriptSetupActionOperationRequestHeaderListEnumerator;
    

    //  Add a FhirTestScriptSetupActionOperationRequestHeader to the end of the list.
    function Append : TFhirTestScriptSetupActionOperationRequestHeader;

    
    // Add an already existing FhirTestScriptSetupActionOperationRequestHeader to the end of the list.
    procedure AddItem(value : TFhirTestScriptSetupActionOperationRequestHeader); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptSetupActionOperationRequestHeader) : Integer;
    

    // Insert FhirTestScriptSetupActionOperationRequestHeader before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptSetupActionOperationRequestHeader;
    

    // Insert an existing FhirTestScriptSetupActionOperationRequestHeader before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptSetupActionOperationRequestHeader);
    
    // Get the iIndexth FhirTestScriptSetupActionOperationRequestHeader. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptSetupActionOperationRequestHeader);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptSetupActionOperationRequestHeader;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirTestScriptSetupActionOperationRequestHeaders[index : Integer] : TFhirTestScriptSetupActionOperationRequestHeader read GetItemN write SetItemN; default;
  End;

  // Evaluates the results of previous operations to determine if the server under test behaves appropriately.
  TFhirTestScriptSetupActionAssert = class (TFhirBackboneElement)
  protected
    FLabel_ : TFhirString;
    FDescription : TFhirString;
    FDirection : TFhirEnum;
    FCompareToSourceId : TFhirString;
    FCompareToSourcePath : TFhirString;
    FContentType : TFhirEnum;
    FHeaderField : TFhirString;
    FMinimumId : TFhirString;
    FNavigationLinks : TFhirBoolean;
    FOperator : TFhirEnum;
    FPath : TFhirString;
    FResource : TFhirCode;
    FResponse : TFhirEnum;
    FResponseCode : TFhirString;
    FSourceId : TFhirId;
    FValidateProfileId : TFhirId;
    FValue : TFhirString;
    FWarningOnly : TFhirBoolean;
    Procedure SetLabel_(value : TFhirString);
    Function GetLabel_ST : String;
    Procedure SetLabel_ST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetDirection(value : TFhirEnum);
    Function GetDirectionST : TFhirAssertDirectionCodesEnum;
    Procedure SetDirectionST(value : TFhirAssertDirectionCodesEnum);
    Procedure SetCompareToSourceId(value : TFhirString);
    Function GetCompareToSourceIdST : String;
    Procedure SetCompareToSourceIdST(value : String);
    Procedure SetCompareToSourcePath(value : TFhirString);
    Function GetCompareToSourcePathST : String;
    Procedure SetCompareToSourcePathST(value : String);
    Procedure SetContentType(value : TFhirEnum);
    Function GetContentTypeST : TFhirContentTypeEnum;
    Procedure SetContentTypeST(value : TFhirContentTypeEnum);
    Procedure SetHeaderField(value : TFhirString);
    Function GetHeaderFieldST : String;
    Procedure SetHeaderFieldST(value : String);
    Procedure SetMinimumId(value : TFhirString);
    Function GetMinimumIdST : String;
    Procedure SetMinimumIdST(value : String);
    Procedure SetNavigationLinks(value : TFhirBoolean);
    Function GetNavigationLinksST : Boolean;
    Procedure SetNavigationLinksST(value : Boolean);
    Procedure SetOperator(value : TFhirEnum);
    Function GetOperatorST : TFhirAssertOperatorCodesEnum;
    Procedure SetOperatorST(value : TFhirAssertOperatorCodesEnum);
    Procedure SetPath(value : TFhirString);
    Function GetPathST : String;
    Procedure SetPathST(value : String);
    Procedure SetResource(value : TFhirCode);
    Function GetResourceST : String;
    Procedure SetResourceST(value : String);
    Procedure SetResponse(value : TFhirEnum);
    Function GetResponseST : TFhirAssertResponseCodeTypesEnum;
    Procedure SetResponseST(value : TFhirAssertResponseCodeTypesEnum);
    Procedure SetResponseCode(value : TFhirString);
    Function GetResponseCodeST : String;
    Procedure SetResponseCodeST(value : String);
    Procedure SetSourceId(value : TFhirId);
    Function GetSourceIdST : String;
    Procedure SetSourceIdST(value : String);
    Procedure SetValidateProfileId(value : TFhirId);
    Function GetValidateProfileIdST : String;
    Procedure SetValidateProfileIdST(value : String);
    Procedure SetValue(value : TFhirString);
    Function GetValueST : String;
    Procedure SetValueST(value : String);
    Procedure SetWarningOnly(value : TFhirBoolean);
    Function GetWarningOnlyST : Boolean;
    Procedure SetWarningOnlyST(value : Boolean);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptSetupActionAssert; overload;
    function Clone : TFhirTestScriptSetupActionAssert; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The label would be used for tracking/logging purposes by test engines.
    property label_ : String read GetLabel_ST write SetLabel_ST;
    // The label would be used for tracking/logging purposes by test engines.
    property label_Element : TFhirString read FLabel_ write SetLabel_;

    // Typed access to The description would be used by test engines for tracking and reporting purposes.
    property description : String read GetDescriptionST write SetDescriptionST;
    // The description would be used by test engines for tracking and reporting purposes.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // The direction to use for the assertion.
    property direction : TFhirAssertDirectionCodesEnum read GetDirectionST write SetDirectionST;
    property directionElement : TFhirEnum read FDirection write SetDirection;

    // Typed access to Id of fixture used to compare the "sourceId/path" evaluations to.
    property compareToSourceId : String read GetCompareToSourceIdST write SetCompareToSourceIdST;
    // Id of fixture used to compare the "sourceId/path" evaluations to.
    property compareToSourceIdElement : TFhirString read FCompareToSourceId write SetCompareToSourceId;

    // Typed access to XPath or JSONPath expression against fixture used to compare the "sourceId/path" evaluations to.
    property compareToSourcePath : String read GetCompareToSourcePathST write SetCompareToSourcePathST;
    // XPath or JSONPath expression against fixture used to compare the "sourceId/path" evaluations to.
    property compareToSourcePathElement : TFhirString read FCompareToSourcePath write SetCompareToSourcePath;

    // The content-type or mime-type to use for RESTful operation in the 'Content-Type' header.
    property contentType : TFhirContentTypeEnum read GetContentTypeST write SetContentTypeST;
    property contentTypeElement : TFhirEnum read FContentType write SetContentType;

    // Typed access to The HTTP header field name e.g. 'Location'.
    property headerField : String read GetHeaderFieldST write SetHeaderFieldST;
    // The HTTP header field name e.g. 'Location'.
    property headerFieldElement : TFhirString read FHeaderField write SetHeaderField;

    // Typed access to The ID of a fixture.  Asserts that the response contains at a minimumId the fixture specified by minimumId.
    property minimumId : String read GetMinimumIdST write SetMinimumIdST;
    // The ID of a fixture.  Asserts that the response contains at a minimumId the fixture specified by minimumId.
    property minimumIdElement : TFhirString read FMinimumId write SetMinimumId;

    // Typed access to Whether or not the test execution performs validation on the bundle navigation links.
    property navigationLinks : Boolean read GetNavigationLinksST write SetNavigationLinksST;
    // Whether or not the test execution performs validation on the bundle navigation links.
    property navigationLinksElement : TFhirBoolean read FNavigationLinks write SetNavigationLinks;

    // The operator type.
    property operator : TFhirAssertOperatorCodesEnum read GetOperatorST write SetOperatorST;
    property operatorElement : TFhirEnum read FOperator write SetOperator;

    // Typed access to The XPath or JSONPath expression to be evaluated against the fixture representing the response received from server.
    property path : String read GetPathST write SetPathST;
    // The XPath or JSONPath expression to be evaluated against the fixture representing the response received from server.
    property pathElement : TFhirString read FPath write SetPath;

    // Typed access to The type of the resource.  See http://hl7-fhir.github.io/resourcelist.html.
    property resource : String read GetResourceST write SetResourceST;
    // The type of the resource.  See http://hl7-fhir.github.io/resourcelist.html.
    property resourceElement : TFhirCode read FResource write SetResource;

    // okay | created | noContent | notModified | bad | forbidden | notFound | methodNotAllowed | conflict | gone | preconditionFailed | unprocessable.
    property response : TFhirAssertResponseCodeTypesEnum read GetResponseST write SetResponseST;
    property responseElement : TFhirEnum read FResponse write SetResponse;

    // Typed access to The value of the HTTP response code to be tested.
    property responseCode : String read GetResponseCodeST write SetResponseCodeST;
    // The value of the HTTP response code to be tested.
    property responseCodeElement : TFhirString read FResponseCode write SetResponseCode;

    // Typed access to Fixture to evaluate the XPath/JSONPath expression or the headerField  against.
    property sourceId : String read GetSourceIdST write SetSourceIdST;
    // Fixture to evaluate the XPath/JSONPath expression or the headerField  against.
    property sourceIdElement : TFhirId read FSourceId write SetSourceId;

    // Typed access to The ID of the Profile to validate against.
    property validateProfileId : String read GetValidateProfileIdST write SetValidateProfileIdST;
    // The ID of the Profile to validate against.
    property validateProfileIdElement : TFhirId read FValidateProfileId write SetValidateProfileId;

    // Typed access to The value to compare to.
    property value : String read GetValueST write SetValueST;
    // The value to compare to.
    property valueElement : TFhirString read FValue write SetValue;

    // Typed access to Whether or not the test execution will produce a warning only on error for this assert.
    property warningOnly : Boolean read GetWarningOnlyST write SetWarningOnlyST;
    // Whether or not the test execution will produce a warning only on error for this assert.
    property warningOnlyElement : TFhirBoolean read FWarningOnly write SetWarningOnly;

  end;

  TFhirTestScriptSetupActionAssertListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptSetupActionAssertList;
    function GetCurrent : TFhirTestScriptSetupActionAssert;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptSetupActionAssertList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptSetupActionAssert read GetCurrent;
  end;

  TFhirTestScriptSetupActionAssertList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestScriptSetupActionAssert;
    procedure SetItemN(index : Integer; value : TFhirTestScriptSetupActionAssert);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestScriptSetupActionAssertList; Overload;
    function Clone : TFhirTestScriptSetupActionAssertList; Overload;
    function GetEnumerator : TFhirTestScriptSetupActionAssertListEnumerator;
    

    //  Add a FhirTestScriptSetupActionAssert to the end of the list.
    function Append : TFhirTestScriptSetupActionAssert;

    
    // Add an already existing FhirTestScriptSetupActionAssert to the end of the list.
    procedure AddItem(value : TFhirTestScriptSetupActionAssert); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptSetupActionAssert) : Integer;
    

    // Insert FhirTestScriptSetupActionAssert before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptSetupActionAssert;
    

    // Insert an existing FhirTestScriptSetupActionAssert before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptSetupActionAssert);
    
    // Get the iIndexth FhirTestScriptSetupActionAssert. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptSetupActionAssert);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptSetupActionAssert;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirTestScriptSetupActionAsserts[index : Integer] : TFhirTestScriptSetupActionAssert read GetItemN write SetItemN; default;
  End;

  // A test in this script.
  TFhirTestScriptTest = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FDescription : TFhirString;
    FMetadata : TFhirTestScriptMetadata;
    FactionList : TFhirTestScriptTestActionList;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetMetadata(value : TFhirTestScriptMetadata);
    function GetActionList : TFhirTestScriptTestActionList;
    function GetHasActionList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptTest; overload;
    function Clone : TFhirTestScriptTest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The name of this test used for tracking/logging purposes by test engines.
    property name : String read GetNameST write SetNameST;
    // The name of this test used for tracking/logging purposes by test engines.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short description of the test used by test engines for tracking and reporting purposes.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A short description of the test used by test engines for tracking and reporting purposes.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Capabilities that must exist and are assumed to function correctly on the FHIR server being tested. (defined for API consistency)
    property metadata : TFhirTestScriptMetadata read FMetadata write SetMetadata;
    // Capabilities that must exist and are assumed to function correctly on the FHIR server being tested.
    property metadataElement : TFhirTestScriptMetadata read FMetadata write SetMetadata;

    // Action would contain either an operation or an assertion.
    property actionList : TFhirTestScriptTestActionList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

  end;

  TFhirTestScriptTestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptTestList;
    function GetCurrent : TFhirTestScriptTest;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptTestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptTest read GetCurrent;
  end;

  TFhirTestScriptTestList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestScriptTest;
    procedure SetItemN(index : Integer; value : TFhirTestScriptTest);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestScriptTestList; Overload;
    function Clone : TFhirTestScriptTestList; Overload;
    function GetEnumerator : TFhirTestScriptTestListEnumerator;
    

    //  Add a FhirTestScriptTest to the end of the list.
    function Append : TFhirTestScriptTest;

    
    // Add an already existing FhirTestScriptTest to the end of the list.
    procedure AddItem(value : TFhirTestScriptTest); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptTest) : Integer;
    

    // Insert FhirTestScriptTest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptTest;
    

    // Insert an existing FhirTestScriptTest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptTest);
    
    // Get the iIndexth FhirTestScriptTest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptTest);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptTest;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirTestScriptTests[index : Integer] : TFhirTestScriptTest read GetItemN write SetItemN; default;
  End;

  // Action would contain either an operation or an assertion.
  TFhirTestScriptTestAction = class (TFhirBackboneElement)
  protected
    FOperation : TFhirTestScriptSetupActionOperation;
    FAssert : TFhirTestScriptSetupActionAssert;
    Procedure SetOperation(value : TFhirTestScriptSetupActionOperation);
    Procedure SetAssert(value : TFhirTestScriptSetupActionAssert);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptTestAction; overload;
    function Clone : TFhirTestScriptTestAction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An operation would involve a REST request to a server. (defined for API consistency)
    property operation : TFhirTestScriptSetupActionOperation read FOperation write SetOperation;
    // An operation would involve a REST request to a server.
    property operationElement : TFhirTestScriptSetupActionOperation read FOperation write SetOperation;

    // Typed access to Evaluates the results of previous operations to determine if the server under test behaves appropriately. (defined for API consistency)
    property assert : TFhirTestScriptSetupActionAssert read FAssert write SetAssert;
    // Evaluates the results of previous operations to determine if the server under test behaves appropriately.
    property assertElement : TFhirTestScriptSetupActionAssert read FAssert write SetAssert;

  end;

  TFhirTestScriptTestActionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptTestActionList;
    function GetCurrent : TFhirTestScriptTestAction;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptTestActionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptTestAction read GetCurrent;
  end;

  TFhirTestScriptTestActionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestScriptTestAction;
    procedure SetItemN(index : Integer; value : TFhirTestScriptTestAction);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestScriptTestActionList; Overload;
    function Clone : TFhirTestScriptTestActionList; Overload;
    function GetEnumerator : TFhirTestScriptTestActionListEnumerator;
    

    //  Add a FhirTestScriptTestAction to the end of the list.
    function Append : TFhirTestScriptTestAction;

    
    // Add an already existing FhirTestScriptTestAction to the end of the list.
    procedure AddItem(value : TFhirTestScriptTestAction); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptTestAction) : Integer;
    

    // Insert FhirTestScriptTestAction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptTestAction;
    

    // Insert an existing FhirTestScriptTestAction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptTestAction);
    
    // Get the iIndexth FhirTestScriptTestAction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptTestAction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptTestAction;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirTestScriptTestActions[index : Integer] : TFhirTestScriptTestAction read GetItemN write SetItemN; default;
  End;

  // A series of operations required to clean up after the all the tests are executed (successfully or otherwise).
  TFhirTestScriptTeardown = class (TFhirBackboneElement)
  protected
    FactionList : TFhirTestScriptTeardownActionList;
    function GetActionList : TFhirTestScriptTeardownActionList;
    function GetHasActionList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptTeardown; overload;
    function Clone : TFhirTestScriptTeardown; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The teardown action will only contain an operation.
    property actionList : TFhirTestScriptTeardownActionList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

  end;

  TFhirTestScriptTeardownListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptTeardownList;
    function GetCurrent : TFhirTestScriptTeardown;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptTeardownList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptTeardown read GetCurrent;
  end;

  TFhirTestScriptTeardownList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestScriptTeardown;
    procedure SetItemN(index : Integer; value : TFhirTestScriptTeardown);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestScriptTeardownList; Overload;
    function Clone : TFhirTestScriptTeardownList; Overload;
    function GetEnumerator : TFhirTestScriptTeardownListEnumerator;
    

    //  Add a FhirTestScriptTeardown to the end of the list.
    function Append : TFhirTestScriptTeardown;

    
    // Add an already existing FhirTestScriptTeardown to the end of the list.
    procedure AddItem(value : TFhirTestScriptTeardown); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptTeardown) : Integer;
    

    // Insert FhirTestScriptTeardown before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptTeardown;
    

    // Insert an existing FhirTestScriptTeardown before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptTeardown);
    
    // Get the iIndexth FhirTestScriptTeardown. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptTeardown);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptTeardown;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirTestScriptTeardowns[index : Integer] : TFhirTestScriptTeardown read GetItemN write SetItemN; default;
  End;

  // The teardown action will only contain an operation.
  TFhirTestScriptTeardownAction = class (TFhirBackboneElement)
  protected
    FOperation : TFhirTestScriptSetupActionOperation;
    Procedure SetOperation(value : TFhirTestScriptSetupActionOperation);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptTeardownAction; overload;
    function Clone : TFhirTestScriptTeardownAction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An operation would involve a REST request to a server. (defined for API consistency)
    property operation : TFhirTestScriptSetupActionOperation read FOperation write SetOperation;
    // An operation would involve a REST request to a server.
    property operationElement : TFhirTestScriptSetupActionOperation read FOperation write SetOperation;

  end;

  TFhirTestScriptTeardownActionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptTeardownActionList;
    function GetCurrent : TFhirTestScriptTeardownAction;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptTeardownActionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptTeardownAction read GetCurrent;
  end;

  TFhirTestScriptTeardownActionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestScriptTeardownAction;
    procedure SetItemN(index : Integer; value : TFhirTestScriptTeardownAction);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestScriptTeardownActionList; Overload;
    function Clone : TFhirTestScriptTeardownActionList; Overload;
    function GetEnumerator : TFhirTestScriptTeardownActionListEnumerator;
    

    //  Add a FhirTestScriptTeardownAction to the end of the list.
    function Append : TFhirTestScriptTeardownAction;

    
    // Add an already existing FhirTestScriptTeardownAction to the end of the list.
    procedure AddItem(value : TFhirTestScriptTeardownAction); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptTeardownAction) : Integer;
    

    // Insert FhirTestScriptTeardownAction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptTeardownAction;
    

    // Insert an existing FhirTestScriptTeardownAction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptTeardownAction);
    
    // Get the iIndexth FhirTestScriptTeardownAction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptTeardownAction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptTeardownAction;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirTestScriptTeardownActions[index : Integer] : TFhirTestScriptTeardownAction read GetItemN write SetItemN; default;
  End;

  // TestScript is a resource that specifies a suite of tests against a FHIR server implementation to determine compliance against the FHIR specification.
  TFhirTestScript = class (TFhirDomainResource)
  protected
    FUrl : TFhirUri;
    FVersion : TFhirString;
    FName : TFhirString;
    FStatus : TFhirEnum;
    FIdentifier : TFhirIdentifier;
    FExperimental : TFhirBoolean;
    FPublisher : TFhirString;
    FcontactList : TFhirTestScriptContactList;
    FDate : TFhirDateTime;
    FDescription : TFhirString;
    FuseContextList : TFhirCodeableConceptList;
    FRequirements : TFhirString;
    FCopyright : TFhirString;
    FMetadata : TFhirTestScriptMetadata;
    FMultiserver : TFhirBoolean;
    FfixtureList : TFhirTestScriptFixtureList;
    FprofileList : TFhirReferenceList{TFhirReference};
    FvariableList : TFhirTestScriptVariableList;
    FSetup : TFhirTestScriptSetup;
    FtestList : TFhirTestScriptTestList;
    FTeardown : TFhirTestScriptTeardown;
    Procedure SetUrl(value : TFhirUri);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);
    Procedure SetVersion(value : TFhirString);
    Function GetVersionST : String;
    Procedure SetVersionST(value : String);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirConformanceResourceStatusEnum;
    Procedure SetStatusST(value : TFhirConformanceResourceStatusEnum);
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetExperimental(value : TFhirBoolean);
    Function GetExperimentalST : Boolean;
    Procedure SetExperimentalST(value : Boolean);
    Procedure SetPublisher(value : TFhirString);
    Function GetPublisherST : String;
    Procedure SetPublisherST(value : String);
    function GetContactList : TFhirTestScriptContactList;
    function GetHasContactList : Boolean;
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    function GetUseContextList : TFhirCodeableConceptList;
    function GetHasUseContextList : Boolean;
    Procedure SetRequirements(value : TFhirString);
    Function GetRequirementsST : String;
    Procedure SetRequirementsST(value : String);
    Procedure SetCopyright(value : TFhirString);
    Function GetCopyrightST : String;
    Procedure SetCopyrightST(value : String);
    Procedure SetMetadata(value : TFhirTestScriptMetadata);
    Procedure SetMultiserver(value : TFhirBoolean);
    Function GetMultiserverST : Boolean;
    Procedure SetMultiserverST(value : Boolean);
    function GetFixtureList : TFhirTestScriptFixtureList;
    function GetHasFixtureList : Boolean;
    function GetProfileList : TFhirReferenceList{TFhirReference};
    function GetHasProfileList : Boolean;
    function GetVariableList : TFhirTestScriptVariableList;
    function GetHasVariableList : Boolean;
    Procedure SetSetup(value : TFhirTestScriptSetup);
    function GetTestList : TFhirTestScriptTestList;
    function GetHasTestList : Boolean;
    Procedure SetTeardown(value : TFhirTestScriptTeardown);
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScript; overload;
    function Clone : TFhirTestScript; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URL that is used to identify this Test Script. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this Test Script is (or will be) {$IFNDEF FPC}published{$ENDIF}.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URL that is used to identify this Test Script. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this Test Script is (or will be) {$IFNDEF FPC}published{$ENDIF}.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to The identifier that is used to identify this version of the TestScript. This is an arbitrary value managed by the TestScript author manually.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the TestScript. This is an arbitrary value managed by the TestScript author manually.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A free text natural language name identifying the TestScript.
    property name : String read GetNameST write SetNameST;
    // A free text natural language name identifying the TestScript.
    property nameElement : TFhirString read FName write SetName;

    // The status of the TestScript.
    property status : TFhirConformanceResourceStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Identifier for the TestScript assigned for external purposes outside the context of FHIR. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Identifier for the TestScript assigned for external purposes outside the context of FHIR.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to This TestScript was authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // This TestScript was authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The name of the individual or organization that {$IFNDEF FPC}published{$ENDIF} the Test Script.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the individual or organization that {$IFNDEF FPC}published{$ENDIF} the Test Script.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contacts to assist a user in finding and communicating with the publisher.
    property contactList : TFhirTestScriptContactList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to The date this version of the test tcript was {$IFNDEF FPC}published{$ENDIF}. The date must change when the business version changes, if it does, and it must change if the status code changes. In addition, it should change when the substantive content of the test cases change.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date this version of the test tcript was {$IFNDEF FPC}published{$ENDIF}. The date must change when the business version changes, if it does, and it must change if the status code changes. In addition, it should change when the substantive content of the test cases change.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to A free text natural language description of the TestScript and its use.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the TestScript and its use.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These terms may be used to assist with indexing and searching of Test Scripts.
    property useContextList : TFhirCodeableConceptList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // Typed access to Explains why this Test Script is needed and why it's been constrained as it has.
    property requirements : String read GetRequirementsST write SetRequirementsST;
    // Explains why this Test Script is needed and why it's been constrained as it has.
    property requirementsElement : TFhirString read FRequirements write SetRequirements;

    // Typed access to A copyright statement relating to the Test Script and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the details of the constraints and mappings.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the Test Script and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the details of the constraints and mappings.
    property copyrightElement : TFhirString read FCopyright write SetCopyright;

    // Typed access to The required capability must exist and are assumed to function correctly on the FHIR server being tested. (defined for API consistency)
    property metadata : TFhirTestScriptMetadata read FMetadata write SetMetadata;
    // The required capability must exist and are assumed to function correctly on the FHIR server being tested.
    property metadataElement : TFhirTestScriptMetadata read FMetadata write SetMetadata;

    // Typed access to If the tests apply to more than one FHIR server (e.g. cross-server interoperability tests) then multiserver=true. Defaults to false if value is unspecified.
    property multiserver : Boolean read GetMultiserverST write SetMultiserverST;
    // If the tests apply to more than one FHIR server (e.g. cross-server interoperability tests) then multiserver=true. Defaults to false if value is unspecified.
    property multiserverElement : TFhirBoolean read FMultiserver write SetMultiserver;

    // Fixture in the test script - by reference (uri). All fixtures are required for the test script to execute.
    property fixtureList : TFhirTestScriptFixtureList read GetFixtureList;
    property hasFixtureList : boolean read GetHasFixtureList;

    // Reference to the profile to be used for validation.
    property profileList : TFhirReferenceList{TFhirReference} read GetProfileList;
    property hasProfileList : boolean read GetHasProfileList;

    // Variable is set based either on element value in response body or on header field value in the response headers.
    property variableList : TFhirTestScriptVariableList read GetVariableList;
    property hasVariableList : boolean read GetHasVariableList;

    // Typed access to A series of required setup operations before tests are executed. (defined for API consistency)
    property setup : TFhirTestScriptSetup read FSetup write SetSetup;
    // A series of required setup operations before tests are executed.
    property setupElement : TFhirTestScriptSetup read FSetup write SetSetup;

    // A test in this script.
    property testList : TFhirTestScriptTestList read GetTestList;
    property hasTestList : boolean read GetHasTestList;

    // Typed access to A series of operations required to clean up after the all the tests are executed (successfully or otherwise). (defined for API consistency)
    property teardown : TFhirTestScriptTeardown read FTeardown write SetTeardown;
    // A series of operations required to clean up after the all the tests are executed (successfully or otherwise).
    property teardownElement : TFhirTestScriptTeardown read FTeardown write SetTeardown;

  end;

  TFhirTestScriptListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptList;
    function GetCurrent : TFhirTestScript;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScript read GetCurrent;
  end;

  TFhirTestScriptList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestScript;
    procedure SetItemN(index : Integer; value : TFhirTestScript);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestScriptList; Overload;
    function Clone : TFhirTestScriptList; Overload;
    function GetEnumerator : TFhirTestScriptListEnumerator;
    

    //  Add a FhirTestScript to the end of the list.
    function Append : TFhirTestScript;

    
    // Add an already existing FhirTestScript to the end of the list.
    procedure AddItem(value : TFhirTestScript); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScript) : Integer;
    

    // Insert FhirTestScript before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScript;
    

    // Insert an existing FhirTestScript before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScript);
    
    // Get the iIndexth FhirTestScript. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScript);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScript;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirTestScripts[index : Integer] : TFhirTestScript read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_TESTSCRIPT}

{$IFDEF FHIR_VALUESET}

  // Contacts to assist a user in finding and communicating with the publisher.
  TFhirValueSetContact = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FtelecomList : TFhirContactPointList;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirValueSetContact; overload;
    function Clone : TFhirValueSetContact; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The name of an individual to contact regarding the value set.
    property name : String read GetNameST write SetNameST;
    // The name of an individual to contact regarding the value set.
    property nameElement : TFhirString read FName write SetName;

    // Contact details for individual (if a name was provided) or the publisher.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

  end;

  TFhirValueSetContactListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirValueSetContactList;
    function GetCurrent : TFhirValueSetContact;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirValueSetContactList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirValueSetContact read GetCurrent;
  end;

  TFhirValueSetContactList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirValueSetContact;
    procedure SetItemN(index : Integer; value : TFhirValueSetContact);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirValueSetContactList; Overload;
    function Clone : TFhirValueSetContactList; Overload;
    function GetEnumerator : TFhirValueSetContactListEnumerator;
    

    //  Add a FhirValueSetContact to the end of the list.
    function Append : TFhirValueSetContact;

    
    // Add an already existing FhirValueSetContact to the end of the list.
    procedure AddItem(value : TFhirValueSetContact); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirValueSetContact) : Integer;
    

    // Insert FhirValueSetContact before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirValueSetContact;
    

    // Insert an existing FhirValueSetContact before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirValueSetContact);
    
    // Get the iIndexth FhirValueSetContact. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetContact);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirValueSetContact;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirValueSetContacts[index : Integer] : TFhirValueSetContact read GetItemN write SetItemN; default;
  End;

  // A definition of a code system, inlined into the value set (as a packaging convenience). Note that the inline code system may be used from other value sets by referring to its (codeSystem.system) directly.
  TFhirValueSetCodeSystem = class (TFhirBackboneElement)
  protected
    FSystem : TFhirUri;
    FVersion : TFhirString;
    FCaseSensitive : TFhirBoolean;
    FconceptList : TFhirValueSetCodeSystemConceptList;
    Procedure SetSystem(value : TFhirUri);
    Function GetSystemST : String;
    Procedure SetSystemST(value : String);
    Procedure SetVersion(value : TFhirString);
    Function GetVersionST : String;
    Procedure SetVersionST(value : String);
    Procedure SetCaseSensitive(value : TFhirBoolean);
    Function GetCaseSensitiveST : Boolean;
    Procedure SetCaseSensitiveST(value : Boolean);
    function GetConceptList : TFhirValueSetCodeSystemConceptList;
    function GetHasConceptList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirValueSetCodeSystem; overload;
    function Clone : TFhirValueSetCodeSystem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URI that is used to reference this code system, including in [Coding].system.
    property system : String read GetSystemST write SetSystemST;
    // An absolute URI that is used to reference this code system, including in [Coding].system.
    property systemElement : TFhirUri read FSystem write SetSystem;

    // Typed access to The version of this code system that defines the codes. Note that the version is optional because a well maintained code system does not suffer from versioning, and therefore the version does not need to be maintained. However many code systems are not well maintained, and the version needs to be defined and tracked.
    property version : String read GetVersionST write SetVersionST;
    // The version of this code system that defines the codes. Note that the version is optional because a well maintained code system does not suffer from versioning, and therefore the version does not need to be maintained. However many code systems are not well maintained, and the version needs to be defined and tracked.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to If code comparison is case sensitive when codes within this system are compared to each other.
    property caseSensitive : Boolean read GetCaseSensitiveST write SetCaseSensitiveST;
    // If code comparison is case sensitive when codes within this system are compared to each other.
    property caseSensitiveElement : TFhirBoolean read FCaseSensitive write SetCaseSensitive;

    // Concepts that are in the code system. The concept definitions are inherently hierarchical, but the definitions must be consulted to determine what the meaning of the hierarchical relationships are.
    property conceptList : TFhirValueSetCodeSystemConceptList read GetConceptList;
    property hasConceptList : boolean read GetHasConceptList;

  end;

  TFhirValueSetCodeSystemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirValueSetCodeSystemList;
    function GetCurrent : TFhirValueSetCodeSystem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirValueSetCodeSystemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirValueSetCodeSystem read GetCurrent;
  end;

  TFhirValueSetCodeSystemList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirValueSetCodeSystem;
    procedure SetItemN(index : Integer; value : TFhirValueSetCodeSystem);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirValueSetCodeSystemList; Overload;
    function Clone : TFhirValueSetCodeSystemList; Overload;
    function GetEnumerator : TFhirValueSetCodeSystemListEnumerator;
    

    //  Add a FhirValueSetCodeSystem to the end of the list.
    function Append : TFhirValueSetCodeSystem;

    
    // Add an already existing FhirValueSetCodeSystem to the end of the list.
    procedure AddItem(value : TFhirValueSetCodeSystem); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirValueSetCodeSystem) : Integer;
    

    // Insert FhirValueSetCodeSystem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirValueSetCodeSystem;
    

    // Insert an existing FhirValueSetCodeSystem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirValueSetCodeSystem);
    
    // Get the iIndexth FhirValueSetCodeSystem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetCodeSystem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirValueSetCodeSystem;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirValueSetCodeSystems[index : Integer] : TFhirValueSetCodeSystem read GetItemN write SetItemN; default;
  End;

  // Concepts that are in the code system. The concept definitions are inherently hierarchical, but the definitions must be consulted to determine what the meaning of the hierarchical relationships are.
  TFhirValueSetCodeSystemConcept = class (TFhirBackboneElement)
  protected
    FCode : TFhirCode;
    FAbstract : TFhirBoolean;
    FDisplay : TFhirString;
    FDefinition : TFhirString;
    FdesignationList : TFhirValueSetCodeSystemConceptDesignationList;
    FconceptList : TFhirValueSetCodeSystemConceptList;
    Procedure SetCode(value : TFhirCode);
    Function GetCodeST : String;
    Procedure SetCodeST(value : String);
    Procedure SetAbstract(value : TFhirBoolean);
    Function GetAbstractST : Boolean;
    Procedure SetAbstractST(value : Boolean);
    Procedure SetDisplay(value : TFhirString);
    Function GetDisplayST : String;
    Procedure SetDisplayST(value : String);
    Procedure SetDefinition(value : TFhirString);
    Function GetDefinitionST : String;
    Procedure SetDefinitionST(value : String);
    function GetDesignationList : TFhirValueSetCodeSystemConceptDesignationList;
    function GetHasDesignationList : Boolean;
    function GetConceptList : TFhirValueSetCodeSystemConceptList;
    function GetHasConceptList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirValueSetCodeSystemConcept; overload;
    function Clone : TFhirValueSetCodeSystemConcept; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code - a text symbol - that uniquely identifies the concept within the code system.
    property code : String read GetCodeST write SetCodeST;
    // A code - a text symbol - that uniquely identifies the concept within the code system.
    property codeElement : TFhirCode read FCode write SetCode;

    // Typed access to If this code is not for use as a real concept.
    property abstract : Boolean read GetAbstractST write SetAbstractST;
    // If this code is not for use as a real concept.
    property abstractElement : TFhirBoolean read FAbstract write SetAbstract;

    // Typed access to A human readable string that is the recommended default way to present this concept to a user.
    property display : String read GetDisplayST write SetDisplayST;
    // A human readable string that is the recommended default way to present this concept to a user.
    property displayElement : TFhirString read FDisplay write SetDisplay;

    // Typed access to The formal definition of the concept. The value set resource does not make formal definitions required, because of the prevalence of legacy systems. However, they are highly recommended, as without them there is no formal meaning associated with the concept.
    property definition : String read GetDefinitionST write SetDefinitionST;
    // The formal definition of the concept. The value set resource does not make formal definitions required, because of the prevalence of legacy systems. However, they are highly recommended, as without them there is no formal meaning associated with the concept.
    property definitionElement : TFhirString read FDefinition write SetDefinition;

    // Additional representations for the concept - other languages, aliases, specialized purposes, used for particular purposes, etc.
    property designationList : TFhirValueSetCodeSystemConceptDesignationList read GetDesignationList;
    property hasDesignationList : boolean read GetHasDesignationList;

    // Defines children of a concept to produce a hierarchy of concepts. The nature of the relationships is variable (is-a/contains/categorizes) and can only be determined by examining the definitions of the concepts.
    property conceptList : TFhirValueSetCodeSystemConceptList read GetConceptList;
    property hasConceptList : boolean read GetHasConceptList;

  end;

  TFhirValueSetCodeSystemConceptListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirValueSetCodeSystemConceptList;
    function GetCurrent : TFhirValueSetCodeSystemConcept;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirValueSetCodeSystemConceptList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirValueSetCodeSystemConcept read GetCurrent;
  end;

  TFhirValueSetCodeSystemConceptList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirValueSetCodeSystemConcept;
    procedure SetItemN(index : Integer; value : TFhirValueSetCodeSystemConcept);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirValueSetCodeSystemConceptList; Overload;
    function Clone : TFhirValueSetCodeSystemConceptList; Overload;
    function GetEnumerator : TFhirValueSetCodeSystemConceptListEnumerator;
    

    //  Add a FhirValueSetCodeSystemConcept to the end of the list.
    function Append : TFhirValueSetCodeSystemConcept;

    
    // Add an already existing FhirValueSetCodeSystemConcept to the end of the list.
    procedure AddItem(value : TFhirValueSetCodeSystemConcept); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirValueSetCodeSystemConcept) : Integer;
    

    // Insert FhirValueSetCodeSystemConcept before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirValueSetCodeSystemConcept;
    

    // Insert an existing FhirValueSetCodeSystemConcept before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirValueSetCodeSystemConcept);
    
    // Get the iIndexth FhirValueSetCodeSystemConcept. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetCodeSystemConcept);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirValueSetCodeSystemConcept;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirValueSetCodeSystemConcepts[index : Integer] : TFhirValueSetCodeSystemConcept read GetItemN write SetItemN; default;
  End;

  // Additional representations for the concept - other languages, aliases, specialized purposes, used for particular purposes, etc.
  TFhirValueSetCodeSystemConceptDesignation = class (TFhirBackboneElement)
  protected
    FLanguage : TFhirCode;
    FUse : TFhirCoding;
    FValue : TFhirString;
    Procedure SetLanguage(value : TFhirCode);
    Function GetLanguageST : String;
    Procedure SetLanguageST(value : String);
    Procedure SetUse(value : TFhirCoding);
    Procedure SetValue(value : TFhirString);
    Function GetValueST : String;
    Procedure SetValueST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirValueSetCodeSystemConceptDesignation; overload;
    function Clone : TFhirValueSetCodeSystemConceptDesignation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The language this designation is defined for.
    property language : String read GetLanguageST write SetLanguageST;
    // The language this designation is defined for.
    property languageElement : TFhirCode read FLanguage write SetLanguage;

    // Typed access to A code that details how this designation would be used. (defined for API consistency)
    property use : TFhirCoding read FUse write SetUse;
    // A code that details how this designation would be used.
    property useElement : TFhirCoding read FUse write SetUse;

    // Typed access to The text value for this designation.
    property value : String read GetValueST write SetValueST;
    // The text value for this designation.
    property valueElement : TFhirString read FValue write SetValue;

  end;

  TFhirValueSetCodeSystemConceptDesignationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirValueSetCodeSystemConceptDesignationList;
    function GetCurrent : TFhirValueSetCodeSystemConceptDesignation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirValueSetCodeSystemConceptDesignationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirValueSetCodeSystemConceptDesignation read GetCurrent;
  end;

  TFhirValueSetCodeSystemConceptDesignationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirValueSetCodeSystemConceptDesignation;
    procedure SetItemN(index : Integer; value : TFhirValueSetCodeSystemConceptDesignation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirValueSetCodeSystemConceptDesignationList; Overload;
    function Clone : TFhirValueSetCodeSystemConceptDesignationList; Overload;
    function GetEnumerator : TFhirValueSetCodeSystemConceptDesignationListEnumerator;
    

    //  Add a FhirValueSetCodeSystemConceptDesignation to the end of the list.
    function Append : TFhirValueSetCodeSystemConceptDesignation;

    
    // Add an already existing FhirValueSetCodeSystemConceptDesignation to the end of the list.
    procedure AddItem(value : TFhirValueSetCodeSystemConceptDesignation); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirValueSetCodeSystemConceptDesignation) : Integer;
    

    // Insert FhirValueSetCodeSystemConceptDesignation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirValueSetCodeSystemConceptDesignation;
    

    // Insert an existing FhirValueSetCodeSystemConceptDesignation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirValueSetCodeSystemConceptDesignation);
    
    // Get the iIndexth FhirValueSetCodeSystemConceptDesignation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetCodeSystemConceptDesignation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirValueSetCodeSystemConceptDesignation;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirValueSetCodeSystemConceptDesignations[index : Integer] : TFhirValueSetCodeSystemConceptDesignation read GetItemN write SetItemN; default;
  End;

  // A set of criteria that provide the content logical definition of the value set by including or excluding codes from outside this value set.
  TFhirValueSetCompose = class (TFhirBackboneElement)
  protected
    FimportList : TFhirUriList;
    FincludeList : TFhirValueSetComposeIncludeList;
    FexcludeList : TFhirValueSetComposeIncludeList;
    function GetImportList : TFhirUriList;
    function GetHasImportList : Boolean;
    function GetIncludeList : TFhirValueSetComposeIncludeList;
    function GetHasIncludeList : Boolean;
    function GetExcludeList : TFhirValueSetComposeIncludeList;
    function GetHasExcludeList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirValueSetCompose; overload;
    function Clone : TFhirValueSetCompose; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Includes the contents of the referenced value set as a part of the contents of this value set. This is an absolute URI that is a reference to ValueSet.uri.
    property importList : TFhirUriList read GetImportList;
    property hasImportList : boolean read GetHasImportList;

    // Include one or more codes from a code system.
    property includeList : TFhirValueSetComposeIncludeList read GetIncludeList;
    property hasIncludeList : boolean read GetHasIncludeList;

    // Exclude one or more codes from the value set.
    property excludeList : TFhirValueSetComposeIncludeList read GetExcludeList;
    property hasExcludeList : boolean read GetHasExcludeList;

  end;

  TFhirValueSetComposeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirValueSetComposeList;
    function GetCurrent : TFhirValueSetCompose;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirValueSetComposeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirValueSetCompose read GetCurrent;
  end;

  TFhirValueSetComposeList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirValueSetCompose;
    procedure SetItemN(index : Integer; value : TFhirValueSetCompose);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirValueSetComposeList; Overload;
    function Clone : TFhirValueSetComposeList; Overload;
    function GetEnumerator : TFhirValueSetComposeListEnumerator;
    

    //  Add a FhirValueSetCompose to the end of the list.
    function Append : TFhirValueSetCompose;

    
    // Add an already existing FhirValueSetCompose to the end of the list.
    procedure AddItem(value : TFhirValueSetCompose); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirValueSetCompose) : Integer;
    

    // Insert FhirValueSetCompose before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirValueSetCompose;
    

    // Insert an existing FhirValueSetCompose before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirValueSetCompose);
    
    // Get the iIndexth FhirValueSetCompose. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetCompose);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirValueSetCompose;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirValueSetComposes[index : Integer] : TFhirValueSetCompose read GetItemN write SetItemN; default;
  End;

  // Include one or more codes from a code system.
  TFhirValueSetComposeInclude = class (TFhirBackboneElement)
  protected
    FSystem : TFhirUri;
    FVersion : TFhirString;
    FconceptList : TFhirValueSetComposeIncludeConceptList;
    FfilterList : TFhirValueSetComposeIncludeFilterList;
    Procedure SetSystem(value : TFhirUri);
    Function GetSystemST : String;
    Procedure SetSystemST(value : String);
    Procedure SetVersion(value : TFhirString);
    Function GetVersionST : String;
    Procedure SetVersionST(value : String);
    function GetConceptList : TFhirValueSetComposeIncludeConceptList;
    function GetHasConceptList : Boolean;
    function GetFilterList : TFhirValueSetComposeIncludeFilterList;
    function GetHasFilterList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirValueSetComposeInclude; overload;
    function Clone : TFhirValueSetComposeInclude; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URI which is the code system from which the selected codes come from.
    property system : String read GetSystemST write SetSystemST;
    // An absolute URI which is the code system from which the selected codes come from.
    property systemElement : TFhirUri read FSystem write SetSystem;

    // Typed access to The version of the code system that the codes are selected from.
    property version : String read GetVersionST write SetVersionST;
    // The version of the code system that the codes are selected from.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Specifies a concept to be included or excluded.
    property conceptList : TFhirValueSetComposeIncludeConceptList read GetConceptList;
    property hasConceptList : boolean read GetHasConceptList;

    // Select concepts by specify a matching criteria based on the properties (including relationships) defined by the system. If multiple filters are specified, they SHALL all be true.
    property filterList : TFhirValueSetComposeIncludeFilterList read GetFilterList;
    property hasFilterList : boolean read GetHasFilterList;

  end;

  TFhirValueSetComposeIncludeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirValueSetComposeIncludeList;
    function GetCurrent : TFhirValueSetComposeInclude;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirValueSetComposeIncludeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirValueSetComposeInclude read GetCurrent;
  end;

  TFhirValueSetComposeIncludeList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirValueSetComposeInclude;
    procedure SetItemN(index : Integer; value : TFhirValueSetComposeInclude);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirValueSetComposeIncludeList; Overload;
    function Clone : TFhirValueSetComposeIncludeList; Overload;
    function GetEnumerator : TFhirValueSetComposeIncludeListEnumerator;
    

    //  Add a FhirValueSetComposeInclude to the end of the list.
    function Append : TFhirValueSetComposeInclude;

    
    // Add an already existing FhirValueSetComposeInclude to the end of the list.
    procedure AddItem(value : TFhirValueSetComposeInclude); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirValueSetComposeInclude) : Integer;
    

    // Insert FhirValueSetComposeInclude before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirValueSetComposeInclude;
    

    // Insert an existing FhirValueSetComposeInclude before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirValueSetComposeInclude);
    
    // Get the iIndexth FhirValueSetComposeInclude. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetComposeInclude);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirValueSetComposeInclude;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirValueSetComposeIncludes[index : Integer] : TFhirValueSetComposeInclude read GetItemN write SetItemN; default;
  End;

  // Specifies a concept to be included or excluded.
  TFhirValueSetComposeIncludeConcept = class (TFhirBackboneElement)
  protected
    FCode : TFhirCode;
    FDisplay : TFhirString;
    FdesignationList : TFhirValueSetCodeSystemConceptDesignationList;
    Procedure SetCode(value : TFhirCode);
    Function GetCodeST : String;
    Procedure SetCodeST(value : String);
    Procedure SetDisplay(value : TFhirString);
    Function GetDisplayST : String;
    Procedure SetDisplayST(value : String);
    function GetDesignationList : TFhirValueSetCodeSystemConceptDesignationList;
    function GetHasDesignationList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirValueSetComposeIncludeConcept; overload;
    function Clone : TFhirValueSetComposeIncludeConcept; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Specifies a code for the concept to be included or excluded.
    property code : String read GetCodeST write SetCodeST;
    // Specifies a code for the concept to be included or excluded.
    property codeElement : TFhirCode read FCode write SetCode;

    // Typed access to The text to display to the user for this concept in the context of this valueset. If no display is provided, then applications using the value set use the display specified for the code by the system.
    property display : String read GetDisplayST write SetDisplayST;
    // The text to display to the user for this concept in the context of this valueset. If no display is provided, then applications using the value set use the display specified for the code by the system.
    property displayElement : TFhirString read FDisplay write SetDisplay;

    // Additional representations for this concept when used in this value set - other languages, aliases, specialized purposes, used for particular purposes, etc.
    property designationList : TFhirValueSetCodeSystemConceptDesignationList read GetDesignationList;
    property hasDesignationList : boolean read GetHasDesignationList;

  end;

  TFhirValueSetComposeIncludeConceptListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirValueSetComposeIncludeConceptList;
    function GetCurrent : TFhirValueSetComposeIncludeConcept;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirValueSetComposeIncludeConceptList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirValueSetComposeIncludeConcept read GetCurrent;
  end;

  TFhirValueSetComposeIncludeConceptList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirValueSetComposeIncludeConcept;
    procedure SetItemN(index : Integer; value : TFhirValueSetComposeIncludeConcept);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirValueSetComposeIncludeConceptList; Overload;
    function Clone : TFhirValueSetComposeIncludeConceptList; Overload;
    function GetEnumerator : TFhirValueSetComposeIncludeConceptListEnumerator;
    

    //  Add a FhirValueSetComposeIncludeConcept to the end of the list.
    function Append : TFhirValueSetComposeIncludeConcept;

    
    // Add an already existing FhirValueSetComposeIncludeConcept to the end of the list.
    procedure AddItem(value : TFhirValueSetComposeIncludeConcept); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirValueSetComposeIncludeConcept) : Integer;
    

    // Insert FhirValueSetComposeIncludeConcept before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirValueSetComposeIncludeConcept;
    

    // Insert an existing FhirValueSetComposeIncludeConcept before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirValueSetComposeIncludeConcept);
    
    // Get the iIndexth FhirValueSetComposeIncludeConcept. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetComposeIncludeConcept);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirValueSetComposeIncludeConcept;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirValueSetComposeIncludeConcepts[index : Integer] : TFhirValueSetComposeIncludeConcept read GetItemN write SetItemN; default;
  End;

  // Select concepts by specify a matching criteria based on the properties (including relationships) defined by the system. If multiple filters are specified, they SHALL all be true.
  TFhirValueSetComposeIncludeFilter = class (TFhirBackboneElement)
  protected
    FProperty_ : TFhirCode;
    FOp : TFhirEnum;
    FValue : TFhirCode;
    Procedure SetProperty_(value : TFhirCode);
    Function GetProperty_ST : String;
    Procedure SetProperty_ST(value : String);
    Procedure SetOp(value : TFhirEnum);
    Function GetOpST : TFhirFilterOperatorEnum;
    Procedure SetOpST(value : TFhirFilterOperatorEnum);
    Procedure SetValue(value : TFhirCode);
    Function GetValueST : String;
    Procedure SetValueST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirValueSetComposeIncludeFilter; overload;
    function Clone : TFhirValueSetComposeIncludeFilter; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code that identifies a property defined in the code system.
    property property_ : String read GetProperty_ST write SetProperty_ST;
    // A code that identifies a property defined in the code system.
    property property_Element : TFhirCode read FProperty_ write SetProperty_;

    // The kind of operation to perform as a part of the filter criteria.
    property op : TFhirFilterOperatorEnum read GetOpST write SetOpST;
    property opElement : TFhirEnum read FOp write SetOp;

    // Typed access to The match value may be either a code defined by the system, or a string value, which is a regex match on the literal string of the property value.
    property value : String read GetValueST write SetValueST;
    // The match value may be either a code defined by the system, or a string value, which is a regex match on the literal string of the property value.
    property valueElement : TFhirCode read FValue write SetValue;

  end;

  TFhirValueSetComposeIncludeFilterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirValueSetComposeIncludeFilterList;
    function GetCurrent : TFhirValueSetComposeIncludeFilter;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirValueSetComposeIncludeFilterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirValueSetComposeIncludeFilter read GetCurrent;
  end;

  TFhirValueSetComposeIncludeFilterList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirValueSetComposeIncludeFilter;
    procedure SetItemN(index : Integer; value : TFhirValueSetComposeIncludeFilter);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirValueSetComposeIncludeFilterList; Overload;
    function Clone : TFhirValueSetComposeIncludeFilterList; Overload;
    function GetEnumerator : TFhirValueSetComposeIncludeFilterListEnumerator;
    

    //  Add a FhirValueSetComposeIncludeFilter to the end of the list.
    function Append : TFhirValueSetComposeIncludeFilter;

    
    // Add an already existing FhirValueSetComposeIncludeFilter to the end of the list.
    procedure AddItem(value : TFhirValueSetComposeIncludeFilter); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirValueSetComposeIncludeFilter) : Integer;
    

    // Insert FhirValueSetComposeIncludeFilter before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirValueSetComposeIncludeFilter;
    

    // Insert an existing FhirValueSetComposeIncludeFilter before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirValueSetComposeIncludeFilter);
    
    // Get the iIndexth FhirValueSetComposeIncludeFilter. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetComposeIncludeFilter);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirValueSetComposeIncludeFilter;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirValueSetComposeIncludeFilters[index : Integer] : TFhirValueSetComposeIncludeFilter read GetItemN write SetItemN; default;
  End;

  // A value set can also be "expanded", where the value set is turned into a simple collection of enumerated codes. This element holds the expansion, if it has been performed.
  TFhirValueSetExpansion = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirUri;
    FTimestamp : TFhirDateTime;
    FTotal : TFhirInteger;
    FOffset : TFhirInteger;
    FparameterList : TFhirValueSetExpansionParameterList;
    FcontainsList : TFhirValueSetExpansionContainsList;
    Procedure SetIdentifier(value : TFhirUri);
    Function GetIdentifierST : String;
    Procedure SetIdentifierST(value : String);
    Procedure SetTimestamp(value : TFhirDateTime);
    Function GetTimestampST : TFslDateTime;
    Procedure SetTimestampST(value : TFslDateTime);
    Procedure SetTotal(value : TFhirInteger);
    Function GetTotalST : String;
    Procedure SetTotalST(value : String);
    Procedure SetOffset(value : TFhirInteger);
    Function GetOffsetST : String;
    Procedure SetOffsetST(value : String);
    function GetParameterList : TFhirValueSetExpansionParameterList;
    function GetHasParameterList : Boolean;
    function GetContainsList : TFhirValueSetExpansionContainsList;
    function GetHasContainsList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirValueSetExpansion; overload;
    function Clone : TFhirValueSetExpansion; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An identifier that uniquely identifies this expansion of the valueset. Systems may re-use the same identifier as long as the expansion and the definition remain the same, but are not required to do so.
    property identifier : String read GetIdentifierST write SetIdentifierST;
    // An identifier that uniquely identifies this expansion of the valueset. Systems may re-use the same identifier as long as the expansion and the definition remain the same, but are not required to do so.
    property identifierElement : TFhirUri read FIdentifier write SetIdentifier;

    // Typed access to The time at which the expansion was produced by the expanding system.
    property timestamp : TFslDateTime read GetTimestampST write SetTimestampST;
    // The time at which the expansion was produced by the expanding system.
    property timestampElement : TFhirDateTime read FTimestamp write SetTimestamp;

    // Typed access to The total number of concepts in the expansion. If the number of concept nodes in this resource is less than the stated number, then the server can return more using the offset parameter.
    property total : String read GetTotalST write SetTotalST;
    // The total number of concepts in the expansion. If the number of concept nodes in this resource is less than the stated number, then the server can return more using the offset parameter.
    property totalElement : TFhirInteger read FTotal write SetTotal;

    // Typed access to If paging is being used, the offset at which this resource starts.  I.e. this resource is a partial view into the expansion. If paging is not being used, this element SHALL not be present.
    property offset : String read GetOffsetST write SetOffsetST;
    // If paging is being used, the offset at which this resource starts.  I.e. this resource is a partial view into the expansion. If paging is not being used, this element SHALL not be present.
    property offsetElement : TFhirInteger read FOffset write SetOffset;

    // A parameter that controlled the expansion process. These parameters may be used by users of expanded value sets to check whether the expansion is suitable for a particular purpose, or to pick the correct expansion.
    property parameterList : TFhirValueSetExpansionParameterList read GetParameterList;
    property hasParameterList : boolean read GetHasParameterList;

    // The codes that are contained in the value set expansion.
    property containsList : TFhirValueSetExpansionContainsList read GetContainsList;
    property hasContainsList : boolean read GetHasContainsList;

  end;

  TFhirValueSetExpansionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirValueSetExpansionList;
    function GetCurrent : TFhirValueSetExpansion;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirValueSetExpansionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirValueSetExpansion read GetCurrent;
  end;

  TFhirValueSetExpansionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirValueSetExpansion;
    procedure SetItemN(index : Integer; value : TFhirValueSetExpansion);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirValueSetExpansionList; Overload;
    function Clone : TFhirValueSetExpansionList; Overload;
    function GetEnumerator : TFhirValueSetExpansionListEnumerator;
    

    //  Add a FhirValueSetExpansion to the end of the list.
    function Append : TFhirValueSetExpansion;

    
    // Add an already existing FhirValueSetExpansion to the end of the list.
    procedure AddItem(value : TFhirValueSetExpansion); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirValueSetExpansion) : Integer;
    

    // Insert FhirValueSetExpansion before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirValueSetExpansion;
    

    // Insert an existing FhirValueSetExpansion before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirValueSetExpansion);
    
    // Get the iIndexth FhirValueSetExpansion. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetExpansion);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirValueSetExpansion;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirValueSetExpansions[index : Integer] : TFhirValueSetExpansion read GetItemN write SetItemN; default;
  End;

  // A parameter that controlled the expansion process. These parameters may be used by users of expanded value sets to check whether the expansion is suitable for a particular purpose, or to pick the correct expansion.
  TFhirValueSetExpansionParameter = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FValue : TFhirType;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetValue(value : TFhirType);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirValueSetExpansionParameter; overload;
    function Clone : TFhirValueSetExpansionParameter; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The name of the parameter.
    property name : String read GetNameST write SetNameST;
    // The name of the parameter.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to The value of the parameter. (defined for API consistency)
    property value : TFhirType read FValue write SetValue;
    // The value of the parameter.
    property valueElement : TFhirType read FValue write SetValue;

  end;

  TFhirValueSetExpansionParameterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirValueSetExpansionParameterList;
    function GetCurrent : TFhirValueSetExpansionParameter;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirValueSetExpansionParameterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirValueSetExpansionParameter read GetCurrent;
  end;

  TFhirValueSetExpansionParameterList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirValueSetExpansionParameter;
    procedure SetItemN(index : Integer; value : TFhirValueSetExpansionParameter);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirValueSetExpansionParameterList; Overload;
    function Clone : TFhirValueSetExpansionParameterList; Overload;
    function GetEnumerator : TFhirValueSetExpansionParameterListEnumerator;
    

    //  Add a FhirValueSetExpansionParameter to the end of the list.
    function Append : TFhirValueSetExpansionParameter;

    
    // Add an already existing FhirValueSetExpansionParameter to the end of the list.
    procedure AddItem(value : TFhirValueSetExpansionParameter); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirValueSetExpansionParameter) : Integer;
    

    // Insert FhirValueSetExpansionParameter before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirValueSetExpansionParameter;
    

    // Insert an existing FhirValueSetExpansionParameter before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirValueSetExpansionParameter);
    
    // Get the iIndexth FhirValueSetExpansionParameter. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetExpansionParameter);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirValueSetExpansionParameter;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirValueSetExpansionParameters[index : Integer] : TFhirValueSetExpansionParameter read GetItemN write SetItemN; default;
  End;

  // The codes that are contained in the value set expansion.
  TFhirValueSetExpansionContains = class (TFhirBackboneElement)
  protected
    FSystem : TFhirUri;
    FAbstract : TFhirBoolean;
    FVersion : TFhirString;
    FCode : TFhirCode;
    FDisplay : TFhirString;
    FcontainsList : TFhirValueSetExpansionContainsList;
    Procedure SetSystem(value : TFhirUri);
    Function GetSystemST : String;
    Procedure SetSystemST(value : String);
    Procedure SetAbstract(value : TFhirBoolean);
    Function GetAbstractST : Boolean;
    Procedure SetAbstractST(value : Boolean);
    Procedure SetVersion(value : TFhirString);
    Function GetVersionST : String;
    Procedure SetVersionST(value : String);
    Procedure SetCode(value : TFhirCode);
    Function GetCodeST : String;
    Procedure SetCodeST(value : String);
    Procedure SetDisplay(value : TFhirString);
    Function GetDisplayST : String;
    Procedure SetDisplayST(value : String);
    function GetContainsList : TFhirValueSetExpansionContainsList;
    function GetHasContainsList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirValueSetExpansionContains; overload;
    function Clone : TFhirValueSetExpansionContains; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URI which is the code system in which the code for this item in the expansion is defined.
    property system : String read GetSystemST write SetSystemST;
    // An absolute URI which is the code system in which the code for this item in the expansion is defined.
    property systemElement : TFhirUri read FSystem write SetSystem;

    // Typed access to If true, this entry is included in the expansion for navigational purposes, and the user cannot select the code directly as a proper value.
    property abstract : Boolean read GetAbstractST write SetAbstractST;
    // If true, this entry is included in the expansion for navigational purposes, and the user cannot select the code directly as a proper value.
    property abstractElement : TFhirBoolean read FAbstract write SetAbstract;

    // Typed access to The version of this code system that defined this code and/or display. This should only be used with code systems that do not enforce concept permanence.
    property version : String read GetVersionST write SetVersionST;
    // The version of this code system that defined this code and/or display. This should only be used with code systems that do not enforce concept permanence.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to The code for this item in the expansion hierarchy. If this code is missing the entry in the hierarchy is a place holder (abstract) and does not represent a valid code in the value set.
    property code : String read GetCodeST write SetCodeST;
    // The code for this item in the expansion hierarchy. If this code is missing the entry in the hierarchy is a place holder (abstract) and does not represent a valid code in the value set.
    property codeElement : TFhirCode read FCode write SetCode;

    // Typed access to The recommended display for this item in the expansion.
    property display : String read GetDisplayST write SetDisplayST;
    // The recommended display for this item in the expansion.
    property displayElement : TFhirString read FDisplay write SetDisplay;

    // Other codes and entries contained under this entry in the hierarchy.
    property containsList : TFhirValueSetExpansionContainsList read GetContainsList;
    property hasContainsList : boolean read GetHasContainsList;

  end;

  TFhirValueSetExpansionContainsListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirValueSetExpansionContainsList;
    function GetCurrent : TFhirValueSetExpansionContains;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirValueSetExpansionContainsList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirValueSetExpansionContains read GetCurrent;
  end;

  TFhirValueSetExpansionContainsList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirValueSetExpansionContains;
    procedure SetItemN(index : Integer; value : TFhirValueSetExpansionContains);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirValueSetExpansionContainsList; Overload;
    function Clone : TFhirValueSetExpansionContainsList; Overload;
    function GetEnumerator : TFhirValueSetExpansionContainsListEnumerator;
    

    //  Add a FhirValueSetExpansionContains to the end of the list.
    function Append : TFhirValueSetExpansionContains;

    
    // Add an already existing FhirValueSetExpansionContains to the end of the list.
    procedure AddItem(value : TFhirValueSetExpansionContains); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirValueSetExpansionContains) : Integer;
    

    // Insert FhirValueSetExpansionContains before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirValueSetExpansionContains;
    

    // Insert an existing FhirValueSetExpansionContains before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirValueSetExpansionContains);
    
    // Get the iIndexth FhirValueSetExpansionContains. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetExpansionContains);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirValueSetExpansionContains;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirValueSetExpansionContains[index : Integer] : TFhirValueSetExpansionContains read GetItemN write SetItemN; default;
  End;

  // A value set specifies a set of codes drawn from one or more code systems.
  TFhirValueSet = class (TFhirDomainResource)
  protected
    FUrl : TFhirUri;
    FIdentifier : TFhirIdentifier;
    FVersion : TFhirString;
    FName : TFhirString;
    FStatus : TFhirEnum;
    FExperimental : TFhirBoolean;
    FPublisher : TFhirString;
    FcontactList : TFhirValueSetContactList;
    FDate : TFhirDateTime;
    FLockedDate : TFhirDate;
    FDescription : TFhirString;
    FuseContextList : TFhirCodeableConceptList;
    FImmutable : TFhirBoolean;
    FRequirements : TFhirString;
    FCopyright : TFhirString;
    FExtensible : TFhirBoolean;
    FCodeSystem : TFhirValueSetCodeSystem;
    FCompose : TFhirValueSetCompose;
    FExpansion : TFhirValueSetExpansion;
    Procedure SetUrl(value : TFhirUri);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetVersion(value : TFhirString);
    Function GetVersionST : String;
    Procedure SetVersionST(value : String);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirConformanceResourceStatusEnum;
    Procedure SetStatusST(value : TFhirConformanceResourceStatusEnum);
    Procedure SetExperimental(value : TFhirBoolean);
    Function GetExperimentalST : Boolean;
    Procedure SetExperimentalST(value : Boolean);
    Procedure SetPublisher(value : TFhirString);
    Function GetPublisherST : String;
    Procedure SetPublisherST(value : String);
    function GetContactList : TFhirValueSetContactList;
    function GetHasContactList : Boolean;
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetLockedDate(value : TFhirDate);
    Function GetLockedDateST : TFslDateTime;
    Procedure SetLockedDateST(value : TFslDateTime);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    function GetUseContextList : TFhirCodeableConceptList;
    function GetHasUseContextList : Boolean;
    Procedure SetImmutable(value : TFhirBoolean);
    Function GetImmutableST : Boolean;
    Procedure SetImmutableST(value : Boolean);
    Procedure SetRequirements(value : TFhirString);
    Function GetRequirementsST : String;
    Procedure SetRequirementsST(value : String);
    Procedure SetCopyright(value : TFhirString);
    Function GetCopyrightST : String;
    Procedure SetCopyrightST(value : String);
    Procedure SetExtensible(value : TFhirBoolean);
    Function GetExtensibleST : Boolean;
    Procedure SetExtensibleST(value : Boolean);
    Procedure SetCodeSystem(value : TFhirValueSetCodeSystem);
    Procedure SetCompose(value : TFhirValueSetCompose);
    Procedure SetExpansion(value : TFhirValueSetExpansion);
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirValueSet; overload;
    function Clone : TFhirValueSet; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URL that is used to identify this value set when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this value set is (or will be) {$IFNDEF FPC}published{$ENDIF}.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URL that is used to identify this value set when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this value set is (or will be) {$IFNDEF FPC}published{$ENDIF}.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to Formal identifier that is used to identify this value set when it is represented in other formats, or referenced in a specification, model, design or an instance. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Formal identifier that is used to identify this value set when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to Used to identify this version of the value set when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the profile author manually and the value should be a timestamp.
    property version : String read GetVersionST write SetVersionST;
    // Used to identify this version of the value set when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the profile author manually and the value should be a timestamp.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A free text natural language name describing the value set.
    property name : String read GetNameST write SetNameST;
    // A free text natural language name describing the value set.
    property nameElement : TFhirString read FName write SetName;

    // The status of the value set.
    property status : TFhirConformanceResourceStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to This valueset was authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // This valueset was authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The name of the individual or organization that {$IFNDEF FPC}published{$ENDIF} the value set.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the individual or organization that {$IFNDEF FPC}published{$ENDIF} the value set.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contacts to assist a user in finding and communicating with the publisher.
    property contactList : TFhirValueSetContactList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to The date that the value set status was last changed. The date must change when the business version changes, if it does, and it must change if the status code changes. In addition, it should change when the substantive content of the implementation guide changes (e.g. the 'content logical definition').
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date that the value set status was last changed. The date must change when the business version changes, if it does, and it must change if the status code changes. In addition, it should change when the substantive content of the implementation guide changes (e.g. the 'content logical definition').
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to If a locked date is defined, then the Content Logical Definition must be evaluated using the current version of all referenced code system(s) and value set instances as of the locked date.
    property lockedDate : TFslDateTime read GetLockedDateST write SetLockedDateST;
    // If a locked date is defined, then the Content Logical Definition must be evaluated using the current version of all referenced code system(s) and value set instances as of the locked date.
    property lockedDateElement : TFhirDate read FLockedDate write SetLockedDate;

    // Typed access to A free text natural language description of the use of the value set - reason for definition, "the semantic space" to be included in the value set, conditions of use, etc. The description may include a list of expected usages for the value set and can also describe the approach taken to build the value set.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the use of the value set - reason for definition, "the semantic space" to be included in the value set, conditions of use, etc. The description may include a list of expected usages for the value set and can also describe the approach taken to build the value set.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These terms may be used to assist with indexing and searching of value set definitions.
    property useContextList : TFhirCodeableConceptList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // Typed access to If this is set to 'true', then no new versions of the content logical definition can be created.  Note: Other metadata might still change.
    property immutable : Boolean read GetImmutableST write SetImmutableST;
    // If this is set to 'true', then no new versions of the content logical definition can be created.  Note: Other metadata might still change.
    property immutableElement : TFhirBoolean read FImmutable write SetImmutable;

    // Typed access to Explains why this value set is needed and why it has been constrained as it has.
    property requirements : String read GetRequirementsST write SetRequirementsST;
    // Explains why this value set is needed and why it has been constrained as it has.
    property requirementsElement : TFhirString read FRequirements write SetRequirements;

    // Typed access to A copyright statement relating to the value set and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the value set.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the value set and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the value set.
    property copyrightElement : TFhirString read FCopyright write SetCopyright;

    // Typed access to Whether this is intended to be used with an extensible binding or not.
    property extensible : Boolean read GetExtensibleST write SetExtensibleST;
    // Whether this is intended to be used with an extensible binding or not.
    property extensibleElement : TFhirBoolean read FExtensible write SetExtensible;

    // Typed access to A definition of a code system, inlined into the value set (as a packaging convenience). Note that the inline code system may be used from other value sets by referring to its (codeSystem.system) directly. (defined for API consistency)
    property codeSystem : TFhirValueSetCodeSystem read FCodeSystem write SetCodeSystem;
    // A definition of a code system, inlined into the value set (as a packaging convenience). Note that the inline code system may be used from other value sets by referring to its (codeSystem.system) directly.
    property codeSystemElement : TFhirValueSetCodeSystem read FCodeSystem write SetCodeSystem;

    // Typed access to A set of criteria that provide the content logical definition of the value set by including or excluding codes from outside this value set. (defined for API consistency)
    property compose : TFhirValueSetCompose read FCompose write SetCompose;
    // A set of criteria that provide the content logical definition of the value set by including or excluding codes from outside this value set.
    property composeElement : TFhirValueSetCompose read FCompose write SetCompose;

    // Typed access to A value set can also be "expanded", where the value set is turned into a simple collection of enumerated codes. This element holds the expansion, if it has been performed. (defined for API consistency)
    property expansion : TFhirValueSetExpansion read FExpansion write SetExpansion;
    // A value set can also be "expanded", where the value set is turned into a simple collection of enumerated codes. This element holds the expansion, if it has been performed.
    property expansionElement : TFhirValueSetExpansion read FExpansion write SetExpansion;

  end;

  TFhirValueSetListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirValueSetList;
    function GetCurrent : TFhirValueSet;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirValueSetList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirValueSet read GetCurrent;
  end;

  TFhirValueSetList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirValueSet;
    procedure SetItemN(index : Integer; value : TFhirValueSet);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirValueSetList; Overload;
    function Clone : TFhirValueSetList; Overload;
    function GetEnumerator : TFhirValueSetListEnumerator;
    

    //  Add a FhirValueSet to the end of the list.
    function Append : TFhirValueSet;

    
    // Add an already existing FhirValueSet to the end of the list.
    procedure AddItem(value : TFhirValueSet); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirValueSet) : Integer;
    

    // Insert FhirValueSet before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirValueSet;
    

    // Insert an existing FhirValueSet before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirValueSet);
    
    // Get the iIndexth FhirValueSet. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirValueSet);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirValueSet;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirValueSets[index : Integer] : TFhirValueSet read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_VALUESET}

implementation

uses
  fhir2_utilities;

{$IFDEF FHIR_CONCEPTMAP}

{ TFhirConceptMapContact }

constructor TFhirConceptMapContact.Create;
begin
  inherited;
end;

destructor TFhirConceptMapContact.Destroy;
begin
  FName.free;
  FTelecomList.Free;
  inherited;
end;

procedure TFhirConceptMapContact.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirConceptMapContact(oSource).nameElement.Clone;
  if (TFhirConceptMapContact(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirConceptMapContact(oSource).FTelecomList);
  end;
end;

procedure TFhirConceptMapContact.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
end;

procedure TFhirConceptMapContact.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link)){3};
end;

function TFhirConceptMapContact.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConceptMapContact.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint){2a}
  else inherited;
end;

function TFhirConceptMapContact.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'telecom') then result := TelecomList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConceptMapContact.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConceptMapContact.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConceptMapContact.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConceptMapContact.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'telecom') then TelecomList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirConceptMapContact.fhirType : string;
begin
  result := 'contact';
end;

function TFhirConceptMapContact.Link : TFhirConceptMapContact;
begin
  result := TFhirConceptMapContact(inherited Link);
end;

function TFhirConceptMapContact.Clone : TFhirConceptMapContact;
begin
  result := TFhirConceptMapContact(inherited Clone);
end;

function TFhirConceptMapContact.equals(other : TObject) : boolean; 
var
  o : TFhirConceptMapContact;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConceptMapContact)) then
    result := false
  else
  begin
    o := TFhirConceptMapContact(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(telecomList, o.telecomList, true);
  end;
end;

function TFhirConceptMapContact.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FtelecomList);
end;

procedure TFhirConceptMapContact.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('telecom');
end;

{ TFhirConceptMapContact }

Procedure TFhirConceptMapContact.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirConceptMapContact.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirConceptMapContact.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Function TFhirConceptMapContact.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

Function TFhirConceptMapContact.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

function TFhirConceptMapContact.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FtelecomList.sizeInBytes);
end;

{ TFhirConceptMapContactListEnumerator }

Constructor TFhirConceptMapContactListEnumerator.Create(list : TFhirConceptMapContactList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConceptMapContactListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConceptMapContactListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConceptMapContactListEnumerator.GetCurrent : TFhirConceptMapContact;
begin
  Result := FList[FIndex];
end;

function TFhirConceptMapContactListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConceptMapContactList }
procedure TFhirConceptMapContactList.AddItem(value: TFhirConceptMapContact);
begin
  assert(value.ClassName = 'TFhirConceptMapContact', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConceptMapContact');
  add(value);
end;

function TFhirConceptMapContactList.Append: TFhirConceptMapContact;
begin
  result := TFhirConceptMapContact.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConceptMapContactList.ClearItems;
begin
  Clear;
end;

function TFhirConceptMapContactList.GetEnumerator : TFhirConceptMapContactListEnumerator;
begin
  result := TFhirConceptMapContactListEnumerator.Create(self.link);
end;

function TFhirConceptMapContactList.Clone: TFhirConceptMapContactList;
begin
  result := TFhirConceptMapContactList(inherited Clone);
end;

function TFhirConceptMapContactList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConceptMapContactList.GetItemN(index: Integer): TFhirConceptMapContact;
begin
  result := TFhirConceptMapContact(ObjectByIndex[index]);
end;

function TFhirConceptMapContactList.ItemClass: TFslObjectClass;
begin
  result := TFhirConceptMapContact;
end;
function TFhirConceptMapContactList.IndexOf(value: TFhirConceptMapContact): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConceptMapContactList.Insert(index: Integer): TFhirConceptMapContact;
begin
  result := TFhirConceptMapContact.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConceptMapContactList.InsertItem(index: Integer; value: TFhirConceptMapContact);
begin
  assert(value is TFhirConceptMapContact);
  Inherited Insert(index, value);
end;

function TFhirConceptMapContactList.Item(index: Integer): TFhirConceptMapContact;
begin
  result := TFhirConceptMapContact(ObjectByIndex[index]);
end;

function TFhirConceptMapContactList.Link: TFhirConceptMapContactList;
begin
  result := TFhirConceptMapContactList(inherited Link);
end;

procedure TFhirConceptMapContactList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConceptMapContactList.SetItemByIndex(index: Integer; value: TFhirConceptMapContact);
begin
  assert(value is TFhirConceptMapContact);
  FhirConceptMapContacts[index] := value;
end;

procedure TFhirConceptMapContactList.SetItemN(index: Integer; value: TFhirConceptMapContact);
begin
  assert(value is TFhirConceptMapContact);
  ObjectByIndex[index] := value;
end;

{ TFhirConceptMapElement }

constructor TFhirConceptMapElement.Create;
begin
  inherited;
end;

destructor TFhirConceptMapElement.Destroy;
begin
  FCodeSystem.free;
  FCode.free;
  FTargetList.Free;
  inherited;
end;

procedure TFhirConceptMapElement.Assign(oSource : TFslObject);
begin
  inherited;
  codeSystemElement := TFhirConceptMapElement(oSource).codeSystemElement.Clone;
  codeElement := TFhirConceptMapElement(oSource).codeElement.Clone;
  if (TFhirConceptMapElement(oSource).FTargetList = nil) then
  begin
    FTargetList.free;
    FTargetList := nil;
  end
  else
  begin
    if FTargetList = nil then
      FTargetList := TFhirConceptMapElementTargetList.Create;
    FTargetList.Assign(TFhirConceptMapElement(oSource).FTargetList);
  end;
end;

procedure TFhirConceptMapElement.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'codeSystem') Then
     list.add(self.link, 'codeSystem', FCodeSystem.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'target') Then
    list.addAll(self, 'target', FTargetList);
end;

procedure TFhirConceptMapElement.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'codeSystem', 'uri', false, TFhirUri, FCodeSystem.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirCode, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'target', '', true, TFhirConceptMapElementTarget, FTargetList.Link)){3};
end;

function TFhirConceptMapElement.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'codeSystem') then
  begin
    CodeSystemElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'target') then
  begin
    TargetList.add(propValue as TFhirConceptMapElementTarget){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConceptMapElement.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'target') then TargetList.insertItem(index, propValue as TFhirConceptMapElementTarget){2a}
  else inherited;
end;

function TFhirConceptMapElement.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'codeSystem') then result := TFhirUri.create() {5b}
  else if (propName = 'code') then result := TFhirCode.create() {5b}
  else if (propName = 'target') then result := TargetList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConceptMapElement.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'codeSystem') then result := 'uri'
  else if (propName = 'code') then result := 'code'
  else if (propName = 'target') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConceptMapElement.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'codeSystem') then CodeSystemElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'target') then deletePropertyValue('target', TargetList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConceptMapElement.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'codeSystem') then CodeSystemElement := asUri(new){5b}
  else if (propName = 'code') then CodeElement := asCode(new){5b}
  else if (propName = 'target') then replacePropertyValue('target', TargetList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConceptMapElement.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'target') then TargetList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirConceptMapElement.fhirType : string;
begin
  result := 'element';
end;

function TFhirConceptMapElement.Link : TFhirConceptMapElement;
begin
  result := TFhirConceptMapElement(inherited Link);
end;

function TFhirConceptMapElement.Clone : TFhirConceptMapElement;
begin
  result := TFhirConceptMapElement(inherited Clone);
end;

function TFhirConceptMapElement.equals(other : TObject) : boolean; 
var
  o : TFhirConceptMapElement;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConceptMapElement)) then
    result := false
  else
  begin
    o := TFhirConceptMapElement(other);
    result := compareDeep(codeSystemElement, o.codeSystemElement, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(targetList, o.targetList, true);
  end;
end;

function TFhirConceptMapElement.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCodeSystem) and isEmptyProp(FCode) and isEmptyProp(FtargetList);
end;

procedure TFhirConceptMapElement.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('codeSystem');
  fields.add('code');
  fields.add('target');
end;

{ TFhirConceptMapElement }

Procedure TFhirConceptMapElement.SetCodeSystem(value : TFhirUri);
begin
  FCodeSystem.free;
  FCodeSystem := value;
end;

Function TFhirConceptMapElement.GetCodeSystemST : String;
begin
  if FCodeSystem = nil then
    result := ''
  else
    result := FCodeSystem.value;
end;

Procedure TFhirConceptMapElement.SetCodeSystemST(value : String);
begin
  if value <> '' then
  begin
    if FCodeSystem = nil then
      FCodeSystem := TFhirUri.create;
    FCodeSystem.value := value
  end
  else if FCodeSystem <> nil then
    FCodeSystem.value := '';
end;

Procedure TFhirConceptMapElement.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirConceptMapElement.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

Procedure TFhirConceptMapElement.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

Function TFhirConceptMapElement.GetTargetList : TFhirConceptMapElementTargetList;
begin
  if FTargetList = nil then
    FTargetList := TFhirConceptMapElementTargetList.Create;
  result := FTargetList;
end;

Function TFhirConceptMapElement.GetHasTargetList : boolean;
begin
  result := (FTargetList <> nil) and (FTargetList.count > 0);
end;

function TFhirConceptMapElement.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCodeSystem.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FtargetList.sizeInBytes);
end;

{ TFhirConceptMapElementListEnumerator }

Constructor TFhirConceptMapElementListEnumerator.Create(list : TFhirConceptMapElementList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConceptMapElementListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConceptMapElementListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConceptMapElementListEnumerator.GetCurrent : TFhirConceptMapElement;
begin
  Result := FList[FIndex];
end;

function TFhirConceptMapElementListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConceptMapElementList }
procedure TFhirConceptMapElementList.AddItem(value: TFhirConceptMapElement);
begin
  assert(value.ClassName = 'TFhirConceptMapElement', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConceptMapElement');
  add(value);
end;

function TFhirConceptMapElementList.Append: TFhirConceptMapElement;
begin
  result := TFhirConceptMapElement.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConceptMapElementList.ClearItems;
begin
  Clear;
end;

function TFhirConceptMapElementList.GetEnumerator : TFhirConceptMapElementListEnumerator;
begin
  result := TFhirConceptMapElementListEnumerator.Create(self.link);
end;

function TFhirConceptMapElementList.Clone: TFhirConceptMapElementList;
begin
  result := TFhirConceptMapElementList(inherited Clone);
end;

function TFhirConceptMapElementList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConceptMapElementList.GetItemN(index: Integer): TFhirConceptMapElement;
begin
  result := TFhirConceptMapElement(ObjectByIndex[index]);
end;

function TFhirConceptMapElementList.ItemClass: TFslObjectClass;
begin
  result := TFhirConceptMapElement;
end;
function TFhirConceptMapElementList.IndexOf(value: TFhirConceptMapElement): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConceptMapElementList.Insert(index: Integer): TFhirConceptMapElement;
begin
  result := TFhirConceptMapElement.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConceptMapElementList.InsertItem(index: Integer; value: TFhirConceptMapElement);
begin
  assert(value is TFhirConceptMapElement);
  Inherited Insert(index, value);
end;

function TFhirConceptMapElementList.Item(index: Integer): TFhirConceptMapElement;
begin
  result := TFhirConceptMapElement(ObjectByIndex[index]);
end;

function TFhirConceptMapElementList.Link: TFhirConceptMapElementList;
begin
  result := TFhirConceptMapElementList(inherited Link);
end;

procedure TFhirConceptMapElementList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConceptMapElementList.SetItemByIndex(index: Integer; value: TFhirConceptMapElement);
begin
  assert(value is TFhirConceptMapElement);
  FhirConceptMapElements[index] := value;
end;

procedure TFhirConceptMapElementList.SetItemN(index: Integer; value: TFhirConceptMapElement);
begin
  assert(value is TFhirConceptMapElement);
  ObjectByIndex[index] := value;
end;

{ TFhirConceptMapElementTarget }

constructor TFhirConceptMapElementTarget.Create;
begin
  inherited;
end;

destructor TFhirConceptMapElementTarget.Destroy;
begin
  FCodeSystem.free;
  FCode.free;
  FEquivalence.free;
  FComments.free;
  FDependsOnList.Free;
  FProductList.Free;
  inherited;
end;

procedure TFhirConceptMapElementTarget.Assign(oSource : TFslObject);
begin
  inherited;
  codeSystemElement := TFhirConceptMapElementTarget(oSource).codeSystemElement.Clone;
  codeElement := TFhirConceptMapElementTarget(oSource).codeElement.Clone;
  FEquivalence := TFhirConceptMapElementTarget(oSource).FEquivalence.Link;
  commentsElement := TFhirConceptMapElementTarget(oSource).commentsElement.Clone;
  if (TFhirConceptMapElementTarget(oSource).FDependsOnList = nil) then
  begin
    FDependsOnList.free;
    FDependsOnList := nil;
  end
  else
  begin
    if FDependsOnList = nil then
      FDependsOnList := TFhirConceptMapElementTargetDependsOnList.Create;
    FDependsOnList.Assign(TFhirConceptMapElementTarget(oSource).FDependsOnList);
  end;
  if (TFhirConceptMapElementTarget(oSource).FProductList = nil) then
  begin
    FProductList.free;
    FProductList := nil;
  end
  else
  begin
    if FProductList = nil then
      FProductList := TFhirConceptMapElementTargetDependsOnList.Create;
    FProductList.Assign(TFhirConceptMapElementTarget(oSource).FProductList);
  end;
end;

procedure TFhirConceptMapElementTarget.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'codeSystem') Then
     list.add(self.link, 'codeSystem', FCodeSystem.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'equivalence') Then
     list.add(self.link, 'equivalence', FEquivalence.Link);
  if (child_name = 'comments') Then
     list.add(self.link, 'comments', FComments.Link);
  if (child_name = 'dependsOn') Then
    list.addAll(self, 'dependsOn', FDependsOnList);
  if (child_name = 'product') Then
    list.addAll(self, 'product', FProductList);
end;

procedure TFhirConceptMapElementTarget.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'codeSystem', 'uri', false, TFhirUri, FCodeSystem.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirCode, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'equivalence', 'code', false, TFHIREnum, FEquivalence.Link));{1}
  oList.add(TFHIRProperty.create(self, 'comments', 'string', false, TFhirString, FComments.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dependsOn', '', true, TFhirConceptMapElementTargetDependsOn, FDependsOnList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'product', '@ConceptMap.element.target.dependsOn', true, TFhirConceptMapElementTargetDependsOn, FProductList.Link)){3};
end;

function TFhirConceptMapElementTarget.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'codeSystem') then
  begin
    CodeSystemElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'equivalence') then
  begin
    EquivalenceElement := asEnum(SYSTEMS_TFhirConceptMapEquivalenceEnum, CODES_TFhirConceptMapEquivalenceEnum, propValue);
    result := propValue
  end
  else if (propName = 'comments') then
  begin
    CommentsElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'dependsOn') then
  begin
    DependsOnList.add(propValue as TFhirConceptMapElementTargetDependsOn){2a};
    result := propValue;
  end
  else if (propName = 'product') then
  begin
    ProductList.add(propValue as TFhirConceptMapElementTargetDependsOn){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConceptMapElementTarget.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'dependsOn') then DependsOnList.insertItem(index, propValue as TFhirConceptMapElementTargetDependsOn){2a}
  else if (propName = 'product') then ProductList.insertItem(index, propValue as TFhirConceptMapElementTargetDependsOn){2a}
  else inherited;
end;

function TFhirConceptMapElementTarget.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'codeSystem') then result := TFhirUri.create() {5b}
  else if (propName = 'code') then result := TFhirCode.create() {5b}
  else if (propName = 'comments') then result := TFhirString.create() {5b}
  else if (propName = 'dependsOn') then result := DependsOnList.new(){2}
  else if (propName = 'product') then result := ProductList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConceptMapElementTarget.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'codeSystem') then result := 'uri'
  else if (propName = 'code') then result := 'code'
  else if (propName = 'equivalence') then result := 'code'
  else if (propName = 'comments') then result := 'string'
  else if (propName = 'dependsOn') then result := ''
  else if (propName = 'product') then result := '@ConceptMap.element.target.dependsOn'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConceptMapElementTarget.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'codeSystem') then CodeSystemElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'equivalence') then EquivalenceElement := nil
  else if (propName = 'comments') then CommentsElement := nil
  else if (propName = 'dependsOn') then deletePropertyValue('dependsOn', DependsOnList, value) {2}
  else if (propName = 'product') then deletePropertyValue('product', ProductList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConceptMapElementTarget.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'codeSystem') then CodeSystemElement := asUri(new){5b}
  else if (propName = 'code') then CodeElement := asCode(new){5b}
  else if (propName = 'equivalence') then EquivalenceElement := asEnum(SYSTEMS_TFhirConceptMapEquivalenceEnum, CODES_TFhirConceptMapEquivalenceEnum, new){4}
  else if (propName = 'comments') then CommentsElement := asString(new){5b}
  else if (propName = 'dependsOn') then replacePropertyValue('dependsOn', DependsOnList, existing, new) {2}
  else if (propName = 'product') then replacePropertyValue('product', ProductList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConceptMapElementTarget.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'dependsOn') then DependsOnList.move(source, destination){2a}
  else if (propName = 'product') then ProductList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirConceptMapElementTarget.fhirType : string;
begin
  result := 'target';
end;

function TFhirConceptMapElementTarget.Link : TFhirConceptMapElementTarget;
begin
  result := TFhirConceptMapElementTarget(inherited Link);
end;

function TFhirConceptMapElementTarget.Clone : TFhirConceptMapElementTarget;
begin
  result := TFhirConceptMapElementTarget(inherited Clone);
end;

function TFhirConceptMapElementTarget.equals(other : TObject) : boolean; 
var
  o : TFhirConceptMapElementTarget;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConceptMapElementTarget)) then
    result := false
  else
  begin
    o := TFhirConceptMapElementTarget(other);
    result := compareDeep(codeSystemElement, o.codeSystemElement, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(equivalenceElement, o.equivalenceElement, true) and compareDeep(commentsElement, o.commentsElement, true) and 
      compareDeep(dependsOnList, o.dependsOnList, true) and compareDeep(productList, o.productList, true);
  end;
end;

function TFhirConceptMapElementTarget.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCodeSystem) and isEmptyProp(FCode) and isEmptyProp(FEquivalence) and isEmptyProp(FComments) and isEmptyProp(FdependsOnList) and isEmptyProp(FproductList);
end;

procedure TFhirConceptMapElementTarget.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('codeSystem');
  fields.add('code');
  fields.add('equivalence');
  fields.add('comments');
  fields.add('dependsOn');
  fields.add('product');
end;

{ TFhirConceptMapElementTarget }

Procedure TFhirConceptMapElementTarget.SetCodeSystem(value : TFhirUri);
begin
  FCodeSystem.free;
  FCodeSystem := value;
end;

Function TFhirConceptMapElementTarget.GetCodeSystemST : String;
begin
  if FCodeSystem = nil then
    result := ''
  else
    result := FCodeSystem.value;
end;

Procedure TFhirConceptMapElementTarget.SetCodeSystemST(value : String);
begin
  if value <> '' then
  begin
    if FCodeSystem = nil then
      FCodeSystem := TFhirUri.create;
    FCodeSystem.value := value
  end
  else if FCodeSystem <> nil then
    FCodeSystem.value := '';
end;

Procedure TFhirConceptMapElementTarget.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirConceptMapElementTarget.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

Procedure TFhirConceptMapElementTarget.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

Procedure TFhirConceptMapElementTarget.SetEquivalence(value : TFhirEnum);
begin
  FEquivalence.free;
  FEquivalence := value;
end;

Function TFhirConceptMapElementTarget.GetEquivalenceST : TFhirConceptMapEquivalenceEnum;
begin
  if FEquivalence = nil then
    result := TFhirConceptMapEquivalenceEnum(0)
  else
    result := TFhirConceptMapEquivalenceEnum(StringArrayIndexOfSensitive(CODES_TFhirConceptMapEquivalenceEnum, FEquivalence.value));
end;

Procedure TFhirConceptMapElementTarget.SetEquivalenceST(value : TFhirConceptMapEquivalenceEnum);
begin
  if ord(value) = 0 then
    EquivalenceElement := nil
  else
    EquivalenceElement := TFhirEnum.create(SYSTEMS_TFhirConceptMapEquivalenceEnum[value], CODES_TFhirConceptMapEquivalenceEnum[value]);
end;

Procedure TFhirConceptMapElementTarget.SetComments(value : TFhirString);
begin
  FComments.free;
  FComments := value;
end;

Function TFhirConceptMapElementTarget.GetCommentsST : String;
begin
  if FComments = nil then
    result := ''
  else
    result := FComments.value;
end;

Procedure TFhirConceptMapElementTarget.SetCommentsST(value : String);
begin
  if value <> '' then
  begin
    if FComments = nil then
      FComments := TFhirString.create;
    FComments.value := value
  end
  else if FComments <> nil then
    FComments.value := '';
end;

Function TFhirConceptMapElementTarget.GetDependsOnList : TFhirConceptMapElementTargetDependsOnList;
begin
  if FDependsOnList = nil then
    FDependsOnList := TFhirConceptMapElementTargetDependsOnList.Create;
  result := FDependsOnList;
end;

Function TFhirConceptMapElementTarget.GetHasDependsOnList : boolean;
begin
  result := (FDependsOnList <> nil) and (FDependsOnList.count > 0);
end;

Function TFhirConceptMapElementTarget.GetProductList : TFhirConceptMapElementTargetDependsOnList;
begin
  if FProductList = nil then
    FProductList := TFhirConceptMapElementTargetDependsOnList.Create;
  result := FProductList;
end;

Function TFhirConceptMapElementTarget.GetHasProductList : boolean;
begin
  result := (FProductList <> nil) and (FProductList.count > 0);
end;

function TFhirConceptMapElementTarget.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCodeSystem.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FEquivalence.sizeInBytes);
  inc(result, FComments.sizeInBytes);
  inc(result, FdependsOnList.sizeInBytes);
  inc(result, FproductList.sizeInBytes);
end;

{ TFhirConceptMapElementTargetListEnumerator }

Constructor TFhirConceptMapElementTargetListEnumerator.Create(list : TFhirConceptMapElementTargetList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConceptMapElementTargetListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConceptMapElementTargetListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConceptMapElementTargetListEnumerator.GetCurrent : TFhirConceptMapElementTarget;
begin
  Result := FList[FIndex];
end;

function TFhirConceptMapElementTargetListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConceptMapElementTargetList }
procedure TFhirConceptMapElementTargetList.AddItem(value: TFhirConceptMapElementTarget);
begin
  assert(value.ClassName = 'TFhirConceptMapElementTarget', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConceptMapElementTarget');
  add(value);
end;

function TFhirConceptMapElementTargetList.Append: TFhirConceptMapElementTarget;
begin
  result := TFhirConceptMapElementTarget.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConceptMapElementTargetList.ClearItems;
begin
  Clear;
end;

function TFhirConceptMapElementTargetList.GetEnumerator : TFhirConceptMapElementTargetListEnumerator;
begin
  result := TFhirConceptMapElementTargetListEnumerator.Create(self.link);
end;

function TFhirConceptMapElementTargetList.Clone: TFhirConceptMapElementTargetList;
begin
  result := TFhirConceptMapElementTargetList(inherited Clone);
end;

function TFhirConceptMapElementTargetList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConceptMapElementTargetList.GetItemN(index: Integer): TFhirConceptMapElementTarget;
begin
  result := TFhirConceptMapElementTarget(ObjectByIndex[index]);
end;

function TFhirConceptMapElementTargetList.ItemClass: TFslObjectClass;
begin
  result := TFhirConceptMapElementTarget;
end;
function TFhirConceptMapElementTargetList.IndexOf(value: TFhirConceptMapElementTarget): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConceptMapElementTargetList.Insert(index: Integer): TFhirConceptMapElementTarget;
begin
  result := TFhirConceptMapElementTarget.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConceptMapElementTargetList.InsertItem(index: Integer; value: TFhirConceptMapElementTarget);
begin
  assert(value is TFhirConceptMapElementTarget);
  Inherited Insert(index, value);
end;

function TFhirConceptMapElementTargetList.Item(index: Integer): TFhirConceptMapElementTarget;
begin
  result := TFhirConceptMapElementTarget(ObjectByIndex[index]);
end;

function TFhirConceptMapElementTargetList.Link: TFhirConceptMapElementTargetList;
begin
  result := TFhirConceptMapElementTargetList(inherited Link);
end;

procedure TFhirConceptMapElementTargetList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConceptMapElementTargetList.SetItemByIndex(index: Integer; value: TFhirConceptMapElementTarget);
begin
  assert(value is TFhirConceptMapElementTarget);
  FhirConceptMapElementTargets[index] := value;
end;

procedure TFhirConceptMapElementTargetList.SetItemN(index: Integer; value: TFhirConceptMapElementTarget);
begin
  assert(value is TFhirConceptMapElementTarget);
  ObjectByIndex[index] := value;
end;

{ TFhirConceptMapElementTargetDependsOn }

constructor TFhirConceptMapElementTargetDependsOn.Create;
begin
  inherited;
end;

destructor TFhirConceptMapElementTargetDependsOn.Destroy;
begin
  FElement.free;
  FCodeSystem.free;
  FCode.free;
  inherited;
end;

procedure TFhirConceptMapElementTargetDependsOn.Assign(oSource : TFslObject);
begin
  inherited;
  elementElement := TFhirConceptMapElementTargetDependsOn(oSource).elementElement.Clone;
  codeSystemElement := TFhirConceptMapElementTargetDependsOn(oSource).codeSystemElement.Clone;
  codeElement := TFhirConceptMapElementTargetDependsOn(oSource).codeElement.Clone;
end;

procedure TFhirConceptMapElementTargetDependsOn.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'element') Then
     list.add(self.link, 'element', FElement.Link);
  if (child_name = 'codeSystem') Then
     list.add(self.link, 'codeSystem', FCodeSystem.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
end;

procedure TFhirConceptMapElementTargetDependsOn.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'element', 'uri', false, TFhirUri, FElement.Link));{2}
  oList.add(TFHIRProperty.create(self, 'codeSystem', 'uri', false, TFhirUri, FCodeSystem.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'string', false, TFhirString, FCode.Link));{2}
end;

function TFhirConceptMapElementTargetDependsOn.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'element') then
  begin
    ElementElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'codeSystem') then
  begin
    CodeSystemElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConceptMapElementTargetDependsOn.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirConceptMapElementTargetDependsOn.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'element') then result := TFhirUri.create() {5b}
  else if (propName = 'codeSystem') then result := TFhirUri.create() {5b}
  else if (propName = 'code') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConceptMapElementTargetDependsOn.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'element') then result := 'uri'
  else if (propName = 'codeSystem') then result := 'uri'
  else if (propName = 'code') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConceptMapElementTargetDependsOn.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'element') then ElementElement := nil
  else if (propName = 'codeSystem') then CodeSystemElement := nil
  else if (propName = 'code') then CodeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConceptMapElementTargetDependsOn.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'element') then ElementElement := asUri(new){5b}
  else if (propName = 'codeSystem') then CodeSystemElement := asUri(new){5b}
  else if (propName = 'code') then CodeElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConceptMapElementTargetDependsOn.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirConceptMapElementTargetDependsOn.fhirType : string;
begin
  result := 'dependsOn';
end;

function TFhirConceptMapElementTargetDependsOn.Link : TFhirConceptMapElementTargetDependsOn;
begin
  result := TFhirConceptMapElementTargetDependsOn(inherited Link);
end;

function TFhirConceptMapElementTargetDependsOn.Clone : TFhirConceptMapElementTargetDependsOn;
begin
  result := TFhirConceptMapElementTargetDependsOn(inherited Clone);
end;

function TFhirConceptMapElementTargetDependsOn.equals(other : TObject) : boolean; 
var
  o : TFhirConceptMapElementTargetDependsOn;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConceptMapElementTargetDependsOn)) then
    result := false
  else
  begin
    o := TFhirConceptMapElementTargetDependsOn(other);
    result := compareDeep(elementElement, o.elementElement, true) and compareDeep(codeSystemElement, o.codeSystemElement, true) and 
      compareDeep(codeElement, o.codeElement, true);
  end;
end;

function TFhirConceptMapElementTargetDependsOn.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FElement) and isEmptyProp(FCodeSystem) and isEmptyProp(FCode);
end;

procedure TFhirConceptMapElementTargetDependsOn.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('element');
  fields.add('codeSystem');
  fields.add('code');
end;

{ TFhirConceptMapElementTargetDependsOn }

Procedure TFhirConceptMapElementTargetDependsOn.SetElement(value : TFhirUri);
begin
  FElement.free;
  FElement := value;
end;

Function TFhirConceptMapElementTargetDependsOn.GetElementST : String;
begin
  if FElement = nil then
    result := ''
  else
    result := FElement.value;
end;

Procedure TFhirConceptMapElementTargetDependsOn.SetElementST(value : String);
begin
  if value <> '' then
  begin
    if FElement = nil then
      FElement := TFhirUri.create;
    FElement.value := value
  end
  else if FElement <> nil then
    FElement.value := '';
end;

Procedure TFhirConceptMapElementTargetDependsOn.SetCodeSystem(value : TFhirUri);
begin
  FCodeSystem.free;
  FCodeSystem := value;
end;

Function TFhirConceptMapElementTargetDependsOn.GetCodeSystemST : String;
begin
  if FCodeSystem = nil then
    result := ''
  else
    result := FCodeSystem.value;
end;

Procedure TFhirConceptMapElementTargetDependsOn.SetCodeSystemST(value : String);
begin
  if value <> '' then
  begin
    if FCodeSystem = nil then
      FCodeSystem := TFhirUri.create;
    FCodeSystem.value := value
  end
  else if FCodeSystem <> nil then
    FCodeSystem.value := '';
end;

Procedure TFhirConceptMapElementTargetDependsOn.SetCode(value : TFhirString);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirConceptMapElementTargetDependsOn.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

Procedure TFhirConceptMapElementTargetDependsOn.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirString.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

function TFhirConceptMapElementTargetDependsOn.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FElement.sizeInBytes);
  inc(result, FCodeSystem.sizeInBytes);
  inc(result, FCode.sizeInBytes);
end;

{ TFhirConceptMapElementTargetDependsOnListEnumerator }

Constructor TFhirConceptMapElementTargetDependsOnListEnumerator.Create(list : TFhirConceptMapElementTargetDependsOnList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConceptMapElementTargetDependsOnListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConceptMapElementTargetDependsOnListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConceptMapElementTargetDependsOnListEnumerator.GetCurrent : TFhirConceptMapElementTargetDependsOn;
begin
  Result := FList[FIndex];
end;

function TFhirConceptMapElementTargetDependsOnListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConceptMapElementTargetDependsOnList }
procedure TFhirConceptMapElementTargetDependsOnList.AddItem(value: TFhirConceptMapElementTargetDependsOn);
begin
  assert(value.ClassName = 'TFhirConceptMapElementTargetDependsOn', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConceptMapElementTargetDependsOn');
  add(value);
end;

function TFhirConceptMapElementTargetDependsOnList.Append: TFhirConceptMapElementTargetDependsOn;
begin
  result := TFhirConceptMapElementTargetDependsOn.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConceptMapElementTargetDependsOnList.ClearItems;
begin
  Clear;
end;

function TFhirConceptMapElementTargetDependsOnList.GetEnumerator : TFhirConceptMapElementTargetDependsOnListEnumerator;
begin
  result := TFhirConceptMapElementTargetDependsOnListEnumerator.Create(self.link);
end;

function TFhirConceptMapElementTargetDependsOnList.Clone: TFhirConceptMapElementTargetDependsOnList;
begin
  result := TFhirConceptMapElementTargetDependsOnList(inherited Clone);
end;

function TFhirConceptMapElementTargetDependsOnList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConceptMapElementTargetDependsOnList.GetItemN(index: Integer): TFhirConceptMapElementTargetDependsOn;
begin
  result := TFhirConceptMapElementTargetDependsOn(ObjectByIndex[index]);
end;

function TFhirConceptMapElementTargetDependsOnList.ItemClass: TFslObjectClass;
begin
  result := TFhirConceptMapElementTargetDependsOn;
end;
function TFhirConceptMapElementTargetDependsOnList.IndexOf(value: TFhirConceptMapElementTargetDependsOn): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConceptMapElementTargetDependsOnList.Insert(index: Integer): TFhirConceptMapElementTargetDependsOn;
begin
  result := TFhirConceptMapElementTargetDependsOn.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConceptMapElementTargetDependsOnList.InsertItem(index: Integer; value: TFhirConceptMapElementTargetDependsOn);
begin
  assert(value is TFhirConceptMapElementTargetDependsOn);
  Inherited Insert(index, value);
end;

function TFhirConceptMapElementTargetDependsOnList.Item(index: Integer): TFhirConceptMapElementTargetDependsOn;
begin
  result := TFhirConceptMapElementTargetDependsOn(ObjectByIndex[index]);
end;

function TFhirConceptMapElementTargetDependsOnList.Link: TFhirConceptMapElementTargetDependsOnList;
begin
  result := TFhirConceptMapElementTargetDependsOnList(inherited Link);
end;

procedure TFhirConceptMapElementTargetDependsOnList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConceptMapElementTargetDependsOnList.SetItemByIndex(index: Integer; value: TFhirConceptMapElementTargetDependsOn);
begin
  assert(value is TFhirConceptMapElementTargetDependsOn);
  FhirConceptMapElementTargetDependsOns[index] := value;
end;

procedure TFhirConceptMapElementTargetDependsOnList.SetItemN(index: Integer; value: TFhirConceptMapElementTargetDependsOn);
begin
  assert(value is TFhirConceptMapElementTargetDependsOn);
  ObjectByIndex[index] := value;
end;

{ TFhirConceptMap }

constructor TFhirConceptMap.Create;
begin
  inherited;
end;

destructor TFhirConceptMap.Destroy;
begin
  FUrl.free;
  FIdentifier.free;
  FVersion.free;
  FName.free;
  FStatus.free;
  FExperimental.free;
  FPublisher.free;
  FContactList.Free;
  FDate.free;
  FDescription.free;
  FUseContextList.Free;
  FRequirements.free;
  FCopyright.free;
  FSource.free;
  FTarget.free;
  FElementList.Free;
  inherited;
end;

function TFhirConceptMap.GetResourceType : TFhirResourceType;
begin
  result := frtConceptMap;
end;

procedure TFhirConceptMap.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirConceptMap(oSource).urlElement.Clone;
  identifier := TFhirConceptMap(oSource).identifier.Clone;
  versionElement := TFhirConceptMap(oSource).versionElement.Clone;
  nameElement := TFhirConceptMap(oSource).nameElement.Clone;
  FStatus := TFhirConceptMap(oSource).FStatus.Link;
  experimentalElement := TFhirConceptMap(oSource).experimentalElement.Clone;
  publisherElement := TFhirConceptMap(oSource).publisherElement.Clone;
  if (TFhirConceptMap(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirConceptMapContactList.Create;
    FContactList.Assign(TFhirConceptMap(oSource).FContactList);
  end;
  dateElement := TFhirConceptMap(oSource).dateElement.Clone;
  descriptionElement := TFhirConceptMap(oSource).descriptionElement.Clone;
  if (TFhirConceptMap(oSource).FUseContextList = nil) then
  begin
    FUseContextList.free;
    FUseContextList := nil;
  end
  else
  begin
    if FUseContextList = nil then
      FUseContextList := TFhirCodeableConceptList.Create;
    FUseContextList.Assign(TFhirConceptMap(oSource).FUseContextList);
  end;
  requirementsElement := TFhirConceptMap(oSource).requirementsElement.Clone;
  copyrightElement := TFhirConceptMap(oSource).copyrightElement.Clone;
  source := TFhirConceptMap(oSource).source.Clone;
  target := TFhirConceptMap(oSource).target.Clone;
  if (TFhirConceptMap(oSource).FElementList = nil) then
  begin
    FElementList.free;
    FElementList := nil;
  end
  else
  begin
    if FElementList = nil then
      FElementList := TFhirConceptMapElementList.Create;
    FElementList.Assign(TFhirConceptMap(oSource).FElementList);
  end;
end;

procedure TFhirConceptMap.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'experimental') Then
     list.add(self.link, 'experimental', FExperimental.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'useContext') Then
    list.addAll(self, 'useContext', FUseContextList);
  if (child_name = 'requirements') Then
     list.add(self.link, 'requirements', FRequirements.Link);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'source[x]') or (child_name = 'source') Then
     list.add(self.link, 'source[x]', FSource.Link);
  if (child_name = 'target[x]') or (child_name = 'target') Then
     list.add(self.link, 'target[x]', FTarget.Link);
  if (child_name = 'element') Then
    list.addAll(self, 'element', FElementList);
end;

procedure TFhirConceptMap.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));{2}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'experimental', 'boolean', false, TFhirBoolean, FExperimental.Link));{2}
  oList.add(TFHIRProperty.create(self, 'publisher', 'string', false, TFhirString, FPublisher.Link));{2}
  oList.add(TFHIRProperty.create(self, 'contact', '', true, TFhirConceptMapContact, FContactList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'useContext', 'CodeableConcept', true, TFhirCodeableConcept, FUseContextList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'requirements', 'string', false, TFhirString, FRequirements.Link));{2}
  oList.add(TFHIRProperty.create(self, 'copyright', 'string', false, TFhirString, FCopyright.Link));{2}
  oList.add(TFHIRProperty.create(self, 'source[x]', 'uri|Reference(ValueSet|StructureDefinition)', false, TFhirType, FSource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'target[x]', 'uri|Reference(ValueSet|StructureDefinition)', false, TFhirType, FTarget.Link));{2}
  oList.add(TFHIRProperty.create(self, 'element', '', true, TFhirConceptMapElement, FElementList.Link)){3};
end;

function TFhirConceptMap.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirConformanceResourceStatusEnum, CODES_TFhirConformanceResourceStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'experimental') then
  begin
    ExperimentalElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    PublisherElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirConceptMapContact){2a};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'useContext') then
  begin
    UseContextList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'requirements') then
  begin
    RequirementsElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asString(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'source', ['Uri', 'Reference'])) then
  begin
    Source := propValue as TFhirType{4};
    result := propValue;
  end
  else if (isMatchingName(propName, 'target', ['Uri', 'Reference'])) then
  begin
    Target := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'element') then
  begin
    ElementList.add(propValue as TFhirConceptMapElement){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirConceptMap.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirConceptMapContact){2a}
  else if (propName = 'useContext') then UseContextList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'element') then ElementList.insertItem(index, propValue as TFhirConceptMapElement){2a}
  else inherited;
end;

function TFhirConceptMap.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create() {5b}
  else if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'version') then result := TFhirString.create() {5b}
  else if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'experimental') then result := TFhirBoolean.create() {5b}
  else if (propName = 'publisher') then result := TFhirString.create() {5b}
  else if (propName = 'contact') then result := ContactList.new(){2}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'useContext') then result := UseContextList.new(){2}
  else if (propName = 'requirements') then result := TFhirString.create() {5b}
  else if (propName = 'copyright') then result := TFhirString.create() {5b}
  else if (isMatchingName(propName, 'source', ['Uri', 'Reference'])) then raise EFHIRException.create('Cannot make property Source'){4x}
  else if (isMatchingName(propName, 'target', ['Uri', 'Reference'])) then raise EFHIRException.create('Cannot make property Target'){4x}
  else if (propName = 'element') then result := ElementList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConceptMap.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'uri'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'experimental') then result := 'boolean'
  else if (propName = 'publisher') then result := 'string'
  else if (propName = 'contact') then result := ''
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'useContext') then result := 'CodeableConcept'
  else if (propName = 'requirements') then result := 'string'
  else if (propName = 'copyright') then result := 'string'
  else if (propName = 'source[x]') then result := 'uri|Reference'
  else if (propName = 'target[x]') then result := 'uri|Reference'
  else if (propName = 'element') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConceptMap.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'experimental') then ExperimentalElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value) {2}
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'useContext') then deletePropertyValue('useContext', UseContextList, value) {2}
  else if (propName = 'requirements') then RequirementsElement := nil
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (isMatchingName(propName, 'source', ['Uri', 'Reference'])) then SourceElement := nil{4x}
  else if (isMatchingName(propName, 'target', ['Uri', 'Reference'])) then TargetElement := nil{4x}
  else if (propName = 'element') then deletePropertyValue('element', ElementList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConceptMap.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asUri(new){5b}
  else if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'version') then VersionElement := asString(new){5b}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirConformanceResourceStatusEnum, CODES_TFhirConformanceResourceStatusEnum, new){4}
  else if (propName = 'experimental') then ExperimentalElement := asBoolean(new){5b}
  else if (propName = 'publisher') then PublisherElement := asString(new){5b}
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new) {2}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'useContext') then replacePropertyValue('useContext', UseContextList, existing, new) {2}
  else if (propName = 'requirements') then RequirementsElement := asString(new){5b}
  else if (propName = 'copyright') then CopyrightElement := asString(new){5b}
  else if (isMatchingName(propName, 'source', ['Uri', 'Reference'])) then SourceElement := new as TFhirType{4x}
  else if (isMatchingName(propName, 'target', ['Uri', 'Reference'])) then TargetElement := new as TFhirType{4x}
  else if (propName = 'element') then replacePropertyValue('element', ElementList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConceptMap.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'contact') then ContactList.move(source, destination){2a}
  else if (propName = 'useContext') then UseContextList.move(source, destination){2a}
  else if (propName = 'element') then ElementList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirConceptMap.fhirType : string;
begin
  result := 'ConceptMap';
end;

function TFhirConceptMap.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FIdentifier) and isEmptyProp(FVersion) and isEmptyProp(FName) and isEmptyProp(FStatus) and isEmptyProp(FExperimental) and isEmptyProp(FPublisher) and isEmptyProp(FcontactList) and isEmptyProp(FDate) and isEmptyProp(FDescription) and isEmptyProp(FuseContextList) and isEmptyProp(FRequirements) and isEmptyProp(FCopyright) and isEmptyProp(FSource) and isEmptyProp(FTarget) and isEmptyProp(FelementList);
end;

function TFhirConceptMap.equals(other : TObject) : boolean; 
var
  o : TFhirConceptMap;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConceptMap)) then
    result := false
  else
  begin
    o := TFhirConceptMap(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(identifierElement, o.identifierElement, true) and 
      compareDeep(versionElement, o.versionElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(experimentalElement, o.experimentalElement, true) and 
      compareDeep(publisherElement, o.publisherElement, true) and compareDeep(contactList, o.contactList, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(useContextList, o.useContextList, true) and compareDeep(requirementsElement, o.requirementsElement, true) and 
      compareDeep(copyrightElement, o.copyrightElement, true) and compareDeep(sourceElement, o.sourceElement, true) and 
      compareDeep(targetElement, o.targetElement, true) and compareDeep(elementList, o.elementList, true);
  end;
end;

function TFhirConceptMap.Link : TFhirConceptMap;
begin
  result := TFhirConceptMap(inherited Link);
end;

function TFhirConceptMap.Clone : TFhirConceptMap;
begin
  result := TFhirConceptMap(inherited Clone);
end;

procedure TFhirConceptMap.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('status');
  fields.add('experimental');
  fields.add('publisher');
  fields.add('contact');
  fields.add('date');
  fields.add('description');
  fields.add('useContext');
  fields.add('requirements');
  fields.add('copyright');
  fields.add('source[x]');
  fields.add('target[x]');
  fields.add('element');
end;

{ TFhirConceptMap }

Procedure TFhirConceptMap.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirConceptMap.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

Procedure TFhirConceptMap.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

Procedure TFhirConceptMap.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirConceptMap.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

Function TFhirConceptMap.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

Procedure TFhirConceptMap.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

Procedure TFhirConceptMap.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirConceptMap.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirConceptMap.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirConceptMap.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirConceptMap.GetStatusST : TFhirConformanceResourceStatusEnum;
begin
  if FStatus = nil then
    result := TFhirConformanceResourceStatusEnum(0)
  else
    result := TFhirConformanceResourceStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirConformanceResourceStatusEnum, FStatus.value));
end;

Procedure TFhirConceptMap.SetStatusST(value : TFhirConformanceResourceStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirConformanceResourceStatusEnum[value], CODES_TFhirConformanceResourceStatusEnum[value]);
end;

Procedure TFhirConceptMap.SetExperimental(value : TFhirBoolean);
begin
  FExperimental.free;
  FExperimental := value;
end;

Function TFhirConceptMap.GetExperimentalST : Boolean;
begin
  if FExperimental = nil then
    result := false
  else
    result := FExperimental.value;
end;

Procedure TFhirConceptMap.SetExperimentalST(value : Boolean);
begin
  if FExperimental = nil then
    FExperimental := TFhirBoolean.create;
  FExperimental.value := value
end;

Procedure TFhirConceptMap.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

Function TFhirConceptMap.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

Procedure TFhirConceptMap.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

Function TFhirConceptMap.GetContactList : TFhirConceptMapContactList;
begin
  if FContactList = nil then
    FContactList := TFhirConceptMapContactList.Create;
  result := FContactList;
end;

Function TFhirConceptMap.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

Procedure TFhirConceptMap.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirConceptMap.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirConceptMap.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirConceptMap.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirConceptMap.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirConceptMap.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Function TFhirConceptMap.GetUseContextList : TFhirCodeableConceptList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirCodeableConceptList.Create;
  result := FUseContextList;
end;

Function TFhirConceptMap.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

Procedure TFhirConceptMap.SetRequirements(value : TFhirString);
begin
  FRequirements.free;
  FRequirements := value;
end;

Function TFhirConceptMap.GetRequirementsST : String;
begin
  if FRequirements = nil then
    result := ''
  else
    result := FRequirements.value;
end;

Procedure TFhirConceptMap.SetRequirementsST(value : String);
begin
  if value <> '' then
  begin
    if FRequirements = nil then
      FRequirements := TFhirString.create;
    FRequirements.value := value
  end
  else if FRequirements <> nil then
    FRequirements.value := '';
end;

Procedure TFhirConceptMap.SetCopyright(value : TFhirString);
begin
  FCopyright.free;
  FCopyright := value;
end;

Function TFhirConceptMap.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

Procedure TFhirConceptMap.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirString.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

Procedure TFhirConceptMap.SetSource(value : TFhirType);
begin
  FSource.free;
  FSource := value;
end;

Procedure TFhirConceptMap.SetTarget(value : TFhirType);
begin
  FTarget.free;
  FTarget := value;
end;

Function TFhirConceptMap.GetElementList : TFhirConceptMapElementList;
begin
  if FElementList = nil then
    FElementList := TFhirConceptMapElementList.Create;
  result := FElementList;
end;

Function TFhirConceptMap.GetHasElementList : boolean;
begin
  result := (FElementList <> nil) and (FElementList.count > 0);
end;

function TFhirConceptMap.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FUrl.sizeInBytes);
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FVersion.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FExperimental.sizeInBytes);
  inc(result, FPublisher.sizeInBytes);
  inc(result, FcontactList.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FuseContextList.sizeInBytes);
  inc(result, FRequirements.sizeInBytes);
  inc(result, FCopyright.sizeInBytes);
  inc(result, FSource.sizeInBytes);
  inc(result, FTarget.sizeInBytes);
  inc(result, FelementList.sizeInBytes);
end;

{ TFhirConceptMapListEnumerator }

Constructor TFhirConceptMapListEnumerator.Create(list : TFhirConceptMapList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConceptMapListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConceptMapListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConceptMapListEnumerator.GetCurrent : TFhirConceptMap;
begin
  Result := FList[FIndex];
end;

function TFhirConceptMapListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConceptMapList }
procedure TFhirConceptMapList.AddItem(value: TFhirConceptMap);
begin
  assert(value.ClassName = 'TFhirConceptMap', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConceptMap');
  add(value);
end;

function TFhirConceptMapList.Append: TFhirConceptMap;
begin
  result := TFhirConceptMap.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConceptMapList.ClearItems;
begin
  Clear;
end;

function TFhirConceptMapList.GetEnumerator : TFhirConceptMapListEnumerator;
begin
  result := TFhirConceptMapListEnumerator.Create(self.link);
end;

function TFhirConceptMapList.Clone: TFhirConceptMapList;
begin
  result := TFhirConceptMapList(inherited Clone);
end;

function TFhirConceptMapList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConceptMapList.GetItemN(index: Integer): TFhirConceptMap;
begin
  result := TFhirConceptMap(ObjectByIndex[index]);
end;

function TFhirConceptMapList.ItemClass: TFslObjectClass;
begin
  result := TFhirConceptMap;
end;
function TFhirConceptMapList.IndexOf(value: TFhirConceptMap): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConceptMapList.Insert(index: Integer): TFhirConceptMap;
begin
  result := TFhirConceptMap.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConceptMapList.InsertItem(index: Integer; value: TFhirConceptMap);
begin
  assert(value is TFhirConceptMap);
  Inherited Insert(index, value);
end;

function TFhirConceptMapList.Item(index: Integer): TFhirConceptMap;
begin
  result := TFhirConceptMap(ObjectByIndex[index]);
end;

function TFhirConceptMapList.Link: TFhirConceptMapList;
begin
  result := TFhirConceptMapList(inherited Link);
end;

procedure TFhirConceptMapList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConceptMapList.SetItemByIndex(index: Integer; value: TFhirConceptMap);
begin
  assert(value is TFhirConceptMap);
  FhirConceptMaps[index] := value;
end;

procedure TFhirConceptMapList.SetItemN(index: Integer; value: TFhirConceptMap);
begin
  assert(value is TFhirConceptMap);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CONCEPTMAP}

{$IFDEF FHIR_CONFORMANCE}

{ TFhirConformanceContact }

constructor TFhirConformanceContact.Create;
begin
  inherited;
end;

destructor TFhirConformanceContact.Destroy;
begin
  FName.free;
  FTelecomList.Free;
  inherited;
end;

procedure TFhirConformanceContact.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirConformanceContact(oSource).nameElement.Clone;
  if (TFhirConformanceContact(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirConformanceContact(oSource).FTelecomList);
  end;
end;

procedure TFhirConformanceContact.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
end;

procedure TFhirConformanceContact.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link)){3};
end;

function TFhirConformanceContact.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConformanceContact.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint){2a}
  else inherited;
end;

function TFhirConformanceContact.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'telecom') then result := TelecomList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConformanceContact.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConformanceContact.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConformanceContact.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConformanceContact.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'telecom') then TelecomList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirConformanceContact.fhirType : string;
begin
  result := 'contact';
end;

function TFhirConformanceContact.Link : TFhirConformanceContact;
begin
  result := TFhirConformanceContact(inherited Link);
end;

function TFhirConformanceContact.Clone : TFhirConformanceContact;
begin
  result := TFhirConformanceContact(inherited Clone);
end;

function TFhirConformanceContact.equals(other : TObject) : boolean; 
var
  o : TFhirConformanceContact;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConformanceContact)) then
    result := false
  else
  begin
    o := TFhirConformanceContact(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(telecomList, o.telecomList, true);
  end;
end;

function TFhirConformanceContact.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FtelecomList);
end;

procedure TFhirConformanceContact.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('telecom');
end;

{ TFhirConformanceContact }

Procedure TFhirConformanceContact.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirConformanceContact.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirConformanceContact.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Function TFhirConformanceContact.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

Function TFhirConformanceContact.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

function TFhirConformanceContact.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FtelecomList.sizeInBytes);
end;

{ TFhirConformanceContactListEnumerator }

Constructor TFhirConformanceContactListEnumerator.Create(list : TFhirConformanceContactList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConformanceContactListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConformanceContactListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConformanceContactListEnumerator.GetCurrent : TFhirConformanceContact;
begin
  Result := FList[FIndex];
end;

function TFhirConformanceContactListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConformanceContactList }
procedure TFhirConformanceContactList.AddItem(value: TFhirConformanceContact);
begin
  assert(value.ClassName = 'TFhirConformanceContact', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceContact');
  add(value);
end;

function TFhirConformanceContactList.Append: TFhirConformanceContact;
begin
  result := TFhirConformanceContact.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConformanceContactList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceContactList.GetEnumerator : TFhirConformanceContactListEnumerator;
begin
  result := TFhirConformanceContactListEnumerator.Create(self.link);
end;

function TFhirConformanceContactList.Clone: TFhirConformanceContactList;
begin
  result := TFhirConformanceContactList(inherited Clone);
end;

function TFhirConformanceContactList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceContactList.GetItemN(index: Integer): TFhirConformanceContact;
begin
  result := TFhirConformanceContact(ObjectByIndex[index]);
end;

function TFhirConformanceContactList.ItemClass: TFslObjectClass;
begin
  result := TFhirConformanceContact;
end;
function TFhirConformanceContactList.IndexOf(value: TFhirConformanceContact): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConformanceContactList.Insert(index: Integer): TFhirConformanceContact;
begin
  result := TFhirConformanceContact.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConformanceContactList.InsertItem(index: Integer; value: TFhirConformanceContact);
begin
  assert(value is TFhirConformanceContact);
  Inherited Insert(index, value);
end;

function TFhirConformanceContactList.Item(index: Integer): TFhirConformanceContact;
begin
  result := TFhirConformanceContact(ObjectByIndex[index]);
end;

function TFhirConformanceContactList.Link: TFhirConformanceContactList;
begin
  result := TFhirConformanceContactList(inherited Link);
end;

procedure TFhirConformanceContactList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceContactList.SetItemByIndex(index: Integer; value: TFhirConformanceContact);
begin
  assert(value is TFhirConformanceContact);
  FhirConformanceContacts[index] := value;
end;

procedure TFhirConformanceContactList.SetItemN(index: Integer; value: TFhirConformanceContact);
begin
  assert(value is TFhirConformanceContact);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceSoftware }

constructor TFhirConformanceSoftware.Create;
begin
  inherited;
end;

destructor TFhirConformanceSoftware.Destroy;
begin
  FName.free;
  FVersion.free;
  FReleaseDate.free;
  inherited;
end;

procedure TFhirConformanceSoftware.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirConformanceSoftware(oSource).nameElement.Clone;
  versionElement := TFhirConformanceSoftware(oSource).versionElement.Clone;
  releaseDateElement := TFhirConformanceSoftware(oSource).releaseDateElement.Clone;
end;

procedure TFhirConformanceSoftware.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'releaseDate') Then
     list.add(self.link, 'releaseDate', FReleaseDate.Link);
end;

procedure TFhirConformanceSoftware.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));{2}
  oList.add(TFHIRProperty.create(self, 'releaseDate', 'dateTime', false, TFhirDateTime, FReleaseDate.Link));{2}
end;

function TFhirConformanceSoftware.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'releaseDate') then
  begin
    ReleaseDateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConformanceSoftware.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirConformanceSoftware.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'version') then result := TFhirString.create() {5b}
  else if (propName = 'releaseDate') then result := TFhirDateTime.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConformanceSoftware.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'releaseDate') then result := 'dateTime'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConformanceSoftware.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'releaseDate') then ReleaseDateElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConformanceSoftware.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'version') then VersionElement := asString(new){5b}
  else if (propName = 'releaseDate') then ReleaseDateElement := asDateTime(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConformanceSoftware.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirConformanceSoftware.fhirType : string;
begin
  result := 'software';
end;

function TFhirConformanceSoftware.Link : TFhirConformanceSoftware;
begin
  result := TFhirConformanceSoftware(inherited Link);
end;

function TFhirConformanceSoftware.Clone : TFhirConformanceSoftware;
begin
  result := TFhirConformanceSoftware(inherited Clone);
end;

function TFhirConformanceSoftware.equals(other : TObject) : boolean; 
var
  o : TFhirConformanceSoftware;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConformanceSoftware)) then
    result := false
  else
  begin
    o := TFhirConformanceSoftware(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(versionElement, o.versionElement, true) and 
      compareDeep(releaseDateElement, o.releaseDateElement, true);
  end;
end;

function TFhirConformanceSoftware.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FVersion) and isEmptyProp(FReleaseDate);
end;

procedure TFhirConformanceSoftware.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('version');
  fields.add('releaseDate');
end;

{ TFhirConformanceSoftware }

Procedure TFhirConformanceSoftware.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirConformanceSoftware.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirConformanceSoftware.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirConformanceSoftware.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

Function TFhirConformanceSoftware.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

Procedure TFhirConformanceSoftware.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

Procedure TFhirConformanceSoftware.SetReleaseDate(value : TFhirDateTime);
begin
  FReleaseDate.free;
  FReleaseDate := value;
end;

Function TFhirConformanceSoftware.GetReleaseDateST : TFslDateTime;
begin
  if FReleaseDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FReleaseDate.value;
end;

Procedure TFhirConformanceSoftware.SetReleaseDateST(value : TFslDateTime);
begin
  if FReleaseDate = nil then
    FReleaseDate := TFhirDateTime.create;
  FReleaseDate.value := value
end;

function TFhirConformanceSoftware.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FVersion.sizeInBytes);
  inc(result, FReleaseDate.sizeInBytes);
end;

{ TFhirConformanceSoftwareListEnumerator }

Constructor TFhirConformanceSoftwareListEnumerator.Create(list : TFhirConformanceSoftwareList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConformanceSoftwareListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConformanceSoftwareListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConformanceSoftwareListEnumerator.GetCurrent : TFhirConformanceSoftware;
begin
  Result := FList[FIndex];
end;

function TFhirConformanceSoftwareListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConformanceSoftwareList }
procedure TFhirConformanceSoftwareList.AddItem(value: TFhirConformanceSoftware);
begin
  assert(value.ClassName = 'TFhirConformanceSoftware', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceSoftware');
  add(value);
end;

function TFhirConformanceSoftwareList.Append: TFhirConformanceSoftware;
begin
  result := TFhirConformanceSoftware.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConformanceSoftwareList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceSoftwareList.GetEnumerator : TFhirConformanceSoftwareListEnumerator;
begin
  result := TFhirConformanceSoftwareListEnumerator.Create(self.link);
end;

function TFhirConformanceSoftwareList.Clone: TFhirConformanceSoftwareList;
begin
  result := TFhirConformanceSoftwareList(inherited Clone);
end;

function TFhirConformanceSoftwareList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceSoftwareList.GetItemN(index: Integer): TFhirConformanceSoftware;
begin
  result := TFhirConformanceSoftware(ObjectByIndex[index]);
end;

function TFhirConformanceSoftwareList.ItemClass: TFslObjectClass;
begin
  result := TFhirConformanceSoftware;
end;
function TFhirConformanceSoftwareList.IndexOf(value: TFhirConformanceSoftware): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConformanceSoftwareList.Insert(index: Integer): TFhirConformanceSoftware;
begin
  result := TFhirConformanceSoftware.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConformanceSoftwareList.InsertItem(index: Integer; value: TFhirConformanceSoftware);
begin
  assert(value is TFhirConformanceSoftware);
  Inherited Insert(index, value);
end;

function TFhirConformanceSoftwareList.Item(index: Integer): TFhirConformanceSoftware;
begin
  result := TFhirConformanceSoftware(ObjectByIndex[index]);
end;

function TFhirConformanceSoftwareList.Link: TFhirConformanceSoftwareList;
begin
  result := TFhirConformanceSoftwareList(inherited Link);
end;

procedure TFhirConformanceSoftwareList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceSoftwareList.SetItemByIndex(index: Integer; value: TFhirConformanceSoftware);
begin
  assert(value is TFhirConformanceSoftware);
  FhirConformanceSoftwares[index] := value;
end;

procedure TFhirConformanceSoftwareList.SetItemN(index: Integer; value: TFhirConformanceSoftware);
begin
  assert(value is TFhirConformanceSoftware);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceImplementation }

constructor TFhirConformanceImplementation.Create;
begin
  inherited;
end;

destructor TFhirConformanceImplementation.Destroy;
begin
  FDescription.free;
  FUrl.free;
  inherited;
end;

procedure TFhirConformanceImplementation.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirConformanceImplementation(oSource).descriptionElement.Clone;
  urlElement := TFhirConformanceImplementation(oSource).urlElement.Clone;
end;

procedure TFhirConformanceImplementation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
end;

procedure TFhirConformanceImplementation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));{2}
end;

function TFhirConformanceImplementation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'url') then
  begin
    UrlElement := asUri(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConformanceImplementation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirConformanceImplementation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'url') then result := TFhirUri.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConformanceImplementation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'url') then result := 'uri'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConformanceImplementation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'url') then UrlElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConformanceImplementation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'url') then UrlElement := asUri(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConformanceImplementation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirConformanceImplementation.fhirType : string;
begin
  result := 'implementation';
end;

function TFhirConformanceImplementation.Link : TFhirConformanceImplementation;
begin
  result := TFhirConformanceImplementation(inherited Link);
end;

function TFhirConformanceImplementation.Clone : TFhirConformanceImplementation;
begin
  result := TFhirConformanceImplementation(inherited Clone);
end;

function TFhirConformanceImplementation.equals(other : TObject) : boolean; 
var
  o : TFhirConformanceImplementation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConformanceImplementation)) then
    result := false
  else
  begin
    o := TFhirConformanceImplementation(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(urlElement, o.urlElement, true);
  end;
end;

function TFhirConformanceImplementation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FUrl);
end;

procedure TFhirConformanceImplementation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('description');
  fields.add('url');
end;

{ TFhirConformanceImplementation }

Procedure TFhirConformanceImplementation.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirConformanceImplementation.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirConformanceImplementation.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirConformanceImplementation.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirConformanceImplementation.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

Procedure TFhirConformanceImplementation.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

function TFhirConformanceImplementation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDescription.sizeInBytes);
  inc(result, FUrl.sizeInBytes);
end;

{ TFhirConformanceImplementationListEnumerator }

Constructor TFhirConformanceImplementationListEnumerator.Create(list : TFhirConformanceImplementationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConformanceImplementationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConformanceImplementationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConformanceImplementationListEnumerator.GetCurrent : TFhirConformanceImplementation;
begin
  Result := FList[FIndex];
end;

function TFhirConformanceImplementationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConformanceImplementationList }
procedure TFhirConformanceImplementationList.AddItem(value: TFhirConformanceImplementation);
begin
  assert(value.ClassName = 'TFhirConformanceImplementation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceImplementation');
  add(value);
end;

function TFhirConformanceImplementationList.Append: TFhirConformanceImplementation;
begin
  result := TFhirConformanceImplementation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConformanceImplementationList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceImplementationList.GetEnumerator : TFhirConformanceImplementationListEnumerator;
begin
  result := TFhirConformanceImplementationListEnumerator.Create(self.link);
end;

function TFhirConformanceImplementationList.Clone: TFhirConformanceImplementationList;
begin
  result := TFhirConformanceImplementationList(inherited Clone);
end;

function TFhirConformanceImplementationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceImplementationList.GetItemN(index: Integer): TFhirConformanceImplementation;
begin
  result := TFhirConformanceImplementation(ObjectByIndex[index]);
end;

function TFhirConformanceImplementationList.ItemClass: TFslObjectClass;
begin
  result := TFhirConformanceImplementation;
end;
function TFhirConformanceImplementationList.IndexOf(value: TFhirConformanceImplementation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConformanceImplementationList.Insert(index: Integer): TFhirConformanceImplementation;
begin
  result := TFhirConformanceImplementation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConformanceImplementationList.InsertItem(index: Integer; value: TFhirConformanceImplementation);
begin
  assert(value is TFhirConformanceImplementation);
  Inherited Insert(index, value);
end;

function TFhirConformanceImplementationList.Item(index: Integer): TFhirConformanceImplementation;
begin
  result := TFhirConformanceImplementation(ObjectByIndex[index]);
end;

function TFhirConformanceImplementationList.Link: TFhirConformanceImplementationList;
begin
  result := TFhirConformanceImplementationList(inherited Link);
end;

procedure TFhirConformanceImplementationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceImplementationList.SetItemByIndex(index: Integer; value: TFhirConformanceImplementation);
begin
  assert(value is TFhirConformanceImplementation);
  FhirConformanceImplementations[index] := value;
end;

procedure TFhirConformanceImplementationList.SetItemN(index: Integer; value: TFhirConformanceImplementation);
begin
  assert(value is TFhirConformanceImplementation);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceRest }

constructor TFhirConformanceRest.Create;
begin
  inherited;
end;

destructor TFhirConformanceRest.Destroy;
begin
  FMode.free;
  FDocumentation.free;
  FSecurity.free;
  FResourceList.Free;
  FInteractionList.Free;
  FTransactionMode.free;
  FSearchParamList.Free;
  FOperationList.Free;
  FCompartmentList.Free;
  inherited;
end;

procedure TFhirConformanceRest.Assign(oSource : TFslObject);
begin
  inherited;
  FMode := TFhirConformanceRest(oSource).FMode.Link;
  documentationElement := TFhirConformanceRest(oSource).documentationElement.Clone;
  security := TFhirConformanceRest(oSource).security.Clone;
  if (TFhirConformanceRest(oSource).FResourceList = nil) then
  begin
    FResourceList.free;
    FResourceList := nil;
  end
  else
  begin
    if FResourceList = nil then
      FResourceList := TFhirConformanceRestResourceList.Create;
    FResourceList.Assign(TFhirConformanceRest(oSource).FResourceList);
  end;
  if (TFhirConformanceRest(oSource).FInteractionList = nil) then
  begin
    FInteractionList.free;
    FInteractionList := nil;
  end
  else
  begin
    if FInteractionList = nil then
      FInteractionList := TFhirConformanceRestInteractionList.Create;
    FInteractionList.Assign(TFhirConformanceRest(oSource).FInteractionList);
  end;
  FTransactionMode := TFhirConformanceRest(oSource).FTransactionMode.Link;
  if (TFhirConformanceRest(oSource).FSearchParamList = nil) then
  begin
    FSearchParamList.free;
    FSearchParamList := nil;
  end
  else
  begin
    if FSearchParamList = nil then
      FSearchParamList := TFhirConformanceRestResourceSearchParamList.Create;
    FSearchParamList.Assign(TFhirConformanceRest(oSource).FSearchParamList);
  end;
  if (TFhirConformanceRest(oSource).FOperationList = nil) then
  begin
    FOperationList.free;
    FOperationList := nil;
  end
  else
  begin
    if FOperationList = nil then
      FOperationList := TFhirConformanceRestOperationList.Create;
    FOperationList.Assign(TFhirConformanceRest(oSource).FOperationList);
  end;
  if (TFhirConformanceRest(oSource).FCompartmentList = nil) then
  begin
    FCompartmentList.free;
    FCompartmentList := nil;
  end
  else
  begin
    if FCompartmentList = nil then
      FCompartmentList := TFhirUriList.Create;
    FCompartmentList.Assign(TFhirConformanceRest(oSource).FCompartmentList);
  end;
end;

procedure TFhirConformanceRest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'mode') Then
     list.add(self.link, 'mode', FMode.Link);
  if (child_name = 'documentation') Then
     list.add(self.link, 'documentation', FDocumentation.Link);
  if (child_name = 'security') Then
     list.add(self.link, 'security', FSecurity.Link);
  if (child_name = 'resource') Then
    list.addAll(self, 'resource', FResourceList);
  if (child_name = 'interaction') Then
    list.addAll(self, 'interaction', FInteractionList);
  if (child_name = 'transactionMode') Then
     list.add(self.link, 'transactionMode', FTransactionMode.Link);
  if (child_name = 'searchParam') Then
    list.addAll(self, 'searchParam', FSearchParamList);
  if (child_name = 'operation') Then
    list.addAll(self, 'operation', FOperationList);
  if (child_name = 'compartment') Then
    list.addAll(self, 'compartment', FCompartmentList);
end;

procedure TFhirConformanceRest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'mode', 'code', false, TFHIREnum, FMode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', false, TFhirString, FDocumentation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'security', '', false, TFhirConformanceRestSecurity, FSecurity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'resource', '', true, TFhirConformanceRestResource, FResourceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'interaction', '', true, TFhirConformanceRestInteraction, FInteractionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'transactionMode', 'code', false, TFHIREnum, FTransactionMode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'searchParam', '@Conformance.rest.resource.searchParam', true, TFhirConformanceRestResourceSearchParam, FSearchParamList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'operation', '', true, TFhirConformanceRestOperation, FOperationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'compartment', 'uri', true, TFhirUri, FCompartmentList.Link)){3};
end;

function TFhirConformanceRest.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'mode') then
  begin
    ModeElement := asEnum(SYSTEMS_TFhirRestfulConformanceModeEnum, CODES_TFhirRestfulConformanceModeEnum, propValue);
    result := propValue
  end
  else if (propName = 'documentation') then
  begin
    DocumentationElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'security') then
  begin
    Security := propValue as TFhirConformanceRestSecurity{4b};
    result := propValue;
  end
  else if (propName = 'resource') then
  begin
    ResourceList.add(propValue as TFhirConformanceRestResource){2a};
    result := propValue;
  end
  else if (propName = 'interaction') then
  begin
    InteractionList.add(propValue as TFhirConformanceRestInteraction){2a};
    result := propValue;
  end
  else if (propName = 'transactionMode') then
  begin
    TransactionModeElement := asEnum(SYSTEMS_TFhirTransactionModeEnum, CODES_TFhirTransactionModeEnum, propValue);
    result := propValue
  end
  else if (propName = 'searchParam') then
  begin
    SearchParamList.add(propValue as TFhirConformanceRestResourceSearchParam){2a};
    result := propValue;
  end
  else if (propName = 'operation') then
  begin
    OperationList.add(propValue as TFhirConformanceRestOperation){2a};
    result := propValue;
  end
  else if (propName = 'compartment') then
  begin
    CompartmentList.add(asUri(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConformanceRest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'resource') then ResourceList.insertItem(index, propValue as TFhirConformanceRestResource){2a}
  else if (propName = 'interaction') then InteractionList.insertItem(index, propValue as TFhirConformanceRestInteraction){2a}
  else if (propName = 'searchParam') then SearchParamList.insertItem(index, propValue as TFhirConformanceRestResourceSearchParam){2a}
  else if (propName = 'operation') then OperationList.insertItem(index, propValue as TFhirConformanceRestOperation){2a}
  else if (propName = 'compartment') then CompartmentList.insertItem(index, asUri(propValue)){2}
  else inherited;
end;

function TFhirConformanceRest.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'documentation') then result := TFhirString.create() {5b}
  else if (propName = 'security') then result := TFhirConformanceRestSecurity.create(){4b}
  else if (propName = 'resource') then result := ResourceList.new(){2}
  else if (propName = 'interaction') then result := InteractionList.new(){2}
  else if (propName = 'searchParam') then result := SearchParamList.new(){2}
  else if (propName = 'operation') then result := OperationList.new(){2}
  else if (propName = 'compartment') then result := CompartmentList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConformanceRest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'mode') then result := 'code'
  else if (propName = 'documentation') then result := 'string'
  else if (propName = 'security') then result := ''
  else if (propName = 'resource') then result := ''
  else if (propName = 'interaction') then result := ''
  else if (propName = 'transactionMode') then result := 'code'
  else if (propName = 'searchParam') then result := '@Conformance.rest.resource.searchParam'
  else if (propName = 'operation') then result := ''
  else if (propName = 'compartment') then result := 'uri'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConformanceRest.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'mode') then ModeElement := nil
  else if (propName = 'documentation') then DocumentationElement := nil
  else if (propName = 'security') then SecurityElement := nil
  else if (propName = 'resource') then deletePropertyValue('resource', ResourceList, value) {2}
  else if (propName = 'interaction') then deletePropertyValue('interaction', InteractionList, value) {2}
  else if (propName = 'transactionMode') then TransactionModeElement := nil
  else if (propName = 'searchParam') then deletePropertyValue('searchParam', SearchParamList, value) {2}
  else if (propName = 'operation') then deletePropertyValue('operation', OperationList, value) {2}
  else if (propName = 'compartment') then deletePropertyValue('compartment', CompartmentList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConformanceRest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'mode') then ModeElement := asEnum(SYSTEMS_TFhirRestfulConformanceModeEnum, CODES_TFhirRestfulConformanceModeEnum, new){4}
  else if (propName = 'documentation') then DocumentationElement := asString(new){5b}
  else if (propName = 'security') then SecurityElement := new as TFhirConformanceRestSecurity{4}
  else if (propName = 'resource') then replacePropertyValue('resource', ResourceList, existing, new) {2}
  else if (propName = 'interaction') then replacePropertyValue('interaction', InteractionList, existing, new) {2}
  else if (propName = 'transactionMode') then TransactionModeElement := asEnum(SYSTEMS_TFhirTransactionModeEnum, CODES_TFhirTransactionModeEnum, new){4}
  else if (propName = 'searchParam') then replacePropertyValue('searchParam', SearchParamList, existing, new) {2}
  else if (propName = 'operation') then replacePropertyValue('operation', OperationList, existing, new) {2}
  else if (propName = 'compartment') then replacePropertyValue('compartment', CompartmentList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConformanceRest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'resource') then ResourceList.move(source, destination){2a}
  else if (propName = 'interaction') then InteractionList.move(source, destination){2a}
  else if (propName = 'searchParam') then SearchParamList.move(source, destination){2a}
  else if (propName = 'operation') then OperationList.move(source, destination){2a}
  else if (propName = 'compartment') then CompartmentList.move(source, destination){2}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirConformanceRest.fhirType : string;
begin
  result := 'rest';
end;

function TFhirConformanceRest.Link : TFhirConformanceRest;
begin
  result := TFhirConformanceRest(inherited Link);
end;

function TFhirConformanceRest.Clone : TFhirConformanceRest;
begin
  result := TFhirConformanceRest(inherited Clone);
end;

function TFhirConformanceRest.equals(other : TObject) : boolean; 
var
  o : TFhirConformanceRest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConformanceRest)) then
    result := false
  else
  begin
    o := TFhirConformanceRest(other);
    result := compareDeep(modeElement, o.modeElement, true) and compareDeep(documentationElement, o.documentationElement, true) and 
      compareDeep(securityElement, o.securityElement, true) and compareDeep(resourceList, o.resourceList, true) and 
      compareDeep(interactionList, o.interactionList, true) and compareDeep(transactionModeElement, o.transactionModeElement, true) and 
      compareDeep(searchParamList, o.searchParamList, true) and compareDeep(operationList, o.operationList, true) and 
      compareDeep(compartmentList, o.compartmentList, true);
  end;
end;

function TFhirConformanceRest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMode) and isEmptyProp(FDocumentation) and isEmptyProp(FSecurity) and isEmptyProp(FresourceList) and isEmptyProp(FinteractionList) and isEmptyProp(FTransactionMode) and isEmptyProp(FsearchParamList) and isEmptyProp(FoperationList) and isEmptyProp(FcompartmentList);
end;

procedure TFhirConformanceRest.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('mode');
  fields.add('documentation');
  fields.add('security');
  fields.add('resource');
  fields.add('interaction');
  fields.add('transactionMode');
  fields.add('searchParam');
  fields.add('operation');
  fields.add('compartment');
end;

{ TFhirConformanceRest }

Procedure TFhirConformanceRest.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

Function TFhirConformanceRest.GetModeST : TFhirRestfulConformanceModeEnum;
begin
  if FMode = nil then
    result := TFhirRestfulConformanceModeEnum(0)
  else
    result := TFhirRestfulConformanceModeEnum(StringArrayIndexOfSensitive(CODES_TFhirRestfulConformanceModeEnum, FMode.value));
end;

Procedure TFhirConformanceRest.SetModeST(value : TFhirRestfulConformanceModeEnum);
begin
  if ord(value) = 0 then
    ModeElement := nil
  else
    ModeElement := TFhirEnum.create(SYSTEMS_TFhirRestfulConformanceModeEnum[value], CODES_TFhirRestfulConformanceModeEnum[value]);
end;

Procedure TFhirConformanceRest.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirConformanceRest.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

Procedure TFhirConformanceRest.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

Procedure TFhirConformanceRest.SetSecurity(value : TFhirConformanceRestSecurity);
begin
  FSecurity.free;
  FSecurity := value;
end;

Function TFhirConformanceRest.GetResourceList : TFhirConformanceRestResourceList;
begin
  if FResourceList = nil then
    FResourceList := TFhirConformanceRestResourceList.Create;
  result := FResourceList;
end;

Function TFhirConformanceRest.GetHasResourceList : boolean;
begin
  result := (FResourceList <> nil) and (FResourceList.count > 0);
end;

Function TFhirConformanceRest.GetInteractionList : TFhirConformanceRestInteractionList;
begin
  if FInteractionList = nil then
    FInteractionList := TFhirConformanceRestInteractionList.Create;
  result := FInteractionList;
end;

Function TFhirConformanceRest.GetHasInteractionList : boolean;
begin
  result := (FInteractionList <> nil) and (FInteractionList.count > 0);
end;

Procedure TFhirConformanceRest.SetTransactionMode(value : TFhirEnum);
begin
  FTransactionMode.free;
  FTransactionMode := value;
end;

Function TFhirConformanceRest.GetTransactionModeST : TFhirTransactionModeEnum;
begin
  if FTransactionMode = nil then
    result := TFhirTransactionModeEnum(0)
  else
    result := TFhirTransactionModeEnum(StringArrayIndexOfSensitive(CODES_TFhirTransactionModeEnum, FTransactionMode.value));
end;

Procedure TFhirConformanceRest.SetTransactionModeST(value : TFhirTransactionModeEnum);
begin
  if ord(value) = 0 then
    TransactionModeElement := nil
  else
    TransactionModeElement := TFhirEnum.create(SYSTEMS_TFhirTransactionModeEnum[value], CODES_TFhirTransactionModeEnum[value]);
end;

Function TFhirConformanceRest.GetSearchParamList : TFhirConformanceRestResourceSearchParamList;
begin
  if FSearchParamList = nil then
    FSearchParamList := TFhirConformanceRestResourceSearchParamList.Create;
  result := FSearchParamList;
end;

Function TFhirConformanceRest.GetHasSearchParamList : boolean;
begin
  result := (FSearchParamList <> nil) and (FSearchParamList.count > 0);
end;

Function TFhirConformanceRest.GetOperationList : TFhirConformanceRestOperationList;
begin
  if FOperationList = nil then
    FOperationList := TFhirConformanceRestOperationList.Create;
  result := FOperationList;
end;

Function TFhirConformanceRest.GetHasOperationList : boolean;
begin
  result := (FOperationList <> nil) and (FOperationList.count > 0);
end;

Function TFhirConformanceRest.GetCompartmentList : TFhirUriList;
begin
  if FCompartmentList = nil then
    FCompartmentList := TFhirUriList.Create;
  result := FCompartmentList;
end;

Function TFhirConformanceRest.GetHasCompartmentList : boolean;
begin
  result := (FCompartmentList <> nil) and (FCompartmentList.count > 0);
end;

function TFhirConformanceRest.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FMode.sizeInBytes);
  inc(result, FDocumentation.sizeInBytes);
  inc(result, FSecurity.sizeInBytes);
  inc(result, FresourceList.sizeInBytes);
  inc(result, FinteractionList.sizeInBytes);
  inc(result, FTransactionMode.sizeInBytes);
  inc(result, FsearchParamList.sizeInBytes);
  inc(result, FoperationList.sizeInBytes);
  inc(result, FcompartmentList.sizeInBytes);
end;

{ TFhirConformanceRestListEnumerator }

Constructor TFhirConformanceRestListEnumerator.Create(list : TFhirConformanceRestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConformanceRestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConformanceRestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConformanceRestListEnumerator.GetCurrent : TFhirConformanceRest;
begin
  Result := FList[FIndex];
end;

function TFhirConformanceRestListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConformanceRestList }
procedure TFhirConformanceRestList.AddItem(value: TFhirConformanceRest);
begin
  assert(value.ClassName = 'TFhirConformanceRest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceRest');
  add(value);
end;

function TFhirConformanceRestList.Append: TFhirConformanceRest;
begin
  result := TFhirConformanceRest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConformanceRestList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceRestList.GetEnumerator : TFhirConformanceRestListEnumerator;
begin
  result := TFhirConformanceRestListEnumerator.Create(self.link);
end;

function TFhirConformanceRestList.Clone: TFhirConformanceRestList;
begin
  result := TFhirConformanceRestList(inherited Clone);
end;

function TFhirConformanceRestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceRestList.GetItemN(index: Integer): TFhirConformanceRest;
begin
  result := TFhirConformanceRest(ObjectByIndex[index]);
end;

function TFhirConformanceRestList.ItemClass: TFslObjectClass;
begin
  result := TFhirConformanceRest;
end;
function TFhirConformanceRestList.IndexOf(value: TFhirConformanceRest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConformanceRestList.Insert(index: Integer): TFhirConformanceRest;
begin
  result := TFhirConformanceRest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConformanceRestList.InsertItem(index: Integer; value: TFhirConformanceRest);
begin
  assert(value is TFhirConformanceRest);
  Inherited Insert(index, value);
end;

function TFhirConformanceRestList.Item(index: Integer): TFhirConformanceRest;
begin
  result := TFhirConformanceRest(ObjectByIndex[index]);
end;

function TFhirConformanceRestList.Link: TFhirConformanceRestList;
begin
  result := TFhirConformanceRestList(inherited Link);
end;

procedure TFhirConformanceRestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceRestList.SetItemByIndex(index: Integer; value: TFhirConformanceRest);
begin
  assert(value is TFhirConformanceRest);
  FhirConformanceRests[index] := value;
end;

procedure TFhirConformanceRestList.SetItemN(index: Integer; value: TFhirConformanceRest);
begin
  assert(value is TFhirConformanceRest);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceRestSecurity }

constructor TFhirConformanceRestSecurity.Create;
begin
  inherited;
end;

destructor TFhirConformanceRestSecurity.Destroy;
begin
  FCors.free;
  FServiceList.Free;
  FDescription.free;
  FCertificateList.Free;
  inherited;
end;

procedure TFhirConformanceRestSecurity.Assign(oSource : TFslObject);
begin
  inherited;
  corsElement := TFhirConformanceRestSecurity(oSource).corsElement.Clone;
  if (TFhirConformanceRestSecurity(oSource).FServiceList = nil) then
  begin
    FServiceList.free;
    FServiceList := nil;
  end
  else
  begin
    if FServiceList = nil then
      FServiceList := TFhirCodeableConceptList.Create;
    FServiceList.Assign(TFhirConformanceRestSecurity(oSource).FServiceList);
  end;
  descriptionElement := TFhirConformanceRestSecurity(oSource).descriptionElement.Clone;
  if (TFhirConformanceRestSecurity(oSource).FCertificateList = nil) then
  begin
    FCertificateList.free;
    FCertificateList := nil;
  end
  else
  begin
    if FCertificateList = nil then
      FCertificateList := TFhirConformanceRestSecurityCertificateList.Create;
    FCertificateList.Assign(TFhirConformanceRestSecurity(oSource).FCertificateList);
  end;
end;

procedure TFhirConformanceRestSecurity.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'cors') Then
     list.add(self.link, 'cors', FCors.Link);
  if (child_name = 'service') Then
    list.addAll(self, 'service', FServiceList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'certificate') Then
    list.addAll(self, 'certificate', FCertificateList);
end;

procedure TFhirConformanceRestSecurity.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'cors', 'boolean', false, TFhirBoolean, FCors.Link));{2}
  oList.add(TFHIRProperty.create(self, 'service', 'CodeableConcept', true, TFhirCodeableConcept, FServiceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'certificate', '', true, TFhirConformanceRestSecurityCertificate, FCertificateList.Link)){3};
end;

function TFhirConformanceRestSecurity.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'cors') then
  begin
    CorsElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'service') then
  begin
    ServiceList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'certificate') then
  begin
    CertificateList.add(propValue as TFhirConformanceRestSecurityCertificate){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConformanceRestSecurity.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'service') then ServiceList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'certificate') then CertificateList.insertItem(index, propValue as TFhirConformanceRestSecurityCertificate){2a}
  else inherited;
end;

function TFhirConformanceRestSecurity.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'cors') then result := TFhirBoolean.create() {5b}
  else if (propName = 'service') then result := ServiceList.new(){2}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'certificate') then result := CertificateList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConformanceRestSecurity.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'cors') then result := 'boolean'
  else if (propName = 'service') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'certificate') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConformanceRestSecurity.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'cors') then CorsElement := nil
  else if (propName = 'service') then deletePropertyValue('service', ServiceList, value) {2}
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'certificate') then deletePropertyValue('certificate', CertificateList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConformanceRestSecurity.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'cors') then CorsElement := asBoolean(new){5b}
  else if (propName = 'service') then replacePropertyValue('service', ServiceList, existing, new) {2}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'certificate') then replacePropertyValue('certificate', CertificateList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConformanceRestSecurity.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'service') then ServiceList.move(source, destination){2a}
  else if (propName = 'certificate') then CertificateList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirConformanceRestSecurity.fhirType : string;
begin
  result := 'security';
end;

function TFhirConformanceRestSecurity.Link : TFhirConformanceRestSecurity;
begin
  result := TFhirConformanceRestSecurity(inherited Link);
end;

function TFhirConformanceRestSecurity.Clone : TFhirConformanceRestSecurity;
begin
  result := TFhirConformanceRestSecurity(inherited Clone);
end;

function TFhirConformanceRestSecurity.equals(other : TObject) : boolean; 
var
  o : TFhirConformanceRestSecurity;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConformanceRestSecurity)) then
    result := false
  else
  begin
    o := TFhirConformanceRestSecurity(other);
    result := compareDeep(corsElement, o.corsElement, true) and compareDeep(serviceList, o.serviceList, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(certificateList, o.certificateList, true);
  end;
end;

function TFhirConformanceRestSecurity.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCors) and isEmptyProp(FserviceList) and isEmptyProp(FDescription) and isEmptyProp(FcertificateList);
end;

procedure TFhirConformanceRestSecurity.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('cors');
  fields.add('service');
  fields.add('description');
  fields.add('certificate');
end;

{ TFhirConformanceRestSecurity }

Procedure TFhirConformanceRestSecurity.SetCors(value : TFhirBoolean);
begin
  FCors.free;
  FCors := value;
end;

Function TFhirConformanceRestSecurity.GetCorsST : Boolean;
begin
  if FCors = nil then
    result := false
  else
    result := FCors.value;
end;

Procedure TFhirConformanceRestSecurity.SetCorsST(value : Boolean);
begin
  if FCors = nil then
    FCors := TFhirBoolean.create;
  FCors.value := value
end;

Function TFhirConformanceRestSecurity.GetServiceList : TFhirCodeableConceptList;
begin
  if FServiceList = nil then
    FServiceList := TFhirCodeableConceptList.Create;
  result := FServiceList;
end;

Function TFhirConformanceRestSecurity.GetHasServiceList : boolean;
begin
  result := (FServiceList <> nil) and (FServiceList.count > 0);
end;

Procedure TFhirConformanceRestSecurity.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirConformanceRestSecurity.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirConformanceRestSecurity.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Function TFhirConformanceRestSecurity.GetCertificateList : TFhirConformanceRestSecurityCertificateList;
begin
  if FCertificateList = nil then
    FCertificateList := TFhirConformanceRestSecurityCertificateList.Create;
  result := FCertificateList;
end;

Function TFhirConformanceRestSecurity.GetHasCertificateList : boolean;
begin
  result := (FCertificateList <> nil) and (FCertificateList.count > 0);
end;

function TFhirConformanceRestSecurity.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCors.sizeInBytes);
  inc(result, FserviceList.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FcertificateList.sizeInBytes);
end;

{ TFhirConformanceRestSecurityListEnumerator }

Constructor TFhirConformanceRestSecurityListEnumerator.Create(list : TFhirConformanceRestSecurityList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConformanceRestSecurityListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConformanceRestSecurityListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConformanceRestSecurityListEnumerator.GetCurrent : TFhirConformanceRestSecurity;
begin
  Result := FList[FIndex];
end;

function TFhirConformanceRestSecurityListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConformanceRestSecurityList }
procedure TFhirConformanceRestSecurityList.AddItem(value: TFhirConformanceRestSecurity);
begin
  assert(value.ClassName = 'TFhirConformanceRestSecurity', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceRestSecurity');
  add(value);
end;

function TFhirConformanceRestSecurityList.Append: TFhirConformanceRestSecurity;
begin
  result := TFhirConformanceRestSecurity.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConformanceRestSecurityList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceRestSecurityList.GetEnumerator : TFhirConformanceRestSecurityListEnumerator;
begin
  result := TFhirConformanceRestSecurityListEnumerator.Create(self.link);
end;

function TFhirConformanceRestSecurityList.Clone: TFhirConformanceRestSecurityList;
begin
  result := TFhirConformanceRestSecurityList(inherited Clone);
end;

function TFhirConformanceRestSecurityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceRestSecurityList.GetItemN(index: Integer): TFhirConformanceRestSecurity;
begin
  result := TFhirConformanceRestSecurity(ObjectByIndex[index]);
end;

function TFhirConformanceRestSecurityList.ItemClass: TFslObjectClass;
begin
  result := TFhirConformanceRestSecurity;
end;
function TFhirConformanceRestSecurityList.IndexOf(value: TFhirConformanceRestSecurity): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConformanceRestSecurityList.Insert(index: Integer): TFhirConformanceRestSecurity;
begin
  result := TFhirConformanceRestSecurity.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConformanceRestSecurityList.InsertItem(index: Integer; value: TFhirConformanceRestSecurity);
begin
  assert(value is TFhirConformanceRestSecurity);
  Inherited Insert(index, value);
end;

function TFhirConformanceRestSecurityList.Item(index: Integer): TFhirConformanceRestSecurity;
begin
  result := TFhirConformanceRestSecurity(ObjectByIndex[index]);
end;

function TFhirConformanceRestSecurityList.Link: TFhirConformanceRestSecurityList;
begin
  result := TFhirConformanceRestSecurityList(inherited Link);
end;

procedure TFhirConformanceRestSecurityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceRestSecurityList.SetItemByIndex(index: Integer; value: TFhirConformanceRestSecurity);
begin
  assert(value is TFhirConformanceRestSecurity);
  FhirConformanceRestSecurities[index] := value;
end;

procedure TFhirConformanceRestSecurityList.SetItemN(index: Integer; value: TFhirConformanceRestSecurity);
begin
  assert(value is TFhirConformanceRestSecurity);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceRestSecurityCertificate }

constructor TFhirConformanceRestSecurityCertificate.Create;
begin
  inherited;
end;

destructor TFhirConformanceRestSecurityCertificate.Destroy;
begin
  FType_.free;
  FBlob.free;
  inherited;
end;

procedure TFhirConformanceRestSecurityCertificate.Assign(oSource : TFslObject);
begin
  inherited;
  type_Element := TFhirConformanceRestSecurityCertificate(oSource).type_Element.Clone;
  blobElement := TFhirConformanceRestSecurityCertificate(oSource).blobElement.Clone;
end;

procedure TFhirConformanceRestSecurityCertificate.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'blob') Then
     list.add(self.link, 'blob', FBlob.Link);
end;

procedure TFhirConformanceRestSecurityCertificate.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirCode, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'blob', 'base64Binary', false, TFhirBase64Binary, FBlob.Link));{2}
end;

function TFhirConformanceRestSecurityCertificate.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'blob') then
  begin
    BlobElement := asBase64Binary(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConformanceRestSecurityCertificate.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirConformanceRestSecurityCertificate.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCode.create() {5b}
  else if (propName = 'blob') then result := TFhirBase64Binary.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConformanceRestSecurityCertificate.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'blob') then result := 'base64Binary'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConformanceRestSecurityCertificate.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'blob') then BlobElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConformanceRestSecurityCertificate.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asCode(new){5b}
  else if (propName = 'blob') then BlobElement := asBase64Binary(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConformanceRestSecurityCertificate.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirConformanceRestSecurityCertificate.fhirType : string;
begin
  result := 'certificate';
end;

function TFhirConformanceRestSecurityCertificate.Link : TFhirConformanceRestSecurityCertificate;
begin
  result := TFhirConformanceRestSecurityCertificate(inherited Link);
end;

function TFhirConformanceRestSecurityCertificate.Clone : TFhirConformanceRestSecurityCertificate;
begin
  result := TFhirConformanceRestSecurityCertificate(inherited Clone);
end;

function TFhirConformanceRestSecurityCertificate.equals(other : TObject) : boolean; 
var
  o : TFhirConformanceRestSecurityCertificate;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConformanceRestSecurityCertificate)) then
    result := false
  else
  begin
    o := TFhirConformanceRestSecurityCertificate(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(blobElement, o.blobElement, true);
  end;
end;

function TFhirConformanceRestSecurityCertificate.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FBlob);
end;

procedure TFhirConformanceRestSecurityCertificate.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('blob');
end;

{ TFhirConformanceRestSecurityCertificate }

Procedure TFhirConformanceRestSecurityCertificate.SetType_(value : TFhirCode);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirConformanceRestSecurityCertificate.GetType_ST : String;
begin
  if FType_ = nil then
    result := ''
  else
    result := FType_.value;
end;

Procedure TFhirConformanceRestSecurityCertificate.SetType_ST(value : String);
begin
  if value <> '' then
  begin
    if FType_ = nil then
      FType_ := TFhirCode.create;
    FType_.value := value
  end
  else if FType_ <> nil then
    FType_.value := '';
end;

Procedure TFhirConformanceRestSecurityCertificate.SetBlob(value : TFhirBase64Binary);
begin
  FBlob.free;
  FBlob := value;
end;

Function TFhirConformanceRestSecurityCertificate.GetBlobST : TBytes;
begin
  if FBlob = nil then
    result := nil
  else
    result := FBlob.value;
end;

Procedure TFhirConformanceRestSecurityCertificate.SetBlobST(value : TBytes);
begin
  if value <> nil then
  begin
    if FBlob = nil then
      FBlob := TFhirBase64Binary.create;
    FBlob.value := value
  end
  else if FBlob <> nil then
    FBlob.value := nil;
end;

function TFhirConformanceRestSecurityCertificate.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FBlob.sizeInBytes);
end;

{ TFhirConformanceRestSecurityCertificateListEnumerator }

Constructor TFhirConformanceRestSecurityCertificateListEnumerator.Create(list : TFhirConformanceRestSecurityCertificateList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConformanceRestSecurityCertificateListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConformanceRestSecurityCertificateListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConformanceRestSecurityCertificateListEnumerator.GetCurrent : TFhirConformanceRestSecurityCertificate;
begin
  Result := FList[FIndex];
end;

function TFhirConformanceRestSecurityCertificateListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConformanceRestSecurityCertificateList }
procedure TFhirConformanceRestSecurityCertificateList.AddItem(value: TFhirConformanceRestSecurityCertificate);
begin
  assert(value.ClassName = 'TFhirConformanceRestSecurityCertificate', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceRestSecurityCertificate');
  add(value);
end;

function TFhirConformanceRestSecurityCertificateList.Append: TFhirConformanceRestSecurityCertificate;
begin
  result := TFhirConformanceRestSecurityCertificate.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConformanceRestSecurityCertificateList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceRestSecurityCertificateList.GetEnumerator : TFhirConformanceRestSecurityCertificateListEnumerator;
begin
  result := TFhirConformanceRestSecurityCertificateListEnumerator.Create(self.link);
end;

function TFhirConformanceRestSecurityCertificateList.Clone: TFhirConformanceRestSecurityCertificateList;
begin
  result := TFhirConformanceRestSecurityCertificateList(inherited Clone);
end;

function TFhirConformanceRestSecurityCertificateList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceRestSecurityCertificateList.GetItemN(index: Integer): TFhirConformanceRestSecurityCertificate;
begin
  result := TFhirConformanceRestSecurityCertificate(ObjectByIndex[index]);
end;

function TFhirConformanceRestSecurityCertificateList.ItemClass: TFslObjectClass;
begin
  result := TFhirConformanceRestSecurityCertificate;
end;
function TFhirConformanceRestSecurityCertificateList.IndexOf(value: TFhirConformanceRestSecurityCertificate): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConformanceRestSecurityCertificateList.Insert(index: Integer): TFhirConformanceRestSecurityCertificate;
begin
  result := TFhirConformanceRestSecurityCertificate.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConformanceRestSecurityCertificateList.InsertItem(index: Integer; value: TFhirConformanceRestSecurityCertificate);
begin
  assert(value is TFhirConformanceRestSecurityCertificate);
  Inherited Insert(index, value);
end;

function TFhirConformanceRestSecurityCertificateList.Item(index: Integer): TFhirConformanceRestSecurityCertificate;
begin
  result := TFhirConformanceRestSecurityCertificate(ObjectByIndex[index]);
end;

function TFhirConformanceRestSecurityCertificateList.Link: TFhirConformanceRestSecurityCertificateList;
begin
  result := TFhirConformanceRestSecurityCertificateList(inherited Link);
end;

procedure TFhirConformanceRestSecurityCertificateList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceRestSecurityCertificateList.SetItemByIndex(index: Integer; value: TFhirConformanceRestSecurityCertificate);
begin
  assert(value is TFhirConformanceRestSecurityCertificate);
  FhirConformanceRestSecurityCertificates[index] := value;
end;

procedure TFhirConformanceRestSecurityCertificateList.SetItemN(index: Integer; value: TFhirConformanceRestSecurityCertificate);
begin
  assert(value is TFhirConformanceRestSecurityCertificate);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceRestResource }

constructor TFhirConformanceRestResource.Create;
begin
  inherited;
end;

destructor TFhirConformanceRestResource.Destroy;
begin
  FType_.free;
  FProfile.free;
  FInteractionList.Free;
  FVersioning.free;
  FReadHistory.free;
  FUpdateCreate.free;
  FConditionalCreate.free;
  FConditionalUpdate.free;
  FConditionalDelete.free;
  FSearchIncludeList.Free;
  FSearchRevIncludeList.Free;
  FSearchParamList.Free;
  inherited;
end;

procedure TFhirConformanceRestResource.Assign(oSource : TFslObject);
begin
  inherited;
  FType_ := TFhirConformanceRestResource(oSource).FType_.Link;
  profile := TFhirConformanceRestResource(oSource).profile.Clone;
  if (TFhirConformanceRestResource(oSource).FInteractionList = nil) then
  begin
    FInteractionList.free;
    FInteractionList := nil;
  end
  else
  begin
    if FInteractionList = nil then
      FInteractionList := TFhirConformanceRestResourceInteractionList.Create;
    FInteractionList.Assign(TFhirConformanceRestResource(oSource).FInteractionList);
  end;
  FVersioning := TFhirConformanceRestResource(oSource).FVersioning.Link;
  readHistoryElement := TFhirConformanceRestResource(oSource).readHistoryElement.Clone;
  updateCreateElement := TFhirConformanceRestResource(oSource).updateCreateElement.Clone;
  conditionalCreateElement := TFhirConformanceRestResource(oSource).conditionalCreateElement.Clone;
  conditionalUpdateElement := TFhirConformanceRestResource(oSource).conditionalUpdateElement.Clone;
  FConditionalDelete := TFhirConformanceRestResource(oSource).FConditionalDelete.Link;
  if (TFhirConformanceRestResource(oSource).FSearchIncludeList = nil) then
  begin
    FSearchIncludeList.free;
    FSearchIncludeList := nil;
  end
  else
  begin
    if FSearchIncludeList = nil then
      FSearchIncludeList := TFhirStringList.Create;
    FSearchIncludeList.Assign(TFhirConformanceRestResource(oSource).FSearchIncludeList);
  end;
  if (TFhirConformanceRestResource(oSource).FSearchRevIncludeList = nil) then
  begin
    FSearchRevIncludeList.free;
    FSearchRevIncludeList := nil;
  end
  else
  begin
    if FSearchRevIncludeList = nil then
      FSearchRevIncludeList := TFhirStringList.Create;
    FSearchRevIncludeList.Assign(TFhirConformanceRestResource(oSource).FSearchRevIncludeList);
  end;
  if (TFhirConformanceRestResource(oSource).FSearchParamList = nil) then
  begin
    FSearchParamList.free;
    FSearchParamList := nil;
  end
  else
  begin
    if FSearchParamList = nil then
      FSearchParamList := TFhirConformanceRestResourceSearchParamList.Create;
    FSearchParamList.Assign(TFhirConformanceRestResource(oSource).FSearchParamList);
  end;
end;

procedure TFhirConformanceRestResource.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'profile') Then
     list.add(self.link, 'profile', FProfile.Link);
  if (child_name = 'interaction') Then
    list.addAll(self, 'interaction', FInteractionList);
  if (child_name = 'versioning') Then
     list.add(self.link, 'versioning', FVersioning.Link);
  if (child_name = 'readHistory') Then
     list.add(self.link, 'readHistory', FReadHistory.Link);
  if (child_name = 'updateCreate') Then
     list.add(self.link, 'updateCreate', FUpdateCreate.Link);
  if (child_name = 'conditionalCreate') Then
     list.add(self.link, 'conditionalCreate', FConditionalCreate.Link);
  if (child_name = 'conditionalUpdate') Then
     list.add(self.link, 'conditionalUpdate', FConditionalUpdate.Link);
  if (child_name = 'conditionalDelete') Then
     list.add(self.link, 'conditionalDelete', FConditionalDelete.Link);
  if (child_name = 'searchInclude') Then
    list.addAll(self, 'searchInclude', FSearchIncludeList);
  if (child_name = 'searchRevInclude') Then
    list.addAll(self, 'searchRevInclude', FSearchRevIncludeList);
  if (child_name = 'searchParam') Then
    list.addAll(self, 'searchParam', FSearchParamList);
end;

procedure TFhirConformanceRestResource.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'profile', 'Reference(StructureDefinition)', false, TFhirReference{TFhirStructureDefinition}, FProfile.Link));{2}
  oList.add(TFHIRProperty.create(self, 'interaction', '', true, TFhirConformanceRestResourceInteraction, FInteractionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'versioning', 'code', false, TFHIREnum, FVersioning.Link));{1}
  oList.add(TFHIRProperty.create(self, 'readHistory', 'boolean', false, TFhirBoolean, FReadHistory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'updateCreate', 'boolean', false, TFhirBoolean, FUpdateCreate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'conditionalCreate', 'boolean', false, TFhirBoolean, FConditionalCreate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'conditionalUpdate', 'boolean', false, TFhirBoolean, FConditionalUpdate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'conditionalDelete', 'code', false, TFHIREnum, FConditionalDelete.Link));{1}
  oList.add(TFHIRProperty.create(self, 'searchInclude', 'string', true, TFhirString, FSearchIncludeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'searchRevInclude', 'string', true, TFhirString, FSearchRevIncludeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'searchParam', '', true, TFhirConformanceRestResourceSearchParam, FSearchParamList.Link)){3};
end;

function TFhirConformanceRestResource.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue);
    result := propValue
  end
  else if (propName = 'profile') then
  begin
    Profile := propValue as TFhirReference{TFhirStructureDefinition}{4b};
    result := propValue;
  end
  else if (propName = 'interaction') then
  begin
    InteractionList.add(propValue as TFhirConformanceRestResourceInteraction){2a};
    result := propValue;
  end
  else if (propName = 'versioning') then
  begin
    VersioningElement := asEnum(SYSTEMS_TFhirVersioningPolicyEnum, CODES_TFhirVersioningPolicyEnum, propValue);
    result := propValue
  end
  else if (propName = 'readHistory') then
  begin
    ReadHistoryElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'updateCreate') then
  begin
    UpdateCreateElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'conditionalCreate') then
  begin
    ConditionalCreateElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'conditionalUpdate') then
  begin
    ConditionalUpdateElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'conditionalDelete') then
  begin
    ConditionalDeleteElement := asEnum(SYSTEMS_TFhirConditionalDeleteStatusEnum, CODES_TFhirConditionalDeleteStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'searchInclude') then
  begin
    SearchIncludeList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'searchRevInclude') then
  begin
    SearchRevIncludeList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'searchParam') then
  begin
    SearchParamList.add(propValue as TFhirConformanceRestResourceSearchParam){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConformanceRestResource.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'interaction') then InteractionList.insertItem(index, propValue as TFhirConformanceRestResourceInteraction){2a}
  else if (propName = 'searchInclude') then SearchIncludeList.insertItem(index, asString(propValue)){2}
  else if (propName = 'searchRevInclude') then SearchRevIncludeList.insertItem(index, asString(propValue)){2}
  else if (propName = 'searchParam') then SearchParamList.insertItem(index, propValue as TFhirConformanceRestResourceSearchParam){2a}
  else inherited;
end;

function TFhirConformanceRestResource.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'profile') then result := TFhirReference{TFhirStructureDefinition}.create(){4b}
  else if (propName = 'interaction') then result := InteractionList.new(){2}
  else if (propName = 'readHistory') then result := TFhirBoolean.create() {5b}
  else if (propName = 'updateCreate') then result := TFhirBoolean.create() {5b}
  else if (propName = 'conditionalCreate') then result := TFhirBoolean.create() {5b}
  else if (propName = 'conditionalUpdate') then result := TFhirBoolean.create() {5b}
  else if (propName = 'searchInclude') then result := SearchIncludeList.new(){2}
  else if (propName = 'searchRevInclude') then result := SearchRevIncludeList.new(){2}
  else if (propName = 'searchParam') then result := SearchParamList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConformanceRestResource.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'profile') then result := 'Reference'
  else if (propName = 'interaction') then result := ''
  else if (propName = 'versioning') then result := 'code'
  else if (propName = 'readHistory') then result := 'boolean'
  else if (propName = 'updateCreate') then result := 'boolean'
  else if (propName = 'conditionalCreate') then result := 'boolean'
  else if (propName = 'conditionalUpdate') then result := 'boolean'
  else if (propName = 'conditionalDelete') then result := 'code'
  else if (propName = 'searchInclude') then result := 'string'
  else if (propName = 'searchRevInclude') then result := 'string'
  else if (propName = 'searchParam') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConformanceRestResource.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'profile') then ProfileElement := nil
  else if (propName = 'interaction') then deletePropertyValue('interaction', InteractionList, value) {2}
  else if (propName = 'versioning') then VersioningElement := nil
  else if (propName = 'readHistory') then ReadHistoryElement := nil
  else if (propName = 'updateCreate') then UpdateCreateElement := nil
  else if (propName = 'conditionalCreate') then ConditionalCreateElement := nil
  else if (propName = 'conditionalUpdate') then ConditionalUpdateElement := nil
  else if (propName = 'conditionalDelete') then ConditionalDeleteElement := nil
  else if (propName = 'searchInclude') then deletePropertyValue('searchInclude', SearchIncludeList, value) {2}
  else if (propName = 'searchRevInclude') then deletePropertyValue('searchRevInclude', SearchRevIncludeList, value) {2}
  else if (propName = 'searchParam') then deletePropertyValue('searchParam', SearchParamList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConformanceRestResource.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, new){4}
  else if (propName = 'profile') then ProfileElement := new as TFhirReference{TFhirStructureDefinition}{4}
  else if (propName = 'interaction') then replacePropertyValue('interaction', InteractionList, existing, new) {2}
  else if (propName = 'versioning') then VersioningElement := asEnum(SYSTEMS_TFhirVersioningPolicyEnum, CODES_TFhirVersioningPolicyEnum, new){4}
  else if (propName = 'readHistory') then ReadHistoryElement := asBoolean(new){5b}
  else if (propName = 'updateCreate') then UpdateCreateElement := asBoolean(new){5b}
  else if (propName = 'conditionalCreate') then ConditionalCreateElement := asBoolean(new){5b}
  else if (propName = 'conditionalUpdate') then ConditionalUpdateElement := asBoolean(new){5b}
  else if (propName = 'conditionalDelete') then ConditionalDeleteElement := asEnum(SYSTEMS_TFhirConditionalDeleteStatusEnum, CODES_TFhirConditionalDeleteStatusEnum, new){4}
  else if (propName = 'searchInclude') then replacePropertyValue('searchInclude', SearchIncludeList, existing, new) {2}
  else if (propName = 'searchRevInclude') then replacePropertyValue('searchRevInclude', SearchRevIncludeList, existing, new) {2}
  else if (propName = 'searchParam') then replacePropertyValue('searchParam', SearchParamList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConformanceRestResource.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'interaction') then InteractionList.move(source, destination){2a}
  else if (propName = 'searchInclude') then SearchIncludeList.move(source, destination){2}
  else if (propName = 'searchRevInclude') then SearchRevIncludeList.move(source, destination){2}
  else if (propName = 'searchParam') then SearchParamList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirConformanceRestResource.fhirType : string;
begin
  result := 'resource';
end;

function TFhirConformanceRestResource.Link : TFhirConformanceRestResource;
begin
  result := TFhirConformanceRestResource(inherited Link);
end;

function TFhirConformanceRestResource.Clone : TFhirConformanceRestResource;
begin
  result := TFhirConformanceRestResource(inherited Clone);
end;

function TFhirConformanceRestResource.equals(other : TObject) : boolean; 
var
  o : TFhirConformanceRestResource;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConformanceRestResource)) then
    result := false
  else
  begin
    o := TFhirConformanceRestResource(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(profileElement, o.profileElement, true) and 
      compareDeep(interactionList, o.interactionList, true) and compareDeep(versioningElement, o.versioningElement, true) and 
      compareDeep(readHistoryElement, o.readHistoryElement, true) and compareDeep(updateCreateElement, o.updateCreateElement, true) and 
      compareDeep(conditionalCreateElement, o.conditionalCreateElement, true) and compareDeep(conditionalUpdateElement, o.conditionalUpdateElement, true) and 
      compareDeep(conditionalDeleteElement, o.conditionalDeleteElement, true) and compareDeep(searchIncludeList, o.searchIncludeList, true) and 
      compareDeep(searchRevIncludeList, o.searchRevIncludeList, true) and compareDeep(searchParamList, o.searchParamList, true);
  end;
end;

function TFhirConformanceRestResource.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FProfile) and isEmptyProp(FinteractionList) and isEmptyProp(FVersioning) and isEmptyProp(FReadHistory) and isEmptyProp(FUpdateCreate) and isEmptyProp(FConditionalCreate) and isEmptyProp(FConditionalUpdate) and isEmptyProp(FConditionalDelete) and isEmptyProp(FsearchIncludeList) and isEmptyProp(FsearchRevIncludeList) and isEmptyProp(FsearchParamList);
end;

procedure TFhirConformanceRestResource.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('profile');
  fields.add('interaction');
  fields.add('versioning');
  fields.add('readHistory');
  fields.add('updateCreate');
  fields.add('conditionalCreate');
  fields.add('conditionalUpdate');
  fields.add('conditionalDelete');
  fields.add('searchInclude');
  fields.add('searchRevInclude');
  fields.add('searchParam');
end;

{ TFhirConformanceRestResource }

Procedure TFhirConformanceRestResource.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirConformanceRestResource.GetType_ST : TFhirResourceTypesEnum;
begin
  if FType_ = nil then
    result := TFhirResourceTypesEnum(0)
  else
    result := TFhirResourceTypesEnum(StringArrayIndexOfSensitive(CODES_TFhirResourceTypesEnum, FType_.value));
end;

Procedure TFhirConformanceRestResource.SetType_ST(value : TFhirResourceTypesEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirResourceTypesEnum[value], CODES_TFhirResourceTypesEnum[value]);
end;

Procedure TFhirConformanceRestResource.SetProfile(value : TFhirReference{TFhirStructureDefinition});
begin
  FProfile.free;
  FProfile := value;
end;

Function TFhirConformanceRestResource.GetInteractionList : TFhirConformanceRestResourceInteractionList;
begin
  if FInteractionList = nil then
    FInteractionList := TFhirConformanceRestResourceInteractionList.Create;
  result := FInteractionList;
end;

Function TFhirConformanceRestResource.GetHasInteractionList : boolean;
begin
  result := (FInteractionList <> nil) and (FInteractionList.count > 0);
end;

Procedure TFhirConformanceRestResource.SetVersioning(value : TFhirEnum);
begin
  FVersioning.free;
  FVersioning := value;
end;

Function TFhirConformanceRestResource.GetVersioningST : TFhirVersioningPolicyEnum;
begin
  if FVersioning = nil then
    result := TFhirVersioningPolicyEnum(0)
  else
    result := TFhirVersioningPolicyEnum(StringArrayIndexOfSensitive(CODES_TFhirVersioningPolicyEnum, FVersioning.value));
end;

Procedure TFhirConformanceRestResource.SetVersioningST(value : TFhirVersioningPolicyEnum);
begin
  if ord(value) = 0 then
    VersioningElement := nil
  else
    VersioningElement := TFhirEnum.create(SYSTEMS_TFhirVersioningPolicyEnum[value], CODES_TFhirVersioningPolicyEnum[value]);
end;

Procedure TFhirConformanceRestResource.SetReadHistory(value : TFhirBoolean);
begin
  FReadHistory.free;
  FReadHistory := value;
end;

Function TFhirConformanceRestResource.GetReadHistoryST : Boolean;
begin
  if FReadHistory = nil then
    result := false
  else
    result := FReadHistory.value;
end;

Procedure TFhirConformanceRestResource.SetReadHistoryST(value : Boolean);
begin
  if FReadHistory = nil then
    FReadHistory := TFhirBoolean.create;
  FReadHistory.value := value
end;

Procedure TFhirConformanceRestResource.SetUpdateCreate(value : TFhirBoolean);
begin
  FUpdateCreate.free;
  FUpdateCreate := value;
end;

Function TFhirConformanceRestResource.GetUpdateCreateST : Boolean;
begin
  if FUpdateCreate = nil then
    result := false
  else
    result := FUpdateCreate.value;
end;

Procedure TFhirConformanceRestResource.SetUpdateCreateST(value : Boolean);
begin
  if FUpdateCreate = nil then
    FUpdateCreate := TFhirBoolean.create;
  FUpdateCreate.value := value
end;

Procedure TFhirConformanceRestResource.SetConditionalCreate(value : TFhirBoolean);
begin
  FConditionalCreate.free;
  FConditionalCreate := value;
end;

Function TFhirConformanceRestResource.GetConditionalCreateST : Boolean;
begin
  if FConditionalCreate = nil then
    result := false
  else
    result := FConditionalCreate.value;
end;

Procedure TFhirConformanceRestResource.SetConditionalCreateST(value : Boolean);
begin
  if FConditionalCreate = nil then
    FConditionalCreate := TFhirBoolean.create;
  FConditionalCreate.value := value
end;

Procedure TFhirConformanceRestResource.SetConditionalUpdate(value : TFhirBoolean);
begin
  FConditionalUpdate.free;
  FConditionalUpdate := value;
end;

Function TFhirConformanceRestResource.GetConditionalUpdateST : Boolean;
begin
  if FConditionalUpdate = nil then
    result := false
  else
    result := FConditionalUpdate.value;
end;

Procedure TFhirConformanceRestResource.SetConditionalUpdateST(value : Boolean);
begin
  if FConditionalUpdate = nil then
    FConditionalUpdate := TFhirBoolean.create;
  FConditionalUpdate.value := value
end;

Procedure TFhirConformanceRestResource.SetConditionalDelete(value : TFhirEnum);
begin
  FConditionalDelete.free;
  FConditionalDelete := value;
end;

Function TFhirConformanceRestResource.GetConditionalDeleteST : TFhirConditionalDeleteStatusEnum;
begin
  if FConditionalDelete = nil then
    result := TFhirConditionalDeleteStatusEnum(0)
  else
    result := TFhirConditionalDeleteStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirConditionalDeleteStatusEnum, FConditionalDelete.value));
end;

Procedure TFhirConformanceRestResource.SetConditionalDeleteST(value : TFhirConditionalDeleteStatusEnum);
begin
  if ord(value) = 0 then
    ConditionalDeleteElement := nil
  else
    ConditionalDeleteElement := TFhirEnum.create(SYSTEMS_TFhirConditionalDeleteStatusEnum[value], CODES_TFhirConditionalDeleteStatusEnum[value]);
end;

Function TFhirConformanceRestResource.GetSearchIncludeList : TFhirStringList;
begin
  if FSearchIncludeList = nil then
    FSearchIncludeList := TFhirStringList.Create;
  result := FSearchIncludeList;
end;

Function TFhirConformanceRestResource.GetHasSearchIncludeList : boolean;
begin
  result := (FSearchIncludeList <> nil) and (FSearchIncludeList.count > 0);
end;

Function TFhirConformanceRestResource.GetSearchRevIncludeList : TFhirStringList;
begin
  if FSearchRevIncludeList = nil then
    FSearchRevIncludeList := TFhirStringList.Create;
  result := FSearchRevIncludeList;
end;

Function TFhirConformanceRestResource.GetHasSearchRevIncludeList : boolean;
begin
  result := (FSearchRevIncludeList <> nil) and (FSearchRevIncludeList.count > 0);
end;

Function TFhirConformanceRestResource.GetSearchParamList : TFhirConformanceRestResourceSearchParamList;
begin
  if FSearchParamList = nil then
    FSearchParamList := TFhirConformanceRestResourceSearchParamList.Create;
  result := FSearchParamList;
end;

Function TFhirConformanceRestResource.GetHasSearchParamList : boolean;
begin
  result := (FSearchParamList <> nil) and (FSearchParamList.count > 0);
end;

function TFhirConformanceRestResource.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FProfile.sizeInBytes);
  inc(result, FinteractionList.sizeInBytes);
  inc(result, FVersioning.sizeInBytes);
  inc(result, FReadHistory.sizeInBytes);
  inc(result, FUpdateCreate.sizeInBytes);
  inc(result, FConditionalCreate.sizeInBytes);
  inc(result, FConditionalUpdate.sizeInBytes);
  inc(result, FConditionalDelete.sizeInBytes);
  inc(result, FsearchIncludeList.sizeInBytes);
  inc(result, FsearchRevIncludeList.sizeInBytes);
  inc(result, FsearchParamList.sizeInBytes);
end;

{ TFhirConformanceRestResourceListEnumerator }

Constructor TFhirConformanceRestResourceListEnumerator.Create(list : TFhirConformanceRestResourceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConformanceRestResourceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConformanceRestResourceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConformanceRestResourceListEnumerator.GetCurrent : TFhirConformanceRestResource;
begin
  Result := FList[FIndex];
end;

function TFhirConformanceRestResourceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConformanceRestResourceList }
procedure TFhirConformanceRestResourceList.AddItem(value: TFhirConformanceRestResource);
begin
  assert(value.ClassName = 'TFhirConformanceRestResource', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceRestResource');
  add(value);
end;

function TFhirConformanceRestResourceList.Append: TFhirConformanceRestResource;
begin
  result := TFhirConformanceRestResource.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConformanceRestResourceList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceRestResourceList.GetEnumerator : TFhirConformanceRestResourceListEnumerator;
begin
  result := TFhirConformanceRestResourceListEnumerator.Create(self.link);
end;

function TFhirConformanceRestResourceList.Clone: TFhirConformanceRestResourceList;
begin
  result := TFhirConformanceRestResourceList(inherited Clone);
end;

function TFhirConformanceRestResourceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceRestResourceList.GetItemN(index: Integer): TFhirConformanceRestResource;
begin
  result := TFhirConformanceRestResource(ObjectByIndex[index]);
end;

function TFhirConformanceRestResourceList.ItemClass: TFslObjectClass;
begin
  result := TFhirConformanceRestResource;
end;
function TFhirConformanceRestResourceList.IndexOf(value: TFhirConformanceRestResource): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConformanceRestResourceList.Insert(index: Integer): TFhirConformanceRestResource;
begin
  result := TFhirConformanceRestResource.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConformanceRestResourceList.InsertItem(index: Integer; value: TFhirConformanceRestResource);
begin
  assert(value is TFhirConformanceRestResource);
  Inherited Insert(index, value);
end;

function TFhirConformanceRestResourceList.Item(index: Integer): TFhirConformanceRestResource;
begin
  result := TFhirConformanceRestResource(ObjectByIndex[index]);
end;

function TFhirConformanceRestResourceList.Link: TFhirConformanceRestResourceList;
begin
  result := TFhirConformanceRestResourceList(inherited Link);
end;

procedure TFhirConformanceRestResourceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceRestResourceList.SetItemByIndex(index: Integer; value: TFhirConformanceRestResource);
begin
  assert(value is TFhirConformanceRestResource);
  FhirConformanceRestResources[index] := value;
end;

procedure TFhirConformanceRestResourceList.SetItemN(index: Integer; value: TFhirConformanceRestResource);
begin
  assert(value is TFhirConformanceRestResource);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceRestResourceInteraction }

constructor TFhirConformanceRestResourceInteraction.Create;
begin
  inherited;
end;

destructor TFhirConformanceRestResourceInteraction.Destroy;
begin
  FCode.free;
  FDocumentation.free;
  inherited;
end;

procedure TFhirConformanceRestResourceInteraction.Assign(oSource : TFslObject);
begin
  inherited;
  FCode := TFhirConformanceRestResourceInteraction(oSource).FCode.Link;
  documentationElement := TFhirConformanceRestResourceInteraction(oSource).documentationElement.Clone;
end;

procedure TFhirConformanceRestResourceInteraction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'documentation') Then
     list.add(self.link, 'documentation', FDocumentation.Link);
end;

procedure TFhirConformanceRestResourceInteraction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFHIREnum, FCode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', false, TFhirString, FDocumentation.Link));{2}
end;

function TFhirConformanceRestResourceInteraction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeElement := asEnum(SYSTEMS_TFhirTypeRestfulInteractionEnum, CODES_TFhirTypeRestfulInteractionEnum, propValue);
    result := propValue
  end
  else if (propName = 'documentation') then
  begin
    DocumentationElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConformanceRestResourceInteraction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirConformanceRestResourceInteraction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'documentation') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConformanceRestResourceInteraction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'code'
  else if (propName = 'documentation') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConformanceRestResourceInteraction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'documentation') then DocumentationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConformanceRestResourceInteraction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := asEnum(SYSTEMS_TFhirTypeRestfulInteractionEnum, CODES_TFhirTypeRestfulInteractionEnum, new){4}
  else if (propName = 'documentation') then DocumentationElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConformanceRestResourceInteraction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirConformanceRestResourceInteraction.fhirType : string;
begin
  result := 'interaction';
end;

function TFhirConformanceRestResourceInteraction.Link : TFhirConformanceRestResourceInteraction;
begin
  result := TFhirConformanceRestResourceInteraction(inherited Link);
end;

function TFhirConformanceRestResourceInteraction.Clone : TFhirConformanceRestResourceInteraction;
begin
  result := TFhirConformanceRestResourceInteraction(inherited Clone);
end;

function TFhirConformanceRestResourceInteraction.equals(other : TObject) : boolean; 
var
  o : TFhirConformanceRestResourceInteraction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConformanceRestResourceInteraction)) then
    result := false
  else
  begin
    o := TFhirConformanceRestResourceInteraction(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(documentationElement, o.documentationElement, true);
  end;
end;

function TFhirConformanceRestResourceInteraction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FDocumentation);
end;

procedure TFhirConformanceRestResourceInteraction.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('documentation');
end;

{ TFhirConformanceRestResourceInteraction }

Procedure TFhirConformanceRestResourceInteraction.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirConformanceRestResourceInteraction.GetCodeST : TFhirTypeRestfulInteractionEnum;
begin
  if FCode = nil then
    result := TFhirTypeRestfulInteractionEnum(0)
  else
    result := TFhirTypeRestfulInteractionEnum(StringArrayIndexOfSensitive(CODES_TFhirTypeRestfulInteractionEnum, FCode.value));
end;

Procedure TFhirConformanceRestResourceInteraction.SetCodeST(value : TFhirTypeRestfulInteractionEnum);
begin
  if ord(value) = 0 then
    CodeElement := nil
  else
    CodeElement := TFhirEnum.create(SYSTEMS_TFhirTypeRestfulInteractionEnum[value], CODES_TFhirTypeRestfulInteractionEnum[value]);
end;

Procedure TFhirConformanceRestResourceInteraction.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirConformanceRestResourceInteraction.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

Procedure TFhirConformanceRestResourceInteraction.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

function TFhirConformanceRestResourceInteraction.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FDocumentation.sizeInBytes);
end;

{ TFhirConformanceRestResourceInteractionListEnumerator }

Constructor TFhirConformanceRestResourceInteractionListEnumerator.Create(list : TFhirConformanceRestResourceInteractionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConformanceRestResourceInteractionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConformanceRestResourceInteractionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConformanceRestResourceInteractionListEnumerator.GetCurrent : TFhirConformanceRestResourceInteraction;
begin
  Result := FList[FIndex];
end;

function TFhirConformanceRestResourceInteractionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConformanceRestResourceInteractionList }
procedure TFhirConformanceRestResourceInteractionList.AddItem(value: TFhirConformanceRestResourceInteraction);
begin
  assert(value.ClassName = 'TFhirConformanceRestResourceInteraction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceRestResourceInteraction');
  add(value);
end;

function TFhirConformanceRestResourceInteractionList.Append: TFhirConformanceRestResourceInteraction;
begin
  result := TFhirConformanceRestResourceInteraction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConformanceRestResourceInteractionList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceRestResourceInteractionList.GetEnumerator : TFhirConformanceRestResourceInteractionListEnumerator;
begin
  result := TFhirConformanceRestResourceInteractionListEnumerator.Create(self.link);
end;

function TFhirConformanceRestResourceInteractionList.Clone: TFhirConformanceRestResourceInteractionList;
begin
  result := TFhirConformanceRestResourceInteractionList(inherited Clone);
end;

function TFhirConformanceRestResourceInteractionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceRestResourceInteractionList.GetItemN(index: Integer): TFhirConformanceRestResourceInteraction;
begin
  result := TFhirConformanceRestResourceInteraction(ObjectByIndex[index]);
end;

function TFhirConformanceRestResourceInteractionList.ItemClass: TFslObjectClass;
begin
  result := TFhirConformanceRestResourceInteraction;
end;
function TFhirConformanceRestResourceInteractionList.IndexOf(value: TFhirConformanceRestResourceInteraction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConformanceRestResourceInteractionList.Insert(index: Integer): TFhirConformanceRestResourceInteraction;
begin
  result := TFhirConformanceRestResourceInteraction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConformanceRestResourceInteractionList.InsertItem(index: Integer; value: TFhirConformanceRestResourceInteraction);
begin
  assert(value is TFhirConformanceRestResourceInteraction);
  Inherited Insert(index, value);
end;

function TFhirConformanceRestResourceInteractionList.Item(index: Integer): TFhirConformanceRestResourceInteraction;
begin
  result := TFhirConformanceRestResourceInteraction(ObjectByIndex[index]);
end;

function TFhirConformanceRestResourceInteractionList.Link: TFhirConformanceRestResourceInteractionList;
begin
  result := TFhirConformanceRestResourceInteractionList(inherited Link);
end;

procedure TFhirConformanceRestResourceInteractionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceRestResourceInteractionList.SetItemByIndex(index: Integer; value: TFhirConformanceRestResourceInteraction);
begin
  assert(value is TFhirConformanceRestResourceInteraction);
  FhirConformanceRestResourceInteractions[index] := value;
end;

procedure TFhirConformanceRestResourceInteractionList.SetItemN(index: Integer; value: TFhirConformanceRestResourceInteraction);
begin
  assert(value is TFhirConformanceRestResourceInteraction);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceRestResourceSearchParam }

constructor TFhirConformanceRestResourceSearchParam.Create;
begin
  inherited;
end;

destructor TFhirConformanceRestResourceSearchParam.Destroy;
begin
  FName.free;
  FDefinition.free;
  FType_.free;
  FDocumentation.free;
  FTarget.Free;
  FModifier.Free;
  FChainList.Free;
  inherited;
end;

procedure TFhirConformanceRestResourceSearchParam.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirConformanceRestResourceSearchParam(oSource).nameElement.Clone;
  definitionElement := TFhirConformanceRestResourceSearchParam(oSource).definitionElement.Clone;
  FType_ := TFhirConformanceRestResourceSearchParam(oSource).FType_.Link;
  documentationElement := TFhirConformanceRestResourceSearchParam(oSource).documentationElement.Clone;
  if (TFhirConformanceRestResourceSearchParam(oSource).FTarget = nil) then
  begin
    FTarget.free;
    FTarget := nil;
  end
  else
  begin
    FTarget := TFHIREnumList.Create(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum);
    FTarget.Assign(TFhirConformanceRestResourceSearchParam(oSource).FTarget);
  end;
  if (TFhirConformanceRestResourceSearchParam(oSource).FModifier = nil) then
  begin
    FModifier.free;
    FModifier := nil;
  end
  else
  begin
    FModifier := TFHIREnumList.Create(SYSTEMS_TFhirSearchModifierCodeEnum, CODES_TFhirSearchModifierCodeEnum);
    FModifier.Assign(TFhirConformanceRestResourceSearchParam(oSource).FModifier);
  end;
  if (TFhirConformanceRestResourceSearchParam(oSource).FChainList = nil) then
  begin
    FChainList.free;
    FChainList := nil;
  end
  else
  begin
    if FChainList = nil then
      FChainList := TFhirStringList.Create;
    FChainList.Assign(TFhirConformanceRestResourceSearchParam(oSource).FChainList);
  end;
end;

procedure TFhirConformanceRestResourceSearchParam.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'definition') Then
     list.add(self.link, 'definition', FDefinition.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'documentation') Then
     list.add(self.link, 'documentation', FDocumentation.Link);
  if (child_name = 'target') Then
     list.addAll(self, 'target', FTarget);
  if (child_name = 'modifier') Then
     list.addAll(self, 'modifier', FModifier);
  if (child_name = 'chain') Then
    list.addAll(self, 'chain', FChainList);
end;

procedure TFhirConformanceRestResourceSearchParam.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'definition', 'uri', false, TFhirUri, FDefinition.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', false, TFhirString, FDocumentation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'target', 'code', true, TFHIREnum, FTarget.Link)){3};
  oList.add(TFHIRProperty.create(self, 'modifier', 'code', true, TFHIREnum, FModifier.Link)){3};
  oList.add(TFHIRProperty.create(self, 'chain', 'string', true, TFhirString, FChainList.Link)){3};
end;

function TFhirConformanceRestResourceSearchParam.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'definition') then
  begin
    DefinitionElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirSearchParamTypeEnum, CODES_TFhirSearchParamTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'documentation') then
  begin
    DocumentationElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'target') then
  begin
    TargetList.add(asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue)); {1}
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(asEnum(SYSTEMS_TFhirSearchModifierCodeEnum, CODES_TFhirSearchModifierCodeEnum, propValue)); {1}
    result := propValue;
  end
  else if (propName = 'chain') then
  begin
    ChainList.add(asString(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConformanceRestResourceSearchParam.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'target') then FTarget.insertItem(index, asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue)) {1}
  else if (propName = 'modifier') then FModifier.insertItem(index, asEnum(SYSTEMS_TFhirSearchModifierCodeEnum, CODES_TFhirSearchModifierCodeEnum, propValue)) {1}
  else if (propName = 'chain') then ChainList.insertItem(index, asString(propValue)){2}
  else inherited;
end;

function TFhirConformanceRestResourceSearchParam.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'definition') then result := TFhirUri.create() {5b}
  else if (propName = 'documentation') then result := TFhirString.create() {5b}
  else if (propName = 'chain') then result := ChainList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConformanceRestResourceSearchParam.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'definition') then result := 'uri'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'documentation') then result := 'string'
  else if (propName = 'target') then result := 'code'
  else if (propName = 'modifier') then result := 'code'
  else if (propName = 'chain') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConformanceRestResourceSearchParam.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'definition') then DefinitionElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'documentation') then DocumentationElement := nil
  else if (propName = 'chain') then deletePropertyValue('chain', ChainList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConformanceRestResourceSearchParam.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'definition') then DefinitionElement := asUri(new){5b}
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirSearchParamTypeEnum, CODES_TFhirSearchParamTypeEnum, new){4}
  else if (propName = 'documentation') then DocumentationElement := asString(new){5b}
  else if (propName = 'chain') then replacePropertyValue('chain', ChainList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConformanceRestResourceSearchParam.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'target') then FTarget.move(source, destination) {1}
  else if (propName = 'modifier') then FModifier.move(source, destination) {1}
  else if (propName = 'chain') then ChainList.move(source, destination){2}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirConformanceRestResourceSearchParam.fhirType : string;
begin
  result := 'searchParam';
end;

function TFhirConformanceRestResourceSearchParam.Link : TFhirConformanceRestResourceSearchParam;
begin
  result := TFhirConformanceRestResourceSearchParam(inherited Link);
end;

function TFhirConformanceRestResourceSearchParam.Clone : TFhirConformanceRestResourceSearchParam;
begin
  result := TFhirConformanceRestResourceSearchParam(inherited Clone);
end;

function TFhirConformanceRestResourceSearchParam.equals(other : TObject) : boolean; 
var
  o : TFhirConformanceRestResourceSearchParam;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConformanceRestResourceSearchParam)) then
    result := false
  else
  begin
    o := TFhirConformanceRestResourceSearchParam(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(definitionElement, o.definitionElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(documentationElement, o.documentationElement, true) and 
      compareDeep(targetList, o.targetList, true) and compareDeep(modifierList, o.modifierList, true) and 
      compareDeep(chainList, o.chainList, true);
  end;
end;

function TFhirConformanceRestResourceSearchParam.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FDefinition) and isEmptyProp(FType_) and isEmptyProp(FDocumentation) and isEmptyProp(FTarget) and isEmptyProp(FModifier) and isEmptyProp(FchainList);
end;

procedure TFhirConformanceRestResourceSearchParam.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('definition');
  fields.add('type');
  fields.add('documentation');
  fields.add('target');
  fields.add('modifier');
  fields.add('chain');
end;

{ TFhirConformanceRestResourceSearchParam }

Procedure TFhirConformanceRestResourceSearchParam.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirConformanceRestResourceSearchParam.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirConformanceRestResourceSearchParam.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirConformanceRestResourceSearchParam.SetDefinition(value : TFhirUri);
begin
  FDefinition.free;
  FDefinition := value;
end;

Function TFhirConformanceRestResourceSearchParam.GetDefinitionST : String;
begin
  if FDefinition = nil then
    result := ''
  else
    result := FDefinition.value;
end;

Procedure TFhirConformanceRestResourceSearchParam.SetDefinitionST(value : String);
begin
  if value <> '' then
  begin
    if FDefinition = nil then
      FDefinition := TFhirUri.create;
    FDefinition.value := value
  end
  else if FDefinition <> nil then
    FDefinition.value := '';
end;

Procedure TFhirConformanceRestResourceSearchParam.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirConformanceRestResourceSearchParam.GetType_ST : TFhirSearchParamTypeEnum;
begin
  if FType_ = nil then
    result := TFhirSearchParamTypeEnum(0)
  else
    result := TFhirSearchParamTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirSearchParamTypeEnum, FType_.value));
end;

Procedure TFhirConformanceRestResourceSearchParam.SetType_ST(value : TFhirSearchParamTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirSearchParamTypeEnum[value], CODES_TFhirSearchParamTypeEnum[value]);
end;

Procedure TFhirConformanceRestResourceSearchParam.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirConformanceRestResourceSearchParam.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

Procedure TFhirConformanceRestResourceSearchParam.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

Function TFhirConformanceRestResourceSearchParam.GetTarget : TFhirEnumList;
begin
  if FTarget = nil then
    FTarget := TFHIREnumList.Create(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum);
  result := FTarget;
end;

Function TFhirConformanceRestResourceSearchParam.GetHasTarget : boolean;
begin
  result := (FTarget <> nil) and (FTarget.count > 0);
end;

Function TFhirConformanceRestResourceSearchParam.GetModifier : TFhirEnumList;
begin
  if FModifier = nil then
    FModifier := TFHIREnumList.Create(SYSTEMS_TFhirSearchModifierCodeEnum, CODES_TFhirSearchModifierCodeEnum);
  result := FModifier;
end;

Function TFhirConformanceRestResourceSearchParam.GetHasModifier : boolean;
begin
  result := (FModifier <> nil) and (FModifier.count > 0);
end;

Function TFhirConformanceRestResourceSearchParam.GetModifierST : TFhirSearchModifierCodeEnumList;
  var i : integer;
begin
  result := [];
  if Fmodifier <> nil then
    for i := 0 to Fmodifier.count - 1 do
      result := result + [TFhirSearchModifierCodeEnum(StringArrayIndexOfSensitive(CODES_TFhirSearchModifierCodeEnum, Fmodifier[i].value))];
end;

Procedure TFhirConformanceRestResourceSearchParam.SetModifierST(value : TFhirSearchModifierCodeEnumList);
var a : TFhirSearchModifierCodeEnum;
begin
  if Fmodifier = nil then
    Fmodifier := TFhirEnumList.create(SYSTEMS_TFhirSearchModifierCodeEnum, CODES_TFhirSearchModifierCodeEnum);
  Fmodifier.clear;
  for a := low(TFhirSearchModifierCodeEnum) to high(TFhirSearchModifierCodeEnum) do
    if a in value then
      begin
         if Fmodifier = nil then
           Fmodifier := TFhirEnumList.create(SYSTEMS_TFhirSearchModifierCodeEnum, CODES_TFhirSearchModifierCodeEnum);
         Fmodifier.add(TFhirEnum.create(SYSTEMS_TFhirSearchModifierCodeEnum[a], CODES_TFhirSearchModifierCodeEnum[a]));
      end;
end;

Function TFhirConformanceRestResourceSearchParam.GetChainList : TFhirStringList;
begin
  if FChainList = nil then
    FChainList := TFhirStringList.Create;
  result := FChainList;
end;

Function TFhirConformanceRestResourceSearchParam.GetHasChainList : boolean;
begin
  result := (FChainList <> nil) and (FChainList.count > 0);
end;

function TFhirConformanceRestResourceSearchParam.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FDefinition.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FDocumentation.sizeInBytes);
  inc(result, FTarget.sizeInBytes);
  inc(result, FModifier.sizeInBytes);
  inc(result, FchainList.sizeInBytes);
end;

{ TFhirConformanceRestResourceSearchParamListEnumerator }

Constructor TFhirConformanceRestResourceSearchParamListEnumerator.Create(list : TFhirConformanceRestResourceSearchParamList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConformanceRestResourceSearchParamListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConformanceRestResourceSearchParamListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConformanceRestResourceSearchParamListEnumerator.GetCurrent : TFhirConformanceRestResourceSearchParam;
begin
  Result := FList[FIndex];
end;

function TFhirConformanceRestResourceSearchParamListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConformanceRestResourceSearchParamList }
procedure TFhirConformanceRestResourceSearchParamList.AddItem(value: TFhirConformanceRestResourceSearchParam);
begin
  assert(value.ClassName = 'TFhirConformanceRestResourceSearchParam', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceRestResourceSearchParam');
  add(value);
end;

function TFhirConformanceRestResourceSearchParamList.Append: TFhirConformanceRestResourceSearchParam;
begin
  result := TFhirConformanceRestResourceSearchParam.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConformanceRestResourceSearchParamList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceRestResourceSearchParamList.GetEnumerator : TFhirConformanceRestResourceSearchParamListEnumerator;
begin
  result := TFhirConformanceRestResourceSearchParamListEnumerator.Create(self.link);
end;

function TFhirConformanceRestResourceSearchParamList.Clone: TFhirConformanceRestResourceSearchParamList;
begin
  result := TFhirConformanceRestResourceSearchParamList(inherited Clone);
end;

function TFhirConformanceRestResourceSearchParamList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceRestResourceSearchParamList.GetItemN(index: Integer): TFhirConformanceRestResourceSearchParam;
begin
  result := TFhirConformanceRestResourceSearchParam(ObjectByIndex[index]);
end;

function TFhirConformanceRestResourceSearchParamList.ItemClass: TFslObjectClass;
begin
  result := TFhirConformanceRestResourceSearchParam;
end;
function TFhirConformanceRestResourceSearchParamList.IndexOf(value: TFhirConformanceRestResourceSearchParam): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConformanceRestResourceSearchParamList.Insert(index: Integer): TFhirConformanceRestResourceSearchParam;
begin
  result := TFhirConformanceRestResourceSearchParam.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConformanceRestResourceSearchParamList.InsertItem(index: Integer; value: TFhirConformanceRestResourceSearchParam);
begin
  assert(value is TFhirConformanceRestResourceSearchParam);
  Inherited Insert(index, value);
end;

function TFhirConformanceRestResourceSearchParamList.Item(index: Integer): TFhirConformanceRestResourceSearchParam;
begin
  result := TFhirConformanceRestResourceSearchParam(ObjectByIndex[index]);
end;

function TFhirConformanceRestResourceSearchParamList.Link: TFhirConformanceRestResourceSearchParamList;
begin
  result := TFhirConformanceRestResourceSearchParamList(inherited Link);
end;

procedure TFhirConformanceRestResourceSearchParamList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceRestResourceSearchParamList.SetItemByIndex(index: Integer; value: TFhirConformanceRestResourceSearchParam);
begin
  assert(value is TFhirConformanceRestResourceSearchParam);
  FhirConformanceRestResourceSearchParams[index] := value;
end;

procedure TFhirConformanceRestResourceSearchParamList.SetItemN(index: Integer; value: TFhirConformanceRestResourceSearchParam);
begin
  assert(value is TFhirConformanceRestResourceSearchParam);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceRestInteraction }

constructor TFhirConformanceRestInteraction.Create;
begin
  inherited;
end;

destructor TFhirConformanceRestInteraction.Destroy;
begin
  FCode.free;
  FDocumentation.free;
  inherited;
end;

procedure TFhirConformanceRestInteraction.Assign(oSource : TFslObject);
begin
  inherited;
  FCode := TFhirConformanceRestInteraction(oSource).FCode.Link;
  documentationElement := TFhirConformanceRestInteraction(oSource).documentationElement.Clone;
end;

procedure TFhirConformanceRestInteraction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'documentation') Then
     list.add(self.link, 'documentation', FDocumentation.Link);
end;

procedure TFhirConformanceRestInteraction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFHIREnum, FCode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', false, TFhirString, FDocumentation.Link));{2}
end;

function TFhirConformanceRestInteraction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeElement := asEnum(SYSTEMS_TFhirSystemRestfulInteractionEnum, CODES_TFhirSystemRestfulInteractionEnum, propValue);
    result := propValue
  end
  else if (propName = 'documentation') then
  begin
    DocumentationElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConformanceRestInteraction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirConformanceRestInteraction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'documentation') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConformanceRestInteraction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'code'
  else if (propName = 'documentation') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConformanceRestInteraction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'documentation') then DocumentationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConformanceRestInteraction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := asEnum(SYSTEMS_TFhirSystemRestfulInteractionEnum, CODES_TFhirSystemRestfulInteractionEnum, new){4}
  else if (propName = 'documentation') then DocumentationElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConformanceRestInteraction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirConformanceRestInteraction.fhirType : string;
begin
  result := 'interaction';
end;

function TFhirConformanceRestInteraction.Link : TFhirConformanceRestInteraction;
begin
  result := TFhirConformanceRestInteraction(inherited Link);
end;

function TFhirConformanceRestInteraction.Clone : TFhirConformanceRestInteraction;
begin
  result := TFhirConformanceRestInteraction(inherited Clone);
end;

function TFhirConformanceRestInteraction.equals(other : TObject) : boolean; 
var
  o : TFhirConformanceRestInteraction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConformanceRestInteraction)) then
    result := false
  else
  begin
    o := TFhirConformanceRestInteraction(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(documentationElement, o.documentationElement, true);
  end;
end;

function TFhirConformanceRestInteraction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FDocumentation);
end;

procedure TFhirConformanceRestInteraction.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('documentation');
end;

{ TFhirConformanceRestInteraction }

Procedure TFhirConformanceRestInteraction.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirConformanceRestInteraction.GetCodeST : TFhirSystemRestfulInteractionEnum;
begin
  if FCode = nil then
    result := TFhirSystemRestfulInteractionEnum(0)
  else
    result := TFhirSystemRestfulInteractionEnum(StringArrayIndexOfSensitive(CODES_TFhirSystemRestfulInteractionEnum, FCode.value));
end;

Procedure TFhirConformanceRestInteraction.SetCodeST(value : TFhirSystemRestfulInteractionEnum);
begin
  if ord(value) = 0 then
    CodeElement := nil
  else
    CodeElement := TFhirEnum.create(SYSTEMS_TFhirSystemRestfulInteractionEnum[value], CODES_TFhirSystemRestfulInteractionEnum[value]);
end;

Procedure TFhirConformanceRestInteraction.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirConformanceRestInteraction.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

Procedure TFhirConformanceRestInteraction.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

function TFhirConformanceRestInteraction.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FDocumentation.sizeInBytes);
end;

{ TFhirConformanceRestInteractionListEnumerator }

Constructor TFhirConformanceRestInteractionListEnumerator.Create(list : TFhirConformanceRestInteractionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConformanceRestInteractionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConformanceRestInteractionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConformanceRestInteractionListEnumerator.GetCurrent : TFhirConformanceRestInteraction;
begin
  Result := FList[FIndex];
end;

function TFhirConformanceRestInteractionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConformanceRestInteractionList }
procedure TFhirConformanceRestInteractionList.AddItem(value: TFhirConformanceRestInteraction);
begin
  assert(value.ClassName = 'TFhirConformanceRestInteraction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceRestInteraction');
  add(value);
end;

function TFhirConformanceRestInteractionList.Append: TFhirConformanceRestInteraction;
begin
  result := TFhirConformanceRestInteraction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConformanceRestInteractionList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceRestInteractionList.GetEnumerator : TFhirConformanceRestInteractionListEnumerator;
begin
  result := TFhirConformanceRestInteractionListEnumerator.Create(self.link);
end;

function TFhirConformanceRestInteractionList.Clone: TFhirConformanceRestInteractionList;
begin
  result := TFhirConformanceRestInteractionList(inherited Clone);
end;

function TFhirConformanceRestInteractionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceRestInteractionList.GetItemN(index: Integer): TFhirConformanceRestInteraction;
begin
  result := TFhirConformanceRestInteraction(ObjectByIndex[index]);
end;

function TFhirConformanceRestInteractionList.ItemClass: TFslObjectClass;
begin
  result := TFhirConformanceRestInteraction;
end;
function TFhirConformanceRestInteractionList.IndexOf(value: TFhirConformanceRestInteraction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConformanceRestInteractionList.Insert(index: Integer): TFhirConformanceRestInteraction;
begin
  result := TFhirConformanceRestInteraction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConformanceRestInteractionList.InsertItem(index: Integer; value: TFhirConformanceRestInteraction);
begin
  assert(value is TFhirConformanceRestInteraction);
  Inherited Insert(index, value);
end;

function TFhirConformanceRestInteractionList.Item(index: Integer): TFhirConformanceRestInteraction;
begin
  result := TFhirConformanceRestInteraction(ObjectByIndex[index]);
end;

function TFhirConformanceRestInteractionList.Link: TFhirConformanceRestInteractionList;
begin
  result := TFhirConformanceRestInteractionList(inherited Link);
end;

procedure TFhirConformanceRestInteractionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceRestInteractionList.SetItemByIndex(index: Integer; value: TFhirConformanceRestInteraction);
begin
  assert(value is TFhirConformanceRestInteraction);
  FhirConformanceRestInteractions[index] := value;
end;

procedure TFhirConformanceRestInteractionList.SetItemN(index: Integer; value: TFhirConformanceRestInteraction);
begin
  assert(value is TFhirConformanceRestInteraction);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceRestOperation }

constructor TFhirConformanceRestOperation.Create;
begin
  inherited;
end;

destructor TFhirConformanceRestOperation.Destroy;
begin
  FName.free;
  FDefinition.free;
  inherited;
end;

procedure TFhirConformanceRestOperation.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirConformanceRestOperation(oSource).nameElement.Clone;
  definition := TFhirConformanceRestOperation(oSource).definition.Clone;
end;

procedure TFhirConformanceRestOperation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'definition') Then
     list.add(self.link, 'definition', FDefinition.Link);
end;

procedure TFhirConformanceRestOperation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'definition', 'Reference(OperationDefinition)', false, TFhirReference{TFhirOperationDefinition}, FDefinition.Link));{2}
end;

function TFhirConformanceRestOperation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'definition') then
  begin
    Definition := propValue as TFhirReference{TFhirOperationDefinition}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConformanceRestOperation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirConformanceRestOperation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'definition') then result := TFhirReference{TFhirOperationDefinition}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConformanceRestOperation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'definition') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConformanceRestOperation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'definition') then DefinitionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConformanceRestOperation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'definition') then DefinitionElement := new as TFhirReference{TFhirOperationDefinition}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConformanceRestOperation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirConformanceRestOperation.fhirType : string;
begin
  result := 'operation';
end;

function TFhirConformanceRestOperation.Link : TFhirConformanceRestOperation;
begin
  result := TFhirConformanceRestOperation(inherited Link);
end;

function TFhirConformanceRestOperation.Clone : TFhirConformanceRestOperation;
begin
  result := TFhirConformanceRestOperation(inherited Clone);
end;

function TFhirConformanceRestOperation.equals(other : TObject) : boolean; 
var
  o : TFhirConformanceRestOperation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConformanceRestOperation)) then
    result := false
  else
  begin
    o := TFhirConformanceRestOperation(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(definitionElement, o.definitionElement, true);
  end;
end;

function TFhirConformanceRestOperation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FDefinition);
end;

procedure TFhirConformanceRestOperation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('definition');
end;

{ TFhirConformanceRestOperation }

Procedure TFhirConformanceRestOperation.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirConformanceRestOperation.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirConformanceRestOperation.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirConformanceRestOperation.SetDefinition(value : TFhirReference{TFhirOperationDefinition});
begin
  FDefinition.free;
  FDefinition := value;
end;

function TFhirConformanceRestOperation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FDefinition.sizeInBytes);
end;

{ TFhirConformanceRestOperationListEnumerator }

Constructor TFhirConformanceRestOperationListEnumerator.Create(list : TFhirConformanceRestOperationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConformanceRestOperationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConformanceRestOperationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConformanceRestOperationListEnumerator.GetCurrent : TFhirConformanceRestOperation;
begin
  Result := FList[FIndex];
end;

function TFhirConformanceRestOperationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConformanceRestOperationList }
procedure TFhirConformanceRestOperationList.AddItem(value: TFhirConformanceRestOperation);
begin
  assert(value.ClassName = 'TFhirConformanceRestOperation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceRestOperation');
  add(value);
end;

function TFhirConformanceRestOperationList.Append: TFhirConformanceRestOperation;
begin
  result := TFhirConformanceRestOperation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConformanceRestOperationList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceRestOperationList.GetEnumerator : TFhirConformanceRestOperationListEnumerator;
begin
  result := TFhirConformanceRestOperationListEnumerator.Create(self.link);
end;

function TFhirConformanceRestOperationList.Clone: TFhirConformanceRestOperationList;
begin
  result := TFhirConformanceRestOperationList(inherited Clone);
end;

function TFhirConformanceRestOperationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceRestOperationList.GetItemN(index: Integer): TFhirConformanceRestOperation;
begin
  result := TFhirConformanceRestOperation(ObjectByIndex[index]);
end;

function TFhirConformanceRestOperationList.ItemClass: TFslObjectClass;
begin
  result := TFhirConformanceRestOperation;
end;
function TFhirConformanceRestOperationList.IndexOf(value: TFhirConformanceRestOperation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConformanceRestOperationList.Insert(index: Integer): TFhirConformanceRestOperation;
begin
  result := TFhirConformanceRestOperation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConformanceRestOperationList.InsertItem(index: Integer; value: TFhirConformanceRestOperation);
begin
  assert(value is TFhirConformanceRestOperation);
  Inherited Insert(index, value);
end;

function TFhirConformanceRestOperationList.Item(index: Integer): TFhirConformanceRestOperation;
begin
  result := TFhirConformanceRestOperation(ObjectByIndex[index]);
end;

function TFhirConformanceRestOperationList.Link: TFhirConformanceRestOperationList;
begin
  result := TFhirConformanceRestOperationList(inherited Link);
end;

procedure TFhirConformanceRestOperationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceRestOperationList.SetItemByIndex(index: Integer; value: TFhirConformanceRestOperation);
begin
  assert(value is TFhirConformanceRestOperation);
  FhirConformanceRestOperations[index] := value;
end;

procedure TFhirConformanceRestOperationList.SetItemN(index: Integer; value: TFhirConformanceRestOperation);
begin
  assert(value is TFhirConformanceRestOperation);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceMessaging }

constructor TFhirConformanceMessaging.Create;
begin
  inherited;
end;

destructor TFhirConformanceMessaging.Destroy;
begin
  FEndpointList.Free;
  FReliableCache.free;
  FDocumentation.free;
  FEventList.Free;
  inherited;
end;

procedure TFhirConformanceMessaging.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirConformanceMessaging(oSource).FEndpointList = nil) then
  begin
    FEndpointList.free;
    FEndpointList := nil;
  end
  else
  begin
    if FEndpointList = nil then
      FEndpointList := TFhirConformanceMessagingEndpointList.Create;
    FEndpointList.Assign(TFhirConformanceMessaging(oSource).FEndpointList);
  end;
  reliableCacheElement := TFhirConformanceMessaging(oSource).reliableCacheElement.Clone;
  documentationElement := TFhirConformanceMessaging(oSource).documentationElement.Clone;
  if (TFhirConformanceMessaging(oSource).FEventList = nil) then
  begin
    FEventList.free;
    FEventList := nil;
  end
  else
  begin
    if FEventList = nil then
      FEventList := TFhirConformanceMessagingEventList.Create;
    FEventList.Assign(TFhirConformanceMessaging(oSource).FEventList);
  end;
end;

procedure TFhirConformanceMessaging.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'endpoint') Then
    list.addAll(self, 'endpoint', FEndpointList);
  if (child_name = 'reliableCache') Then
     list.add(self.link, 'reliableCache', FReliableCache.Link);
  if (child_name = 'documentation') Then
     list.add(self.link, 'documentation', FDocumentation.Link);
  if (child_name = 'event') Then
    list.addAll(self, 'event', FEventList);
end;

procedure TFhirConformanceMessaging.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'endpoint', '', true, TFhirConformanceMessagingEndpoint, FEndpointList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reliableCache', 'unsignedInt', false, TFhirUnsignedInt, FReliableCache.Link));{2}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', false, TFhirString, FDocumentation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'event', '', true, TFhirConformanceMessagingEvent, FEventList.Link)){3};
end;

function TFhirConformanceMessaging.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'endpoint') then
  begin
    EndpointList.add(propValue as TFhirConformanceMessagingEndpoint){2a};
    result := propValue;
  end
  else if (propName = 'reliableCache') then
  begin
    ReliableCacheElement := asUnsignedInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'documentation') then
  begin
    DocumentationElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'event') then
  begin
    EventList.add(propValue as TFhirConformanceMessagingEvent){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConformanceMessaging.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'endpoint') then EndpointList.insertItem(index, propValue as TFhirConformanceMessagingEndpoint){2a}
  else if (propName = 'event') then EventList.insertItem(index, propValue as TFhirConformanceMessagingEvent){2a}
  else inherited;
end;

function TFhirConformanceMessaging.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'endpoint') then result := EndpointList.new(){2}
  else if (propName = 'reliableCache') then result := TFhirUnsignedInt.create() {5b}
  else if (propName = 'documentation') then result := TFhirString.create() {5b}
  else if (propName = 'event') then result := EventList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConformanceMessaging.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'endpoint') then result := ''
  else if (propName = 'reliableCache') then result := 'unsignedInt'
  else if (propName = 'documentation') then result := 'string'
  else if (propName = 'event') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConformanceMessaging.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'endpoint') then deletePropertyValue('endpoint', EndpointList, value) {2}
  else if (propName = 'reliableCache') then ReliableCacheElement := nil
  else if (propName = 'documentation') then DocumentationElement := nil
  else if (propName = 'event') then deletePropertyValue('event', EventList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConformanceMessaging.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'endpoint') then replacePropertyValue('endpoint', EndpointList, existing, new) {2}
  else if (propName = 'reliableCache') then ReliableCacheElement := asUnsignedInt(new){5b}
  else if (propName = 'documentation') then DocumentationElement := asString(new){5b}
  else if (propName = 'event') then replacePropertyValue('event', EventList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConformanceMessaging.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'endpoint') then EndpointList.move(source, destination){2a}
  else if (propName = 'event') then EventList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirConformanceMessaging.fhirType : string;
begin
  result := 'messaging';
end;

function TFhirConformanceMessaging.Link : TFhirConformanceMessaging;
begin
  result := TFhirConformanceMessaging(inherited Link);
end;

function TFhirConformanceMessaging.Clone : TFhirConformanceMessaging;
begin
  result := TFhirConformanceMessaging(inherited Clone);
end;

function TFhirConformanceMessaging.equals(other : TObject) : boolean; 
var
  o : TFhirConformanceMessaging;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConformanceMessaging)) then
    result := false
  else
  begin
    o := TFhirConformanceMessaging(other);
    result := compareDeep(endpointList, o.endpointList, true) and compareDeep(reliableCacheElement, o.reliableCacheElement, true) and 
      compareDeep(documentationElement, o.documentationElement, true) and compareDeep(eventList, o.eventList, true);
  end;
end;

function TFhirConformanceMessaging.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FendpointList) and isEmptyProp(FReliableCache) and isEmptyProp(FDocumentation) and isEmptyProp(FeventList);
end;

procedure TFhirConformanceMessaging.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('endpoint');
  fields.add('reliableCache');
  fields.add('documentation');
  fields.add('event');
end;

{ TFhirConformanceMessaging }

Function TFhirConformanceMessaging.GetEndpointList : TFhirConformanceMessagingEndpointList;
begin
  if FEndpointList = nil then
    FEndpointList := TFhirConformanceMessagingEndpointList.Create;
  result := FEndpointList;
end;

Function TFhirConformanceMessaging.GetHasEndpointList : boolean;
begin
  result := (FEndpointList <> nil) and (FEndpointList.count > 0);
end;

Procedure TFhirConformanceMessaging.SetReliableCache(value : TFhirUnsignedInt);
begin
  FReliableCache.free;
  FReliableCache := value;
end;

Function TFhirConformanceMessaging.GetReliableCacheST : String;
begin
  if FReliableCache = nil then
    result := ''
  else
    result := FReliableCache.value;
end;

Procedure TFhirConformanceMessaging.SetReliableCacheST(value : String);
begin
  if value <> '' then
  begin
    if FReliableCache = nil then
      FReliableCache := TFhirUnsignedInt.create;
    FReliableCache.value := value
  end
  else if FReliableCache <> nil then
    FReliableCache.value := '';
end;

Procedure TFhirConformanceMessaging.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirConformanceMessaging.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

Procedure TFhirConformanceMessaging.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

Function TFhirConformanceMessaging.GetEventList : TFhirConformanceMessagingEventList;
begin
  if FEventList = nil then
    FEventList := TFhirConformanceMessagingEventList.Create;
  result := FEventList;
end;

Function TFhirConformanceMessaging.GetHasEventList : boolean;
begin
  result := (FEventList <> nil) and (FEventList.count > 0);
end;

function TFhirConformanceMessaging.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FendpointList.sizeInBytes);
  inc(result, FReliableCache.sizeInBytes);
  inc(result, FDocumentation.sizeInBytes);
  inc(result, FeventList.sizeInBytes);
end;

{ TFhirConformanceMessagingListEnumerator }

Constructor TFhirConformanceMessagingListEnumerator.Create(list : TFhirConformanceMessagingList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConformanceMessagingListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConformanceMessagingListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConformanceMessagingListEnumerator.GetCurrent : TFhirConformanceMessaging;
begin
  Result := FList[FIndex];
end;

function TFhirConformanceMessagingListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConformanceMessagingList }
procedure TFhirConformanceMessagingList.AddItem(value: TFhirConformanceMessaging);
begin
  assert(value.ClassName = 'TFhirConformanceMessaging', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceMessaging');
  add(value);
end;

function TFhirConformanceMessagingList.Append: TFhirConformanceMessaging;
begin
  result := TFhirConformanceMessaging.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConformanceMessagingList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceMessagingList.GetEnumerator : TFhirConformanceMessagingListEnumerator;
begin
  result := TFhirConformanceMessagingListEnumerator.Create(self.link);
end;

function TFhirConformanceMessagingList.Clone: TFhirConformanceMessagingList;
begin
  result := TFhirConformanceMessagingList(inherited Clone);
end;

function TFhirConformanceMessagingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceMessagingList.GetItemN(index: Integer): TFhirConformanceMessaging;
begin
  result := TFhirConformanceMessaging(ObjectByIndex[index]);
end;

function TFhirConformanceMessagingList.ItemClass: TFslObjectClass;
begin
  result := TFhirConformanceMessaging;
end;
function TFhirConformanceMessagingList.IndexOf(value: TFhirConformanceMessaging): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConformanceMessagingList.Insert(index: Integer): TFhirConformanceMessaging;
begin
  result := TFhirConformanceMessaging.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConformanceMessagingList.InsertItem(index: Integer; value: TFhirConformanceMessaging);
begin
  assert(value is TFhirConformanceMessaging);
  Inherited Insert(index, value);
end;

function TFhirConformanceMessagingList.Item(index: Integer): TFhirConformanceMessaging;
begin
  result := TFhirConformanceMessaging(ObjectByIndex[index]);
end;

function TFhirConformanceMessagingList.Link: TFhirConformanceMessagingList;
begin
  result := TFhirConformanceMessagingList(inherited Link);
end;

procedure TFhirConformanceMessagingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceMessagingList.SetItemByIndex(index: Integer; value: TFhirConformanceMessaging);
begin
  assert(value is TFhirConformanceMessaging);
  FhirConformanceMessagings[index] := value;
end;

procedure TFhirConformanceMessagingList.SetItemN(index: Integer; value: TFhirConformanceMessaging);
begin
  assert(value is TFhirConformanceMessaging);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceMessagingEndpoint }

constructor TFhirConformanceMessagingEndpoint.Create;
begin
  inherited;
end;

destructor TFhirConformanceMessagingEndpoint.Destroy;
begin
  FProtocol.free;
  FAddress.free;
  inherited;
end;

procedure TFhirConformanceMessagingEndpoint.Assign(oSource : TFslObject);
begin
  inherited;
  protocol := TFhirConformanceMessagingEndpoint(oSource).protocol.Clone;
  addressElement := TFhirConformanceMessagingEndpoint(oSource).addressElement.Clone;
end;

procedure TFhirConformanceMessagingEndpoint.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'protocol') Then
     list.add(self.link, 'protocol', FProtocol.Link);
  if (child_name = 'address') Then
     list.add(self.link, 'address', FAddress.Link);
end;

procedure TFhirConformanceMessagingEndpoint.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'protocol', 'Coding', false, TFhirCoding, FProtocol.Link));{2}
  oList.add(TFHIRProperty.create(self, 'address', 'uri', false, TFhirUri, FAddress.Link));{2}
end;

function TFhirConformanceMessagingEndpoint.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'protocol') then
  begin
    Protocol := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'address') then
  begin
    AddressElement := asUri(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConformanceMessagingEndpoint.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirConformanceMessagingEndpoint.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'protocol') then result := TFhirCoding.create(){4b}
  else if (propName = 'address') then result := TFhirUri.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConformanceMessagingEndpoint.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'protocol') then result := 'Coding'
  else if (propName = 'address') then result := 'uri'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConformanceMessagingEndpoint.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'protocol') then ProtocolElement := nil
  else if (propName = 'address') then AddressElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConformanceMessagingEndpoint.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'protocol') then ProtocolElement := new as TFhirCoding{4}
  else if (propName = 'address') then AddressElement := asUri(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConformanceMessagingEndpoint.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirConformanceMessagingEndpoint.fhirType : string;
begin
  result := 'endpoint';
end;

function TFhirConformanceMessagingEndpoint.Link : TFhirConformanceMessagingEndpoint;
begin
  result := TFhirConformanceMessagingEndpoint(inherited Link);
end;

function TFhirConformanceMessagingEndpoint.Clone : TFhirConformanceMessagingEndpoint;
begin
  result := TFhirConformanceMessagingEndpoint(inherited Clone);
end;

function TFhirConformanceMessagingEndpoint.equals(other : TObject) : boolean; 
var
  o : TFhirConformanceMessagingEndpoint;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConformanceMessagingEndpoint)) then
    result := false
  else
  begin
    o := TFhirConformanceMessagingEndpoint(other);
    result := compareDeep(protocolElement, o.protocolElement, true) and compareDeep(addressElement, o.addressElement, true);
  end;
end;

function TFhirConformanceMessagingEndpoint.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FProtocol) and isEmptyProp(FAddress);
end;

procedure TFhirConformanceMessagingEndpoint.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('protocol');
  fields.add('address');
end;

{ TFhirConformanceMessagingEndpoint }

Procedure TFhirConformanceMessagingEndpoint.SetProtocol(value : TFhirCoding);
begin
  FProtocol.free;
  FProtocol := value;
end;

Procedure TFhirConformanceMessagingEndpoint.SetAddress(value : TFhirUri);
begin
  FAddress.free;
  FAddress := value;
end;

Function TFhirConformanceMessagingEndpoint.GetAddressST : String;
begin
  if FAddress = nil then
    result := ''
  else
    result := FAddress.value;
end;

Procedure TFhirConformanceMessagingEndpoint.SetAddressST(value : String);
begin
  if value <> '' then
  begin
    if FAddress = nil then
      FAddress := TFhirUri.create;
    FAddress.value := value
  end
  else if FAddress <> nil then
    FAddress.value := '';
end;

function TFhirConformanceMessagingEndpoint.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FProtocol.sizeInBytes);
  inc(result, FAddress.sizeInBytes);
end;

{ TFhirConformanceMessagingEndpointListEnumerator }

Constructor TFhirConformanceMessagingEndpointListEnumerator.Create(list : TFhirConformanceMessagingEndpointList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConformanceMessagingEndpointListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConformanceMessagingEndpointListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConformanceMessagingEndpointListEnumerator.GetCurrent : TFhirConformanceMessagingEndpoint;
begin
  Result := FList[FIndex];
end;

function TFhirConformanceMessagingEndpointListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConformanceMessagingEndpointList }
procedure TFhirConformanceMessagingEndpointList.AddItem(value: TFhirConformanceMessagingEndpoint);
begin
  assert(value.ClassName = 'TFhirConformanceMessagingEndpoint', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceMessagingEndpoint');
  add(value);
end;

function TFhirConformanceMessagingEndpointList.Append: TFhirConformanceMessagingEndpoint;
begin
  result := TFhirConformanceMessagingEndpoint.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConformanceMessagingEndpointList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceMessagingEndpointList.GetEnumerator : TFhirConformanceMessagingEndpointListEnumerator;
begin
  result := TFhirConformanceMessagingEndpointListEnumerator.Create(self.link);
end;

function TFhirConformanceMessagingEndpointList.Clone: TFhirConformanceMessagingEndpointList;
begin
  result := TFhirConformanceMessagingEndpointList(inherited Clone);
end;

function TFhirConformanceMessagingEndpointList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceMessagingEndpointList.GetItemN(index: Integer): TFhirConformanceMessagingEndpoint;
begin
  result := TFhirConformanceMessagingEndpoint(ObjectByIndex[index]);
end;

function TFhirConformanceMessagingEndpointList.ItemClass: TFslObjectClass;
begin
  result := TFhirConformanceMessagingEndpoint;
end;
function TFhirConformanceMessagingEndpointList.IndexOf(value: TFhirConformanceMessagingEndpoint): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConformanceMessagingEndpointList.Insert(index: Integer): TFhirConformanceMessagingEndpoint;
begin
  result := TFhirConformanceMessagingEndpoint.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConformanceMessagingEndpointList.InsertItem(index: Integer; value: TFhirConformanceMessagingEndpoint);
begin
  assert(value is TFhirConformanceMessagingEndpoint);
  Inherited Insert(index, value);
end;

function TFhirConformanceMessagingEndpointList.Item(index: Integer): TFhirConformanceMessagingEndpoint;
begin
  result := TFhirConformanceMessagingEndpoint(ObjectByIndex[index]);
end;

function TFhirConformanceMessagingEndpointList.Link: TFhirConformanceMessagingEndpointList;
begin
  result := TFhirConformanceMessagingEndpointList(inherited Link);
end;

procedure TFhirConformanceMessagingEndpointList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceMessagingEndpointList.SetItemByIndex(index: Integer; value: TFhirConformanceMessagingEndpoint);
begin
  assert(value is TFhirConformanceMessagingEndpoint);
  FhirConformanceMessagingEndpoints[index] := value;
end;

procedure TFhirConformanceMessagingEndpointList.SetItemN(index: Integer; value: TFhirConformanceMessagingEndpoint);
begin
  assert(value is TFhirConformanceMessagingEndpoint);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceMessagingEvent }

constructor TFhirConformanceMessagingEvent.Create;
begin
  inherited;
end;

destructor TFhirConformanceMessagingEvent.Destroy;
begin
  FCode.free;
  FCategory.free;
  FMode.free;
  FFocus.free;
  FRequest.free;
  FResponse.free;
  FDocumentation.free;
  inherited;
end;

procedure TFhirConformanceMessagingEvent.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirConformanceMessagingEvent(oSource).code.Clone;
  FCategory := TFhirConformanceMessagingEvent(oSource).FCategory.Link;
  FMode := TFhirConformanceMessagingEvent(oSource).FMode.Link;
  FFocus := TFhirConformanceMessagingEvent(oSource).FFocus.Link;
  request := TFhirConformanceMessagingEvent(oSource).request.Clone;
  response := TFhirConformanceMessagingEvent(oSource).response.Clone;
  documentationElement := TFhirConformanceMessagingEvent(oSource).documentationElement.Clone;
end;

procedure TFhirConformanceMessagingEvent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'mode') Then
     list.add(self.link, 'mode', FMode.Link);
  if (child_name = 'focus') Then
     list.add(self.link, 'focus', FFocus.Link);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'response') Then
     list.add(self.link, 'response', FResponse.Link);
  if (child_name = 'documentation') Then
     list.add(self.link, 'documentation', FDocumentation.Link);
end;

procedure TFhirConformanceMessagingEvent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'Coding', false, TFhirCoding, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'category', 'code', false, TFHIREnum, FCategory.Link));{1}
  oList.add(TFHIRProperty.create(self, 'mode', 'code', false, TFHIREnum, FMode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'focus', 'code', false, TFHIREnum, FFocus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'request', 'Reference(StructureDefinition)', false, TFhirReference{TFhirStructureDefinition}, FRequest.Link));{2}
  oList.add(TFHIRProperty.create(self, 'response', 'Reference(StructureDefinition)', false, TFhirReference{TFhirStructureDefinition}, FResponse.Link));{2}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', false, TFhirString, FDocumentation.Link));{2}
end;

function TFhirConformanceMessagingEvent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryElement := asEnum(SYSTEMS_TFhirMessageSignificanceCategoryEnum, CODES_TFhirMessageSignificanceCategoryEnum, propValue);
    result := propValue
  end
  else if (propName = 'mode') then
  begin
    ModeElement := asEnum(SYSTEMS_TFhirMessageConformanceEventModeEnum, CODES_TFhirMessageConformanceEventModeEnum, propValue);
    result := propValue
  end
  else if (propName = 'focus') then
  begin
    FocusElement := asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue);
    result := propValue
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirReference{TFhirStructureDefinition}{4b};
    result := propValue;
  end
  else if (propName = 'response') then
  begin
    Response := propValue as TFhirReference{TFhirStructureDefinition}{4b};
    result := propValue;
  end
  else if (propName = 'documentation') then
  begin
    DocumentationElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConformanceMessagingEvent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirConformanceMessagingEvent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCoding.create(){4b}
  else if (propName = 'request') then result := TFhirReference{TFhirStructureDefinition}.create(){4b}
  else if (propName = 'response') then result := TFhirReference{TFhirStructureDefinition}.create(){4b}
  else if (propName = 'documentation') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConformanceMessagingEvent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'Coding'
  else if (propName = 'category') then result := 'code'
  else if (propName = 'mode') then result := 'code'
  else if (propName = 'focus') then result := 'code'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'response') then result := 'Reference'
  else if (propName = 'documentation') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConformanceMessagingEvent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'mode') then ModeElement := nil
  else if (propName = 'focus') then FocusElement := nil
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'response') then ResponseElement := nil
  else if (propName = 'documentation') then DocumentationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConformanceMessagingEvent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCoding{4}
  else if (propName = 'category') then CategoryElement := asEnum(SYSTEMS_TFhirMessageSignificanceCategoryEnum, CODES_TFhirMessageSignificanceCategoryEnum, new){4}
  else if (propName = 'mode') then ModeElement := asEnum(SYSTEMS_TFhirMessageConformanceEventModeEnum, CODES_TFhirMessageConformanceEventModeEnum, new){4}
  else if (propName = 'focus') then FocusElement := asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, new){4}
  else if (propName = 'request') then RequestElement := new as TFhirReference{TFhirStructureDefinition}{4}
  else if (propName = 'response') then ResponseElement := new as TFhirReference{TFhirStructureDefinition}{4}
  else if (propName = 'documentation') then DocumentationElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConformanceMessagingEvent.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirConformanceMessagingEvent.fhirType : string;
begin
  result := 'event';
end;

function TFhirConformanceMessagingEvent.Link : TFhirConformanceMessagingEvent;
begin
  result := TFhirConformanceMessagingEvent(inherited Link);
end;

function TFhirConformanceMessagingEvent.Clone : TFhirConformanceMessagingEvent;
begin
  result := TFhirConformanceMessagingEvent(inherited Clone);
end;

function TFhirConformanceMessagingEvent.equals(other : TObject) : boolean; 
var
  o : TFhirConformanceMessagingEvent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConformanceMessagingEvent)) then
    result := false
  else
  begin
    o := TFhirConformanceMessagingEvent(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(categoryElement, o.categoryElement, true) and 
      compareDeep(modeElement, o.modeElement, true) and compareDeep(focusElement, o.focusElement, true) and 
      compareDeep(requestElement, o.requestElement, true) and compareDeep(responseElement, o.responseElement, true) and 
      compareDeep(documentationElement, o.documentationElement, true);
  end;
end;

function TFhirConformanceMessagingEvent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FCategory) and isEmptyProp(FMode) and isEmptyProp(FFocus) and isEmptyProp(FRequest) and isEmptyProp(FResponse) and isEmptyProp(FDocumentation);
end;

procedure TFhirConformanceMessagingEvent.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('category');
  fields.add('mode');
  fields.add('focus');
  fields.add('request');
  fields.add('response');
  fields.add('documentation');
end;

{ TFhirConformanceMessagingEvent }

Procedure TFhirConformanceMessagingEvent.SetCode(value : TFhirCoding);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirConformanceMessagingEvent.SetCategory(value : TFhirEnum);
begin
  FCategory.free;
  FCategory := value;
end;

Function TFhirConformanceMessagingEvent.GetCategoryST : TFhirMessageSignificanceCategoryEnum;
begin
  if FCategory = nil then
    result := TFhirMessageSignificanceCategoryEnum(0)
  else
    result := TFhirMessageSignificanceCategoryEnum(StringArrayIndexOfSensitive(CODES_TFhirMessageSignificanceCategoryEnum, FCategory.value));
end;

Procedure TFhirConformanceMessagingEvent.SetCategoryST(value : TFhirMessageSignificanceCategoryEnum);
begin
  if ord(value) = 0 then
    CategoryElement := nil
  else
    CategoryElement := TFhirEnum.create(SYSTEMS_TFhirMessageSignificanceCategoryEnum[value], CODES_TFhirMessageSignificanceCategoryEnum[value]);
end;

Procedure TFhirConformanceMessagingEvent.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

Function TFhirConformanceMessagingEvent.GetModeST : TFhirMessageConformanceEventModeEnum;
begin
  if FMode = nil then
    result := TFhirMessageConformanceEventModeEnum(0)
  else
    result := TFhirMessageConformanceEventModeEnum(StringArrayIndexOfSensitive(CODES_TFhirMessageConformanceEventModeEnum, FMode.value));
end;

Procedure TFhirConformanceMessagingEvent.SetModeST(value : TFhirMessageConformanceEventModeEnum);
begin
  if ord(value) = 0 then
    ModeElement := nil
  else
    ModeElement := TFhirEnum.create(SYSTEMS_TFhirMessageConformanceEventModeEnum[value], CODES_TFhirMessageConformanceEventModeEnum[value]);
end;

Procedure TFhirConformanceMessagingEvent.SetFocus(value : TFhirEnum);
begin
  FFocus.free;
  FFocus := value;
end;

Function TFhirConformanceMessagingEvent.GetFocusST : TFhirResourceTypesEnum;
begin
  if FFocus = nil then
    result := TFhirResourceTypesEnum(0)
  else
    result := TFhirResourceTypesEnum(StringArrayIndexOfSensitive(CODES_TFhirResourceTypesEnum, FFocus.value));
end;

Procedure TFhirConformanceMessagingEvent.SetFocusST(value : TFhirResourceTypesEnum);
begin
  if ord(value) = 0 then
    FocusElement := nil
  else
    FocusElement := TFhirEnum.create(SYSTEMS_TFhirResourceTypesEnum[value], CODES_TFhirResourceTypesEnum[value]);
end;

Procedure TFhirConformanceMessagingEvent.SetRequest(value : TFhirReference{TFhirStructureDefinition});
begin
  FRequest.free;
  FRequest := value;
end;

Procedure TFhirConformanceMessagingEvent.SetResponse(value : TFhirReference{TFhirStructureDefinition});
begin
  FResponse.free;
  FResponse := value;
end;

Procedure TFhirConformanceMessagingEvent.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirConformanceMessagingEvent.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

Procedure TFhirConformanceMessagingEvent.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

function TFhirConformanceMessagingEvent.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FMode.sizeInBytes);
  inc(result, FFocus.sizeInBytes);
  inc(result, FRequest.sizeInBytes);
  inc(result, FResponse.sizeInBytes);
  inc(result, FDocumentation.sizeInBytes);
end;

{ TFhirConformanceMessagingEventListEnumerator }

Constructor TFhirConformanceMessagingEventListEnumerator.Create(list : TFhirConformanceMessagingEventList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConformanceMessagingEventListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConformanceMessagingEventListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConformanceMessagingEventListEnumerator.GetCurrent : TFhirConformanceMessagingEvent;
begin
  Result := FList[FIndex];
end;

function TFhirConformanceMessagingEventListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConformanceMessagingEventList }
procedure TFhirConformanceMessagingEventList.AddItem(value: TFhirConformanceMessagingEvent);
begin
  assert(value.ClassName = 'TFhirConformanceMessagingEvent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceMessagingEvent');
  add(value);
end;

function TFhirConformanceMessagingEventList.Append: TFhirConformanceMessagingEvent;
begin
  result := TFhirConformanceMessagingEvent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConformanceMessagingEventList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceMessagingEventList.GetEnumerator : TFhirConformanceMessagingEventListEnumerator;
begin
  result := TFhirConformanceMessagingEventListEnumerator.Create(self.link);
end;

function TFhirConformanceMessagingEventList.Clone: TFhirConformanceMessagingEventList;
begin
  result := TFhirConformanceMessagingEventList(inherited Clone);
end;

function TFhirConformanceMessagingEventList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceMessagingEventList.GetItemN(index: Integer): TFhirConformanceMessagingEvent;
begin
  result := TFhirConformanceMessagingEvent(ObjectByIndex[index]);
end;

function TFhirConformanceMessagingEventList.ItemClass: TFslObjectClass;
begin
  result := TFhirConformanceMessagingEvent;
end;
function TFhirConformanceMessagingEventList.IndexOf(value: TFhirConformanceMessagingEvent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConformanceMessagingEventList.Insert(index: Integer): TFhirConformanceMessagingEvent;
begin
  result := TFhirConformanceMessagingEvent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConformanceMessagingEventList.InsertItem(index: Integer; value: TFhirConformanceMessagingEvent);
begin
  assert(value is TFhirConformanceMessagingEvent);
  Inherited Insert(index, value);
end;

function TFhirConformanceMessagingEventList.Item(index: Integer): TFhirConformanceMessagingEvent;
begin
  result := TFhirConformanceMessagingEvent(ObjectByIndex[index]);
end;

function TFhirConformanceMessagingEventList.Link: TFhirConformanceMessagingEventList;
begin
  result := TFhirConformanceMessagingEventList(inherited Link);
end;

procedure TFhirConformanceMessagingEventList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceMessagingEventList.SetItemByIndex(index: Integer; value: TFhirConformanceMessagingEvent);
begin
  assert(value is TFhirConformanceMessagingEvent);
  FhirConformanceMessagingEvents[index] := value;
end;

procedure TFhirConformanceMessagingEventList.SetItemN(index: Integer; value: TFhirConformanceMessagingEvent);
begin
  assert(value is TFhirConformanceMessagingEvent);
  ObjectByIndex[index] := value;
end;

{ TFhirConformanceDocument }

constructor TFhirConformanceDocument.Create;
begin
  inherited;
end;

destructor TFhirConformanceDocument.Destroy;
begin
  FMode.free;
  FDocumentation.free;
  FProfile.free;
  inherited;
end;

procedure TFhirConformanceDocument.Assign(oSource : TFslObject);
begin
  inherited;
  FMode := TFhirConformanceDocument(oSource).FMode.Link;
  documentationElement := TFhirConformanceDocument(oSource).documentationElement.Clone;
  profile := TFhirConformanceDocument(oSource).profile.Clone;
end;

procedure TFhirConformanceDocument.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'mode') Then
     list.add(self.link, 'mode', FMode.Link);
  if (child_name = 'documentation') Then
     list.add(self.link, 'documentation', FDocumentation.Link);
  if (child_name = 'profile') Then
     list.add(self.link, 'profile', FProfile.Link);
end;

procedure TFhirConformanceDocument.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'mode', 'code', false, TFHIREnum, FMode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', false, TFhirString, FDocumentation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'profile', 'Reference(StructureDefinition)', false, TFhirReference{TFhirStructureDefinition}, FProfile.Link));{2}
end;

function TFhirConformanceDocument.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'mode') then
  begin
    ModeElement := asEnum(SYSTEMS_TFhirDocumentModeEnum, CODES_TFhirDocumentModeEnum, propValue);
    result := propValue
  end
  else if (propName = 'documentation') then
  begin
    DocumentationElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'profile') then
  begin
    Profile := propValue as TFhirReference{TFhirStructureDefinition}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConformanceDocument.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirConformanceDocument.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'documentation') then result := TFhirString.create() {5b}
  else if (propName = 'profile') then result := TFhirReference{TFhirStructureDefinition}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConformanceDocument.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'mode') then result := 'code'
  else if (propName = 'documentation') then result := 'string'
  else if (propName = 'profile') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConformanceDocument.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'mode') then ModeElement := nil
  else if (propName = 'documentation') then DocumentationElement := nil
  else if (propName = 'profile') then ProfileElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConformanceDocument.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'mode') then ModeElement := asEnum(SYSTEMS_TFhirDocumentModeEnum, CODES_TFhirDocumentModeEnum, new){4}
  else if (propName = 'documentation') then DocumentationElement := asString(new){5b}
  else if (propName = 'profile') then ProfileElement := new as TFhirReference{TFhirStructureDefinition}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConformanceDocument.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirConformanceDocument.fhirType : string;
begin
  result := 'document';
end;

function TFhirConformanceDocument.Link : TFhirConformanceDocument;
begin
  result := TFhirConformanceDocument(inherited Link);
end;

function TFhirConformanceDocument.Clone : TFhirConformanceDocument;
begin
  result := TFhirConformanceDocument(inherited Clone);
end;

function TFhirConformanceDocument.equals(other : TObject) : boolean; 
var
  o : TFhirConformanceDocument;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConformanceDocument)) then
    result := false
  else
  begin
    o := TFhirConformanceDocument(other);
    result := compareDeep(modeElement, o.modeElement, true) and compareDeep(documentationElement, o.documentationElement, true) and 
      compareDeep(profileElement, o.profileElement, true);
  end;
end;

function TFhirConformanceDocument.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMode) and isEmptyProp(FDocumentation) and isEmptyProp(FProfile);
end;

procedure TFhirConformanceDocument.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('mode');
  fields.add('documentation');
  fields.add('profile');
end;

{ TFhirConformanceDocument }

Procedure TFhirConformanceDocument.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

Function TFhirConformanceDocument.GetModeST : TFhirDocumentModeEnum;
begin
  if FMode = nil then
    result := TFhirDocumentModeEnum(0)
  else
    result := TFhirDocumentModeEnum(StringArrayIndexOfSensitive(CODES_TFhirDocumentModeEnum, FMode.value));
end;

Procedure TFhirConformanceDocument.SetModeST(value : TFhirDocumentModeEnum);
begin
  if ord(value) = 0 then
    ModeElement := nil
  else
    ModeElement := TFhirEnum.create(SYSTEMS_TFhirDocumentModeEnum[value], CODES_TFhirDocumentModeEnum[value]);
end;

Procedure TFhirConformanceDocument.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirConformanceDocument.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

Procedure TFhirConformanceDocument.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

Procedure TFhirConformanceDocument.SetProfile(value : TFhirReference{TFhirStructureDefinition});
begin
  FProfile.free;
  FProfile := value;
end;

function TFhirConformanceDocument.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FMode.sizeInBytes);
  inc(result, FDocumentation.sizeInBytes);
  inc(result, FProfile.sizeInBytes);
end;

{ TFhirConformanceDocumentListEnumerator }

Constructor TFhirConformanceDocumentListEnumerator.Create(list : TFhirConformanceDocumentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConformanceDocumentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConformanceDocumentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConformanceDocumentListEnumerator.GetCurrent : TFhirConformanceDocument;
begin
  Result := FList[FIndex];
end;

function TFhirConformanceDocumentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConformanceDocumentList }
procedure TFhirConformanceDocumentList.AddItem(value: TFhirConformanceDocument);
begin
  assert(value.ClassName = 'TFhirConformanceDocument', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformanceDocument');
  add(value);
end;

function TFhirConformanceDocumentList.Append: TFhirConformanceDocument;
begin
  result := TFhirConformanceDocument.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConformanceDocumentList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceDocumentList.GetEnumerator : TFhirConformanceDocumentListEnumerator;
begin
  result := TFhirConformanceDocumentListEnumerator.Create(self.link);
end;

function TFhirConformanceDocumentList.Clone: TFhirConformanceDocumentList;
begin
  result := TFhirConformanceDocumentList(inherited Clone);
end;

function TFhirConformanceDocumentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceDocumentList.GetItemN(index: Integer): TFhirConformanceDocument;
begin
  result := TFhirConformanceDocument(ObjectByIndex[index]);
end;

function TFhirConformanceDocumentList.ItemClass: TFslObjectClass;
begin
  result := TFhirConformanceDocument;
end;
function TFhirConformanceDocumentList.IndexOf(value: TFhirConformanceDocument): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConformanceDocumentList.Insert(index: Integer): TFhirConformanceDocument;
begin
  result := TFhirConformanceDocument.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConformanceDocumentList.InsertItem(index: Integer; value: TFhirConformanceDocument);
begin
  assert(value is TFhirConformanceDocument);
  Inherited Insert(index, value);
end;

function TFhirConformanceDocumentList.Item(index: Integer): TFhirConformanceDocument;
begin
  result := TFhirConformanceDocument(ObjectByIndex[index]);
end;

function TFhirConformanceDocumentList.Link: TFhirConformanceDocumentList;
begin
  result := TFhirConformanceDocumentList(inherited Link);
end;

procedure TFhirConformanceDocumentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceDocumentList.SetItemByIndex(index: Integer; value: TFhirConformanceDocument);
begin
  assert(value is TFhirConformanceDocument);
  FhirConformanceDocuments[index] := value;
end;

procedure TFhirConformanceDocumentList.SetItemN(index: Integer; value: TFhirConformanceDocument);
begin
  assert(value is TFhirConformanceDocument);
  ObjectByIndex[index] := value;
end;

{ TFhirConformance }

constructor TFhirConformance.Create;
begin
  inherited;
end;

destructor TFhirConformance.Destroy;
begin
  FUrl.free;
  FVersion.free;
  FName.free;
  FStatus.free;
  FExperimental.free;
  FPublisher.free;
  FContactList.Free;
  FDate.free;
  FDescription.free;
  FRequirements.free;
  FCopyright.free;
  FKind.free;
  FSoftware.free;
  FImplementation_.free;
  FFhirVersion.free;
  FAcceptUnknown.free;
  FFormatList.Free;
  FProfileList.Free;
  FRestList.Free;
  FMessagingList.Free;
  FDocumentList.Free;
  inherited;
end;

function TFhirConformance.GetResourceType : TFhirResourceType;
begin
  result := frtConformance;
end;

procedure TFhirConformance.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirConformance(oSource).urlElement.Clone;
  versionElement := TFhirConformance(oSource).versionElement.Clone;
  nameElement := TFhirConformance(oSource).nameElement.Clone;
  FStatus := TFhirConformance(oSource).FStatus.Link;
  experimentalElement := TFhirConformance(oSource).experimentalElement.Clone;
  publisherElement := TFhirConformance(oSource).publisherElement.Clone;
  if (TFhirConformance(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirConformanceContactList.Create;
    FContactList.Assign(TFhirConformance(oSource).FContactList);
  end;
  dateElement := TFhirConformance(oSource).dateElement.Clone;
  descriptionElement := TFhirConformance(oSource).descriptionElement.Clone;
  requirementsElement := TFhirConformance(oSource).requirementsElement.Clone;
  copyrightElement := TFhirConformance(oSource).copyrightElement.Clone;
  FKind := TFhirConformance(oSource).FKind.Link;
  software := TFhirConformance(oSource).software.Clone;
  implementation_ := TFhirConformance(oSource).implementation_.Clone;
  fhirVersionElement := TFhirConformance(oSource).fhirVersionElement.Clone;
  FAcceptUnknown := TFhirConformance(oSource).FAcceptUnknown.Link;
  if (TFhirConformance(oSource).FFormatList = nil) then
  begin
    FFormatList.free;
    FFormatList := nil;
  end
  else
  begin
    if FFormatList = nil then
      FFormatList := TFhirCodeList.Create;
    FFormatList.Assign(TFhirConformance(oSource).FFormatList);
  end;
  if (TFhirConformance(oSource).FProfileList = nil) then
  begin
    FProfileList.free;
    FProfileList := nil;
  end
  else
  begin
    if FProfileList = nil then
      FProfileList := TFhirReferenceList{TFhirStructureDefinition}.Create;
    FProfileList.Assign(TFhirConformance(oSource).FProfileList);
  end;
  if (TFhirConformance(oSource).FRestList = nil) then
  begin
    FRestList.free;
    FRestList := nil;
  end
  else
  begin
    if FRestList = nil then
      FRestList := TFhirConformanceRestList.Create;
    FRestList.Assign(TFhirConformance(oSource).FRestList);
  end;
  if (TFhirConformance(oSource).FMessagingList = nil) then
  begin
    FMessagingList.free;
    FMessagingList := nil;
  end
  else
  begin
    if FMessagingList = nil then
      FMessagingList := TFhirConformanceMessagingList.Create;
    FMessagingList.Assign(TFhirConformance(oSource).FMessagingList);
  end;
  if (TFhirConformance(oSource).FDocumentList = nil) then
  begin
    FDocumentList.free;
    FDocumentList := nil;
  end
  else
  begin
    if FDocumentList = nil then
      FDocumentList := TFhirConformanceDocumentList.Create;
    FDocumentList.Assign(TFhirConformance(oSource).FDocumentList);
  end;
end;

procedure TFhirConformance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'experimental') Then
     list.add(self.link, 'experimental', FExperimental.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'requirements') Then
     list.add(self.link, 'requirements', FRequirements.Link);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'kind') Then
     list.add(self.link, 'kind', FKind.Link);
  if (child_name = 'software') Then
     list.add(self.link, 'software', FSoftware.Link);
  if (child_name = 'implementation') Then
     list.add(self.link, 'implementation', FImplementation_.Link);
  if (child_name = 'fhirVersion') Then
     list.add(self.link, 'fhirVersion', FFhirVersion.Link);
  if (child_name = 'acceptUnknown') Then
     list.add(self.link, 'acceptUnknown', FAcceptUnknown.Link);
  if (child_name = 'format') Then
    list.addAll(self, 'format', FFormatList);
  if (child_name = 'profile') Then
    list.addAll(self, 'profile', FProfileList);
  if (child_name = 'rest') Then
    list.addAll(self, 'rest', FRestList);
  if (child_name = 'messaging') Then
    list.addAll(self, 'messaging', FMessagingList);
  if (child_name = 'document') Then
    list.addAll(self, 'document', FDocumentList);
end;

procedure TFhirConformance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));{2}
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'experimental', 'boolean', false, TFhirBoolean, FExperimental.Link));{2}
  oList.add(TFHIRProperty.create(self, 'publisher', 'string', false, TFhirString, FPublisher.Link));{2}
  oList.add(TFHIRProperty.create(self, 'contact', '', true, TFhirConformanceContact, FContactList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requirements', 'string', false, TFhirString, FRequirements.Link));{2}
  oList.add(TFHIRProperty.create(self, 'copyright', 'string', false, TFhirString, FCopyright.Link));{2}
  oList.add(TFHIRProperty.create(self, 'kind', 'code', false, TFHIREnum, FKind.Link));{1}
  oList.add(TFHIRProperty.create(self, 'software', '', false, TFhirConformanceSoftware, FSoftware.Link));{2}
  oList.add(TFHIRProperty.create(self, 'implementation', '', false, TFhirConformanceImplementation, FImplementation_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'fhirVersion', 'id', false, TFhirId, FFhirVersion.Link));{2}
  oList.add(TFHIRProperty.create(self, 'acceptUnknown', 'code', false, TFHIREnum, FAcceptUnknown.Link));{1}
  oList.add(TFHIRProperty.create(self, 'format', 'code', true, TFhirCode, FFormatList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'profile', 'Reference(StructureDefinition)', true, TFhirReference{TFhirStructureDefinition}, FProfileList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'rest', '', true, TFhirConformanceRest, FRestList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'messaging', '', true, TFhirConformanceMessaging, FMessagingList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'document', '', true, TFhirConformanceDocument, FDocumentList.Link)){3};
end;

function TFhirConformance.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirConformanceResourceStatusEnum, CODES_TFhirConformanceResourceStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'experimental') then
  begin
    ExperimentalElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    PublisherElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirConformanceContact){2a};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'requirements') then
  begin
    RequirementsElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'kind') then
  begin
    KindElement := asEnum(SYSTEMS_TFhirConformanceStatementKindEnum, CODES_TFhirConformanceStatementKindEnum, propValue);
    result := propValue
  end
  else if (propName = 'software') then
  begin
    Software := propValue as TFhirConformanceSoftware{4b};
    result := propValue;
  end
  else if (propName = 'implementation') then
  begin
    Implementation_ := propValue as TFhirConformanceImplementation{4b};
    result := propValue;
  end
  else if (propName = 'fhirVersion') then
  begin
    FhirVersionElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'acceptUnknown') then
  begin
    AcceptUnknownElement := asEnum(SYSTEMS_TFhirUnknownContentCodeEnum, CODES_TFhirUnknownContentCodeEnum, propValue);
    result := propValue
  end
  else if (propName = 'format') then
  begin
    FormatList.add(asCode(propValue)){2};     result := propValue;

  end
  else if (propName = 'profile') then
  begin
    ProfileList.add(propValue as TFhirReference{TFhirStructureDefinition}){2a};
    result := propValue;
  end
  else if (propName = 'rest') then
  begin
    RestList.add(propValue as TFhirConformanceRest){2a};
    result := propValue;
  end
  else if (propName = 'messaging') then
  begin
    MessagingList.add(propValue as TFhirConformanceMessaging){2a};
    result := propValue;
  end
  else if (propName = 'document') then
  begin
    DocumentList.add(propValue as TFhirConformanceDocument){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirConformance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirConformanceContact){2a}
  else if (propName = 'format') then FormatList.insertItem(index, asCode(propValue)){2}
  else if (propName = 'profile') then ProfileList.insertItem(index, propValue as TFhirReference{TFhirStructureDefinition}){2a}
  else if (propName = 'rest') then RestList.insertItem(index, propValue as TFhirConformanceRest){2a}
  else if (propName = 'messaging') then MessagingList.insertItem(index, propValue as TFhirConformanceMessaging){2a}
  else if (propName = 'document') then DocumentList.insertItem(index, propValue as TFhirConformanceDocument){2a}
  else inherited;
end;

function TFhirConformance.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create() {5b}
  else if (propName = 'version') then result := TFhirString.create() {5b}
  else if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'experimental') then result := TFhirBoolean.create() {5b}
  else if (propName = 'publisher') then result := TFhirString.create() {5b}
  else if (propName = 'contact') then result := ContactList.new(){2}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'requirements') then result := TFhirString.create() {5b}
  else if (propName = 'copyright') then result := TFhirString.create() {5b}
  else if (propName = 'software') then result := TFhirConformanceSoftware.create(){4b}
  else if (propName = 'implementation') then result := TFhirConformanceImplementation.create(){4b}
  else if (propName = 'fhirVersion') then result := TFhirId.create() {5b}
  else if (propName = 'format') then result := FormatList.new(){2}
  else if (propName = 'profile') then result := ProfileList.new(){2}
  else if (propName = 'rest') then result := RestList.new(){2}
  else if (propName = 'messaging') then result := MessagingList.new(){2}
  else if (propName = 'document') then result := DocumentList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConformance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'uri'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'experimental') then result := 'boolean'
  else if (propName = 'publisher') then result := 'string'
  else if (propName = 'contact') then result := ''
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'requirements') then result := 'string'
  else if (propName = 'copyright') then result := 'string'
  else if (propName = 'kind') then result := 'code'
  else if (propName = 'software') then result := ''
  else if (propName = 'implementation') then result := ''
  else if (propName = 'fhirVersion') then result := 'id'
  else if (propName = 'acceptUnknown') then result := 'code'
  else if (propName = 'format') then result := 'code'
  else if (propName = 'profile') then result := 'Reference'
  else if (propName = 'rest') then result := ''
  else if (propName = 'messaging') then result := ''
  else if (propName = 'document') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConformance.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'experimental') then ExperimentalElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value) {2}
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'requirements') then RequirementsElement := nil
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'kind') then KindElement := nil
  else if (propName = 'software') then SoftwareElement := nil
  else if (propName = 'implementation') then Implementation_Element := nil
  else if (propName = 'fhirVersion') then FhirVersionElement := nil
  else if (propName = 'acceptUnknown') then AcceptUnknownElement := nil
  else if (propName = 'format') then deletePropertyValue('format', FormatList, value) {2}
  else if (propName = 'profile') then deletePropertyValue('profile', ProfileList, value) {2}
  else if (propName = 'rest') then deletePropertyValue('rest', RestList, value) {2}
  else if (propName = 'messaging') then deletePropertyValue('messaging', MessagingList, value) {2}
  else if (propName = 'document') then deletePropertyValue('document', DocumentList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConformance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asUri(new){5b}
  else if (propName = 'version') then VersionElement := asString(new){5b}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirConformanceResourceStatusEnum, CODES_TFhirConformanceResourceStatusEnum, new){4}
  else if (propName = 'experimental') then ExperimentalElement := asBoolean(new){5b}
  else if (propName = 'publisher') then PublisherElement := asString(new){5b}
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new) {2}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'requirements') then RequirementsElement := asString(new){5b}
  else if (propName = 'copyright') then CopyrightElement := asString(new){5b}
  else if (propName = 'kind') then KindElement := asEnum(SYSTEMS_TFhirConformanceStatementKindEnum, CODES_TFhirConformanceStatementKindEnum, new){4}
  else if (propName = 'software') then SoftwareElement := new as TFhirConformanceSoftware{4}
  else if (propName = 'implementation') then Implementation_Element := new as TFhirConformanceImplementation{4}
  else if (propName = 'fhirVersion') then FhirVersionElement := asId(new){5b}
  else if (propName = 'acceptUnknown') then AcceptUnknownElement := asEnum(SYSTEMS_TFhirUnknownContentCodeEnum, CODES_TFhirUnknownContentCodeEnum, new){4}
  else if (propName = 'format') then replacePropertyValue('format', FormatList, existing, new) {2}
  else if (propName = 'profile') then replacePropertyValue('profile', ProfileList, existing, new) {2}
  else if (propName = 'rest') then replacePropertyValue('rest', RestList, existing, new) {2}
  else if (propName = 'messaging') then replacePropertyValue('messaging', MessagingList, existing, new) {2}
  else if (propName = 'document') then replacePropertyValue('document', DocumentList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConformance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'contact') then ContactList.move(source, destination){2a}
  else if (propName = 'format') then FormatList.move(source, destination){2}
  else if (propName = 'profile') then ProfileList.move(source, destination){2a}
  else if (propName = 'rest') then RestList.move(source, destination){2a}
  else if (propName = 'messaging') then MessagingList.move(source, destination){2a}
  else if (propName = 'document') then DocumentList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirConformance.fhirType : string;
begin
  result := 'Conformance';
end;

function TFhirConformance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FVersion) and isEmptyProp(FName) and isEmptyProp(FStatus) and isEmptyProp(FExperimental) and isEmptyProp(FPublisher) and isEmptyProp(FcontactList) and isEmptyProp(FDate) and isEmptyProp(FDescription) and isEmptyProp(FRequirements) and isEmptyProp(FCopyright) and isEmptyProp(FKind) and isEmptyProp(FSoftware) and isEmptyProp(FImplementation_) and isEmptyProp(FFhirVersion) and isEmptyProp(FAcceptUnknown) and isEmptyProp(FformatList) and isEmptyProp(FprofileList) and isEmptyProp(FrestList) and isEmptyProp(FmessagingList) and isEmptyProp(FdocumentList);
end;

function TFhirConformance.equals(other : TObject) : boolean; 
var
  o : TFhirConformance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConformance)) then
    result := false
  else
  begin
    o := TFhirConformance(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(versionElement, o.versionElement, true) and 
      compareDeep(nameElement, o.nameElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(experimentalElement, o.experimentalElement, true) and compareDeep(publisherElement, o.publisherElement, true) and 
      compareDeep(contactList, o.contactList, true) and compareDeep(dateElement, o.dateElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(requirementsElement, o.requirementsElement, true) and 
      compareDeep(copyrightElement, o.copyrightElement, true) and compareDeep(kindElement, o.kindElement, true) and 
      compareDeep(softwareElement, o.softwareElement, true) and compareDeep(implementation_Element, o.implementation_Element, true) and 
      compareDeep(fhirVersionElement, o.fhirVersionElement, true) and compareDeep(acceptUnknownElement, o.acceptUnknownElement, true) and 
      compareDeep(formatList, o.formatList, true) and compareDeep(profileList, o.profileList, true) and 
      compareDeep(restList, o.restList, true) and compareDeep(messagingList, o.messagingList, true) and 
      compareDeep(documentList, o.documentList, true);
  end;
end;

function TFhirConformance.Link : TFhirConformance;
begin
  result := TFhirConformance(inherited Link);
end;

function TFhirConformance.Clone : TFhirConformance;
begin
  result := TFhirConformance(inherited Clone);
end;

procedure TFhirConformance.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('url');
  fields.add('version');
  fields.add('name');
  fields.add('status');
  fields.add('experimental');
  fields.add('publisher');
  fields.add('contact');
  fields.add('date');
  fields.add('description');
  fields.add('requirements');
  fields.add('copyright');
  fields.add('kind');
  fields.add('software');
  fields.add('implementation');
  fields.add('fhirVersion');
  fields.add('acceptUnknown');
  fields.add('format');
  fields.add('profile');
  fields.add('rest');
  fields.add('messaging');
  fields.add('document');
end;

{ TFhirConformance }

Procedure TFhirConformance.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirConformance.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

Procedure TFhirConformance.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

Procedure TFhirConformance.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

Function TFhirConformance.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

Procedure TFhirConformance.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

Procedure TFhirConformance.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirConformance.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirConformance.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirConformance.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirConformance.GetStatusST : TFhirConformanceResourceStatusEnum;
begin
  if FStatus = nil then
    result := TFhirConformanceResourceStatusEnum(0)
  else
    result := TFhirConformanceResourceStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirConformanceResourceStatusEnum, FStatus.value));
end;

Procedure TFhirConformance.SetStatusST(value : TFhirConformanceResourceStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirConformanceResourceStatusEnum[value], CODES_TFhirConformanceResourceStatusEnum[value]);
end;

Procedure TFhirConformance.SetExperimental(value : TFhirBoolean);
begin
  FExperimental.free;
  FExperimental := value;
end;

Function TFhirConformance.GetExperimentalST : Boolean;
begin
  if FExperimental = nil then
    result := false
  else
    result := FExperimental.value;
end;

Procedure TFhirConformance.SetExperimentalST(value : Boolean);
begin
  if FExperimental = nil then
    FExperimental := TFhirBoolean.create;
  FExperimental.value := value
end;

Procedure TFhirConformance.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

Function TFhirConformance.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

Procedure TFhirConformance.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

Function TFhirConformance.GetContactList : TFhirConformanceContactList;
begin
  if FContactList = nil then
    FContactList := TFhirConformanceContactList.Create;
  result := FContactList;
end;

Function TFhirConformance.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

Procedure TFhirConformance.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirConformance.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirConformance.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirConformance.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirConformance.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirConformance.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirConformance.SetRequirements(value : TFhirString);
begin
  FRequirements.free;
  FRequirements := value;
end;

Function TFhirConformance.GetRequirementsST : String;
begin
  if FRequirements = nil then
    result := ''
  else
    result := FRequirements.value;
end;

Procedure TFhirConformance.SetRequirementsST(value : String);
begin
  if value <> '' then
  begin
    if FRequirements = nil then
      FRequirements := TFhirString.create;
    FRequirements.value := value
  end
  else if FRequirements <> nil then
    FRequirements.value := '';
end;

Procedure TFhirConformance.SetCopyright(value : TFhirString);
begin
  FCopyright.free;
  FCopyright := value;
end;

Function TFhirConformance.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

Procedure TFhirConformance.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirString.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

Procedure TFhirConformance.SetKind(value : TFhirEnum);
begin
  FKind.free;
  FKind := value;
end;

Function TFhirConformance.GetKindST : TFhirConformanceStatementKindEnum;
begin
  if FKind = nil then
    result := TFhirConformanceStatementKindEnum(0)
  else
    result := TFhirConformanceStatementKindEnum(StringArrayIndexOfSensitive(CODES_TFhirConformanceStatementKindEnum, FKind.value));
end;

Procedure TFhirConformance.SetKindST(value : TFhirConformanceStatementKindEnum);
begin
  if ord(value) = 0 then
    KindElement := nil
  else
    KindElement := TFhirEnum.create(SYSTEMS_TFhirConformanceStatementKindEnum[value], CODES_TFhirConformanceStatementKindEnum[value]);
end;

Procedure TFhirConformance.SetSoftware(value : TFhirConformanceSoftware);
begin
  FSoftware.free;
  FSoftware := value;
end;

Procedure TFhirConformance.SetImplementation_(value : TFhirConformanceImplementation);
begin
  FImplementation_.free;
  FImplementation_ := value;
end;

Procedure TFhirConformance.SetFhirVersion(value : TFhirId);
begin
  FFhirVersion.free;
  FFhirVersion := value;
end;

Function TFhirConformance.GetFhirVersionST : String;
begin
  if FFhirVersion = nil then
    result := ''
  else
    result := FFhirVersion.value;
end;

Procedure TFhirConformance.SetFhirVersionST(value : String);
begin
  if value <> '' then
  begin
    if FFhirVersion = nil then
      FFhirVersion := TFhirId.create;
    FFhirVersion.value := value
  end
  else if FFhirVersion <> nil then
    FFhirVersion.value := '';
end;

Procedure TFhirConformance.SetAcceptUnknown(value : TFhirEnum);
begin
  FAcceptUnknown.free;
  FAcceptUnknown := value;
end;

Function TFhirConformance.GetAcceptUnknownST : TFhirUnknownContentCodeEnum;
begin
  if FAcceptUnknown = nil then
    result := TFhirUnknownContentCodeEnum(0)
  else
    result := TFhirUnknownContentCodeEnum(StringArrayIndexOfSensitive(CODES_TFhirUnknownContentCodeEnum, FAcceptUnknown.value));
end;

Procedure TFhirConformance.SetAcceptUnknownST(value : TFhirUnknownContentCodeEnum);
begin
  if ord(value) = 0 then
    AcceptUnknownElement := nil
  else
    AcceptUnknownElement := TFhirEnum.create(SYSTEMS_TFhirUnknownContentCodeEnum[value], CODES_TFhirUnknownContentCodeEnum[value]);
end;

Function TFhirConformance.GetFormatList : TFhirCodeList;
begin
  if FFormatList = nil then
    FFormatList := TFhirCodeList.Create;
  result := FFormatList;
end;

Function TFhirConformance.GetHasFormatList : boolean;
begin
  result := (FFormatList <> nil) and (FFormatList.count > 0);
end;

Function TFhirConformance.GetProfileList : TFhirReferenceList{TFhirStructureDefinition};
begin
  if FProfileList = nil then
    FProfileList := TFhirReferenceList{TFhirStructureDefinition}.Create;
  result := FProfileList;
end;

Function TFhirConformance.GetHasProfileList : boolean;
begin
  result := (FProfileList <> nil) and (FProfileList.count > 0);
end;

Function TFhirConformance.GetRestList : TFhirConformanceRestList;
begin
  if FRestList = nil then
    FRestList := TFhirConformanceRestList.Create;
  result := FRestList;
end;

Function TFhirConformance.GetHasRestList : boolean;
begin
  result := (FRestList <> nil) and (FRestList.count > 0);
end;

Function TFhirConformance.GetMessagingList : TFhirConformanceMessagingList;
begin
  if FMessagingList = nil then
    FMessagingList := TFhirConformanceMessagingList.Create;
  result := FMessagingList;
end;

Function TFhirConformance.GetHasMessagingList : boolean;
begin
  result := (FMessagingList <> nil) and (FMessagingList.count > 0);
end;

Function TFhirConformance.GetDocumentList : TFhirConformanceDocumentList;
begin
  if FDocumentList = nil then
    FDocumentList := TFhirConformanceDocumentList.Create;
  result := FDocumentList;
end;

Function TFhirConformance.GetHasDocumentList : boolean;
begin
  result := (FDocumentList <> nil) and (FDocumentList.count > 0);
end;

function TFhirConformance.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FUrl.sizeInBytes);
  inc(result, FVersion.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FExperimental.sizeInBytes);
  inc(result, FPublisher.sizeInBytes);
  inc(result, FcontactList.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FRequirements.sizeInBytes);
  inc(result, FCopyright.sizeInBytes);
  inc(result, FKind.sizeInBytes);
  inc(result, FSoftware.sizeInBytes);
  inc(result, FImplementation_.sizeInBytes);
  inc(result, FFhirVersion.sizeInBytes);
  inc(result, FAcceptUnknown.sizeInBytes);
  inc(result, FformatList.sizeInBytes);
  inc(result, FprofileList.sizeInBytes);
  inc(result, FrestList.sizeInBytes);
  inc(result, FmessagingList.sizeInBytes);
  inc(result, FdocumentList.sizeInBytes);
end;

{ TFhirConformanceListEnumerator }

Constructor TFhirConformanceListEnumerator.Create(list : TFhirConformanceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConformanceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConformanceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConformanceListEnumerator.GetCurrent : TFhirConformance;
begin
  Result := FList[FIndex];
end;

function TFhirConformanceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConformanceList }
procedure TFhirConformanceList.AddItem(value: TFhirConformance);
begin
  assert(value.ClassName = 'TFhirConformance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConformance');
  add(value);
end;

function TFhirConformanceList.Append: TFhirConformance;
begin
  result := TFhirConformance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConformanceList.ClearItems;
begin
  Clear;
end;

function TFhirConformanceList.GetEnumerator : TFhirConformanceListEnumerator;
begin
  result := TFhirConformanceListEnumerator.Create(self.link);
end;

function TFhirConformanceList.Clone: TFhirConformanceList;
begin
  result := TFhirConformanceList(inherited Clone);
end;

function TFhirConformanceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConformanceList.GetItemN(index: Integer): TFhirConformance;
begin
  result := TFhirConformance(ObjectByIndex[index]);
end;

function TFhirConformanceList.ItemClass: TFslObjectClass;
begin
  result := TFhirConformance;
end;
function TFhirConformanceList.IndexOf(value: TFhirConformance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConformanceList.Insert(index: Integer): TFhirConformance;
begin
  result := TFhirConformance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConformanceList.InsertItem(index: Integer; value: TFhirConformance);
begin
  assert(value is TFhirConformance);
  Inherited Insert(index, value);
end;

function TFhirConformanceList.Item(index: Integer): TFhirConformance;
begin
  result := TFhirConformance(ObjectByIndex[index]);
end;

function TFhirConformanceList.Link: TFhirConformanceList;
begin
  result := TFhirConformanceList(inherited Link);
end;

procedure TFhirConformanceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConformanceList.SetItemByIndex(index: Integer; value: TFhirConformance);
begin
  assert(value is TFhirConformance);
  FhirConformances[index] := value;
end;

procedure TFhirConformanceList.SetItemN(index: Integer; value: TFhirConformance);
begin
  assert(value is TFhirConformance);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CONFORMANCE}

{$IFDEF FHIR_DATAELEMENT}

{ TFhirDataElementContact }

constructor TFhirDataElementContact.Create;
begin
  inherited;
end;

destructor TFhirDataElementContact.Destroy;
begin
  FName.free;
  FTelecomList.Free;
  inherited;
end;

procedure TFhirDataElementContact.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirDataElementContact(oSource).nameElement.Clone;
  if (TFhirDataElementContact(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirDataElementContact(oSource).FTelecomList);
  end;
end;

procedure TFhirDataElementContact.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
end;

procedure TFhirDataElementContact.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link)){3};
end;

function TFhirDataElementContact.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDataElementContact.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint){2a}
  else inherited;
end;

function TFhirDataElementContact.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'telecom') then result := TelecomList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDataElementContact.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDataElementContact.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDataElementContact.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDataElementContact.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'telecom') then TelecomList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDataElementContact.fhirType : string;
begin
  result := 'contact';
end;

function TFhirDataElementContact.Link : TFhirDataElementContact;
begin
  result := TFhirDataElementContact(inherited Link);
end;

function TFhirDataElementContact.Clone : TFhirDataElementContact;
begin
  result := TFhirDataElementContact(inherited Clone);
end;

function TFhirDataElementContact.equals(other : TObject) : boolean; 
var
  o : TFhirDataElementContact;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDataElementContact)) then
    result := false
  else
  begin
    o := TFhirDataElementContact(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(telecomList, o.telecomList, true);
  end;
end;

function TFhirDataElementContact.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FtelecomList);
end;

procedure TFhirDataElementContact.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('telecom');
end;

{ TFhirDataElementContact }

Procedure TFhirDataElementContact.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirDataElementContact.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirDataElementContact.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Function TFhirDataElementContact.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

Function TFhirDataElementContact.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

function TFhirDataElementContact.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FtelecomList.sizeInBytes);
end;

{ TFhirDataElementContactListEnumerator }

Constructor TFhirDataElementContactListEnumerator.Create(list : TFhirDataElementContactList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDataElementContactListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDataElementContactListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDataElementContactListEnumerator.GetCurrent : TFhirDataElementContact;
begin
  Result := FList[FIndex];
end;

function TFhirDataElementContactListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDataElementContactList }
procedure TFhirDataElementContactList.AddItem(value: TFhirDataElementContact);
begin
  assert(value.ClassName = 'TFhirDataElementContact', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDataElementContact');
  add(value);
end;

function TFhirDataElementContactList.Append: TFhirDataElementContact;
begin
  result := TFhirDataElementContact.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDataElementContactList.ClearItems;
begin
  Clear;
end;

function TFhirDataElementContactList.GetEnumerator : TFhirDataElementContactListEnumerator;
begin
  result := TFhirDataElementContactListEnumerator.Create(self.link);
end;

function TFhirDataElementContactList.Clone: TFhirDataElementContactList;
begin
  result := TFhirDataElementContactList(inherited Clone);
end;

function TFhirDataElementContactList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDataElementContactList.GetItemN(index: Integer): TFhirDataElementContact;
begin
  result := TFhirDataElementContact(ObjectByIndex[index]);
end;

function TFhirDataElementContactList.ItemClass: TFslObjectClass;
begin
  result := TFhirDataElementContact;
end;
function TFhirDataElementContactList.IndexOf(value: TFhirDataElementContact): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDataElementContactList.Insert(index: Integer): TFhirDataElementContact;
begin
  result := TFhirDataElementContact.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDataElementContactList.InsertItem(index: Integer; value: TFhirDataElementContact);
begin
  assert(value is TFhirDataElementContact);
  Inherited Insert(index, value);
end;

function TFhirDataElementContactList.Item(index: Integer): TFhirDataElementContact;
begin
  result := TFhirDataElementContact(ObjectByIndex[index]);
end;

function TFhirDataElementContactList.Link: TFhirDataElementContactList;
begin
  result := TFhirDataElementContactList(inherited Link);
end;

procedure TFhirDataElementContactList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDataElementContactList.SetItemByIndex(index: Integer; value: TFhirDataElementContact);
begin
  assert(value is TFhirDataElementContact);
  FhirDataElementContacts[index] := value;
end;

procedure TFhirDataElementContactList.SetItemN(index: Integer; value: TFhirDataElementContact);
begin
  assert(value is TFhirDataElementContact);
  ObjectByIndex[index] := value;
end;

{ TFhirDataElementMapping }

constructor TFhirDataElementMapping.Create;
begin
  inherited;
end;

destructor TFhirDataElementMapping.Destroy;
begin
  FIdentity.free;
  FUri.free;
  FName.free;
  FComments.free;
  inherited;
end;

procedure TFhirDataElementMapping.Assign(oSource : TFslObject);
begin
  inherited;
  identityElement := TFhirDataElementMapping(oSource).identityElement.Clone;
  uriElement := TFhirDataElementMapping(oSource).uriElement.Clone;
  nameElement := TFhirDataElementMapping(oSource).nameElement.Clone;
  commentsElement := TFhirDataElementMapping(oSource).commentsElement.Clone;
end;

procedure TFhirDataElementMapping.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identity') Then
     list.add(self.link, 'identity', FIdentity.Link);
  if (child_name = 'uri') Then
     list.add(self.link, 'uri', FUri.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'comments') Then
     list.add(self.link, 'comments', FComments.Link);
end;

procedure TFhirDataElementMapping.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identity', 'id', false, TFhirId, FIdentity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'uri', 'uri', false, TFhirUri, FUri.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'comments', 'string', false, TFhirString, FComments.Link));{2}
end;

function TFhirDataElementMapping.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identity') then
  begin
    IdentityElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'uri') then
  begin
    UriElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'comments') then
  begin
    CommentsElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDataElementMapping.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDataElementMapping.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identity') then result := TFhirId.create() {5b}
  else if (propName = 'uri') then result := TFhirUri.create() {5b}
  else if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'comments') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDataElementMapping.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identity') then result := 'id'
  else if (propName = 'uri') then result := 'uri'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'comments') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDataElementMapping.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identity') then IdentityElement := nil
  else if (propName = 'uri') then UriElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'comments') then CommentsElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDataElementMapping.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identity') then IdentityElement := asId(new){5b}
  else if (propName = 'uri') then UriElement := asUri(new){5b}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'comments') then CommentsElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDataElementMapping.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDataElementMapping.fhirType : string;
begin
  result := 'mapping';
end;

function TFhirDataElementMapping.Link : TFhirDataElementMapping;
begin
  result := TFhirDataElementMapping(inherited Link);
end;

function TFhirDataElementMapping.Clone : TFhirDataElementMapping;
begin
  result := TFhirDataElementMapping(inherited Clone);
end;

function TFhirDataElementMapping.equals(other : TObject) : boolean; 
var
  o : TFhirDataElementMapping;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDataElementMapping)) then
    result := false
  else
  begin
    o := TFhirDataElementMapping(other);
    result := compareDeep(identityElement, o.identityElement, true) and compareDeep(uriElement, o.uriElement, true) and 
      compareDeep(nameElement, o.nameElement, true) and compareDeep(commentsElement, o.commentsElement, true);
  end;
end;

function TFhirDataElementMapping.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentity) and isEmptyProp(FUri) and isEmptyProp(FName) and isEmptyProp(FComments);
end;

procedure TFhirDataElementMapping.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identity');
  fields.add('uri');
  fields.add('name');
  fields.add('comments');
end;

{ TFhirDataElementMapping }

Procedure TFhirDataElementMapping.SetIdentity(value : TFhirId);
begin
  FIdentity.free;
  FIdentity := value;
end;

Function TFhirDataElementMapping.GetIdentityST : String;
begin
  if FIdentity = nil then
    result := ''
  else
    result := FIdentity.value;
end;

Procedure TFhirDataElementMapping.SetIdentityST(value : String);
begin
  if value <> '' then
  begin
    if FIdentity = nil then
      FIdentity := TFhirId.create;
    FIdentity.value := value
  end
  else if FIdentity <> nil then
    FIdentity.value := '';
end;

Procedure TFhirDataElementMapping.SetUri(value : TFhirUri);
begin
  FUri.free;
  FUri := value;
end;

Function TFhirDataElementMapping.GetUriST : String;
begin
  if FUri = nil then
    result := ''
  else
    result := FUri.value;
end;

Procedure TFhirDataElementMapping.SetUriST(value : String);
begin
  if value <> '' then
  begin
    if FUri = nil then
      FUri := TFhirUri.create;
    FUri.value := value
  end
  else if FUri <> nil then
    FUri.value := '';
end;

Procedure TFhirDataElementMapping.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirDataElementMapping.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirDataElementMapping.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirDataElementMapping.SetComments(value : TFhirString);
begin
  FComments.free;
  FComments := value;
end;

Function TFhirDataElementMapping.GetCommentsST : String;
begin
  if FComments = nil then
    result := ''
  else
    result := FComments.value;
end;

Procedure TFhirDataElementMapping.SetCommentsST(value : String);
begin
  if value <> '' then
  begin
    if FComments = nil then
      FComments := TFhirString.create;
    FComments.value := value
  end
  else if FComments <> nil then
    FComments.value := '';
end;

function TFhirDataElementMapping.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentity.sizeInBytes);
  inc(result, FUri.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FComments.sizeInBytes);
end;

{ TFhirDataElementMappingListEnumerator }

Constructor TFhirDataElementMappingListEnumerator.Create(list : TFhirDataElementMappingList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDataElementMappingListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDataElementMappingListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDataElementMappingListEnumerator.GetCurrent : TFhirDataElementMapping;
begin
  Result := FList[FIndex];
end;

function TFhirDataElementMappingListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDataElementMappingList }
procedure TFhirDataElementMappingList.AddItem(value: TFhirDataElementMapping);
begin
  assert(value.ClassName = 'TFhirDataElementMapping', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDataElementMapping');
  add(value);
end;

function TFhirDataElementMappingList.Append: TFhirDataElementMapping;
begin
  result := TFhirDataElementMapping.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDataElementMappingList.ClearItems;
begin
  Clear;
end;

function TFhirDataElementMappingList.GetEnumerator : TFhirDataElementMappingListEnumerator;
begin
  result := TFhirDataElementMappingListEnumerator.Create(self.link);
end;

function TFhirDataElementMappingList.Clone: TFhirDataElementMappingList;
begin
  result := TFhirDataElementMappingList(inherited Clone);
end;

function TFhirDataElementMappingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDataElementMappingList.GetItemN(index: Integer): TFhirDataElementMapping;
begin
  result := TFhirDataElementMapping(ObjectByIndex[index]);
end;

function TFhirDataElementMappingList.ItemClass: TFslObjectClass;
begin
  result := TFhirDataElementMapping;
end;
function TFhirDataElementMappingList.IndexOf(value: TFhirDataElementMapping): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDataElementMappingList.Insert(index: Integer): TFhirDataElementMapping;
begin
  result := TFhirDataElementMapping.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDataElementMappingList.InsertItem(index: Integer; value: TFhirDataElementMapping);
begin
  assert(value is TFhirDataElementMapping);
  Inherited Insert(index, value);
end;

function TFhirDataElementMappingList.Item(index: Integer): TFhirDataElementMapping;
begin
  result := TFhirDataElementMapping(ObjectByIndex[index]);
end;

function TFhirDataElementMappingList.Link: TFhirDataElementMappingList;
begin
  result := TFhirDataElementMappingList(inherited Link);
end;

procedure TFhirDataElementMappingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDataElementMappingList.SetItemByIndex(index: Integer; value: TFhirDataElementMapping);
begin
  assert(value is TFhirDataElementMapping);
  FhirDataElementMappings[index] := value;
end;

procedure TFhirDataElementMappingList.SetItemN(index: Integer; value: TFhirDataElementMapping);
begin
  assert(value is TFhirDataElementMapping);
  ObjectByIndex[index] := value;
end;

{ TFhirDataElement }

constructor TFhirDataElement.Create;
begin
  inherited;
end;

destructor TFhirDataElement.Destroy;
begin
  FUrl.free;
  FIdentifierList.Free;
  FVersion.free;
  FName.free;
  FStatus.free;
  FExperimental.free;
  FPublisher.free;
  FContactList.Free;
  FDate.free;
  FUseContextList.Free;
  FCopyright.free;
  FStringency.free;
  FMappingList.Free;
  FElementList.Free;
  inherited;
end;

function TFhirDataElement.GetResourceType : TFhirResourceType;
begin
  result := frtDataElement;
end;

procedure TFhirDataElement.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirDataElement(oSource).urlElement.Clone;
  if (TFhirDataElement(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirDataElement(oSource).FIdentifierList);
  end;
  versionElement := TFhirDataElement(oSource).versionElement.Clone;
  nameElement := TFhirDataElement(oSource).nameElement.Clone;
  FStatus := TFhirDataElement(oSource).FStatus.Link;
  experimentalElement := TFhirDataElement(oSource).experimentalElement.Clone;
  publisherElement := TFhirDataElement(oSource).publisherElement.Clone;
  if (TFhirDataElement(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirDataElementContactList.Create;
    FContactList.Assign(TFhirDataElement(oSource).FContactList);
  end;
  dateElement := TFhirDataElement(oSource).dateElement.Clone;
  if (TFhirDataElement(oSource).FUseContextList = nil) then
  begin
    FUseContextList.free;
    FUseContextList := nil;
  end
  else
  begin
    if FUseContextList = nil then
      FUseContextList := TFhirCodeableConceptList.Create;
    FUseContextList.Assign(TFhirDataElement(oSource).FUseContextList);
  end;
  copyrightElement := TFhirDataElement(oSource).copyrightElement.Clone;
  FStringency := TFhirDataElement(oSource).FStringency.Link;
  if (TFhirDataElement(oSource).FMappingList = nil) then
  begin
    FMappingList.free;
    FMappingList := nil;
  end
  else
  begin
    if FMappingList = nil then
      FMappingList := TFhirDataElementMappingList.Create;
    FMappingList.Assign(TFhirDataElement(oSource).FMappingList);
  end;
  if (TFhirDataElement(oSource).FElementList = nil) then
  begin
    FElementList.free;
    FElementList := nil;
  end
  else
  begin
    if FElementList = nil then
      FElementList := TFhirElementDefinitionList.Create;
    FElementList.Assign(TFhirDataElement(oSource).FElementList);
  end;
end;

procedure TFhirDataElement.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'experimental') Then
     list.add(self.link, 'experimental', FExperimental.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'useContext') Then
    list.addAll(self, 'useContext', FUseContextList);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'stringency') Then
     list.add(self.link, 'stringency', FStringency.Link);
  if (child_name = 'mapping') Then
    list.addAll(self, 'mapping', FMappingList);
  if (child_name = 'element') Then
    list.addAll(self, 'element', FElementList);
end;

procedure TFhirDataElement.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));{2}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'experimental', 'boolean', false, TFhirBoolean, FExperimental.Link));{2}
  oList.add(TFHIRProperty.create(self, 'publisher', 'string', false, TFhirString, FPublisher.Link));{2}
  oList.add(TFHIRProperty.create(self, 'contact', '', true, TFhirDataElementContact, FContactList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'useContext', 'CodeableConcept', true, TFhirCodeableConcept, FUseContextList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'copyright', 'string', false, TFhirString, FCopyright.Link));{2}
  oList.add(TFHIRProperty.create(self, 'stringency', 'code', false, TFHIREnum, FStringency.Link));{1}
  oList.add(TFHIRProperty.create(self, 'mapping', '', true, TFhirDataElementMapping, FMappingList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'element', 'ElementDefinition', true, TFhirElementDefinition, FElementList.Link)){3};
end;

function TFhirDataElement.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirConformanceResourceStatusEnum, CODES_TFhirConformanceResourceStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'experimental') then
  begin
    ExperimentalElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    PublisherElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirDataElementContact){2a};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'useContext') then
  begin
    UseContextList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'stringency') then
  begin
    StringencyElement := asEnum(SYSTEMS_TFhirDataelementStringencyEnum, CODES_TFhirDataelementStringencyEnum, propValue);
    result := propValue
  end
  else if (propName = 'mapping') then
  begin
    MappingList.add(propValue as TFhirDataElementMapping){2a};
    result := propValue;
  end
  else if (propName = 'element') then
  begin
    ElementList.add(propValue as TFhirElementDefinition){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirDataElement.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirDataElementContact){2a}
  else if (propName = 'useContext') then UseContextList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'mapping') then MappingList.insertItem(index, propValue as TFhirDataElementMapping){2a}
  else if (propName = 'element') then ElementList.insertItem(index, propValue as TFhirElementDefinition){2a}
  else inherited;
end;

function TFhirDataElement.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create() {5b}
  else if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'version') then result := TFhirString.create() {5b}
  else if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'experimental') then result := TFhirBoolean.create() {5b}
  else if (propName = 'publisher') then result := TFhirString.create() {5b}
  else if (propName = 'contact') then result := ContactList.new(){2}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'useContext') then result := UseContextList.new(){2}
  else if (propName = 'copyright') then result := TFhirString.create() {5b}
  else if (propName = 'mapping') then result := MappingList.new(){2}
  else if (propName = 'element') then result := ElementList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDataElement.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'uri'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'experimental') then result := 'boolean'
  else if (propName = 'publisher') then result := 'string'
  else if (propName = 'contact') then result := ''
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'useContext') then result := 'CodeableConcept'
  else if (propName = 'copyright') then result := 'string'
  else if (propName = 'stringency') then result := 'code'
  else if (propName = 'mapping') then result := ''
  else if (propName = 'element') then result := 'ElementDefinition'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDataElement.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'experimental') then ExperimentalElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value) {2}
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'useContext') then deletePropertyValue('useContext', UseContextList, value) {2}
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'stringency') then StringencyElement := nil
  else if (propName = 'mapping') then deletePropertyValue('mapping', MappingList, value) {2}
  else if (propName = 'element') then deletePropertyValue('element', ElementList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDataElement.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asUri(new){5b}
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'version') then VersionElement := asString(new){5b}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirConformanceResourceStatusEnum, CODES_TFhirConformanceResourceStatusEnum, new){4}
  else if (propName = 'experimental') then ExperimentalElement := asBoolean(new){5b}
  else if (propName = 'publisher') then PublisherElement := asString(new){5b}
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new) {2}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'useContext') then replacePropertyValue('useContext', UseContextList, existing, new) {2}
  else if (propName = 'copyright') then CopyrightElement := asString(new){5b}
  else if (propName = 'stringency') then StringencyElement := asEnum(SYSTEMS_TFhirDataelementStringencyEnum, CODES_TFhirDataelementStringencyEnum, new){4}
  else if (propName = 'mapping') then replacePropertyValue('mapping', MappingList, existing, new) {2}
  else if (propName = 'element') then replacePropertyValue('element', ElementList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDataElement.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'contact') then ContactList.move(source, destination){2a}
  else if (propName = 'useContext') then UseContextList.move(source, destination){2a}
  else if (propName = 'mapping') then MappingList.move(source, destination){2a}
  else if (propName = 'element') then ElementList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDataElement.fhirType : string;
begin
  result := 'DataElement';
end;

function TFhirDataElement.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FidentifierList) and isEmptyProp(FVersion) and isEmptyProp(FName) and isEmptyProp(FStatus) and isEmptyProp(FExperimental) and isEmptyProp(FPublisher) and isEmptyProp(FcontactList) and isEmptyProp(FDate) and isEmptyProp(FuseContextList) and isEmptyProp(FCopyright) and isEmptyProp(FStringency) and isEmptyProp(FmappingList) and isEmptyProp(FelementList);
end;

function TFhirDataElement.equals(other : TObject) : boolean; 
var
  o : TFhirDataElement;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDataElement)) then
    result := false
  else
  begin
    o := TFhirDataElement(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(identifierList, o.identifierList, true) and 
      compareDeep(versionElement, o.versionElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(experimentalElement, o.experimentalElement, true) and 
      compareDeep(publisherElement, o.publisherElement, true) and compareDeep(contactList, o.contactList, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(useContextList, o.useContextList, true) and 
      compareDeep(copyrightElement, o.copyrightElement, true) and compareDeep(stringencyElement, o.stringencyElement, true) and 
      compareDeep(mappingList, o.mappingList, true) and compareDeep(elementList, o.elementList, true);
  end;
end;

function TFhirDataElement.Link : TFhirDataElement;
begin
  result := TFhirDataElement(inherited Link);
end;

function TFhirDataElement.Clone : TFhirDataElement;
begin
  result := TFhirDataElement(inherited Clone);
end;

procedure TFhirDataElement.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('status');
  fields.add('experimental');
  fields.add('publisher');
  fields.add('contact');
  fields.add('date');
  fields.add('useContext');
  fields.add('copyright');
  fields.add('stringency');
  fields.add('mapping');
  fields.add('element');
end;

{ TFhirDataElement }

Procedure TFhirDataElement.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirDataElement.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

Procedure TFhirDataElement.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

Function TFhirDataElement.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirDataElement.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirDataElement.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

Function TFhirDataElement.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

Procedure TFhirDataElement.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

Procedure TFhirDataElement.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirDataElement.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirDataElement.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirDataElement.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirDataElement.GetStatusST : TFhirConformanceResourceStatusEnum;
begin
  if FStatus = nil then
    result := TFhirConformanceResourceStatusEnum(0)
  else
    result := TFhirConformanceResourceStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirConformanceResourceStatusEnum, FStatus.value));
end;

Procedure TFhirDataElement.SetStatusST(value : TFhirConformanceResourceStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirConformanceResourceStatusEnum[value], CODES_TFhirConformanceResourceStatusEnum[value]);
end;

Procedure TFhirDataElement.SetExperimental(value : TFhirBoolean);
begin
  FExperimental.free;
  FExperimental := value;
end;

Function TFhirDataElement.GetExperimentalST : Boolean;
begin
  if FExperimental = nil then
    result := false
  else
    result := FExperimental.value;
end;

Procedure TFhirDataElement.SetExperimentalST(value : Boolean);
begin
  if FExperimental = nil then
    FExperimental := TFhirBoolean.create;
  FExperimental.value := value
end;

Procedure TFhirDataElement.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

Function TFhirDataElement.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

Procedure TFhirDataElement.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

Function TFhirDataElement.GetContactList : TFhirDataElementContactList;
begin
  if FContactList = nil then
    FContactList := TFhirDataElementContactList.Create;
  result := FContactList;
end;

Function TFhirDataElement.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

Procedure TFhirDataElement.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirDataElement.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirDataElement.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Function TFhirDataElement.GetUseContextList : TFhirCodeableConceptList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirCodeableConceptList.Create;
  result := FUseContextList;
end;

Function TFhirDataElement.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

Procedure TFhirDataElement.SetCopyright(value : TFhirString);
begin
  FCopyright.free;
  FCopyright := value;
end;

Function TFhirDataElement.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

Procedure TFhirDataElement.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirString.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

Procedure TFhirDataElement.SetStringency(value : TFhirEnum);
begin
  FStringency.free;
  FStringency := value;
end;

Function TFhirDataElement.GetStringencyST : TFhirDataelementStringencyEnum;
begin
  if FStringency = nil then
    result := TFhirDataelementStringencyEnum(0)
  else
    result := TFhirDataelementStringencyEnum(StringArrayIndexOfSensitive(CODES_TFhirDataelementStringencyEnum, FStringency.value));
end;

Procedure TFhirDataElement.SetStringencyST(value : TFhirDataelementStringencyEnum);
begin
  if ord(value) = 0 then
    StringencyElement := nil
  else
    StringencyElement := TFhirEnum.create(SYSTEMS_TFhirDataelementStringencyEnum[value], CODES_TFhirDataelementStringencyEnum[value]);
end;

Function TFhirDataElement.GetMappingList : TFhirDataElementMappingList;
begin
  if FMappingList = nil then
    FMappingList := TFhirDataElementMappingList.Create;
  result := FMappingList;
end;

Function TFhirDataElement.GetHasMappingList : boolean;
begin
  result := (FMappingList <> nil) and (FMappingList.count > 0);
end;

Function TFhirDataElement.GetElementList : TFhirElementDefinitionList;
begin
  if FElementList = nil then
    FElementList := TFhirElementDefinitionList.Create;
  result := FElementList;
end;

Function TFhirDataElement.GetHasElementList : boolean;
begin
  result := (FElementList <> nil) and (FElementList.count > 0);
end;

function TFhirDataElement.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FUrl.sizeInBytes);
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FVersion.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FExperimental.sizeInBytes);
  inc(result, FPublisher.sizeInBytes);
  inc(result, FcontactList.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FuseContextList.sizeInBytes);
  inc(result, FCopyright.sizeInBytes);
  inc(result, FStringency.sizeInBytes);
  inc(result, FmappingList.sizeInBytes);
  inc(result, FelementList.sizeInBytes);
end;

{ TFhirDataElementListEnumerator }

Constructor TFhirDataElementListEnumerator.Create(list : TFhirDataElementList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDataElementListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDataElementListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDataElementListEnumerator.GetCurrent : TFhirDataElement;
begin
  Result := FList[FIndex];
end;

function TFhirDataElementListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDataElementList }
procedure TFhirDataElementList.AddItem(value: TFhirDataElement);
begin
  assert(value.ClassName = 'TFhirDataElement', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDataElement');
  add(value);
end;

function TFhirDataElementList.Append: TFhirDataElement;
begin
  result := TFhirDataElement.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDataElementList.ClearItems;
begin
  Clear;
end;

function TFhirDataElementList.GetEnumerator : TFhirDataElementListEnumerator;
begin
  result := TFhirDataElementListEnumerator.Create(self.link);
end;

function TFhirDataElementList.Clone: TFhirDataElementList;
begin
  result := TFhirDataElementList(inherited Clone);
end;

function TFhirDataElementList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDataElementList.GetItemN(index: Integer): TFhirDataElement;
begin
  result := TFhirDataElement(ObjectByIndex[index]);
end;

function TFhirDataElementList.ItemClass: TFslObjectClass;
begin
  result := TFhirDataElement;
end;
function TFhirDataElementList.IndexOf(value: TFhirDataElement): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDataElementList.Insert(index: Integer): TFhirDataElement;
begin
  result := TFhirDataElement.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDataElementList.InsertItem(index: Integer; value: TFhirDataElement);
begin
  assert(value is TFhirDataElement);
  Inherited Insert(index, value);
end;

function TFhirDataElementList.Item(index: Integer): TFhirDataElement;
begin
  result := TFhirDataElement(ObjectByIndex[index]);
end;

function TFhirDataElementList.Link: TFhirDataElementList;
begin
  result := TFhirDataElementList(inherited Link);
end;

procedure TFhirDataElementList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDataElementList.SetItemByIndex(index: Integer; value: TFhirDataElement);
begin
  assert(value is TFhirDataElement);
  FhirDataElements[index] := value;
end;

procedure TFhirDataElementList.SetItemN(index: Integer; value: TFhirDataElement);
begin
  assert(value is TFhirDataElement);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_DATAELEMENT}

{$IFDEF FHIR_IMPLEMENTATIONGUIDE}

{ TFhirImplementationGuideContact }

constructor TFhirImplementationGuideContact.Create;
begin
  inherited;
end;

destructor TFhirImplementationGuideContact.Destroy;
begin
  FName.free;
  FTelecomList.Free;
  inherited;
end;

procedure TFhirImplementationGuideContact.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirImplementationGuideContact(oSource).nameElement.Clone;
  if (TFhirImplementationGuideContact(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirImplementationGuideContact(oSource).FTelecomList);
  end;
end;

procedure TFhirImplementationGuideContact.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
end;

procedure TFhirImplementationGuideContact.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link)){3};
end;

function TFhirImplementationGuideContact.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImplementationGuideContact.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint){2a}
  else inherited;
end;

function TFhirImplementationGuideContact.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'telecom') then result := TelecomList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImplementationGuideContact.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImplementationGuideContact.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImplementationGuideContact.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImplementationGuideContact.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'telecom') then TelecomList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImplementationGuideContact.fhirType : string;
begin
  result := 'contact';
end;

function TFhirImplementationGuideContact.Link : TFhirImplementationGuideContact;
begin
  result := TFhirImplementationGuideContact(inherited Link);
end;

function TFhirImplementationGuideContact.Clone : TFhirImplementationGuideContact;
begin
  result := TFhirImplementationGuideContact(inherited Clone);
end;

function TFhirImplementationGuideContact.equals(other : TObject) : boolean; 
var
  o : TFhirImplementationGuideContact;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImplementationGuideContact)) then
    result := false
  else
  begin
    o := TFhirImplementationGuideContact(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(telecomList, o.telecomList, true);
  end;
end;

function TFhirImplementationGuideContact.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FtelecomList);
end;

procedure TFhirImplementationGuideContact.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('telecom');
end;

{ TFhirImplementationGuideContact }

Procedure TFhirImplementationGuideContact.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirImplementationGuideContact.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirImplementationGuideContact.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Function TFhirImplementationGuideContact.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

Function TFhirImplementationGuideContact.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

function TFhirImplementationGuideContact.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FtelecomList.sizeInBytes);
end;

{ TFhirImplementationGuideContactListEnumerator }

Constructor TFhirImplementationGuideContactListEnumerator.Create(list : TFhirImplementationGuideContactList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImplementationGuideContactListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImplementationGuideContactListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImplementationGuideContactListEnumerator.GetCurrent : TFhirImplementationGuideContact;
begin
  Result := FList[FIndex];
end;

function TFhirImplementationGuideContactListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImplementationGuideContactList }
procedure TFhirImplementationGuideContactList.AddItem(value: TFhirImplementationGuideContact);
begin
  assert(value.ClassName = 'TFhirImplementationGuideContact', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImplementationGuideContact');
  add(value);
end;

function TFhirImplementationGuideContactList.Append: TFhirImplementationGuideContact;
begin
  result := TFhirImplementationGuideContact.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuideContactList.ClearItems;
begin
  Clear;
end;

function TFhirImplementationGuideContactList.GetEnumerator : TFhirImplementationGuideContactListEnumerator;
begin
  result := TFhirImplementationGuideContactListEnumerator.Create(self.link);
end;

function TFhirImplementationGuideContactList.Clone: TFhirImplementationGuideContactList;
begin
  result := TFhirImplementationGuideContactList(inherited Clone);
end;

function TFhirImplementationGuideContactList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImplementationGuideContactList.GetItemN(index: Integer): TFhirImplementationGuideContact;
begin
  result := TFhirImplementationGuideContact(ObjectByIndex[index]);
end;

function TFhirImplementationGuideContactList.ItemClass: TFslObjectClass;
begin
  result := TFhirImplementationGuideContact;
end;
function TFhirImplementationGuideContactList.IndexOf(value: TFhirImplementationGuideContact): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImplementationGuideContactList.Insert(index: Integer): TFhirImplementationGuideContact;
begin
  result := TFhirImplementationGuideContact.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuideContactList.InsertItem(index: Integer; value: TFhirImplementationGuideContact);
begin
  assert(value is TFhirImplementationGuideContact);
  Inherited Insert(index, value);
end;

function TFhirImplementationGuideContactList.Item(index: Integer): TFhirImplementationGuideContact;
begin
  result := TFhirImplementationGuideContact(ObjectByIndex[index]);
end;

function TFhirImplementationGuideContactList.Link: TFhirImplementationGuideContactList;
begin
  result := TFhirImplementationGuideContactList(inherited Link);
end;

procedure TFhirImplementationGuideContactList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImplementationGuideContactList.SetItemByIndex(index: Integer; value: TFhirImplementationGuideContact);
begin
  assert(value is TFhirImplementationGuideContact);
  FhirImplementationGuideContacts[index] := value;
end;

procedure TFhirImplementationGuideContactList.SetItemN(index: Integer; value: TFhirImplementationGuideContact);
begin
  assert(value is TFhirImplementationGuideContact);
  ObjectByIndex[index] := value;
end;

{ TFhirImplementationGuideDependency }

constructor TFhirImplementationGuideDependency.Create;
begin
  inherited;
end;

destructor TFhirImplementationGuideDependency.Destroy;
begin
  FType_.free;
  FUri.free;
  inherited;
end;

procedure TFhirImplementationGuideDependency.Assign(oSource : TFslObject);
begin
  inherited;
  FType_ := TFhirImplementationGuideDependency(oSource).FType_.Link;
  uriElement := TFhirImplementationGuideDependency(oSource).uriElement.Clone;
end;

procedure TFhirImplementationGuideDependency.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'uri') Then
     list.add(self.link, 'uri', FUri.Link);
end;

procedure TFhirImplementationGuideDependency.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'uri', 'uri', false, TFhirUri, FUri.Link));{2}
end;

function TFhirImplementationGuideDependency.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirGuideDependencyTypeEnum, CODES_TFhirGuideDependencyTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'uri') then
  begin
    UriElement := asUri(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImplementationGuideDependency.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirImplementationGuideDependency.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'uri') then result := TFhirUri.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImplementationGuideDependency.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'uri') then result := 'uri'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImplementationGuideDependency.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'uri') then UriElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImplementationGuideDependency.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirGuideDependencyTypeEnum, CODES_TFhirGuideDependencyTypeEnum, new){4}
  else if (propName = 'uri') then UriElement := asUri(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImplementationGuideDependency.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirImplementationGuideDependency.fhirType : string;
begin
  result := 'dependency';
end;

function TFhirImplementationGuideDependency.Link : TFhirImplementationGuideDependency;
begin
  result := TFhirImplementationGuideDependency(inherited Link);
end;

function TFhirImplementationGuideDependency.Clone : TFhirImplementationGuideDependency;
begin
  result := TFhirImplementationGuideDependency(inherited Clone);
end;

function TFhirImplementationGuideDependency.equals(other : TObject) : boolean; 
var
  o : TFhirImplementationGuideDependency;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImplementationGuideDependency)) then
    result := false
  else
  begin
    o := TFhirImplementationGuideDependency(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(uriElement, o.uriElement, true);
  end;
end;

function TFhirImplementationGuideDependency.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FUri);
end;

procedure TFhirImplementationGuideDependency.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('uri');
end;

{ TFhirImplementationGuideDependency }

Procedure TFhirImplementationGuideDependency.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirImplementationGuideDependency.GetType_ST : TFhirGuideDependencyTypeEnum;
begin
  if FType_ = nil then
    result := TFhirGuideDependencyTypeEnum(0)
  else
    result := TFhirGuideDependencyTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirGuideDependencyTypeEnum, FType_.value));
end;

Procedure TFhirImplementationGuideDependency.SetType_ST(value : TFhirGuideDependencyTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirGuideDependencyTypeEnum[value], CODES_TFhirGuideDependencyTypeEnum[value]);
end;

Procedure TFhirImplementationGuideDependency.SetUri(value : TFhirUri);
begin
  FUri.free;
  FUri := value;
end;

Function TFhirImplementationGuideDependency.GetUriST : String;
begin
  if FUri = nil then
    result := ''
  else
    result := FUri.value;
end;

Procedure TFhirImplementationGuideDependency.SetUriST(value : String);
begin
  if value <> '' then
  begin
    if FUri = nil then
      FUri := TFhirUri.create;
    FUri.value := value
  end
  else if FUri <> nil then
    FUri.value := '';
end;

function TFhirImplementationGuideDependency.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FUri.sizeInBytes);
end;

{ TFhirImplementationGuideDependencyListEnumerator }

Constructor TFhirImplementationGuideDependencyListEnumerator.Create(list : TFhirImplementationGuideDependencyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImplementationGuideDependencyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImplementationGuideDependencyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImplementationGuideDependencyListEnumerator.GetCurrent : TFhirImplementationGuideDependency;
begin
  Result := FList[FIndex];
end;

function TFhirImplementationGuideDependencyListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImplementationGuideDependencyList }
procedure TFhirImplementationGuideDependencyList.AddItem(value: TFhirImplementationGuideDependency);
begin
  assert(value.ClassName = 'TFhirImplementationGuideDependency', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImplementationGuideDependency');
  add(value);
end;

function TFhirImplementationGuideDependencyList.Append: TFhirImplementationGuideDependency;
begin
  result := TFhirImplementationGuideDependency.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuideDependencyList.ClearItems;
begin
  Clear;
end;

function TFhirImplementationGuideDependencyList.GetEnumerator : TFhirImplementationGuideDependencyListEnumerator;
begin
  result := TFhirImplementationGuideDependencyListEnumerator.Create(self.link);
end;

function TFhirImplementationGuideDependencyList.Clone: TFhirImplementationGuideDependencyList;
begin
  result := TFhirImplementationGuideDependencyList(inherited Clone);
end;

function TFhirImplementationGuideDependencyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImplementationGuideDependencyList.GetItemN(index: Integer): TFhirImplementationGuideDependency;
begin
  result := TFhirImplementationGuideDependency(ObjectByIndex[index]);
end;

function TFhirImplementationGuideDependencyList.ItemClass: TFslObjectClass;
begin
  result := TFhirImplementationGuideDependency;
end;
function TFhirImplementationGuideDependencyList.IndexOf(value: TFhirImplementationGuideDependency): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImplementationGuideDependencyList.Insert(index: Integer): TFhirImplementationGuideDependency;
begin
  result := TFhirImplementationGuideDependency.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuideDependencyList.InsertItem(index: Integer; value: TFhirImplementationGuideDependency);
begin
  assert(value is TFhirImplementationGuideDependency);
  Inherited Insert(index, value);
end;

function TFhirImplementationGuideDependencyList.Item(index: Integer): TFhirImplementationGuideDependency;
begin
  result := TFhirImplementationGuideDependency(ObjectByIndex[index]);
end;

function TFhirImplementationGuideDependencyList.Link: TFhirImplementationGuideDependencyList;
begin
  result := TFhirImplementationGuideDependencyList(inherited Link);
end;

procedure TFhirImplementationGuideDependencyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImplementationGuideDependencyList.SetItemByIndex(index: Integer; value: TFhirImplementationGuideDependency);
begin
  assert(value is TFhirImplementationGuideDependency);
  FhirImplementationGuideDependencies[index] := value;
end;

procedure TFhirImplementationGuideDependencyList.SetItemN(index: Integer; value: TFhirImplementationGuideDependency);
begin
  assert(value is TFhirImplementationGuideDependency);
  ObjectByIndex[index] := value;
end;

{ TFhirImplementationGuidePackage }

constructor TFhirImplementationGuidePackage.Create;
begin
  inherited;
end;

destructor TFhirImplementationGuidePackage.Destroy;
begin
  FName.free;
  FDescription.free;
  FResourceList.Free;
  inherited;
end;

procedure TFhirImplementationGuidePackage.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirImplementationGuidePackage(oSource).nameElement.Clone;
  descriptionElement := TFhirImplementationGuidePackage(oSource).descriptionElement.Clone;
  if (TFhirImplementationGuidePackage(oSource).FResourceList = nil) then
  begin
    FResourceList.free;
    FResourceList := nil;
  end
  else
  begin
    if FResourceList = nil then
      FResourceList := TFhirImplementationGuidePackageResourceList.Create;
    FResourceList.Assign(TFhirImplementationGuidePackage(oSource).FResourceList);
  end;
end;

procedure TFhirImplementationGuidePackage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'resource') Then
    list.addAll(self, 'resource', FResourceList);
end;

procedure TFhirImplementationGuidePackage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'resource', '', true, TFhirImplementationGuidePackageResource, FResourceList.Link)){3};
end;

function TFhirImplementationGuidePackage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'resource') then
  begin
    ResourceList.add(propValue as TFhirImplementationGuidePackageResource){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImplementationGuidePackage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'resource') then ResourceList.insertItem(index, propValue as TFhirImplementationGuidePackageResource){2a}
  else inherited;
end;

function TFhirImplementationGuidePackage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'resource') then result := ResourceList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImplementationGuidePackage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'resource') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImplementationGuidePackage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'resource') then deletePropertyValue('resource', ResourceList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImplementationGuidePackage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'resource') then replacePropertyValue('resource', ResourceList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImplementationGuidePackage.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'resource') then ResourceList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImplementationGuidePackage.fhirType : string;
begin
  result := 'package';
end;

function TFhirImplementationGuidePackage.Link : TFhirImplementationGuidePackage;
begin
  result := TFhirImplementationGuidePackage(inherited Link);
end;

function TFhirImplementationGuidePackage.Clone : TFhirImplementationGuidePackage;
begin
  result := TFhirImplementationGuidePackage(inherited Clone);
end;

function TFhirImplementationGuidePackage.equals(other : TObject) : boolean; 
var
  o : TFhirImplementationGuidePackage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImplementationGuidePackage)) then
    result := false
  else
  begin
    o := TFhirImplementationGuidePackage(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(resourceList, o.resourceList, true);
  end;
end;

function TFhirImplementationGuidePackage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FDescription) and isEmptyProp(FresourceList);
end;

procedure TFhirImplementationGuidePackage.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('description');
  fields.add('resource');
end;

{ TFhirImplementationGuidePackage }

Procedure TFhirImplementationGuidePackage.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirImplementationGuidePackage.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirImplementationGuidePackage.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirImplementationGuidePackage.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirImplementationGuidePackage.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirImplementationGuidePackage.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Function TFhirImplementationGuidePackage.GetResourceList : TFhirImplementationGuidePackageResourceList;
begin
  if FResourceList = nil then
    FResourceList := TFhirImplementationGuidePackageResourceList.Create;
  result := FResourceList;
end;

Function TFhirImplementationGuidePackage.GetHasResourceList : boolean;
begin
  result := (FResourceList <> nil) and (FResourceList.count > 0);
end;

function TFhirImplementationGuidePackage.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FresourceList.sizeInBytes);
end;

{ TFhirImplementationGuidePackageListEnumerator }

Constructor TFhirImplementationGuidePackageListEnumerator.Create(list : TFhirImplementationGuidePackageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImplementationGuidePackageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImplementationGuidePackageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImplementationGuidePackageListEnumerator.GetCurrent : TFhirImplementationGuidePackage;
begin
  Result := FList[FIndex];
end;

function TFhirImplementationGuidePackageListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImplementationGuidePackageList }
procedure TFhirImplementationGuidePackageList.AddItem(value: TFhirImplementationGuidePackage);
begin
  assert(value.ClassName = 'TFhirImplementationGuidePackage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImplementationGuidePackage');
  add(value);
end;

function TFhirImplementationGuidePackageList.Append: TFhirImplementationGuidePackage;
begin
  result := TFhirImplementationGuidePackage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuidePackageList.ClearItems;
begin
  Clear;
end;

function TFhirImplementationGuidePackageList.GetEnumerator : TFhirImplementationGuidePackageListEnumerator;
begin
  result := TFhirImplementationGuidePackageListEnumerator.Create(self.link);
end;

function TFhirImplementationGuidePackageList.Clone: TFhirImplementationGuidePackageList;
begin
  result := TFhirImplementationGuidePackageList(inherited Clone);
end;

function TFhirImplementationGuidePackageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImplementationGuidePackageList.GetItemN(index: Integer): TFhirImplementationGuidePackage;
begin
  result := TFhirImplementationGuidePackage(ObjectByIndex[index]);
end;

function TFhirImplementationGuidePackageList.ItemClass: TFslObjectClass;
begin
  result := TFhirImplementationGuidePackage;
end;
function TFhirImplementationGuidePackageList.IndexOf(value: TFhirImplementationGuidePackage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImplementationGuidePackageList.Insert(index: Integer): TFhirImplementationGuidePackage;
begin
  result := TFhirImplementationGuidePackage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuidePackageList.InsertItem(index: Integer; value: TFhirImplementationGuidePackage);
begin
  assert(value is TFhirImplementationGuidePackage);
  Inherited Insert(index, value);
end;

function TFhirImplementationGuidePackageList.Item(index: Integer): TFhirImplementationGuidePackage;
begin
  result := TFhirImplementationGuidePackage(ObjectByIndex[index]);
end;

function TFhirImplementationGuidePackageList.Link: TFhirImplementationGuidePackageList;
begin
  result := TFhirImplementationGuidePackageList(inherited Link);
end;

procedure TFhirImplementationGuidePackageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImplementationGuidePackageList.SetItemByIndex(index: Integer; value: TFhirImplementationGuidePackage);
begin
  assert(value is TFhirImplementationGuidePackage);
  FhirImplementationGuidePackages[index] := value;
end;

procedure TFhirImplementationGuidePackageList.SetItemN(index: Integer; value: TFhirImplementationGuidePackage);
begin
  assert(value is TFhirImplementationGuidePackage);
  ObjectByIndex[index] := value;
end;

{ TFhirImplementationGuidePackageResource }

constructor TFhirImplementationGuidePackageResource.Create;
begin
  inherited;
end;

destructor TFhirImplementationGuidePackageResource.Destroy;
begin
  FPurpose.free;
  FName.free;
  FDescription.free;
  FAcronym.free;
  FSource.free;
  FExampleFor.free;
  inherited;
end;

procedure TFhirImplementationGuidePackageResource.Assign(oSource : TFslObject);
begin
  inherited;
  FPurpose := TFhirImplementationGuidePackageResource(oSource).FPurpose.Link;
  nameElement := TFhirImplementationGuidePackageResource(oSource).nameElement.Clone;
  descriptionElement := TFhirImplementationGuidePackageResource(oSource).descriptionElement.Clone;
  acronymElement := TFhirImplementationGuidePackageResource(oSource).acronymElement.Clone;
  source := TFhirImplementationGuidePackageResource(oSource).source.Clone;
  exampleFor := TFhirImplementationGuidePackageResource(oSource).exampleFor.Clone;
end;

procedure TFhirImplementationGuidePackageResource.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'acronym') Then
     list.add(self.link, 'acronym', FAcronym.Link);
  if (child_name = 'source[x]') or (child_name = 'source') Then
     list.add(self.link, 'source[x]', FSource.Link);
  if (child_name = 'exampleFor') Then
     list.add(self.link, 'exampleFor', FExampleFor.Link);
end;

procedure TFhirImplementationGuidePackageResource.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'purpose', 'code', false, TFHIREnum, FPurpose.Link));{1}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'acronym', 'string', false, TFhirString, FAcronym.Link));{2}
  oList.add(TFHIRProperty.create(self, 'source[x]', 'uri|Reference(Any)', false, TFhirType, FSource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'exampleFor', 'Reference(StructureDefinition)', false, TFhirReference{TFhirStructureDefinition}, FExampleFor.Link));{2}
end;

function TFhirImplementationGuidePackageResource.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'purpose') then
  begin
    PurposeElement := asEnum(SYSTEMS_TFhirGuideResourcePurposeEnum, CODES_TFhirGuideResourcePurposeEnum, propValue);
    result := propValue
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'acronym') then
  begin
    AcronymElement := asString(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'source', ['Uri', 'Reference'])) then
  begin
    Source := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'exampleFor') then
  begin
    ExampleFor := propValue as TFhirReference{TFhirStructureDefinition}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImplementationGuidePackageResource.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirImplementationGuidePackageResource.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'acronym') then result := TFhirString.create() {5b}
  else if (isMatchingName(propName, 'source', ['Uri', 'Reference'])) then raise EFHIRException.create('Cannot make property Source'){4x}
  else if (propName = 'exampleFor') then result := TFhirReference{TFhirStructureDefinition}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImplementationGuidePackageResource.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'purpose') then result := 'code'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'acronym') then result := 'string'
  else if (propName = 'source[x]') then result := 'uri|Reference'
  else if (propName = 'exampleFor') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImplementationGuidePackageResource.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'acronym') then AcronymElement := nil
  else if (isMatchingName(propName, 'source', ['Uri', 'Reference'])) then SourceElement := nil{4x}
  else if (propName = 'exampleFor') then ExampleForElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImplementationGuidePackageResource.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'purpose') then PurposeElement := asEnum(SYSTEMS_TFhirGuideResourcePurposeEnum, CODES_TFhirGuideResourcePurposeEnum, new){4}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'acronym') then AcronymElement := asString(new){5b}
  else if (isMatchingName(propName, 'source', ['Uri', 'Reference'])) then SourceElement := new as TFhirType{4x}
  else if (propName = 'exampleFor') then ExampleForElement := new as TFhirReference{TFhirStructureDefinition}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImplementationGuidePackageResource.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirImplementationGuidePackageResource.fhirType : string;
begin
  result := 'resource';
end;

function TFhirImplementationGuidePackageResource.Link : TFhirImplementationGuidePackageResource;
begin
  result := TFhirImplementationGuidePackageResource(inherited Link);
end;

function TFhirImplementationGuidePackageResource.Clone : TFhirImplementationGuidePackageResource;
begin
  result := TFhirImplementationGuidePackageResource(inherited Clone);
end;

function TFhirImplementationGuidePackageResource.equals(other : TObject) : boolean; 
var
  o : TFhirImplementationGuidePackageResource;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImplementationGuidePackageResource)) then
    result := false
  else
  begin
    o := TFhirImplementationGuidePackageResource(other);
    result := compareDeep(purposeElement, o.purposeElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(acronymElement, o.acronymElement, true) and 
      compareDeep(sourceElement, o.sourceElement, true) and compareDeep(exampleForElement, o.exampleForElement, true);
  end;
end;

function TFhirImplementationGuidePackageResource.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPurpose) and isEmptyProp(FName) and isEmptyProp(FDescription) and isEmptyProp(FAcronym) and isEmptyProp(FSource) and isEmptyProp(FExampleFor);
end;

procedure TFhirImplementationGuidePackageResource.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('purpose');
  fields.add('name');
  fields.add('description');
  fields.add('acronym');
  fields.add('source[x]');
  fields.add('exampleFor');
end;

{ TFhirImplementationGuidePackageResource }

Procedure TFhirImplementationGuidePackageResource.SetPurpose(value : TFhirEnum);
begin
  FPurpose.free;
  FPurpose := value;
end;

Function TFhirImplementationGuidePackageResource.GetPurposeST : TFhirGuideResourcePurposeEnum;
begin
  if FPurpose = nil then
    result := TFhirGuideResourcePurposeEnum(0)
  else
    result := TFhirGuideResourcePurposeEnum(StringArrayIndexOfSensitive(CODES_TFhirGuideResourcePurposeEnum, FPurpose.value));
end;

Procedure TFhirImplementationGuidePackageResource.SetPurposeST(value : TFhirGuideResourcePurposeEnum);
begin
  if ord(value) = 0 then
    PurposeElement := nil
  else
    PurposeElement := TFhirEnum.create(SYSTEMS_TFhirGuideResourcePurposeEnum[value], CODES_TFhirGuideResourcePurposeEnum[value]);
end;

Procedure TFhirImplementationGuidePackageResource.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirImplementationGuidePackageResource.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirImplementationGuidePackageResource.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirImplementationGuidePackageResource.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirImplementationGuidePackageResource.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirImplementationGuidePackageResource.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirImplementationGuidePackageResource.SetAcronym(value : TFhirString);
begin
  FAcronym.free;
  FAcronym := value;
end;

Function TFhirImplementationGuidePackageResource.GetAcronymST : String;
begin
  if FAcronym = nil then
    result := ''
  else
    result := FAcronym.value;
end;

Procedure TFhirImplementationGuidePackageResource.SetAcronymST(value : String);
begin
  if value <> '' then
  begin
    if FAcronym = nil then
      FAcronym := TFhirString.create;
    FAcronym.value := value
  end
  else if FAcronym <> nil then
    FAcronym.value := '';
end;

Procedure TFhirImplementationGuidePackageResource.SetSource(value : TFhirType);
begin
  FSource.free;
  FSource := value;
end;

Procedure TFhirImplementationGuidePackageResource.SetExampleFor(value : TFhirReference{TFhirStructureDefinition});
begin
  FExampleFor.free;
  FExampleFor := value;
end;

function TFhirImplementationGuidePackageResource.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FPurpose.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FAcronym.sizeInBytes);
  inc(result, FSource.sizeInBytes);
  inc(result, FExampleFor.sizeInBytes);
end;

{ TFhirImplementationGuidePackageResourceListEnumerator }

Constructor TFhirImplementationGuidePackageResourceListEnumerator.Create(list : TFhirImplementationGuidePackageResourceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImplementationGuidePackageResourceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImplementationGuidePackageResourceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImplementationGuidePackageResourceListEnumerator.GetCurrent : TFhirImplementationGuidePackageResource;
begin
  Result := FList[FIndex];
end;

function TFhirImplementationGuidePackageResourceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImplementationGuidePackageResourceList }
procedure TFhirImplementationGuidePackageResourceList.AddItem(value: TFhirImplementationGuidePackageResource);
begin
  assert(value.ClassName = 'TFhirImplementationGuidePackageResource', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImplementationGuidePackageResource');
  add(value);
end;

function TFhirImplementationGuidePackageResourceList.Append: TFhirImplementationGuidePackageResource;
begin
  result := TFhirImplementationGuidePackageResource.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuidePackageResourceList.ClearItems;
begin
  Clear;
end;

function TFhirImplementationGuidePackageResourceList.GetEnumerator : TFhirImplementationGuidePackageResourceListEnumerator;
begin
  result := TFhirImplementationGuidePackageResourceListEnumerator.Create(self.link);
end;

function TFhirImplementationGuidePackageResourceList.Clone: TFhirImplementationGuidePackageResourceList;
begin
  result := TFhirImplementationGuidePackageResourceList(inherited Clone);
end;

function TFhirImplementationGuidePackageResourceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImplementationGuidePackageResourceList.GetItemN(index: Integer): TFhirImplementationGuidePackageResource;
begin
  result := TFhirImplementationGuidePackageResource(ObjectByIndex[index]);
end;

function TFhirImplementationGuidePackageResourceList.ItemClass: TFslObjectClass;
begin
  result := TFhirImplementationGuidePackageResource;
end;
function TFhirImplementationGuidePackageResourceList.IndexOf(value: TFhirImplementationGuidePackageResource): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImplementationGuidePackageResourceList.Insert(index: Integer): TFhirImplementationGuidePackageResource;
begin
  result := TFhirImplementationGuidePackageResource.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuidePackageResourceList.InsertItem(index: Integer; value: TFhirImplementationGuidePackageResource);
begin
  assert(value is TFhirImplementationGuidePackageResource);
  Inherited Insert(index, value);
end;

function TFhirImplementationGuidePackageResourceList.Item(index: Integer): TFhirImplementationGuidePackageResource;
begin
  result := TFhirImplementationGuidePackageResource(ObjectByIndex[index]);
end;

function TFhirImplementationGuidePackageResourceList.Link: TFhirImplementationGuidePackageResourceList;
begin
  result := TFhirImplementationGuidePackageResourceList(inherited Link);
end;

procedure TFhirImplementationGuidePackageResourceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImplementationGuidePackageResourceList.SetItemByIndex(index: Integer; value: TFhirImplementationGuidePackageResource);
begin
  assert(value is TFhirImplementationGuidePackageResource);
  FhirImplementationGuidePackageResources[index] := value;
end;

procedure TFhirImplementationGuidePackageResourceList.SetItemN(index: Integer; value: TFhirImplementationGuidePackageResource);
begin
  assert(value is TFhirImplementationGuidePackageResource);
  ObjectByIndex[index] := value;
end;

{ TFhirImplementationGuideGlobal }

constructor TFhirImplementationGuideGlobal.Create;
begin
  inherited;
end;

destructor TFhirImplementationGuideGlobal.Destroy;
begin
  FType_.free;
  FProfile.free;
  inherited;
end;

procedure TFhirImplementationGuideGlobal.Assign(oSource : TFslObject);
begin
  inherited;
  FType_ := TFhirImplementationGuideGlobal(oSource).FType_.Link;
  profile := TFhirImplementationGuideGlobal(oSource).profile.Clone;
end;

procedure TFhirImplementationGuideGlobal.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'profile') Then
     list.add(self.link, 'profile', FProfile.Link);
end;

procedure TFhirImplementationGuideGlobal.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'profile', 'Reference(StructureDefinition)', false, TFhirReference{TFhirStructureDefinition}, FProfile.Link));{2}
end;

function TFhirImplementationGuideGlobal.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue);
    result := propValue
  end
  else if (propName = 'profile') then
  begin
    Profile := propValue as TFhirReference{TFhirStructureDefinition}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImplementationGuideGlobal.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirImplementationGuideGlobal.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'profile') then result := TFhirReference{TFhirStructureDefinition}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImplementationGuideGlobal.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'profile') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImplementationGuideGlobal.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'profile') then ProfileElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImplementationGuideGlobal.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, new){4}
  else if (propName = 'profile') then ProfileElement := new as TFhirReference{TFhirStructureDefinition}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImplementationGuideGlobal.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirImplementationGuideGlobal.fhirType : string;
begin
  result := 'global';
end;

function TFhirImplementationGuideGlobal.Link : TFhirImplementationGuideGlobal;
begin
  result := TFhirImplementationGuideGlobal(inherited Link);
end;

function TFhirImplementationGuideGlobal.Clone : TFhirImplementationGuideGlobal;
begin
  result := TFhirImplementationGuideGlobal(inherited Clone);
end;

function TFhirImplementationGuideGlobal.equals(other : TObject) : boolean; 
var
  o : TFhirImplementationGuideGlobal;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImplementationGuideGlobal)) then
    result := false
  else
  begin
    o := TFhirImplementationGuideGlobal(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(profileElement, o.profileElement, true);
  end;
end;

function TFhirImplementationGuideGlobal.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FProfile);
end;

procedure TFhirImplementationGuideGlobal.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('profile');
end;

{ TFhirImplementationGuideGlobal }

Procedure TFhirImplementationGuideGlobal.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirImplementationGuideGlobal.GetType_ST : TFhirResourceTypesEnum;
begin
  if FType_ = nil then
    result := TFhirResourceTypesEnum(0)
  else
    result := TFhirResourceTypesEnum(StringArrayIndexOfSensitive(CODES_TFhirResourceTypesEnum, FType_.value));
end;

Procedure TFhirImplementationGuideGlobal.SetType_ST(value : TFhirResourceTypesEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirResourceTypesEnum[value], CODES_TFhirResourceTypesEnum[value]);
end;

Procedure TFhirImplementationGuideGlobal.SetProfile(value : TFhirReference{TFhirStructureDefinition});
begin
  FProfile.free;
  FProfile := value;
end;

function TFhirImplementationGuideGlobal.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FProfile.sizeInBytes);
end;

{ TFhirImplementationGuideGlobalListEnumerator }

Constructor TFhirImplementationGuideGlobalListEnumerator.Create(list : TFhirImplementationGuideGlobalList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImplementationGuideGlobalListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImplementationGuideGlobalListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImplementationGuideGlobalListEnumerator.GetCurrent : TFhirImplementationGuideGlobal;
begin
  Result := FList[FIndex];
end;

function TFhirImplementationGuideGlobalListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImplementationGuideGlobalList }
procedure TFhirImplementationGuideGlobalList.AddItem(value: TFhirImplementationGuideGlobal);
begin
  assert(value.ClassName = 'TFhirImplementationGuideGlobal', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImplementationGuideGlobal');
  add(value);
end;

function TFhirImplementationGuideGlobalList.Append: TFhirImplementationGuideGlobal;
begin
  result := TFhirImplementationGuideGlobal.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuideGlobalList.ClearItems;
begin
  Clear;
end;

function TFhirImplementationGuideGlobalList.GetEnumerator : TFhirImplementationGuideGlobalListEnumerator;
begin
  result := TFhirImplementationGuideGlobalListEnumerator.Create(self.link);
end;

function TFhirImplementationGuideGlobalList.Clone: TFhirImplementationGuideGlobalList;
begin
  result := TFhirImplementationGuideGlobalList(inherited Clone);
end;

function TFhirImplementationGuideGlobalList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImplementationGuideGlobalList.GetItemN(index: Integer): TFhirImplementationGuideGlobal;
begin
  result := TFhirImplementationGuideGlobal(ObjectByIndex[index]);
end;

function TFhirImplementationGuideGlobalList.ItemClass: TFslObjectClass;
begin
  result := TFhirImplementationGuideGlobal;
end;
function TFhirImplementationGuideGlobalList.IndexOf(value: TFhirImplementationGuideGlobal): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImplementationGuideGlobalList.Insert(index: Integer): TFhirImplementationGuideGlobal;
begin
  result := TFhirImplementationGuideGlobal.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuideGlobalList.InsertItem(index: Integer; value: TFhirImplementationGuideGlobal);
begin
  assert(value is TFhirImplementationGuideGlobal);
  Inherited Insert(index, value);
end;

function TFhirImplementationGuideGlobalList.Item(index: Integer): TFhirImplementationGuideGlobal;
begin
  result := TFhirImplementationGuideGlobal(ObjectByIndex[index]);
end;

function TFhirImplementationGuideGlobalList.Link: TFhirImplementationGuideGlobalList;
begin
  result := TFhirImplementationGuideGlobalList(inherited Link);
end;

procedure TFhirImplementationGuideGlobalList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImplementationGuideGlobalList.SetItemByIndex(index: Integer; value: TFhirImplementationGuideGlobal);
begin
  assert(value is TFhirImplementationGuideGlobal);
  FhirImplementationGuideGlobals[index] := value;
end;

procedure TFhirImplementationGuideGlobalList.SetItemN(index: Integer; value: TFhirImplementationGuideGlobal);
begin
  assert(value is TFhirImplementationGuideGlobal);
  ObjectByIndex[index] := value;
end;

{ TFhirImplementationGuidePage }

constructor TFhirImplementationGuidePage.Create;
begin
  inherited;
end;

destructor TFhirImplementationGuidePage.Destroy;
begin
  FSource.free;
  FName.free;
  FKind.free;
  FType_.Free;
  FPackageList.Free;
  FFormat.free;
  FPageList.Free;
  inherited;
end;

procedure TFhirImplementationGuidePage.Assign(oSource : TFslObject);
begin
  inherited;
  sourceElement := TFhirImplementationGuidePage(oSource).sourceElement.Clone;
  nameElement := TFhirImplementationGuidePage(oSource).nameElement.Clone;
  FKind := TFhirImplementationGuidePage(oSource).FKind.Link;
  if (TFhirImplementationGuidePage(oSource).FType_ = nil) then
  begin
    FType_.free;
    FType_ := nil;
  end
  else
  begin
    FType_ := TFHIREnumList.Create(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum);
    FType_.Assign(TFhirImplementationGuidePage(oSource).FType_);
  end;
  if (TFhirImplementationGuidePage(oSource).FPackageList = nil) then
  begin
    FPackageList.free;
    FPackageList := nil;
  end
  else
  begin
    if FPackageList = nil then
      FPackageList := TFhirStringList.Create;
    FPackageList.Assign(TFhirImplementationGuidePage(oSource).FPackageList);
  end;
  formatElement := TFhirImplementationGuidePage(oSource).formatElement.Clone;
  if (TFhirImplementationGuidePage(oSource).FPageList = nil) then
  begin
    FPageList.free;
    FPageList := nil;
  end
  else
  begin
    if FPageList = nil then
      FPageList := TFhirImplementationGuidePageList.Create;
    FPageList.Assign(TFhirImplementationGuidePage(oSource).FPageList);
  end;
end;

procedure TFhirImplementationGuidePage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'kind') Then
     list.add(self.link, 'kind', FKind.Link);
  if (child_name = 'type') Then
     list.addAll(self, 'type', FType_);
  if (child_name = 'package') Then
    list.addAll(self, 'package', FPackageList);
  if (child_name = 'format') Then
     list.add(self.link, 'format', FFormat.Link);
  if (child_name = 'page') Then
    list.addAll(self, 'page', FPageList);
end;

procedure TFhirImplementationGuidePage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'source', 'uri', false, TFhirUri, FSource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'kind', 'code', false, TFHIREnum, FKind.Link));{1}
  oList.add(TFHIRProperty.create(self, 'type', 'code', true, TFHIREnum, FType_.Link)){3};
  oList.add(TFHIRProperty.create(self, 'package', 'string', true, TFhirString, FPackageList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'format', 'code', false, TFhirCode, FFormat.Link));{2}
  oList.add(TFHIRProperty.create(self, 'page', '@ImplementationGuide.page', true, TFhirImplementationGuidePage, FPageList.Link)){3};
end;

function TFhirImplementationGuidePage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'source') then
  begin
    SourceElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'kind') then
  begin
    KindElement := asEnum(SYSTEMS_TFhirGuidePageKindEnum, CODES_TFhirGuidePageKindEnum, propValue);
    result := propValue
  end
  else if (propName = 'type') then
  begin
    Type_List.add(asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue)); {1}
    result := propValue;
  end
  else if (propName = 'package') then
  begin
    PackageList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'format') then
  begin
    FormatElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'page') then
  begin
    PageList.add(propValue as TFhirImplementationGuidePage){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImplementationGuidePage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'type') then FType_.insertItem(index, asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue)) {1}
  else if (propName = 'package') then PackageList.insertItem(index, asString(propValue)){2}
  else if (propName = 'page') then PageList.insertItem(index, propValue as TFhirImplementationGuidePage){2a}
  else inherited;
end;

function TFhirImplementationGuidePage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'source') then result := TFhirUri.create() {5b}
  else if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'package') then result := PackageList.new(){2}
  else if (propName = 'format') then result := TFhirCode.create() {5b}
  else if (propName = 'page') then result := PageList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImplementationGuidePage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'source') then result := 'uri'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'kind') then result := 'code'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'package') then result := 'string'
  else if (propName = 'format') then result := 'code'
  else if (propName = 'page') then result := '@ImplementationGuide.page'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImplementationGuidePage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'source') then SourceElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'kind') then KindElement := nil
  else if (propName = 'package') then deletePropertyValue('package', PackageList, value) {2}
  else if (propName = 'format') then FormatElement := nil
  else if (propName = 'page') then deletePropertyValue('page', PageList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImplementationGuidePage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'source') then SourceElement := asUri(new){5b}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'kind') then KindElement := asEnum(SYSTEMS_TFhirGuidePageKindEnum, CODES_TFhirGuidePageKindEnum, new){4}
  else if (propName = 'package') then replacePropertyValue('package', PackageList, existing, new) {2}
  else if (propName = 'format') then FormatElement := asCode(new){5b}
  else if (propName = 'page') then replacePropertyValue('page', PageList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImplementationGuidePage.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'type') then FType_.move(source, destination) {1}
  else if (propName = 'package') then PackageList.move(source, destination){2}
  else if (propName = 'page') then PageList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImplementationGuidePage.fhirType : string;
begin
  result := 'page';
end;

function TFhirImplementationGuidePage.Link : TFhirImplementationGuidePage;
begin
  result := TFhirImplementationGuidePage(inherited Link);
end;

function TFhirImplementationGuidePage.Clone : TFhirImplementationGuidePage;
begin
  result := TFhirImplementationGuidePage(inherited Clone);
end;

function TFhirImplementationGuidePage.equals(other : TObject) : boolean; 
var
  o : TFhirImplementationGuidePage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImplementationGuidePage)) then
    result := false
  else
  begin
    o := TFhirImplementationGuidePage(other);
    result := compareDeep(sourceElement, o.sourceElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(kindElement, o.kindElement, true) and compareDeep(type_List, o.type_List, true) and 
      compareDeep(packageList, o.packageList, true) and compareDeep(formatElement, o.formatElement, true) and 
      compareDeep(pageList, o.pageList, true);
  end;
end;

function TFhirImplementationGuidePage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSource) and isEmptyProp(FName) and isEmptyProp(FKind) and isEmptyProp(FType_) and isEmptyProp(FpackageList) and isEmptyProp(FFormat) and isEmptyProp(FpageList);
end;

procedure TFhirImplementationGuidePage.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('source');
  fields.add('name');
  fields.add('kind');
  fields.add('type');
  fields.add('package');
  fields.add('format');
  fields.add('page');
end;

{ TFhirImplementationGuidePage }

Procedure TFhirImplementationGuidePage.SetSource(value : TFhirUri);
begin
  FSource.free;
  FSource := value;
end;

Function TFhirImplementationGuidePage.GetSourceST : String;
begin
  if FSource = nil then
    result := ''
  else
    result := FSource.value;
end;

Procedure TFhirImplementationGuidePage.SetSourceST(value : String);
begin
  if value <> '' then
  begin
    if FSource = nil then
      FSource := TFhirUri.create;
    FSource.value := value
  end
  else if FSource <> nil then
    FSource.value := '';
end;

Procedure TFhirImplementationGuidePage.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirImplementationGuidePage.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirImplementationGuidePage.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirImplementationGuidePage.SetKind(value : TFhirEnum);
begin
  FKind.free;
  FKind := value;
end;

Function TFhirImplementationGuidePage.GetKindST : TFhirGuidePageKindEnum;
begin
  if FKind = nil then
    result := TFhirGuidePageKindEnum(0)
  else
    result := TFhirGuidePageKindEnum(StringArrayIndexOfSensitive(CODES_TFhirGuidePageKindEnum, FKind.value));
end;

Procedure TFhirImplementationGuidePage.SetKindST(value : TFhirGuidePageKindEnum);
begin
  if ord(value) = 0 then
    KindElement := nil
  else
    KindElement := TFhirEnum.create(SYSTEMS_TFhirGuidePageKindEnum[value], CODES_TFhirGuidePageKindEnum[value]);
end;

Function TFhirImplementationGuidePage.GetType_ : TFhirEnumList;
begin
  if FType_ = nil then
    FType_ := TFHIREnumList.Create(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum);
  result := FType_;
end;

Function TFhirImplementationGuidePage.GetHasType_ : boolean;
begin
  result := (FType_ <> nil) and (FType_.count > 0);
end;

Function TFhirImplementationGuidePage.GetPackageList : TFhirStringList;
begin
  if FPackageList = nil then
    FPackageList := TFhirStringList.Create;
  result := FPackageList;
end;

Function TFhirImplementationGuidePage.GetHasPackageList : boolean;
begin
  result := (FPackageList <> nil) and (FPackageList.count > 0);
end;

Procedure TFhirImplementationGuidePage.SetFormat(value : TFhirCode);
begin
  FFormat.free;
  FFormat := value;
end;

Function TFhirImplementationGuidePage.GetFormatST : String;
begin
  if FFormat = nil then
    result := ''
  else
    result := FFormat.value;
end;

Procedure TFhirImplementationGuidePage.SetFormatST(value : String);
begin
  if value <> '' then
  begin
    if FFormat = nil then
      FFormat := TFhirCode.create;
    FFormat.value := value
  end
  else if FFormat <> nil then
    FFormat.value := '';
end;

Function TFhirImplementationGuidePage.GetPageList : TFhirImplementationGuidePageList;
begin
  if FPageList = nil then
    FPageList := TFhirImplementationGuidePageList.Create;
  result := FPageList;
end;

Function TFhirImplementationGuidePage.GetHasPageList : boolean;
begin
  result := (FPageList <> nil) and (FPageList.count > 0);
end;

function TFhirImplementationGuidePage.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSource.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FKind.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FpackageList.sizeInBytes);
  inc(result, FFormat.sizeInBytes);
  inc(result, FpageList.sizeInBytes);
end;

{ TFhirImplementationGuidePageListEnumerator }

Constructor TFhirImplementationGuidePageListEnumerator.Create(list : TFhirImplementationGuidePageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImplementationGuidePageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImplementationGuidePageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImplementationGuidePageListEnumerator.GetCurrent : TFhirImplementationGuidePage;
begin
  Result := FList[FIndex];
end;

function TFhirImplementationGuidePageListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImplementationGuidePageList }
procedure TFhirImplementationGuidePageList.AddItem(value: TFhirImplementationGuidePage);
begin
  assert(value.ClassName = 'TFhirImplementationGuidePage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImplementationGuidePage');
  add(value);
end;

function TFhirImplementationGuidePageList.Append: TFhirImplementationGuidePage;
begin
  result := TFhirImplementationGuidePage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuidePageList.ClearItems;
begin
  Clear;
end;

function TFhirImplementationGuidePageList.GetEnumerator : TFhirImplementationGuidePageListEnumerator;
begin
  result := TFhirImplementationGuidePageListEnumerator.Create(self.link);
end;

function TFhirImplementationGuidePageList.Clone: TFhirImplementationGuidePageList;
begin
  result := TFhirImplementationGuidePageList(inherited Clone);
end;

function TFhirImplementationGuidePageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImplementationGuidePageList.GetItemN(index: Integer): TFhirImplementationGuidePage;
begin
  result := TFhirImplementationGuidePage(ObjectByIndex[index]);
end;

function TFhirImplementationGuidePageList.ItemClass: TFslObjectClass;
begin
  result := TFhirImplementationGuidePage;
end;
function TFhirImplementationGuidePageList.IndexOf(value: TFhirImplementationGuidePage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImplementationGuidePageList.Insert(index: Integer): TFhirImplementationGuidePage;
begin
  result := TFhirImplementationGuidePage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuidePageList.InsertItem(index: Integer; value: TFhirImplementationGuidePage);
begin
  assert(value is TFhirImplementationGuidePage);
  Inherited Insert(index, value);
end;

function TFhirImplementationGuidePageList.Item(index: Integer): TFhirImplementationGuidePage;
begin
  result := TFhirImplementationGuidePage(ObjectByIndex[index]);
end;

function TFhirImplementationGuidePageList.Link: TFhirImplementationGuidePageList;
begin
  result := TFhirImplementationGuidePageList(inherited Link);
end;

procedure TFhirImplementationGuidePageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImplementationGuidePageList.SetItemByIndex(index: Integer; value: TFhirImplementationGuidePage);
begin
  assert(value is TFhirImplementationGuidePage);
  FhirImplementationGuidePages[index] := value;
end;

procedure TFhirImplementationGuidePageList.SetItemN(index: Integer; value: TFhirImplementationGuidePage);
begin
  assert(value is TFhirImplementationGuidePage);
  ObjectByIndex[index] := value;
end;

{ TFhirImplementationGuide }

constructor TFhirImplementationGuide.Create;
begin
  inherited;
end;

destructor TFhirImplementationGuide.Destroy;
begin
  FUrl.free;
  FVersion.free;
  FName.free;
  FStatus.free;
  FExperimental.free;
  FPublisher.free;
  FContactList.Free;
  FDate.free;
  FDescription.free;
  FUseContextList.Free;
  FCopyright.free;
  FFhirVersion.free;
  FDependencyList.Free;
  FPackageList.Free;
  FGlobalList.Free;
  FBinaryList.Free;
  FPage.free;
  inherited;
end;

function TFhirImplementationGuide.GetResourceType : TFhirResourceType;
begin
  result := frtImplementationGuide;
end;

procedure TFhirImplementationGuide.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirImplementationGuide(oSource).urlElement.Clone;
  versionElement := TFhirImplementationGuide(oSource).versionElement.Clone;
  nameElement := TFhirImplementationGuide(oSource).nameElement.Clone;
  FStatus := TFhirImplementationGuide(oSource).FStatus.Link;
  experimentalElement := TFhirImplementationGuide(oSource).experimentalElement.Clone;
  publisherElement := TFhirImplementationGuide(oSource).publisherElement.Clone;
  if (TFhirImplementationGuide(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirImplementationGuideContactList.Create;
    FContactList.Assign(TFhirImplementationGuide(oSource).FContactList);
  end;
  dateElement := TFhirImplementationGuide(oSource).dateElement.Clone;
  descriptionElement := TFhirImplementationGuide(oSource).descriptionElement.Clone;
  if (TFhirImplementationGuide(oSource).FUseContextList = nil) then
  begin
    FUseContextList.free;
    FUseContextList := nil;
  end
  else
  begin
    if FUseContextList = nil then
      FUseContextList := TFhirCodeableConceptList.Create;
    FUseContextList.Assign(TFhirImplementationGuide(oSource).FUseContextList);
  end;
  copyrightElement := TFhirImplementationGuide(oSource).copyrightElement.Clone;
  fhirVersionElement := TFhirImplementationGuide(oSource).fhirVersionElement.Clone;
  if (TFhirImplementationGuide(oSource).FDependencyList = nil) then
  begin
    FDependencyList.free;
    FDependencyList := nil;
  end
  else
  begin
    if FDependencyList = nil then
      FDependencyList := TFhirImplementationGuideDependencyList.Create;
    FDependencyList.Assign(TFhirImplementationGuide(oSource).FDependencyList);
  end;
  if (TFhirImplementationGuide(oSource).FPackageList = nil) then
  begin
    FPackageList.free;
    FPackageList := nil;
  end
  else
  begin
    if FPackageList = nil then
      FPackageList := TFhirImplementationGuidePackageList.Create;
    FPackageList.Assign(TFhirImplementationGuide(oSource).FPackageList);
  end;
  if (TFhirImplementationGuide(oSource).FGlobalList = nil) then
  begin
    FGlobalList.free;
    FGlobalList := nil;
  end
  else
  begin
    if FGlobalList = nil then
      FGlobalList := TFhirImplementationGuideGlobalList.Create;
    FGlobalList.Assign(TFhirImplementationGuide(oSource).FGlobalList);
  end;
  if (TFhirImplementationGuide(oSource).FBinaryList = nil) then
  begin
    FBinaryList.free;
    FBinaryList := nil;
  end
  else
  begin
    if FBinaryList = nil then
      FBinaryList := TFhirUriList.Create;
    FBinaryList.Assign(TFhirImplementationGuide(oSource).FBinaryList);
  end;
  page := TFhirImplementationGuide(oSource).page.Clone;
end;

procedure TFhirImplementationGuide.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'experimental') Then
     list.add(self.link, 'experimental', FExperimental.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'useContext') Then
    list.addAll(self, 'useContext', FUseContextList);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'fhirVersion') Then
     list.add(self.link, 'fhirVersion', FFhirVersion.Link);
  if (child_name = 'dependency') Then
    list.addAll(self, 'dependency', FDependencyList);
  if (child_name = 'package') Then
    list.addAll(self, 'package', FPackageList);
  if (child_name = 'global') Then
    list.addAll(self, 'global', FGlobalList);
  if (child_name = 'binary') Then
    list.addAll(self, 'binary', FBinaryList);
  if (child_name = 'page') Then
     list.add(self.link, 'page', FPage.Link);
end;

procedure TFhirImplementationGuide.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));{2}
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'experimental', 'boolean', false, TFhirBoolean, FExperimental.Link));{2}
  oList.add(TFHIRProperty.create(self, 'publisher', 'string', false, TFhirString, FPublisher.Link));{2}
  oList.add(TFHIRProperty.create(self, 'contact', '', true, TFhirImplementationGuideContact, FContactList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'useContext', 'CodeableConcept', true, TFhirCodeableConcept, FUseContextList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'copyright', 'string', false, TFhirString, FCopyright.Link));{2}
  oList.add(TFHIRProperty.create(self, 'fhirVersion', 'id', false, TFhirId, FFhirVersion.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dependency', '', true, TFhirImplementationGuideDependency, FDependencyList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'package', '', true, TFhirImplementationGuidePackage, FPackageList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'global', '', true, TFhirImplementationGuideGlobal, FGlobalList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'binary', 'uri', true, TFhirUri, FBinaryList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'page', '', false, TFhirImplementationGuidePage, FPage.Link));{2}
end;

function TFhirImplementationGuide.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirConformanceResourceStatusEnum, CODES_TFhirConformanceResourceStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'experimental') then
  begin
    ExperimentalElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    PublisherElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirImplementationGuideContact){2a};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'useContext') then
  begin
    UseContextList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'fhirVersion') then
  begin
    FhirVersionElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'dependency') then
  begin
    DependencyList.add(propValue as TFhirImplementationGuideDependency){2a};
    result := propValue;
  end
  else if (propName = 'package') then
  begin
    PackageList.add(propValue as TFhirImplementationGuidePackage){2a};
    result := propValue;
  end
  else if (propName = 'global') then
  begin
    GlobalList.add(propValue as TFhirImplementationGuideGlobal){2a};
    result := propValue;
  end
  else if (propName = 'binary') then
  begin
    BinaryList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'page') then
  begin
    Page := propValue as TFhirImplementationGuidePage{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirImplementationGuide.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirImplementationGuideContact){2a}
  else if (propName = 'useContext') then UseContextList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'dependency') then DependencyList.insertItem(index, propValue as TFhirImplementationGuideDependency){2a}
  else if (propName = 'package') then PackageList.insertItem(index, propValue as TFhirImplementationGuidePackage){2a}
  else if (propName = 'global') then GlobalList.insertItem(index, propValue as TFhirImplementationGuideGlobal){2a}
  else if (propName = 'binary') then BinaryList.insertItem(index, asUri(propValue)){2}
  else inherited;
end;

function TFhirImplementationGuide.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create() {5b}
  else if (propName = 'version') then result := TFhirString.create() {5b}
  else if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'experimental') then result := TFhirBoolean.create() {5b}
  else if (propName = 'publisher') then result := TFhirString.create() {5b}
  else if (propName = 'contact') then result := ContactList.new(){2}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'useContext') then result := UseContextList.new(){2}
  else if (propName = 'copyright') then result := TFhirString.create() {5b}
  else if (propName = 'fhirVersion') then result := TFhirId.create() {5b}
  else if (propName = 'dependency') then result := DependencyList.new(){2}
  else if (propName = 'package') then result := PackageList.new(){2}
  else if (propName = 'global') then result := GlobalList.new(){2}
  else if (propName = 'binary') then result := BinaryList.new(){2}
  else if (propName = 'page') then result := TFhirImplementationGuidePage.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImplementationGuide.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'uri'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'experimental') then result := 'boolean'
  else if (propName = 'publisher') then result := 'string'
  else if (propName = 'contact') then result := ''
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'useContext') then result := 'CodeableConcept'
  else if (propName = 'copyright') then result := 'string'
  else if (propName = 'fhirVersion') then result := 'id'
  else if (propName = 'dependency') then result := ''
  else if (propName = 'package') then result := ''
  else if (propName = 'global') then result := ''
  else if (propName = 'binary') then result := 'uri'
  else if (propName = 'page') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImplementationGuide.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'experimental') then ExperimentalElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value) {2}
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'useContext') then deletePropertyValue('useContext', UseContextList, value) {2}
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'fhirVersion') then FhirVersionElement := nil
  else if (propName = 'dependency') then deletePropertyValue('dependency', DependencyList, value) {2}
  else if (propName = 'package') then deletePropertyValue('package', PackageList, value) {2}
  else if (propName = 'global') then deletePropertyValue('global', GlobalList, value) {2}
  else if (propName = 'binary') then deletePropertyValue('binary', BinaryList, value) {2}
  else if (propName = 'page') then PageElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImplementationGuide.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asUri(new){5b}
  else if (propName = 'version') then VersionElement := asString(new){5b}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirConformanceResourceStatusEnum, CODES_TFhirConformanceResourceStatusEnum, new){4}
  else if (propName = 'experimental') then ExperimentalElement := asBoolean(new){5b}
  else if (propName = 'publisher') then PublisherElement := asString(new){5b}
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new) {2}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'useContext') then replacePropertyValue('useContext', UseContextList, existing, new) {2}
  else if (propName = 'copyright') then CopyrightElement := asString(new){5b}
  else if (propName = 'fhirVersion') then FhirVersionElement := asId(new){5b}
  else if (propName = 'dependency') then replacePropertyValue('dependency', DependencyList, existing, new) {2}
  else if (propName = 'package') then replacePropertyValue('package', PackageList, existing, new) {2}
  else if (propName = 'global') then replacePropertyValue('global', GlobalList, existing, new) {2}
  else if (propName = 'binary') then replacePropertyValue('binary', BinaryList, existing, new) {2}
  else if (propName = 'page') then PageElement := new as TFhirImplementationGuidePage{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImplementationGuide.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'contact') then ContactList.move(source, destination){2a}
  else if (propName = 'useContext') then UseContextList.move(source, destination){2a}
  else if (propName = 'dependency') then DependencyList.move(source, destination){2a}
  else if (propName = 'package') then PackageList.move(source, destination){2a}
  else if (propName = 'global') then GlobalList.move(source, destination){2a}
  else if (propName = 'binary') then BinaryList.move(source, destination){2}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImplementationGuide.fhirType : string;
begin
  result := 'ImplementationGuide';
end;

function TFhirImplementationGuide.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FVersion) and isEmptyProp(FName) and isEmptyProp(FStatus) and isEmptyProp(FExperimental) and isEmptyProp(FPublisher) and isEmptyProp(FcontactList) and isEmptyProp(FDate) and isEmptyProp(FDescription) and isEmptyProp(FuseContextList) and isEmptyProp(FCopyright) and isEmptyProp(FFhirVersion) and isEmptyProp(FdependencyList) and isEmptyProp(FpackageList) and isEmptyProp(FglobalList) and isEmptyProp(FbinaryList) and isEmptyProp(FPage);
end;

function TFhirImplementationGuide.equals(other : TObject) : boolean; 
var
  o : TFhirImplementationGuide;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImplementationGuide)) then
    result := false
  else
  begin
    o := TFhirImplementationGuide(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(versionElement, o.versionElement, true) and 
      compareDeep(nameElement, o.nameElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(experimentalElement, o.experimentalElement, true) and compareDeep(publisherElement, o.publisherElement, true) and 
      compareDeep(contactList, o.contactList, true) and compareDeep(dateElement, o.dateElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(useContextList, o.useContextList, true) and 
      compareDeep(copyrightElement, o.copyrightElement, true) and compareDeep(fhirVersionElement, o.fhirVersionElement, true) and 
      compareDeep(dependencyList, o.dependencyList, true) and compareDeep(packageList, o.packageList, true) and 
      compareDeep(globalList, o.globalList, true) and compareDeep(binaryList, o.binaryList, true) and 
      compareDeep(pageElement, o.pageElement, true);
  end;
end;

function TFhirImplementationGuide.Link : TFhirImplementationGuide;
begin
  result := TFhirImplementationGuide(inherited Link);
end;

function TFhirImplementationGuide.Clone : TFhirImplementationGuide;
begin
  result := TFhirImplementationGuide(inherited Clone);
end;

procedure TFhirImplementationGuide.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('url');
  fields.add('version');
  fields.add('name');
  fields.add('status');
  fields.add('experimental');
  fields.add('publisher');
  fields.add('contact');
  fields.add('date');
  fields.add('description');
  fields.add('useContext');
  fields.add('copyright');
  fields.add('fhirVersion');
  fields.add('dependency');
  fields.add('package');
  fields.add('global');
  fields.add('binary');
  fields.add('page');
end;

{ TFhirImplementationGuide }

Procedure TFhirImplementationGuide.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirImplementationGuide.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

Procedure TFhirImplementationGuide.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

Procedure TFhirImplementationGuide.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

Function TFhirImplementationGuide.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

Procedure TFhirImplementationGuide.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

Procedure TFhirImplementationGuide.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirImplementationGuide.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirImplementationGuide.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirImplementationGuide.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirImplementationGuide.GetStatusST : TFhirConformanceResourceStatusEnum;
begin
  if FStatus = nil then
    result := TFhirConformanceResourceStatusEnum(0)
  else
    result := TFhirConformanceResourceStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirConformanceResourceStatusEnum, FStatus.value));
end;

Procedure TFhirImplementationGuide.SetStatusST(value : TFhirConformanceResourceStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirConformanceResourceStatusEnum[value], CODES_TFhirConformanceResourceStatusEnum[value]);
end;

Procedure TFhirImplementationGuide.SetExperimental(value : TFhirBoolean);
begin
  FExperimental.free;
  FExperimental := value;
end;

Function TFhirImplementationGuide.GetExperimentalST : Boolean;
begin
  if FExperimental = nil then
    result := false
  else
    result := FExperimental.value;
end;

Procedure TFhirImplementationGuide.SetExperimentalST(value : Boolean);
begin
  if FExperimental = nil then
    FExperimental := TFhirBoolean.create;
  FExperimental.value := value
end;

Procedure TFhirImplementationGuide.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

Function TFhirImplementationGuide.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

Procedure TFhirImplementationGuide.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

Function TFhirImplementationGuide.GetContactList : TFhirImplementationGuideContactList;
begin
  if FContactList = nil then
    FContactList := TFhirImplementationGuideContactList.Create;
  result := FContactList;
end;

Function TFhirImplementationGuide.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

Procedure TFhirImplementationGuide.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirImplementationGuide.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirImplementationGuide.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirImplementationGuide.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirImplementationGuide.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirImplementationGuide.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Function TFhirImplementationGuide.GetUseContextList : TFhirCodeableConceptList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirCodeableConceptList.Create;
  result := FUseContextList;
end;

Function TFhirImplementationGuide.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

Procedure TFhirImplementationGuide.SetCopyright(value : TFhirString);
begin
  FCopyright.free;
  FCopyright := value;
end;

Function TFhirImplementationGuide.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

Procedure TFhirImplementationGuide.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirString.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

Procedure TFhirImplementationGuide.SetFhirVersion(value : TFhirId);
begin
  FFhirVersion.free;
  FFhirVersion := value;
end;

Function TFhirImplementationGuide.GetFhirVersionST : String;
begin
  if FFhirVersion = nil then
    result := ''
  else
    result := FFhirVersion.value;
end;

Procedure TFhirImplementationGuide.SetFhirVersionST(value : String);
begin
  if value <> '' then
  begin
    if FFhirVersion = nil then
      FFhirVersion := TFhirId.create;
    FFhirVersion.value := value
  end
  else if FFhirVersion <> nil then
    FFhirVersion.value := '';
end;

Function TFhirImplementationGuide.GetDependencyList : TFhirImplementationGuideDependencyList;
begin
  if FDependencyList = nil then
    FDependencyList := TFhirImplementationGuideDependencyList.Create;
  result := FDependencyList;
end;

Function TFhirImplementationGuide.GetHasDependencyList : boolean;
begin
  result := (FDependencyList <> nil) and (FDependencyList.count > 0);
end;

Function TFhirImplementationGuide.GetPackageList : TFhirImplementationGuidePackageList;
begin
  if FPackageList = nil then
    FPackageList := TFhirImplementationGuidePackageList.Create;
  result := FPackageList;
end;

Function TFhirImplementationGuide.GetHasPackageList : boolean;
begin
  result := (FPackageList <> nil) and (FPackageList.count > 0);
end;

Function TFhirImplementationGuide.GetGlobalList : TFhirImplementationGuideGlobalList;
begin
  if FGlobalList = nil then
    FGlobalList := TFhirImplementationGuideGlobalList.Create;
  result := FGlobalList;
end;

Function TFhirImplementationGuide.GetHasGlobalList : boolean;
begin
  result := (FGlobalList <> nil) and (FGlobalList.count > 0);
end;

Function TFhirImplementationGuide.GetBinaryList : TFhirUriList;
begin
  if FBinaryList = nil then
    FBinaryList := TFhirUriList.Create;
  result := FBinaryList;
end;

Function TFhirImplementationGuide.GetHasBinaryList : boolean;
begin
  result := (FBinaryList <> nil) and (FBinaryList.count > 0);
end;

Procedure TFhirImplementationGuide.SetPage(value : TFhirImplementationGuidePage);
begin
  FPage.free;
  FPage := value;
end;

function TFhirImplementationGuide.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FUrl.sizeInBytes);
  inc(result, FVersion.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FExperimental.sizeInBytes);
  inc(result, FPublisher.sizeInBytes);
  inc(result, FcontactList.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FuseContextList.sizeInBytes);
  inc(result, FCopyright.sizeInBytes);
  inc(result, FFhirVersion.sizeInBytes);
  inc(result, FdependencyList.sizeInBytes);
  inc(result, FpackageList.sizeInBytes);
  inc(result, FglobalList.sizeInBytes);
  inc(result, FbinaryList.sizeInBytes);
  inc(result, FPage.sizeInBytes);
end;

{ TFhirImplementationGuideListEnumerator }

Constructor TFhirImplementationGuideListEnumerator.Create(list : TFhirImplementationGuideList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImplementationGuideListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImplementationGuideListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImplementationGuideListEnumerator.GetCurrent : TFhirImplementationGuide;
begin
  Result := FList[FIndex];
end;

function TFhirImplementationGuideListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImplementationGuideList }
procedure TFhirImplementationGuideList.AddItem(value: TFhirImplementationGuide);
begin
  assert(value.ClassName = 'TFhirImplementationGuide', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImplementationGuide');
  add(value);
end;

function TFhirImplementationGuideList.Append: TFhirImplementationGuide;
begin
  result := TFhirImplementationGuide.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuideList.ClearItems;
begin
  Clear;
end;

function TFhirImplementationGuideList.GetEnumerator : TFhirImplementationGuideListEnumerator;
begin
  result := TFhirImplementationGuideListEnumerator.Create(self.link);
end;

function TFhirImplementationGuideList.Clone: TFhirImplementationGuideList;
begin
  result := TFhirImplementationGuideList(inherited Clone);
end;

function TFhirImplementationGuideList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImplementationGuideList.GetItemN(index: Integer): TFhirImplementationGuide;
begin
  result := TFhirImplementationGuide(ObjectByIndex[index]);
end;

function TFhirImplementationGuideList.ItemClass: TFslObjectClass;
begin
  result := TFhirImplementationGuide;
end;
function TFhirImplementationGuideList.IndexOf(value: TFhirImplementationGuide): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImplementationGuideList.Insert(index: Integer): TFhirImplementationGuide;
begin
  result := TFhirImplementationGuide.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuideList.InsertItem(index: Integer; value: TFhirImplementationGuide);
begin
  assert(value is TFhirImplementationGuide);
  Inherited Insert(index, value);
end;

function TFhirImplementationGuideList.Item(index: Integer): TFhirImplementationGuide;
begin
  result := TFhirImplementationGuide(ObjectByIndex[index]);
end;

function TFhirImplementationGuideList.Link: TFhirImplementationGuideList;
begin
  result := TFhirImplementationGuideList(inherited Link);
end;

procedure TFhirImplementationGuideList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImplementationGuideList.SetItemByIndex(index: Integer; value: TFhirImplementationGuide);
begin
  assert(value is TFhirImplementationGuide);
  FhirImplementationGuides[index] := value;
end;

procedure TFhirImplementationGuideList.SetItemN(index: Integer; value: TFhirImplementationGuide);
begin
  assert(value is TFhirImplementationGuide);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_IMPLEMENTATIONGUIDE}

{$IFDEF FHIR_NAMINGSYSTEM}

{ TFhirNamingSystemContact }

constructor TFhirNamingSystemContact.Create;
begin
  inherited;
end;

destructor TFhirNamingSystemContact.Destroy;
begin
  FName.free;
  FTelecomList.Free;
  inherited;
end;

procedure TFhirNamingSystemContact.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirNamingSystemContact(oSource).nameElement.Clone;
  if (TFhirNamingSystemContact(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirNamingSystemContact(oSource).FTelecomList);
  end;
end;

procedure TFhirNamingSystemContact.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
end;

procedure TFhirNamingSystemContact.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link)){3};
end;

function TFhirNamingSystemContact.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNamingSystemContact.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint){2a}
  else inherited;
end;

function TFhirNamingSystemContact.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'telecom') then result := TelecomList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirNamingSystemContact.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNamingSystemContact.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNamingSystemContact.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNamingSystemContact.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'telecom') then TelecomList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirNamingSystemContact.fhirType : string;
begin
  result := 'contact';
end;

function TFhirNamingSystemContact.Link : TFhirNamingSystemContact;
begin
  result := TFhirNamingSystemContact(inherited Link);
end;

function TFhirNamingSystemContact.Clone : TFhirNamingSystemContact;
begin
  result := TFhirNamingSystemContact(inherited Clone);
end;

function TFhirNamingSystemContact.equals(other : TObject) : boolean; 
var
  o : TFhirNamingSystemContact;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNamingSystemContact)) then
    result := false
  else
  begin
    o := TFhirNamingSystemContact(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(telecomList, o.telecomList, true);
  end;
end;

function TFhirNamingSystemContact.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FtelecomList);
end;

procedure TFhirNamingSystemContact.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('telecom');
end;

{ TFhirNamingSystemContact }

Procedure TFhirNamingSystemContact.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirNamingSystemContact.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirNamingSystemContact.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Function TFhirNamingSystemContact.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

Function TFhirNamingSystemContact.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

function TFhirNamingSystemContact.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FtelecomList.sizeInBytes);
end;

{ TFhirNamingSystemContactListEnumerator }

Constructor TFhirNamingSystemContactListEnumerator.Create(list : TFhirNamingSystemContactList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNamingSystemContactListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNamingSystemContactListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNamingSystemContactListEnumerator.GetCurrent : TFhirNamingSystemContact;
begin
  Result := FList[FIndex];
end;

function TFhirNamingSystemContactListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirNamingSystemContactList }
procedure TFhirNamingSystemContactList.AddItem(value: TFhirNamingSystemContact);
begin
  assert(value.ClassName = 'TFhirNamingSystemContact', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNamingSystemContact');
  add(value);
end;

function TFhirNamingSystemContactList.Append: TFhirNamingSystemContact;
begin
  result := TFhirNamingSystemContact.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNamingSystemContactList.ClearItems;
begin
  Clear;
end;

function TFhirNamingSystemContactList.GetEnumerator : TFhirNamingSystemContactListEnumerator;
begin
  result := TFhirNamingSystemContactListEnumerator.Create(self.link);
end;

function TFhirNamingSystemContactList.Clone: TFhirNamingSystemContactList;
begin
  result := TFhirNamingSystemContactList(inherited Clone);
end;

function TFhirNamingSystemContactList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNamingSystemContactList.GetItemN(index: Integer): TFhirNamingSystemContact;
begin
  result := TFhirNamingSystemContact(ObjectByIndex[index]);
end;

function TFhirNamingSystemContactList.ItemClass: TFslObjectClass;
begin
  result := TFhirNamingSystemContact;
end;
function TFhirNamingSystemContactList.IndexOf(value: TFhirNamingSystemContact): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNamingSystemContactList.Insert(index: Integer): TFhirNamingSystemContact;
begin
  result := TFhirNamingSystemContact.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNamingSystemContactList.InsertItem(index: Integer; value: TFhirNamingSystemContact);
begin
  assert(value is TFhirNamingSystemContact);
  Inherited Insert(index, value);
end;

function TFhirNamingSystemContactList.Item(index: Integer): TFhirNamingSystemContact;
begin
  result := TFhirNamingSystemContact(ObjectByIndex[index]);
end;

function TFhirNamingSystemContactList.Link: TFhirNamingSystemContactList;
begin
  result := TFhirNamingSystemContactList(inherited Link);
end;

procedure TFhirNamingSystemContactList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNamingSystemContactList.SetItemByIndex(index: Integer; value: TFhirNamingSystemContact);
begin
  assert(value is TFhirNamingSystemContact);
  FhirNamingSystemContacts[index] := value;
end;

procedure TFhirNamingSystemContactList.SetItemN(index: Integer; value: TFhirNamingSystemContact);
begin
  assert(value is TFhirNamingSystemContact);
  ObjectByIndex[index] := value;
end;

{ TFhirNamingSystemUniqueId }

constructor TFhirNamingSystemUniqueId.Create;
begin
  inherited;
end;

destructor TFhirNamingSystemUniqueId.Destroy;
begin
  FType_.free;
  FValue.free;
  FPreferred.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirNamingSystemUniqueId.Assign(oSource : TFslObject);
begin
  inherited;
  FType_ := TFhirNamingSystemUniqueId(oSource).FType_.Link;
  valueElement := TFhirNamingSystemUniqueId(oSource).valueElement.Clone;
  preferredElement := TFhirNamingSystemUniqueId(oSource).preferredElement.Clone;
  period := TFhirNamingSystemUniqueId(oSource).period.Clone;
end;

procedure TFhirNamingSystemUniqueId.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
  if (child_name = 'preferred') Then
     list.add(self.link, 'preferred', FPreferred.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirNamingSystemUniqueId.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'value', 'string', false, TFhirString, FValue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'preferred', 'boolean', false, TFhirBoolean, FPreferred.Link));{2}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
end;

function TFhirNamingSystemUniqueId.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirNamingsystemIdentifierTypeEnum, CODES_TFhirNamingsystemIdentifierTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'value') then
  begin
    ValueElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'preferred') then
  begin
    PreferredElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNamingSystemUniqueId.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirNamingSystemUniqueId.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'value') then result := TFhirString.create() {5b}
  else if (propName = 'preferred') then result := TFhirBoolean.create() {5b}
  else if (propName = 'period') then result := TFhirPeriod.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirNamingSystemUniqueId.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'value') then result := 'string'
  else if (propName = 'preferred') then result := 'boolean'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNamingSystemUniqueId.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'value') then ValueElement := nil
  else if (propName = 'preferred') then PreferredElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNamingSystemUniqueId.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirNamingsystemIdentifierTypeEnum, CODES_TFhirNamingsystemIdentifierTypeEnum, new){4}
  else if (propName = 'value') then ValueElement := asString(new){5b}
  else if (propName = 'preferred') then PreferredElement := asBoolean(new){5b}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNamingSystemUniqueId.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirNamingSystemUniqueId.fhirType : string;
begin
  result := 'uniqueId';
end;

function TFhirNamingSystemUniqueId.Link : TFhirNamingSystemUniqueId;
begin
  result := TFhirNamingSystemUniqueId(inherited Link);
end;

function TFhirNamingSystemUniqueId.Clone : TFhirNamingSystemUniqueId;
begin
  result := TFhirNamingSystemUniqueId(inherited Clone);
end;

function TFhirNamingSystemUniqueId.equals(other : TObject) : boolean; 
var
  o : TFhirNamingSystemUniqueId;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNamingSystemUniqueId)) then
    result := false
  else
  begin
    o := TFhirNamingSystemUniqueId(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true) and 
      compareDeep(preferredElement, o.preferredElement, true) and compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirNamingSystemUniqueId.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue) and isEmptyProp(FPreferred) and isEmptyProp(FPeriod);
end;

procedure TFhirNamingSystemUniqueId.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('value');
  fields.add('preferred');
  fields.add('period');
end;

{ TFhirNamingSystemUniqueId }

Procedure TFhirNamingSystemUniqueId.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirNamingSystemUniqueId.GetType_ST : TFhirNamingsystemIdentifierTypeEnum;
begin
  if FType_ = nil then
    result := TFhirNamingsystemIdentifierTypeEnum(0)
  else
    result := TFhirNamingsystemIdentifierTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirNamingsystemIdentifierTypeEnum, FType_.value));
end;

Procedure TFhirNamingSystemUniqueId.SetType_ST(value : TFhirNamingsystemIdentifierTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirNamingsystemIdentifierTypeEnum[value], CODES_TFhirNamingsystemIdentifierTypeEnum[value]);
end;

Procedure TFhirNamingSystemUniqueId.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirNamingSystemUniqueId.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

Procedure TFhirNamingSystemUniqueId.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

Procedure TFhirNamingSystemUniqueId.SetPreferred(value : TFhirBoolean);
begin
  FPreferred.free;
  FPreferred := value;
end;

Function TFhirNamingSystemUniqueId.GetPreferredST : Boolean;
begin
  if FPreferred = nil then
    result := false
  else
    result := FPreferred.value;
end;

Procedure TFhirNamingSystemUniqueId.SetPreferredST(value : Boolean);
begin
  if FPreferred = nil then
    FPreferred := TFhirBoolean.create;
  FPreferred.value := value
end;

Procedure TFhirNamingSystemUniqueId.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

function TFhirNamingSystemUniqueId.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FValue.sizeInBytes);
  inc(result, FPreferred.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
end;

{ TFhirNamingSystemUniqueIdListEnumerator }

Constructor TFhirNamingSystemUniqueIdListEnumerator.Create(list : TFhirNamingSystemUniqueIdList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNamingSystemUniqueIdListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNamingSystemUniqueIdListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNamingSystemUniqueIdListEnumerator.GetCurrent : TFhirNamingSystemUniqueId;
begin
  Result := FList[FIndex];
end;

function TFhirNamingSystemUniqueIdListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirNamingSystemUniqueIdList }
procedure TFhirNamingSystemUniqueIdList.AddItem(value: TFhirNamingSystemUniqueId);
begin
  assert(value.ClassName = 'TFhirNamingSystemUniqueId', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNamingSystemUniqueId');
  add(value);
end;

function TFhirNamingSystemUniqueIdList.Append: TFhirNamingSystemUniqueId;
begin
  result := TFhirNamingSystemUniqueId.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNamingSystemUniqueIdList.ClearItems;
begin
  Clear;
end;

function TFhirNamingSystemUniqueIdList.GetEnumerator : TFhirNamingSystemUniqueIdListEnumerator;
begin
  result := TFhirNamingSystemUniqueIdListEnumerator.Create(self.link);
end;

function TFhirNamingSystemUniqueIdList.Clone: TFhirNamingSystemUniqueIdList;
begin
  result := TFhirNamingSystemUniqueIdList(inherited Clone);
end;

function TFhirNamingSystemUniqueIdList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNamingSystemUniqueIdList.GetItemN(index: Integer): TFhirNamingSystemUniqueId;
begin
  result := TFhirNamingSystemUniqueId(ObjectByIndex[index]);
end;

function TFhirNamingSystemUniqueIdList.ItemClass: TFslObjectClass;
begin
  result := TFhirNamingSystemUniqueId;
end;
function TFhirNamingSystemUniqueIdList.IndexOf(value: TFhirNamingSystemUniqueId): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNamingSystemUniqueIdList.Insert(index: Integer): TFhirNamingSystemUniqueId;
begin
  result := TFhirNamingSystemUniqueId.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNamingSystemUniqueIdList.InsertItem(index: Integer; value: TFhirNamingSystemUniqueId);
begin
  assert(value is TFhirNamingSystemUniqueId);
  Inherited Insert(index, value);
end;

function TFhirNamingSystemUniqueIdList.Item(index: Integer): TFhirNamingSystemUniqueId;
begin
  result := TFhirNamingSystemUniqueId(ObjectByIndex[index]);
end;

function TFhirNamingSystemUniqueIdList.Link: TFhirNamingSystemUniqueIdList;
begin
  result := TFhirNamingSystemUniqueIdList(inherited Link);
end;

procedure TFhirNamingSystemUniqueIdList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNamingSystemUniqueIdList.SetItemByIndex(index: Integer; value: TFhirNamingSystemUniqueId);
begin
  assert(value is TFhirNamingSystemUniqueId);
  FhirNamingSystemUniqueIds[index] := value;
end;

procedure TFhirNamingSystemUniqueIdList.SetItemN(index: Integer; value: TFhirNamingSystemUniqueId);
begin
  assert(value is TFhirNamingSystemUniqueId);
  ObjectByIndex[index] := value;
end;

{ TFhirNamingSystem }

constructor TFhirNamingSystem.Create;
begin
  inherited;
end;

destructor TFhirNamingSystem.Destroy;
begin
  FName.free;
  FStatus.free;
  FKind.free;
  FPublisher.free;
  FContactList.Free;
  FResponsible.free;
  FDate.free;
  FType_.free;
  FDescription.free;
  FUseContextList.Free;
  FUsage.free;
  FUniqueIdList.Free;
  FReplacedBy.free;
  inherited;
end;

function TFhirNamingSystem.GetResourceType : TFhirResourceType;
begin
  result := frtNamingSystem;
end;

procedure TFhirNamingSystem.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirNamingSystem(oSource).nameElement.Clone;
  FStatus := TFhirNamingSystem(oSource).FStatus.Link;
  FKind := TFhirNamingSystem(oSource).FKind.Link;
  publisherElement := TFhirNamingSystem(oSource).publisherElement.Clone;
  if (TFhirNamingSystem(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirNamingSystemContactList.Create;
    FContactList.Assign(TFhirNamingSystem(oSource).FContactList);
  end;
  responsibleElement := TFhirNamingSystem(oSource).responsibleElement.Clone;
  dateElement := TFhirNamingSystem(oSource).dateElement.Clone;
  type_ := TFhirNamingSystem(oSource).type_.Clone;
  descriptionElement := TFhirNamingSystem(oSource).descriptionElement.Clone;
  if (TFhirNamingSystem(oSource).FUseContextList = nil) then
  begin
    FUseContextList.free;
    FUseContextList := nil;
  end
  else
  begin
    if FUseContextList = nil then
      FUseContextList := TFhirCodeableConceptList.Create;
    FUseContextList.Assign(TFhirNamingSystem(oSource).FUseContextList);
  end;
  usageElement := TFhirNamingSystem(oSource).usageElement.Clone;
  if (TFhirNamingSystem(oSource).FUniqueIdList = nil) then
  begin
    FUniqueIdList.free;
    FUniqueIdList := nil;
  end
  else
  begin
    if FUniqueIdList = nil then
      FUniqueIdList := TFhirNamingSystemUniqueIdList.Create;
    FUniqueIdList.Assign(TFhirNamingSystem(oSource).FUniqueIdList);
  end;
  replacedBy := TFhirNamingSystem(oSource).replacedBy.Clone;
end;

procedure TFhirNamingSystem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'kind') Then
     list.add(self.link, 'kind', FKind.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'responsible') Then
     list.add(self.link, 'responsible', FResponsible.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'useContext') Then
    list.addAll(self, 'useContext', FUseContextList);
  if (child_name = 'usage') Then
     list.add(self.link, 'usage', FUsage.Link);
  if (child_name = 'uniqueId') Then
    list.addAll(self, 'uniqueId', FUniqueIdList);
  if (child_name = 'replacedBy') Then
     list.add(self.link, 'replacedBy', FReplacedBy.Link);
end;

procedure TFhirNamingSystem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'kind', 'code', false, TFHIREnum, FKind.Link));{1}
  oList.add(TFHIRProperty.create(self, 'publisher', 'string', false, TFhirString, FPublisher.Link));{2}
  oList.add(TFHIRProperty.create(self, 'contact', '', true, TFhirNamingSystemContact, FContactList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'responsible', 'string', false, TFhirString, FResponsible.Link));{2}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'useContext', 'CodeableConcept', true, TFhirCodeableConcept, FUseContextList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'usage', 'string', false, TFhirString, FUsage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'uniqueId', '', true, TFhirNamingSystemUniqueId, FUniqueIdList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'replacedBy', 'Reference(NamingSystem)', false, TFhirReference{TFhirNamingSystem}, FReplacedBy.Link));{2}
end;

function TFhirNamingSystem.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirConformanceResourceStatusEnum, CODES_TFhirConformanceResourceStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'kind') then
  begin
    KindElement := asEnum(SYSTEMS_TFhirNamingsystemTypeEnum, CODES_TFhirNamingsystemTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'publisher') then
  begin
    PublisherElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirNamingSystemContact){2a};
    result := propValue;
  end
  else if (propName = 'responsible') then
  begin
    ResponsibleElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'useContext') then
  begin
    UseContextList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'usage') then
  begin
    UsageElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'uniqueId') then
  begin
    UniqueIdList.add(propValue as TFhirNamingSystemUniqueId){2a};
    result := propValue;
  end
  else if (propName = 'replacedBy') then
  begin
    ReplacedBy := propValue as TFhirReference{TFhirNamingSystem}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirNamingSystem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirNamingSystemContact){2a}
  else if (propName = 'useContext') then UseContextList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'uniqueId') then UniqueIdList.insertItem(index, propValue as TFhirNamingSystemUniqueId){2a}
  else inherited;
end;

function TFhirNamingSystem.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'publisher') then result := TFhirString.create() {5b}
  else if (propName = 'contact') then result := ContactList.new(){2}
  else if (propName = 'responsible') then result := TFhirString.create() {5b}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'useContext') then result := UseContextList.new(){2}
  else if (propName = 'usage') then result := TFhirString.create() {5b}
  else if (propName = 'uniqueId') then result := UniqueIdList.new(){2}
  else if (propName = 'replacedBy') then result := TFhirReference{TFhirNamingSystem}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirNamingSystem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'kind') then result := 'code'
  else if (propName = 'publisher') then result := 'string'
  else if (propName = 'contact') then result := ''
  else if (propName = 'responsible') then result := 'string'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'useContext') then result := 'CodeableConcept'
  else if (propName = 'usage') then result := 'string'
  else if (propName = 'uniqueId') then result := ''
  else if (propName = 'replacedBy') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNamingSystem.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'kind') then KindElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value) {2}
  else if (propName = 'responsible') then ResponsibleElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'useContext') then deletePropertyValue('useContext', UseContextList, value) {2}
  else if (propName = 'usage') then UsageElement := nil
  else if (propName = 'uniqueId') then deletePropertyValue('uniqueId', UniqueIdList, value) {2}
  else if (propName = 'replacedBy') then ReplacedByElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNamingSystem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirConformanceResourceStatusEnum, CODES_TFhirConformanceResourceStatusEnum, new){4}
  else if (propName = 'kind') then KindElement := asEnum(SYSTEMS_TFhirNamingsystemTypeEnum, CODES_TFhirNamingsystemTypeEnum, new){4}
  else if (propName = 'publisher') then PublisherElement := asString(new){5b}
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new) {2}
  else if (propName = 'responsible') then ResponsibleElement := asString(new){5b}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'useContext') then replacePropertyValue('useContext', UseContextList, existing, new) {2}
  else if (propName = 'usage') then UsageElement := asString(new){5b}
  else if (propName = 'uniqueId') then replacePropertyValue('uniqueId', UniqueIdList, existing, new) {2}
  else if (propName = 'replacedBy') then ReplacedByElement := new as TFhirReference{TFhirNamingSystem}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNamingSystem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'contact') then ContactList.move(source, destination){2a}
  else if (propName = 'useContext') then UseContextList.move(source, destination){2a}
  else if (propName = 'uniqueId') then UniqueIdList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirNamingSystem.fhirType : string;
begin
  result := 'NamingSystem';
end;

function TFhirNamingSystem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FStatus) and isEmptyProp(FKind) and isEmptyProp(FPublisher) and isEmptyProp(FcontactList) and isEmptyProp(FResponsible) and isEmptyProp(FDate) and isEmptyProp(FType_) and isEmptyProp(FDescription) and isEmptyProp(FuseContextList) and isEmptyProp(FUsage) and isEmptyProp(FuniqueIdList) and isEmptyProp(FReplacedBy);
end;

function TFhirNamingSystem.equals(other : TObject) : boolean; 
var
  o : TFhirNamingSystem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNamingSystem)) then
    result := false
  else
  begin
    o := TFhirNamingSystem(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(kindElement, o.kindElement, true) and compareDeep(publisherElement, o.publisherElement, true) and 
      compareDeep(contactList, o.contactList, true) and compareDeep(responsibleElement, o.responsibleElement, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(useContextList, o.useContextList, true) and 
      compareDeep(usageElement, o.usageElement, true) and compareDeep(uniqueIdList, o.uniqueIdList, true) and 
      compareDeep(replacedByElement, o.replacedByElement, true);
  end;
end;

function TFhirNamingSystem.Link : TFhirNamingSystem;
begin
  result := TFhirNamingSystem(inherited Link);
end;

function TFhirNamingSystem.Clone : TFhirNamingSystem;
begin
  result := TFhirNamingSystem(inherited Clone);
end;

procedure TFhirNamingSystem.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('name');
  fields.add('status');
  fields.add('kind');
  fields.add('publisher');
  fields.add('contact');
  fields.add('responsible');
  fields.add('date');
  fields.add('type');
  fields.add('description');
  fields.add('useContext');
  fields.add('usage');
  fields.add('uniqueId');
  fields.add('replacedBy');
end;

{ TFhirNamingSystem }

Procedure TFhirNamingSystem.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirNamingSystem.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirNamingSystem.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirNamingSystem.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirNamingSystem.GetStatusST : TFhirConformanceResourceStatusEnum;
begin
  if FStatus = nil then
    result := TFhirConformanceResourceStatusEnum(0)
  else
    result := TFhirConformanceResourceStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirConformanceResourceStatusEnum, FStatus.value));
end;

Procedure TFhirNamingSystem.SetStatusST(value : TFhirConformanceResourceStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirConformanceResourceStatusEnum[value], CODES_TFhirConformanceResourceStatusEnum[value]);
end;

Procedure TFhirNamingSystem.SetKind(value : TFhirEnum);
begin
  FKind.free;
  FKind := value;
end;

Function TFhirNamingSystem.GetKindST : TFhirNamingsystemTypeEnum;
begin
  if FKind = nil then
    result := TFhirNamingsystemTypeEnum(0)
  else
    result := TFhirNamingsystemTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirNamingsystemTypeEnum, FKind.value));
end;

Procedure TFhirNamingSystem.SetKindST(value : TFhirNamingsystemTypeEnum);
begin
  if ord(value) = 0 then
    KindElement := nil
  else
    KindElement := TFhirEnum.create(SYSTEMS_TFhirNamingsystemTypeEnum[value], CODES_TFhirNamingsystemTypeEnum[value]);
end;

Procedure TFhirNamingSystem.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

Function TFhirNamingSystem.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

Procedure TFhirNamingSystem.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

Function TFhirNamingSystem.GetContactList : TFhirNamingSystemContactList;
begin
  if FContactList = nil then
    FContactList := TFhirNamingSystemContactList.Create;
  result := FContactList;
end;

Function TFhirNamingSystem.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

Procedure TFhirNamingSystem.SetResponsible(value : TFhirString);
begin
  FResponsible.free;
  FResponsible := value;
end;

Function TFhirNamingSystem.GetResponsibleST : String;
begin
  if FResponsible = nil then
    result := ''
  else
    result := FResponsible.value;
end;

Procedure TFhirNamingSystem.SetResponsibleST(value : String);
begin
  if value <> '' then
  begin
    if FResponsible = nil then
      FResponsible := TFhirString.create;
    FResponsible.value := value
  end
  else if FResponsible <> nil then
    FResponsible.value := '';
end;

Procedure TFhirNamingSystem.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirNamingSystem.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirNamingSystem.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirNamingSystem.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirNamingSystem.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirNamingSystem.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirNamingSystem.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Function TFhirNamingSystem.GetUseContextList : TFhirCodeableConceptList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirCodeableConceptList.Create;
  result := FUseContextList;
end;

Function TFhirNamingSystem.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

Procedure TFhirNamingSystem.SetUsage(value : TFhirString);
begin
  FUsage.free;
  FUsage := value;
end;

Function TFhirNamingSystem.GetUsageST : String;
begin
  if FUsage = nil then
    result := ''
  else
    result := FUsage.value;
end;

Procedure TFhirNamingSystem.SetUsageST(value : String);
begin
  if value <> '' then
  begin
    if FUsage = nil then
      FUsage := TFhirString.create;
    FUsage.value := value
  end
  else if FUsage <> nil then
    FUsage.value := '';
end;

Function TFhirNamingSystem.GetUniqueIdList : TFhirNamingSystemUniqueIdList;
begin
  if FUniqueIdList = nil then
    FUniqueIdList := TFhirNamingSystemUniqueIdList.Create;
  result := FUniqueIdList;
end;

Function TFhirNamingSystem.GetHasUniqueIdList : boolean;
begin
  result := (FUniqueIdList <> nil) and (FUniqueIdList.count > 0);
end;

Procedure TFhirNamingSystem.SetReplacedBy(value : TFhirReference{TFhirNamingSystem});
begin
  FReplacedBy.free;
  FReplacedBy := value;
end;

function TFhirNamingSystem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FKind.sizeInBytes);
  inc(result, FPublisher.sizeInBytes);
  inc(result, FcontactList.sizeInBytes);
  inc(result, FResponsible.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FuseContextList.sizeInBytes);
  inc(result, FUsage.sizeInBytes);
  inc(result, FuniqueIdList.sizeInBytes);
  inc(result, FReplacedBy.sizeInBytes);
end;

{ TFhirNamingSystemListEnumerator }

Constructor TFhirNamingSystemListEnumerator.Create(list : TFhirNamingSystemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNamingSystemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNamingSystemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNamingSystemListEnumerator.GetCurrent : TFhirNamingSystem;
begin
  Result := FList[FIndex];
end;

function TFhirNamingSystemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirNamingSystemList }
procedure TFhirNamingSystemList.AddItem(value: TFhirNamingSystem);
begin
  assert(value.ClassName = 'TFhirNamingSystem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNamingSystem');
  add(value);
end;

function TFhirNamingSystemList.Append: TFhirNamingSystem;
begin
  result := TFhirNamingSystem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNamingSystemList.ClearItems;
begin
  Clear;
end;

function TFhirNamingSystemList.GetEnumerator : TFhirNamingSystemListEnumerator;
begin
  result := TFhirNamingSystemListEnumerator.Create(self.link);
end;

function TFhirNamingSystemList.Clone: TFhirNamingSystemList;
begin
  result := TFhirNamingSystemList(inherited Clone);
end;

function TFhirNamingSystemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNamingSystemList.GetItemN(index: Integer): TFhirNamingSystem;
begin
  result := TFhirNamingSystem(ObjectByIndex[index]);
end;

function TFhirNamingSystemList.ItemClass: TFslObjectClass;
begin
  result := TFhirNamingSystem;
end;
function TFhirNamingSystemList.IndexOf(value: TFhirNamingSystem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNamingSystemList.Insert(index: Integer): TFhirNamingSystem;
begin
  result := TFhirNamingSystem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNamingSystemList.InsertItem(index: Integer; value: TFhirNamingSystem);
begin
  assert(value is TFhirNamingSystem);
  Inherited Insert(index, value);
end;

function TFhirNamingSystemList.Item(index: Integer): TFhirNamingSystem;
begin
  result := TFhirNamingSystem(ObjectByIndex[index]);
end;

function TFhirNamingSystemList.Link: TFhirNamingSystemList;
begin
  result := TFhirNamingSystemList(inherited Link);
end;

procedure TFhirNamingSystemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNamingSystemList.SetItemByIndex(index: Integer; value: TFhirNamingSystem);
begin
  assert(value is TFhirNamingSystem);
  FhirNamingSystems[index] := value;
end;

procedure TFhirNamingSystemList.SetItemN(index: Integer; value: TFhirNamingSystem);
begin
  assert(value is TFhirNamingSystem);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_NAMINGSYSTEM}

{$IFDEF FHIR_OPERATIONDEFINITION}

{ TFhirOperationDefinitionContact }

constructor TFhirOperationDefinitionContact.Create;
begin
  inherited;
end;

destructor TFhirOperationDefinitionContact.Destroy;
begin
  FName.free;
  FTelecomList.Free;
  inherited;
end;

procedure TFhirOperationDefinitionContact.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirOperationDefinitionContact(oSource).nameElement.Clone;
  if (TFhirOperationDefinitionContact(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirOperationDefinitionContact(oSource).FTelecomList);
  end;
end;

procedure TFhirOperationDefinitionContact.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
end;

procedure TFhirOperationDefinitionContact.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link)){3};
end;

function TFhirOperationDefinitionContact.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirOperationDefinitionContact.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint){2a}
  else inherited;
end;

function TFhirOperationDefinitionContact.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'telecom') then result := TelecomList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirOperationDefinitionContact.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirOperationDefinitionContact.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirOperationDefinitionContact.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirOperationDefinitionContact.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'telecom') then TelecomList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirOperationDefinitionContact.fhirType : string;
begin
  result := 'contact';
end;

function TFhirOperationDefinitionContact.Link : TFhirOperationDefinitionContact;
begin
  result := TFhirOperationDefinitionContact(inherited Link);
end;

function TFhirOperationDefinitionContact.Clone : TFhirOperationDefinitionContact;
begin
  result := TFhirOperationDefinitionContact(inherited Clone);
end;

function TFhirOperationDefinitionContact.equals(other : TObject) : boolean; 
var
  o : TFhirOperationDefinitionContact;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirOperationDefinitionContact)) then
    result := false
  else
  begin
    o := TFhirOperationDefinitionContact(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(telecomList, o.telecomList, true);
  end;
end;

function TFhirOperationDefinitionContact.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FtelecomList);
end;

procedure TFhirOperationDefinitionContact.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('telecom');
end;

{ TFhirOperationDefinitionContact }

Procedure TFhirOperationDefinitionContact.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirOperationDefinitionContact.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirOperationDefinitionContact.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Function TFhirOperationDefinitionContact.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

Function TFhirOperationDefinitionContact.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

function TFhirOperationDefinitionContact.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FtelecomList.sizeInBytes);
end;

{ TFhirOperationDefinitionContactListEnumerator }

Constructor TFhirOperationDefinitionContactListEnumerator.Create(list : TFhirOperationDefinitionContactList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirOperationDefinitionContactListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirOperationDefinitionContactListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirOperationDefinitionContactListEnumerator.GetCurrent : TFhirOperationDefinitionContact;
begin
  Result := FList[FIndex];
end;

function TFhirOperationDefinitionContactListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirOperationDefinitionContactList }
procedure TFhirOperationDefinitionContactList.AddItem(value: TFhirOperationDefinitionContact);
begin
  assert(value.ClassName = 'TFhirOperationDefinitionContact', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOperationDefinitionContact');
  add(value);
end;

function TFhirOperationDefinitionContactList.Append: TFhirOperationDefinitionContact;
begin
  result := TFhirOperationDefinitionContact.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationDefinitionContactList.ClearItems;
begin
  Clear;
end;

function TFhirOperationDefinitionContactList.GetEnumerator : TFhirOperationDefinitionContactListEnumerator;
begin
  result := TFhirOperationDefinitionContactListEnumerator.Create(self.link);
end;

function TFhirOperationDefinitionContactList.Clone: TFhirOperationDefinitionContactList;
begin
  result := TFhirOperationDefinitionContactList(inherited Clone);
end;

function TFhirOperationDefinitionContactList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOperationDefinitionContactList.GetItemN(index: Integer): TFhirOperationDefinitionContact;
begin
  result := TFhirOperationDefinitionContact(ObjectByIndex[index]);
end;

function TFhirOperationDefinitionContactList.ItemClass: TFslObjectClass;
begin
  result := TFhirOperationDefinitionContact;
end;
function TFhirOperationDefinitionContactList.IndexOf(value: TFhirOperationDefinitionContact): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirOperationDefinitionContactList.Insert(index: Integer): TFhirOperationDefinitionContact;
begin
  result := TFhirOperationDefinitionContact.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationDefinitionContactList.InsertItem(index: Integer; value: TFhirOperationDefinitionContact);
begin
  assert(value is TFhirOperationDefinitionContact);
  Inherited Insert(index, value);
end;

function TFhirOperationDefinitionContactList.Item(index: Integer): TFhirOperationDefinitionContact;
begin
  result := TFhirOperationDefinitionContact(ObjectByIndex[index]);
end;

function TFhirOperationDefinitionContactList.Link: TFhirOperationDefinitionContactList;
begin
  result := TFhirOperationDefinitionContactList(inherited Link);
end;

procedure TFhirOperationDefinitionContactList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOperationDefinitionContactList.SetItemByIndex(index: Integer; value: TFhirOperationDefinitionContact);
begin
  assert(value is TFhirOperationDefinitionContact);
  FhirOperationDefinitionContacts[index] := value;
end;

procedure TFhirOperationDefinitionContactList.SetItemN(index: Integer; value: TFhirOperationDefinitionContact);
begin
  assert(value is TFhirOperationDefinitionContact);
  ObjectByIndex[index] := value;
end;

{ TFhirOperationDefinitionParameter }

constructor TFhirOperationDefinitionParameter.Create;
begin
  inherited;
end;

destructor TFhirOperationDefinitionParameter.Destroy;
begin
  FName.free;
  FUse.free;
  FMin.free;
  FMax.free;
  FDocumentation.free;
  FType_.free;
  FProfile.free;
  FBinding.free;
  FPartList.Free;
  inherited;
end;

procedure TFhirOperationDefinitionParameter.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirOperationDefinitionParameter(oSource).nameElement.Clone;
  FUse := TFhirOperationDefinitionParameter(oSource).FUse.Link;
  minElement := TFhirOperationDefinitionParameter(oSource).minElement.Clone;
  maxElement := TFhirOperationDefinitionParameter(oSource).maxElement.Clone;
  documentationElement := TFhirOperationDefinitionParameter(oSource).documentationElement.Clone;
  FType_ := TFhirOperationDefinitionParameter(oSource).FType_.Link;
  profile := TFhirOperationDefinitionParameter(oSource).profile.Clone;
  binding := TFhirOperationDefinitionParameter(oSource).binding.Clone;
  if (TFhirOperationDefinitionParameter(oSource).FPartList = nil) then
  begin
    FPartList.free;
    FPartList := nil;
  end
  else
  begin
    if FPartList = nil then
      FPartList := TFhirOperationDefinitionParameterList.Create;
    FPartList.Assign(TFhirOperationDefinitionParameter(oSource).FPartList);
  end;
end;

procedure TFhirOperationDefinitionParameter.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'use') Then
     list.add(self.link, 'use', FUse.Link);
  if (child_name = 'min') Then
     list.add(self.link, 'min', FMin.Link);
  if (child_name = 'max') Then
     list.add(self.link, 'max', FMax.Link);
  if (child_name = 'documentation') Then
     list.add(self.link, 'documentation', FDocumentation.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'profile') Then
     list.add(self.link, 'profile', FProfile.Link);
  if (child_name = 'binding') Then
     list.add(self.link, 'binding', FBinding.Link);
  if (child_name = 'part') Then
    list.addAll(self, 'part', FPartList);
end;

procedure TFhirOperationDefinitionParameter.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'code', false, TFhirCode, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'use', 'code', false, TFHIREnum, FUse.Link));{1}
  oList.add(TFHIRProperty.create(self, 'min', 'integer', false, TFhirInteger, FMin.Link));{2}
  oList.add(TFHIRProperty.create(self, 'max', 'string', false, TFhirString, FMax.Link));{2}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', false, TFhirString, FDocumentation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'profile', 'Reference(StructureDefinition)', false, TFhirReference{TFhirStructureDefinition}, FProfile.Link));{2}
  oList.add(TFHIRProperty.create(self, 'binding', '', false, TFhirOperationDefinitionParameterBinding, FBinding.Link));{2}
  oList.add(TFHIRProperty.create(self, 'part', '@OperationDefinition.parameter', true, TFhirOperationDefinitionParameter, FPartList.Link)){3};
end;

function TFhirOperationDefinitionParameter.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'use') then
  begin
    UseElement := asEnum(SYSTEMS_TFhirOperationParameterUseEnum, CODES_TFhirOperationParameterUseEnum, propValue);
    result := propValue
  end
  else if (propName = 'min') then
  begin
    MinElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'max') then
  begin
    MaxElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'documentation') then
  begin
    DocumentationElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirOperationParameterTypeEnum, CODES_TFhirOperationParameterTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'profile') then
  begin
    Profile := propValue as TFhirReference{TFhirStructureDefinition}{4b};
    result := propValue;
  end
  else if (propName = 'binding') then
  begin
    Binding := propValue as TFhirOperationDefinitionParameterBinding{4b};
    result := propValue;
  end
  else if (propName = 'part') then
  begin
    PartList.add(propValue as TFhirOperationDefinitionParameter){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirOperationDefinitionParameter.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'part') then PartList.insertItem(index, propValue as TFhirOperationDefinitionParameter){2a}
  else inherited;
end;

function TFhirOperationDefinitionParameter.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirCode.create() {5b}
  else if (propName = 'min') then result := TFhirInteger.create() {5b}
  else if (propName = 'max') then result := TFhirString.create() {5b}
  else if (propName = 'documentation') then result := TFhirString.create() {5b}
  else if (propName = 'profile') then result := TFhirReference{TFhirStructureDefinition}.create(){4b}
  else if (propName = 'binding') then result := TFhirOperationDefinitionParameterBinding.create(){4b}
  else if (propName = 'part') then result := PartList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirOperationDefinitionParameter.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'code'
  else if (propName = 'use') then result := 'code'
  else if (propName = 'min') then result := 'integer'
  else if (propName = 'max') then result := 'string'
  else if (propName = 'documentation') then result := 'string'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'profile') then result := 'Reference'
  else if (propName = 'binding') then result := ''
  else if (propName = 'part') then result := '@OperationDefinition.parameter'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirOperationDefinitionParameter.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'use') then UseElement := nil
  else if (propName = 'min') then MinElement := nil
  else if (propName = 'max') then MaxElement := nil
  else if (propName = 'documentation') then DocumentationElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'profile') then ProfileElement := nil
  else if (propName = 'binding') then BindingElement := nil
  else if (propName = 'part') then deletePropertyValue('part', PartList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirOperationDefinitionParameter.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asCode(new){5b}
  else if (propName = 'use') then UseElement := asEnum(SYSTEMS_TFhirOperationParameterUseEnum, CODES_TFhirOperationParameterUseEnum, new){4}
  else if (propName = 'min') then MinElement := asInteger(new){5b}
  else if (propName = 'max') then MaxElement := asString(new){5b}
  else if (propName = 'documentation') then DocumentationElement := asString(new){5b}
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirOperationParameterTypeEnum, CODES_TFhirOperationParameterTypeEnum, new){4}
  else if (propName = 'profile') then ProfileElement := new as TFhirReference{TFhirStructureDefinition}{4}
  else if (propName = 'binding') then BindingElement := new as TFhirOperationDefinitionParameterBinding{4}
  else if (propName = 'part') then replacePropertyValue('part', PartList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirOperationDefinitionParameter.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'part') then PartList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirOperationDefinitionParameter.fhirType : string;
begin
  result := 'parameter';
end;

function TFhirOperationDefinitionParameter.Link : TFhirOperationDefinitionParameter;
begin
  result := TFhirOperationDefinitionParameter(inherited Link);
end;

function TFhirOperationDefinitionParameter.Clone : TFhirOperationDefinitionParameter;
begin
  result := TFhirOperationDefinitionParameter(inherited Clone);
end;

function TFhirOperationDefinitionParameter.equals(other : TObject) : boolean; 
var
  o : TFhirOperationDefinitionParameter;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirOperationDefinitionParameter)) then
    result := false
  else
  begin
    o := TFhirOperationDefinitionParameter(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(useElement, o.useElement, true) and 
      compareDeep(minElement, o.minElement, true) and compareDeep(maxElement, o.maxElement, true) and 
      compareDeep(documentationElement, o.documentationElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(profileElement, o.profileElement, true) and compareDeep(bindingElement, o.bindingElement, true) and 
      compareDeep(partList, o.partList, true);
  end;
end;

function TFhirOperationDefinitionParameter.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FUse) and isEmptyProp(FMin) and isEmptyProp(FMax) and isEmptyProp(FDocumentation) and isEmptyProp(FType_) and isEmptyProp(FProfile) and isEmptyProp(FBinding) and isEmptyProp(FpartList);
end;

procedure TFhirOperationDefinitionParameter.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('use');
  fields.add('min');
  fields.add('max');
  fields.add('documentation');
  fields.add('type');
  fields.add('profile');
  fields.add('binding');
  fields.add('part');
end;

{ TFhirOperationDefinitionParameter }

Procedure TFhirOperationDefinitionParameter.SetName(value : TFhirCode);
begin
  FName.free;
  FName := value;
end;

Function TFhirOperationDefinitionParameter.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirOperationDefinitionParameter.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirCode.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirOperationDefinitionParameter.SetUse(value : TFhirEnum);
begin
  FUse.free;
  FUse := value;
end;

Function TFhirOperationDefinitionParameter.GetUseST : TFhirOperationParameterUseEnum;
begin
  if FUse = nil then
    result := TFhirOperationParameterUseEnum(0)
  else
    result := TFhirOperationParameterUseEnum(StringArrayIndexOfSensitive(CODES_TFhirOperationParameterUseEnum, FUse.value));
end;

Procedure TFhirOperationDefinitionParameter.SetUseST(value : TFhirOperationParameterUseEnum);
begin
  if ord(value) = 0 then
    UseElement := nil
  else
    UseElement := TFhirEnum.create(SYSTEMS_TFhirOperationParameterUseEnum[value], CODES_TFhirOperationParameterUseEnum[value]);
end;

Procedure TFhirOperationDefinitionParameter.SetMin(value : TFhirInteger);
begin
  FMin.free;
  FMin := value;
end;

Function TFhirOperationDefinitionParameter.GetMinST : String;
begin
  if FMin = nil then
    result := ''
  else
    result := FMin.value;
end;

Procedure TFhirOperationDefinitionParameter.SetMinST(value : String);
begin
  if value <> '' then
  begin
    if FMin = nil then
      FMin := TFhirInteger.create;
    FMin.value := value
  end
  else if FMin <> nil then
    FMin.value := '';
end;

Procedure TFhirOperationDefinitionParameter.SetMax(value : TFhirString);
begin
  FMax.free;
  FMax := value;
end;

Function TFhirOperationDefinitionParameter.GetMaxST : String;
begin
  if FMax = nil then
    result := ''
  else
    result := FMax.value;
end;

Procedure TFhirOperationDefinitionParameter.SetMaxST(value : String);
begin
  if value <> '' then
  begin
    if FMax = nil then
      FMax := TFhirString.create;
    FMax.value := value
  end
  else if FMax <> nil then
    FMax.value := '';
end;

Procedure TFhirOperationDefinitionParameter.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirOperationDefinitionParameter.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

Procedure TFhirOperationDefinitionParameter.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

Procedure TFhirOperationDefinitionParameter.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirOperationDefinitionParameter.GetType_ST : TFhirOperationParameterTypeEnum;
begin
  if FType_ = nil then
    result := TFhirOperationParameterTypeEnum(0)
  else
    result := TFhirOperationParameterTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirOperationParameterTypeEnum, FType_.value));
end;

Procedure TFhirOperationDefinitionParameter.SetType_ST(value : TFhirOperationParameterTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirOperationParameterTypeEnum[value], CODES_TFhirOperationParameterTypeEnum[value]);
end;

Procedure TFhirOperationDefinitionParameter.SetProfile(value : TFhirReference{TFhirStructureDefinition});
begin
  FProfile.free;
  FProfile := value;
end;

Procedure TFhirOperationDefinitionParameter.SetBinding(value : TFhirOperationDefinitionParameterBinding);
begin
  FBinding.free;
  FBinding := value;
end;

Function TFhirOperationDefinitionParameter.GetPartList : TFhirOperationDefinitionParameterList;
begin
  if FPartList = nil then
    FPartList := TFhirOperationDefinitionParameterList.Create;
  result := FPartList;
end;

Function TFhirOperationDefinitionParameter.GetHasPartList : boolean;
begin
  result := (FPartList <> nil) and (FPartList.count > 0);
end;

function TFhirOperationDefinitionParameter.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FUse.sizeInBytes);
  inc(result, FMin.sizeInBytes);
  inc(result, FMax.sizeInBytes);
  inc(result, FDocumentation.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FProfile.sizeInBytes);
  inc(result, FBinding.sizeInBytes);
  inc(result, FpartList.sizeInBytes);
end;

{ TFhirOperationDefinitionParameterListEnumerator }

Constructor TFhirOperationDefinitionParameterListEnumerator.Create(list : TFhirOperationDefinitionParameterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirOperationDefinitionParameterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirOperationDefinitionParameterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirOperationDefinitionParameterListEnumerator.GetCurrent : TFhirOperationDefinitionParameter;
begin
  Result := FList[FIndex];
end;

function TFhirOperationDefinitionParameterListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirOperationDefinitionParameterList }
procedure TFhirOperationDefinitionParameterList.AddItem(value: TFhirOperationDefinitionParameter);
begin
  assert(value.ClassName = 'TFhirOperationDefinitionParameter', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOperationDefinitionParameter');
  add(value);
end;

function TFhirOperationDefinitionParameterList.Append: TFhirOperationDefinitionParameter;
begin
  result := TFhirOperationDefinitionParameter.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationDefinitionParameterList.ClearItems;
begin
  Clear;
end;

function TFhirOperationDefinitionParameterList.GetEnumerator : TFhirOperationDefinitionParameterListEnumerator;
begin
  result := TFhirOperationDefinitionParameterListEnumerator.Create(self.link);
end;

function TFhirOperationDefinitionParameterList.Clone: TFhirOperationDefinitionParameterList;
begin
  result := TFhirOperationDefinitionParameterList(inherited Clone);
end;

function TFhirOperationDefinitionParameterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOperationDefinitionParameterList.GetItemN(index: Integer): TFhirOperationDefinitionParameter;
begin
  result := TFhirOperationDefinitionParameter(ObjectByIndex[index]);
end;

function TFhirOperationDefinitionParameterList.ItemClass: TFslObjectClass;
begin
  result := TFhirOperationDefinitionParameter;
end;
function TFhirOperationDefinitionParameterList.IndexOf(value: TFhirOperationDefinitionParameter): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirOperationDefinitionParameterList.Insert(index: Integer): TFhirOperationDefinitionParameter;
begin
  result := TFhirOperationDefinitionParameter.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationDefinitionParameterList.InsertItem(index: Integer; value: TFhirOperationDefinitionParameter);
begin
  assert(value is TFhirOperationDefinitionParameter);
  Inherited Insert(index, value);
end;

function TFhirOperationDefinitionParameterList.Item(index: Integer): TFhirOperationDefinitionParameter;
begin
  result := TFhirOperationDefinitionParameter(ObjectByIndex[index]);
end;

function TFhirOperationDefinitionParameterList.Link: TFhirOperationDefinitionParameterList;
begin
  result := TFhirOperationDefinitionParameterList(inherited Link);
end;

procedure TFhirOperationDefinitionParameterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOperationDefinitionParameterList.SetItemByIndex(index: Integer; value: TFhirOperationDefinitionParameter);
begin
  assert(value is TFhirOperationDefinitionParameter);
  FhirOperationDefinitionParameters[index] := value;
end;

procedure TFhirOperationDefinitionParameterList.SetItemN(index: Integer; value: TFhirOperationDefinitionParameter);
begin
  assert(value is TFhirOperationDefinitionParameter);
  ObjectByIndex[index] := value;
end;

{ TFhirOperationDefinitionParameterBinding }

constructor TFhirOperationDefinitionParameterBinding.Create;
begin
  inherited;
end;

destructor TFhirOperationDefinitionParameterBinding.Destroy;
begin
  FStrength.free;
  FValueSet.free;
  inherited;
end;

procedure TFhirOperationDefinitionParameterBinding.Assign(oSource : TFslObject);
begin
  inherited;
  FStrength := TFhirOperationDefinitionParameterBinding(oSource).FStrength.Link;
  valueSet := TFhirOperationDefinitionParameterBinding(oSource).valueSet.Clone;
end;

procedure TFhirOperationDefinitionParameterBinding.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'strength') Then
     list.add(self.link, 'strength', FStrength.Link);
  if (child_name = 'valueSet[x]') or (child_name = 'valueSet') Then
     list.add(self.link, 'valueSet[x]', FValueSet.Link);
end;

procedure TFhirOperationDefinitionParameterBinding.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'strength', 'code', false, TFHIREnum, FStrength.Link));{1}
  oList.add(TFHIRProperty.create(self, 'valueSet[x]', 'uri|Reference(ValueSet)', false, TFhirType, FValueSet.Link));{2}
end;

function TFhirOperationDefinitionParameterBinding.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'strength') then
  begin
    StrengthElement := asEnum(SYSTEMS_TFhirBindingStrengthEnum, CODES_TFhirBindingStrengthEnum, propValue);
    result := propValue
  end
  else if (isMatchingName(propName, 'valueSet', ['Uri', 'Reference'])) then
  begin
    ValueSet := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirOperationDefinitionParameterBinding.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirOperationDefinitionParameterBinding.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'valueSet', ['Uri', 'Reference'])) then raise EFHIRException.create('Cannot make property ValueSet'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirOperationDefinitionParameterBinding.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'strength') then result := 'code'
  else if (propName = 'valueSet[x]') then result := 'uri|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirOperationDefinitionParameterBinding.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'strength') then StrengthElement := nil
  else if (isMatchingName(propName, 'valueSet', ['Uri', 'Reference'])) then ValueSetElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirOperationDefinitionParameterBinding.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'strength') then StrengthElement := asEnum(SYSTEMS_TFhirBindingStrengthEnum, CODES_TFhirBindingStrengthEnum, new){4}
  else if (isMatchingName(propName, 'valueSet', ['Uri', 'Reference'])) then ValueSetElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirOperationDefinitionParameterBinding.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirOperationDefinitionParameterBinding.fhirType : string;
begin
  result := 'binding';
end;

function TFhirOperationDefinitionParameterBinding.Link : TFhirOperationDefinitionParameterBinding;
begin
  result := TFhirOperationDefinitionParameterBinding(inherited Link);
end;

function TFhirOperationDefinitionParameterBinding.Clone : TFhirOperationDefinitionParameterBinding;
begin
  result := TFhirOperationDefinitionParameterBinding(inherited Clone);
end;

function TFhirOperationDefinitionParameterBinding.equals(other : TObject) : boolean; 
var
  o : TFhirOperationDefinitionParameterBinding;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirOperationDefinitionParameterBinding)) then
    result := false
  else
  begin
    o := TFhirOperationDefinitionParameterBinding(other);
    result := compareDeep(strengthElement, o.strengthElement, true) and compareDeep(valueSetElement, o.valueSetElement, true);
  end;
end;

function TFhirOperationDefinitionParameterBinding.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FStrength) and isEmptyProp(FValueSet);
end;

procedure TFhirOperationDefinitionParameterBinding.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('strength');
  fields.add('valueSet[x]');
end;

{ TFhirOperationDefinitionParameterBinding }

Procedure TFhirOperationDefinitionParameterBinding.SetStrength(value : TFhirEnum);
begin
  FStrength.free;
  FStrength := value;
end;

Function TFhirOperationDefinitionParameterBinding.GetStrengthST : TFhirBindingStrengthEnum;
begin
  if FStrength = nil then
    result := TFhirBindingStrengthEnum(0)
  else
    result := TFhirBindingStrengthEnum(StringArrayIndexOfSensitive(CODES_TFhirBindingStrengthEnum, FStrength.value));
end;

Procedure TFhirOperationDefinitionParameterBinding.SetStrengthST(value : TFhirBindingStrengthEnum);
begin
  if ord(value) = 0 then
    StrengthElement := nil
  else
    StrengthElement := TFhirEnum.create(SYSTEMS_TFhirBindingStrengthEnum[value], CODES_TFhirBindingStrengthEnum[value]);
end;

Procedure TFhirOperationDefinitionParameterBinding.SetValueSet(value : TFhirType);
begin
  FValueSet.free;
  FValueSet := value;
end;

function TFhirOperationDefinitionParameterBinding.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FStrength.sizeInBytes);
  inc(result, FValueSet.sizeInBytes);
end;

{ TFhirOperationDefinitionParameterBindingListEnumerator }

Constructor TFhirOperationDefinitionParameterBindingListEnumerator.Create(list : TFhirOperationDefinitionParameterBindingList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirOperationDefinitionParameterBindingListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirOperationDefinitionParameterBindingListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirOperationDefinitionParameterBindingListEnumerator.GetCurrent : TFhirOperationDefinitionParameterBinding;
begin
  Result := FList[FIndex];
end;

function TFhirOperationDefinitionParameterBindingListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirOperationDefinitionParameterBindingList }
procedure TFhirOperationDefinitionParameterBindingList.AddItem(value: TFhirOperationDefinitionParameterBinding);
begin
  assert(value.ClassName = 'TFhirOperationDefinitionParameterBinding', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOperationDefinitionParameterBinding');
  add(value);
end;

function TFhirOperationDefinitionParameterBindingList.Append: TFhirOperationDefinitionParameterBinding;
begin
  result := TFhirOperationDefinitionParameterBinding.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationDefinitionParameterBindingList.ClearItems;
begin
  Clear;
end;

function TFhirOperationDefinitionParameterBindingList.GetEnumerator : TFhirOperationDefinitionParameterBindingListEnumerator;
begin
  result := TFhirOperationDefinitionParameterBindingListEnumerator.Create(self.link);
end;

function TFhirOperationDefinitionParameterBindingList.Clone: TFhirOperationDefinitionParameterBindingList;
begin
  result := TFhirOperationDefinitionParameterBindingList(inherited Clone);
end;

function TFhirOperationDefinitionParameterBindingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOperationDefinitionParameterBindingList.GetItemN(index: Integer): TFhirOperationDefinitionParameterBinding;
begin
  result := TFhirOperationDefinitionParameterBinding(ObjectByIndex[index]);
end;

function TFhirOperationDefinitionParameterBindingList.ItemClass: TFslObjectClass;
begin
  result := TFhirOperationDefinitionParameterBinding;
end;
function TFhirOperationDefinitionParameterBindingList.IndexOf(value: TFhirOperationDefinitionParameterBinding): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirOperationDefinitionParameterBindingList.Insert(index: Integer): TFhirOperationDefinitionParameterBinding;
begin
  result := TFhirOperationDefinitionParameterBinding.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationDefinitionParameterBindingList.InsertItem(index: Integer; value: TFhirOperationDefinitionParameterBinding);
begin
  assert(value is TFhirOperationDefinitionParameterBinding);
  Inherited Insert(index, value);
end;

function TFhirOperationDefinitionParameterBindingList.Item(index: Integer): TFhirOperationDefinitionParameterBinding;
begin
  result := TFhirOperationDefinitionParameterBinding(ObjectByIndex[index]);
end;

function TFhirOperationDefinitionParameterBindingList.Link: TFhirOperationDefinitionParameterBindingList;
begin
  result := TFhirOperationDefinitionParameterBindingList(inherited Link);
end;

procedure TFhirOperationDefinitionParameterBindingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOperationDefinitionParameterBindingList.SetItemByIndex(index: Integer; value: TFhirOperationDefinitionParameterBinding);
begin
  assert(value is TFhirOperationDefinitionParameterBinding);
  FhirOperationDefinitionParameterBindings[index] := value;
end;

procedure TFhirOperationDefinitionParameterBindingList.SetItemN(index: Integer; value: TFhirOperationDefinitionParameterBinding);
begin
  assert(value is TFhirOperationDefinitionParameterBinding);
  ObjectByIndex[index] := value;
end;

{ TFhirOperationDefinition }

constructor TFhirOperationDefinition.Create;
begin
  inherited;
end;

destructor TFhirOperationDefinition.Destroy;
begin
  FUrl.free;
  FVersion.free;
  FName.free;
  FStatus.free;
  FKind.free;
  FExperimental.free;
  FPublisher.free;
  FContactList.Free;
  FDate.free;
  FDescription.free;
  FRequirements.free;
  FIdempotent.free;
  FCode.free;
  FNotes.free;
  FBase.free;
  FSystem.free;
  FType_.Free;
  FInstance.free;
  FParameterList.Free;
  inherited;
end;

function TFhirOperationDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtOperationDefinition;
end;

procedure TFhirOperationDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirOperationDefinition(oSource).urlElement.Clone;
  versionElement := TFhirOperationDefinition(oSource).versionElement.Clone;
  nameElement := TFhirOperationDefinition(oSource).nameElement.Clone;
  FStatus := TFhirOperationDefinition(oSource).FStatus.Link;
  FKind := TFhirOperationDefinition(oSource).FKind.Link;
  experimentalElement := TFhirOperationDefinition(oSource).experimentalElement.Clone;
  publisherElement := TFhirOperationDefinition(oSource).publisherElement.Clone;
  if (TFhirOperationDefinition(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirOperationDefinitionContactList.Create;
    FContactList.Assign(TFhirOperationDefinition(oSource).FContactList);
  end;
  dateElement := TFhirOperationDefinition(oSource).dateElement.Clone;
  descriptionElement := TFhirOperationDefinition(oSource).descriptionElement.Clone;
  requirementsElement := TFhirOperationDefinition(oSource).requirementsElement.Clone;
  idempotentElement := TFhirOperationDefinition(oSource).idempotentElement.Clone;
  codeElement := TFhirOperationDefinition(oSource).codeElement.Clone;
  notesElement := TFhirOperationDefinition(oSource).notesElement.Clone;
  base := TFhirOperationDefinition(oSource).base.Clone;
  systemElement := TFhirOperationDefinition(oSource).systemElement.Clone;
  if (TFhirOperationDefinition(oSource).FType_ = nil) then
  begin
    FType_.free;
    FType_ := nil;
  end
  else
  begin
    FType_ := TFHIREnumList.Create(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum);
    FType_.Assign(TFhirOperationDefinition(oSource).FType_);
  end;
  instanceElement := TFhirOperationDefinition(oSource).instanceElement.Clone;
  if (TFhirOperationDefinition(oSource).FParameterList = nil) then
  begin
    FParameterList.free;
    FParameterList := nil;
  end
  else
  begin
    if FParameterList = nil then
      FParameterList := TFhirOperationDefinitionParameterList.Create;
    FParameterList.Assign(TFhirOperationDefinition(oSource).FParameterList);
  end;
end;

procedure TFhirOperationDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'kind') Then
     list.add(self.link, 'kind', FKind.Link);
  if (child_name = 'experimental') Then
     list.add(self.link, 'experimental', FExperimental.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'requirements') Then
     list.add(self.link, 'requirements', FRequirements.Link);
  if (child_name = 'idempotent') Then
     list.add(self.link, 'idempotent', FIdempotent.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'notes') Then
     list.add(self.link, 'notes', FNotes.Link);
  if (child_name = 'base') Then
     list.add(self.link, 'base', FBase.Link);
  if (child_name = 'system') Then
     list.add(self.link, 'system', FSystem.Link);
  if (child_name = 'type') Then
     list.addAll(self, 'type', FType_);
  if (child_name = 'instance') Then
     list.add(self.link, 'instance', FInstance.Link);
  if (child_name = 'parameter') Then
    list.addAll(self, 'parameter', FParameterList);
end;

procedure TFhirOperationDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));{2}
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'kind', 'code', false, TFHIREnum, FKind.Link));{1}
  oList.add(TFHIRProperty.create(self, 'experimental', 'boolean', false, TFhirBoolean, FExperimental.Link));{2}
  oList.add(TFHIRProperty.create(self, 'publisher', 'string', false, TFhirString, FPublisher.Link));{2}
  oList.add(TFHIRProperty.create(self, 'contact', '', true, TFhirOperationDefinitionContact, FContactList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requirements', 'string', false, TFhirString, FRequirements.Link));{2}
  oList.add(TFHIRProperty.create(self, 'idempotent', 'boolean', false, TFhirBoolean, FIdempotent.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirCode, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'notes', 'string', false, TFhirString, FNotes.Link));{2}
  oList.add(TFHIRProperty.create(self, 'base', 'Reference(OperationDefinition)', false, TFhirReference{TFhirOperationDefinition}, FBase.Link));{2}
  oList.add(TFHIRProperty.create(self, 'system', 'boolean', false, TFhirBoolean, FSystem.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'code', true, TFHIREnum, FType_.Link)){3};
  oList.add(TFHIRProperty.create(self, 'instance', 'boolean', false, TFhirBoolean, FInstance.Link));{2}
  oList.add(TFHIRProperty.create(self, 'parameter', '', true, TFhirOperationDefinitionParameter, FParameterList.Link)){3};
end;

function TFhirOperationDefinition.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirConformanceResourceStatusEnum, CODES_TFhirConformanceResourceStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'kind') then
  begin
    KindElement := asEnum(SYSTEMS_TFhirOperationKindEnum, CODES_TFhirOperationKindEnum, propValue);
    result := propValue
  end
  else if (propName = 'experimental') then
  begin
    ExperimentalElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    PublisherElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirOperationDefinitionContact){2a};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'requirements') then
  begin
    RequirementsElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'idempotent') then
  begin
    IdempotentElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'notes') then
  begin
    NotesElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'base') then
  begin
    Base := propValue as TFhirReference{TFhirOperationDefinition}{4b};
    result := propValue;
  end
  else if (propName = 'system') then
  begin
    SystemElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue)); {1}
    result := propValue;
  end
  else if (propName = 'instance') then
  begin
    InstanceElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'parameter') then
  begin
    ParameterList.add(propValue as TFhirOperationDefinitionParameter){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirOperationDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirOperationDefinitionContact){2a}
  else if (propName = 'type') then FType_.insertItem(index, asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue)) {1}
  else if (propName = 'parameter') then ParameterList.insertItem(index, propValue as TFhirOperationDefinitionParameter){2a}
  else inherited;
end;

function TFhirOperationDefinition.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create() {5b}
  else if (propName = 'version') then result := TFhirString.create() {5b}
  else if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'experimental') then result := TFhirBoolean.create() {5b}
  else if (propName = 'publisher') then result := TFhirString.create() {5b}
  else if (propName = 'contact') then result := ContactList.new(){2}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'requirements') then result := TFhirString.create() {5b}
  else if (propName = 'idempotent') then result := TFhirBoolean.create() {5b}
  else if (propName = 'code') then result := TFhirCode.create() {5b}
  else if (propName = 'notes') then result := TFhirString.create() {5b}
  else if (propName = 'base') then result := TFhirReference{TFhirOperationDefinition}.create(){4b}
  else if (propName = 'system') then result := TFhirBoolean.create() {5b}
  else if (propName = 'instance') then result := TFhirBoolean.create() {5b}
  else if (propName = 'parameter') then result := ParameterList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirOperationDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'uri'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'kind') then result := 'code'
  else if (propName = 'experimental') then result := 'boolean'
  else if (propName = 'publisher') then result := 'string'
  else if (propName = 'contact') then result := ''
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'requirements') then result := 'string'
  else if (propName = 'idempotent') then result := 'boolean'
  else if (propName = 'code') then result := 'code'
  else if (propName = 'notes') then result := 'string'
  else if (propName = 'base') then result := 'Reference'
  else if (propName = 'system') then result := 'boolean'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'instance') then result := 'boolean'
  else if (propName = 'parameter') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirOperationDefinition.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'kind') then KindElement := nil
  else if (propName = 'experimental') then ExperimentalElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value) {2}
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'requirements') then RequirementsElement := nil
  else if (propName = 'idempotent') then IdempotentElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'notes') then NotesElement := nil
  else if (propName = 'base') then BaseElement := nil
  else if (propName = 'system') then SystemElement := nil
  else if (propName = 'instance') then InstanceElement := nil
  else if (propName = 'parameter') then deletePropertyValue('parameter', ParameterList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirOperationDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asUri(new){5b}
  else if (propName = 'version') then VersionElement := asString(new){5b}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirConformanceResourceStatusEnum, CODES_TFhirConformanceResourceStatusEnum, new){4}
  else if (propName = 'kind') then KindElement := asEnum(SYSTEMS_TFhirOperationKindEnum, CODES_TFhirOperationKindEnum, new){4}
  else if (propName = 'experimental') then ExperimentalElement := asBoolean(new){5b}
  else if (propName = 'publisher') then PublisherElement := asString(new){5b}
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new) {2}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'requirements') then RequirementsElement := asString(new){5b}
  else if (propName = 'idempotent') then IdempotentElement := asBoolean(new){5b}
  else if (propName = 'code') then CodeElement := asCode(new){5b}
  else if (propName = 'notes') then NotesElement := asString(new){5b}
  else if (propName = 'base') then BaseElement := new as TFhirReference{TFhirOperationDefinition}{4}
  else if (propName = 'system') then SystemElement := asBoolean(new){5b}
  else if (propName = 'instance') then InstanceElement := asBoolean(new){5b}
  else if (propName = 'parameter') then replacePropertyValue('parameter', ParameterList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirOperationDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'contact') then ContactList.move(source, destination){2a}
  else if (propName = 'type') then FType_.move(source, destination) {1}
  else if (propName = 'parameter') then ParameterList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirOperationDefinition.fhirType : string;
begin
  result := 'OperationDefinition';
end;

function TFhirOperationDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FVersion) and isEmptyProp(FName) and isEmptyProp(FStatus) and isEmptyProp(FKind) and isEmptyProp(FExperimental) and isEmptyProp(FPublisher) and isEmptyProp(FcontactList) and isEmptyProp(FDate) and isEmptyProp(FDescription) and isEmptyProp(FRequirements) and isEmptyProp(FIdempotent) and isEmptyProp(FCode) and isEmptyProp(FNotes) and isEmptyProp(FBase) and isEmptyProp(FSystem) and isEmptyProp(FType_) and isEmptyProp(FInstance) and isEmptyProp(FparameterList);
end;

function TFhirOperationDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirOperationDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirOperationDefinition)) then
    result := false
  else
  begin
    o := TFhirOperationDefinition(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(versionElement, o.versionElement, true) and 
      compareDeep(nameElement, o.nameElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(kindElement, o.kindElement, true) and compareDeep(experimentalElement, o.experimentalElement, true) and 
      compareDeep(publisherElement, o.publisherElement, true) and compareDeep(contactList, o.contactList, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(requirementsElement, o.requirementsElement, true) and compareDeep(idempotentElement, o.idempotentElement, true) and 
      compareDeep(codeElement, o.codeElement, true) and compareDeep(notesElement, o.notesElement, true) and 
      compareDeep(baseElement, o.baseElement, true) and compareDeep(systemElement, o.systemElement, true) and 
      compareDeep(type_List, o.type_List, true) and compareDeep(instanceElement, o.instanceElement, true) and 
      compareDeep(parameterList, o.parameterList, true);
  end;
end;

function TFhirOperationDefinition.Link : TFhirOperationDefinition;
begin
  result := TFhirOperationDefinition(inherited Link);
end;

function TFhirOperationDefinition.Clone : TFhirOperationDefinition;
begin
  result := TFhirOperationDefinition(inherited Clone);
end;

procedure TFhirOperationDefinition.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('url');
  fields.add('version');
  fields.add('name');
  fields.add('status');
  fields.add('kind');
  fields.add('experimental');
  fields.add('publisher');
  fields.add('contact');
  fields.add('date');
  fields.add('description');
  fields.add('requirements');
  fields.add('idempotent');
  fields.add('code');
  fields.add('notes');
  fields.add('base');
  fields.add('system');
  fields.add('type');
  fields.add('instance');
  fields.add('parameter');
end;

{ TFhirOperationDefinition }

Procedure TFhirOperationDefinition.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirOperationDefinition.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

Procedure TFhirOperationDefinition.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

Procedure TFhirOperationDefinition.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

Function TFhirOperationDefinition.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

Procedure TFhirOperationDefinition.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

Procedure TFhirOperationDefinition.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirOperationDefinition.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirOperationDefinition.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirOperationDefinition.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirOperationDefinition.GetStatusST : TFhirConformanceResourceStatusEnum;
begin
  if FStatus = nil then
    result := TFhirConformanceResourceStatusEnum(0)
  else
    result := TFhirConformanceResourceStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirConformanceResourceStatusEnum, FStatus.value));
end;

Procedure TFhirOperationDefinition.SetStatusST(value : TFhirConformanceResourceStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirConformanceResourceStatusEnum[value], CODES_TFhirConformanceResourceStatusEnum[value]);
end;

Procedure TFhirOperationDefinition.SetKind(value : TFhirEnum);
begin
  FKind.free;
  FKind := value;
end;

Function TFhirOperationDefinition.GetKindST : TFhirOperationKindEnum;
begin
  if FKind = nil then
    result := TFhirOperationKindEnum(0)
  else
    result := TFhirOperationKindEnum(StringArrayIndexOfSensitive(CODES_TFhirOperationKindEnum, FKind.value));
end;

Procedure TFhirOperationDefinition.SetKindST(value : TFhirOperationKindEnum);
begin
  if ord(value) = 0 then
    KindElement := nil
  else
    KindElement := TFhirEnum.create(SYSTEMS_TFhirOperationKindEnum[value], CODES_TFhirOperationKindEnum[value]);
end;

Procedure TFhirOperationDefinition.SetExperimental(value : TFhirBoolean);
begin
  FExperimental.free;
  FExperimental := value;
end;

Function TFhirOperationDefinition.GetExperimentalST : Boolean;
begin
  if FExperimental = nil then
    result := false
  else
    result := FExperimental.value;
end;

Procedure TFhirOperationDefinition.SetExperimentalST(value : Boolean);
begin
  if FExperimental = nil then
    FExperimental := TFhirBoolean.create;
  FExperimental.value := value
end;

Procedure TFhirOperationDefinition.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

Function TFhirOperationDefinition.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

Procedure TFhirOperationDefinition.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

Function TFhirOperationDefinition.GetContactList : TFhirOperationDefinitionContactList;
begin
  if FContactList = nil then
    FContactList := TFhirOperationDefinitionContactList.Create;
  result := FContactList;
end;

Function TFhirOperationDefinition.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

Procedure TFhirOperationDefinition.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirOperationDefinition.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirOperationDefinition.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirOperationDefinition.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirOperationDefinition.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirOperationDefinition.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirOperationDefinition.SetRequirements(value : TFhirString);
begin
  FRequirements.free;
  FRequirements := value;
end;

Function TFhirOperationDefinition.GetRequirementsST : String;
begin
  if FRequirements = nil then
    result := ''
  else
    result := FRequirements.value;
end;

Procedure TFhirOperationDefinition.SetRequirementsST(value : String);
begin
  if value <> '' then
  begin
    if FRequirements = nil then
      FRequirements := TFhirString.create;
    FRequirements.value := value
  end
  else if FRequirements <> nil then
    FRequirements.value := '';
end;

Procedure TFhirOperationDefinition.SetIdempotent(value : TFhirBoolean);
begin
  FIdempotent.free;
  FIdempotent := value;
end;

Function TFhirOperationDefinition.GetIdempotentST : Boolean;
begin
  if FIdempotent = nil then
    result := false
  else
    result := FIdempotent.value;
end;

Procedure TFhirOperationDefinition.SetIdempotentST(value : Boolean);
begin
  if FIdempotent = nil then
    FIdempotent := TFhirBoolean.create;
  FIdempotent.value := value
end;

Procedure TFhirOperationDefinition.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirOperationDefinition.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

Procedure TFhirOperationDefinition.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

Procedure TFhirOperationDefinition.SetNotes(value : TFhirString);
begin
  FNotes.free;
  FNotes := value;
end;

Function TFhirOperationDefinition.GetNotesST : String;
begin
  if FNotes = nil then
    result := ''
  else
    result := FNotes.value;
end;

Procedure TFhirOperationDefinition.SetNotesST(value : String);
begin
  if value <> '' then
  begin
    if FNotes = nil then
      FNotes := TFhirString.create;
    FNotes.value := value
  end
  else if FNotes <> nil then
    FNotes.value := '';
end;

Procedure TFhirOperationDefinition.SetBase(value : TFhirReference{TFhirOperationDefinition});
begin
  FBase.free;
  FBase := value;
end;

Procedure TFhirOperationDefinition.SetSystem(value : TFhirBoolean);
begin
  FSystem.free;
  FSystem := value;
end;

Function TFhirOperationDefinition.GetSystemST : Boolean;
begin
  if FSystem = nil then
    result := false
  else
    result := FSystem.value;
end;

Procedure TFhirOperationDefinition.SetSystemST(value : Boolean);
begin
  if FSystem = nil then
    FSystem := TFhirBoolean.create;
  FSystem.value := value
end;

Function TFhirOperationDefinition.GetType_ : TFhirEnumList;
begin
  if FType_ = nil then
    FType_ := TFHIREnumList.Create(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum);
  result := FType_;
end;

Function TFhirOperationDefinition.GetHasType_ : boolean;
begin
  result := (FType_ <> nil) and (FType_.count > 0);
end;

Procedure TFhirOperationDefinition.SetInstance(value : TFhirBoolean);
begin
  FInstance.free;
  FInstance := value;
end;

Function TFhirOperationDefinition.GetInstanceST : Boolean;
begin
  if FInstance = nil then
    result := false
  else
    result := FInstance.value;
end;

Procedure TFhirOperationDefinition.SetInstanceST(value : Boolean);
begin
  if FInstance = nil then
    FInstance := TFhirBoolean.create;
  FInstance.value := value
end;

Function TFhirOperationDefinition.GetParameterList : TFhirOperationDefinitionParameterList;
begin
  if FParameterList = nil then
    FParameterList := TFhirOperationDefinitionParameterList.Create;
  result := FParameterList;
end;

Function TFhirOperationDefinition.GetHasParameterList : boolean;
begin
  result := (FParameterList <> nil) and (FParameterList.count > 0);
end;

function TFhirOperationDefinition.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FUrl.sizeInBytes);
  inc(result, FVersion.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FKind.sizeInBytes);
  inc(result, FExperimental.sizeInBytes);
  inc(result, FPublisher.sizeInBytes);
  inc(result, FcontactList.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FRequirements.sizeInBytes);
  inc(result, FIdempotent.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FNotes.sizeInBytes);
  inc(result, FBase.sizeInBytes);
  inc(result, FSystem.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FInstance.sizeInBytes);
  inc(result, FparameterList.sizeInBytes);
end;

{ TFhirOperationDefinitionListEnumerator }

Constructor TFhirOperationDefinitionListEnumerator.Create(list : TFhirOperationDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirOperationDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirOperationDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirOperationDefinitionListEnumerator.GetCurrent : TFhirOperationDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirOperationDefinitionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirOperationDefinitionList }
procedure TFhirOperationDefinitionList.AddItem(value: TFhirOperationDefinition);
begin
  assert(value.ClassName = 'TFhirOperationDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOperationDefinition');
  add(value);
end;

function TFhirOperationDefinitionList.Append: TFhirOperationDefinition;
begin
  result := TFhirOperationDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirOperationDefinitionList.GetEnumerator : TFhirOperationDefinitionListEnumerator;
begin
  result := TFhirOperationDefinitionListEnumerator.Create(self.link);
end;

function TFhirOperationDefinitionList.Clone: TFhirOperationDefinitionList;
begin
  result := TFhirOperationDefinitionList(inherited Clone);
end;

function TFhirOperationDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOperationDefinitionList.GetItemN(index: Integer): TFhirOperationDefinition;
begin
  result := TFhirOperationDefinition(ObjectByIndex[index]);
end;

function TFhirOperationDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirOperationDefinition;
end;
function TFhirOperationDefinitionList.IndexOf(value: TFhirOperationDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirOperationDefinitionList.Insert(index: Integer): TFhirOperationDefinition;
begin
  result := TFhirOperationDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationDefinitionList.InsertItem(index: Integer; value: TFhirOperationDefinition);
begin
  assert(value is TFhirOperationDefinition);
  Inherited Insert(index, value);
end;

function TFhirOperationDefinitionList.Item(index: Integer): TFhirOperationDefinition;
begin
  result := TFhirOperationDefinition(ObjectByIndex[index]);
end;

function TFhirOperationDefinitionList.Link: TFhirOperationDefinitionList;
begin
  result := TFhirOperationDefinitionList(inherited Link);
end;

procedure TFhirOperationDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOperationDefinitionList.SetItemByIndex(index: Integer; value: TFhirOperationDefinition);
begin
  assert(value is TFhirOperationDefinition);
  FhirOperationDefinitions[index] := value;
end;

procedure TFhirOperationDefinitionList.SetItemN(index: Integer; value: TFhirOperationDefinition);
begin
  assert(value is TFhirOperationDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_OPERATIONDEFINITION}

{$IFDEF FHIR_QUESTIONNAIRE}

{ TFhirQuestionnaireGroup }

constructor TFhirQuestionnaireGroup.Create;
begin
  inherited;
end;

destructor TFhirQuestionnaireGroup.Destroy;
begin
  FLinkId.free;
  FTitle.free;
  FConceptList.Free;
  FText.free;
  FRequired.free;
  FRepeats.free;
  FGroupList.Free;
  FQuestionList.Free;
  inherited;
end;

procedure TFhirQuestionnaireGroup.Assign(oSource : TFslObject);
begin
  inherited;
  linkIdElement := TFhirQuestionnaireGroup(oSource).linkIdElement.Clone;
  titleElement := TFhirQuestionnaireGroup(oSource).titleElement.Clone;
  if (TFhirQuestionnaireGroup(oSource).FConceptList = nil) then
  begin
    FConceptList.free;
    FConceptList := nil;
  end
  else
  begin
    if FConceptList = nil then
      FConceptList := TFhirCodingList.Create;
    FConceptList.Assign(TFhirQuestionnaireGroup(oSource).FConceptList);
  end;
  textElement := TFhirQuestionnaireGroup(oSource).textElement.Clone;
  requiredElement := TFhirQuestionnaireGroup(oSource).requiredElement.Clone;
  repeatsElement := TFhirQuestionnaireGroup(oSource).repeatsElement.Clone;
  if (TFhirQuestionnaireGroup(oSource).FGroupList = nil) then
  begin
    FGroupList.free;
    FGroupList := nil;
  end
  else
  begin
    if FGroupList = nil then
      FGroupList := TFhirQuestionnaireGroupList.Create;
    FGroupList.Assign(TFhirQuestionnaireGroup(oSource).FGroupList);
  end;
  if (TFhirQuestionnaireGroup(oSource).FQuestionList = nil) then
  begin
    FQuestionList.free;
    FQuestionList := nil;
  end
  else
  begin
    if FQuestionList = nil then
      FQuestionList := TFhirQuestionnaireGroupQuestionList.Create;
    FQuestionList.Assign(TFhirQuestionnaireGroup(oSource).FQuestionList);
  end;
end;

procedure TFhirQuestionnaireGroup.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'linkId') Then
     list.add(self.link, 'linkId', FLinkId.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'concept') Then
    list.addAll(self, 'concept', FConceptList);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'required') Then
     list.add(self.link, 'required', FRequired.Link);
  if (child_name = 'repeats') Then
     list.add(self.link, 'repeats', FRepeats.Link);
  if (child_name = 'group') Then
    list.addAll(self, 'group', FGroupList);
  if (child_name = 'question') Then
    list.addAll(self, 'question', FQuestionList);
end;

procedure TFhirQuestionnaireGroup.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'linkId', 'string', false, TFhirString, FLinkId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));{2}
  oList.add(TFHIRProperty.create(self, 'concept', 'Coding', true, TFhirCoding, FConceptList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));{2}
  oList.add(TFHIRProperty.create(self, 'required', 'boolean', false, TFhirBoolean, FRequired.Link));{2}
  oList.add(TFHIRProperty.create(self, 'repeats', 'boolean', false, TFhirBoolean, FRepeats.Link));{2}
  oList.add(TFHIRProperty.create(self, 'group', '@Questionnaire.group', true, TFhirQuestionnaireGroup, FGroupList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'question', '', true, TFhirQuestionnaireGroupQuestion, FQuestionList.Link)){3};
end;

function TFhirQuestionnaireGroup.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'linkId') then
  begin
    LinkIdElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'concept') then
  begin
    ConceptList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'required') then
  begin
    RequiredElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'repeats') then
  begin
    RepeatsElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'group') then
  begin
    GroupList.add(propValue as TFhirQuestionnaireGroup){2a};
    result := propValue;
  end
  else if (propName = 'question') then
  begin
    QuestionList.add(propValue as TFhirQuestionnaireGroupQuestion){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirQuestionnaireGroup.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'concept') then ConceptList.insertItem(index, propValue as TFhirCoding){2a}
  else if (propName = 'group') then GroupList.insertItem(index, propValue as TFhirQuestionnaireGroup){2a}
  else if (propName = 'question') then QuestionList.insertItem(index, propValue as TFhirQuestionnaireGroupQuestion){2a}
  else inherited;
end;

function TFhirQuestionnaireGroup.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'linkId') then result := TFhirString.create() {5b}
  else if (propName = 'title') then result := TFhirString.create() {5b}
  else if (propName = 'concept') then result := ConceptList.new(){2}
  else if (propName = 'text') then result := TFhirString.create() {5b}
  else if (propName = 'required') then result := TFhirBoolean.create() {5b}
  else if (propName = 'repeats') then result := TFhirBoolean.create() {5b}
  else if (propName = 'group') then result := GroupList.new(){2}
  else if (propName = 'question') then result := QuestionList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirQuestionnaireGroup.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'linkId') then result := 'string'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'concept') then result := 'Coding'
  else if (propName = 'text') then result := 'string'
  else if (propName = 'required') then result := 'boolean'
  else if (propName = 'repeats') then result := 'boolean'
  else if (propName = 'group') then result := '@Questionnaire.group'
  else if (propName = 'question') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirQuestionnaireGroup.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'linkId') then LinkIdElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'concept') then deletePropertyValue('concept', ConceptList, value) {2}
  else if (propName = 'text') then TextElement := nil
  else if (propName = 'required') then RequiredElement := nil
  else if (propName = 'repeats') then RepeatsElement := nil
  else if (propName = 'group') then deletePropertyValue('group', GroupList, value) {2}
  else if (propName = 'question') then deletePropertyValue('question', QuestionList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirQuestionnaireGroup.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'linkId') then LinkIdElement := asString(new){5b}
  else if (propName = 'title') then TitleElement := asString(new){5b}
  else if (propName = 'concept') then replacePropertyValue('concept', ConceptList, existing, new) {2}
  else if (propName = 'text') then TextElement := asString(new){5b}
  else if (propName = 'required') then RequiredElement := asBoolean(new){5b}
  else if (propName = 'repeats') then RepeatsElement := asBoolean(new){5b}
  else if (propName = 'group') then replacePropertyValue('group', GroupList, existing, new) {2}
  else if (propName = 'question') then replacePropertyValue('question', QuestionList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirQuestionnaireGroup.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'concept') then ConceptList.move(source, destination){2a}
  else if (propName = 'group') then GroupList.move(source, destination){2a}
  else if (propName = 'question') then QuestionList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirQuestionnaireGroup.fhirType : string;
begin
  result := 'group';
end;

function TFhirQuestionnaireGroup.Link : TFhirQuestionnaireGroup;
begin
  result := TFhirQuestionnaireGroup(inherited Link);
end;

function TFhirQuestionnaireGroup.Clone : TFhirQuestionnaireGroup;
begin
  result := TFhirQuestionnaireGroup(inherited Clone);
end;

function TFhirQuestionnaireGroup.equals(other : TObject) : boolean; 
var
  o : TFhirQuestionnaireGroup;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirQuestionnaireGroup)) then
    result := false
  else
  begin
    o := TFhirQuestionnaireGroup(other);
    result := compareDeep(linkIdElement, o.linkIdElement, true) and compareDeep(titleElement, o.titleElement, true) and 
      compareDeep(conceptList, o.conceptList, true) and compareDeep(textElement, o.textElement, true) and 
      compareDeep(requiredElement, o.requiredElement, true) and compareDeep(repeatsElement, o.repeatsElement, true) and 
      compareDeep(groupList, o.groupList, true) and compareDeep(questionList, o.questionList, true);
  end;
end;

function TFhirQuestionnaireGroup.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLinkId) and isEmptyProp(FTitle) and isEmptyProp(FconceptList) and isEmptyProp(FText) and isEmptyProp(FRequired) and isEmptyProp(FRepeats) and isEmptyProp(FgroupList) and isEmptyProp(FquestionList);
end;

procedure TFhirQuestionnaireGroup.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('linkId');
  fields.add('title');
  fields.add('concept');
  fields.add('text');
  fields.add('required');
  fields.add('repeats');
  fields.add('group');
  fields.add('question');
end;

{ TFhirQuestionnaireGroup }

Procedure TFhirQuestionnaireGroup.SetLinkId(value : TFhirString);
begin
  FLinkId.free;
  FLinkId := value;
end;

Function TFhirQuestionnaireGroup.GetLinkIdST : String;
begin
  if FLinkId = nil then
    result := ''
  else
    result := FLinkId.value;
end;

Procedure TFhirQuestionnaireGroup.SetLinkIdST(value : String);
begin
  if value <> '' then
  begin
    if FLinkId = nil then
      FLinkId := TFhirString.create;
    FLinkId.value := value
  end
  else if FLinkId <> nil then
    FLinkId.value := '';
end;

Procedure TFhirQuestionnaireGroup.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

Function TFhirQuestionnaireGroup.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

Procedure TFhirQuestionnaireGroup.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

Function TFhirQuestionnaireGroup.GetConceptList : TFhirCodingList;
begin
  if FConceptList = nil then
    FConceptList := TFhirCodingList.Create;
  result := FConceptList;
end;

Function TFhirQuestionnaireGroup.GetHasConceptList : boolean;
begin
  result := (FConceptList <> nil) and (FConceptList.count > 0);
end;

Procedure TFhirQuestionnaireGroup.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

Function TFhirQuestionnaireGroup.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

Procedure TFhirQuestionnaireGroup.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

Procedure TFhirQuestionnaireGroup.SetRequired(value : TFhirBoolean);
begin
  FRequired.free;
  FRequired := value;
end;

Function TFhirQuestionnaireGroup.GetRequiredST : Boolean;
begin
  if FRequired = nil then
    result := false
  else
    result := FRequired.value;
end;

Procedure TFhirQuestionnaireGroup.SetRequiredST(value : Boolean);
begin
  if FRequired = nil then
    FRequired := TFhirBoolean.create;
  FRequired.value := value
end;

Procedure TFhirQuestionnaireGroup.SetRepeats(value : TFhirBoolean);
begin
  FRepeats.free;
  FRepeats := value;
end;

Function TFhirQuestionnaireGroup.GetRepeatsST : Boolean;
begin
  if FRepeats = nil then
    result := false
  else
    result := FRepeats.value;
end;

Procedure TFhirQuestionnaireGroup.SetRepeatsST(value : Boolean);
begin
  if FRepeats = nil then
    FRepeats := TFhirBoolean.create;
  FRepeats.value := value
end;

Function TFhirQuestionnaireGroup.GetGroupList : TFhirQuestionnaireGroupList;
begin
  if FGroupList = nil then
    FGroupList := TFhirQuestionnaireGroupList.Create;
  result := FGroupList;
end;

Function TFhirQuestionnaireGroup.GetHasGroupList : boolean;
begin
  result := (FGroupList <> nil) and (FGroupList.count > 0);
end;

Function TFhirQuestionnaireGroup.GetQuestionList : TFhirQuestionnaireGroupQuestionList;
begin
  if FQuestionList = nil then
    FQuestionList := TFhirQuestionnaireGroupQuestionList.Create;
  result := FQuestionList;
end;

Function TFhirQuestionnaireGroup.GetHasQuestionList : boolean;
begin
  result := (FQuestionList <> nil) and (FQuestionList.count > 0);
end;

function TFhirQuestionnaireGroup.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FLinkId.sizeInBytes);
  inc(result, FTitle.sizeInBytes);
  inc(result, FconceptList.sizeInBytes);
  inc(result, FText.sizeInBytes);
  inc(result, FRequired.sizeInBytes);
  inc(result, FRepeats.sizeInBytes);
  inc(result, FgroupList.sizeInBytes);
  inc(result, FquestionList.sizeInBytes);
end;

{ TFhirQuestionnaireGroupListEnumerator }

Constructor TFhirQuestionnaireGroupListEnumerator.Create(list : TFhirQuestionnaireGroupList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirQuestionnaireGroupListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirQuestionnaireGroupListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirQuestionnaireGroupListEnumerator.GetCurrent : TFhirQuestionnaireGroup;
begin
  Result := FList[FIndex];
end;

function TFhirQuestionnaireGroupListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirQuestionnaireGroupList }
procedure TFhirQuestionnaireGroupList.AddItem(value: TFhirQuestionnaireGroup);
begin
  assert(value.ClassName = 'TFhirQuestionnaireGroup', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirQuestionnaireGroup');
  add(value);
end;

function TFhirQuestionnaireGroupList.Append: TFhirQuestionnaireGroup;
begin
  result := TFhirQuestionnaireGroup.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireGroupList.ClearItems;
begin
  Clear;
end;

function TFhirQuestionnaireGroupList.GetEnumerator : TFhirQuestionnaireGroupListEnumerator;
begin
  result := TFhirQuestionnaireGroupListEnumerator.Create(self.link);
end;

function TFhirQuestionnaireGroupList.Clone: TFhirQuestionnaireGroupList;
begin
  result := TFhirQuestionnaireGroupList(inherited Clone);
end;

function TFhirQuestionnaireGroupList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirQuestionnaireGroupList.GetItemN(index: Integer): TFhirQuestionnaireGroup;
begin
  result := TFhirQuestionnaireGroup(ObjectByIndex[index]);
end;

function TFhirQuestionnaireGroupList.ItemClass: TFslObjectClass;
begin
  result := TFhirQuestionnaireGroup;
end;
function TFhirQuestionnaireGroupList.IndexOf(value: TFhirQuestionnaireGroup): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirQuestionnaireGroupList.Insert(index: Integer): TFhirQuestionnaireGroup;
begin
  result := TFhirQuestionnaireGroup.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireGroupList.InsertItem(index: Integer; value: TFhirQuestionnaireGroup);
begin
  assert(value is TFhirQuestionnaireGroup);
  Inherited Insert(index, value);
end;

function TFhirQuestionnaireGroupList.Item(index: Integer): TFhirQuestionnaireGroup;
begin
  result := TFhirQuestionnaireGroup(ObjectByIndex[index]);
end;

function TFhirQuestionnaireGroupList.Link: TFhirQuestionnaireGroupList;
begin
  result := TFhirQuestionnaireGroupList(inherited Link);
end;

procedure TFhirQuestionnaireGroupList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirQuestionnaireGroupList.SetItemByIndex(index: Integer; value: TFhirQuestionnaireGroup);
begin
  assert(value is TFhirQuestionnaireGroup);
  FhirQuestionnaireGroups[index] := value;
end;

procedure TFhirQuestionnaireGroupList.SetItemN(index: Integer; value: TFhirQuestionnaireGroup);
begin
  assert(value is TFhirQuestionnaireGroup);
  ObjectByIndex[index] := value;
end;

{ TFhirQuestionnaireGroupQuestion }

constructor TFhirQuestionnaireGroupQuestion.Create;
begin
  inherited;
end;

destructor TFhirQuestionnaireGroupQuestion.Destroy;
begin
  FLinkId.free;
  FConceptList.Free;
  FText.free;
  FType_.free;
  FRequired.free;
  FRepeats.free;
  FOptions.free;
  FOptionList.Free;
  FGroupList.Free;
  inherited;
end;

procedure TFhirQuestionnaireGroupQuestion.Assign(oSource : TFslObject);
begin
  inherited;
  linkIdElement := TFhirQuestionnaireGroupQuestion(oSource).linkIdElement.Clone;
  if (TFhirQuestionnaireGroupQuestion(oSource).FConceptList = nil) then
  begin
    FConceptList.free;
    FConceptList := nil;
  end
  else
  begin
    if FConceptList = nil then
      FConceptList := TFhirCodingList.Create;
    FConceptList.Assign(TFhirQuestionnaireGroupQuestion(oSource).FConceptList);
  end;
  textElement := TFhirQuestionnaireGroupQuestion(oSource).textElement.Clone;
  FType_ := TFhirQuestionnaireGroupQuestion(oSource).FType_.Link;
  requiredElement := TFhirQuestionnaireGroupQuestion(oSource).requiredElement.Clone;
  repeatsElement := TFhirQuestionnaireGroupQuestion(oSource).repeatsElement.Clone;
  options := TFhirQuestionnaireGroupQuestion(oSource).options.Clone;
  if (TFhirQuestionnaireGroupQuestion(oSource).FOptionList = nil) then
  begin
    FOptionList.free;
    FOptionList := nil;
  end
  else
  begin
    if FOptionList = nil then
      FOptionList := TFhirCodingList.Create;
    FOptionList.Assign(TFhirQuestionnaireGroupQuestion(oSource).FOptionList);
  end;
  if (TFhirQuestionnaireGroupQuestion(oSource).FGroupList = nil) then
  begin
    FGroupList.free;
    FGroupList := nil;
  end
  else
  begin
    if FGroupList = nil then
      FGroupList := TFhirQuestionnaireGroupList.Create;
    FGroupList.Assign(TFhirQuestionnaireGroupQuestion(oSource).FGroupList);
  end;
end;

procedure TFhirQuestionnaireGroupQuestion.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'linkId') Then
     list.add(self.link, 'linkId', FLinkId.Link);
  if (child_name = 'concept') Then
    list.addAll(self, 'concept', FConceptList);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'required') Then
     list.add(self.link, 'required', FRequired.Link);
  if (child_name = 'repeats') Then
     list.add(self.link, 'repeats', FRepeats.Link);
  if (child_name = 'options') Then
     list.add(self.link, 'options', FOptions.Link);
  if (child_name = 'option') Then
    list.addAll(self, 'option', FOptionList);
  if (child_name = 'group') Then
    list.addAll(self, 'group', FGroupList);
end;

procedure TFhirQuestionnaireGroupQuestion.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'linkId', 'string', false, TFhirString, FLinkId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'concept', 'Coding', true, TFhirCoding, FConceptList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'required', 'boolean', false, TFhirBoolean, FRequired.Link));{2}
  oList.add(TFHIRProperty.create(self, 'repeats', 'boolean', false, TFhirBoolean, FRepeats.Link));{2}
  oList.add(TFHIRProperty.create(self, 'options', 'Reference(ValueSet)', false, TFhirReference{TFhirValueSet}, FOptions.Link));{2}
  oList.add(TFHIRProperty.create(self, 'option', 'Coding', true, TFhirCoding, FOptionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'group', '@Questionnaire.group', true, TFhirQuestionnaireGroup, FGroupList.Link)){3};
end;

function TFhirQuestionnaireGroupQuestion.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'linkId') then
  begin
    LinkIdElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'concept') then
  begin
    ConceptList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirAnswerFormatEnum, CODES_TFhirAnswerFormatEnum, propValue);
    result := propValue
  end
  else if (propName = 'required') then
  begin
    RequiredElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'repeats') then
  begin
    RepeatsElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'options') then
  begin
    Options := propValue as TFhirReference{TFhirValueSet}{4b};
    result := propValue;
  end
  else if (propName = 'option') then
  begin
    OptionList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else if (propName = 'group') then
  begin
    GroupList.add(propValue as TFhirQuestionnaireGroup){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirQuestionnaireGroupQuestion.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'concept') then ConceptList.insertItem(index, propValue as TFhirCoding){2a}
  else if (propName = 'option') then OptionList.insertItem(index, propValue as TFhirCoding){2a}
  else if (propName = 'group') then GroupList.insertItem(index, propValue as TFhirQuestionnaireGroup){2a}
  else inherited;
end;

function TFhirQuestionnaireGroupQuestion.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'linkId') then result := TFhirString.create() {5b}
  else if (propName = 'concept') then result := ConceptList.new(){2}
  else if (propName = 'text') then result := TFhirString.create() {5b}
  else if (propName = 'required') then result := TFhirBoolean.create() {5b}
  else if (propName = 'repeats') then result := TFhirBoolean.create() {5b}
  else if (propName = 'options') then result := TFhirReference{TFhirValueSet}.create(){4b}
  else if (propName = 'option') then result := OptionList.new(){2}
  else if (propName = 'group') then result := GroupList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirQuestionnaireGroupQuestion.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'linkId') then result := 'string'
  else if (propName = 'concept') then result := 'Coding'
  else if (propName = 'text') then result := 'string'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'required') then result := 'boolean'
  else if (propName = 'repeats') then result := 'boolean'
  else if (propName = 'options') then result := 'Reference'
  else if (propName = 'option') then result := 'Coding'
  else if (propName = 'group') then result := '@Questionnaire.group'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirQuestionnaireGroupQuestion.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'linkId') then LinkIdElement := nil
  else if (propName = 'concept') then deletePropertyValue('concept', ConceptList, value) {2}
  else if (propName = 'text') then TextElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'required') then RequiredElement := nil
  else if (propName = 'repeats') then RepeatsElement := nil
  else if (propName = 'options') then OptionsElement := nil
  else if (propName = 'option') then deletePropertyValue('option', OptionList, value) {2}
  else if (propName = 'group') then deletePropertyValue('group', GroupList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirQuestionnaireGroupQuestion.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'linkId') then LinkIdElement := asString(new){5b}
  else if (propName = 'concept') then replacePropertyValue('concept', ConceptList, existing, new) {2}
  else if (propName = 'text') then TextElement := asString(new){5b}
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirAnswerFormatEnum, CODES_TFhirAnswerFormatEnum, new){4}
  else if (propName = 'required') then RequiredElement := asBoolean(new){5b}
  else if (propName = 'repeats') then RepeatsElement := asBoolean(new){5b}
  else if (propName = 'options') then OptionsElement := new as TFhirReference{TFhirValueSet}{4}
  else if (propName = 'option') then replacePropertyValue('option', OptionList, existing, new) {2}
  else if (propName = 'group') then replacePropertyValue('group', GroupList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirQuestionnaireGroupQuestion.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'concept') then ConceptList.move(source, destination){2a}
  else if (propName = 'option') then OptionList.move(source, destination){2a}
  else if (propName = 'group') then GroupList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirQuestionnaireGroupQuestion.fhirType : string;
begin
  result := 'question';
end;

function TFhirQuestionnaireGroupQuestion.Link : TFhirQuestionnaireGroupQuestion;
begin
  result := TFhirQuestionnaireGroupQuestion(inherited Link);
end;

function TFhirQuestionnaireGroupQuestion.Clone : TFhirQuestionnaireGroupQuestion;
begin
  result := TFhirQuestionnaireGroupQuestion(inherited Clone);
end;

function TFhirQuestionnaireGroupQuestion.equals(other : TObject) : boolean; 
var
  o : TFhirQuestionnaireGroupQuestion;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirQuestionnaireGroupQuestion)) then
    result := false
  else
  begin
    o := TFhirQuestionnaireGroupQuestion(other);
    result := compareDeep(linkIdElement, o.linkIdElement, true) and compareDeep(conceptList, o.conceptList, true) and 
      compareDeep(textElement, o.textElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(requiredElement, o.requiredElement, true) and compareDeep(repeatsElement, o.repeatsElement, true) and 
      compareDeep(optionsElement, o.optionsElement, true) and compareDeep(optionList, o.optionList, true) and 
      compareDeep(groupList, o.groupList, true);
  end;
end;

function TFhirQuestionnaireGroupQuestion.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLinkId) and isEmptyProp(FconceptList) and isEmptyProp(FText) and isEmptyProp(FType_) and isEmptyProp(FRequired) and isEmptyProp(FRepeats) and isEmptyProp(FOptions) and isEmptyProp(FoptionList) and isEmptyProp(FgroupList);
end;

procedure TFhirQuestionnaireGroupQuestion.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('linkId');
  fields.add('concept');
  fields.add('text');
  fields.add('type');
  fields.add('required');
  fields.add('repeats');
  fields.add('options');
  fields.add('option');
  fields.add('group');
end;

{ TFhirQuestionnaireGroupQuestion }

Procedure TFhirQuestionnaireGroupQuestion.SetLinkId(value : TFhirString);
begin
  FLinkId.free;
  FLinkId := value;
end;

Function TFhirQuestionnaireGroupQuestion.GetLinkIdST : String;
begin
  if FLinkId = nil then
    result := ''
  else
    result := FLinkId.value;
end;

Procedure TFhirQuestionnaireGroupQuestion.SetLinkIdST(value : String);
begin
  if value <> '' then
  begin
    if FLinkId = nil then
      FLinkId := TFhirString.create;
    FLinkId.value := value
  end
  else if FLinkId <> nil then
    FLinkId.value := '';
end;

Function TFhirQuestionnaireGroupQuestion.GetConceptList : TFhirCodingList;
begin
  if FConceptList = nil then
    FConceptList := TFhirCodingList.Create;
  result := FConceptList;
end;

Function TFhirQuestionnaireGroupQuestion.GetHasConceptList : boolean;
begin
  result := (FConceptList <> nil) and (FConceptList.count > 0);
end;

Procedure TFhirQuestionnaireGroupQuestion.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

Function TFhirQuestionnaireGroupQuestion.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

Procedure TFhirQuestionnaireGroupQuestion.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

Procedure TFhirQuestionnaireGroupQuestion.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirQuestionnaireGroupQuestion.GetType_ST : TFhirAnswerFormatEnum;
begin
  if FType_ = nil then
    result := TFhirAnswerFormatEnum(0)
  else
    result := TFhirAnswerFormatEnum(StringArrayIndexOfSensitive(CODES_TFhirAnswerFormatEnum, FType_.value));
end;

Procedure TFhirQuestionnaireGroupQuestion.SetType_ST(value : TFhirAnswerFormatEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirAnswerFormatEnum[value], CODES_TFhirAnswerFormatEnum[value]);
end;

Procedure TFhirQuestionnaireGroupQuestion.SetRequired(value : TFhirBoolean);
begin
  FRequired.free;
  FRequired := value;
end;

Function TFhirQuestionnaireGroupQuestion.GetRequiredST : Boolean;
begin
  if FRequired = nil then
    result := false
  else
    result := FRequired.value;
end;

Procedure TFhirQuestionnaireGroupQuestion.SetRequiredST(value : Boolean);
begin
  if FRequired = nil then
    FRequired := TFhirBoolean.create;
  FRequired.value := value
end;

Procedure TFhirQuestionnaireGroupQuestion.SetRepeats(value : TFhirBoolean);
begin
  FRepeats.free;
  FRepeats := value;
end;

Function TFhirQuestionnaireGroupQuestion.GetRepeatsST : Boolean;
begin
  if FRepeats = nil then
    result := false
  else
    result := FRepeats.value;
end;

Procedure TFhirQuestionnaireGroupQuestion.SetRepeatsST(value : Boolean);
begin
  if FRepeats = nil then
    FRepeats := TFhirBoolean.create;
  FRepeats.value := value
end;

Procedure TFhirQuestionnaireGroupQuestion.SetOptions(value : TFhirReference{TFhirValueSet});
begin
  FOptions.free;
  FOptions := value;
end;

Function TFhirQuestionnaireGroupQuestion.GetOptionList : TFhirCodingList;
begin
  if FOptionList = nil then
    FOptionList := TFhirCodingList.Create;
  result := FOptionList;
end;

Function TFhirQuestionnaireGroupQuestion.GetHasOptionList : boolean;
begin
  result := (FOptionList <> nil) and (FOptionList.count > 0);
end;

Function TFhirQuestionnaireGroupQuestion.GetGroupList : TFhirQuestionnaireGroupList;
begin
  if FGroupList = nil then
    FGroupList := TFhirQuestionnaireGroupList.Create;
  result := FGroupList;
end;

Function TFhirQuestionnaireGroupQuestion.GetHasGroupList : boolean;
begin
  result := (FGroupList <> nil) and (FGroupList.count > 0);
end;

function TFhirQuestionnaireGroupQuestion.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FLinkId.sizeInBytes);
  inc(result, FconceptList.sizeInBytes);
  inc(result, FText.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FRequired.sizeInBytes);
  inc(result, FRepeats.sizeInBytes);
  inc(result, FOptions.sizeInBytes);
  inc(result, FoptionList.sizeInBytes);
  inc(result, FgroupList.sizeInBytes);
end;

{ TFhirQuestionnaireGroupQuestionListEnumerator }

Constructor TFhirQuestionnaireGroupQuestionListEnumerator.Create(list : TFhirQuestionnaireGroupQuestionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirQuestionnaireGroupQuestionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirQuestionnaireGroupQuestionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirQuestionnaireGroupQuestionListEnumerator.GetCurrent : TFhirQuestionnaireGroupQuestion;
begin
  Result := FList[FIndex];
end;

function TFhirQuestionnaireGroupQuestionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirQuestionnaireGroupQuestionList }
procedure TFhirQuestionnaireGroupQuestionList.AddItem(value: TFhirQuestionnaireGroupQuestion);
begin
  assert(value.ClassName = 'TFhirQuestionnaireGroupQuestion', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirQuestionnaireGroupQuestion');
  add(value);
end;

function TFhirQuestionnaireGroupQuestionList.Append: TFhirQuestionnaireGroupQuestion;
begin
  result := TFhirQuestionnaireGroupQuestion.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireGroupQuestionList.ClearItems;
begin
  Clear;
end;

function TFhirQuestionnaireGroupQuestionList.GetEnumerator : TFhirQuestionnaireGroupQuestionListEnumerator;
begin
  result := TFhirQuestionnaireGroupQuestionListEnumerator.Create(self.link);
end;

function TFhirQuestionnaireGroupQuestionList.Clone: TFhirQuestionnaireGroupQuestionList;
begin
  result := TFhirQuestionnaireGroupQuestionList(inherited Clone);
end;

function TFhirQuestionnaireGroupQuestionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirQuestionnaireGroupQuestionList.GetItemN(index: Integer): TFhirQuestionnaireGroupQuestion;
begin
  result := TFhirQuestionnaireGroupQuestion(ObjectByIndex[index]);
end;

function TFhirQuestionnaireGroupQuestionList.ItemClass: TFslObjectClass;
begin
  result := TFhirQuestionnaireGroupQuestion;
end;
function TFhirQuestionnaireGroupQuestionList.IndexOf(value: TFhirQuestionnaireGroupQuestion): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirQuestionnaireGroupQuestionList.Insert(index: Integer): TFhirQuestionnaireGroupQuestion;
begin
  result := TFhirQuestionnaireGroupQuestion.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireGroupQuestionList.InsertItem(index: Integer; value: TFhirQuestionnaireGroupQuestion);
begin
  assert(value is TFhirQuestionnaireGroupQuestion);
  Inherited Insert(index, value);
end;

function TFhirQuestionnaireGroupQuestionList.Item(index: Integer): TFhirQuestionnaireGroupQuestion;
begin
  result := TFhirQuestionnaireGroupQuestion(ObjectByIndex[index]);
end;

function TFhirQuestionnaireGroupQuestionList.Link: TFhirQuestionnaireGroupQuestionList;
begin
  result := TFhirQuestionnaireGroupQuestionList(inherited Link);
end;

procedure TFhirQuestionnaireGroupQuestionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirQuestionnaireGroupQuestionList.SetItemByIndex(index: Integer; value: TFhirQuestionnaireGroupQuestion);
begin
  assert(value is TFhirQuestionnaireGroupQuestion);
  FhirQuestionnaireGroupQuestions[index] := value;
end;

procedure TFhirQuestionnaireGroupQuestionList.SetItemN(index: Integer; value: TFhirQuestionnaireGroupQuestion);
begin
  assert(value is TFhirQuestionnaireGroupQuestion);
  ObjectByIndex[index] := value;
end;

{ TFhirQuestionnaire }

constructor TFhirQuestionnaire.Create;
begin
  inherited;
end;

destructor TFhirQuestionnaire.Destroy;
begin
  FIdentifierList.Free;
  FVersion.free;
  FStatus.free;
  FDate.free;
  FPublisher.free;
  FTelecomList.Free;
  FSubjectType.Free;
  FGroup.free;
  inherited;
end;

function TFhirQuestionnaire.GetResourceType : TFhirResourceType;
begin
  result := frtQuestionnaire;
end;

procedure TFhirQuestionnaire.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirQuestionnaire(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirQuestionnaire(oSource).FIdentifierList);
  end;
  versionElement := TFhirQuestionnaire(oSource).versionElement.Clone;
  FStatus := TFhirQuestionnaire(oSource).FStatus.Link;
  dateElement := TFhirQuestionnaire(oSource).dateElement.Clone;
  publisherElement := TFhirQuestionnaire(oSource).publisherElement.Clone;
  if (TFhirQuestionnaire(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirQuestionnaire(oSource).FTelecomList);
  end;
  if (TFhirQuestionnaire(oSource).FSubjectType = nil) then
  begin
    FSubjectType.free;
    FSubjectType := nil;
  end
  else
  begin
    FSubjectType := TFHIREnumList.Create(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum);
    FSubjectType.Assign(TFhirQuestionnaire(oSource).FSubjectType);
  end;
  group := TFhirQuestionnaire(oSource).group.Clone;
end;

procedure TFhirQuestionnaire.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'subjectType') Then
     list.addAll(self, 'subjectType', FSubjectType);
  if (child_name = 'group') Then
     list.add(self.link, 'group', FGroup.Link);
end;

procedure TFhirQuestionnaire.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'publisher', 'string', false, TFhirString, FPublisher.Link));{2}
  oList.add(TFHIRProperty.create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'subjectType', 'code', true, TFHIREnum, FSubjectType.Link)){3};
  oList.add(TFHIRProperty.create(self, 'group', '', false, TFhirQuestionnaireGroup, FGroup.Link));{2}
end;

function TFhirQuestionnaire.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirQuestionnaireStatusEnum, CODES_TFhirQuestionnaireStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    PublisherElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint){2a};
    result := propValue;
  end
  else if (propName = 'subjectType') then
  begin
    SubjectTypeList.add(asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue)); {1}
    result := propValue;
  end
  else if (propName = 'group') then
  begin
    Group := propValue as TFhirQuestionnaireGroup{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirQuestionnaire.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint){2a}
  else if (propName = 'subjectType') then FSubjectType.insertItem(index, asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue)) {1}
  else inherited;
end;

function TFhirQuestionnaire.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'version') then result := TFhirString.create() {5b}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'publisher') then result := TFhirString.create() {5b}
  else if (propName = 'telecom') then result := TelecomList.new(){2}
  else if (propName = 'group') then result := TFhirQuestionnaireGroup.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirQuestionnaire.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'publisher') then result := 'string'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'subjectType') then result := 'code'
  else if (propName = 'group') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirQuestionnaire.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value) {2}
  else if (propName = 'group') then GroupElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirQuestionnaire.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'version') then VersionElement := asString(new){5b}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirQuestionnaireStatusEnum, CODES_TFhirQuestionnaireStatusEnum, new){4}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'publisher') then PublisherElement := asString(new){5b}
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new) {2}
  else if (propName = 'group') then GroupElement := new as TFhirQuestionnaireGroup{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirQuestionnaire.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'telecom') then TelecomList.move(source, destination){2a}
  else if (propName = 'subjectType') then FSubjectType.move(source, destination) {1}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirQuestionnaire.fhirType : string;
begin
  result := 'Questionnaire';
end;

function TFhirQuestionnaire.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FVersion) and isEmptyProp(FStatus) and isEmptyProp(FDate) and isEmptyProp(FPublisher) and isEmptyProp(FtelecomList) and isEmptyProp(FSubjectType) and isEmptyProp(FGroup);
end;

function TFhirQuestionnaire.equals(other : TObject) : boolean; 
var
  o : TFhirQuestionnaire;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirQuestionnaire)) then
    result := false
  else
  begin
    o := TFhirQuestionnaire(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(versionElement, o.versionElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(dateElement, o.dateElement, true) and 
      compareDeep(publisherElement, o.publisherElement, true) and compareDeep(telecomList, o.telecomList, true) and 
      compareDeep(subjectTypeList, o.subjectTypeList, true) and compareDeep(groupElement, o.groupElement, true);
  end;
end;

function TFhirQuestionnaire.Link : TFhirQuestionnaire;
begin
  result := TFhirQuestionnaire(inherited Link);
end;

function TFhirQuestionnaire.Clone : TFhirQuestionnaire;
begin
  result := TFhirQuestionnaire(inherited Clone);
end;

procedure TFhirQuestionnaire.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('version');
  fields.add('status');
  fields.add('date');
  fields.add('publisher');
  fields.add('telecom');
  fields.add('subjectType');
  fields.add('group');
end;

{ TFhirQuestionnaire }

Function TFhirQuestionnaire.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirQuestionnaire.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirQuestionnaire.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

Function TFhirQuestionnaire.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

Procedure TFhirQuestionnaire.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

Procedure TFhirQuestionnaire.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirQuestionnaire.GetStatusST : TFhirQuestionnaireStatusEnum;
begin
  if FStatus = nil then
    result := TFhirQuestionnaireStatusEnum(0)
  else
    result := TFhirQuestionnaireStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirQuestionnaireStatusEnum, FStatus.value));
end;

Procedure TFhirQuestionnaire.SetStatusST(value : TFhirQuestionnaireStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirQuestionnaireStatusEnum[value], CODES_TFhirQuestionnaireStatusEnum[value]);
end;

Procedure TFhirQuestionnaire.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirQuestionnaire.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirQuestionnaire.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirQuestionnaire.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

Function TFhirQuestionnaire.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

Procedure TFhirQuestionnaire.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

Function TFhirQuestionnaire.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

Function TFhirQuestionnaire.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

Function TFhirQuestionnaire.GetSubjectType : TFhirEnumList;
begin
  if FSubjectType = nil then
    FSubjectType := TFHIREnumList.Create(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum);
  result := FSubjectType;
end;

Function TFhirQuestionnaire.GetHasSubjectType : boolean;
begin
  result := (FSubjectType <> nil) and (FSubjectType.count > 0);
end;

Procedure TFhirQuestionnaire.SetGroup(value : TFhirQuestionnaireGroup);
begin
  FGroup.free;
  FGroup := value;
end;

function TFhirQuestionnaire.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FVersion.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FPublisher.sizeInBytes);
  inc(result, FtelecomList.sizeInBytes);
  inc(result, FSubjectType.sizeInBytes);
  inc(result, FGroup.sizeInBytes);
end;

{ TFhirQuestionnaireListEnumerator }

Constructor TFhirQuestionnaireListEnumerator.Create(list : TFhirQuestionnaireList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirQuestionnaireListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirQuestionnaireListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirQuestionnaireListEnumerator.GetCurrent : TFhirQuestionnaire;
begin
  Result := FList[FIndex];
end;

function TFhirQuestionnaireListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirQuestionnaireList }
procedure TFhirQuestionnaireList.AddItem(value: TFhirQuestionnaire);
begin
  assert(value.ClassName = 'TFhirQuestionnaire', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirQuestionnaire');
  add(value);
end;

function TFhirQuestionnaireList.Append: TFhirQuestionnaire;
begin
  result := TFhirQuestionnaire.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireList.ClearItems;
begin
  Clear;
end;

function TFhirQuestionnaireList.GetEnumerator : TFhirQuestionnaireListEnumerator;
begin
  result := TFhirQuestionnaireListEnumerator.Create(self.link);
end;

function TFhirQuestionnaireList.Clone: TFhirQuestionnaireList;
begin
  result := TFhirQuestionnaireList(inherited Clone);
end;

function TFhirQuestionnaireList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirQuestionnaireList.GetItemN(index: Integer): TFhirQuestionnaire;
begin
  result := TFhirQuestionnaire(ObjectByIndex[index]);
end;

function TFhirQuestionnaireList.ItemClass: TFslObjectClass;
begin
  result := TFhirQuestionnaire;
end;
function TFhirQuestionnaireList.IndexOf(value: TFhirQuestionnaire): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirQuestionnaireList.Insert(index: Integer): TFhirQuestionnaire;
begin
  result := TFhirQuestionnaire.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireList.InsertItem(index: Integer; value: TFhirQuestionnaire);
begin
  assert(value is TFhirQuestionnaire);
  Inherited Insert(index, value);
end;

function TFhirQuestionnaireList.Item(index: Integer): TFhirQuestionnaire;
begin
  result := TFhirQuestionnaire(ObjectByIndex[index]);
end;

function TFhirQuestionnaireList.Link: TFhirQuestionnaireList;
begin
  result := TFhirQuestionnaireList(inherited Link);
end;

procedure TFhirQuestionnaireList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirQuestionnaireList.SetItemByIndex(index: Integer; value: TFhirQuestionnaire);
begin
  assert(value is TFhirQuestionnaire);
  FhirQuestionnaires[index] := value;
end;

procedure TFhirQuestionnaireList.SetItemN(index: Integer; value: TFhirQuestionnaire);
begin
  assert(value is TFhirQuestionnaire);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_QUESTIONNAIRE}

{$IFDEF FHIR_SEARCHPARAMETER}

{ TFhirSearchParameterContact }

constructor TFhirSearchParameterContact.Create;
begin
  inherited;
end;

destructor TFhirSearchParameterContact.Destroy;
begin
  FName.free;
  FTelecomList.Free;
  inherited;
end;

procedure TFhirSearchParameterContact.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirSearchParameterContact(oSource).nameElement.Clone;
  if (TFhirSearchParameterContact(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirSearchParameterContact(oSource).FTelecomList);
  end;
end;

procedure TFhirSearchParameterContact.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
end;

procedure TFhirSearchParameterContact.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link)){3};
end;

function TFhirSearchParameterContact.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSearchParameterContact.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint){2a}
  else inherited;
end;

function TFhirSearchParameterContact.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'telecom') then result := TelecomList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSearchParameterContact.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSearchParameterContact.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSearchParameterContact.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSearchParameterContact.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'telecom') then TelecomList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSearchParameterContact.fhirType : string;
begin
  result := 'contact';
end;

function TFhirSearchParameterContact.Link : TFhirSearchParameterContact;
begin
  result := TFhirSearchParameterContact(inherited Link);
end;

function TFhirSearchParameterContact.Clone : TFhirSearchParameterContact;
begin
  result := TFhirSearchParameterContact(inherited Clone);
end;

function TFhirSearchParameterContact.equals(other : TObject) : boolean; 
var
  o : TFhirSearchParameterContact;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSearchParameterContact)) then
    result := false
  else
  begin
    o := TFhirSearchParameterContact(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(telecomList, o.telecomList, true);
  end;
end;

function TFhirSearchParameterContact.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FtelecomList);
end;

procedure TFhirSearchParameterContact.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('telecom');
end;

{ TFhirSearchParameterContact }

Procedure TFhirSearchParameterContact.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirSearchParameterContact.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirSearchParameterContact.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Function TFhirSearchParameterContact.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

Function TFhirSearchParameterContact.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

function TFhirSearchParameterContact.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FtelecomList.sizeInBytes);
end;

{ TFhirSearchParameterContactListEnumerator }

Constructor TFhirSearchParameterContactListEnumerator.Create(list : TFhirSearchParameterContactList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSearchParameterContactListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSearchParameterContactListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSearchParameterContactListEnumerator.GetCurrent : TFhirSearchParameterContact;
begin
  Result := FList[FIndex];
end;

function TFhirSearchParameterContactListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSearchParameterContactList }
procedure TFhirSearchParameterContactList.AddItem(value: TFhirSearchParameterContact);
begin
  assert(value.ClassName = 'TFhirSearchParameterContact', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSearchParameterContact');
  add(value);
end;

function TFhirSearchParameterContactList.Append: TFhirSearchParameterContact;
begin
  result := TFhirSearchParameterContact.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSearchParameterContactList.ClearItems;
begin
  Clear;
end;

function TFhirSearchParameterContactList.GetEnumerator : TFhirSearchParameterContactListEnumerator;
begin
  result := TFhirSearchParameterContactListEnumerator.Create(self.link);
end;

function TFhirSearchParameterContactList.Clone: TFhirSearchParameterContactList;
begin
  result := TFhirSearchParameterContactList(inherited Clone);
end;

function TFhirSearchParameterContactList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSearchParameterContactList.GetItemN(index: Integer): TFhirSearchParameterContact;
begin
  result := TFhirSearchParameterContact(ObjectByIndex[index]);
end;

function TFhirSearchParameterContactList.ItemClass: TFslObjectClass;
begin
  result := TFhirSearchParameterContact;
end;
function TFhirSearchParameterContactList.IndexOf(value: TFhirSearchParameterContact): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSearchParameterContactList.Insert(index: Integer): TFhirSearchParameterContact;
begin
  result := TFhirSearchParameterContact.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSearchParameterContactList.InsertItem(index: Integer; value: TFhirSearchParameterContact);
begin
  assert(value is TFhirSearchParameterContact);
  Inherited Insert(index, value);
end;

function TFhirSearchParameterContactList.Item(index: Integer): TFhirSearchParameterContact;
begin
  result := TFhirSearchParameterContact(ObjectByIndex[index]);
end;

function TFhirSearchParameterContactList.Link: TFhirSearchParameterContactList;
begin
  result := TFhirSearchParameterContactList(inherited Link);
end;

procedure TFhirSearchParameterContactList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSearchParameterContactList.SetItemByIndex(index: Integer; value: TFhirSearchParameterContact);
begin
  assert(value is TFhirSearchParameterContact);
  FhirSearchParameterContacts[index] := value;
end;

procedure TFhirSearchParameterContactList.SetItemN(index: Integer; value: TFhirSearchParameterContact);
begin
  assert(value is TFhirSearchParameterContact);
  ObjectByIndex[index] := value;
end;

{ TFhirSearchParameter }

constructor TFhirSearchParameter.Create;
begin
  inherited;
end;

destructor TFhirSearchParameter.Destroy;
begin
  FUrl.free;
  FName.free;
  FStatus.free;
  FExperimental.free;
  FPublisher.free;
  FContactList.Free;
  FDate.free;
  FRequirements.free;
  FCode.free;
  FBase.free;
  FType_.free;
  FDescription.free;
  FXpath.free;
  FXpathUsage.free;
  FTarget.Free;
  inherited;
end;

function TFhirSearchParameter.GetResourceType : TFhirResourceType;
begin
  result := frtSearchParameter;
end;

procedure TFhirSearchParameter.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirSearchParameter(oSource).urlElement.Clone;
  nameElement := TFhirSearchParameter(oSource).nameElement.Clone;
  FStatus := TFhirSearchParameter(oSource).FStatus.Link;
  experimentalElement := TFhirSearchParameter(oSource).experimentalElement.Clone;
  publisherElement := TFhirSearchParameter(oSource).publisherElement.Clone;
  if (TFhirSearchParameter(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirSearchParameterContactList.Create;
    FContactList.Assign(TFhirSearchParameter(oSource).FContactList);
  end;
  dateElement := TFhirSearchParameter(oSource).dateElement.Clone;
  requirementsElement := TFhirSearchParameter(oSource).requirementsElement.Clone;
  codeElement := TFhirSearchParameter(oSource).codeElement.Clone;
  FBase := TFhirSearchParameter(oSource).FBase.Link;
  FType_ := TFhirSearchParameter(oSource).FType_.Link;
  descriptionElement := TFhirSearchParameter(oSource).descriptionElement.Clone;
  xpathElement := TFhirSearchParameter(oSource).xpathElement.Clone;
  FXpathUsage := TFhirSearchParameter(oSource).FXpathUsage.Link;
  if (TFhirSearchParameter(oSource).FTarget = nil) then
  begin
    FTarget.free;
    FTarget := nil;
  end
  else
  begin
    FTarget := TFHIREnumList.Create(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum);
    FTarget.Assign(TFhirSearchParameter(oSource).FTarget);
  end;
end;

procedure TFhirSearchParameter.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'experimental') Then
     list.add(self.link, 'experimental', FExperimental.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'requirements') Then
     list.add(self.link, 'requirements', FRequirements.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'base') Then
     list.add(self.link, 'base', FBase.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'xpath') Then
     list.add(self.link, 'xpath', FXpath.Link);
  if (child_name = 'xpathUsage') Then
     list.add(self.link, 'xpathUsage', FXpathUsage.Link);
  if (child_name = 'target') Then
     list.addAll(self, 'target', FTarget);
end;

procedure TFhirSearchParameter.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'experimental', 'boolean', false, TFhirBoolean, FExperimental.Link));{2}
  oList.add(TFHIRProperty.create(self, 'publisher', 'string', false, TFhirString, FPublisher.Link));{2}
  oList.add(TFHIRProperty.create(self, 'contact', '', true, TFhirSearchParameterContact, FContactList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requirements', 'string', false, TFhirString, FRequirements.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirCode, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'base', 'code', false, TFHIREnum, FBase.Link));{1}
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'xpath', 'string', false, TFhirString, FXpath.Link));{2}
  oList.add(TFHIRProperty.create(self, 'xpathUsage', 'code', false, TFHIREnum, FXpathUsage.Link));{1}
  oList.add(TFHIRProperty.create(self, 'target', 'code', true, TFHIREnum, FTarget.Link)){3};
end;

function TFhirSearchParameter.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirConformanceResourceStatusEnum, CODES_TFhirConformanceResourceStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'experimental') then
  begin
    ExperimentalElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    PublisherElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirSearchParameterContact){2a};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'requirements') then
  begin
    RequirementsElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'base') then
  begin
    BaseElement := asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue);
    result := propValue
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirSearchParamTypeEnum, CODES_TFhirSearchParamTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'xpath') then
  begin
    XpathElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'xpathUsage') then
  begin
    XpathUsageElement := asEnum(SYSTEMS_TFhirSearchXpathUsageEnum, CODES_TFhirSearchXpathUsageEnum, propValue);
    result := propValue
  end
  else if (propName = 'target') then
  begin
    TargetList.add(asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue)); {1}
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirSearchParameter.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirSearchParameterContact){2a}
  else if (propName = 'target') then FTarget.insertItem(index, asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue)) {1}
  else inherited;
end;

function TFhirSearchParameter.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create() {5b}
  else if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'experimental') then result := TFhirBoolean.create() {5b}
  else if (propName = 'publisher') then result := TFhirString.create() {5b}
  else if (propName = 'contact') then result := ContactList.new(){2}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'requirements') then result := TFhirString.create() {5b}
  else if (propName = 'code') then result := TFhirCode.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'xpath') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSearchParameter.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'uri'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'experimental') then result := 'boolean'
  else if (propName = 'publisher') then result := 'string'
  else if (propName = 'contact') then result := ''
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'requirements') then result := 'string'
  else if (propName = 'code') then result := 'code'
  else if (propName = 'base') then result := 'code'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'xpath') then result := 'string'
  else if (propName = 'xpathUsage') then result := 'code'
  else if (propName = 'target') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSearchParameter.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'experimental') then ExperimentalElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value) {2}
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'requirements') then RequirementsElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'base') then BaseElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'xpath') then XpathElement := nil
  else if (propName = 'xpathUsage') then XpathUsageElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSearchParameter.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asUri(new){5b}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirConformanceResourceStatusEnum, CODES_TFhirConformanceResourceStatusEnum, new){4}
  else if (propName = 'experimental') then ExperimentalElement := asBoolean(new){5b}
  else if (propName = 'publisher') then PublisherElement := asString(new){5b}
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new) {2}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'requirements') then RequirementsElement := asString(new){5b}
  else if (propName = 'code') then CodeElement := asCode(new){5b}
  else if (propName = 'base') then BaseElement := asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, new){4}
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirSearchParamTypeEnum, CODES_TFhirSearchParamTypeEnum, new){4}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'xpath') then XpathElement := asString(new){5b}
  else if (propName = 'xpathUsage') then XpathUsageElement := asEnum(SYSTEMS_TFhirSearchXpathUsageEnum, CODES_TFhirSearchXpathUsageEnum, new){4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSearchParameter.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'contact') then ContactList.move(source, destination){2a}
  else if (propName = 'target') then FTarget.move(source, destination) {1}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSearchParameter.fhirType : string;
begin
  result := 'SearchParameter';
end;

function TFhirSearchParameter.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FName) and isEmptyProp(FStatus) and isEmptyProp(FExperimental) and isEmptyProp(FPublisher) and isEmptyProp(FcontactList) and isEmptyProp(FDate) and isEmptyProp(FRequirements) and isEmptyProp(FCode) and isEmptyProp(FBase) and isEmptyProp(FType_) and isEmptyProp(FDescription) and isEmptyProp(FXpath) and isEmptyProp(FXpathUsage) and isEmptyProp(FTarget);
end;

function TFhirSearchParameter.equals(other : TObject) : boolean; 
var
  o : TFhirSearchParameter;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSearchParameter)) then
    result := false
  else
  begin
    o := TFhirSearchParameter(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(experimentalElement, o.experimentalElement, true) and 
      compareDeep(publisherElement, o.publisherElement, true) and compareDeep(contactList, o.contactList, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(requirementsElement, o.requirementsElement, true) and 
      compareDeep(codeElement, o.codeElement, true) and compareDeep(baseElement, o.baseElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(xpathElement, o.xpathElement, true) and compareDeep(xpathUsageElement, o.xpathUsageElement, true) and 
      compareDeep(targetList, o.targetList, true);
  end;
end;

function TFhirSearchParameter.Link : TFhirSearchParameter;
begin
  result := TFhirSearchParameter(inherited Link);
end;

function TFhirSearchParameter.Clone : TFhirSearchParameter;
begin
  result := TFhirSearchParameter(inherited Clone);
end;

procedure TFhirSearchParameter.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('url');
  fields.add('name');
  fields.add('status');
  fields.add('experimental');
  fields.add('publisher');
  fields.add('contact');
  fields.add('date');
  fields.add('requirements');
  fields.add('code');
  fields.add('base');
  fields.add('type');
  fields.add('description');
  fields.add('xpath');
  fields.add('xpathUsage');
  fields.add('target');
end;

{ TFhirSearchParameter }

Procedure TFhirSearchParameter.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirSearchParameter.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

Procedure TFhirSearchParameter.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

Procedure TFhirSearchParameter.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirSearchParameter.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirSearchParameter.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirSearchParameter.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirSearchParameter.GetStatusST : TFhirConformanceResourceStatusEnum;
begin
  if FStatus = nil then
    result := TFhirConformanceResourceStatusEnum(0)
  else
    result := TFhirConformanceResourceStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirConformanceResourceStatusEnum, FStatus.value));
end;

Procedure TFhirSearchParameter.SetStatusST(value : TFhirConformanceResourceStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirConformanceResourceStatusEnum[value], CODES_TFhirConformanceResourceStatusEnum[value]);
end;

Procedure TFhirSearchParameter.SetExperimental(value : TFhirBoolean);
begin
  FExperimental.free;
  FExperimental := value;
end;

Function TFhirSearchParameter.GetExperimentalST : Boolean;
begin
  if FExperimental = nil then
    result := false
  else
    result := FExperimental.value;
end;

Procedure TFhirSearchParameter.SetExperimentalST(value : Boolean);
begin
  if FExperimental = nil then
    FExperimental := TFhirBoolean.create;
  FExperimental.value := value
end;

Procedure TFhirSearchParameter.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

Function TFhirSearchParameter.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

Procedure TFhirSearchParameter.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

Function TFhirSearchParameter.GetContactList : TFhirSearchParameterContactList;
begin
  if FContactList = nil then
    FContactList := TFhirSearchParameterContactList.Create;
  result := FContactList;
end;

Function TFhirSearchParameter.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

Procedure TFhirSearchParameter.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirSearchParameter.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirSearchParameter.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirSearchParameter.SetRequirements(value : TFhirString);
begin
  FRequirements.free;
  FRequirements := value;
end;

Function TFhirSearchParameter.GetRequirementsST : String;
begin
  if FRequirements = nil then
    result := ''
  else
    result := FRequirements.value;
end;

Procedure TFhirSearchParameter.SetRequirementsST(value : String);
begin
  if value <> '' then
  begin
    if FRequirements = nil then
      FRequirements := TFhirString.create;
    FRequirements.value := value
  end
  else if FRequirements <> nil then
    FRequirements.value := '';
end;

Procedure TFhirSearchParameter.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirSearchParameter.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

Procedure TFhirSearchParameter.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

Procedure TFhirSearchParameter.SetBase(value : TFhirEnum);
begin
  FBase.free;
  FBase := value;
end;

Function TFhirSearchParameter.GetBaseST : TFhirResourceTypesEnum;
begin
  if FBase = nil then
    result := TFhirResourceTypesEnum(0)
  else
    result := TFhirResourceTypesEnum(StringArrayIndexOfSensitive(CODES_TFhirResourceTypesEnum, FBase.value));
end;

Procedure TFhirSearchParameter.SetBaseST(value : TFhirResourceTypesEnum);
begin
  if ord(value) = 0 then
    BaseElement := nil
  else
    BaseElement := TFhirEnum.create(SYSTEMS_TFhirResourceTypesEnum[value], CODES_TFhirResourceTypesEnum[value]);
end;

Procedure TFhirSearchParameter.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirSearchParameter.GetType_ST : TFhirSearchParamTypeEnum;
begin
  if FType_ = nil then
    result := TFhirSearchParamTypeEnum(0)
  else
    result := TFhirSearchParamTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirSearchParamTypeEnum, FType_.value));
end;

Procedure TFhirSearchParameter.SetType_ST(value : TFhirSearchParamTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirSearchParamTypeEnum[value], CODES_TFhirSearchParamTypeEnum[value]);
end;

Procedure TFhirSearchParameter.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirSearchParameter.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirSearchParameter.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirSearchParameter.SetXpath(value : TFhirString);
begin
  FXpath.free;
  FXpath := value;
end;

Function TFhirSearchParameter.GetXpathST : String;
begin
  if FXpath = nil then
    result := ''
  else
    result := FXpath.value;
end;

Procedure TFhirSearchParameter.SetXpathST(value : String);
begin
  if value <> '' then
  begin
    if FXpath = nil then
      FXpath := TFhirString.create;
    FXpath.value := value
  end
  else if FXpath <> nil then
    FXpath.value := '';
end;

Procedure TFhirSearchParameter.SetXpathUsage(value : TFhirEnum);
begin
  FXpathUsage.free;
  FXpathUsage := value;
end;

Function TFhirSearchParameter.GetXpathUsageST : TFhirSearchXpathUsageEnum;
begin
  if FXpathUsage = nil then
    result := TFhirSearchXpathUsageEnum(0)
  else
    result := TFhirSearchXpathUsageEnum(StringArrayIndexOfSensitive(CODES_TFhirSearchXpathUsageEnum, FXpathUsage.value));
end;

Procedure TFhirSearchParameter.SetXpathUsageST(value : TFhirSearchXpathUsageEnum);
begin
  if ord(value) = 0 then
    XpathUsageElement := nil
  else
    XpathUsageElement := TFhirEnum.create(SYSTEMS_TFhirSearchXpathUsageEnum[value], CODES_TFhirSearchXpathUsageEnum[value]);
end;

Function TFhirSearchParameter.GetTarget : TFhirEnumList;
begin
  if FTarget = nil then
    FTarget := TFHIREnumList.Create(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum);
  result := FTarget;
end;

Function TFhirSearchParameter.GetHasTarget : boolean;
begin
  result := (FTarget <> nil) and (FTarget.count > 0);
end;

function TFhirSearchParameter.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FUrl.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FExperimental.sizeInBytes);
  inc(result, FPublisher.sizeInBytes);
  inc(result, FcontactList.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FRequirements.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FBase.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FXpath.sizeInBytes);
  inc(result, FXpathUsage.sizeInBytes);
  inc(result, FTarget.sizeInBytes);
end;

{ TFhirSearchParameterListEnumerator }

Constructor TFhirSearchParameterListEnumerator.Create(list : TFhirSearchParameterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSearchParameterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSearchParameterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSearchParameterListEnumerator.GetCurrent : TFhirSearchParameter;
begin
  Result := FList[FIndex];
end;

function TFhirSearchParameterListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSearchParameterList }
procedure TFhirSearchParameterList.AddItem(value: TFhirSearchParameter);
begin
  assert(value.ClassName = 'TFhirSearchParameter', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSearchParameter');
  add(value);
end;

function TFhirSearchParameterList.Append: TFhirSearchParameter;
begin
  result := TFhirSearchParameter.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSearchParameterList.ClearItems;
begin
  Clear;
end;

function TFhirSearchParameterList.GetEnumerator : TFhirSearchParameterListEnumerator;
begin
  result := TFhirSearchParameterListEnumerator.Create(self.link);
end;

function TFhirSearchParameterList.Clone: TFhirSearchParameterList;
begin
  result := TFhirSearchParameterList(inherited Clone);
end;

function TFhirSearchParameterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSearchParameterList.GetItemN(index: Integer): TFhirSearchParameter;
begin
  result := TFhirSearchParameter(ObjectByIndex[index]);
end;

function TFhirSearchParameterList.ItemClass: TFslObjectClass;
begin
  result := TFhirSearchParameter;
end;
function TFhirSearchParameterList.IndexOf(value: TFhirSearchParameter): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSearchParameterList.Insert(index: Integer): TFhirSearchParameter;
begin
  result := TFhirSearchParameter.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSearchParameterList.InsertItem(index: Integer; value: TFhirSearchParameter);
begin
  assert(value is TFhirSearchParameter);
  Inherited Insert(index, value);
end;

function TFhirSearchParameterList.Item(index: Integer): TFhirSearchParameter;
begin
  result := TFhirSearchParameter(ObjectByIndex[index]);
end;

function TFhirSearchParameterList.Link: TFhirSearchParameterList;
begin
  result := TFhirSearchParameterList(inherited Link);
end;

procedure TFhirSearchParameterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSearchParameterList.SetItemByIndex(index: Integer; value: TFhirSearchParameter);
begin
  assert(value is TFhirSearchParameter);
  FhirSearchParameters[index] := value;
end;

procedure TFhirSearchParameterList.SetItemN(index: Integer; value: TFhirSearchParameter);
begin
  assert(value is TFhirSearchParameter);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SEARCHPARAMETER}

{$IFDEF FHIR_STRUCTUREDEFINITION}

{ TFhirStructureDefinitionContact }

constructor TFhirStructureDefinitionContact.Create;
begin
  inherited;
end;

destructor TFhirStructureDefinitionContact.Destroy;
begin
  FName.free;
  FTelecomList.Free;
  inherited;
end;

procedure TFhirStructureDefinitionContact.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirStructureDefinitionContact(oSource).nameElement.Clone;
  if (TFhirStructureDefinitionContact(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirStructureDefinitionContact(oSource).FTelecomList);
  end;
end;

procedure TFhirStructureDefinitionContact.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
end;

procedure TFhirStructureDefinitionContact.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link)){3};
end;

function TFhirStructureDefinitionContact.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirStructureDefinitionContact.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint){2a}
  else inherited;
end;

function TFhirStructureDefinitionContact.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'telecom') then result := TelecomList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirStructureDefinitionContact.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirStructureDefinitionContact.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirStructureDefinitionContact.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirStructureDefinitionContact.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'telecom') then TelecomList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirStructureDefinitionContact.fhirType : string;
begin
  result := 'contact';
end;

function TFhirStructureDefinitionContact.Link : TFhirStructureDefinitionContact;
begin
  result := TFhirStructureDefinitionContact(inherited Link);
end;

function TFhirStructureDefinitionContact.Clone : TFhirStructureDefinitionContact;
begin
  result := TFhirStructureDefinitionContact(inherited Clone);
end;

function TFhirStructureDefinitionContact.equals(other : TObject) : boolean; 
var
  o : TFhirStructureDefinitionContact;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirStructureDefinitionContact)) then
    result := false
  else
  begin
    o := TFhirStructureDefinitionContact(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(telecomList, o.telecomList, true);
  end;
end;

function TFhirStructureDefinitionContact.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FtelecomList);
end;

procedure TFhirStructureDefinitionContact.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('telecom');
end;

{ TFhirStructureDefinitionContact }

Procedure TFhirStructureDefinitionContact.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirStructureDefinitionContact.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirStructureDefinitionContact.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Function TFhirStructureDefinitionContact.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

Function TFhirStructureDefinitionContact.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

function TFhirStructureDefinitionContact.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FtelecomList.sizeInBytes);
end;

{ TFhirStructureDefinitionContactListEnumerator }

Constructor TFhirStructureDefinitionContactListEnumerator.Create(list : TFhirStructureDefinitionContactList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirStructureDefinitionContactListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirStructureDefinitionContactListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirStructureDefinitionContactListEnumerator.GetCurrent : TFhirStructureDefinitionContact;
begin
  Result := FList[FIndex];
end;

function TFhirStructureDefinitionContactListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirStructureDefinitionContactList }
procedure TFhirStructureDefinitionContactList.AddItem(value: TFhirStructureDefinitionContact);
begin
  assert(value.ClassName = 'TFhirStructureDefinitionContact', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirStructureDefinitionContact');
  add(value);
end;

function TFhirStructureDefinitionContactList.Append: TFhirStructureDefinitionContact;
begin
  result := TFhirStructureDefinitionContact.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureDefinitionContactList.ClearItems;
begin
  Clear;
end;

function TFhirStructureDefinitionContactList.GetEnumerator : TFhirStructureDefinitionContactListEnumerator;
begin
  result := TFhirStructureDefinitionContactListEnumerator.Create(self.link);
end;

function TFhirStructureDefinitionContactList.Clone: TFhirStructureDefinitionContactList;
begin
  result := TFhirStructureDefinitionContactList(inherited Clone);
end;

function TFhirStructureDefinitionContactList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirStructureDefinitionContactList.GetItemN(index: Integer): TFhirStructureDefinitionContact;
begin
  result := TFhirStructureDefinitionContact(ObjectByIndex[index]);
end;

function TFhirStructureDefinitionContactList.ItemClass: TFslObjectClass;
begin
  result := TFhirStructureDefinitionContact;
end;
function TFhirStructureDefinitionContactList.IndexOf(value: TFhirStructureDefinitionContact): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirStructureDefinitionContactList.Insert(index: Integer): TFhirStructureDefinitionContact;
begin
  result := TFhirStructureDefinitionContact.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureDefinitionContactList.InsertItem(index: Integer; value: TFhirStructureDefinitionContact);
begin
  assert(value is TFhirStructureDefinitionContact);
  Inherited Insert(index, value);
end;

function TFhirStructureDefinitionContactList.Item(index: Integer): TFhirStructureDefinitionContact;
begin
  result := TFhirStructureDefinitionContact(ObjectByIndex[index]);
end;

function TFhirStructureDefinitionContactList.Link: TFhirStructureDefinitionContactList;
begin
  result := TFhirStructureDefinitionContactList(inherited Link);
end;

procedure TFhirStructureDefinitionContactList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirStructureDefinitionContactList.SetItemByIndex(index: Integer; value: TFhirStructureDefinitionContact);
begin
  assert(value is TFhirStructureDefinitionContact);
  FhirStructureDefinitionContacts[index] := value;
end;

procedure TFhirStructureDefinitionContactList.SetItemN(index: Integer; value: TFhirStructureDefinitionContact);
begin
  assert(value is TFhirStructureDefinitionContact);
  ObjectByIndex[index] := value;
end;

{ TFhirStructureDefinitionMapping }

constructor TFhirStructureDefinitionMapping.Create;
begin
  inherited;
end;

destructor TFhirStructureDefinitionMapping.Destroy;
begin
  FIdentity.free;
  FUri.free;
  FName.free;
  FComments.free;
  inherited;
end;

procedure TFhirStructureDefinitionMapping.Assign(oSource : TFslObject);
begin
  inherited;
  identityElement := TFhirStructureDefinitionMapping(oSource).identityElement.Clone;
  uriElement := TFhirStructureDefinitionMapping(oSource).uriElement.Clone;
  nameElement := TFhirStructureDefinitionMapping(oSource).nameElement.Clone;
  commentsElement := TFhirStructureDefinitionMapping(oSource).commentsElement.Clone;
end;

procedure TFhirStructureDefinitionMapping.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identity') Then
     list.add(self.link, 'identity', FIdentity.Link);
  if (child_name = 'uri') Then
     list.add(self.link, 'uri', FUri.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'comments') Then
     list.add(self.link, 'comments', FComments.Link);
end;

procedure TFhirStructureDefinitionMapping.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identity', 'id', false, TFhirId, FIdentity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'uri', 'uri', false, TFhirUri, FUri.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'comments', 'string', false, TFhirString, FComments.Link));{2}
end;

function TFhirStructureDefinitionMapping.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identity') then
  begin
    IdentityElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'uri') then
  begin
    UriElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'comments') then
  begin
    CommentsElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirStructureDefinitionMapping.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirStructureDefinitionMapping.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identity') then result := TFhirId.create() {5b}
  else if (propName = 'uri') then result := TFhirUri.create() {5b}
  else if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'comments') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirStructureDefinitionMapping.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identity') then result := 'id'
  else if (propName = 'uri') then result := 'uri'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'comments') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirStructureDefinitionMapping.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identity') then IdentityElement := nil
  else if (propName = 'uri') then UriElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'comments') then CommentsElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirStructureDefinitionMapping.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identity') then IdentityElement := asId(new){5b}
  else if (propName = 'uri') then UriElement := asUri(new){5b}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'comments') then CommentsElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirStructureDefinitionMapping.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirStructureDefinitionMapping.fhirType : string;
begin
  result := 'mapping';
end;

function TFhirStructureDefinitionMapping.Link : TFhirStructureDefinitionMapping;
begin
  result := TFhirStructureDefinitionMapping(inherited Link);
end;

function TFhirStructureDefinitionMapping.Clone : TFhirStructureDefinitionMapping;
begin
  result := TFhirStructureDefinitionMapping(inherited Clone);
end;

function TFhirStructureDefinitionMapping.equals(other : TObject) : boolean; 
var
  o : TFhirStructureDefinitionMapping;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirStructureDefinitionMapping)) then
    result := false
  else
  begin
    o := TFhirStructureDefinitionMapping(other);
    result := compareDeep(identityElement, o.identityElement, true) and compareDeep(uriElement, o.uriElement, true) and 
      compareDeep(nameElement, o.nameElement, true) and compareDeep(commentsElement, o.commentsElement, true);
  end;
end;

function TFhirStructureDefinitionMapping.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentity) and isEmptyProp(FUri) and isEmptyProp(FName) and isEmptyProp(FComments);
end;

procedure TFhirStructureDefinitionMapping.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identity');
  fields.add('uri');
  fields.add('name');
  fields.add('comments');
end;

{ TFhirStructureDefinitionMapping }

Procedure TFhirStructureDefinitionMapping.SetIdentity(value : TFhirId);
begin
  FIdentity.free;
  FIdentity := value;
end;

Function TFhirStructureDefinitionMapping.GetIdentityST : String;
begin
  if FIdentity = nil then
    result := ''
  else
    result := FIdentity.value;
end;

Procedure TFhirStructureDefinitionMapping.SetIdentityST(value : String);
begin
  if value <> '' then
  begin
    if FIdentity = nil then
      FIdentity := TFhirId.create;
    FIdentity.value := value
  end
  else if FIdentity <> nil then
    FIdentity.value := '';
end;

Procedure TFhirStructureDefinitionMapping.SetUri(value : TFhirUri);
begin
  FUri.free;
  FUri := value;
end;

Function TFhirStructureDefinitionMapping.GetUriST : String;
begin
  if FUri = nil then
    result := ''
  else
    result := FUri.value;
end;

Procedure TFhirStructureDefinitionMapping.SetUriST(value : String);
begin
  if value <> '' then
  begin
    if FUri = nil then
      FUri := TFhirUri.create;
    FUri.value := value
  end
  else if FUri <> nil then
    FUri.value := '';
end;

Procedure TFhirStructureDefinitionMapping.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirStructureDefinitionMapping.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirStructureDefinitionMapping.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirStructureDefinitionMapping.SetComments(value : TFhirString);
begin
  FComments.free;
  FComments := value;
end;

Function TFhirStructureDefinitionMapping.GetCommentsST : String;
begin
  if FComments = nil then
    result := ''
  else
    result := FComments.value;
end;

Procedure TFhirStructureDefinitionMapping.SetCommentsST(value : String);
begin
  if value <> '' then
  begin
    if FComments = nil then
      FComments := TFhirString.create;
    FComments.value := value
  end
  else if FComments <> nil then
    FComments.value := '';
end;

function TFhirStructureDefinitionMapping.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentity.sizeInBytes);
  inc(result, FUri.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FComments.sizeInBytes);
end;

{ TFhirStructureDefinitionMappingListEnumerator }

Constructor TFhirStructureDefinitionMappingListEnumerator.Create(list : TFhirStructureDefinitionMappingList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirStructureDefinitionMappingListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirStructureDefinitionMappingListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirStructureDefinitionMappingListEnumerator.GetCurrent : TFhirStructureDefinitionMapping;
begin
  Result := FList[FIndex];
end;

function TFhirStructureDefinitionMappingListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirStructureDefinitionMappingList }
procedure TFhirStructureDefinitionMappingList.AddItem(value: TFhirStructureDefinitionMapping);
begin
  assert(value.ClassName = 'TFhirStructureDefinitionMapping', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirStructureDefinitionMapping');
  add(value);
end;

function TFhirStructureDefinitionMappingList.Append: TFhirStructureDefinitionMapping;
begin
  result := TFhirStructureDefinitionMapping.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureDefinitionMappingList.ClearItems;
begin
  Clear;
end;

function TFhirStructureDefinitionMappingList.GetEnumerator : TFhirStructureDefinitionMappingListEnumerator;
begin
  result := TFhirStructureDefinitionMappingListEnumerator.Create(self.link);
end;

function TFhirStructureDefinitionMappingList.Clone: TFhirStructureDefinitionMappingList;
begin
  result := TFhirStructureDefinitionMappingList(inherited Clone);
end;

function TFhirStructureDefinitionMappingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirStructureDefinitionMappingList.GetItemN(index: Integer): TFhirStructureDefinitionMapping;
begin
  result := TFhirStructureDefinitionMapping(ObjectByIndex[index]);
end;

function TFhirStructureDefinitionMappingList.ItemClass: TFslObjectClass;
begin
  result := TFhirStructureDefinitionMapping;
end;
function TFhirStructureDefinitionMappingList.IndexOf(value: TFhirStructureDefinitionMapping): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirStructureDefinitionMappingList.Insert(index: Integer): TFhirStructureDefinitionMapping;
begin
  result := TFhirStructureDefinitionMapping.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureDefinitionMappingList.InsertItem(index: Integer; value: TFhirStructureDefinitionMapping);
begin
  assert(value is TFhirStructureDefinitionMapping);
  Inherited Insert(index, value);
end;

function TFhirStructureDefinitionMappingList.Item(index: Integer): TFhirStructureDefinitionMapping;
begin
  result := TFhirStructureDefinitionMapping(ObjectByIndex[index]);
end;

function TFhirStructureDefinitionMappingList.Link: TFhirStructureDefinitionMappingList;
begin
  result := TFhirStructureDefinitionMappingList(inherited Link);
end;

procedure TFhirStructureDefinitionMappingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirStructureDefinitionMappingList.SetItemByIndex(index: Integer; value: TFhirStructureDefinitionMapping);
begin
  assert(value is TFhirStructureDefinitionMapping);
  FhirStructureDefinitionMappings[index] := value;
end;

procedure TFhirStructureDefinitionMappingList.SetItemN(index: Integer; value: TFhirStructureDefinitionMapping);
begin
  assert(value is TFhirStructureDefinitionMapping);
  ObjectByIndex[index] := value;
end;

{ TFhirStructureDefinitionSnapshot }

constructor TFhirStructureDefinitionSnapshot.Create;
begin
  inherited;
end;

destructor TFhirStructureDefinitionSnapshot.Destroy;
begin
  FElementList.Free;
  inherited;
end;

procedure TFhirStructureDefinitionSnapshot.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirStructureDefinitionSnapshot(oSource).FElementList = nil) then
  begin
    FElementList.free;
    FElementList := nil;
  end
  else
  begin
    if FElementList = nil then
      FElementList := TFhirElementDefinitionList.Create;
    FElementList.Assign(TFhirStructureDefinitionSnapshot(oSource).FElementList);
  end;
end;

procedure TFhirStructureDefinitionSnapshot.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'element') Then
    list.addAll(self, 'element', FElementList);
end;

procedure TFhirStructureDefinitionSnapshot.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'element', 'ElementDefinition', true, TFhirElementDefinition, FElementList.Link)){3};
end;

function TFhirStructureDefinitionSnapshot.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'element') then
  begin
    ElementList.add(propValue as TFhirElementDefinition){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirStructureDefinitionSnapshot.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'element') then ElementList.insertItem(index, propValue as TFhirElementDefinition){2a}
  else inherited;
end;

function TFhirStructureDefinitionSnapshot.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'element') then result := ElementList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirStructureDefinitionSnapshot.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'element') then result := 'ElementDefinition'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirStructureDefinitionSnapshot.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'element') then deletePropertyValue('element', ElementList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirStructureDefinitionSnapshot.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'element') then replacePropertyValue('element', ElementList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirStructureDefinitionSnapshot.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'element') then ElementList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirStructureDefinitionSnapshot.fhirType : string;
begin
  result := 'snapshot';
end;

function TFhirStructureDefinitionSnapshot.Link : TFhirStructureDefinitionSnapshot;
begin
  result := TFhirStructureDefinitionSnapshot(inherited Link);
end;

function TFhirStructureDefinitionSnapshot.Clone : TFhirStructureDefinitionSnapshot;
begin
  result := TFhirStructureDefinitionSnapshot(inherited Clone);
end;

function TFhirStructureDefinitionSnapshot.equals(other : TObject) : boolean; 
var
  o : TFhirStructureDefinitionSnapshot;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirStructureDefinitionSnapshot)) then
    result := false
  else
  begin
    o := TFhirStructureDefinitionSnapshot(other);
    result := compareDeep(elementList, o.elementList, true);
  end;
end;

function TFhirStructureDefinitionSnapshot.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FelementList);
end;

procedure TFhirStructureDefinitionSnapshot.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('element');
end;

{ TFhirStructureDefinitionSnapshot }

Function TFhirStructureDefinitionSnapshot.GetElementList : TFhirElementDefinitionList;
begin
  if FElementList = nil then
    FElementList := TFhirElementDefinitionList.Create;
  result := FElementList;
end;

Function TFhirStructureDefinitionSnapshot.GetHasElementList : boolean;
begin
  result := (FElementList <> nil) and (FElementList.count > 0);
end;

function TFhirStructureDefinitionSnapshot.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FelementList.sizeInBytes);
end;

{ TFhirStructureDefinitionSnapshotListEnumerator }

Constructor TFhirStructureDefinitionSnapshotListEnumerator.Create(list : TFhirStructureDefinitionSnapshotList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirStructureDefinitionSnapshotListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirStructureDefinitionSnapshotListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirStructureDefinitionSnapshotListEnumerator.GetCurrent : TFhirStructureDefinitionSnapshot;
begin
  Result := FList[FIndex];
end;

function TFhirStructureDefinitionSnapshotListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirStructureDefinitionSnapshotList }
procedure TFhirStructureDefinitionSnapshotList.AddItem(value: TFhirStructureDefinitionSnapshot);
begin
  assert(value.ClassName = 'TFhirStructureDefinitionSnapshot', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirStructureDefinitionSnapshot');
  add(value);
end;

function TFhirStructureDefinitionSnapshotList.Append: TFhirStructureDefinitionSnapshot;
begin
  result := TFhirStructureDefinitionSnapshot.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureDefinitionSnapshotList.ClearItems;
begin
  Clear;
end;

function TFhirStructureDefinitionSnapshotList.GetEnumerator : TFhirStructureDefinitionSnapshotListEnumerator;
begin
  result := TFhirStructureDefinitionSnapshotListEnumerator.Create(self.link);
end;

function TFhirStructureDefinitionSnapshotList.Clone: TFhirStructureDefinitionSnapshotList;
begin
  result := TFhirStructureDefinitionSnapshotList(inherited Clone);
end;

function TFhirStructureDefinitionSnapshotList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirStructureDefinitionSnapshotList.GetItemN(index: Integer): TFhirStructureDefinitionSnapshot;
begin
  result := TFhirStructureDefinitionSnapshot(ObjectByIndex[index]);
end;

function TFhirStructureDefinitionSnapshotList.ItemClass: TFslObjectClass;
begin
  result := TFhirStructureDefinitionSnapshot;
end;
function TFhirStructureDefinitionSnapshotList.IndexOf(value: TFhirStructureDefinitionSnapshot): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirStructureDefinitionSnapshotList.Insert(index: Integer): TFhirStructureDefinitionSnapshot;
begin
  result := TFhirStructureDefinitionSnapshot.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureDefinitionSnapshotList.InsertItem(index: Integer; value: TFhirStructureDefinitionSnapshot);
begin
  assert(value is TFhirStructureDefinitionSnapshot);
  Inherited Insert(index, value);
end;

function TFhirStructureDefinitionSnapshotList.Item(index: Integer): TFhirStructureDefinitionSnapshot;
begin
  result := TFhirStructureDefinitionSnapshot(ObjectByIndex[index]);
end;

function TFhirStructureDefinitionSnapshotList.Link: TFhirStructureDefinitionSnapshotList;
begin
  result := TFhirStructureDefinitionSnapshotList(inherited Link);
end;

procedure TFhirStructureDefinitionSnapshotList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirStructureDefinitionSnapshotList.SetItemByIndex(index: Integer; value: TFhirStructureDefinitionSnapshot);
begin
  assert(value is TFhirStructureDefinitionSnapshot);
  FhirStructureDefinitionSnapshots[index] := value;
end;

procedure TFhirStructureDefinitionSnapshotList.SetItemN(index: Integer; value: TFhirStructureDefinitionSnapshot);
begin
  assert(value is TFhirStructureDefinitionSnapshot);
  ObjectByIndex[index] := value;
end;

{ TFhirStructureDefinitionDifferential }

constructor TFhirStructureDefinitionDifferential.Create;
begin
  inherited;
end;

destructor TFhirStructureDefinitionDifferential.Destroy;
begin
  FElementList.Free;
  inherited;
end;

procedure TFhirStructureDefinitionDifferential.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirStructureDefinitionDifferential(oSource).FElementList = nil) then
  begin
    FElementList.free;
    FElementList := nil;
  end
  else
  begin
    if FElementList = nil then
      FElementList := TFhirElementDefinitionList.Create;
    FElementList.Assign(TFhirStructureDefinitionDifferential(oSource).FElementList);
  end;
end;

procedure TFhirStructureDefinitionDifferential.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'element') Then
    list.addAll(self, 'element', FElementList);
end;

procedure TFhirStructureDefinitionDifferential.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'element', 'ElementDefinition', true, TFhirElementDefinition, FElementList.Link)){3};
end;

function TFhirStructureDefinitionDifferential.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'element') then
  begin
    ElementList.add(propValue as TFhirElementDefinition){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirStructureDefinitionDifferential.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'element') then ElementList.insertItem(index, propValue as TFhirElementDefinition){2a}
  else inherited;
end;

function TFhirStructureDefinitionDifferential.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'element') then result := ElementList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirStructureDefinitionDifferential.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'element') then result := 'ElementDefinition'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirStructureDefinitionDifferential.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'element') then deletePropertyValue('element', ElementList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirStructureDefinitionDifferential.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'element') then replacePropertyValue('element', ElementList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirStructureDefinitionDifferential.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'element') then ElementList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirStructureDefinitionDifferential.fhirType : string;
begin
  result := 'differential';
end;

function TFhirStructureDefinitionDifferential.Link : TFhirStructureDefinitionDifferential;
begin
  result := TFhirStructureDefinitionDifferential(inherited Link);
end;

function TFhirStructureDefinitionDifferential.Clone : TFhirStructureDefinitionDifferential;
begin
  result := TFhirStructureDefinitionDifferential(inherited Clone);
end;

function TFhirStructureDefinitionDifferential.equals(other : TObject) : boolean; 
var
  o : TFhirStructureDefinitionDifferential;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirStructureDefinitionDifferential)) then
    result := false
  else
  begin
    o := TFhirStructureDefinitionDifferential(other);
    result := compareDeep(elementList, o.elementList, true);
  end;
end;

function TFhirStructureDefinitionDifferential.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FelementList);
end;

procedure TFhirStructureDefinitionDifferential.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('element');
end;

{ TFhirStructureDefinitionDifferential }

Function TFhirStructureDefinitionDifferential.GetElementList : TFhirElementDefinitionList;
begin
  if FElementList = nil then
    FElementList := TFhirElementDefinitionList.Create;
  result := FElementList;
end;

Function TFhirStructureDefinitionDifferential.GetHasElementList : boolean;
begin
  result := (FElementList <> nil) and (FElementList.count > 0);
end;

function TFhirStructureDefinitionDifferential.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FelementList.sizeInBytes);
end;

{ TFhirStructureDefinitionDifferentialListEnumerator }

Constructor TFhirStructureDefinitionDifferentialListEnumerator.Create(list : TFhirStructureDefinitionDifferentialList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirStructureDefinitionDifferentialListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirStructureDefinitionDifferentialListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirStructureDefinitionDifferentialListEnumerator.GetCurrent : TFhirStructureDefinitionDifferential;
begin
  Result := FList[FIndex];
end;

function TFhirStructureDefinitionDifferentialListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirStructureDefinitionDifferentialList }
procedure TFhirStructureDefinitionDifferentialList.AddItem(value: TFhirStructureDefinitionDifferential);
begin
  assert(value.ClassName = 'TFhirStructureDefinitionDifferential', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirStructureDefinitionDifferential');
  add(value);
end;

function TFhirStructureDefinitionDifferentialList.Append: TFhirStructureDefinitionDifferential;
begin
  result := TFhirStructureDefinitionDifferential.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureDefinitionDifferentialList.ClearItems;
begin
  Clear;
end;

function TFhirStructureDefinitionDifferentialList.GetEnumerator : TFhirStructureDefinitionDifferentialListEnumerator;
begin
  result := TFhirStructureDefinitionDifferentialListEnumerator.Create(self.link);
end;

function TFhirStructureDefinitionDifferentialList.Clone: TFhirStructureDefinitionDifferentialList;
begin
  result := TFhirStructureDefinitionDifferentialList(inherited Clone);
end;

function TFhirStructureDefinitionDifferentialList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirStructureDefinitionDifferentialList.GetItemN(index: Integer): TFhirStructureDefinitionDifferential;
begin
  result := TFhirStructureDefinitionDifferential(ObjectByIndex[index]);
end;

function TFhirStructureDefinitionDifferentialList.ItemClass: TFslObjectClass;
begin
  result := TFhirStructureDefinitionDifferential;
end;
function TFhirStructureDefinitionDifferentialList.IndexOf(value: TFhirStructureDefinitionDifferential): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirStructureDefinitionDifferentialList.Insert(index: Integer): TFhirStructureDefinitionDifferential;
begin
  result := TFhirStructureDefinitionDifferential.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureDefinitionDifferentialList.InsertItem(index: Integer; value: TFhirStructureDefinitionDifferential);
begin
  assert(value is TFhirStructureDefinitionDifferential);
  Inherited Insert(index, value);
end;

function TFhirStructureDefinitionDifferentialList.Item(index: Integer): TFhirStructureDefinitionDifferential;
begin
  result := TFhirStructureDefinitionDifferential(ObjectByIndex[index]);
end;

function TFhirStructureDefinitionDifferentialList.Link: TFhirStructureDefinitionDifferentialList;
begin
  result := TFhirStructureDefinitionDifferentialList(inherited Link);
end;

procedure TFhirStructureDefinitionDifferentialList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirStructureDefinitionDifferentialList.SetItemByIndex(index: Integer; value: TFhirStructureDefinitionDifferential);
begin
  assert(value is TFhirStructureDefinitionDifferential);
  FhirStructureDefinitionDifferentials[index] := value;
end;

procedure TFhirStructureDefinitionDifferentialList.SetItemN(index: Integer; value: TFhirStructureDefinitionDifferential);
begin
  assert(value is TFhirStructureDefinitionDifferential);
  ObjectByIndex[index] := value;
end;

{ TFhirStructureDefinition }

constructor TFhirStructureDefinition.Create;
begin
  inherited;
end;

destructor TFhirStructureDefinition.Destroy;
begin
  FUrl.free;
  FIdentifierList.Free;
  FVersion.free;
  FName.free;
  FDisplay.free;
  FStatus.free;
  FExperimental.free;
  FPublisher.free;
  FContactList.Free;
  FDate.free;
  FDescription.free;
  FUseContextList.Free;
  FRequirements.free;
  FCopyright.free;
  FCodeList.Free;
  FFhirVersion.free;
  FMappingList.Free;
  FKind.free;
  FConstrainedType.free;
  FAbstract.free;
  FContextType.free;
  FContextList.Free;
  FBase.free;
  FSnapshot.free;
  FDifferential.free;
  inherited;
end;

function TFhirStructureDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtStructureDefinition;
end;

procedure TFhirStructureDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirStructureDefinition(oSource).urlElement.Clone;
  if (TFhirStructureDefinition(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirStructureDefinition(oSource).FIdentifierList);
  end;
  versionElement := TFhirStructureDefinition(oSource).versionElement.Clone;
  nameElement := TFhirStructureDefinition(oSource).nameElement.Clone;
  displayElement := TFhirStructureDefinition(oSource).displayElement.Clone;
  FStatus := TFhirStructureDefinition(oSource).FStatus.Link;
  experimentalElement := TFhirStructureDefinition(oSource).experimentalElement.Clone;
  publisherElement := TFhirStructureDefinition(oSource).publisherElement.Clone;
  if (TFhirStructureDefinition(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirStructureDefinitionContactList.Create;
    FContactList.Assign(TFhirStructureDefinition(oSource).FContactList);
  end;
  dateElement := TFhirStructureDefinition(oSource).dateElement.Clone;
  descriptionElement := TFhirStructureDefinition(oSource).descriptionElement.Clone;
  if (TFhirStructureDefinition(oSource).FUseContextList = nil) then
  begin
    FUseContextList.free;
    FUseContextList := nil;
  end
  else
  begin
    if FUseContextList = nil then
      FUseContextList := TFhirCodeableConceptList.Create;
    FUseContextList.Assign(TFhirStructureDefinition(oSource).FUseContextList);
  end;
  requirementsElement := TFhirStructureDefinition(oSource).requirementsElement.Clone;
  copyrightElement := TFhirStructureDefinition(oSource).copyrightElement.Clone;
  if (TFhirStructureDefinition(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirCodingList.Create;
    FCodeList.Assign(TFhirStructureDefinition(oSource).FCodeList);
  end;
  fhirVersionElement := TFhirStructureDefinition(oSource).fhirVersionElement.Clone;
  if (TFhirStructureDefinition(oSource).FMappingList = nil) then
  begin
    FMappingList.free;
    FMappingList := nil;
  end
  else
  begin
    if FMappingList = nil then
      FMappingList := TFhirStructureDefinitionMappingList.Create;
    FMappingList.Assign(TFhirStructureDefinition(oSource).FMappingList);
  end;
  FKind := TFhirStructureDefinition(oSource).FKind.Link;
  constrainedTypeElement := TFhirStructureDefinition(oSource).constrainedTypeElement.Clone;
  abstractElement := TFhirStructureDefinition(oSource).abstractElement.Clone;
  FContextType := TFhirStructureDefinition(oSource).FContextType.Link;
  if (TFhirStructureDefinition(oSource).FContextList = nil) then
  begin
    FContextList.free;
    FContextList := nil;
  end
  else
  begin
    if FContextList = nil then
      FContextList := TFhirStringList.Create;
    FContextList.Assign(TFhirStructureDefinition(oSource).FContextList);
  end;
  baseElement := TFhirStructureDefinition(oSource).baseElement.Clone;
  snapshot := TFhirStructureDefinition(oSource).snapshot.Clone;
  differential := TFhirStructureDefinition(oSource).differential.Clone;
end;

procedure TFhirStructureDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'display') Then
     list.add(self.link, 'display', FDisplay.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'experimental') Then
     list.add(self.link, 'experimental', FExperimental.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'useContext') Then
    list.addAll(self, 'useContext', FUseContextList);
  if (child_name = 'requirements') Then
     list.add(self.link, 'requirements', FRequirements.Link);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'fhirVersion') Then
     list.add(self.link, 'fhirVersion', FFhirVersion.Link);
  if (child_name = 'mapping') Then
    list.addAll(self, 'mapping', FMappingList);
  if (child_name = 'kind') Then
     list.add(self.link, 'kind', FKind.Link);
  if (child_name = 'constrainedType') Then
     list.add(self.link, 'constrainedType', FConstrainedType.Link);
  if (child_name = 'abstract') Then
     list.add(self.link, 'abstract', FAbstract.Link);
  if (child_name = 'contextType') Then
     list.add(self.link, 'contextType', FContextType.Link);
  if (child_name = 'context') Then
    list.addAll(self, 'context', FContextList);
  if (child_name = 'base') Then
     list.add(self.link, 'base', FBase.Link);
  if (child_name = 'snapshot') Then
     list.add(self.link, 'snapshot', FSnapshot.Link);
  if (child_name = 'differential') Then
     list.add(self.link, 'differential', FDifferential.Link);
end;

procedure TFhirStructureDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));{2}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'display', 'string', false, TFhirString, FDisplay.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'experimental', 'boolean', false, TFhirBoolean, FExperimental.Link));{2}
  oList.add(TFHIRProperty.create(self, 'publisher', 'string', false, TFhirString, FPublisher.Link));{2}
  oList.add(TFHIRProperty.create(self, 'contact', '', true, TFhirStructureDefinitionContact, FContactList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'useContext', 'CodeableConcept', true, TFhirCodeableConcept, FUseContextList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'requirements', 'string', false, TFhirString, FRequirements.Link));{2}
  oList.add(TFHIRProperty.create(self, 'copyright', 'string', false, TFhirString, FCopyright.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'Coding', true, TFhirCoding, FCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'fhirVersion', 'id', false, TFhirId, FFhirVersion.Link));{2}
  oList.add(TFHIRProperty.create(self, 'mapping', '', true, TFhirStructureDefinitionMapping, FMappingList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'kind', 'code', false, TFHIREnum, FKind.Link));{1}
  oList.add(TFHIRProperty.create(self, 'constrainedType', 'code', false, TFhirCode, FConstrainedType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'abstract', 'boolean', false, TFhirBoolean, FAbstract.Link));{2}
  oList.add(TFHIRProperty.create(self, 'contextType', 'code', false, TFHIREnum, FContextType.Link));{1}
  oList.add(TFHIRProperty.create(self, 'context', 'string', true, TFhirString, FContextList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'base', 'uri', false, TFhirUri, FBase.Link));{2}
  oList.add(TFHIRProperty.create(self, 'snapshot', '', false, TFhirStructureDefinitionSnapshot, FSnapshot.Link));{2}
  oList.add(TFHIRProperty.create(self, 'differential', '', false, TFhirStructureDefinitionDifferential, FDifferential.Link));{2}
end;

function TFhirStructureDefinition.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'display') then
  begin
    DisplayElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirConformanceResourceStatusEnum, CODES_TFhirConformanceResourceStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'experimental') then
  begin
    ExperimentalElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    PublisherElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirStructureDefinitionContact){2a};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'useContext') then
  begin
    UseContextList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'requirements') then
  begin
    RequirementsElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else if (propName = 'fhirVersion') then
  begin
    FhirVersionElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'mapping') then
  begin
    MappingList.add(propValue as TFhirStructureDefinitionMapping){2a};
    result := propValue;
  end
  else if (propName = 'kind') then
  begin
    KindElement := asEnum(SYSTEMS_TFhirStructureDefinitionKindEnum, CODES_TFhirStructureDefinitionKindEnum, propValue);
    result := propValue
  end
  else if (propName = 'constrainedType') then
  begin
    ConstrainedTypeElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'abstract') then
  begin
    AbstractElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'contextType') then
  begin
    ContextTypeElement := asEnum(SYSTEMS_TFhirExtensionContextEnum, CODES_TFhirExtensionContextEnum, propValue);
    result := propValue
  end
  else if (propName = 'context') then
  begin
    ContextList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'base') then
  begin
    BaseElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'snapshot') then
  begin
    Snapshot := propValue as TFhirStructureDefinitionSnapshot{4b};
    result := propValue;
  end
  else if (propName = 'differential') then
  begin
    Differential := propValue as TFhirStructureDefinitionDifferential{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirStructureDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirStructureDefinitionContact){2a}
  else if (propName = 'useContext') then UseContextList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirCoding){2a}
  else if (propName = 'mapping') then MappingList.insertItem(index, propValue as TFhirStructureDefinitionMapping){2a}
  else if (propName = 'context') then ContextList.insertItem(index, asString(propValue)){2}
  else inherited;
end;

function TFhirStructureDefinition.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create() {5b}
  else if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'version') then result := TFhirString.create() {5b}
  else if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'display') then result := TFhirString.create() {5b}
  else if (propName = 'experimental') then result := TFhirBoolean.create() {5b}
  else if (propName = 'publisher') then result := TFhirString.create() {5b}
  else if (propName = 'contact') then result := ContactList.new(){2}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'useContext') then result := UseContextList.new(){2}
  else if (propName = 'requirements') then result := TFhirString.create() {5b}
  else if (propName = 'copyright') then result := TFhirString.create() {5b}
  else if (propName = 'code') then result := CodeList.new(){2}
  else if (propName = 'fhirVersion') then result := TFhirId.create() {5b}
  else if (propName = 'mapping') then result := MappingList.new(){2}
  else if (propName = 'constrainedType') then result := TFhirCode.create() {5b}
  else if (propName = 'abstract') then result := TFhirBoolean.create() {5b}
  else if (propName = 'context') then result := ContextList.new(){2}
  else if (propName = 'base') then result := TFhirUri.create() {5b}
  else if (propName = 'snapshot') then result := TFhirStructureDefinitionSnapshot.create(){4b}
  else if (propName = 'differential') then result := TFhirStructureDefinitionDifferential.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirStructureDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'uri'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'display') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'experimental') then result := 'boolean'
  else if (propName = 'publisher') then result := 'string'
  else if (propName = 'contact') then result := ''
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'useContext') then result := 'CodeableConcept'
  else if (propName = 'requirements') then result := 'string'
  else if (propName = 'copyright') then result := 'string'
  else if (propName = 'code') then result := 'Coding'
  else if (propName = 'fhirVersion') then result := 'id'
  else if (propName = 'mapping') then result := ''
  else if (propName = 'kind') then result := 'code'
  else if (propName = 'constrainedType') then result := 'code'
  else if (propName = 'abstract') then result := 'boolean'
  else if (propName = 'contextType') then result := 'code'
  else if (propName = 'context') then result := 'string'
  else if (propName = 'base') then result := 'uri'
  else if (propName = 'snapshot') then result := ''
  else if (propName = 'differential') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirStructureDefinition.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'display') then DisplayElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'experimental') then ExperimentalElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value) {2}
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'useContext') then deletePropertyValue('useContext', UseContextList, value) {2}
  else if (propName = 'requirements') then RequirementsElement := nil
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'code') then deletePropertyValue('code', CodeList, value) {2}
  else if (propName = 'fhirVersion') then FhirVersionElement := nil
  else if (propName = 'mapping') then deletePropertyValue('mapping', MappingList, value) {2}
  else if (propName = 'kind') then KindElement := nil
  else if (propName = 'constrainedType') then ConstrainedTypeElement := nil
  else if (propName = 'abstract') then AbstractElement := nil
  else if (propName = 'contextType') then ContextTypeElement := nil
  else if (propName = 'context') then deletePropertyValue('context', ContextList, value) {2}
  else if (propName = 'base') then BaseElement := nil
  else if (propName = 'snapshot') then SnapshotElement := nil
  else if (propName = 'differential') then DifferentialElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirStructureDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asUri(new){5b}
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'version') then VersionElement := asString(new){5b}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'display') then DisplayElement := asString(new){5b}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirConformanceResourceStatusEnum, CODES_TFhirConformanceResourceStatusEnum, new){4}
  else if (propName = 'experimental') then ExperimentalElement := asBoolean(new){5b}
  else if (propName = 'publisher') then PublisherElement := asString(new){5b}
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new) {2}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'useContext') then replacePropertyValue('useContext', UseContextList, existing, new) {2}
  else if (propName = 'requirements') then RequirementsElement := asString(new){5b}
  else if (propName = 'copyright') then CopyrightElement := asString(new){5b}
  else if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new) {2}
  else if (propName = 'fhirVersion') then FhirVersionElement := asId(new){5b}
  else if (propName = 'mapping') then replacePropertyValue('mapping', MappingList, existing, new) {2}
  else if (propName = 'kind') then KindElement := asEnum(SYSTEMS_TFhirStructureDefinitionKindEnum, CODES_TFhirStructureDefinitionKindEnum, new){4}
  else if (propName = 'constrainedType') then ConstrainedTypeElement := asCode(new){5b}
  else if (propName = 'abstract') then AbstractElement := asBoolean(new){5b}
  else if (propName = 'contextType') then ContextTypeElement := asEnum(SYSTEMS_TFhirExtensionContextEnum, CODES_TFhirExtensionContextEnum, new){4}
  else if (propName = 'context') then replacePropertyValue('context', ContextList, existing, new) {2}
  else if (propName = 'base') then BaseElement := asUri(new){5b}
  else if (propName = 'snapshot') then SnapshotElement := new as TFhirStructureDefinitionSnapshot{4}
  else if (propName = 'differential') then DifferentialElement := new as TFhirStructureDefinitionDifferential{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirStructureDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'contact') then ContactList.move(source, destination){2a}
  else if (propName = 'useContext') then UseContextList.move(source, destination){2a}
  else if (propName = 'code') then CodeList.move(source, destination){2a}
  else if (propName = 'mapping') then MappingList.move(source, destination){2a}
  else if (propName = 'context') then ContextList.move(source, destination){2}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirStructureDefinition.fhirType : string;
begin
  result := 'StructureDefinition';
end;

function TFhirStructureDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FidentifierList) and isEmptyProp(FVersion) and isEmptyProp(FName) and isEmptyProp(FDisplay) and isEmptyProp(FStatus) and isEmptyProp(FExperimental) and isEmptyProp(FPublisher) and isEmptyProp(FcontactList) and isEmptyProp(FDate) and isEmptyProp(FDescription) and isEmptyProp(FuseContextList) and isEmptyProp(FRequirements) and isEmptyProp(FCopyright) and isEmptyProp(FcodeList) and isEmptyProp(FFhirVersion) and isEmptyProp(FmappingList) and isEmptyProp(FKind) and isEmptyProp(FConstrainedType) and isEmptyProp(FAbstract) and isEmptyProp(FContextType) and isEmptyProp(FcontextList) and isEmptyProp(FBase) and isEmptyProp(FSnapshot) and isEmptyProp(FDifferential);
end;

function TFhirStructureDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirStructureDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirStructureDefinition)) then
    result := false
  else
  begin
    o := TFhirStructureDefinition(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(identifierList, o.identifierList, true) and 
      compareDeep(versionElement, o.versionElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(displayElement, o.displayElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(experimentalElement, o.experimentalElement, true) and compareDeep(publisherElement, o.publisherElement, true) and 
      compareDeep(contactList, o.contactList, true) and compareDeep(dateElement, o.dateElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(useContextList, o.useContextList, true) and 
      compareDeep(requirementsElement, o.requirementsElement, true) and compareDeep(copyrightElement, o.copyrightElement, true) and 
      compareDeep(codeList, o.codeList, true) and compareDeep(fhirVersionElement, o.fhirVersionElement, true) and 
      compareDeep(mappingList, o.mappingList, true) and compareDeep(kindElement, o.kindElement, true) and 
      compareDeep(constrainedTypeElement, o.constrainedTypeElement, true) and compareDeep(abstractElement, o.abstractElement, true) and 
      compareDeep(contextTypeElement, o.contextTypeElement, true) and compareDeep(contextList, o.contextList, true) and 
      compareDeep(baseElement, o.baseElement, true) and compareDeep(snapshotElement, o.snapshotElement, true) and 
      compareDeep(differentialElement, o.differentialElement, true);
  end;
end;

function TFhirStructureDefinition.Link : TFhirStructureDefinition;
begin
  result := TFhirStructureDefinition(inherited Link);
end;

function TFhirStructureDefinition.Clone : TFhirStructureDefinition;
begin
  result := TFhirStructureDefinition(inherited Clone);
end;

procedure TFhirStructureDefinition.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('display');
  fields.add('status');
  fields.add('experimental');
  fields.add('publisher');
  fields.add('contact');
  fields.add('date');
  fields.add('description');
  fields.add('useContext');
  fields.add('requirements');
  fields.add('copyright');
  fields.add('code');
  fields.add('fhirVersion');
  fields.add('mapping');
  fields.add('kind');
  fields.add('constrainedType');
  fields.add('abstract');
  fields.add('contextType');
  fields.add('context');
  fields.add('base');
  fields.add('snapshot');
  fields.add('differential');
end;

{ TFhirStructureDefinition }

Procedure TFhirStructureDefinition.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirStructureDefinition.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

Procedure TFhirStructureDefinition.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

Function TFhirStructureDefinition.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirStructureDefinition.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirStructureDefinition.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

Function TFhirStructureDefinition.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

Procedure TFhirStructureDefinition.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

Procedure TFhirStructureDefinition.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirStructureDefinition.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirStructureDefinition.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirStructureDefinition.SetDisplay(value : TFhirString);
begin
  FDisplay.free;
  FDisplay := value;
end;

Function TFhirStructureDefinition.GetDisplayST : String;
begin
  if FDisplay = nil then
    result := ''
  else
    result := FDisplay.value;
end;

Procedure TFhirStructureDefinition.SetDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FDisplay = nil then
      FDisplay := TFhirString.create;
    FDisplay.value := value
  end
  else if FDisplay <> nil then
    FDisplay.value := '';
end;

Procedure TFhirStructureDefinition.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirStructureDefinition.GetStatusST : TFhirConformanceResourceStatusEnum;
begin
  if FStatus = nil then
    result := TFhirConformanceResourceStatusEnum(0)
  else
    result := TFhirConformanceResourceStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirConformanceResourceStatusEnum, FStatus.value));
end;

Procedure TFhirStructureDefinition.SetStatusST(value : TFhirConformanceResourceStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirConformanceResourceStatusEnum[value], CODES_TFhirConformanceResourceStatusEnum[value]);
end;

Procedure TFhirStructureDefinition.SetExperimental(value : TFhirBoolean);
begin
  FExperimental.free;
  FExperimental := value;
end;

Function TFhirStructureDefinition.GetExperimentalST : Boolean;
begin
  if FExperimental = nil then
    result := false
  else
    result := FExperimental.value;
end;

Procedure TFhirStructureDefinition.SetExperimentalST(value : Boolean);
begin
  if FExperimental = nil then
    FExperimental := TFhirBoolean.create;
  FExperimental.value := value
end;

Procedure TFhirStructureDefinition.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

Function TFhirStructureDefinition.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

Procedure TFhirStructureDefinition.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

Function TFhirStructureDefinition.GetContactList : TFhirStructureDefinitionContactList;
begin
  if FContactList = nil then
    FContactList := TFhirStructureDefinitionContactList.Create;
  result := FContactList;
end;

Function TFhirStructureDefinition.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

Procedure TFhirStructureDefinition.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirStructureDefinition.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirStructureDefinition.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirStructureDefinition.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirStructureDefinition.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirStructureDefinition.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Function TFhirStructureDefinition.GetUseContextList : TFhirCodeableConceptList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirCodeableConceptList.Create;
  result := FUseContextList;
end;

Function TFhirStructureDefinition.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

Procedure TFhirStructureDefinition.SetRequirements(value : TFhirString);
begin
  FRequirements.free;
  FRequirements := value;
end;

Function TFhirStructureDefinition.GetRequirementsST : String;
begin
  if FRequirements = nil then
    result := ''
  else
    result := FRequirements.value;
end;

Procedure TFhirStructureDefinition.SetRequirementsST(value : String);
begin
  if value <> '' then
  begin
    if FRequirements = nil then
      FRequirements := TFhirString.create;
    FRequirements.value := value
  end
  else if FRequirements <> nil then
    FRequirements.value := '';
end;

Procedure TFhirStructureDefinition.SetCopyright(value : TFhirString);
begin
  FCopyright.free;
  FCopyright := value;
end;

Function TFhirStructureDefinition.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

Procedure TFhirStructureDefinition.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirString.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

Function TFhirStructureDefinition.GetCodeList : TFhirCodingList;
begin
  if FCodeList = nil then
    FCodeList := TFhirCodingList.Create;
  result := FCodeList;
end;

Function TFhirStructureDefinition.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

Procedure TFhirStructureDefinition.SetFhirVersion(value : TFhirId);
begin
  FFhirVersion.free;
  FFhirVersion := value;
end;

Function TFhirStructureDefinition.GetFhirVersionST : String;
begin
  if FFhirVersion = nil then
    result := ''
  else
    result := FFhirVersion.value;
end;

Procedure TFhirStructureDefinition.SetFhirVersionST(value : String);
begin
  if value <> '' then
  begin
    if FFhirVersion = nil then
      FFhirVersion := TFhirId.create;
    FFhirVersion.value := value
  end
  else if FFhirVersion <> nil then
    FFhirVersion.value := '';
end;

Function TFhirStructureDefinition.GetMappingList : TFhirStructureDefinitionMappingList;
begin
  if FMappingList = nil then
    FMappingList := TFhirStructureDefinitionMappingList.Create;
  result := FMappingList;
end;

Function TFhirStructureDefinition.GetHasMappingList : boolean;
begin
  result := (FMappingList <> nil) and (FMappingList.count > 0);
end;

Procedure TFhirStructureDefinition.SetKind(value : TFhirEnum);
begin
  FKind.free;
  FKind := value;
end;

Function TFhirStructureDefinition.GetKindST : TFhirStructureDefinitionKindEnum;
begin
  if FKind = nil then
    result := TFhirStructureDefinitionKindEnum(0)
  else
    result := TFhirStructureDefinitionKindEnum(StringArrayIndexOfSensitive(CODES_TFhirStructureDefinitionKindEnum, FKind.value));
end;

Procedure TFhirStructureDefinition.SetKindST(value : TFhirStructureDefinitionKindEnum);
begin
  if ord(value) = 0 then
    KindElement := nil
  else
    KindElement := TFhirEnum.create(SYSTEMS_TFhirStructureDefinitionKindEnum[value], CODES_TFhirStructureDefinitionKindEnum[value]);
end;

Procedure TFhirStructureDefinition.SetConstrainedType(value : TFhirCode);
begin
  FConstrainedType.free;
  FConstrainedType := value;
end;

Function TFhirStructureDefinition.GetConstrainedTypeST : String;
begin
  if FConstrainedType = nil then
    result := ''
  else
    result := FConstrainedType.value;
end;

Procedure TFhirStructureDefinition.SetConstrainedTypeST(value : String);
begin
  if value <> '' then
  begin
    if FConstrainedType = nil then
      FConstrainedType := TFhirCode.create;
    FConstrainedType.value := value
  end
  else if FConstrainedType <> nil then
    FConstrainedType.value := '';
end;

Procedure TFhirStructureDefinition.SetAbstract(value : TFhirBoolean);
begin
  FAbstract.free;
  FAbstract := value;
end;

Function TFhirStructureDefinition.GetAbstractST : Boolean;
begin
  if FAbstract = nil then
    result := false
  else
    result := FAbstract.value;
end;

Procedure TFhirStructureDefinition.SetAbstractST(value : Boolean);
begin
  if FAbstract = nil then
    FAbstract := TFhirBoolean.create;
  FAbstract.value := value
end;

Procedure TFhirStructureDefinition.SetContextType(value : TFhirEnum);
begin
  FContextType.free;
  FContextType := value;
end;

Function TFhirStructureDefinition.GetContextTypeST : TFhirExtensionContextEnum;
begin
  if FContextType = nil then
    result := TFhirExtensionContextEnum(0)
  else
    result := TFhirExtensionContextEnum(StringArrayIndexOfSensitive(CODES_TFhirExtensionContextEnum, FContextType.value));
end;

Procedure TFhirStructureDefinition.SetContextTypeST(value : TFhirExtensionContextEnum);
begin
  if ord(value) = 0 then
    ContextTypeElement := nil
  else
    ContextTypeElement := TFhirEnum.create(SYSTEMS_TFhirExtensionContextEnum[value], CODES_TFhirExtensionContextEnum[value]);
end;

Function TFhirStructureDefinition.GetContextList : TFhirStringList;
begin
  if FContextList = nil then
    FContextList := TFhirStringList.Create;
  result := FContextList;
end;

Function TFhirStructureDefinition.GetHasContextList : boolean;
begin
  result := (FContextList <> nil) and (FContextList.count > 0);
end;

Procedure TFhirStructureDefinition.SetBase(value : TFhirUri);
begin
  FBase.free;
  FBase := value;
end;

Function TFhirStructureDefinition.GetBaseST : String;
begin
  if FBase = nil then
    result := ''
  else
    result := FBase.value;
end;

Procedure TFhirStructureDefinition.SetBaseST(value : String);
begin
  if value <> '' then
  begin
    if FBase = nil then
      FBase := TFhirUri.create;
    FBase.value := value
  end
  else if FBase <> nil then
    FBase.value := '';
end;

Procedure TFhirStructureDefinition.SetSnapshot(value : TFhirStructureDefinitionSnapshot);
begin
  FSnapshot.free;
  FSnapshot := value;
end;

Procedure TFhirStructureDefinition.SetDifferential(value : TFhirStructureDefinitionDifferential);
begin
  FDifferential.free;
  FDifferential := value;
end;

function TFhirStructureDefinition.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FUrl.sizeInBytes);
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FVersion.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FDisplay.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FExperimental.sizeInBytes);
  inc(result, FPublisher.sizeInBytes);
  inc(result, FcontactList.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FuseContextList.sizeInBytes);
  inc(result, FRequirements.sizeInBytes);
  inc(result, FCopyright.sizeInBytes);
  inc(result, FcodeList.sizeInBytes);
  inc(result, FFhirVersion.sizeInBytes);
  inc(result, FmappingList.sizeInBytes);
  inc(result, FKind.sizeInBytes);
  inc(result, FConstrainedType.sizeInBytes);
  inc(result, FAbstract.sizeInBytes);
  inc(result, FContextType.sizeInBytes);
  inc(result, FcontextList.sizeInBytes);
  inc(result, FBase.sizeInBytes);
  inc(result, FSnapshot.sizeInBytes);
  inc(result, FDifferential.sizeInBytes);
end;

{ TFhirStructureDefinitionListEnumerator }

Constructor TFhirStructureDefinitionListEnumerator.Create(list : TFhirStructureDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirStructureDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirStructureDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirStructureDefinitionListEnumerator.GetCurrent : TFhirStructureDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirStructureDefinitionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirStructureDefinitionList }
procedure TFhirStructureDefinitionList.AddItem(value: TFhirStructureDefinition);
begin
  assert(value.ClassName = 'TFhirStructureDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirStructureDefinition');
  add(value);
end;

function TFhirStructureDefinitionList.Append: TFhirStructureDefinition;
begin
  result := TFhirStructureDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirStructureDefinitionList.GetEnumerator : TFhirStructureDefinitionListEnumerator;
begin
  result := TFhirStructureDefinitionListEnumerator.Create(self.link);
end;

function TFhirStructureDefinitionList.Clone: TFhirStructureDefinitionList;
begin
  result := TFhirStructureDefinitionList(inherited Clone);
end;

function TFhirStructureDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirStructureDefinitionList.GetItemN(index: Integer): TFhirStructureDefinition;
begin
  result := TFhirStructureDefinition(ObjectByIndex[index]);
end;

function TFhirStructureDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirStructureDefinition;
end;
function TFhirStructureDefinitionList.IndexOf(value: TFhirStructureDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirStructureDefinitionList.Insert(index: Integer): TFhirStructureDefinition;
begin
  result := TFhirStructureDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureDefinitionList.InsertItem(index: Integer; value: TFhirStructureDefinition);
begin
  assert(value is TFhirStructureDefinition);
  Inherited Insert(index, value);
end;

function TFhirStructureDefinitionList.Item(index: Integer): TFhirStructureDefinition;
begin
  result := TFhirStructureDefinition(ObjectByIndex[index]);
end;

function TFhirStructureDefinitionList.Link: TFhirStructureDefinitionList;
begin
  result := TFhirStructureDefinitionList(inherited Link);
end;

procedure TFhirStructureDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirStructureDefinitionList.SetItemByIndex(index: Integer; value: TFhirStructureDefinition);
begin
  assert(value is TFhirStructureDefinition);
  FhirStructureDefinitions[index] := value;
end;

procedure TFhirStructureDefinitionList.SetItemN(index: Integer; value: TFhirStructureDefinition);
begin
  assert(value is TFhirStructureDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_STRUCTUREDEFINITION}

{$IFDEF FHIR_TESTSCRIPT}

{ TFhirTestScriptContact }

constructor TFhirTestScriptContact.Create;
begin
  inherited;
end;

destructor TFhirTestScriptContact.Destroy;
begin
  FName.free;
  FTelecomList.Free;
  inherited;
end;

procedure TFhirTestScriptContact.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirTestScriptContact(oSource).nameElement.Clone;
  if (TFhirTestScriptContact(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirTestScriptContact(oSource).FTelecomList);
  end;
end;

procedure TFhirTestScriptContact.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
end;

procedure TFhirTestScriptContact.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link)){3};
end;

function TFhirTestScriptContact.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptContact.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint){2a}
  else inherited;
end;

function TFhirTestScriptContact.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'telecom') then result := TelecomList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptContact.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptContact.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptContact.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptContact.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'telecom') then TelecomList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptContact.fhirType : string;
begin
  result := 'contact';
end;

function TFhirTestScriptContact.Link : TFhirTestScriptContact;
begin
  result := TFhirTestScriptContact(inherited Link);
end;

function TFhirTestScriptContact.Clone : TFhirTestScriptContact;
begin
  result := TFhirTestScriptContact(inherited Clone);
end;

function TFhirTestScriptContact.equals(other : TObject) : boolean; 
var
  o : TFhirTestScriptContact;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptContact)) then
    result := false
  else
  begin
    o := TFhirTestScriptContact(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(telecomList, o.telecomList, true);
  end;
end;

function TFhirTestScriptContact.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FtelecomList);
end;

procedure TFhirTestScriptContact.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('telecom');
end;

{ TFhirTestScriptContact }

Procedure TFhirTestScriptContact.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirTestScriptContact.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirTestScriptContact.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Function TFhirTestScriptContact.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

Function TFhirTestScriptContact.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

function TFhirTestScriptContact.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FtelecomList.sizeInBytes);
end;

{ TFhirTestScriptContactListEnumerator }

Constructor TFhirTestScriptContactListEnumerator.Create(list : TFhirTestScriptContactList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptContactListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptContactListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptContactListEnumerator.GetCurrent : TFhirTestScriptContact;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptContactListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestScriptContactList }
procedure TFhirTestScriptContactList.AddItem(value: TFhirTestScriptContact);
begin
  assert(value.ClassName = 'TFhirTestScriptContact', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptContact');
  add(value);
end;

function TFhirTestScriptContactList.Append: TFhirTestScriptContact;
begin
  result := TFhirTestScriptContact.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptContactList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptContactList.GetEnumerator : TFhirTestScriptContactListEnumerator;
begin
  result := TFhirTestScriptContactListEnumerator.Create(self.link);
end;

function TFhirTestScriptContactList.Clone: TFhirTestScriptContactList;
begin
  result := TFhirTestScriptContactList(inherited Clone);
end;

function TFhirTestScriptContactList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptContactList.GetItemN(index: Integer): TFhirTestScriptContact;
begin
  result := TFhirTestScriptContact(ObjectByIndex[index]);
end;

function TFhirTestScriptContactList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptContact;
end;
function TFhirTestScriptContactList.IndexOf(value: TFhirTestScriptContact): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptContactList.Insert(index: Integer): TFhirTestScriptContact;
begin
  result := TFhirTestScriptContact.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptContactList.InsertItem(index: Integer; value: TFhirTestScriptContact);
begin
  assert(value is TFhirTestScriptContact);
  Inherited Insert(index, value);
end;

function TFhirTestScriptContactList.Item(index: Integer): TFhirTestScriptContact;
begin
  result := TFhirTestScriptContact(ObjectByIndex[index]);
end;

function TFhirTestScriptContactList.Link: TFhirTestScriptContactList;
begin
  result := TFhirTestScriptContactList(inherited Link);
end;

procedure TFhirTestScriptContactList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptContactList.SetItemByIndex(index: Integer; value: TFhirTestScriptContact);
begin
  assert(value is TFhirTestScriptContact);
  FhirTestScriptContacts[index] := value;
end;

procedure TFhirTestScriptContactList.SetItemN(index: Integer; value: TFhirTestScriptContact);
begin
  assert(value is TFhirTestScriptContact);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptMetadata }

constructor TFhirTestScriptMetadata.Create;
begin
  inherited;
end;

destructor TFhirTestScriptMetadata.Destroy;
begin
  FLink_List.Free;
  FCapabilityList.Free;
  inherited;
end;

procedure TFhirTestScriptMetadata.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirTestScriptMetadata(oSource).FLink_List = nil) then
  begin
    FLink_List.free;
    FLink_List := nil;
  end
  else
  begin
    if FLink_List = nil then
      FLink_List := TFhirTestScriptMetadataLinkList.Create;
    FLink_List.Assign(TFhirTestScriptMetadata(oSource).FLink_List);
  end;
  if (TFhirTestScriptMetadata(oSource).FCapabilityList = nil) then
  begin
    FCapabilityList.free;
    FCapabilityList := nil;
  end
  else
  begin
    if FCapabilityList = nil then
      FCapabilityList := TFhirTestScriptMetadataCapabilityList.Create;
    FCapabilityList.Assign(TFhirTestScriptMetadata(oSource).FCapabilityList);
  end;
end;

procedure TFhirTestScriptMetadata.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'link') Then
    list.addAll(self, 'link', FLink_List);
  if (child_name = 'capability') Then
    list.addAll(self, 'capability', FCapabilityList);
end;

procedure TFhirTestScriptMetadata.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'link', '', true, TFhirTestScriptMetadataLink, FLink_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'capability', '', true, TFhirTestScriptMetadataCapability, FCapabilityList.Link)){3};
end;

function TFhirTestScriptMetadata.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'link') then
  begin
    Link_List.add(propValue as TFhirTestScriptMetadataLink){2a};
    result := propValue;
  end
  else if (propName = 'capability') then
  begin
    CapabilityList.add(propValue as TFhirTestScriptMetadataCapability){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptMetadata.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'link') then Link_List.insertItem(index, propValue as TFhirTestScriptMetadataLink){2a}
  else if (propName = 'capability') then CapabilityList.insertItem(index, propValue as TFhirTestScriptMetadataCapability){2a}
  else inherited;
end;

function TFhirTestScriptMetadata.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'link') then result := Link_List.new(){2}
  else if (propName = 'capability') then result := CapabilityList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptMetadata.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'link') then result := ''
  else if (propName = 'capability') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptMetadata.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'link') then deletePropertyValue('link', Link_List, value) {2}
  else if (propName = 'capability') then deletePropertyValue('capability', CapabilityList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptMetadata.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'link') then replacePropertyValue('link', Link_List, existing, new) {2}
  else if (propName = 'capability') then replacePropertyValue('capability', CapabilityList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptMetadata.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'link') then Link_List.move(source, destination){2a}
  else if (propName = 'capability') then CapabilityList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptMetadata.fhirType : string;
begin
  result := 'metadata';
end;

function TFhirTestScriptMetadata.Link : TFhirTestScriptMetadata;
begin
  result := TFhirTestScriptMetadata(inherited Link);
end;

function TFhirTestScriptMetadata.Clone : TFhirTestScriptMetadata;
begin
  result := TFhirTestScriptMetadata(inherited Clone);
end;

function TFhirTestScriptMetadata.equals(other : TObject) : boolean; 
var
  o : TFhirTestScriptMetadata;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptMetadata)) then
    result := false
  else
  begin
    o := TFhirTestScriptMetadata(other);
    result := compareDeep(link_List, o.link_List, true) and compareDeep(capabilityList, o.capabilityList, true);
  end;
end;

function TFhirTestScriptMetadata.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(Flink_List) and isEmptyProp(FcapabilityList);
end;

procedure TFhirTestScriptMetadata.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('link');
  fields.add('capability');
end;

{ TFhirTestScriptMetadata }

Function TFhirTestScriptMetadata.GetLink_List : TFhirTestScriptMetadataLinkList;
begin
  if FLink_List = nil then
    FLink_List := TFhirTestScriptMetadataLinkList.Create;
  result := FLink_List;
end;

Function TFhirTestScriptMetadata.GetHasLink_List : boolean;
begin
  result := (FLink_List <> nil) and (FLink_List.count > 0);
end;

Function TFhirTestScriptMetadata.GetCapabilityList : TFhirTestScriptMetadataCapabilityList;
begin
  if FCapabilityList = nil then
    FCapabilityList := TFhirTestScriptMetadataCapabilityList.Create;
  result := FCapabilityList;
end;

Function TFhirTestScriptMetadata.GetHasCapabilityList : boolean;
begin
  result := (FCapabilityList <> nil) and (FCapabilityList.count > 0);
end;

function TFhirTestScriptMetadata.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, Flink_List.sizeInBytes);
  inc(result, FcapabilityList.sizeInBytes);
end;

{ TFhirTestScriptMetadataListEnumerator }

Constructor TFhirTestScriptMetadataListEnumerator.Create(list : TFhirTestScriptMetadataList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptMetadataListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptMetadataListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptMetadataListEnumerator.GetCurrent : TFhirTestScriptMetadata;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptMetadataListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestScriptMetadataList }
procedure TFhirTestScriptMetadataList.AddItem(value: TFhirTestScriptMetadata);
begin
  assert(value.ClassName = 'TFhirTestScriptMetadata', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptMetadata');
  add(value);
end;

function TFhirTestScriptMetadataList.Append: TFhirTestScriptMetadata;
begin
  result := TFhirTestScriptMetadata.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptMetadataList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptMetadataList.GetEnumerator : TFhirTestScriptMetadataListEnumerator;
begin
  result := TFhirTestScriptMetadataListEnumerator.Create(self.link);
end;

function TFhirTestScriptMetadataList.Clone: TFhirTestScriptMetadataList;
begin
  result := TFhirTestScriptMetadataList(inherited Clone);
end;

function TFhirTestScriptMetadataList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptMetadataList.GetItemN(index: Integer): TFhirTestScriptMetadata;
begin
  result := TFhirTestScriptMetadata(ObjectByIndex[index]);
end;

function TFhirTestScriptMetadataList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptMetadata;
end;
function TFhirTestScriptMetadataList.IndexOf(value: TFhirTestScriptMetadata): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptMetadataList.Insert(index: Integer): TFhirTestScriptMetadata;
begin
  result := TFhirTestScriptMetadata.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptMetadataList.InsertItem(index: Integer; value: TFhirTestScriptMetadata);
begin
  assert(value is TFhirTestScriptMetadata);
  Inherited Insert(index, value);
end;

function TFhirTestScriptMetadataList.Item(index: Integer): TFhirTestScriptMetadata;
begin
  result := TFhirTestScriptMetadata(ObjectByIndex[index]);
end;

function TFhirTestScriptMetadataList.Link: TFhirTestScriptMetadataList;
begin
  result := TFhirTestScriptMetadataList(inherited Link);
end;

procedure TFhirTestScriptMetadataList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptMetadataList.SetItemByIndex(index: Integer; value: TFhirTestScriptMetadata);
begin
  assert(value is TFhirTestScriptMetadata);
  FhirTestScriptMetadata[index] := value;
end;

procedure TFhirTestScriptMetadataList.SetItemN(index: Integer; value: TFhirTestScriptMetadata);
begin
  assert(value is TFhirTestScriptMetadata);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptMetadataLink }

constructor TFhirTestScriptMetadataLink.Create;
begin
  inherited;
end;

destructor TFhirTestScriptMetadataLink.Destroy;
begin
  FUrl.free;
  FDescription.free;
  inherited;
end;

procedure TFhirTestScriptMetadataLink.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirTestScriptMetadataLink(oSource).urlElement.Clone;
  descriptionElement := TFhirTestScriptMetadataLink(oSource).descriptionElement.Clone;
end;

procedure TFhirTestScriptMetadataLink.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
end;

procedure TFhirTestScriptMetadataLink.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
end;

function TFhirTestScriptMetadataLink.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptMetadataLink.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestScriptMetadataLink.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptMetadataLink.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'uri'
  else if (propName = 'description') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptMetadataLink.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptMetadataLink.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asUri(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptMetadataLink.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptMetadataLink.fhirType : string;
begin
  result := 'link';
end;

function TFhirTestScriptMetadataLink.Link : TFhirTestScriptMetadataLink;
begin
  result := TFhirTestScriptMetadataLink(inherited Link);
end;

function TFhirTestScriptMetadataLink.Clone : TFhirTestScriptMetadataLink;
begin
  result := TFhirTestScriptMetadataLink(inherited Clone);
end;

function TFhirTestScriptMetadataLink.equals(other : TObject) : boolean; 
var
  o : TFhirTestScriptMetadataLink;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptMetadataLink)) then
    result := false
  else
  begin
    o := TFhirTestScriptMetadataLink(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(descriptionElement, o.descriptionElement, true);
  end;
end;

function TFhirTestScriptMetadataLink.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FDescription);
end;

procedure TFhirTestScriptMetadataLink.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('url');
  fields.add('description');
end;

{ TFhirTestScriptMetadataLink }

Procedure TFhirTestScriptMetadataLink.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirTestScriptMetadataLink.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

Procedure TFhirTestScriptMetadataLink.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

Procedure TFhirTestScriptMetadataLink.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirTestScriptMetadataLink.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirTestScriptMetadataLink.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirTestScriptMetadataLink.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FUrl.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
end;

{ TFhirTestScriptMetadataLinkListEnumerator }

Constructor TFhirTestScriptMetadataLinkListEnumerator.Create(list : TFhirTestScriptMetadataLinkList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptMetadataLinkListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptMetadataLinkListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptMetadataLinkListEnumerator.GetCurrent : TFhirTestScriptMetadataLink;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptMetadataLinkListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestScriptMetadataLinkList }
procedure TFhirTestScriptMetadataLinkList.AddItem(value: TFhirTestScriptMetadataLink);
begin
  assert(value.ClassName = 'TFhirTestScriptMetadataLink', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptMetadataLink');
  add(value);
end;

function TFhirTestScriptMetadataLinkList.Append: TFhirTestScriptMetadataLink;
begin
  result := TFhirTestScriptMetadataLink.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptMetadataLinkList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptMetadataLinkList.GetEnumerator : TFhirTestScriptMetadataLinkListEnumerator;
begin
  result := TFhirTestScriptMetadataLinkListEnumerator.Create(self.link);
end;

function TFhirTestScriptMetadataLinkList.Clone: TFhirTestScriptMetadataLinkList;
begin
  result := TFhirTestScriptMetadataLinkList(inherited Clone);
end;

function TFhirTestScriptMetadataLinkList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptMetadataLinkList.GetItemN(index: Integer): TFhirTestScriptMetadataLink;
begin
  result := TFhirTestScriptMetadataLink(ObjectByIndex[index]);
end;

function TFhirTestScriptMetadataLinkList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptMetadataLink;
end;
function TFhirTestScriptMetadataLinkList.IndexOf(value: TFhirTestScriptMetadataLink): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptMetadataLinkList.Insert(index: Integer): TFhirTestScriptMetadataLink;
begin
  result := TFhirTestScriptMetadataLink.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptMetadataLinkList.InsertItem(index: Integer; value: TFhirTestScriptMetadataLink);
begin
  assert(value is TFhirTestScriptMetadataLink);
  Inherited Insert(index, value);
end;

function TFhirTestScriptMetadataLinkList.Item(index: Integer): TFhirTestScriptMetadataLink;
begin
  result := TFhirTestScriptMetadataLink(ObjectByIndex[index]);
end;

function TFhirTestScriptMetadataLinkList.Link: TFhirTestScriptMetadataLinkList;
begin
  result := TFhirTestScriptMetadataLinkList(inherited Link);
end;

procedure TFhirTestScriptMetadataLinkList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptMetadataLinkList.SetItemByIndex(index: Integer; value: TFhirTestScriptMetadataLink);
begin
  assert(value is TFhirTestScriptMetadataLink);
  FhirTestScriptMetadataLinks[index] := value;
end;

procedure TFhirTestScriptMetadataLinkList.SetItemN(index: Integer; value: TFhirTestScriptMetadataLink);
begin
  assert(value is TFhirTestScriptMetadataLink);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptMetadataCapability }

constructor TFhirTestScriptMetadataCapability.Create;
begin
  inherited;
end;

destructor TFhirTestScriptMetadataCapability.Destroy;
begin
  FRequired.free;
  FValidated.free;
  FDescription.free;
  FDestination.free;
  FLink_List.Free;
  FConformance.free;
  inherited;
end;

procedure TFhirTestScriptMetadataCapability.Assign(oSource : TFslObject);
begin
  inherited;
  requiredElement := TFhirTestScriptMetadataCapability(oSource).requiredElement.Clone;
  validatedElement := TFhirTestScriptMetadataCapability(oSource).validatedElement.Clone;
  descriptionElement := TFhirTestScriptMetadataCapability(oSource).descriptionElement.Clone;
  destinationElement := TFhirTestScriptMetadataCapability(oSource).destinationElement.Clone;
  if (TFhirTestScriptMetadataCapability(oSource).FLink_List = nil) then
  begin
    FLink_List.free;
    FLink_List := nil;
  end
  else
  begin
    if FLink_List = nil then
      FLink_List := TFhirUriList.Create;
    FLink_List.Assign(TFhirTestScriptMetadataCapability(oSource).FLink_List);
  end;
  conformance := TFhirTestScriptMetadataCapability(oSource).conformance.Clone;
end;

procedure TFhirTestScriptMetadataCapability.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'required') Then
     list.add(self.link, 'required', FRequired.Link);
  if (child_name = 'validated') Then
     list.add(self.link, 'validated', FValidated.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'destination') Then
     list.add(self.link, 'destination', FDestination.Link);
  if (child_name = 'link') Then
    list.addAll(self, 'link', FLink_List);
  if (child_name = 'conformance') Then
     list.add(self.link, 'conformance', FConformance.Link);
end;

procedure TFhirTestScriptMetadataCapability.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'required', 'boolean', false, TFhirBoolean, FRequired.Link));{2}
  oList.add(TFHIRProperty.create(self, 'validated', 'boolean', false, TFhirBoolean, FValidated.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'destination', 'integer', false, TFhirInteger, FDestination.Link));{2}
  oList.add(TFHIRProperty.create(self, 'link', 'uri', true, TFhirUri, FLink_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'conformance', 'Reference(Conformance)', false, TFhirReference{TFhirConformance}, FConformance.Link));{2}
end;

function TFhirTestScriptMetadataCapability.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'required') then
  begin
    RequiredElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'validated') then
  begin
    ValidatedElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'destination') then
  begin
    DestinationElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'link') then
  begin
    Link_List.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'conformance') then
  begin
    Conformance := propValue as TFhirReference{TFhirConformance}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptMetadataCapability.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'link') then Link_List.insertItem(index, asUri(propValue)){2}
  else inherited;
end;

function TFhirTestScriptMetadataCapability.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'required') then result := TFhirBoolean.create() {5b}
  else if (propName = 'validated') then result := TFhirBoolean.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'destination') then result := TFhirInteger.create() {5b}
  else if (propName = 'link') then result := Link_List.new(){2}
  else if (propName = 'conformance') then result := TFhirReference{TFhirConformance}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptMetadataCapability.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'required') then result := 'boolean'
  else if (propName = 'validated') then result := 'boolean'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'destination') then result := 'integer'
  else if (propName = 'link') then result := 'uri'
  else if (propName = 'conformance') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptMetadataCapability.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'required') then RequiredElement := nil
  else if (propName = 'validated') then ValidatedElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'destination') then DestinationElement := nil
  else if (propName = 'link') then deletePropertyValue('link', Link_List, value) {2}
  else if (propName = 'conformance') then ConformanceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptMetadataCapability.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'required') then RequiredElement := asBoolean(new){5b}
  else if (propName = 'validated') then ValidatedElement := asBoolean(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'destination') then DestinationElement := asInteger(new){5b}
  else if (propName = 'link') then replacePropertyValue('link', Link_List, existing, new) {2}
  else if (propName = 'conformance') then ConformanceElement := new as TFhirReference{TFhirConformance}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptMetadataCapability.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'link') then Link_List.move(source, destination){2}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptMetadataCapability.fhirType : string;
begin
  result := 'capability';
end;

function TFhirTestScriptMetadataCapability.Link : TFhirTestScriptMetadataCapability;
begin
  result := TFhirTestScriptMetadataCapability(inherited Link);
end;

function TFhirTestScriptMetadataCapability.Clone : TFhirTestScriptMetadataCapability;
begin
  result := TFhirTestScriptMetadataCapability(inherited Clone);
end;

function TFhirTestScriptMetadataCapability.equals(other : TObject) : boolean; 
var
  o : TFhirTestScriptMetadataCapability;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptMetadataCapability)) then
    result := false
  else
  begin
    o := TFhirTestScriptMetadataCapability(other);
    result := compareDeep(requiredElement, o.requiredElement, true) and compareDeep(validatedElement, o.validatedElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(destinationElement, o.destinationElement, true) and 
      compareDeep(link_List, o.link_List, true) and compareDeep(conformanceElement, o.conformanceElement, true);
  end;
end;

function TFhirTestScriptMetadataCapability.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRequired) and isEmptyProp(FValidated) and isEmptyProp(FDescription) and isEmptyProp(FDestination) and isEmptyProp(Flink_List) and isEmptyProp(FConformance);
end;

procedure TFhirTestScriptMetadataCapability.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('required');
  fields.add('validated');
  fields.add('description');
  fields.add('destination');
  fields.add('link');
  fields.add('conformance');
end;

{ TFhirTestScriptMetadataCapability }

Procedure TFhirTestScriptMetadataCapability.SetRequired(value : TFhirBoolean);
begin
  FRequired.free;
  FRequired := value;
end;

Function TFhirTestScriptMetadataCapability.GetRequiredST : Boolean;
begin
  if FRequired = nil then
    result := false
  else
    result := FRequired.value;
end;

Procedure TFhirTestScriptMetadataCapability.SetRequiredST(value : Boolean);
begin
  if FRequired = nil then
    FRequired := TFhirBoolean.create;
  FRequired.value := value
end;

Procedure TFhirTestScriptMetadataCapability.SetValidated(value : TFhirBoolean);
begin
  FValidated.free;
  FValidated := value;
end;

Function TFhirTestScriptMetadataCapability.GetValidatedST : Boolean;
begin
  if FValidated = nil then
    result := false
  else
    result := FValidated.value;
end;

Procedure TFhirTestScriptMetadataCapability.SetValidatedST(value : Boolean);
begin
  if FValidated = nil then
    FValidated := TFhirBoolean.create;
  FValidated.value := value
end;

Procedure TFhirTestScriptMetadataCapability.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirTestScriptMetadataCapability.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirTestScriptMetadataCapability.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirTestScriptMetadataCapability.SetDestination(value : TFhirInteger);
begin
  FDestination.free;
  FDestination := value;
end;

Function TFhirTestScriptMetadataCapability.GetDestinationST : String;
begin
  if FDestination = nil then
    result := ''
  else
    result := FDestination.value;
end;

Procedure TFhirTestScriptMetadataCapability.SetDestinationST(value : String);
begin
  if value <> '' then
  begin
    if FDestination = nil then
      FDestination := TFhirInteger.create;
    FDestination.value := value
  end
  else if FDestination <> nil then
    FDestination.value := '';
end;

Function TFhirTestScriptMetadataCapability.GetLink_List : TFhirUriList;
begin
  if FLink_List = nil then
    FLink_List := TFhirUriList.Create;
  result := FLink_List;
end;

Function TFhirTestScriptMetadataCapability.GetHasLink_List : boolean;
begin
  result := (FLink_List <> nil) and (FLink_List.count > 0);
end;

Procedure TFhirTestScriptMetadataCapability.SetConformance(value : TFhirReference{TFhirConformance});
begin
  FConformance.free;
  FConformance := value;
end;

function TFhirTestScriptMetadataCapability.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FRequired.sizeInBytes);
  inc(result, FValidated.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FDestination.sizeInBytes);
  inc(result, Flink_List.sizeInBytes);
  inc(result, FConformance.sizeInBytes);
end;

{ TFhirTestScriptMetadataCapabilityListEnumerator }

Constructor TFhirTestScriptMetadataCapabilityListEnumerator.Create(list : TFhirTestScriptMetadataCapabilityList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptMetadataCapabilityListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptMetadataCapabilityListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptMetadataCapabilityListEnumerator.GetCurrent : TFhirTestScriptMetadataCapability;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptMetadataCapabilityListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestScriptMetadataCapabilityList }
procedure TFhirTestScriptMetadataCapabilityList.AddItem(value: TFhirTestScriptMetadataCapability);
begin
  assert(value.ClassName = 'TFhirTestScriptMetadataCapability', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptMetadataCapability');
  add(value);
end;

function TFhirTestScriptMetadataCapabilityList.Append: TFhirTestScriptMetadataCapability;
begin
  result := TFhirTestScriptMetadataCapability.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptMetadataCapabilityList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptMetadataCapabilityList.GetEnumerator : TFhirTestScriptMetadataCapabilityListEnumerator;
begin
  result := TFhirTestScriptMetadataCapabilityListEnumerator.Create(self.link);
end;

function TFhirTestScriptMetadataCapabilityList.Clone: TFhirTestScriptMetadataCapabilityList;
begin
  result := TFhirTestScriptMetadataCapabilityList(inherited Clone);
end;

function TFhirTestScriptMetadataCapabilityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptMetadataCapabilityList.GetItemN(index: Integer): TFhirTestScriptMetadataCapability;
begin
  result := TFhirTestScriptMetadataCapability(ObjectByIndex[index]);
end;

function TFhirTestScriptMetadataCapabilityList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptMetadataCapability;
end;
function TFhirTestScriptMetadataCapabilityList.IndexOf(value: TFhirTestScriptMetadataCapability): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptMetadataCapabilityList.Insert(index: Integer): TFhirTestScriptMetadataCapability;
begin
  result := TFhirTestScriptMetadataCapability.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptMetadataCapabilityList.InsertItem(index: Integer; value: TFhirTestScriptMetadataCapability);
begin
  assert(value is TFhirTestScriptMetadataCapability);
  Inherited Insert(index, value);
end;

function TFhirTestScriptMetadataCapabilityList.Item(index: Integer): TFhirTestScriptMetadataCapability;
begin
  result := TFhirTestScriptMetadataCapability(ObjectByIndex[index]);
end;

function TFhirTestScriptMetadataCapabilityList.Link: TFhirTestScriptMetadataCapabilityList;
begin
  result := TFhirTestScriptMetadataCapabilityList(inherited Link);
end;

procedure TFhirTestScriptMetadataCapabilityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptMetadataCapabilityList.SetItemByIndex(index: Integer; value: TFhirTestScriptMetadataCapability);
begin
  assert(value is TFhirTestScriptMetadataCapability);
  FhirTestScriptMetadataCapabilities[index] := value;
end;

procedure TFhirTestScriptMetadataCapabilityList.SetItemN(index: Integer; value: TFhirTestScriptMetadataCapability);
begin
  assert(value is TFhirTestScriptMetadataCapability);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptFixture }

constructor TFhirTestScriptFixture.Create;
begin
  inherited;
end;

destructor TFhirTestScriptFixture.Destroy;
begin
  FAutocreate.free;
  FAutodelete.free;
  FResource.free;
  inherited;
end;

procedure TFhirTestScriptFixture.Assign(oSource : TFslObject);
begin
  inherited;
  autocreateElement := TFhirTestScriptFixture(oSource).autocreateElement.Clone;
  autodeleteElement := TFhirTestScriptFixture(oSource).autodeleteElement.Clone;
  resource := TFhirTestScriptFixture(oSource).resource.Clone;
end;

procedure TFhirTestScriptFixture.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'autocreate') Then
     list.add(self.link, 'autocreate', FAutocreate.Link);
  if (child_name = 'autodelete') Then
     list.add(self.link, 'autodelete', FAutodelete.Link);
  if (child_name = 'resource') Then
     list.add(self.link, 'resource', FResource.Link);
end;

procedure TFhirTestScriptFixture.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'autocreate', 'boolean', false, TFhirBoolean, FAutocreate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'autodelete', 'boolean', false, TFhirBoolean, FAutodelete.Link));{2}
  oList.add(TFHIRProperty.create(self, 'resource', 'Reference(Any)', false, TFhirReference{TFhirReference}, FResource.Link));{2}
end;

function TFhirTestScriptFixture.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'autocreate') then
  begin
    AutocreateElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'autodelete') then
  begin
    AutodeleteElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'resource') then
  begin
    Resource := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptFixture.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestScriptFixture.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'autocreate') then result := TFhirBoolean.create() {5b}
  else if (propName = 'autodelete') then result := TFhirBoolean.create() {5b}
  else if (propName = 'resource') then result := TFhirReference{TFhirReference}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptFixture.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'autocreate') then result := 'boolean'
  else if (propName = 'autodelete') then result := 'boolean'
  else if (propName = 'resource') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptFixture.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'autocreate') then AutocreateElement := nil
  else if (propName = 'autodelete') then AutodeleteElement := nil
  else if (propName = 'resource') then ResourceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptFixture.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'autocreate') then AutocreateElement := asBoolean(new){5b}
  else if (propName = 'autodelete') then AutodeleteElement := asBoolean(new){5b}
  else if (propName = 'resource') then ResourceElement := new as TFhirReference{TFhirReference}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptFixture.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptFixture.fhirType : string;
begin
  result := 'fixture';
end;

function TFhirTestScriptFixture.Link : TFhirTestScriptFixture;
begin
  result := TFhirTestScriptFixture(inherited Link);
end;

function TFhirTestScriptFixture.Clone : TFhirTestScriptFixture;
begin
  result := TFhirTestScriptFixture(inherited Clone);
end;

function TFhirTestScriptFixture.equals(other : TObject) : boolean; 
var
  o : TFhirTestScriptFixture;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptFixture)) then
    result := false
  else
  begin
    o := TFhirTestScriptFixture(other);
    result := compareDeep(autocreateElement, o.autocreateElement, true) and compareDeep(autodeleteElement, o.autodeleteElement, true) and 
      compareDeep(resourceElement, o.resourceElement, true);
  end;
end;

function TFhirTestScriptFixture.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAutocreate) and isEmptyProp(FAutodelete) and isEmptyProp(FResource);
end;

procedure TFhirTestScriptFixture.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('autocreate');
  fields.add('autodelete');
  fields.add('resource');
end;

{ TFhirTestScriptFixture }

Procedure TFhirTestScriptFixture.SetAutocreate(value : TFhirBoolean);
begin
  FAutocreate.free;
  FAutocreate := value;
end;

Function TFhirTestScriptFixture.GetAutocreateST : Boolean;
begin
  if FAutocreate = nil then
    result := false
  else
    result := FAutocreate.value;
end;

Procedure TFhirTestScriptFixture.SetAutocreateST(value : Boolean);
begin
  if FAutocreate = nil then
    FAutocreate := TFhirBoolean.create;
  FAutocreate.value := value
end;

Procedure TFhirTestScriptFixture.SetAutodelete(value : TFhirBoolean);
begin
  FAutodelete.free;
  FAutodelete := value;
end;

Function TFhirTestScriptFixture.GetAutodeleteST : Boolean;
begin
  if FAutodelete = nil then
    result := false
  else
    result := FAutodelete.value;
end;

Procedure TFhirTestScriptFixture.SetAutodeleteST(value : Boolean);
begin
  if FAutodelete = nil then
    FAutodelete := TFhirBoolean.create;
  FAutodelete.value := value
end;

Procedure TFhirTestScriptFixture.SetResource(value : TFhirReference{TFhirReference});
begin
  FResource.free;
  FResource := value;
end;

function TFhirTestScriptFixture.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FAutocreate.sizeInBytes);
  inc(result, FAutodelete.sizeInBytes);
  inc(result, FResource.sizeInBytes);
end;

{ TFhirTestScriptFixtureListEnumerator }

Constructor TFhirTestScriptFixtureListEnumerator.Create(list : TFhirTestScriptFixtureList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptFixtureListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptFixtureListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptFixtureListEnumerator.GetCurrent : TFhirTestScriptFixture;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptFixtureListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestScriptFixtureList }
procedure TFhirTestScriptFixtureList.AddItem(value: TFhirTestScriptFixture);
begin
  assert(value.ClassName = 'TFhirTestScriptFixture', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptFixture');
  add(value);
end;

function TFhirTestScriptFixtureList.Append: TFhirTestScriptFixture;
begin
  result := TFhirTestScriptFixture.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptFixtureList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptFixtureList.GetEnumerator : TFhirTestScriptFixtureListEnumerator;
begin
  result := TFhirTestScriptFixtureListEnumerator.Create(self.link);
end;

function TFhirTestScriptFixtureList.Clone: TFhirTestScriptFixtureList;
begin
  result := TFhirTestScriptFixtureList(inherited Clone);
end;

function TFhirTestScriptFixtureList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptFixtureList.GetItemN(index: Integer): TFhirTestScriptFixture;
begin
  result := TFhirTestScriptFixture(ObjectByIndex[index]);
end;

function TFhirTestScriptFixtureList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptFixture;
end;
function TFhirTestScriptFixtureList.IndexOf(value: TFhirTestScriptFixture): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptFixtureList.Insert(index: Integer): TFhirTestScriptFixture;
begin
  result := TFhirTestScriptFixture.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptFixtureList.InsertItem(index: Integer; value: TFhirTestScriptFixture);
begin
  assert(value is TFhirTestScriptFixture);
  Inherited Insert(index, value);
end;

function TFhirTestScriptFixtureList.Item(index: Integer): TFhirTestScriptFixture;
begin
  result := TFhirTestScriptFixture(ObjectByIndex[index]);
end;

function TFhirTestScriptFixtureList.Link: TFhirTestScriptFixtureList;
begin
  result := TFhirTestScriptFixtureList(inherited Link);
end;

procedure TFhirTestScriptFixtureList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptFixtureList.SetItemByIndex(index: Integer; value: TFhirTestScriptFixture);
begin
  assert(value is TFhirTestScriptFixture);
  FhirTestScriptFixtures[index] := value;
end;

procedure TFhirTestScriptFixtureList.SetItemN(index: Integer; value: TFhirTestScriptFixture);
begin
  assert(value is TFhirTestScriptFixture);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptVariable }

constructor TFhirTestScriptVariable.Create;
begin
  inherited;
end;

destructor TFhirTestScriptVariable.Destroy;
begin
  FName.free;
  FHeaderField.free;
  FPath.free;
  FSourceId.free;
  inherited;
end;

procedure TFhirTestScriptVariable.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirTestScriptVariable(oSource).nameElement.Clone;
  headerFieldElement := TFhirTestScriptVariable(oSource).headerFieldElement.Clone;
  pathElement := TFhirTestScriptVariable(oSource).pathElement.Clone;
  sourceIdElement := TFhirTestScriptVariable(oSource).sourceIdElement.Clone;
end;

procedure TFhirTestScriptVariable.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'headerField') Then
     list.add(self.link, 'headerField', FHeaderField.Link);
  if (child_name = 'path') Then
     list.add(self.link, 'path', FPath.Link);
  if (child_name = 'sourceId') Then
     list.add(self.link, 'sourceId', FSourceId.Link);
end;

procedure TFhirTestScriptVariable.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'headerField', 'string', false, TFhirString, FHeaderField.Link));{2}
  oList.add(TFHIRProperty.create(self, 'path', 'string', false, TFhirString, FPath.Link));{2}
  oList.add(TFHIRProperty.create(self, 'sourceId', 'id', false, TFhirId, FSourceId.Link));{2}
end;

function TFhirTestScriptVariable.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'headerField') then
  begin
    HeaderFieldElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'path') then
  begin
    PathElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'sourceId') then
  begin
    SourceIdElement := asId(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptVariable.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestScriptVariable.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'headerField') then result := TFhirString.create() {5b}
  else if (propName = 'path') then result := TFhirString.create() {5b}
  else if (propName = 'sourceId') then result := TFhirId.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptVariable.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'headerField') then result := 'string'
  else if (propName = 'path') then result := 'string'
  else if (propName = 'sourceId') then result := 'id'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptVariable.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'headerField') then HeaderFieldElement := nil
  else if (propName = 'path') then PathElement := nil
  else if (propName = 'sourceId') then SourceIdElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptVariable.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'headerField') then HeaderFieldElement := asString(new){5b}
  else if (propName = 'path') then PathElement := asString(new){5b}
  else if (propName = 'sourceId') then SourceIdElement := asId(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptVariable.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptVariable.fhirType : string;
begin
  result := 'variable';
end;

function TFhirTestScriptVariable.Link : TFhirTestScriptVariable;
begin
  result := TFhirTestScriptVariable(inherited Link);
end;

function TFhirTestScriptVariable.Clone : TFhirTestScriptVariable;
begin
  result := TFhirTestScriptVariable(inherited Clone);
end;

function TFhirTestScriptVariable.equals(other : TObject) : boolean; 
var
  o : TFhirTestScriptVariable;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptVariable)) then
    result := false
  else
  begin
    o := TFhirTestScriptVariable(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(headerFieldElement, o.headerFieldElement, true) and 
      compareDeep(pathElement, o.pathElement, true) and compareDeep(sourceIdElement, o.sourceIdElement, true);
  end;
end;

function TFhirTestScriptVariable.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FHeaderField) and isEmptyProp(FPath) and isEmptyProp(FSourceId);
end;

procedure TFhirTestScriptVariable.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('headerField');
  fields.add('path');
  fields.add('sourceId');
end;

{ TFhirTestScriptVariable }

Procedure TFhirTestScriptVariable.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirTestScriptVariable.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirTestScriptVariable.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirTestScriptVariable.SetHeaderField(value : TFhirString);
begin
  FHeaderField.free;
  FHeaderField := value;
end;

Function TFhirTestScriptVariable.GetHeaderFieldST : String;
begin
  if FHeaderField = nil then
    result := ''
  else
    result := FHeaderField.value;
end;

Procedure TFhirTestScriptVariable.SetHeaderFieldST(value : String);
begin
  if value <> '' then
  begin
    if FHeaderField = nil then
      FHeaderField := TFhirString.create;
    FHeaderField.value := value
  end
  else if FHeaderField <> nil then
    FHeaderField.value := '';
end;

Procedure TFhirTestScriptVariable.SetPath(value : TFhirString);
begin
  FPath.free;
  FPath := value;
end;

Function TFhirTestScriptVariable.GetPathST : String;
begin
  if FPath = nil then
    result := ''
  else
    result := FPath.value;
end;

Procedure TFhirTestScriptVariable.SetPathST(value : String);
begin
  if value <> '' then
  begin
    if FPath = nil then
      FPath := TFhirString.create;
    FPath.value := value
  end
  else if FPath <> nil then
    FPath.value := '';
end;

Procedure TFhirTestScriptVariable.SetSourceId(value : TFhirId);
begin
  FSourceId.free;
  FSourceId := value;
end;

Function TFhirTestScriptVariable.GetSourceIdST : String;
begin
  if FSourceId = nil then
    result := ''
  else
    result := FSourceId.value;
end;

Procedure TFhirTestScriptVariable.SetSourceIdST(value : String);
begin
  if value <> '' then
  begin
    if FSourceId = nil then
      FSourceId := TFhirId.create;
    FSourceId.value := value
  end
  else if FSourceId <> nil then
    FSourceId.value := '';
end;

function TFhirTestScriptVariable.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FHeaderField.sizeInBytes);
  inc(result, FPath.sizeInBytes);
  inc(result, FSourceId.sizeInBytes);
end;

{ TFhirTestScriptVariableListEnumerator }

Constructor TFhirTestScriptVariableListEnumerator.Create(list : TFhirTestScriptVariableList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptVariableListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptVariableListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptVariableListEnumerator.GetCurrent : TFhirTestScriptVariable;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptVariableListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestScriptVariableList }
procedure TFhirTestScriptVariableList.AddItem(value: TFhirTestScriptVariable);
begin
  assert(value.ClassName = 'TFhirTestScriptVariable', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptVariable');
  add(value);
end;

function TFhirTestScriptVariableList.Append: TFhirTestScriptVariable;
begin
  result := TFhirTestScriptVariable.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptVariableList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptVariableList.GetEnumerator : TFhirTestScriptVariableListEnumerator;
begin
  result := TFhirTestScriptVariableListEnumerator.Create(self.link);
end;

function TFhirTestScriptVariableList.Clone: TFhirTestScriptVariableList;
begin
  result := TFhirTestScriptVariableList(inherited Clone);
end;

function TFhirTestScriptVariableList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptVariableList.GetItemN(index: Integer): TFhirTestScriptVariable;
begin
  result := TFhirTestScriptVariable(ObjectByIndex[index]);
end;

function TFhirTestScriptVariableList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptVariable;
end;
function TFhirTestScriptVariableList.IndexOf(value: TFhirTestScriptVariable): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptVariableList.Insert(index: Integer): TFhirTestScriptVariable;
begin
  result := TFhirTestScriptVariable.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptVariableList.InsertItem(index: Integer; value: TFhirTestScriptVariable);
begin
  assert(value is TFhirTestScriptVariable);
  Inherited Insert(index, value);
end;

function TFhirTestScriptVariableList.Item(index: Integer): TFhirTestScriptVariable;
begin
  result := TFhirTestScriptVariable(ObjectByIndex[index]);
end;

function TFhirTestScriptVariableList.Link: TFhirTestScriptVariableList;
begin
  result := TFhirTestScriptVariableList(inherited Link);
end;

procedure TFhirTestScriptVariableList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptVariableList.SetItemByIndex(index: Integer; value: TFhirTestScriptVariable);
begin
  assert(value is TFhirTestScriptVariable);
  FhirTestScriptVariables[index] := value;
end;

procedure TFhirTestScriptVariableList.SetItemN(index: Integer; value: TFhirTestScriptVariable);
begin
  assert(value is TFhirTestScriptVariable);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptSetup }

constructor TFhirTestScriptSetup.Create;
begin
  inherited;
end;

destructor TFhirTestScriptSetup.Destroy;
begin
  FMetadata.free;
  FActionList.Free;
  inherited;
end;

procedure TFhirTestScriptSetup.Assign(oSource : TFslObject);
begin
  inherited;
  metadata := TFhirTestScriptSetup(oSource).metadata.Clone;
  if (TFhirTestScriptSetup(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirTestScriptSetupActionList.Create;
    FActionList.Assign(TFhirTestScriptSetup(oSource).FActionList);
  end;
end;

procedure TFhirTestScriptSetup.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'metadata') Then
     list.add(self.link, 'metadata', FMetadata.Link);
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
end;

procedure TFhirTestScriptSetup.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'metadata', '@TestScript.metadata', false, TFhirTestScriptMetadata, FMetadata.Link));{2}
  oList.add(TFHIRProperty.create(self, 'action', '', true, TFhirTestScriptSetupAction, FActionList.Link)){3};
end;

function TFhirTestScriptSetup.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'metadata') then
  begin
    Metadata := propValue as TFhirTestScriptMetadata{4b};
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirTestScriptSetupAction){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptSetup.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirTestScriptSetupAction){2a}
  else inherited;
end;

function TFhirTestScriptSetup.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'metadata') then result := TFhirTestScriptMetadata.create(){4b}
  else if (propName = 'action') then result := ActionList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptSetup.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'metadata') then result := '@TestScript.metadata'
  else if (propName = 'action') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptSetup.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'metadata') then MetadataElement := nil
  else if (propName = 'action') then deletePropertyValue('action', ActionList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptSetup.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'metadata') then MetadataElement := new as TFhirTestScriptMetadata{4}
  else if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptSetup.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'action') then ActionList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptSetup.fhirType : string;
begin
  result := 'setup';
end;

function TFhirTestScriptSetup.Link : TFhirTestScriptSetup;
begin
  result := TFhirTestScriptSetup(inherited Link);
end;

function TFhirTestScriptSetup.Clone : TFhirTestScriptSetup;
begin
  result := TFhirTestScriptSetup(inherited Clone);
end;

function TFhirTestScriptSetup.equals(other : TObject) : boolean; 
var
  o : TFhirTestScriptSetup;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptSetup)) then
    result := false
  else
  begin
    o := TFhirTestScriptSetup(other);
    result := compareDeep(metadataElement, o.metadataElement, true) and compareDeep(actionList, o.actionList, true);
  end;
end;

function TFhirTestScriptSetup.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMetadata) and isEmptyProp(FactionList);
end;

procedure TFhirTestScriptSetup.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('metadata');
  fields.add('action');
end;

{ TFhirTestScriptSetup }

Procedure TFhirTestScriptSetup.SetMetadata(value : TFhirTestScriptMetadata);
begin
  FMetadata.free;
  FMetadata := value;
end;

Function TFhirTestScriptSetup.GetActionList : TFhirTestScriptSetupActionList;
begin
  if FActionList = nil then
    FActionList := TFhirTestScriptSetupActionList.Create;
  result := FActionList;
end;

Function TFhirTestScriptSetup.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

function TFhirTestScriptSetup.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FMetadata.sizeInBytes);
  inc(result, FactionList.sizeInBytes);
end;

{ TFhirTestScriptSetupListEnumerator }

Constructor TFhirTestScriptSetupListEnumerator.Create(list : TFhirTestScriptSetupList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptSetupListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptSetupListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptSetupListEnumerator.GetCurrent : TFhirTestScriptSetup;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptSetupListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestScriptSetupList }
procedure TFhirTestScriptSetupList.AddItem(value: TFhirTestScriptSetup);
begin
  assert(value.ClassName = 'TFhirTestScriptSetup', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptSetup');
  add(value);
end;

function TFhirTestScriptSetupList.Append: TFhirTestScriptSetup;
begin
  result := TFhirTestScriptSetup.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptSetupList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptSetupList.GetEnumerator : TFhirTestScriptSetupListEnumerator;
begin
  result := TFhirTestScriptSetupListEnumerator.Create(self.link);
end;

function TFhirTestScriptSetupList.Clone: TFhirTestScriptSetupList;
begin
  result := TFhirTestScriptSetupList(inherited Clone);
end;

function TFhirTestScriptSetupList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptSetupList.GetItemN(index: Integer): TFhirTestScriptSetup;
begin
  result := TFhirTestScriptSetup(ObjectByIndex[index]);
end;

function TFhirTestScriptSetupList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptSetup;
end;
function TFhirTestScriptSetupList.IndexOf(value: TFhirTestScriptSetup): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptSetupList.Insert(index: Integer): TFhirTestScriptSetup;
begin
  result := TFhirTestScriptSetup.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptSetupList.InsertItem(index: Integer; value: TFhirTestScriptSetup);
begin
  assert(value is TFhirTestScriptSetup);
  Inherited Insert(index, value);
end;

function TFhirTestScriptSetupList.Item(index: Integer): TFhirTestScriptSetup;
begin
  result := TFhirTestScriptSetup(ObjectByIndex[index]);
end;

function TFhirTestScriptSetupList.Link: TFhirTestScriptSetupList;
begin
  result := TFhirTestScriptSetupList(inherited Link);
end;

procedure TFhirTestScriptSetupList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptSetupList.SetItemByIndex(index: Integer; value: TFhirTestScriptSetup);
begin
  assert(value is TFhirTestScriptSetup);
  FhirTestScriptSetups[index] := value;
end;

procedure TFhirTestScriptSetupList.SetItemN(index: Integer; value: TFhirTestScriptSetup);
begin
  assert(value is TFhirTestScriptSetup);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptSetupAction }

constructor TFhirTestScriptSetupAction.Create;
begin
  inherited;
end;

destructor TFhirTestScriptSetupAction.Destroy;
begin
  FOperation.free;
  FAssert.free;
  inherited;
end;

procedure TFhirTestScriptSetupAction.Assign(oSource : TFslObject);
begin
  inherited;
  operation := TFhirTestScriptSetupAction(oSource).operation.Clone;
  assert := TFhirTestScriptSetupAction(oSource).assert.Clone;
end;

procedure TFhirTestScriptSetupAction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'operation') Then
     list.add(self.link, 'operation', FOperation.Link);
  if (child_name = 'assert') Then
     list.add(self.link, 'assert', FAssert.Link);
end;

procedure TFhirTestScriptSetupAction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'operation', '', false, TFhirTestScriptSetupActionOperation, FOperation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'assert', '', false, TFhirTestScriptSetupActionAssert, FAssert.Link));{2}
end;

function TFhirTestScriptSetupAction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'operation') then
  begin
    Operation := propValue as TFhirTestScriptSetupActionOperation{4b};
    result := propValue;
  end
  else if (propName = 'assert') then
  begin
    Assert := propValue as TFhirTestScriptSetupActionAssert{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptSetupAction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestScriptSetupAction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'operation') then result := TFhirTestScriptSetupActionOperation.create(){4b}
  else if (propName = 'assert') then result := TFhirTestScriptSetupActionAssert.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptSetupAction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'operation') then result := ''
  else if (propName = 'assert') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptSetupAction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'operation') then OperationElement := nil
  else if (propName = 'assert') then AssertElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptSetupAction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'operation') then OperationElement := new as TFhirTestScriptSetupActionOperation{4}
  else if (propName = 'assert') then AssertElement := new as TFhirTestScriptSetupActionAssert{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptSetupAction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptSetupAction.fhirType : string;
begin
  result := 'action';
end;

function TFhirTestScriptSetupAction.Link : TFhirTestScriptSetupAction;
begin
  result := TFhirTestScriptSetupAction(inherited Link);
end;

function TFhirTestScriptSetupAction.Clone : TFhirTestScriptSetupAction;
begin
  result := TFhirTestScriptSetupAction(inherited Clone);
end;

function TFhirTestScriptSetupAction.equals(other : TObject) : boolean; 
var
  o : TFhirTestScriptSetupAction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptSetupAction)) then
    result := false
  else
  begin
    o := TFhirTestScriptSetupAction(other);
    result := compareDeep(operationElement, o.operationElement, true) and compareDeep(assertElement, o.assertElement, true);
  end;
end;

function TFhirTestScriptSetupAction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FOperation) and isEmptyProp(FAssert);
end;

procedure TFhirTestScriptSetupAction.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('operation');
  fields.add('assert');
end;

{ TFhirTestScriptSetupAction }

Procedure TFhirTestScriptSetupAction.SetOperation(value : TFhirTestScriptSetupActionOperation);
begin
  FOperation.free;
  FOperation := value;
end;

Procedure TFhirTestScriptSetupAction.SetAssert(value : TFhirTestScriptSetupActionAssert);
begin
  FAssert.free;
  FAssert := value;
end;

function TFhirTestScriptSetupAction.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FOperation.sizeInBytes);
  inc(result, FAssert.sizeInBytes);
end;

{ TFhirTestScriptSetupActionListEnumerator }

Constructor TFhirTestScriptSetupActionListEnumerator.Create(list : TFhirTestScriptSetupActionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptSetupActionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptSetupActionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptSetupActionListEnumerator.GetCurrent : TFhirTestScriptSetupAction;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptSetupActionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestScriptSetupActionList }
procedure TFhirTestScriptSetupActionList.AddItem(value: TFhirTestScriptSetupAction);
begin
  assert(value.ClassName = 'TFhirTestScriptSetupAction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptSetupAction');
  add(value);
end;

function TFhirTestScriptSetupActionList.Append: TFhirTestScriptSetupAction;
begin
  result := TFhirTestScriptSetupAction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptSetupActionList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptSetupActionList.GetEnumerator : TFhirTestScriptSetupActionListEnumerator;
begin
  result := TFhirTestScriptSetupActionListEnumerator.Create(self.link);
end;

function TFhirTestScriptSetupActionList.Clone: TFhirTestScriptSetupActionList;
begin
  result := TFhirTestScriptSetupActionList(inherited Clone);
end;

function TFhirTestScriptSetupActionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptSetupActionList.GetItemN(index: Integer): TFhirTestScriptSetupAction;
begin
  result := TFhirTestScriptSetupAction(ObjectByIndex[index]);
end;

function TFhirTestScriptSetupActionList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptSetupAction;
end;
function TFhirTestScriptSetupActionList.IndexOf(value: TFhirTestScriptSetupAction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptSetupActionList.Insert(index: Integer): TFhirTestScriptSetupAction;
begin
  result := TFhirTestScriptSetupAction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptSetupActionList.InsertItem(index: Integer; value: TFhirTestScriptSetupAction);
begin
  assert(value is TFhirTestScriptSetupAction);
  Inherited Insert(index, value);
end;

function TFhirTestScriptSetupActionList.Item(index: Integer): TFhirTestScriptSetupAction;
begin
  result := TFhirTestScriptSetupAction(ObjectByIndex[index]);
end;

function TFhirTestScriptSetupActionList.Link: TFhirTestScriptSetupActionList;
begin
  result := TFhirTestScriptSetupActionList(inherited Link);
end;

procedure TFhirTestScriptSetupActionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptSetupActionList.SetItemByIndex(index: Integer; value: TFhirTestScriptSetupAction);
begin
  assert(value is TFhirTestScriptSetupAction);
  FhirTestScriptSetupActions[index] := value;
end;

procedure TFhirTestScriptSetupActionList.SetItemN(index: Integer; value: TFhirTestScriptSetupAction);
begin
  assert(value is TFhirTestScriptSetupAction);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptSetupActionOperation }

constructor TFhirTestScriptSetupActionOperation.Create;
begin
  inherited;
end;

destructor TFhirTestScriptSetupActionOperation.Destroy;
begin
  FType_.free;
  FResource.free;
  FLabel_.free;
  FDescription.free;
  FAccept.free;
  FContentType.free;
  FDestination.free;
  FEncodeRequestUrl.free;
  FParams.free;
  FRequestHeaderList.Free;
  FResponseId.free;
  FSourceId.free;
  FTargetId.free;
  FUrl.free;
  inherited;
end;

procedure TFhirTestScriptSetupActionOperation.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirTestScriptSetupActionOperation(oSource).type_.Clone;
  resourceElement := TFhirTestScriptSetupActionOperation(oSource).resourceElement.Clone;
  label_Element := TFhirTestScriptSetupActionOperation(oSource).label_Element.Clone;
  descriptionElement := TFhirTestScriptSetupActionOperation(oSource).descriptionElement.Clone;
  FAccept := TFhirTestScriptSetupActionOperation(oSource).FAccept.Link;
  FContentType := TFhirTestScriptSetupActionOperation(oSource).FContentType.Link;
  destinationElement := TFhirTestScriptSetupActionOperation(oSource).destinationElement.Clone;
  encodeRequestUrlElement := TFhirTestScriptSetupActionOperation(oSource).encodeRequestUrlElement.Clone;
  paramsElement := TFhirTestScriptSetupActionOperation(oSource).paramsElement.Clone;
  if (TFhirTestScriptSetupActionOperation(oSource).FRequestHeaderList = nil) then
  begin
    FRequestHeaderList.free;
    FRequestHeaderList := nil;
  end
  else
  begin
    if FRequestHeaderList = nil then
      FRequestHeaderList := TFhirTestScriptSetupActionOperationRequestHeaderList.Create;
    FRequestHeaderList.Assign(TFhirTestScriptSetupActionOperation(oSource).FRequestHeaderList);
  end;
  responseIdElement := TFhirTestScriptSetupActionOperation(oSource).responseIdElement.Clone;
  sourceIdElement := TFhirTestScriptSetupActionOperation(oSource).sourceIdElement.Clone;
  targetIdElement := TFhirTestScriptSetupActionOperation(oSource).targetIdElement.Clone;
  urlElement := TFhirTestScriptSetupActionOperation(oSource).urlElement.Clone;
end;

procedure TFhirTestScriptSetupActionOperation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'resource') Then
     list.add(self.link, 'resource', FResource.Link);
  if (child_name = 'label') Then
     list.add(self.link, 'label', FLabel_.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'accept') Then
     list.add(self.link, 'accept', FAccept.Link);
  if (child_name = 'contentType') Then
     list.add(self.link, 'contentType', FContentType.Link);
  if (child_name = 'destination') Then
     list.add(self.link, 'destination', FDestination.Link);
  if (child_name = 'encodeRequestUrl') Then
     list.add(self.link, 'encodeRequestUrl', FEncodeRequestUrl.Link);
  if (child_name = 'params') Then
     list.add(self.link, 'params', FParams.Link);
  if (child_name = 'requestHeader') Then
    list.addAll(self, 'requestHeader', FRequestHeaderList);
  if (child_name = 'responseId') Then
     list.add(self.link, 'responseId', FResponseId.Link);
  if (child_name = 'sourceId') Then
     list.add(self.link, 'sourceId', FSourceId.Link);
  if (child_name = 'targetId') Then
     list.add(self.link, 'targetId', FTargetId.Link);
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
end;

procedure TFhirTestScriptSetupActionOperation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', false, TFhirCoding, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'resource', 'code', false, TFhirCode, FResource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'label', 'string', false, TFhirString, FLabel_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'accept', 'code', false, TFHIREnum, FAccept.Link));{1}
  oList.add(TFHIRProperty.create(self, 'contentType', 'code', false, TFHIREnum, FContentType.Link));{1}
  oList.add(TFHIRProperty.create(self, 'destination', 'integer', false, TFhirInteger, FDestination.Link));{2}
  oList.add(TFHIRProperty.create(self, 'encodeRequestUrl', 'boolean', false, TFhirBoolean, FEncodeRequestUrl.Link));{2}
  oList.add(TFHIRProperty.create(self, 'params', 'string', false, TFhirString, FParams.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requestHeader', '', true, TFhirTestScriptSetupActionOperationRequestHeader, FRequestHeaderList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'responseId', 'id', false, TFhirId, FResponseId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'sourceId', 'id', false, TFhirId, FSourceId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'targetId', 'id', false, TFhirId, FTargetId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'url', 'string', false, TFhirString, FUrl.Link));{2}
end;

function TFhirTestScriptSetupActionOperation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'resource') then
  begin
    ResourceElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'label') then
  begin
    Label_Element := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'accept') then
  begin
    AcceptElement := asEnum(SYSTEMS_TFhirContentTypeEnum, CODES_TFhirContentTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'contentType') then
  begin
    ContentTypeElement := asEnum(SYSTEMS_TFhirContentTypeEnum, CODES_TFhirContentTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'destination') then
  begin
    DestinationElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'encodeRequestUrl') then
  begin
    EncodeRequestUrlElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'params') then
  begin
    ParamsElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'requestHeader') then
  begin
    RequestHeaderList.add(propValue as TFhirTestScriptSetupActionOperationRequestHeader){2a};
    result := propValue;
  end
  else if (propName = 'responseId') then
  begin
    ResponseIdElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'sourceId') then
  begin
    SourceIdElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'targetId') then
  begin
    TargetIdElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'url') then
  begin
    UrlElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptSetupActionOperation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'requestHeader') then RequestHeaderList.insertItem(index, propValue as TFhirTestScriptSetupActionOperationRequestHeader){2a}
  else inherited;
end;

function TFhirTestScriptSetupActionOperation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCoding.create(){4b}
  else if (propName = 'resource') then result := TFhirCode.create() {5b}
  else if (propName = 'label') then result := TFhirString.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'destination') then result := TFhirInteger.create() {5b}
  else if (propName = 'encodeRequestUrl') then result := TFhirBoolean.create() {5b}
  else if (propName = 'params') then result := TFhirString.create() {5b}
  else if (propName = 'requestHeader') then result := RequestHeaderList.new(){2}
  else if (propName = 'responseId') then result := TFhirId.create() {5b}
  else if (propName = 'sourceId') then result := TFhirId.create() {5b}
  else if (propName = 'targetId') then result := TFhirId.create() {5b}
  else if (propName = 'url') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptSetupActionOperation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'Coding'
  else if (propName = 'resource') then result := 'code'
  else if (propName = 'label') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'accept') then result := 'code'
  else if (propName = 'contentType') then result := 'code'
  else if (propName = 'destination') then result := 'integer'
  else if (propName = 'encodeRequestUrl') then result := 'boolean'
  else if (propName = 'params') then result := 'string'
  else if (propName = 'requestHeader') then result := ''
  else if (propName = 'responseId') then result := 'id'
  else if (propName = 'sourceId') then result := 'id'
  else if (propName = 'targetId') then result := 'id'
  else if (propName = 'url') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptSetupActionOperation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'resource') then ResourceElement := nil
  else if (propName = 'label') then Label_Element := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'accept') then AcceptElement := nil
  else if (propName = 'contentType') then ContentTypeElement := nil
  else if (propName = 'destination') then DestinationElement := nil
  else if (propName = 'encodeRequestUrl') then EncodeRequestUrlElement := nil
  else if (propName = 'params') then ParamsElement := nil
  else if (propName = 'requestHeader') then deletePropertyValue('requestHeader', RequestHeaderList, value) {2}
  else if (propName = 'responseId') then ResponseIdElement := nil
  else if (propName = 'sourceId') then SourceIdElement := nil
  else if (propName = 'targetId') then TargetIdElement := nil
  else if (propName = 'url') then UrlElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptSetupActionOperation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCoding{4}
  else if (propName = 'resource') then ResourceElement := asCode(new){5b}
  else if (propName = 'label') then Label_Element := asString(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'accept') then AcceptElement := asEnum(SYSTEMS_TFhirContentTypeEnum, CODES_TFhirContentTypeEnum, new){4}
  else if (propName = 'contentType') then ContentTypeElement := asEnum(SYSTEMS_TFhirContentTypeEnum, CODES_TFhirContentTypeEnum, new){4}
  else if (propName = 'destination') then DestinationElement := asInteger(new){5b}
  else if (propName = 'encodeRequestUrl') then EncodeRequestUrlElement := asBoolean(new){5b}
  else if (propName = 'params') then ParamsElement := asString(new){5b}
  else if (propName = 'requestHeader') then replacePropertyValue('requestHeader', RequestHeaderList, existing, new) {2}
  else if (propName = 'responseId') then ResponseIdElement := asId(new){5b}
  else if (propName = 'sourceId') then SourceIdElement := asId(new){5b}
  else if (propName = 'targetId') then TargetIdElement := asId(new){5b}
  else if (propName = 'url') then UrlElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptSetupActionOperation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'requestHeader') then RequestHeaderList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptSetupActionOperation.fhirType : string;
begin
  result := 'operation';
end;

function TFhirTestScriptSetupActionOperation.Link : TFhirTestScriptSetupActionOperation;
begin
  result := TFhirTestScriptSetupActionOperation(inherited Link);
end;

function TFhirTestScriptSetupActionOperation.Clone : TFhirTestScriptSetupActionOperation;
begin
  result := TFhirTestScriptSetupActionOperation(inherited Clone);
end;

function TFhirTestScriptSetupActionOperation.equals(other : TObject) : boolean; 
var
  o : TFhirTestScriptSetupActionOperation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptSetupActionOperation)) then
    result := false
  else
  begin
    o := TFhirTestScriptSetupActionOperation(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(resourceElement, o.resourceElement, true) and 
      compareDeep(label_Element, o.label_Element, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(acceptElement, o.acceptElement, true) and compareDeep(contentTypeElement, o.contentTypeElement, true) and 
      compareDeep(destinationElement, o.destinationElement, true) and compareDeep(encodeRequestUrlElement, o.encodeRequestUrlElement, true) and 
      compareDeep(paramsElement, o.paramsElement, true) and compareDeep(requestHeaderList, o.requestHeaderList, true) and 
      compareDeep(responseIdElement, o.responseIdElement, true) and compareDeep(sourceIdElement, o.sourceIdElement, true) and 
      compareDeep(targetIdElement, o.targetIdElement, true) and compareDeep(urlElement, o.urlElement, true);
  end;
end;

function TFhirTestScriptSetupActionOperation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FResource) and isEmptyProp(FLabel_) and isEmptyProp(FDescription) and isEmptyProp(FAccept) and isEmptyProp(FContentType) and isEmptyProp(FDestination) and isEmptyProp(FEncodeRequestUrl) and isEmptyProp(FParams) and isEmptyProp(FrequestHeaderList) and isEmptyProp(FResponseId) and isEmptyProp(FSourceId) and isEmptyProp(FTargetId) and isEmptyProp(FUrl);
end;

procedure TFhirTestScriptSetupActionOperation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('resource');
  fields.add('label');
  fields.add('description');
  fields.add('accept');
  fields.add('contentType');
  fields.add('destination');
  fields.add('encodeRequestUrl');
  fields.add('params');
  fields.add('requestHeader');
  fields.add('responseId');
  fields.add('sourceId');
  fields.add('targetId');
  fields.add('url');
end;

{ TFhirTestScriptSetupActionOperation }

Procedure TFhirTestScriptSetupActionOperation.SetType_(value : TFhirCoding);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirTestScriptSetupActionOperation.SetResource(value : TFhirCode);
begin
  FResource.free;
  FResource := value;
end;

Function TFhirTestScriptSetupActionOperation.GetResourceST : String;
begin
  if FResource = nil then
    result := ''
  else
    result := FResource.value;
end;

Procedure TFhirTestScriptSetupActionOperation.SetResourceST(value : String);
begin
  if value <> '' then
  begin
    if FResource = nil then
      FResource := TFhirCode.create;
    FResource.value := value
  end
  else if FResource <> nil then
    FResource.value := '';
end;

Procedure TFhirTestScriptSetupActionOperation.SetLabel_(value : TFhirString);
begin
  FLabel_.free;
  FLabel_ := value;
end;

Function TFhirTestScriptSetupActionOperation.GetLabel_ST : String;
begin
  if FLabel_ = nil then
    result := ''
  else
    result := FLabel_.value;
end;

Procedure TFhirTestScriptSetupActionOperation.SetLabel_ST(value : String);
begin
  if value <> '' then
  begin
    if FLabel_ = nil then
      FLabel_ := TFhirString.create;
    FLabel_.value := value
  end
  else if FLabel_ <> nil then
    FLabel_.value := '';
end;

Procedure TFhirTestScriptSetupActionOperation.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirTestScriptSetupActionOperation.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirTestScriptSetupActionOperation.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirTestScriptSetupActionOperation.SetAccept(value : TFhirEnum);
begin
  FAccept.free;
  FAccept := value;
end;

Function TFhirTestScriptSetupActionOperation.GetAcceptST : TFhirContentTypeEnum;
begin
  if FAccept = nil then
    result := TFhirContentTypeEnum(0)
  else
    result := TFhirContentTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirContentTypeEnum, FAccept.value));
end;

Procedure TFhirTestScriptSetupActionOperation.SetAcceptST(value : TFhirContentTypeEnum);
begin
  if ord(value) = 0 then
    AcceptElement := nil
  else
    AcceptElement := TFhirEnum.create(SYSTEMS_TFhirContentTypeEnum[value], CODES_TFhirContentTypeEnum[value]);
end;

Procedure TFhirTestScriptSetupActionOperation.SetContentType(value : TFhirEnum);
begin
  FContentType.free;
  FContentType := value;
end;

Function TFhirTestScriptSetupActionOperation.GetContentTypeST : TFhirContentTypeEnum;
begin
  if FContentType = nil then
    result := TFhirContentTypeEnum(0)
  else
    result := TFhirContentTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirContentTypeEnum, FContentType.value));
end;

Procedure TFhirTestScriptSetupActionOperation.SetContentTypeST(value : TFhirContentTypeEnum);
begin
  if ord(value) = 0 then
    ContentTypeElement := nil
  else
    ContentTypeElement := TFhirEnum.create(SYSTEMS_TFhirContentTypeEnum[value], CODES_TFhirContentTypeEnum[value]);
end;

Procedure TFhirTestScriptSetupActionOperation.SetDestination(value : TFhirInteger);
begin
  FDestination.free;
  FDestination := value;
end;

Function TFhirTestScriptSetupActionOperation.GetDestinationST : String;
begin
  if FDestination = nil then
    result := ''
  else
    result := FDestination.value;
end;

Procedure TFhirTestScriptSetupActionOperation.SetDestinationST(value : String);
begin
  if value <> '' then
  begin
    if FDestination = nil then
      FDestination := TFhirInteger.create;
    FDestination.value := value
  end
  else if FDestination <> nil then
    FDestination.value := '';
end;

Procedure TFhirTestScriptSetupActionOperation.SetEncodeRequestUrl(value : TFhirBoolean);
begin
  FEncodeRequestUrl.free;
  FEncodeRequestUrl := value;
end;

Function TFhirTestScriptSetupActionOperation.GetEncodeRequestUrlST : Boolean;
begin
  if FEncodeRequestUrl = nil then
    result := false
  else
    result := FEncodeRequestUrl.value;
end;

Procedure TFhirTestScriptSetupActionOperation.SetEncodeRequestUrlST(value : Boolean);
begin
  if FEncodeRequestUrl = nil then
    FEncodeRequestUrl := TFhirBoolean.create;
  FEncodeRequestUrl.value := value
end;

Procedure TFhirTestScriptSetupActionOperation.SetParams(value : TFhirString);
begin
  FParams.free;
  FParams := value;
end;

Function TFhirTestScriptSetupActionOperation.GetParamsST : String;
begin
  if FParams = nil then
    result := ''
  else
    result := FParams.value;
end;

Procedure TFhirTestScriptSetupActionOperation.SetParamsST(value : String);
begin
  if value <> '' then
  begin
    if FParams = nil then
      FParams := TFhirString.create;
    FParams.value := value
  end
  else if FParams <> nil then
    FParams.value := '';
end;

Function TFhirTestScriptSetupActionOperation.GetRequestHeaderList : TFhirTestScriptSetupActionOperationRequestHeaderList;
begin
  if FRequestHeaderList = nil then
    FRequestHeaderList := TFhirTestScriptSetupActionOperationRequestHeaderList.Create;
  result := FRequestHeaderList;
end;

Function TFhirTestScriptSetupActionOperation.GetHasRequestHeaderList : boolean;
begin
  result := (FRequestHeaderList <> nil) and (FRequestHeaderList.count > 0);
end;

Procedure TFhirTestScriptSetupActionOperation.SetResponseId(value : TFhirId);
begin
  FResponseId.free;
  FResponseId := value;
end;

Function TFhirTestScriptSetupActionOperation.GetResponseIdST : String;
begin
  if FResponseId = nil then
    result := ''
  else
    result := FResponseId.value;
end;

Procedure TFhirTestScriptSetupActionOperation.SetResponseIdST(value : String);
begin
  if value <> '' then
  begin
    if FResponseId = nil then
      FResponseId := TFhirId.create;
    FResponseId.value := value
  end
  else if FResponseId <> nil then
    FResponseId.value := '';
end;

Procedure TFhirTestScriptSetupActionOperation.SetSourceId(value : TFhirId);
begin
  FSourceId.free;
  FSourceId := value;
end;

Function TFhirTestScriptSetupActionOperation.GetSourceIdST : String;
begin
  if FSourceId = nil then
    result := ''
  else
    result := FSourceId.value;
end;

Procedure TFhirTestScriptSetupActionOperation.SetSourceIdST(value : String);
begin
  if value <> '' then
  begin
    if FSourceId = nil then
      FSourceId := TFhirId.create;
    FSourceId.value := value
  end
  else if FSourceId <> nil then
    FSourceId.value := '';
end;

Procedure TFhirTestScriptSetupActionOperation.SetTargetId(value : TFhirId);
begin
  FTargetId.free;
  FTargetId := value;
end;

Function TFhirTestScriptSetupActionOperation.GetTargetIdST : String;
begin
  if FTargetId = nil then
    result := ''
  else
    result := FTargetId.value;
end;

Procedure TFhirTestScriptSetupActionOperation.SetTargetIdST(value : String);
begin
  if value <> '' then
  begin
    if FTargetId = nil then
      FTargetId := TFhirId.create;
    FTargetId.value := value
  end
  else if FTargetId <> nil then
    FTargetId.value := '';
end;

Procedure TFhirTestScriptSetupActionOperation.SetUrl(value : TFhirString);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirTestScriptSetupActionOperation.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

Procedure TFhirTestScriptSetupActionOperation.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirString.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

function TFhirTestScriptSetupActionOperation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FResource.sizeInBytes);
  inc(result, FLabel_.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FAccept.sizeInBytes);
  inc(result, FContentType.sizeInBytes);
  inc(result, FDestination.sizeInBytes);
  inc(result, FEncodeRequestUrl.sizeInBytes);
  inc(result, FParams.sizeInBytes);
  inc(result, FrequestHeaderList.sizeInBytes);
  inc(result, FResponseId.sizeInBytes);
  inc(result, FSourceId.sizeInBytes);
  inc(result, FTargetId.sizeInBytes);
  inc(result, FUrl.sizeInBytes);
end;

{ TFhirTestScriptSetupActionOperationListEnumerator }

Constructor TFhirTestScriptSetupActionOperationListEnumerator.Create(list : TFhirTestScriptSetupActionOperationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptSetupActionOperationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptSetupActionOperationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptSetupActionOperationListEnumerator.GetCurrent : TFhirTestScriptSetupActionOperation;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptSetupActionOperationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestScriptSetupActionOperationList }
procedure TFhirTestScriptSetupActionOperationList.AddItem(value: TFhirTestScriptSetupActionOperation);
begin
  assert(value.ClassName = 'TFhirTestScriptSetupActionOperation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptSetupActionOperation');
  add(value);
end;

function TFhirTestScriptSetupActionOperationList.Append: TFhirTestScriptSetupActionOperation;
begin
  result := TFhirTestScriptSetupActionOperation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptSetupActionOperationList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptSetupActionOperationList.GetEnumerator : TFhirTestScriptSetupActionOperationListEnumerator;
begin
  result := TFhirTestScriptSetupActionOperationListEnumerator.Create(self.link);
end;

function TFhirTestScriptSetupActionOperationList.Clone: TFhirTestScriptSetupActionOperationList;
begin
  result := TFhirTestScriptSetupActionOperationList(inherited Clone);
end;

function TFhirTestScriptSetupActionOperationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptSetupActionOperationList.GetItemN(index: Integer): TFhirTestScriptSetupActionOperation;
begin
  result := TFhirTestScriptSetupActionOperation(ObjectByIndex[index]);
end;

function TFhirTestScriptSetupActionOperationList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptSetupActionOperation;
end;
function TFhirTestScriptSetupActionOperationList.IndexOf(value: TFhirTestScriptSetupActionOperation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptSetupActionOperationList.Insert(index: Integer): TFhirTestScriptSetupActionOperation;
begin
  result := TFhirTestScriptSetupActionOperation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptSetupActionOperationList.InsertItem(index: Integer; value: TFhirTestScriptSetupActionOperation);
begin
  assert(value is TFhirTestScriptSetupActionOperation);
  Inherited Insert(index, value);
end;

function TFhirTestScriptSetupActionOperationList.Item(index: Integer): TFhirTestScriptSetupActionOperation;
begin
  result := TFhirTestScriptSetupActionOperation(ObjectByIndex[index]);
end;

function TFhirTestScriptSetupActionOperationList.Link: TFhirTestScriptSetupActionOperationList;
begin
  result := TFhirTestScriptSetupActionOperationList(inherited Link);
end;

procedure TFhirTestScriptSetupActionOperationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptSetupActionOperationList.SetItemByIndex(index: Integer; value: TFhirTestScriptSetupActionOperation);
begin
  assert(value is TFhirTestScriptSetupActionOperation);
  FhirTestScriptSetupActionOperations[index] := value;
end;

procedure TFhirTestScriptSetupActionOperationList.SetItemN(index: Integer; value: TFhirTestScriptSetupActionOperation);
begin
  assert(value is TFhirTestScriptSetupActionOperation);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptSetupActionOperationRequestHeader }

constructor TFhirTestScriptSetupActionOperationRequestHeader.Create;
begin
  inherited;
end;

destructor TFhirTestScriptSetupActionOperationRequestHeader.Destroy;
begin
  FField.free;
  FValue.free;
  inherited;
end;

procedure TFhirTestScriptSetupActionOperationRequestHeader.Assign(oSource : TFslObject);
begin
  inherited;
  fieldElement := TFhirTestScriptSetupActionOperationRequestHeader(oSource).fieldElement.Clone;
  valueElement := TFhirTestScriptSetupActionOperationRequestHeader(oSource).valueElement.Clone;
end;

procedure TFhirTestScriptSetupActionOperationRequestHeader.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'field') Then
     list.add(self.link, 'field', FField.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirTestScriptSetupActionOperationRequestHeader.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'field', 'string', false, TFhirString, FField.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value', 'string', false, TFhirString, FValue.Link));{2}
end;

function TFhirTestScriptSetupActionOperationRequestHeader.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'field') then
  begin
    FieldElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptSetupActionOperationRequestHeader.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestScriptSetupActionOperationRequestHeader.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'field') then result := TFhirString.create() {5b}
  else if (propName = 'value') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptSetupActionOperationRequestHeader.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'field') then result := 'string'
  else if (propName = 'value') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptSetupActionOperationRequestHeader.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'field') then FieldElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptSetupActionOperationRequestHeader.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'field') then FieldElement := asString(new){5b}
  else if (propName = 'value') then ValueElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptSetupActionOperationRequestHeader.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptSetupActionOperationRequestHeader.fhirType : string;
begin
  result := 'requestHeader';
end;

function TFhirTestScriptSetupActionOperationRequestHeader.Link : TFhirTestScriptSetupActionOperationRequestHeader;
begin
  result := TFhirTestScriptSetupActionOperationRequestHeader(inherited Link);
end;

function TFhirTestScriptSetupActionOperationRequestHeader.Clone : TFhirTestScriptSetupActionOperationRequestHeader;
begin
  result := TFhirTestScriptSetupActionOperationRequestHeader(inherited Clone);
end;

function TFhirTestScriptSetupActionOperationRequestHeader.equals(other : TObject) : boolean; 
var
  o : TFhirTestScriptSetupActionOperationRequestHeader;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptSetupActionOperationRequestHeader)) then
    result := false
  else
  begin
    o := TFhirTestScriptSetupActionOperationRequestHeader(other);
    result := compareDeep(fieldElement, o.fieldElement, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirTestScriptSetupActionOperationRequestHeader.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FField) and isEmptyProp(FValue);
end;

procedure TFhirTestScriptSetupActionOperationRequestHeader.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('field');
  fields.add('value');
end;

{ TFhirTestScriptSetupActionOperationRequestHeader }

Procedure TFhirTestScriptSetupActionOperationRequestHeader.SetField(value : TFhirString);
begin
  FField.free;
  FField := value;
end;

Function TFhirTestScriptSetupActionOperationRequestHeader.GetFieldST : String;
begin
  if FField = nil then
    result := ''
  else
    result := FField.value;
end;

Procedure TFhirTestScriptSetupActionOperationRequestHeader.SetFieldST(value : String);
begin
  if value <> '' then
  begin
    if FField = nil then
      FField := TFhirString.create;
    FField.value := value
  end
  else if FField <> nil then
    FField.value := '';
end;

Procedure TFhirTestScriptSetupActionOperationRequestHeader.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirTestScriptSetupActionOperationRequestHeader.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

Procedure TFhirTestScriptSetupActionOperationRequestHeader.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

function TFhirTestScriptSetupActionOperationRequestHeader.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FField.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirTestScriptSetupActionOperationRequestHeaderListEnumerator }

Constructor TFhirTestScriptSetupActionOperationRequestHeaderListEnumerator.Create(list : TFhirTestScriptSetupActionOperationRequestHeaderList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptSetupActionOperationRequestHeaderListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptSetupActionOperationRequestHeaderListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptSetupActionOperationRequestHeaderListEnumerator.GetCurrent : TFhirTestScriptSetupActionOperationRequestHeader;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptSetupActionOperationRequestHeaderListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestScriptSetupActionOperationRequestHeaderList }
procedure TFhirTestScriptSetupActionOperationRequestHeaderList.AddItem(value: TFhirTestScriptSetupActionOperationRequestHeader);
begin
  assert(value.ClassName = 'TFhirTestScriptSetupActionOperationRequestHeader', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptSetupActionOperationRequestHeader');
  add(value);
end;

function TFhirTestScriptSetupActionOperationRequestHeaderList.Append: TFhirTestScriptSetupActionOperationRequestHeader;
begin
  result := TFhirTestScriptSetupActionOperationRequestHeader.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptSetupActionOperationRequestHeaderList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptSetupActionOperationRequestHeaderList.GetEnumerator : TFhirTestScriptSetupActionOperationRequestHeaderListEnumerator;
begin
  result := TFhirTestScriptSetupActionOperationRequestHeaderListEnumerator.Create(self.link);
end;

function TFhirTestScriptSetupActionOperationRequestHeaderList.Clone: TFhirTestScriptSetupActionOperationRequestHeaderList;
begin
  result := TFhirTestScriptSetupActionOperationRequestHeaderList(inherited Clone);
end;

function TFhirTestScriptSetupActionOperationRequestHeaderList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptSetupActionOperationRequestHeaderList.GetItemN(index: Integer): TFhirTestScriptSetupActionOperationRequestHeader;
begin
  result := TFhirTestScriptSetupActionOperationRequestHeader(ObjectByIndex[index]);
end;

function TFhirTestScriptSetupActionOperationRequestHeaderList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptSetupActionOperationRequestHeader;
end;
function TFhirTestScriptSetupActionOperationRequestHeaderList.IndexOf(value: TFhirTestScriptSetupActionOperationRequestHeader): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptSetupActionOperationRequestHeaderList.Insert(index: Integer): TFhirTestScriptSetupActionOperationRequestHeader;
begin
  result := TFhirTestScriptSetupActionOperationRequestHeader.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptSetupActionOperationRequestHeaderList.InsertItem(index: Integer; value: TFhirTestScriptSetupActionOperationRequestHeader);
begin
  assert(value is TFhirTestScriptSetupActionOperationRequestHeader);
  Inherited Insert(index, value);
end;

function TFhirTestScriptSetupActionOperationRequestHeaderList.Item(index: Integer): TFhirTestScriptSetupActionOperationRequestHeader;
begin
  result := TFhirTestScriptSetupActionOperationRequestHeader(ObjectByIndex[index]);
end;

function TFhirTestScriptSetupActionOperationRequestHeaderList.Link: TFhirTestScriptSetupActionOperationRequestHeaderList;
begin
  result := TFhirTestScriptSetupActionOperationRequestHeaderList(inherited Link);
end;

procedure TFhirTestScriptSetupActionOperationRequestHeaderList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptSetupActionOperationRequestHeaderList.SetItemByIndex(index: Integer; value: TFhirTestScriptSetupActionOperationRequestHeader);
begin
  assert(value is TFhirTestScriptSetupActionOperationRequestHeader);
  FhirTestScriptSetupActionOperationRequestHeaders[index] := value;
end;

procedure TFhirTestScriptSetupActionOperationRequestHeaderList.SetItemN(index: Integer; value: TFhirTestScriptSetupActionOperationRequestHeader);
begin
  assert(value is TFhirTestScriptSetupActionOperationRequestHeader);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptSetupActionAssert }

constructor TFhirTestScriptSetupActionAssert.Create;
begin
  inherited;
end;

destructor TFhirTestScriptSetupActionAssert.Destroy;
begin
  FLabel_.free;
  FDescription.free;
  FDirection.free;
  FCompareToSourceId.free;
  FCompareToSourcePath.free;
  FContentType.free;
  FHeaderField.free;
  FMinimumId.free;
  FNavigationLinks.free;
  FOperator.free;
  FPath.free;
  FResource.free;
  FResponse.free;
  FResponseCode.free;
  FSourceId.free;
  FValidateProfileId.free;
  FValue.free;
  FWarningOnly.free;
  inherited;
end;

procedure TFhirTestScriptSetupActionAssert.Assign(oSource : TFslObject);
begin
  inherited;
  label_Element := TFhirTestScriptSetupActionAssert(oSource).label_Element.Clone;
  descriptionElement := TFhirTestScriptSetupActionAssert(oSource).descriptionElement.Clone;
  FDirection := TFhirTestScriptSetupActionAssert(oSource).FDirection.Link;
  compareToSourceIdElement := TFhirTestScriptSetupActionAssert(oSource).compareToSourceIdElement.Clone;
  compareToSourcePathElement := TFhirTestScriptSetupActionAssert(oSource).compareToSourcePathElement.Clone;
  FContentType := TFhirTestScriptSetupActionAssert(oSource).FContentType.Link;
  headerFieldElement := TFhirTestScriptSetupActionAssert(oSource).headerFieldElement.Clone;
  minimumIdElement := TFhirTestScriptSetupActionAssert(oSource).minimumIdElement.Clone;
  navigationLinksElement := TFhirTestScriptSetupActionAssert(oSource).navigationLinksElement.Clone;
  FOperator := TFhirTestScriptSetupActionAssert(oSource).FOperator.Link;
  pathElement := TFhirTestScriptSetupActionAssert(oSource).pathElement.Clone;
  resourceElement := TFhirTestScriptSetupActionAssert(oSource).resourceElement.Clone;
  FResponse := TFhirTestScriptSetupActionAssert(oSource).FResponse.Link;
  responseCodeElement := TFhirTestScriptSetupActionAssert(oSource).responseCodeElement.Clone;
  sourceIdElement := TFhirTestScriptSetupActionAssert(oSource).sourceIdElement.Clone;
  validateProfileIdElement := TFhirTestScriptSetupActionAssert(oSource).validateProfileIdElement.Clone;
  valueElement := TFhirTestScriptSetupActionAssert(oSource).valueElement.Clone;
  warningOnlyElement := TFhirTestScriptSetupActionAssert(oSource).warningOnlyElement.Clone;
end;

procedure TFhirTestScriptSetupActionAssert.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'label') Then
     list.add(self.link, 'label', FLabel_.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'direction') Then
     list.add(self.link, 'direction', FDirection.Link);
  if (child_name = 'compareToSourceId') Then
     list.add(self.link, 'compareToSourceId', FCompareToSourceId.Link);
  if (child_name = 'compareToSourcePath') Then
     list.add(self.link, 'compareToSourcePath', FCompareToSourcePath.Link);
  if (child_name = 'contentType') Then
     list.add(self.link, 'contentType', FContentType.Link);
  if (child_name = 'headerField') Then
     list.add(self.link, 'headerField', FHeaderField.Link);
  if (child_name = 'minimumId') Then
     list.add(self.link, 'minimumId', FMinimumId.Link);
  if (child_name = 'navigationLinks') Then
     list.add(self.link, 'navigationLinks', FNavigationLinks.Link);
  if (child_name = 'operator') Then
     list.add(self.link, 'operator', FOperator.Link);
  if (child_name = 'path') Then
     list.add(self.link, 'path', FPath.Link);
  if (child_name = 'resource') Then
     list.add(self.link, 'resource', FResource.Link);
  if (child_name = 'response') Then
     list.add(self.link, 'response', FResponse.Link);
  if (child_name = 'responseCode') Then
     list.add(self.link, 'responseCode', FResponseCode.Link);
  if (child_name = 'sourceId') Then
     list.add(self.link, 'sourceId', FSourceId.Link);
  if (child_name = 'validateProfileId') Then
     list.add(self.link, 'validateProfileId', FValidateProfileId.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
  if (child_name = 'warningOnly') Then
     list.add(self.link, 'warningOnly', FWarningOnly.Link);
end;

procedure TFhirTestScriptSetupActionAssert.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'label', 'string', false, TFhirString, FLabel_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'direction', 'code', false, TFHIREnum, FDirection.Link));{1}
  oList.add(TFHIRProperty.create(self, 'compareToSourceId', 'string', false, TFhirString, FCompareToSourceId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'compareToSourcePath', 'string', false, TFhirString, FCompareToSourcePath.Link));{2}
  oList.add(TFHIRProperty.create(self, 'contentType', 'code', false, TFHIREnum, FContentType.Link));{1}
  oList.add(TFHIRProperty.create(self, 'headerField', 'string', false, TFhirString, FHeaderField.Link));{2}
  oList.add(TFHIRProperty.create(self, 'minimumId', 'string', false, TFhirString, FMinimumId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'navigationLinks', 'boolean', false, TFhirBoolean, FNavigationLinks.Link));{2}
  oList.add(TFHIRProperty.create(self, 'operator', 'code', false, TFHIREnum, FOperator.Link));{1}
  oList.add(TFHIRProperty.create(self, 'path', 'string', false, TFhirString, FPath.Link));{2}
  oList.add(TFHIRProperty.create(self, 'resource', 'code', false, TFhirCode, FResource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'response', 'code', false, TFHIREnum, FResponse.Link));{1}
  oList.add(TFHIRProperty.create(self, 'responseCode', 'string', false, TFhirString, FResponseCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'sourceId', 'id', false, TFhirId, FSourceId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'validateProfileId', 'id', false, TFhirId, FValidateProfileId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value', 'string', false, TFhirString, FValue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'warningOnly', 'boolean', false, TFhirBoolean, FWarningOnly.Link));{2}
end;

function TFhirTestScriptSetupActionAssert.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'label') then
  begin
    Label_Element := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'direction') then
  begin
    DirectionElement := asEnum(SYSTEMS_TFhirAssertDirectionCodesEnum, CODES_TFhirAssertDirectionCodesEnum, propValue);
    result := propValue
  end
  else if (propName = 'compareToSourceId') then
  begin
    CompareToSourceIdElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'compareToSourcePath') then
  begin
    CompareToSourcePathElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'contentType') then
  begin
    ContentTypeElement := asEnum(SYSTEMS_TFhirContentTypeEnum, CODES_TFhirContentTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'headerField') then
  begin
    HeaderFieldElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'minimumId') then
  begin
    MinimumIdElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'navigationLinks') then
  begin
    NavigationLinksElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'operator') then
  begin
    OperatorElement := asEnum(SYSTEMS_TFhirAssertOperatorCodesEnum, CODES_TFhirAssertOperatorCodesEnum, propValue);
    result := propValue
  end
  else if (propName = 'path') then
  begin
    PathElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'resource') then
  begin
    ResourceElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'response') then
  begin
    ResponseElement := asEnum(SYSTEMS_TFhirAssertResponseCodeTypesEnum, CODES_TFhirAssertResponseCodeTypesEnum, propValue);
    result := propValue
  end
  else if (propName = 'responseCode') then
  begin
    ResponseCodeElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'sourceId') then
  begin
    SourceIdElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'validateProfileId') then
  begin
    ValidateProfileIdElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'warningOnly') then
  begin
    WarningOnlyElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptSetupActionAssert.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestScriptSetupActionAssert.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'label') then result := TFhirString.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'compareToSourceId') then result := TFhirString.create() {5b}
  else if (propName = 'compareToSourcePath') then result := TFhirString.create() {5b}
  else if (propName = 'headerField') then result := TFhirString.create() {5b}
  else if (propName = 'minimumId') then result := TFhirString.create() {5b}
  else if (propName = 'navigationLinks') then result := TFhirBoolean.create() {5b}
  else if (propName = 'path') then result := TFhirString.create() {5b}
  else if (propName = 'resource') then result := TFhirCode.create() {5b}
  else if (propName = 'responseCode') then result := TFhirString.create() {5b}
  else if (propName = 'sourceId') then result := TFhirId.create() {5b}
  else if (propName = 'validateProfileId') then result := TFhirId.create() {5b}
  else if (propName = 'value') then result := TFhirString.create() {5b}
  else if (propName = 'warningOnly') then result := TFhirBoolean.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptSetupActionAssert.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'label') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'direction') then result := 'code'
  else if (propName = 'compareToSourceId') then result := 'string'
  else if (propName = 'compareToSourcePath') then result := 'string'
  else if (propName = 'contentType') then result := 'code'
  else if (propName = 'headerField') then result := 'string'
  else if (propName = 'minimumId') then result := 'string'
  else if (propName = 'navigationLinks') then result := 'boolean'
  else if (propName = 'operator') then result := 'code'
  else if (propName = 'path') then result := 'string'
  else if (propName = 'resource') then result := 'code'
  else if (propName = 'response') then result := 'code'
  else if (propName = 'responseCode') then result := 'string'
  else if (propName = 'sourceId') then result := 'id'
  else if (propName = 'validateProfileId') then result := 'id'
  else if (propName = 'value') then result := 'string'
  else if (propName = 'warningOnly') then result := 'boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptSetupActionAssert.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'label') then Label_Element := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'direction') then DirectionElement := nil
  else if (propName = 'compareToSourceId') then CompareToSourceIdElement := nil
  else if (propName = 'compareToSourcePath') then CompareToSourcePathElement := nil
  else if (propName = 'contentType') then ContentTypeElement := nil
  else if (propName = 'headerField') then HeaderFieldElement := nil
  else if (propName = 'minimumId') then MinimumIdElement := nil
  else if (propName = 'navigationLinks') then NavigationLinksElement := nil
  else if (propName = 'operator') then OperatorElement := nil
  else if (propName = 'path') then PathElement := nil
  else if (propName = 'resource') then ResourceElement := nil
  else if (propName = 'response') then ResponseElement := nil
  else if (propName = 'responseCode') then ResponseCodeElement := nil
  else if (propName = 'sourceId') then SourceIdElement := nil
  else if (propName = 'validateProfileId') then ValidateProfileIdElement := nil
  else if (propName = 'value') then ValueElement := nil
  else if (propName = 'warningOnly') then WarningOnlyElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptSetupActionAssert.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'label') then Label_Element := asString(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'direction') then DirectionElement := asEnum(SYSTEMS_TFhirAssertDirectionCodesEnum, CODES_TFhirAssertDirectionCodesEnum, new){4}
  else if (propName = 'compareToSourceId') then CompareToSourceIdElement := asString(new){5b}
  else if (propName = 'compareToSourcePath') then CompareToSourcePathElement := asString(new){5b}
  else if (propName = 'contentType') then ContentTypeElement := asEnum(SYSTEMS_TFhirContentTypeEnum, CODES_TFhirContentTypeEnum, new){4}
  else if (propName = 'headerField') then HeaderFieldElement := asString(new){5b}
  else if (propName = 'minimumId') then MinimumIdElement := asString(new){5b}
  else if (propName = 'navigationLinks') then NavigationLinksElement := asBoolean(new){5b}
  else if (propName = 'operator') then OperatorElement := asEnum(SYSTEMS_TFhirAssertOperatorCodesEnum, CODES_TFhirAssertOperatorCodesEnum, new){4}
  else if (propName = 'path') then PathElement := asString(new){5b}
  else if (propName = 'resource') then ResourceElement := asCode(new){5b}
  else if (propName = 'response') then ResponseElement := asEnum(SYSTEMS_TFhirAssertResponseCodeTypesEnum, CODES_TFhirAssertResponseCodeTypesEnum, new){4}
  else if (propName = 'responseCode') then ResponseCodeElement := asString(new){5b}
  else if (propName = 'sourceId') then SourceIdElement := asId(new){5b}
  else if (propName = 'validateProfileId') then ValidateProfileIdElement := asId(new){5b}
  else if (propName = 'value') then ValueElement := asString(new){5b}
  else if (propName = 'warningOnly') then WarningOnlyElement := asBoolean(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptSetupActionAssert.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptSetupActionAssert.fhirType : string;
begin
  result := 'assert';
end;

function TFhirTestScriptSetupActionAssert.Link : TFhirTestScriptSetupActionAssert;
begin
  result := TFhirTestScriptSetupActionAssert(inherited Link);
end;

function TFhirTestScriptSetupActionAssert.Clone : TFhirTestScriptSetupActionAssert;
begin
  result := TFhirTestScriptSetupActionAssert(inherited Clone);
end;

function TFhirTestScriptSetupActionAssert.equals(other : TObject) : boolean; 
var
  o : TFhirTestScriptSetupActionAssert;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptSetupActionAssert)) then
    result := false
  else
  begin
    o := TFhirTestScriptSetupActionAssert(other);
    result := compareDeep(label_Element, o.label_Element, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(directionElement, o.directionElement, true) and compareDeep(compareToSourceIdElement, o.compareToSourceIdElement, true) and 
      compareDeep(compareToSourcePathElement, o.compareToSourcePathElement, true) and 
      compareDeep(contentTypeElement, o.contentTypeElement, true) and compareDeep(headerFieldElement, o.headerFieldElement, true) and 
      compareDeep(minimumIdElement, o.minimumIdElement, true) and compareDeep(navigationLinksElement, o.navigationLinksElement, true) and 
      compareDeep(operatorElement, o.operatorElement, true) and compareDeep(pathElement, o.pathElement, true) and 
      compareDeep(resourceElement, o.resourceElement, true) and compareDeep(responseElement, o.responseElement, true) and 
      compareDeep(responseCodeElement, o.responseCodeElement, true) and compareDeep(sourceIdElement, o.sourceIdElement, true) and 
      compareDeep(validateProfileIdElement, o.validateProfileIdElement, true) and compareDeep(valueElement, o.valueElement, true) and 
      compareDeep(warningOnlyElement, o.warningOnlyElement, true);
  end;
end;

function TFhirTestScriptSetupActionAssert.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLabel_) and isEmptyProp(FDescription) and isEmptyProp(FDirection) and isEmptyProp(FCompareToSourceId) and isEmptyProp(FCompareToSourcePath) and isEmptyProp(FContentType) and isEmptyProp(FHeaderField) and isEmptyProp(FMinimumId) and isEmptyProp(FNavigationLinks) and isEmptyProp(FOperator) and isEmptyProp(FPath) and isEmptyProp(FResource) and isEmptyProp(FResponse) and isEmptyProp(FResponseCode) and isEmptyProp(FSourceId) and isEmptyProp(FValidateProfileId) and isEmptyProp(FValue) and isEmptyProp(FWarningOnly);
end;

procedure TFhirTestScriptSetupActionAssert.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('label');
  fields.add('description');
  fields.add('direction');
  fields.add('compareToSourceId');
  fields.add('compareToSourcePath');
  fields.add('contentType');
  fields.add('headerField');
  fields.add('minimumId');
  fields.add('navigationLinks');
  fields.add('operator');
  fields.add('path');
  fields.add('resource');
  fields.add('response');
  fields.add('responseCode');
  fields.add('sourceId');
  fields.add('validateProfileId');
  fields.add('value');
  fields.add('warningOnly');
end;

{ TFhirTestScriptSetupActionAssert }

Procedure TFhirTestScriptSetupActionAssert.SetLabel_(value : TFhirString);
begin
  FLabel_.free;
  FLabel_ := value;
end;

Function TFhirTestScriptSetupActionAssert.GetLabel_ST : String;
begin
  if FLabel_ = nil then
    result := ''
  else
    result := FLabel_.value;
end;

Procedure TFhirTestScriptSetupActionAssert.SetLabel_ST(value : String);
begin
  if value <> '' then
  begin
    if FLabel_ = nil then
      FLabel_ := TFhirString.create;
    FLabel_.value := value
  end
  else if FLabel_ <> nil then
    FLabel_.value := '';
end;

Procedure TFhirTestScriptSetupActionAssert.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirTestScriptSetupActionAssert.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirTestScriptSetupActionAssert.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirTestScriptSetupActionAssert.SetDirection(value : TFhirEnum);
begin
  FDirection.free;
  FDirection := value;
end;

Function TFhirTestScriptSetupActionAssert.GetDirectionST : TFhirAssertDirectionCodesEnum;
begin
  if FDirection = nil then
    result := TFhirAssertDirectionCodesEnum(0)
  else
    result := TFhirAssertDirectionCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirAssertDirectionCodesEnum, FDirection.value));
end;

Procedure TFhirTestScriptSetupActionAssert.SetDirectionST(value : TFhirAssertDirectionCodesEnum);
begin
  if ord(value) = 0 then
    DirectionElement := nil
  else
    DirectionElement := TFhirEnum.create(SYSTEMS_TFhirAssertDirectionCodesEnum[value], CODES_TFhirAssertDirectionCodesEnum[value]);
end;

Procedure TFhirTestScriptSetupActionAssert.SetCompareToSourceId(value : TFhirString);
begin
  FCompareToSourceId.free;
  FCompareToSourceId := value;
end;

Function TFhirTestScriptSetupActionAssert.GetCompareToSourceIdST : String;
begin
  if FCompareToSourceId = nil then
    result := ''
  else
    result := FCompareToSourceId.value;
end;

Procedure TFhirTestScriptSetupActionAssert.SetCompareToSourceIdST(value : String);
begin
  if value <> '' then
  begin
    if FCompareToSourceId = nil then
      FCompareToSourceId := TFhirString.create;
    FCompareToSourceId.value := value
  end
  else if FCompareToSourceId <> nil then
    FCompareToSourceId.value := '';
end;

Procedure TFhirTestScriptSetupActionAssert.SetCompareToSourcePath(value : TFhirString);
begin
  FCompareToSourcePath.free;
  FCompareToSourcePath := value;
end;

Function TFhirTestScriptSetupActionAssert.GetCompareToSourcePathST : String;
begin
  if FCompareToSourcePath = nil then
    result := ''
  else
    result := FCompareToSourcePath.value;
end;

Procedure TFhirTestScriptSetupActionAssert.SetCompareToSourcePathST(value : String);
begin
  if value <> '' then
  begin
    if FCompareToSourcePath = nil then
      FCompareToSourcePath := TFhirString.create;
    FCompareToSourcePath.value := value
  end
  else if FCompareToSourcePath <> nil then
    FCompareToSourcePath.value := '';
end;

Procedure TFhirTestScriptSetupActionAssert.SetContentType(value : TFhirEnum);
begin
  FContentType.free;
  FContentType := value;
end;

Function TFhirTestScriptSetupActionAssert.GetContentTypeST : TFhirContentTypeEnum;
begin
  if FContentType = nil then
    result := TFhirContentTypeEnum(0)
  else
    result := TFhirContentTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirContentTypeEnum, FContentType.value));
end;

Procedure TFhirTestScriptSetupActionAssert.SetContentTypeST(value : TFhirContentTypeEnum);
begin
  if ord(value) = 0 then
    ContentTypeElement := nil
  else
    ContentTypeElement := TFhirEnum.create(SYSTEMS_TFhirContentTypeEnum[value], CODES_TFhirContentTypeEnum[value]);
end;

Procedure TFhirTestScriptSetupActionAssert.SetHeaderField(value : TFhirString);
begin
  FHeaderField.free;
  FHeaderField := value;
end;

Function TFhirTestScriptSetupActionAssert.GetHeaderFieldST : String;
begin
  if FHeaderField = nil then
    result := ''
  else
    result := FHeaderField.value;
end;

Procedure TFhirTestScriptSetupActionAssert.SetHeaderFieldST(value : String);
begin
  if value <> '' then
  begin
    if FHeaderField = nil then
      FHeaderField := TFhirString.create;
    FHeaderField.value := value
  end
  else if FHeaderField <> nil then
    FHeaderField.value := '';
end;

Procedure TFhirTestScriptSetupActionAssert.SetMinimumId(value : TFhirString);
begin
  FMinimumId.free;
  FMinimumId := value;
end;

Function TFhirTestScriptSetupActionAssert.GetMinimumIdST : String;
begin
  if FMinimumId = nil then
    result := ''
  else
    result := FMinimumId.value;
end;

Procedure TFhirTestScriptSetupActionAssert.SetMinimumIdST(value : String);
begin
  if value <> '' then
  begin
    if FMinimumId = nil then
      FMinimumId := TFhirString.create;
    FMinimumId.value := value
  end
  else if FMinimumId <> nil then
    FMinimumId.value := '';
end;

Procedure TFhirTestScriptSetupActionAssert.SetNavigationLinks(value : TFhirBoolean);
begin
  FNavigationLinks.free;
  FNavigationLinks := value;
end;

Function TFhirTestScriptSetupActionAssert.GetNavigationLinksST : Boolean;
begin
  if FNavigationLinks = nil then
    result := false
  else
    result := FNavigationLinks.value;
end;

Procedure TFhirTestScriptSetupActionAssert.SetNavigationLinksST(value : Boolean);
begin
  if FNavigationLinks = nil then
    FNavigationLinks := TFhirBoolean.create;
  FNavigationLinks.value := value
end;

Procedure TFhirTestScriptSetupActionAssert.SetOperator(value : TFhirEnum);
begin
  FOperator.free;
  FOperator := value;
end;

Function TFhirTestScriptSetupActionAssert.GetOperatorST : TFhirAssertOperatorCodesEnum;
begin
  if FOperator = nil then
    result := TFhirAssertOperatorCodesEnum(0)
  else
    result := TFhirAssertOperatorCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirAssertOperatorCodesEnum, FOperator.value));
end;

Procedure TFhirTestScriptSetupActionAssert.SetOperatorST(value : TFhirAssertOperatorCodesEnum);
begin
  if ord(value) = 0 then
    OperatorElement := nil
  else
    OperatorElement := TFhirEnum.create(SYSTEMS_TFhirAssertOperatorCodesEnum[value], CODES_TFhirAssertOperatorCodesEnum[value]);
end;

Procedure TFhirTestScriptSetupActionAssert.SetPath(value : TFhirString);
begin
  FPath.free;
  FPath := value;
end;

Function TFhirTestScriptSetupActionAssert.GetPathST : String;
begin
  if FPath = nil then
    result := ''
  else
    result := FPath.value;
end;

Procedure TFhirTestScriptSetupActionAssert.SetPathST(value : String);
begin
  if value <> '' then
  begin
    if FPath = nil then
      FPath := TFhirString.create;
    FPath.value := value
  end
  else if FPath <> nil then
    FPath.value := '';
end;

Procedure TFhirTestScriptSetupActionAssert.SetResource(value : TFhirCode);
begin
  FResource.free;
  FResource := value;
end;

Function TFhirTestScriptSetupActionAssert.GetResourceST : String;
begin
  if FResource = nil then
    result := ''
  else
    result := FResource.value;
end;

Procedure TFhirTestScriptSetupActionAssert.SetResourceST(value : String);
begin
  if value <> '' then
  begin
    if FResource = nil then
      FResource := TFhirCode.create;
    FResource.value := value
  end
  else if FResource <> nil then
    FResource.value := '';
end;

Procedure TFhirTestScriptSetupActionAssert.SetResponse(value : TFhirEnum);
begin
  FResponse.free;
  FResponse := value;
end;

Function TFhirTestScriptSetupActionAssert.GetResponseST : TFhirAssertResponseCodeTypesEnum;
begin
  if FResponse = nil then
    result := TFhirAssertResponseCodeTypesEnum(0)
  else
    result := TFhirAssertResponseCodeTypesEnum(StringArrayIndexOfSensitive(CODES_TFhirAssertResponseCodeTypesEnum, FResponse.value));
end;

Procedure TFhirTestScriptSetupActionAssert.SetResponseST(value : TFhirAssertResponseCodeTypesEnum);
begin
  if ord(value) = 0 then
    ResponseElement := nil
  else
    ResponseElement := TFhirEnum.create(SYSTEMS_TFhirAssertResponseCodeTypesEnum[value], CODES_TFhirAssertResponseCodeTypesEnum[value]);
end;

Procedure TFhirTestScriptSetupActionAssert.SetResponseCode(value : TFhirString);
begin
  FResponseCode.free;
  FResponseCode := value;
end;

Function TFhirTestScriptSetupActionAssert.GetResponseCodeST : String;
begin
  if FResponseCode = nil then
    result := ''
  else
    result := FResponseCode.value;
end;

Procedure TFhirTestScriptSetupActionAssert.SetResponseCodeST(value : String);
begin
  if value <> '' then
  begin
    if FResponseCode = nil then
      FResponseCode := TFhirString.create;
    FResponseCode.value := value
  end
  else if FResponseCode <> nil then
    FResponseCode.value := '';
end;

Procedure TFhirTestScriptSetupActionAssert.SetSourceId(value : TFhirId);
begin
  FSourceId.free;
  FSourceId := value;
end;

Function TFhirTestScriptSetupActionAssert.GetSourceIdST : String;
begin
  if FSourceId = nil then
    result := ''
  else
    result := FSourceId.value;
end;

Procedure TFhirTestScriptSetupActionAssert.SetSourceIdST(value : String);
begin
  if value <> '' then
  begin
    if FSourceId = nil then
      FSourceId := TFhirId.create;
    FSourceId.value := value
  end
  else if FSourceId <> nil then
    FSourceId.value := '';
end;

Procedure TFhirTestScriptSetupActionAssert.SetValidateProfileId(value : TFhirId);
begin
  FValidateProfileId.free;
  FValidateProfileId := value;
end;

Function TFhirTestScriptSetupActionAssert.GetValidateProfileIdST : String;
begin
  if FValidateProfileId = nil then
    result := ''
  else
    result := FValidateProfileId.value;
end;

Procedure TFhirTestScriptSetupActionAssert.SetValidateProfileIdST(value : String);
begin
  if value <> '' then
  begin
    if FValidateProfileId = nil then
      FValidateProfileId := TFhirId.create;
    FValidateProfileId.value := value
  end
  else if FValidateProfileId <> nil then
    FValidateProfileId.value := '';
end;

Procedure TFhirTestScriptSetupActionAssert.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirTestScriptSetupActionAssert.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

Procedure TFhirTestScriptSetupActionAssert.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

Procedure TFhirTestScriptSetupActionAssert.SetWarningOnly(value : TFhirBoolean);
begin
  FWarningOnly.free;
  FWarningOnly := value;
end;

Function TFhirTestScriptSetupActionAssert.GetWarningOnlyST : Boolean;
begin
  if FWarningOnly = nil then
    result := false
  else
    result := FWarningOnly.value;
end;

Procedure TFhirTestScriptSetupActionAssert.SetWarningOnlyST(value : Boolean);
begin
  if FWarningOnly = nil then
    FWarningOnly := TFhirBoolean.create;
  FWarningOnly.value := value
end;

function TFhirTestScriptSetupActionAssert.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FLabel_.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FDirection.sizeInBytes);
  inc(result, FCompareToSourceId.sizeInBytes);
  inc(result, FCompareToSourcePath.sizeInBytes);
  inc(result, FContentType.sizeInBytes);
  inc(result, FHeaderField.sizeInBytes);
  inc(result, FMinimumId.sizeInBytes);
  inc(result, FNavigationLinks.sizeInBytes);
  inc(result, FOperator.sizeInBytes);
  inc(result, FPath.sizeInBytes);
  inc(result, FResource.sizeInBytes);
  inc(result, FResponse.sizeInBytes);
  inc(result, FResponseCode.sizeInBytes);
  inc(result, FSourceId.sizeInBytes);
  inc(result, FValidateProfileId.sizeInBytes);
  inc(result, FValue.sizeInBytes);
  inc(result, FWarningOnly.sizeInBytes);
end;

{ TFhirTestScriptSetupActionAssertListEnumerator }

Constructor TFhirTestScriptSetupActionAssertListEnumerator.Create(list : TFhirTestScriptSetupActionAssertList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptSetupActionAssertListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptSetupActionAssertListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptSetupActionAssertListEnumerator.GetCurrent : TFhirTestScriptSetupActionAssert;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptSetupActionAssertListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestScriptSetupActionAssertList }
procedure TFhirTestScriptSetupActionAssertList.AddItem(value: TFhirTestScriptSetupActionAssert);
begin
  assert(value.ClassName = 'TFhirTestScriptSetupActionAssert', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptSetupActionAssert');
  add(value);
end;

function TFhirTestScriptSetupActionAssertList.Append: TFhirTestScriptSetupActionAssert;
begin
  result := TFhirTestScriptSetupActionAssert.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptSetupActionAssertList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptSetupActionAssertList.GetEnumerator : TFhirTestScriptSetupActionAssertListEnumerator;
begin
  result := TFhirTestScriptSetupActionAssertListEnumerator.Create(self.link);
end;

function TFhirTestScriptSetupActionAssertList.Clone: TFhirTestScriptSetupActionAssertList;
begin
  result := TFhirTestScriptSetupActionAssertList(inherited Clone);
end;

function TFhirTestScriptSetupActionAssertList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptSetupActionAssertList.GetItemN(index: Integer): TFhirTestScriptSetupActionAssert;
begin
  result := TFhirTestScriptSetupActionAssert(ObjectByIndex[index]);
end;

function TFhirTestScriptSetupActionAssertList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptSetupActionAssert;
end;
function TFhirTestScriptSetupActionAssertList.IndexOf(value: TFhirTestScriptSetupActionAssert): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptSetupActionAssertList.Insert(index: Integer): TFhirTestScriptSetupActionAssert;
begin
  result := TFhirTestScriptSetupActionAssert.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptSetupActionAssertList.InsertItem(index: Integer; value: TFhirTestScriptSetupActionAssert);
begin
  assert(value is TFhirTestScriptSetupActionAssert);
  Inherited Insert(index, value);
end;

function TFhirTestScriptSetupActionAssertList.Item(index: Integer): TFhirTestScriptSetupActionAssert;
begin
  result := TFhirTestScriptSetupActionAssert(ObjectByIndex[index]);
end;

function TFhirTestScriptSetupActionAssertList.Link: TFhirTestScriptSetupActionAssertList;
begin
  result := TFhirTestScriptSetupActionAssertList(inherited Link);
end;

procedure TFhirTestScriptSetupActionAssertList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptSetupActionAssertList.SetItemByIndex(index: Integer; value: TFhirTestScriptSetupActionAssert);
begin
  assert(value is TFhirTestScriptSetupActionAssert);
  FhirTestScriptSetupActionAsserts[index] := value;
end;

procedure TFhirTestScriptSetupActionAssertList.SetItemN(index: Integer; value: TFhirTestScriptSetupActionAssert);
begin
  assert(value is TFhirTestScriptSetupActionAssert);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptTest }

constructor TFhirTestScriptTest.Create;
begin
  inherited;
end;

destructor TFhirTestScriptTest.Destroy;
begin
  FName.free;
  FDescription.free;
  FMetadata.free;
  FActionList.Free;
  inherited;
end;

procedure TFhirTestScriptTest.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirTestScriptTest(oSource).nameElement.Clone;
  descriptionElement := TFhirTestScriptTest(oSource).descriptionElement.Clone;
  metadata := TFhirTestScriptTest(oSource).metadata.Clone;
  if (TFhirTestScriptTest(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirTestScriptTestActionList.Create;
    FActionList.Assign(TFhirTestScriptTest(oSource).FActionList);
  end;
end;

procedure TFhirTestScriptTest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'metadata') Then
     list.add(self.link, 'metadata', FMetadata.Link);
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
end;

procedure TFhirTestScriptTest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'metadata', '@TestScript.metadata', false, TFhirTestScriptMetadata, FMetadata.Link));{2}
  oList.add(TFHIRProperty.create(self, 'action', '', true, TFhirTestScriptTestAction, FActionList.Link)){3};
end;

function TFhirTestScriptTest.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'metadata') then
  begin
    Metadata := propValue as TFhirTestScriptMetadata{4b};
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirTestScriptTestAction){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptTest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirTestScriptTestAction){2a}
  else inherited;
end;

function TFhirTestScriptTest.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'metadata') then result := TFhirTestScriptMetadata.create(){4b}
  else if (propName = 'action') then result := ActionList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptTest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'metadata') then result := '@TestScript.metadata'
  else if (propName = 'action') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptTest.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'metadata') then MetadataElement := nil
  else if (propName = 'action') then deletePropertyValue('action', ActionList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptTest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'metadata') then MetadataElement := new as TFhirTestScriptMetadata{4}
  else if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptTest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'action') then ActionList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptTest.fhirType : string;
begin
  result := 'test';
end;

function TFhirTestScriptTest.Link : TFhirTestScriptTest;
begin
  result := TFhirTestScriptTest(inherited Link);
end;

function TFhirTestScriptTest.Clone : TFhirTestScriptTest;
begin
  result := TFhirTestScriptTest(inherited Clone);
end;

function TFhirTestScriptTest.equals(other : TObject) : boolean; 
var
  o : TFhirTestScriptTest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptTest)) then
    result := false
  else
  begin
    o := TFhirTestScriptTest(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(metadataElement, o.metadataElement, true) and compareDeep(actionList, o.actionList, true);
  end;
end;

function TFhirTestScriptTest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FDescription) and isEmptyProp(FMetadata) and isEmptyProp(FactionList);
end;

procedure TFhirTestScriptTest.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('description');
  fields.add('metadata');
  fields.add('action');
end;

{ TFhirTestScriptTest }

Procedure TFhirTestScriptTest.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirTestScriptTest.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirTestScriptTest.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirTestScriptTest.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirTestScriptTest.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirTestScriptTest.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirTestScriptTest.SetMetadata(value : TFhirTestScriptMetadata);
begin
  FMetadata.free;
  FMetadata := value;
end;

Function TFhirTestScriptTest.GetActionList : TFhirTestScriptTestActionList;
begin
  if FActionList = nil then
    FActionList := TFhirTestScriptTestActionList.Create;
  result := FActionList;
end;

Function TFhirTestScriptTest.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

function TFhirTestScriptTest.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FMetadata.sizeInBytes);
  inc(result, FactionList.sizeInBytes);
end;

{ TFhirTestScriptTestListEnumerator }

Constructor TFhirTestScriptTestListEnumerator.Create(list : TFhirTestScriptTestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptTestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptTestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptTestListEnumerator.GetCurrent : TFhirTestScriptTest;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptTestListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestScriptTestList }
procedure TFhirTestScriptTestList.AddItem(value: TFhirTestScriptTest);
begin
  assert(value.ClassName = 'TFhirTestScriptTest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptTest');
  add(value);
end;

function TFhirTestScriptTestList.Append: TFhirTestScriptTest;
begin
  result := TFhirTestScriptTest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptTestList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptTestList.GetEnumerator : TFhirTestScriptTestListEnumerator;
begin
  result := TFhirTestScriptTestListEnumerator.Create(self.link);
end;

function TFhirTestScriptTestList.Clone: TFhirTestScriptTestList;
begin
  result := TFhirTestScriptTestList(inherited Clone);
end;

function TFhirTestScriptTestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptTestList.GetItemN(index: Integer): TFhirTestScriptTest;
begin
  result := TFhirTestScriptTest(ObjectByIndex[index]);
end;

function TFhirTestScriptTestList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptTest;
end;
function TFhirTestScriptTestList.IndexOf(value: TFhirTestScriptTest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptTestList.Insert(index: Integer): TFhirTestScriptTest;
begin
  result := TFhirTestScriptTest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptTestList.InsertItem(index: Integer; value: TFhirTestScriptTest);
begin
  assert(value is TFhirTestScriptTest);
  Inherited Insert(index, value);
end;

function TFhirTestScriptTestList.Item(index: Integer): TFhirTestScriptTest;
begin
  result := TFhirTestScriptTest(ObjectByIndex[index]);
end;

function TFhirTestScriptTestList.Link: TFhirTestScriptTestList;
begin
  result := TFhirTestScriptTestList(inherited Link);
end;

procedure TFhirTestScriptTestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptTestList.SetItemByIndex(index: Integer; value: TFhirTestScriptTest);
begin
  assert(value is TFhirTestScriptTest);
  FhirTestScriptTests[index] := value;
end;

procedure TFhirTestScriptTestList.SetItemN(index: Integer; value: TFhirTestScriptTest);
begin
  assert(value is TFhirTestScriptTest);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptTestAction }

constructor TFhirTestScriptTestAction.Create;
begin
  inherited;
end;

destructor TFhirTestScriptTestAction.Destroy;
begin
  FOperation.free;
  FAssert.free;
  inherited;
end;

procedure TFhirTestScriptTestAction.Assign(oSource : TFslObject);
begin
  inherited;
  operation := TFhirTestScriptTestAction(oSource).operation.Clone;
  assert := TFhirTestScriptTestAction(oSource).assert.Clone;
end;

procedure TFhirTestScriptTestAction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'operation') Then
     list.add(self.link, 'operation', FOperation.Link);
  if (child_name = 'assert') Then
     list.add(self.link, 'assert', FAssert.Link);
end;

procedure TFhirTestScriptTestAction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'operation', '@TestScript.setup.action.operation', false, TFhirTestScriptSetupActionOperation, FOperation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'assert', '@TestScript.setup.action.assert', false, TFhirTestScriptSetupActionAssert, FAssert.Link));{2}
end;

function TFhirTestScriptTestAction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'operation') then
  begin
    Operation := propValue as TFhirTestScriptSetupActionOperation{4b};
    result := propValue;
  end
  else if (propName = 'assert') then
  begin
    Assert := propValue as TFhirTestScriptSetupActionAssert{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptTestAction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestScriptTestAction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'operation') then result := TFhirTestScriptSetupActionOperation.create(){4b}
  else if (propName = 'assert') then result := TFhirTestScriptSetupActionAssert.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptTestAction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'operation') then result := '@TestScript.setup.action.operation'
  else if (propName = 'assert') then result := '@TestScript.setup.action.assert'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptTestAction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'operation') then OperationElement := nil
  else if (propName = 'assert') then AssertElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptTestAction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'operation') then OperationElement := new as TFhirTestScriptSetupActionOperation{4}
  else if (propName = 'assert') then AssertElement := new as TFhirTestScriptSetupActionAssert{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptTestAction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptTestAction.fhirType : string;
begin
  result := 'action';
end;

function TFhirTestScriptTestAction.Link : TFhirTestScriptTestAction;
begin
  result := TFhirTestScriptTestAction(inherited Link);
end;

function TFhirTestScriptTestAction.Clone : TFhirTestScriptTestAction;
begin
  result := TFhirTestScriptTestAction(inherited Clone);
end;

function TFhirTestScriptTestAction.equals(other : TObject) : boolean; 
var
  o : TFhirTestScriptTestAction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptTestAction)) then
    result := false
  else
  begin
    o := TFhirTestScriptTestAction(other);
    result := compareDeep(operationElement, o.operationElement, true) and compareDeep(assertElement, o.assertElement, true);
  end;
end;

function TFhirTestScriptTestAction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FOperation) and isEmptyProp(FAssert);
end;

procedure TFhirTestScriptTestAction.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('operation');
  fields.add('assert');
end;

{ TFhirTestScriptTestAction }

Procedure TFhirTestScriptTestAction.SetOperation(value : TFhirTestScriptSetupActionOperation);
begin
  FOperation.free;
  FOperation := value;
end;

Procedure TFhirTestScriptTestAction.SetAssert(value : TFhirTestScriptSetupActionAssert);
begin
  FAssert.free;
  FAssert := value;
end;

function TFhirTestScriptTestAction.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FOperation.sizeInBytes);
  inc(result, FAssert.sizeInBytes);
end;

{ TFhirTestScriptTestActionListEnumerator }

Constructor TFhirTestScriptTestActionListEnumerator.Create(list : TFhirTestScriptTestActionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptTestActionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptTestActionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptTestActionListEnumerator.GetCurrent : TFhirTestScriptTestAction;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptTestActionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestScriptTestActionList }
procedure TFhirTestScriptTestActionList.AddItem(value: TFhirTestScriptTestAction);
begin
  assert(value.ClassName = 'TFhirTestScriptTestAction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptTestAction');
  add(value);
end;

function TFhirTestScriptTestActionList.Append: TFhirTestScriptTestAction;
begin
  result := TFhirTestScriptTestAction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptTestActionList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptTestActionList.GetEnumerator : TFhirTestScriptTestActionListEnumerator;
begin
  result := TFhirTestScriptTestActionListEnumerator.Create(self.link);
end;

function TFhirTestScriptTestActionList.Clone: TFhirTestScriptTestActionList;
begin
  result := TFhirTestScriptTestActionList(inherited Clone);
end;

function TFhirTestScriptTestActionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptTestActionList.GetItemN(index: Integer): TFhirTestScriptTestAction;
begin
  result := TFhirTestScriptTestAction(ObjectByIndex[index]);
end;

function TFhirTestScriptTestActionList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptTestAction;
end;
function TFhirTestScriptTestActionList.IndexOf(value: TFhirTestScriptTestAction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptTestActionList.Insert(index: Integer): TFhirTestScriptTestAction;
begin
  result := TFhirTestScriptTestAction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptTestActionList.InsertItem(index: Integer; value: TFhirTestScriptTestAction);
begin
  assert(value is TFhirTestScriptTestAction);
  Inherited Insert(index, value);
end;

function TFhirTestScriptTestActionList.Item(index: Integer): TFhirTestScriptTestAction;
begin
  result := TFhirTestScriptTestAction(ObjectByIndex[index]);
end;

function TFhirTestScriptTestActionList.Link: TFhirTestScriptTestActionList;
begin
  result := TFhirTestScriptTestActionList(inherited Link);
end;

procedure TFhirTestScriptTestActionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptTestActionList.SetItemByIndex(index: Integer; value: TFhirTestScriptTestAction);
begin
  assert(value is TFhirTestScriptTestAction);
  FhirTestScriptTestActions[index] := value;
end;

procedure TFhirTestScriptTestActionList.SetItemN(index: Integer; value: TFhirTestScriptTestAction);
begin
  assert(value is TFhirTestScriptTestAction);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptTeardown }

constructor TFhirTestScriptTeardown.Create;
begin
  inherited;
end;

destructor TFhirTestScriptTeardown.Destroy;
begin
  FActionList.Free;
  inherited;
end;

procedure TFhirTestScriptTeardown.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirTestScriptTeardown(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirTestScriptTeardownActionList.Create;
    FActionList.Assign(TFhirTestScriptTeardown(oSource).FActionList);
  end;
end;

procedure TFhirTestScriptTeardown.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
end;

procedure TFhirTestScriptTeardown.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'action', '', true, TFhirTestScriptTeardownAction, FActionList.Link)){3};
end;

function TFhirTestScriptTeardown.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirTestScriptTeardownAction){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptTeardown.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirTestScriptTeardownAction){2a}
  else inherited;
end;

function TFhirTestScriptTeardown.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'action') then result := ActionList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptTeardown.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'action') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptTeardown.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'action') then deletePropertyValue('action', ActionList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptTeardown.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptTeardown.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'action') then ActionList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptTeardown.fhirType : string;
begin
  result := 'teardown';
end;

function TFhirTestScriptTeardown.Link : TFhirTestScriptTeardown;
begin
  result := TFhirTestScriptTeardown(inherited Link);
end;

function TFhirTestScriptTeardown.Clone : TFhirTestScriptTeardown;
begin
  result := TFhirTestScriptTeardown(inherited Clone);
end;

function TFhirTestScriptTeardown.equals(other : TObject) : boolean; 
var
  o : TFhirTestScriptTeardown;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptTeardown)) then
    result := false
  else
  begin
    o := TFhirTestScriptTeardown(other);
    result := compareDeep(actionList, o.actionList, true);
  end;
end;

function TFhirTestScriptTeardown.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FactionList);
end;

procedure TFhirTestScriptTeardown.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('action');
end;

{ TFhirTestScriptTeardown }

Function TFhirTestScriptTeardown.GetActionList : TFhirTestScriptTeardownActionList;
begin
  if FActionList = nil then
    FActionList := TFhirTestScriptTeardownActionList.Create;
  result := FActionList;
end;

Function TFhirTestScriptTeardown.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

function TFhirTestScriptTeardown.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FactionList.sizeInBytes);
end;

{ TFhirTestScriptTeardownListEnumerator }

Constructor TFhirTestScriptTeardownListEnumerator.Create(list : TFhirTestScriptTeardownList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptTeardownListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptTeardownListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptTeardownListEnumerator.GetCurrent : TFhirTestScriptTeardown;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptTeardownListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestScriptTeardownList }
procedure TFhirTestScriptTeardownList.AddItem(value: TFhirTestScriptTeardown);
begin
  assert(value.ClassName = 'TFhirTestScriptTeardown', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptTeardown');
  add(value);
end;

function TFhirTestScriptTeardownList.Append: TFhirTestScriptTeardown;
begin
  result := TFhirTestScriptTeardown.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptTeardownList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptTeardownList.GetEnumerator : TFhirTestScriptTeardownListEnumerator;
begin
  result := TFhirTestScriptTeardownListEnumerator.Create(self.link);
end;

function TFhirTestScriptTeardownList.Clone: TFhirTestScriptTeardownList;
begin
  result := TFhirTestScriptTeardownList(inherited Clone);
end;

function TFhirTestScriptTeardownList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptTeardownList.GetItemN(index: Integer): TFhirTestScriptTeardown;
begin
  result := TFhirTestScriptTeardown(ObjectByIndex[index]);
end;

function TFhirTestScriptTeardownList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptTeardown;
end;
function TFhirTestScriptTeardownList.IndexOf(value: TFhirTestScriptTeardown): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptTeardownList.Insert(index: Integer): TFhirTestScriptTeardown;
begin
  result := TFhirTestScriptTeardown.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptTeardownList.InsertItem(index: Integer; value: TFhirTestScriptTeardown);
begin
  assert(value is TFhirTestScriptTeardown);
  Inherited Insert(index, value);
end;

function TFhirTestScriptTeardownList.Item(index: Integer): TFhirTestScriptTeardown;
begin
  result := TFhirTestScriptTeardown(ObjectByIndex[index]);
end;

function TFhirTestScriptTeardownList.Link: TFhirTestScriptTeardownList;
begin
  result := TFhirTestScriptTeardownList(inherited Link);
end;

procedure TFhirTestScriptTeardownList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptTeardownList.SetItemByIndex(index: Integer; value: TFhirTestScriptTeardown);
begin
  assert(value is TFhirTestScriptTeardown);
  FhirTestScriptTeardowns[index] := value;
end;

procedure TFhirTestScriptTeardownList.SetItemN(index: Integer; value: TFhirTestScriptTeardown);
begin
  assert(value is TFhirTestScriptTeardown);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptTeardownAction }

constructor TFhirTestScriptTeardownAction.Create;
begin
  inherited;
end;

destructor TFhirTestScriptTeardownAction.Destroy;
begin
  FOperation.free;
  inherited;
end;

procedure TFhirTestScriptTeardownAction.Assign(oSource : TFslObject);
begin
  inherited;
  operation := TFhirTestScriptTeardownAction(oSource).operation.Clone;
end;

procedure TFhirTestScriptTeardownAction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'operation') Then
     list.add(self.link, 'operation', FOperation.Link);
end;

procedure TFhirTestScriptTeardownAction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'operation', '@TestScript.setup.action.operation', false, TFhirTestScriptSetupActionOperation, FOperation.Link));{2}
end;

function TFhirTestScriptTeardownAction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'operation') then
  begin
    Operation := propValue as TFhirTestScriptSetupActionOperation{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptTeardownAction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestScriptTeardownAction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'operation') then result := TFhirTestScriptSetupActionOperation.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptTeardownAction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'operation') then result := '@TestScript.setup.action.operation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptTeardownAction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'operation') then OperationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptTeardownAction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'operation') then OperationElement := new as TFhirTestScriptSetupActionOperation{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptTeardownAction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptTeardownAction.fhirType : string;
begin
  result := 'action';
end;

function TFhirTestScriptTeardownAction.Link : TFhirTestScriptTeardownAction;
begin
  result := TFhirTestScriptTeardownAction(inherited Link);
end;

function TFhirTestScriptTeardownAction.Clone : TFhirTestScriptTeardownAction;
begin
  result := TFhirTestScriptTeardownAction(inherited Clone);
end;

function TFhirTestScriptTeardownAction.equals(other : TObject) : boolean; 
var
  o : TFhirTestScriptTeardownAction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptTeardownAction)) then
    result := false
  else
  begin
    o := TFhirTestScriptTeardownAction(other);
    result := compareDeep(operationElement, o.operationElement, true);
  end;
end;

function TFhirTestScriptTeardownAction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FOperation);
end;

procedure TFhirTestScriptTeardownAction.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('operation');
end;

{ TFhirTestScriptTeardownAction }

Procedure TFhirTestScriptTeardownAction.SetOperation(value : TFhirTestScriptSetupActionOperation);
begin
  FOperation.free;
  FOperation := value;
end;

function TFhirTestScriptTeardownAction.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FOperation.sizeInBytes);
end;

{ TFhirTestScriptTeardownActionListEnumerator }

Constructor TFhirTestScriptTeardownActionListEnumerator.Create(list : TFhirTestScriptTeardownActionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptTeardownActionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptTeardownActionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptTeardownActionListEnumerator.GetCurrent : TFhirTestScriptTeardownAction;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptTeardownActionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestScriptTeardownActionList }
procedure TFhirTestScriptTeardownActionList.AddItem(value: TFhirTestScriptTeardownAction);
begin
  assert(value.ClassName = 'TFhirTestScriptTeardownAction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptTeardownAction');
  add(value);
end;

function TFhirTestScriptTeardownActionList.Append: TFhirTestScriptTeardownAction;
begin
  result := TFhirTestScriptTeardownAction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptTeardownActionList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptTeardownActionList.GetEnumerator : TFhirTestScriptTeardownActionListEnumerator;
begin
  result := TFhirTestScriptTeardownActionListEnumerator.Create(self.link);
end;

function TFhirTestScriptTeardownActionList.Clone: TFhirTestScriptTeardownActionList;
begin
  result := TFhirTestScriptTeardownActionList(inherited Clone);
end;

function TFhirTestScriptTeardownActionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptTeardownActionList.GetItemN(index: Integer): TFhirTestScriptTeardownAction;
begin
  result := TFhirTestScriptTeardownAction(ObjectByIndex[index]);
end;

function TFhirTestScriptTeardownActionList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptTeardownAction;
end;
function TFhirTestScriptTeardownActionList.IndexOf(value: TFhirTestScriptTeardownAction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptTeardownActionList.Insert(index: Integer): TFhirTestScriptTeardownAction;
begin
  result := TFhirTestScriptTeardownAction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptTeardownActionList.InsertItem(index: Integer; value: TFhirTestScriptTeardownAction);
begin
  assert(value is TFhirTestScriptTeardownAction);
  Inherited Insert(index, value);
end;

function TFhirTestScriptTeardownActionList.Item(index: Integer): TFhirTestScriptTeardownAction;
begin
  result := TFhirTestScriptTeardownAction(ObjectByIndex[index]);
end;

function TFhirTestScriptTeardownActionList.Link: TFhirTestScriptTeardownActionList;
begin
  result := TFhirTestScriptTeardownActionList(inherited Link);
end;

procedure TFhirTestScriptTeardownActionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptTeardownActionList.SetItemByIndex(index: Integer; value: TFhirTestScriptTeardownAction);
begin
  assert(value is TFhirTestScriptTeardownAction);
  FhirTestScriptTeardownActions[index] := value;
end;

procedure TFhirTestScriptTeardownActionList.SetItemN(index: Integer; value: TFhirTestScriptTeardownAction);
begin
  assert(value is TFhirTestScriptTeardownAction);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScript }

constructor TFhirTestScript.Create;
begin
  inherited;
end;

destructor TFhirTestScript.Destroy;
begin
  FUrl.free;
  FVersion.free;
  FName.free;
  FStatus.free;
  FIdentifier.free;
  FExperimental.free;
  FPublisher.free;
  FContactList.Free;
  FDate.free;
  FDescription.free;
  FUseContextList.Free;
  FRequirements.free;
  FCopyright.free;
  FMetadata.free;
  FMultiserver.free;
  FFixtureList.Free;
  FProfileList.Free;
  FVariableList.Free;
  FSetup.free;
  FTestList.Free;
  FTeardown.free;
  inherited;
end;

function TFhirTestScript.GetResourceType : TFhirResourceType;
begin
  result := frtTestScript;
end;

procedure TFhirTestScript.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirTestScript(oSource).urlElement.Clone;
  versionElement := TFhirTestScript(oSource).versionElement.Clone;
  nameElement := TFhirTestScript(oSource).nameElement.Clone;
  FStatus := TFhirTestScript(oSource).FStatus.Link;
  identifier := TFhirTestScript(oSource).identifier.Clone;
  experimentalElement := TFhirTestScript(oSource).experimentalElement.Clone;
  publisherElement := TFhirTestScript(oSource).publisherElement.Clone;
  if (TFhirTestScript(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirTestScriptContactList.Create;
    FContactList.Assign(TFhirTestScript(oSource).FContactList);
  end;
  dateElement := TFhirTestScript(oSource).dateElement.Clone;
  descriptionElement := TFhirTestScript(oSource).descriptionElement.Clone;
  if (TFhirTestScript(oSource).FUseContextList = nil) then
  begin
    FUseContextList.free;
    FUseContextList := nil;
  end
  else
  begin
    if FUseContextList = nil then
      FUseContextList := TFhirCodeableConceptList.Create;
    FUseContextList.Assign(TFhirTestScript(oSource).FUseContextList);
  end;
  requirementsElement := TFhirTestScript(oSource).requirementsElement.Clone;
  copyrightElement := TFhirTestScript(oSource).copyrightElement.Clone;
  metadata := TFhirTestScript(oSource).metadata.Clone;
  multiserverElement := TFhirTestScript(oSource).multiserverElement.Clone;
  if (TFhirTestScript(oSource).FFixtureList = nil) then
  begin
    FFixtureList.free;
    FFixtureList := nil;
  end
  else
  begin
    if FFixtureList = nil then
      FFixtureList := TFhirTestScriptFixtureList.Create;
    FFixtureList.Assign(TFhirTestScript(oSource).FFixtureList);
  end;
  if (TFhirTestScript(oSource).FProfileList = nil) then
  begin
    FProfileList.free;
    FProfileList := nil;
  end
  else
  begin
    if FProfileList = nil then
      FProfileList := TFhirReferenceList{TFhirReference}.Create;
    FProfileList.Assign(TFhirTestScript(oSource).FProfileList);
  end;
  if (TFhirTestScript(oSource).FVariableList = nil) then
  begin
    FVariableList.free;
    FVariableList := nil;
  end
  else
  begin
    if FVariableList = nil then
      FVariableList := TFhirTestScriptVariableList.Create;
    FVariableList.Assign(TFhirTestScript(oSource).FVariableList);
  end;
  setup := TFhirTestScript(oSource).setup.Clone;
  if (TFhirTestScript(oSource).FTestList = nil) then
  begin
    FTestList.free;
    FTestList := nil;
  end
  else
  begin
    if FTestList = nil then
      FTestList := TFhirTestScriptTestList.Create;
    FTestList.Assign(TFhirTestScript(oSource).FTestList);
  end;
  teardown := TFhirTestScript(oSource).teardown.Clone;
end;

procedure TFhirTestScript.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'experimental') Then
     list.add(self.link, 'experimental', FExperimental.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'useContext') Then
    list.addAll(self, 'useContext', FUseContextList);
  if (child_name = 'requirements') Then
     list.add(self.link, 'requirements', FRequirements.Link);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'metadata') Then
     list.add(self.link, 'metadata', FMetadata.Link);
  if (child_name = 'multiserver') Then
     list.add(self.link, 'multiserver', FMultiserver.Link);
  if (child_name = 'fixture') Then
    list.addAll(self, 'fixture', FFixtureList);
  if (child_name = 'profile') Then
    list.addAll(self, 'profile', FProfileList);
  if (child_name = 'variable') Then
    list.addAll(self, 'variable', FVariableList);
  if (child_name = 'setup') Then
     list.add(self.link, 'setup', FSetup.Link);
  if (child_name = 'test') Then
    list.addAll(self, 'test', FTestList);
  if (child_name = 'teardown') Then
     list.add(self.link, 'teardown', FTeardown.Link);
end;

procedure TFhirTestScript.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));{2}
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'experimental', 'boolean', false, TFhirBoolean, FExperimental.Link));{2}
  oList.add(TFHIRProperty.create(self, 'publisher', 'string', false, TFhirString, FPublisher.Link));{2}
  oList.add(TFHIRProperty.create(self, 'contact', '', true, TFhirTestScriptContact, FContactList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'useContext', 'CodeableConcept', true, TFhirCodeableConcept, FUseContextList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'requirements', 'string', false, TFhirString, FRequirements.Link));{2}
  oList.add(TFHIRProperty.create(self, 'copyright', 'string', false, TFhirString, FCopyright.Link));{2}
  oList.add(TFHIRProperty.create(self, 'metadata', '', false, TFhirTestScriptMetadata, FMetadata.Link));{2}
  oList.add(TFHIRProperty.create(self, 'multiserver', 'boolean', false, TFhirBoolean, FMultiserver.Link));{2}
  oList.add(TFHIRProperty.create(self, 'fixture', '', true, TFhirTestScriptFixture, FFixtureList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'profile', 'Reference(Any)', true, TFhirReference{TFhirReference}, FProfileList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'variable', '', true, TFhirTestScriptVariable, FVariableList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'setup', '', false, TFhirTestScriptSetup, FSetup.Link));{2}
  oList.add(TFHIRProperty.create(self, 'test', '', true, TFhirTestScriptTest, FTestList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'teardown', '', false, TFhirTestScriptTeardown, FTeardown.Link));{2}
end;

function TFhirTestScript.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirConformanceResourceStatusEnum, CODES_TFhirConformanceResourceStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'experimental') then
  begin
    ExperimentalElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    PublisherElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirTestScriptContact){2a};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'useContext') then
  begin
    UseContextList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'requirements') then
  begin
    RequirementsElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'metadata') then
  begin
    Metadata := propValue as TFhirTestScriptMetadata{4b};
    result := propValue;
  end
  else if (propName = 'multiserver') then
  begin
    MultiserverElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'fixture') then
  begin
    FixtureList.add(propValue as TFhirTestScriptFixture){2a};
    result := propValue;
  end
  else if (propName = 'profile') then
  begin
    ProfileList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'variable') then
  begin
    VariableList.add(propValue as TFhirTestScriptVariable){2a};
    result := propValue;
  end
  else if (propName = 'setup') then
  begin
    Setup := propValue as TFhirTestScriptSetup{4b};
    result := propValue;
  end
  else if (propName = 'test') then
  begin
    TestList.add(propValue as TFhirTestScriptTest){2a};
    result := propValue;
  end
  else if (propName = 'teardown') then
  begin
    Teardown := propValue as TFhirTestScriptTeardown{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirTestScript.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirTestScriptContact){2a}
  else if (propName = 'useContext') then UseContextList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'fixture') then FixtureList.insertItem(index, propValue as TFhirTestScriptFixture){2a}
  else if (propName = 'profile') then ProfileList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'variable') then VariableList.insertItem(index, propValue as TFhirTestScriptVariable){2a}
  else if (propName = 'test') then TestList.insertItem(index, propValue as TFhirTestScriptTest){2a}
  else inherited;
end;

function TFhirTestScript.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create() {5b}
  else if (propName = 'version') then result := TFhirString.create() {5b}
  else if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'experimental') then result := TFhirBoolean.create() {5b}
  else if (propName = 'publisher') then result := TFhirString.create() {5b}
  else if (propName = 'contact') then result := ContactList.new(){2}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'useContext') then result := UseContextList.new(){2}
  else if (propName = 'requirements') then result := TFhirString.create() {5b}
  else if (propName = 'copyright') then result := TFhirString.create() {5b}
  else if (propName = 'metadata') then result := TFhirTestScriptMetadata.create(){4b}
  else if (propName = 'multiserver') then result := TFhirBoolean.create() {5b}
  else if (propName = 'fixture') then result := FixtureList.new(){2}
  else if (propName = 'profile') then result := ProfileList.new(){2}
  else if (propName = 'variable') then result := VariableList.new(){2}
  else if (propName = 'setup') then result := TFhirTestScriptSetup.create(){4b}
  else if (propName = 'test') then result := TestList.new(){2}
  else if (propName = 'teardown') then result := TFhirTestScriptTeardown.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScript.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'uri'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'experimental') then result := 'boolean'
  else if (propName = 'publisher') then result := 'string'
  else if (propName = 'contact') then result := ''
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'useContext') then result := 'CodeableConcept'
  else if (propName = 'requirements') then result := 'string'
  else if (propName = 'copyright') then result := 'string'
  else if (propName = 'metadata') then result := ''
  else if (propName = 'multiserver') then result := 'boolean'
  else if (propName = 'fixture') then result := ''
  else if (propName = 'profile') then result := 'Reference'
  else if (propName = 'variable') then result := ''
  else if (propName = 'setup') then result := ''
  else if (propName = 'test') then result := ''
  else if (propName = 'teardown') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScript.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'experimental') then ExperimentalElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value) {2}
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'useContext') then deletePropertyValue('useContext', UseContextList, value) {2}
  else if (propName = 'requirements') then RequirementsElement := nil
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'metadata') then MetadataElement := nil
  else if (propName = 'multiserver') then MultiserverElement := nil
  else if (propName = 'fixture') then deletePropertyValue('fixture', FixtureList, value) {2}
  else if (propName = 'profile') then deletePropertyValue('profile', ProfileList, value) {2}
  else if (propName = 'variable') then deletePropertyValue('variable', VariableList, value) {2}
  else if (propName = 'setup') then SetupElement := nil
  else if (propName = 'test') then deletePropertyValue('test', TestList, value) {2}
  else if (propName = 'teardown') then TeardownElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScript.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asUri(new){5b}
  else if (propName = 'version') then VersionElement := asString(new){5b}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirConformanceResourceStatusEnum, CODES_TFhirConformanceResourceStatusEnum, new){4}
  else if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'experimental') then ExperimentalElement := asBoolean(new){5b}
  else if (propName = 'publisher') then PublisherElement := asString(new){5b}
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new) {2}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'useContext') then replacePropertyValue('useContext', UseContextList, existing, new) {2}
  else if (propName = 'requirements') then RequirementsElement := asString(new){5b}
  else if (propName = 'copyright') then CopyrightElement := asString(new){5b}
  else if (propName = 'metadata') then MetadataElement := new as TFhirTestScriptMetadata{4}
  else if (propName = 'multiserver') then MultiserverElement := asBoolean(new){5b}
  else if (propName = 'fixture') then replacePropertyValue('fixture', FixtureList, existing, new) {2}
  else if (propName = 'profile') then replacePropertyValue('profile', ProfileList, existing, new) {2}
  else if (propName = 'variable') then replacePropertyValue('variable', VariableList, existing, new) {2}
  else if (propName = 'setup') then SetupElement := new as TFhirTestScriptSetup{4}
  else if (propName = 'test') then replacePropertyValue('test', TestList, existing, new) {2}
  else if (propName = 'teardown') then TeardownElement := new as TFhirTestScriptTeardown{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScript.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'contact') then ContactList.move(source, destination){2a}
  else if (propName = 'useContext') then UseContextList.move(source, destination){2a}
  else if (propName = 'fixture') then FixtureList.move(source, destination){2a}
  else if (propName = 'profile') then ProfileList.move(source, destination){2a}
  else if (propName = 'variable') then VariableList.move(source, destination){2a}
  else if (propName = 'test') then TestList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScript.fhirType : string;
begin
  result := 'TestScript';
end;

function TFhirTestScript.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FVersion) and isEmptyProp(FName) and isEmptyProp(FStatus) and isEmptyProp(FIdentifier) and isEmptyProp(FExperimental) and isEmptyProp(FPublisher) and isEmptyProp(FcontactList) and isEmptyProp(FDate) and isEmptyProp(FDescription) and isEmptyProp(FuseContextList) and isEmptyProp(FRequirements) and isEmptyProp(FCopyright) and isEmptyProp(FMetadata) and isEmptyProp(FMultiserver) and isEmptyProp(FfixtureList) and isEmptyProp(FprofileList) and isEmptyProp(FvariableList) and isEmptyProp(FSetup) and isEmptyProp(FtestList) and isEmptyProp(FTeardown);
end;

function TFhirTestScript.equals(other : TObject) : boolean; 
var
  o : TFhirTestScript;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScript)) then
    result := false
  else
  begin
    o := TFhirTestScript(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(versionElement, o.versionElement, true) and 
      compareDeep(nameElement, o.nameElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(identifierElement, o.identifierElement, true) and compareDeep(experimentalElement, o.experimentalElement, true) and 
      compareDeep(publisherElement, o.publisherElement, true) and compareDeep(contactList, o.contactList, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(useContextList, o.useContextList, true) and compareDeep(requirementsElement, o.requirementsElement, true) and 
      compareDeep(copyrightElement, o.copyrightElement, true) and compareDeep(metadataElement, o.metadataElement, true) and 
      compareDeep(multiserverElement, o.multiserverElement, true) and compareDeep(fixtureList, o.fixtureList, true) and 
      compareDeep(profileList, o.profileList, true) and compareDeep(variableList, o.variableList, true) and 
      compareDeep(setupElement, o.setupElement, true) and compareDeep(testList, o.testList, true) and 
      compareDeep(teardownElement, o.teardownElement, true);
  end;
end;

function TFhirTestScript.Link : TFhirTestScript;
begin
  result := TFhirTestScript(inherited Link);
end;

function TFhirTestScript.Clone : TFhirTestScript;
begin
  result := TFhirTestScript(inherited Clone);
end;

procedure TFhirTestScript.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('url');
  fields.add('version');
  fields.add('name');
  fields.add('status');
  fields.add('identifier');
  fields.add('experimental');
  fields.add('publisher');
  fields.add('contact');
  fields.add('date');
  fields.add('description');
  fields.add('useContext');
  fields.add('requirements');
  fields.add('copyright');
  fields.add('metadata');
  fields.add('multiserver');
  fields.add('fixture');
  fields.add('profile');
  fields.add('variable');
  fields.add('setup');
  fields.add('test');
  fields.add('teardown');
end;

{ TFhirTestScript }

Procedure TFhirTestScript.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirTestScript.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

Procedure TFhirTestScript.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

Procedure TFhirTestScript.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

Function TFhirTestScript.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

Procedure TFhirTestScript.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

Procedure TFhirTestScript.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirTestScript.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirTestScript.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirTestScript.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirTestScript.GetStatusST : TFhirConformanceResourceStatusEnum;
begin
  if FStatus = nil then
    result := TFhirConformanceResourceStatusEnum(0)
  else
    result := TFhirConformanceResourceStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirConformanceResourceStatusEnum, FStatus.value));
end;

Procedure TFhirTestScript.SetStatusST(value : TFhirConformanceResourceStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirConformanceResourceStatusEnum[value], CODES_TFhirConformanceResourceStatusEnum[value]);
end;

Procedure TFhirTestScript.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirTestScript.SetExperimental(value : TFhirBoolean);
begin
  FExperimental.free;
  FExperimental := value;
end;

Function TFhirTestScript.GetExperimentalST : Boolean;
begin
  if FExperimental = nil then
    result := false
  else
    result := FExperimental.value;
end;

Procedure TFhirTestScript.SetExperimentalST(value : Boolean);
begin
  if FExperimental = nil then
    FExperimental := TFhirBoolean.create;
  FExperimental.value := value
end;

Procedure TFhirTestScript.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

Function TFhirTestScript.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

Procedure TFhirTestScript.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

Function TFhirTestScript.GetContactList : TFhirTestScriptContactList;
begin
  if FContactList = nil then
    FContactList := TFhirTestScriptContactList.Create;
  result := FContactList;
end;

Function TFhirTestScript.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

Procedure TFhirTestScript.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirTestScript.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirTestScript.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirTestScript.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirTestScript.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirTestScript.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Function TFhirTestScript.GetUseContextList : TFhirCodeableConceptList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirCodeableConceptList.Create;
  result := FUseContextList;
end;

Function TFhirTestScript.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

Procedure TFhirTestScript.SetRequirements(value : TFhirString);
begin
  FRequirements.free;
  FRequirements := value;
end;

Function TFhirTestScript.GetRequirementsST : String;
begin
  if FRequirements = nil then
    result := ''
  else
    result := FRequirements.value;
end;

Procedure TFhirTestScript.SetRequirementsST(value : String);
begin
  if value <> '' then
  begin
    if FRequirements = nil then
      FRequirements := TFhirString.create;
    FRequirements.value := value
  end
  else if FRequirements <> nil then
    FRequirements.value := '';
end;

Procedure TFhirTestScript.SetCopyright(value : TFhirString);
begin
  FCopyright.free;
  FCopyright := value;
end;

Function TFhirTestScript.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

Procedure TFhirTestScript.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirString.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

Procedure TFhirTestScript.SetMetadata(value : TFhirTestScriptMetadata);
begin
  FMetadata.free;
  FMetadata := value;
end;

Procedure TFhirTestScript.SetMultiserver(value : TFhirBoolean);
begin
  FMultiserver.free;
  FMultiserver := value;
end;

Function TFhirTestScript.GetMultiserverST : Boolean;
begin
  if FMultiserver = nil then
    result := false
  else
    result := FMultiserver.value;
end;

Procedure TFhirTestScript.SetMultiserverST(value : Boolean);
begin
  if FMultiserver = nil then
    FMultiserver := TFhirBoolean.create;
  FMultiserver.value := value
end;

Function TFhirTestScript.GetFixtureList : TFhirTestScriptFixtureList;
begin
  if FFixtureList = nil then
    FFixtureList := TFhirTestScriptFixtureList.Create;
  result := FFixtureList;
end;

Function TFhirTestScript.GetHasFixtureList : boolean;
begin
  result := (FFixtureList <> nil) and (FFixtureList.count > 0);
end;

Function TFhirTestScript.GetProfileList : TFhirReferenceList{TFhirReference};
begin
  if FProfileList = nil then
    FProfileList := TFhirReferenceList{TFhirReference}.Create;
  result := FProfileList;
end;

Function TFhirTestScript.GetHasProfileList : boolean;
begin
  result := (FProfileList <> nil) and (FProfileList.count > 0);
end;

Function TFhirTestScript.GetVariableList : TFhirTestScriptVariableList;
begin
  if FVariableList = nil then
    FVariableList := TFhirTestScriptVariableList.Create;
  result := FVariableList;
end;

Function TFhirTestScript.GetHasVariableList : boolean;
begin
  result := (FVariableList <> nil) and (FVariableList.count > 0);
end;

Procedure TFhirTestScript.SetSetup(value : TFhirTestScriptSetup);
begin
  FSetup.free;
  FSetup := value;
end;

Function TFhirTestScript.GetTestList : TFhirTestScriptTestList;
begin
  if FTestList = nil then
    FTestList := TFhirTestScriptTestList.Create;
  result := FTestList;
end;

Function TFhirTestScript.GetHasTestList : boolean;
begin
  result := (FTestList <> nil) and (FTestList.count > 0);
end;

Procedure TFhirTestScript.SetTeardown(value : TFhirTestScriptTeardown);
begin
  FTeardown.free;
  FTeardown := value;
end;

function TFhirTestScript.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FUrl.sizeInBytes);
  inc(result, FVersion.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FExperimental.sizeInBytes);
  inc(result, FPublisher.sizeInBytes);
  inc(result, FcontactList.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FuseContextList.sizeInBytes);
  inc(result, FRequirements.sizeInBytes);
  inc(result, FCopyright.sizeInBytes);
  inc(result, FMetadata.sizeInBytes);
  inc(result, FMultiserver.sizeInBytes);
  inc(result, FfixtureList.sizeInBytes);
  inc(result, FprofileList.sizeInBytes);
  inc(result, FvariableList.sizeInBytes);
  inc(result, FSetup.sizeInBytes);
  inc(result, FtestList.sizeInBytes);
  inc(result, FTeardown.sizeInBytes);
end;

{ TFhirTestScriptListEnumerator }

Constructor TFhirTestScriptListEnumerator.Create(list : TFhirTestScriptList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptListEnumerator.GetCurrent : TFhirTestScript;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestScriptList }
procedure TFhirTestScriptList.AddItem(value: TFhirTestScript);
begin
  assert(value.ClassName = 'TFhirTestScript', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScript');
  add(value);
end;

function TFhirTestScriptList.Append: TFhirTestScript;
begin
  result := TFhirTestScript.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptList.GetEnumerator : TFhirTestScriptListEnumerator;
begin
  result := TFhirTestScriptListEnumerator.Create(self.link);
end;

function TFhirTestScriptList.Clone: TFhirTestScriptList;
begin
  result := TFhirTestScriptList(inherited Clone);
end;

function TFhirTestScriptList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptList.GetItemN(index: Integer): TFhirTestScript;
begin
  result := TFhirTestScript(ObjectByIndex[index]);
end;

function TFhirTestScriptList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScript;
end;
function TFhirTestScriptList.IndexOf(value: TFhirTestScript): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptList.Insert(index: Integer): TFhirTestScript;
begin
  result := TFhirTestScript.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptList.InsertItem(index: Integer; value: TFhirTestScript);
begin
  assert(value is TFhirTestScript);
  Inherited Insert(index, value);
end;

function TFhirTestScriptList.Item(index: Integer): TFhirTestScript;
begin
  result := TFhirTestScript(ObjectByIndex[index]);
end;

function TFhirTestScriptList.Link: TFhirTestScriptList;
begin
  result := TFhirTestScriptList(inherited Link);
end;

procedure TFhirTestScriptList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptList.SetItemByIndex(index: Integer; value: TFhirTestScript);
begin
  assert(value is TFhirTestScript);
  FhirTestScripts[index] := value;
end;

procedure TFhirTestScriptList.SetItemN(index: Integer; value: TFhirTestScript);
begin
  assert(value is TFhirTestScript);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_TESTSCRIPT}

{$IFDEF FHIR_VALUESET}

{ TFhirValueSetContact }

constructor TFhirValueSetContact.Create;
begin
  inherited;
end;

destructor TFhirValueSetContact.Destroy;
begin
  FName.free;
  FTelecomList.Free;
  inherited;
end;

procedure TFhirValueSetContact.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirValueSetContact(oSource).nameElement.Clone;
  if (TFhirValueSetContact(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirValueSetContact(oSource).FTelecomList);
  end;
end;

procedure TFhirValueSetContact.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
end;

procedure TFhirValueSetContact.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link)){3};
end;

function TFhirValueSetContact.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirValueSetContact.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint){2a}
  else inherited;
end;

function TFhirValueSetContact.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'telecom') then result := TelecomList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirValueSetContact.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirValueSetContact.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirValueSetContact.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirValueSetContact.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'telecom') then TelecomList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirValueSetContact.fhirType : string;
begin
  result := 'contact';
end;

function TFhirValueSetContact.Link : TFhirValueSetContact;
begin
  result := TFhirValueSetContact(inherited Link);
end;

function TFhirValueSetContact.Clone : TFhirValueSetContact;
begin
  result := TFhirValueSetContact(inherited Clone);
end;

function TFhirValueSetContact.equals(other : TObject) : boolean; 
var
  o : TFhirValueSetContact;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirValueSetContact)) then
    result := false
  else
  begin
    o := TFhirValueSetContact(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(telecomList, o.telecomList, true);
  end;
end;

function TFhirValueSetContact.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FtelecomList);
end;

procedure TFhirValueSetContact.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('telecom');
end;

{ TFhirValueSetContact }

Procedure TFhirValueSetContact.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirValueSetContact.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirValueSetContact.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Function TFhirValueSetContact.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

Function TFhirValueSetContact.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

function TFhirValueSetContact.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FtelecomList.sizeInBytes);
end;

{ TFhirValueSetContactListEnumerator }

Constructor TFhirValueSetContactListEnumerator.Create(list : TFhirValueSetContactList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirValueSetContactListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirValueSetContactListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirValueSetContactListEnumerator.GetCurrent : TFhirValueSetContact;
begin
  Result := FList[FIndex];
end;

function TFhirValueSetContactListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirValueSetContactList }
procedure TFhirValueSetContactList.AddItem(value: TFhirValueSetContact);
begin
  assert(value.ClassName = 'TFhirValueSetContact', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetContact');
  add(value);
end;

function TFhirValueSetContactList.Append: TFhirValueSetContact;
begin
  result := TFhirValueSetContact.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetContactList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetContactList.GetEnumerator : TFhirValueSetContactListEnumerator;
begin
  result := TFhirValueSetContactListEnumerator.Create(self.link);
end;

function TFhirValueSetContactList.Clone: TFhirValueSetContactList;
begin
  result := TFhirValueSetContactList(inherited Clone);
end;

function TFhirValueSetContactList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetContactList.GetItemN(index: Integer): TFhirValueSetContact;
begin
  result := TFhirValueSetContact(ObjectByIndex[index]);
end;

function TFhirValueSetContactList.ItemClass: TFslObjectClass;
begin
  result := TFhirValueSetContact;
end;
function TFhirValueSetContactList.IndexOf(value: TFhirValueSetContact): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirValueSetContactList.Insert(index: Integer): TFhirValueSetContact;
begin
  result := TFhirValueSetContact.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetContactList.InsertItem(index: Integer; value: TFhirValueSetContact);
begin
  assert(value is TFhirValueSetContact);
  Inherited Insert(index, value);
end;

function TFhirValueSetContactList.Item(index: Integer): TFhirValueSetContact;
begin
  result := TFhirValueSetContact(ObjectByIndex[index]);
end;

function TFhirValueSetContactList.Link: TFhirValueSetContactList;
begin
  result := TFhirValueSetContactList(inherited Link);
end;

procedure TFhirValueSetContactList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetContactList.SetItemByIndex(index: Integer; value: TFhirValueSetContact);
begin
  assert(value is TFhirValueSetContact);
  FhirValueSetContacts[index] := value;
end;

procedure TFhirValueSetContactList.SetItemN(index: Integer; value: TFhirValueSetContact);
begin
  assert(value is TFhirValueSetContact);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetCodeSystem }

constructor TFhirValueSetCodeSystem.Create;
begin
  inherited;
end;

destructor TFhirValueSetCodeSystem.Destroy;
begin
  FSystem.free;
  FVersion.free;
  FCaseSensitive.free;
  FConceptList.Free;
  inherited;
end;

procedure TFhirValueSetCodeSystem.Assign(oSource : TFslObject);
begin
  inherited;
  systemElement := TFhirValueSetCodeSystem(oSource).systemElement.Clone;
  versionElement := TFhirValueSetCodeSystem(oSource).versionElement.Clone;
  caseSensitiveElement := TFhirValueSetCodeSystem(oSource).caseSensitiveElement.Clone;
  if (TFhirValueSetCodeSystem(oSource).FConceptList = nil) then
  begin
    FConceptList.free;
    FConceptList := nil;
  end
  else
  begin
    if FConceptList = nil then
      FConceptList := TFhirValueSetCodeSystemConceptList.Create;
    FConceptList.Assign(TFhirValueSetCodeSystem(oSource).FConceptList);
  end;
end;

procedure TFhirValueSetCodeSystem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'system') Then
     list.add(self.link, 'system', FSystem.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'caseSensitive') Then
     list.add(self.link, 'caseSensitive', FCaseSensitive.Link);
  if (child_name = 'concept') Then
    list.addAll(self, 'concept', FConceptList);
end;

procedure TFhirValueSetCodeSystem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'system', 'uri', false, TFhirUri, FSystem.Link));{2}
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));{2}
  oList.add(TFHIRProperty.create(self, 'caseSensitive', 'boolean', false, TFhirBoolean, FCaseSensitive.Link));{2}
  oList.add(TFHIRProperty.create(self, 'concept', '', true, TFhirValueSetCodeSystemConcept, FConceptList.Link)){3};
end;

function TFhirValueSetCodeSystem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'system') then
  begin
    SystemElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'caseSensitive') then
  begin
    CaseSensitiveElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'concept') then
  begin
    ConceptList.add(propValue as TFhirValueSetCodeSystemConcept){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirValueSetCodeSystem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'concept') then ConceptList.insertItem(index, propValue as TFhirValueSetCodeSystemConcept){2a}
  else inherited;
end;

function TFhirValueSetCodeSystem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'system') then result := TFhirUri.create() {5b}
  else if (propName = 'version') then result := TFhirString.create() {5b}
  else if (propName = 'caseSensitive') then result := TFhirBoolean.create() {5b}
  else if (propName = 'concept') then result := ConceptList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirValueSetCodeSystem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'system') then result := 'uri'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'caseSensitive') then result := 'boolean'
  else if (propName = 'concept') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirValueSetCodeSystem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'system') then SystemElement := nil
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'caseSensitive') then CaseSensitiveElement := nil
  else if (propName = 'concept') then deletePropertyValue('concept', ConceptList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirValueSetCodeSystem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'system') then SystemElement := asUri(new){5b}
  else if (propName = 'version') then VersionElement := asString(new){5b}
  else if (propName = 'caseSensitive') then CaseSensitiveElement := asBoolean(new){5b}
  else if (propName = 'concept') then replacePropertyValue('concept', ConceptList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirValueSetCodeSystem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'concept') then ConceptList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirValueSetCodeSystem.fhirType : string;
begin
  result := 'codeSystem';
end;

function TFhirValueSetCodeSystem.Link : TFhirValueSetCodeSystem;
begin
  result := TFhirValueSetCodeSystem(inherited Link);
end;

function TFhirValueSetCodeSystem.Clone : TFhirValueSetCodeSystem;
begin
  result := TFhirValueSetCodeSystem(inherited Clone);
end;

function TFhirValueSetCodeSystem.equals(other : TObject) : boolean; 
var
  o : TFhirValueSetCodeSystem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirValueSetCodeSystem)) then
    result := false
  else
  begin
    o := TFhirValueSetCodeSystem(other);
    result := compareDeep(systemElement, o.systemElement, true) and compareDeep(versionElement, o.versionElement, true) and 
      compareDeep(caseSensitiveElement, o.caseSensitiveElement, true) and compareDeep(conceptList, o.conceptList, true);
  end;
end;

function TFhirValueSetCodeSystem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSystem) and isEmptyProp(FVersion) and isEmptyProp(FCaseSensitive) and isEmptyProp(FconceptList);
end;

procedure TFhirValueSetCodeSystem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('system');
  fields.add('version');
  fields.add('caseSensitive');
  fields.add('concept');
end;

{ TFhirValueSetCodeSystem }

Procedure TFhirValueSetCodeSystem.SetSystem(value : TFhirUri);
begin
  FSystem.free;
  FSystem := value;
end;

Function TFhirValueSetCodeSystem.GetSystemST : String;
begin
  if FSystem = nil then
    result := ''
  else
    result := FSystem.value;
end;

Procedure TFhirValueSetCodeSystem.SetSystemST(value : String);
begin
  if value <> '' then
  begin
    if FSystem = nil then
      FSystem := TFhirUri.create;
    FSystem.value := value
  end
  else if FSystem <> nil then
    FSystem.value := '';
end;

Procedure TFhirValueSetCodeSystem.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

Function TFhirValueSetCodeSystem.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

Procedure TFhirValueSetCodeSystem.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

Procedure TFhirValueSetCodeSystem.SetCaseSensitive(value : TFhirBoolean);
begin
  FCaseSensitive.free;
  FCaseSensitive := value;
end;

Function TFhirValueSetCodeSystem.GetCaseSensitiveST : Boolean;
begin
  if FCaseSensitive = nil then
    result := false
  else
    result := FCaseSensitive.value;
end;

Procedure TFhirValueSetCodeSystem.SetCaseSensitiveST(value : Boolean);
begin
  if FCaseSensitive = nil then
    FCaseSensitive := TFhirBoolean.create;
  FCaseSensitive.value := value
end;

Function TFhirValueSetCodeSystem.GetConceptList : TFhirValueSetCodeSystemConceptList;
begin
  if FConceptList = nil then
    FConceptList := TFhirValueSetCodeSystemConceptList.Create;
  result := FConceptList;
end;

Function TFhirValueSetCodeSystem.GetHasConceptList : boolean;
begin
  result := (FConceptList <> nil) and (FConceptList.count > 0);
end;

function TFhirValueSetCodeSystem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSystem.sizeInBytes);
  inc(result, FVersion.sizeInBytes);
  inc(result, FCaseSensitive.sizeInBytes);
  inc(result, FconceptList.sizeInBytes);
end;

{ TFhirValueSetCodeSystemListEnumerator }

Constructor TFhirValueSetCodeSystemListEnumerator.Create(list : TFhirValueSetCodeSystemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirValueSetCodeSystemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirValueSetCodeSystemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirValueSetCodeSystemListEnumerator.GetCurrent : TFhirValueSetCodeSystem;
begin
  Result := FList[FIndex];
end;

function TFhirValueSetCodeSystemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirValueSetCodeSystemList }
procedure TFhirValueSetCodeSystemList.AddItem(value: TFhirValueSetCodeSystem);
begin
  assert(value.ClassName = 'TFhirValueSetCodeSystem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetCodeSystem');
  add(value);
end;

function TFhirValueSetCodeSystemList.Append: TFhirValueSetCodeSystem;
begin
  result := TFhirValueSetCodeSystem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetCodeSystemList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetCodeSystemList.GetEnumerator : TFhirValueSetCodeSystemListEnumerator;
begin
  result := TFhirValueSetCodeSystemListEnumerator.Create(self.link);
end;

function TFhirValueSetCodeSystemList.Clone: TFhirValueSetCodeSystemList;
begin
  result := TFhirValueSetCodeSystemList(inherited Clone);
end;

function TFhirValueSetCodeSystemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetCodeSystemList.GetItemN(index: Integer): TFhirValueSetCodeSystem;
begin
  result := TFhirValueSetCodeSystem(ObjectByIndex[index]);
end;

function TFhirValueSetCodeSystemList.ItemClass: TFslObjectClass;
begin
  result := TFhirValueSetCodeSystem;
end;
function TFhirValueSetCodeSystemList.IndexOf(value: TFhirValueSetCodeSystem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirValueSetCodeSystemList.Insert(index: Integer): TFhirValueSetCodeSystem;
begin
  result := TFhirValueSetCodeSystem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetCodeSystemList.InsertItem(index: Integer; value: TFhirValueSetCodeSystem);
begin
  assert(value is TFhirValueSetCodeSystem);
  Inherited Insert(index, value);
end;

function TFhirValueSetCodeSystemList.Item(index: Integer): TFhirValueSetCodeSystem;
begin
  result := TFhirValueSetCodeSystem(ObjectByIndex[index]);
end;

function TFhirValueSetCodeSystemList.Link: TFhirValueSetCodeSystemList;
begin
  result := TFhirValueSetCodeSystemList(inherited Link);
end;

procedure TFhirValueSetCodeSystemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetCodeSystemList.SetItemByIndex(index: Integer; value: TFhirValueSetCodeSystem);
begin
  assert(value is TFhirValueSetCodeSystem);
  FhirValueSetCodeSystems[index] := value;
end;

procedure TFhirValueSetCodeSystemList.SetItemN(index: Integer; value: TFhirValueSetCodeSystem);
begin
  assert(value is TFhirValueSetCodeSystem);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetCodeSystemConcept }

constructor TFhirValueSetCodeSystemConcept.Create;
begin
  inherited;
end;

destructor TFhirValueSetCodeSystemConcept.Destroy;
begin
  FCode.free;
  FAbstract.free;
  FDisplay.free;
  FDefinition.free;
  FDesignationList.Free;
  FConceptList.Free;
  inherited;
end;

procedure TFhirValueSetCodeSystemConcept.Assign(oSource : TFslObject);
begin
  inherited;
  codeElement := TFhirValueSetCodeSystemConcept(oSource).codeElement.Clone;
  abstractElement := TFhirValueSetCodeSystemConcept(oSource).abstractElement.Clone;
  displayElement := TFhirValueSetCodeSystemConcept(oSource).displayElement.Clone;
  definitionElement := TFhirValueSetCodeSystemConcept(oSource).definitionElement.Clone;
  if (TFhirValueSetCodeSystemConcept(oSource).FDesignationList = nil) then
  begin
    FDesignationList.free;
    FDesignationList := nil;
  end
  else
  begin
    if FDesignationList = nil then
      FDesignationList := TFhirValueSetCodeSystemConceptDesignationList.Create;
    FDesignationList.Assign(TFhirValueSetCodeSystemConcept(oSource).FDesignationList);
  end;
  if (TFhirValueSetCodeSystemConcept(oSource).FConceptList = nil) then
  begin
    FConceptList.free;
    FConceptList := nil;
  end
  else
  begin
    if FConceptList = nil then
      FConceptList := TFhirValueSetCodeSystemConceptList.Create;
    FConceptList.Assign(TFhirValueSetCodeSystemConcept(oSource).FConceptList);
  end;
end;

procedure TFhirValueSetCodeSystemConcept.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'abstract') Then
     list.add(self.link, 'abstract', FAbstract.Link);
  if (child_name = 'display') Then
     list.add(self.link, 'display', FDisplay.Link);
  if (child_name = 'definition') Then
     list.add(self.link, 'definition', FDefinition.Link);
  if (child_name = 'designation') Then
    list.addAll(self, 'designation', FDesignationList);
  if (child_name = 'concept') Then
    list.addAll(self, 'concept', FConceptList);
end;

procedure TFhirValueSetCodeSystemConcept.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirCode, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'abstract', 'boolean', false, TFhirBoolean, FAbstract.Link));{2}
  oList.add(TFHIRProperty.create(self, 'display', 'string', false, TFhirString, FDisplay.Link));{2}
  oList.add(TFHIRProperty.create(self, 'definition', 'string', false, TFhirString, FDefinition.Link));{2}
  oList.add(TFHIRProperty.create(self, 'designation', '', true, TFhirValueSetCodeSystemConceptDesignation, FDesignationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'concept', '@ValueSet.codeSystem.concept', true, TFhirValueSetCodeSystemConcept, FConceptList.Link)){3};
end;

function TFhirValueSetCodeSystemConcept.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'abstract') then
  begin
    AbstractElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'display') then
  begin
    DisplayElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'definition') then
  begin
    DefinitionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'designation') then
  begin
    DesignationList.add(propValue as TFhirValueSetCodeSystemConceptDesignation){2a};
    result := propValue;
  end
  else if (propName = 'concept') then
  begin
    ConceptList.add(propValue as TFhirValueSetCodeSystemConcept){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirValueSetCodeSystemConcept.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'designation') then DesignationList.insertItem(index, propValue as TFhirValueSetCodeSystemConceptDesignation){2a}
  else if (propName = 'concept') then ConceptList.insertItem(index, propValue as TFhirValueSetCodeSystemConcept){2a}
  else inherited;
end;

function TFhirValueSetCodeSystemConcept.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCode.create() {5b}
  else if (propName = 'abstract') then result := TFhirBoolean.create() {5b}
  else if (propName = 'display') then result := TFhirString.create() {5b}
  else if (propName = 'definition') then result := TFhirString.create() {5b}
  else if (propName = 'designation') then result := DesignationList.new(){2}
  else if (propName = 'concept') then result := ConceptList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirValueSetCodeSystemConcept.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'code'
  else if (propName = 'abstract') then result := 'boolean'
  else if (propName = 'display') then result := 'string'
  else if (propName = 'definition') then result := 'string'
  else if (propName = 'designation') then result := ''
  else if (propName = 'concept') then result := '@ValueSet.codeSystem.concept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirValueSetCodeSystemConcept.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'abstract') then AbstractElement := nil
  else if (propName = 'display') then DisplayElement := nil
  else if (propName = 'definition') then DefinitionElement := nil
  else if (propName = 'designation') then deletePropertyValue('designation', DesignationList, value) {2}
  else if (propName = 'concept') then deletePropertyValue('concept', ConceptList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirValueSetCodeSystemConcept.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := asCode(new){5b}
  else if (propName = 'abstract') then AbstractElement := asBoolean(new){5b}
  else if (propName = 'display') then DisplayElement := asString(new){5b}
  else if (propName = 'definition') then DefinitionElement := asString(new){5b}
  else if (propName = 'designation') then replacePropertyValue('designation', DesignationList, existing, new) {2}
  else if (propName = 'concept') then replacePropertyValue('concept', ConceptList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirValueSetCodeSystemConcept.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'designation') then DesignationList.move(source, destination){2a}
  else if (propName = 'concept') then ConceptList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirValueSetCodeSystemConcept.fhirType : string;
begin
  result := 'concept';
end;

function TFhirValueSetCodeSystemConcept.Link : TFhirValueSetCodeSystemConcept;
begin
  result := TFhirValueSetCodeSystemConcept(inherited Link);
end;

function TFhirValueSetCodeSystemConcept.Clone : TFhirValueSetCodeSystemConcept;
begin
  result := TFhirValueSetCodeSystemConcept(inherited Clone);
end;

function TFhirValueSetCodeSystemConcept.equals(other : TObject) : boolean; 
var
  o : TFhirValueSetCodeSystemConcept;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirValueSetCodeSystemConcept)) then
    result := false
  else
  begin
    o := TFhirValueSetCodeSystemConcept(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(abstractElement, o.abstractElement, true) and 
      compareDeep(displayElement, o.displayElement, true) and compareDeep(definitionElement, o.definitionElement, true) and 
      compareDeep(designationList, o.designationList, true) and compareDeep(conceptList, o.conceptList, true);
  end;
end;

function TFhirValueSetCodeSystemConcept.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FAbstract) and isEmptyProp(FDisplay) and isEmptyProp(FDefinition) and isEmptyProp(FdesignationList) and isEmptyProp(FconceptList);
end;

procedure TFhirValueSetCodeSystemConcept.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('abstract');
  fields.add('display');
  fields.add('definition');
  fields.add('designation');
  fields.add('concept');
end;

{ TFhirValueSetCodeSystemConcept }

Procedure TFhirValueSetCodeSystemConcept.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirValueSetCodeSystemConcept.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

Procedure TFhirValueSetCodeSystemConcept.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

Procedure TFhirValueSetCodeSystemConcept.SetAbstract(value : TFhirBoolean);
begin
  FAbstract.free;
  FAbstract := value;
end;

Function TFhirValueSetCodeSystemConcept.GetAbstractST : Boolean;
begin
  if FAbstract = nil then
    result := false
  else
    result := FAbstract.value;
end;

Procedure TFhirValueSetCodeSystemConcept.SetAbstractST(value : Boolean);
begin
  if FAbstract = nil then
    FAbstract := TFhirBoolean.create;
  FAbstract.value := value
end;

Procedure TFhirValueSetCodeSystemConcept.SetDisplay(value : TFhirString);
begin
  FDisplay.free;
  FDisplay := value;
end;

Function TFhirValueSetCodeSystemConcept.GetDisplayST : String;
begin
  if FDisplay = nil then
    result := ''
  else
    result := FDisplay.value;
end;

Procedure TFhirValueSetCodeSystemConcept.SetDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FDisplay = nil then
      FDisplay := TFhirString.create;
    FDisplay.value := value
  end
  else if FDisplay <> nil then
    FDisplay.value := '';
end;

Procedure TFhirValueSetCodeSystemConcept.SetDefinition(value : TFhirString);
begin
  FDefinition.free;
  FDefinition := value;
end;

Function TFhirValueSetCodeSystemConcept.GetDefinitionST : String;
begin
  if FDefinition = nil then
    result := ''
  else
    result := FDefinition.value;
end;

Procedure TFhirValueSetCodeSystemConcept.SetDefinitionST(value : String);
begin
  if value <> '' then
  begin
    if FDefinition = nil then
      FDefinition := TFhirString.create;
    FDefinition.value := value
  end
  else if FDefinition <> nil then
    FDefinition.value := '';
end;

Function TFhirValueSetCodeSystemConcept.GetDesignationList : TFhirValueSetCodeSystemConceptDesignationList;
begin
  if FDesignationList = nil then
    FDesignationList := TFhirValueSetCodeSystemConceptDesignationList.Create;
  result := FDesignationList;
end;

Function TFhirValueSetCodeSystemConcept.GetHasDesignationList : boolean;
begin
  result := (FDesignationList <> nil) and (FDesignationList.count > 0);
end;

Function TFhirValueSetCodeSystemConcept.GetConceptList : TFhirValueSetCodeSystemConceptList;
begin
  if FConceptList = nil then
    FConceptList := TFhirValueSetCodeSystemConceptList.Create;
  result := FConceptList;
end;

Function TFhirValueSetCodeSystemConcept.GetHasConceptList : boolean;
begin
  result := (FConceptList <> nil) and (FConceptList.count > 0);
end;

function TFhirValueSetCodeSystemConcept.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FAbstract.sizeInBytes);
  inc(result, FDisplay.sizeInBytes);
  inc(result, FDefinition.sizeInBytes);
  inc(result, FdesignationList.sizeInBytes);
  inc(result, FconceptList.sizeInBytes);
end;

{ TFhirValueSetCodeSystemConceptListEnumerator }

Constructor TFhirValueSetCodeSystemConceptListEnumerator.Create(list : TFhirValueSetCodeSystemConceptList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirValueSetCodeSystemConceptListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirValueSetCodeSystemConceptListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirValueSetCodeSystemConceptListEnumerator.GetCurrent : TFhirValueSetCodeSystemConcept;
begin
  Result := FList[FIndex];
end;

function TFhirValueSetCodeSystemConceptListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirValueSetCodeSystemConceptList }
procedure TFhirValueSetCodeSystemConceptList.AddItem(value: TFhirValueSetCodeSystemConcept);
begin
  assert(value.ClassName = 'TFhirValueSetCodeSystemConcept', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetCodeSystemConcept');
  add(value);
end;

function TFhirValueSetCodeSystemConceptList.Append: TFhirValueSetCodeSystemConcept;
begin
  result := TFhirValueSetCodeSystemConcept.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetCodeSystemConceptList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetCodeSystemConceptList.GetEnumerator : TFhirValueSetCodeSystemConceptListEnumerator;
begin
  result := TFhirValueSetCodeSystemConceptListEnumerator.Create(self.link);
end;

function TFhirValueSetCodeSystemConceptList.Clone: TFhirValueSetCodeSystemConceptList;
begin
  result := TFhirValueSetCodeSystemConceptList(inherited Clone);
end;

function TFhirValueSetCodeSystemConceptList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetCodeSystemConceptList.GetItemN(index: Integer): TFhirValueSetCodeSystemConcept;
begin
  result := TFhirValueSetCodeSystemConcept(ObjectByIndex[index]);
end;

function TFhirValueSetCodeSystemConceptList.ItemClass: TFslObjectClass;
begin
  result := TFhirValueSetCodeSystemConcept;
end;
function TFhirValueSetCodeSystemConceptList.IndexOf(value: TFhirValueSetCodeSystemConcept): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirValueSetCodeSystemConceptList.Insert(index: Integer): TFhirValueSetCodeSystemConcept;
begin
  result := TFhirValueSetCodeSystemConcept.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetCodeSystemConceptList.InsertItem(index: Integer; value: TFhirValueSetCodeSystemConcept);
begin
  assert(value is TFhirValueSetCodeSystemConcept);
  Inherited Insert(index, value);
end;

function TFhirValueSetCodeSystemConceptList.Item(index: Integer): TFhirValueSetCodeSystemConcept;
begin
  result := TFhirValueSetCodeSystemConcept(ObjectByIndex[index]);
end;

function TFhirValueSetCodeSystemConceptList.Link: TFhirValueSetCodeSystemConceptList;
begin
  result := TFhirValueSetCodeSystemConceptList(inherited Link);
end;

procedure TFhirValueSetCodeSystemConceptList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetCodeSystemConceptList.SetItemByIndex(index: Integer; value: TFhirValueSetCodeSystemConcept);
begin
  assert(value is TFhirValueSetCodeSystemConcept);
  FhirValueSetCodeSystemConcepts[index] := value;
end;

procedure TFhirValueSetCodeSystemConceptList.SetItemN(index: Integer; value: TFhirValueSetCodeSystemConcept);
begin
  assert(value is TFhirValueSetCodeSystemConcept);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetCodeSystemConceptDesignation }

constructor TFhirValueSetCodeSystemConceptDesignation.Create;
begin
  inherited;
end;

destructor TFhirValueSetCodeSystemConceptDesignation.Destroy;
begin
  FLanguage.free;
  FUse.free;
  FValue.free;
  inherited;
end;

procedure TFhirValueSetCodeSystemConceptDesignation.Assign(oSource : TFslObject);
begin
  inherited;
  languageElement := TFhirValueSetCodeSystemConceptDesignation(oSource).languageElement.Clone;
  use := TFhirValueSetCodeSystemConceptDesignation(oSource).use.Clone;
  valueElement := TFhirValueSetCodeSystemConceptDesignation(oSource).valueElement.Clone;
end;

procedure TFhirValueSetCodeSystemConceptDesignation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'language') Then
     list.add(self.link, 'language', FLanguage.Link);
  if (child_name = 'use') Then
     list.add(self.link, 'use', FUse.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirValueSetCodeSystemConceptDesignation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'language', 'code', false, TFhirCode, FLanguage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'use', 'Coding', false, TFhirCoding, FUse.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value', 'string', false, TFhirString, FValue.Link));{2}
end;

function TFhirValueSetCodeSystemConceptDesignation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'language') then
  begin
    LanguageElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'use') then
  begin
    Use := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirValueSetCodeSystemConceptDesignation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirValueSetCodeSystemConceptDesignation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'language') then result := TFhirCode.create() {5b}
  else if (propName = 'use') then result := TFhirCoding.create(){4b}
  else if (propName = 'value') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirValueSetCodeSystemConceptDesignation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'language') then result := 'code'
  else if (propName = 'use') then result := 'Coding'
  else if (propName = 'value') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirValueSetCodeSystemConceptDesignation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'language') then LanguageElement := nil
  else if (propName = 'use') then UseElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirValueSetCodeSystemConceptDesignation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'language') then LanguageElement := asCode(new){5b}
  else if (propName = 'use') then UseElement := new as TFhirCoding{4}
  else if (propName = 'value') then ValueElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirValueSetCodeSystemConceptDesignation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirValueSetCodeSystemConceptDesignation.fhirType : string;
begin
  result := 'designation';
end;

function TFhirValueSetCodeSystemConceptDesignation.Link : TFhirValueSetCodeSystemConceptDesignation;
begin
  result := TFhirValueSetCodeSystemConceptDesignation(inherited Link);
end;

function TFhirValueSetCodeSystemConceptDesignation.Clone : TFhirValueSetCodeSystemConceptDesignation;
begin
  result := TFhirValueSetCodeSystemConceptDesignation(inherited Clone);
end;

function TFhirValueSetCodeSystemConceptDesignation.equals(other : TObject) : boolean; 
var
  o : TFhirValueSetCodeSystemConceptDesignation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirValueSetCodeSystemConceptDesignation)) then
    result := false
  else
  begin
    o := TFhirValueSetCodeSystemConceptDesignation(other);
    result := compareDeep(languageElement, o.languageElement, true) and compareDeep(useElement, o.useElement, true) and 
      compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirValueSetCodeSystemConceptDesignation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLanguage) and isEmptyProp(FUse) and isEmptyProp(FValue);
end;

procedure TFhirValueSetCodeSystemConceptDesignation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('language');
  fields.add('use');
  fields.add('value');
end;

{ TFhirValueSetCodeSystemConceptDesignation }

Procedure TFhirValueSetCodeSystemConceptDesignation.SetLanguage(value : TFhirCode);
begin
  FLanguage.free;
  FLanguage := value;
end;

Function TFhirValueSetCodeSystemConceptDesignation.GetLanguageST : String;
begin
  if FLanguage = nil then
    result := ''
  else
    result := FLanguage.value;
end;

Procedure TFhirValueSetCodeSystemConceptDesignation.SetLanguageST(value : String);
begin
  if value <> '' then
  begin
    if FLanguage = nil then
      FLanguage := TFhirCode.create;
    FLanguage.value := value
  end
  else if FLanguage <> nil then
    FLanguage.value := '';
end;

Procedure TFhirValueSetCodeSystemConceptDesignation.SetUse(value : TFhirCoding);
begin
  FUse.free;
  FUse := value;
end;

Procedure TFhirValueSetCodeSystemConceptDesignation.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirValueSetCodeSystemConceptDesignation.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

Procedure TFhirValueSetCodeSystemConceptDesignation.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

function TFhirValueSetCodeSystemConceptDesignation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FLanguage.sizeInBytes);
  inc(result, FUse.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirValueSetCodeSystemConceptDesignationListEnumerator }

Constructor TFhirValueSetCodeSystemConceptDesignationListEnumerator.Create(list : TFhirValueSetCodeSystemConceptDesignationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirValueSetCodeSystemConceptDesignationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirValueSetCodeSystemConceptDesignationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirValueSetCodeSystemConceptDesignationListEnumerator.GetCurrent : TFhirValueSetCodeSystemConceptDesignation;
begin
  Result := FList[FIndex];
end;

function TFhirValueSetCodeSystemConceptDesignationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirValueSetCodeSystemConceptDesignationList }
procedure TFhirValueSetCodeSystemConceptDesignationList.AddItem(value: TFhirValueSetCodeSystemConceptDesignation);
begin
  assert(value.ClassName = 'TFhirValueSetCodeSystemConceptDesignation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetCodeSystemConceptDesignation');
  add(value);
end;

function TFhirValueSetCodeSystemConceptDesignationList.Append: TFhirValueSetCodeSystemConceptDesignation;
begin
  result := TFhirValueSetCodeSystemConceptDesignation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetCodeSystemConceptDesignationList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetCodeSystemConceptDesignationList.GetEnumerator : TFhirValueSetCodeSystemConceptDesignationListEnumerator;
begin
  result := TFhirValueSetCodeSystemConceptDesignationListEnumerator.Create(self.link);
end;

function TFhirValueSetCodeSystemConceptDesignationList.Clone: TFhirValueSetCodeSystemConceptDesignationList;
begin
  result := TFhirValueSetCodeSystemConceptDesignationList(inherited Clone);
end;

function TFhirValueSetCodeSystemConceptDesignationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetCodeSystemConceptDesignationList.GetItemN(index: Integer): TFhirValueSetCodeSystemConceptDesignation;
begin
  result := TFhirValueSetCodeSystemConceptDesignation(ObjectByIndex[index]);
end;

function TFhirValueSetCodeSystemConceptDesignationList.ItemClass: TFslObjectClass;
begin
  result := TFhirValueSetCodeSystemConceptDesignation;
end;
function TFhirValueSetCodeSystemConceptDesignationList.IndexOf(value: TFhirValueSetCodeSystemConceptDesignation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirValueSetCodeSystemConceptDesignationList.Insert(index: Integer): TFhirValueSetCodeSystemConceptDesignation;
begin
  result := TFhirValueSetCodeSystemConceptDesignation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetCodeSystemConceptDesignationList.InsertItem(index: Integer; value: TFhirValueSetCodeSystemConceptDesignation);
begin
  assert(value is TFhirValueSetCodeSystemConceptDesignation);
  Inherited Insert(index, value);
end;

function TFhirValueSetCodeSystemConceptDesignationList.Item(index: Integer): TFhirValueSetCodeSystemConceptDesignation;
begin
  result := TFhirValueSetCodeSystemConceptDesignation(ObjectByIndex[index]);
end;

function TFhirValueSetCodeSystemConceptDesignationList.Link: TFhirValueSetCodeSystemConceptDesignationList;
begin
  result := TFhirValueSetCodeSystemConceptDesignationList(inherited Link);
end;

procedure TFhirValueSetCodeSystemConceptDesignationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetCodeSystemConceptDesignationList.SetItemByIndex(index: Integer; value: TFhirValueSetCodeSystemConceptDesignation);
begin
  assert(value is TFhirValueSetCodeSystemConceptDesignation);
  FhirValueSetCodeSystemConceptDesignations[index] := value;
end;

procedure TFhirValueSetCodeSystemConceptDesignationList.SetItemN(index: Integer; value: TFhirValueSetCodeSystemConceptDesignation);
begin
  assert(value is TFhirValueSetCodeSystemConceptDesignation);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetCompose }

constructor TFhirValueSetCompose.Create;
begin
  inherited;
end;

destructor TFhirValueSetCompose.Destroy;
begin
  FImportList.Free;
  FIncludeList.Free;
  FExcludeList.Free;
  inherited;
end;

procedure TFhirValueSetCompose.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirValueSetCompose(oSource).FImportList = nil) then
  begin
    FImportList.free;
    FImportList := nil;
  end
  else
  begin
    if FImportList = nil then
      FImportList := TFhirUriList.Create;
    FImportList.Assign(TFhirValueSetCompose(oSource).FImportList);
  end;
  if (TFhirValueSetCompose(oSource).FIncludeList = nil) then
  begin
    FIncludeList.free;
    FIncludeList := nil;
  end
  else
  begin
    if FIncludeList = nil then
      FIncludeList := TFhirValueSetComposeIncludeList.Create;
    FIncludeList.Assign(TFhirValueSetCompose(oSource).FIncludeList);
  end;
  if (TFhirValueSetCompose(oSource).FExcludeList = nil) then
  begin
    FExcludeList.free;
    FExcludeList := nil;
  end
  else
  begin
    if FExcludeList = nil then
      FExcludeList := TFhirValueSetComposeIncludeList.Create;
    FExcludeList.Assign(TFhirValueSetCompose(oSource).FExcludeList);
  end;
end;

procedure TFhirValueSetCompose.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'import') Then
    list.addAll(self, 'import', FImportList);
  if (child_name = 'include') Then
    list.addAll(self, 'include', FIncludeList);
  if (child_name = 'exclude') Then
    list.addAll(self, 'exclude', FExcludeList);
end;

procedure TFhirValueSetCompose.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'import', 'uri', true, TFhirUri, FImportList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'include', '', true, TFhirValueSetComposeInclude, FIncludeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'exclude', '@ValueSet.compose.include', true, TFhirValueSetComposeInclude, FExcludeList.Link)){3};
end;

function TFhirValueSetCompose.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'import') then
  begin
    ImportList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'include') then
  begin
    IncludeList.add(propValue as TFhirValueSetComposeInclude){2a};
    result := propValue;
  end
  else if (propName = 'exclude') then
  begin
    ExcludeList.add(propValue as TFhirValueSetComposeInclude){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirValueSetCompose.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'import') then ImportList.insertItem(index, asUri(propValue)){2}
  else if (propName = 'include') then IncludeList.insertItem(index, propValue as TFhirValueSetComposeInclude){2a}
  else if (propName = 'exclude') then ExcludeList.insertItem(index, propValue as TFhirValueSetComposeInclude){2a}
  else inherited;
end;

function TFhirValueSetCompose.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'import') then result := ImportList.new(){2}
  else if (propName = 'include') then result := IncludeList.new(){2}
  else if (propName = 'exclude') then result := ExcludeList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirValueSetCompose.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'import') then result := 'uri'
  else if (propName = 'include') then result := ''
  else if (propName = 'exclude') then result := '@ValueSet.compose.include'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirValueSetCompose.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'import') then deletePropertyValue('import', ImportList, value) {2}
  else if (propName = 'include') then deletePropertyValue('include', IncludeList, value) {2}
  else if (propName = 'exclude') then deletePropertyValue('exclude', ExcludeList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirValueSetCompose.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'import') then replacePropertyValue('import', ImportList, existing, new) {2}
  else if (propName = 'include') then replacePropertyValue('include', IncludeList, existing, new) {2}
  else if (propName = 'exclude') then replacePropertyValue('exclude', ExcludeList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirValueSetCompose.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'import') then ImportList.move(source, destination){2}
  else if (propName = 'include') then IncludeList.move(source, destination){2a}
  else if (propName = 'exclude') then ExcludeList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirValueSetCompose.fhirType : string;
begin
  result := 'compose';
end;

function TFhirValueSetCompose.Link : TFhirValueSetCompose;
begin
  result := TFhirValueSetCompose(inherited Link);
end;

function TFhirValueSetCompose.Clone : TFhirValueSetCompose;
begin
  result := TFhirValueSetCompose(inherited Clone);
end;

function TFhirValueSetCompose.equals(other : TObject) : boolean; 
var
  o : TFhirValueSetCompose;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirValueSetCompose)) then
    result := false
  else
  begin
    o := TFhirValueSetCompose(other);
    result := compareDeep(importList, o.importList, true) and compareDeep(includeList, o.includeList, true) and 
      compareDeep(excludeList, o.excludeList, true);
  end;
end;

function TFhirValueSetCompose.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FimportList) and isEmptyProp(FincludeList) and isEmptyProp(FexcludeList);
end;

procedure TFhirValueSetCompose.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('import');
  fields.add('include');
  fields.add('exclude');
end;

{ TFhirValueSetCompose }

Function TFhirValueSetCompose.GetImportList : TFhirUriList;
begin
  if FImportList = nil then
    FImportList := TFhirUriList.Create;
  result := FImportList;
end;

Function TFhirValueSetCompose.GetHasImportList : boolean;
begin
  result := (FImportList <> nil) and (FImportList.count > 0);
end;

Function TFhirValueSetCompose.GetIncludeList : TFhirValueSetComposeIncludeList;
begin
  if FIncludeList = nil then
    FIncludeList := TFhirValueSetComposeIncludeList.Create;
  result := FIncludeList;
end;

Function TFhirValueSetCompose.GetHasIncludeList : boolean;
begin
  result := (FIncludeList <> nil) and (FIncludeList.count > 0);
end;

Function TFhirValueSetCompose.GetExcludeList : TFhirValueSetComposeIncludeList;
begin
  if FExcludeList = nil then
    FExcludeList := TFhirValueSetComposeIncludeList.Create;
  result := FExcludeList;
end;

Function TFhirValueSetCompose.GetHasExcludeList : boolean;
begin
  result := (FExcludeList <> nil) and (FExcludeList.count > 0);
end;

function TFhirValueSetCompose.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FimportList.sizeInBytes);
  inc(result, FincludeList.sizeInBytes);
  inc(result, FexcludeList.sizeInBytes);
end;

{ TFhirValueSetComposeListEnumerator }

Constructor TFhirValueSetComposeListEnumerator.Create(list : TFhirValueSetComposeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirValueSetComposeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirValueSetComposeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirValueSetComposeListEnumerator.GetCurrent : TFhirValueSetCompose;
begin
  Result := FList[FIndex];
end;

function TFhirValueSetComposeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirValueSetComposeList }
procedure TFhirValueSetComposeList.AddItem(value: TFhirValueSetCompose);
begin
  assert(value.ClassName = 'TFhirValueSetCompose', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetCompose');
  add(value);
end;

function TFhirValueSetComposeList.Append: TFhirValueSetCompose;
begin
  result := TFhirValueSetCompose.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetComposeList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetComposeList.GetEnumerator : TFhirValueSetComposeListEnumerator;
begin
  result := TFhirValueSetComposeListEnumerator.Create(self.link);
end;

function TFhirValueSetComposeList.Clone: TFhirValueSetComposeList;
begin
  result := TFhirValueSetComposeList(inherited Clone);
end;

function TFhirValueSetComposeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetComposeList.GetItemN(index: Integer): TFhirValueSetCompose;
begin
  result := TFhirValueSetCompose(ObjectByIndex[index]);
end;

function TFhirValueSetComposeList.ItemClass: TFslObjectClass;
begin
  result := TFhirValueSetCompose;
end;
function TFhirValueSetComposeList.IndexOf(value: TFhirValueSetCompose): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirValueSetComposeList.Insert(index: Integer): TFhirValueSetCompose;
begin
  result := TFhirValueSetCompose.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetComposeList.InsertItem(index: Integer; value: TFhirValueSetCompose);
begin
  assert(value is TFhirValueSetCompose);
  Inherited Insert(index, value);
end;

function TFhirValueSetComposeList.Item(index: Integer): TFhirValueSetCompose;
begin
  result := TFhirValueSetCompose(ObjectByIndex[index]);
end;

function TFhirValueSetComposeList.Link: TFhirValueSetComposeList;
begin
  result := TFhirValueSetComposeList(inherited Link);
end;

procedure TFhirValueSetComposeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetComposeList.SetItemByIndex(index: Integer; value: TFhirValueSetCompose);
begin
  assert(value is TFhirValueSetCompose);
  FhirValueSetComposes[index] := value;
end;

procedure TFhirValueSetComposeList.SetItemN(index: Integer; value: TFhirValueSetCompose);
begin
  assert(value is TFhirValueSetCompose);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetComposeInclude }

constructor TFhirValueSetComposeInclude.Create;
begin
  inherited;
end;

destructor TFhirValueSetComposeInclude.Destroy;
begin
  FSystem.free;
  FVersion.free;
  FConceptList.Free;
  FFilterList.Free;
  inherited;
end;

procedure TFhirValueSetComposeInclude.Assign(oSource : TFslObject);
begin
  inherited;
  systemElement := TFhirValueSetComposeInclude(oSource).systemElement.Clone;
  versionElement := TFhirValueSetComposeInclude(oSource).versionElement.Clone;
  if (TFhirValueSetComposeInclude(oSource).FConceptList = nil) then
  begin
    FConceptList.free;
    FConceptList := nil;
  end
  else
  begin
    if FConceptList = nil then
      FConceptList := TFhirValueSetComposeIncludeConceptList.Create;
    FConceptList.Assign(TFhirValueSetComposeInclude(oSource).FConceptList);
  end;
  if (TFhirValueSetComposeInclude(oSource).FFilterList = nil) then
  begin
    FFilterList.free;
    FFilterList := nil;
  end
  else
  begin
    if FFilterList = nil then
      FFilterList := TFhirValueSetComposeIncludeFilterList.Create;
    FFilterList.Assign(TFhirValueSetComposeInclude(oSource).FFilterList);
  end;
end;

procedure TFhirValueSetComposeInclude.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'system') Then
     list.add(self.link, 'system', FSystem.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'concept') Then
    list.addAll(self, 'concept', FConceptList);
  if (child_name = 'filter') Then
    list.addAll(self, 'filter', FFilterList);
end;

procedure TFhirValueSetComposeInclude.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'system', 'uri', false, TFhirUri, FSystem.Link));{2}
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));{2}
  oList.add(TFHIRProperty.create(self, 'concept', '', true, TFhirValueSetComposeIncludeConcept, FConceptList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'filter', '', true, TFhirValueSetComposeIncludeFilter, FFilterList.Link)){3};
end;

function TFhirValueSetComposeInclude.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'system') then
  begin
    SystemElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'concept') then
  begin
    ConceptList.add(propValue as TFhirValueSetComposeIncludeConcept){2a};
    result := propValue;
  end
  else if (propName = 'filter') then
  begin
    FilterList.add(propValue as TFhirValueSetComposeIncludeFilter){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirValueSetComposeInclude.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'concept') then ConceptList.insertItem(index, propValue as TFhirValueSetComposeIncludeConcept){2a}
  else if (propName = 'filter') then FilterList.insertItem(index, propValue as TFhirValueSetComposeIncludeFilter){2a}
  else inherited;
end;

function TFhirValueSetComposeInclude.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'system') then result := TFhirUri.create() {5b}
  else if (propName = 'version') then result := TFhirString.create() {5b}
  else if (propName = 'concept') then result := ConceptList.new(){2}
  else if (propName = 'filter') then result := FilterList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirValueSetComposeInclude.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'system') then result := 'uri'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'concept') then result := ''
  else if (propName = 'filter') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirValueSetComposeInclude.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'system') then SystemElement := nil
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'concept') then deletePropertyValue('concept', ConceptList, value) {2}
  else if (propName = 'filter') then deletePropertyValue('filter', FilterList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirValueSetComposeInclude.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'system') then SystemElement := asUri(new){5b}
  else if (propName = 'version') then VersionElement := asString(new){5b}
  else if (propName = 'concept') then replacePropertyValue('concept', ConceptList, existing, new) {2}
  else if (propName = 'filter') then replacePropertyValue('filter', FilterList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirValueSetComposeInclude.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'concept') then ConceptList.move(source, destination){2a}
  else if (propName = 'filter') then FilterList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirValueSetComposeInclude.fhirType : string;
begin
  result := 'include';
end;

function TFhirValueSetComposeInclude.Link : TFhirValueSetComposeInclude;
begin
  result := TFhirValueSetComposeInclude(inherited Link);
end;

function TFhirValueSetComposeInclude.Clone : TFhirValueSetComposeInclude;
begin
  result := TFhirValueSetComposeInclude(inherited Clone);
end;

function TFhirValueSetComposeInclude.equals(other : TObject) : boolean; 
var
  o : TFhirValueSetComposeInclude;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirValueSetComposeInclude)) then
    result := false
  else
  begin
    o := TFhirValueSetComposeInclude(other);
    result := compareDeep(systemElement, o.systemElement, true) and compareDeep(versionElement, o.versionElement, true) and 
      compareDeep(conceptList, o.conceptList, true) and compareDeep(filterList, o.filterList, true);
  end;
end;

function TFhirValueSetComposeInclude.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSystem) and isEmptyProp(FVersion) and isEmptyProp(FconceptList) and isEmptyProp(FfilterList);
end;

procedure TFhirValueSetComposeInclude.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('system');
  fields.add('version');
  fields.add('concept');
  fields.add('filter');
end;

{ TFhirValueSetComposeInclude }

Procedure TFhirValueSetComposeInclude.SetSystem(value : TFhirUri);
begin
  FSystem.free;
  FSystem := value;
end;

Function TFhirValueSetComposeInclude.GetSystemST : String;
begin
  if FSystem = nil then
    result := ''
  else
    result := FSystem.value;
end;

Procedure TFhirValueSetComposeInclude.SetSystemST(value : String);
begin
  if value <> '' then
  begin
    if FSystem = nil then
      FSystem := TFhirUri.create;
    FSystem.value := value
  end
  else if FSystem <> nil then
    FSystem.value := '';
end;

Procedure TFhirValueSetComposeInclude.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

Function TFhirValueSetComposeInclude.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

Procedure TFhirValueSetComposeInclude.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

Function TFhirValueSetComposeInclude.GetConceptList : TFhirValueSetComposeIncludeConceptList;
begin
  if FConceptList = nil then
    FConceptList := TFhirValueSetComposeIncludeConceptList.Create;
  result := FConceptList;
end;

Function TFhirValueSetComposeInclude.GetHasConceptList : boolean;
begin
  result := (FConceptList <> nil) and (FConceptList.count > 0);
end;

Function TFhirValueSetComposeInclude.GetFilterList : TFhirValueSetComposeIncludeFilterList;
begin
  if FFilterList = nil then
    FFilterList := TFhirValueSetComposeIncludeFilterList.Create;
  result := FFilterList;
end;

Function TFhirValueSetComposeInclude.GetHasFilterList : boolean;
begin
  result := (FFilterList <> nil) and (FFilterList.count > 0);
end;

function TFhirValueSetComposeInclude.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSystem.sizeInBytes);
  inc(result, FVersion.sizeInBytes);
  inc(result, FconceptList.sizeInBytes);
  inc(result, FfilterList.sizeInBytes);
end;

{ TFhirValueSetComposeIncludeListEnumerator }

Constructor TFhirValueSetComposeIncludeListEnumerator.Create(list : TFhirValueSetComposeIncludeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirValueSetComposeIncludeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirValueSetComposeIncludeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirValueSetComposeIncludeListEnumerator.GetCurrent : TFhirValueSetComposeInclude;
begin
  Result := FList[FIndex];
end;

function TFhirValueSetComposeIncludeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirValueSetComposeIncludeList }
procedure TFhirValueSetComposeIncludeList.AddItem(value: TFhirValueSetComposeInclude);
begin
  assert(value.ClassName = 'TFhirValueSetComposeInclude', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetComposeInclude');
  add(value);
end;

function TFhirValueSetComposeIncludeList.Append: TFhirValueSetComposeInclude;
begin
  result := TFhirValueSetComposeInclude.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetComposeIncludeList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetComposeIncludeList.GetEnumerator : TFhirValueSetComposeIncludeListEnumerator;
begin
  result := TFhirValueSetComposeIncludeListEnumerator.Create(self.link);
end;

function TFhirValueSetComposeIncludeList.Clone: TFhirValueSetComposeIncludeList;
begin
  result := TFhirValueSetComposeIncludeList(inherited Clone);
end;

function TFhirValueSetComposeIncludeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetComposeIncludeList.GetItemN(index: Integer): TFhirValueSetComposeInclude;
begin
  result := TFhirValueSetComposeInclude(ObjectByIndex[index]);
end;

function TFhirValueSetComposeIncludeList.ItemClass: TFslObjectClass;
begin
  result := TFhirValueSetComposeInclude;
end;
function TFhirValueSetComposeIncludeList.IndexOf(value: TFhirValueSetComposeInclude): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirValueSetComposeIncludeList.Insert(index: Integer): TFhirValueSetComposeInclude;
begin
  result := TFhirValueSetComposeInclude.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetComposeIncludeList.InsertItem(index: Integer; value: TFhirValueSetComposeInclude);
begin
  assert(value is TFhirValueSetComposeInclude);
  Inherited Insert(index, value);
end;

function TFhirValueSetComposeIncludeList.Item(index: Integer): TFhirValueSetComposeInclude;
begin
  result := TFhirValueSetComposeInclude(ObjectByIndex[index]);
end;

function TFhirValueSetComposeIncludeList.Link: TFhirValueSetComposeIncludeList;
begin
  result := TFhirValueSetComposeIncludeList(inherited Link);
end;

procedure TFhirValueSetComposeIncludeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetComposeIncludeList.SetItemByIndex(index: Integer; value: TFhirValueSetComposeInclude);
begin
  assert(value is TFhirValueSetComposeInclude);
  FhirValueSetComposeIncludes[index] := value;
end;

procedure TFhirValueSetComposeIncludeList.SetItemN(index: Integer; value: TFhirValueSetComposeInclude);
begin
  assert(value is TFhirValueSetComposeInclude);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetComposeIncludeConcept }

constructor TFhirValueSetComposeIncludeConcept.Create;
begin
  inherited;
end;

destructor TFhirValueSetComposeIncludeConcept.Destroy;
begin
  FCode.free;
  FDisplay.free;
  FDesignationList.Free;
  inherited;
end;

procedure TFhirValueSetComposeIncludeConcept.Assign(oSource : TFslObject);
begin
  inherited;
  codeElement := TFhirValueSetComposeIncludeConcept(oSource).codeElement.Clone;
  displayElement := TFhirValueSetComposeIncludeConcept(oSource).displayElement.Clone;
  if (TFhirValueSetComposeIncludeConcept(oSource).FDesignationList = nil) then
  begin
    FDesignationList.free;
    FDesignationList := nil;
  end
  else
  begin
    if FDesignationList = nil then
      FDesignationList := TFhirValueSetCodeSystemConceptDesignationList.Create;
    FDesignationList.Assign(TFhirValueSetComposeIncludeConcept(oSource).FDesignationList);
  end;
end;

procedure TFhirValueSetComposeIncludeConcept.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'display') Then
     list.add(self.link, 'display', FDisplay.Link);
  if (child_name = 'designation') Then
    list.addAll(self, 'designation', FDesignationList);
end;

procedure TFhirValueSetComposeIncludeConcept.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirCode, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'display', 'string', false, TFhirString, FDisplay.Link));{2}
  oList.add(TFHIRProperty.create(self, 'designation', '@ValueSet.codeSystem.concept.designation', true, TFhirValueSetCodeSystemConceptDesignation, FDesignationList.Link)){3};
end;

function TFhirValueSetComposeIncludeConcept.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'display') then
  begin
    DisplayElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'designation') then
  begin
    DesignationList.add(propValue as TFhirValueSetCodeSystemConceptDesignation){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirValueSetComposeIncludeConcept.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'designation') then DesignationList.insertItem(index, propValue as TFhirValueSetCodeSystemConceptDesignation){2a}
  else inherited;
end;

function TFhirValueSetComposeIncludeConcept.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCode.create() {5b}
  else if (propName = 'display') then result := TFhirString.create() {5b}
  else if (propName = 'designation') then result := DesignationList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirValueSetComposeIncludeConcept.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'code'
  else if (propName = 'display') then result := 'string'
  else if (propName = 'designation') then result := '@ValueSet.codeSystem.concept.designation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirValueSetComposeIncludeConcept.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'display') then DisplayElement := nil
  else if (propName = 'designation') then deletePropertyValue('designation', DesignationList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirValueSetComposeIncludeConcept.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := asCode(new){5b}
  else if (propName = 'display') then DisplayElement := asString(new){5b}
  else if (propName = 'designation') then replacePropertyValue('designation', DesignationList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirValueSetComposeIncludeConcept.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'designation') then DesignationList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirValueSetComposeIncludeConcept.fhirType : string;
begin
  result := 'concept';
end;

function TFhirValueSetComposeIncludeConcept.Link : TFhirValueSetComposeIncludeConcept;
begin
  result := TFhirValueSetComposeIncludeConcept(inherited Link);
end;

function TFhirValueSetComposeIncludeConcept.Clone : TFhirValueSetComposeIncludeConcept;
begin
  result := TFhirValueSetComposeIncludeConcept(inherited Clone);
end;

function TFhirValueSetComposeIncludeConcept.equals(other : TObject) : boolean; 
var
  o : TFhirValueSetComposeIncludeConcept;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirValueSetComposeIncludeConcept)) then
    result := false
  else
  begin
    o := TFhirValueSetComposeIncludeConcept(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(displayElement, o.displayElement, true) and 
      compareDeep(designationList, o.designationList, true);
  end;
end;

function TFhirValueSetComposeIncludeConcept.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FDisplay) and isEmptyProp(FdesignationList);
end;

procedure TFhirValueSetComposeIncludeConcept.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('display');
  fields.add('designation');
end;

{ TFhirValueSetComposeIncludeConcept }

Procedure TFhirValueSetComposeIncludeConcept.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirValueSetComposeIncludeConcept.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

Procedure TFhirValueSetComposeIncludeConcept.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

Procedure TFhirValueSetComposeIncludeConcept.SetDisplay(value : TFhirString);
begin
  FDisplay.free;
  FDisplay := value;
end;

Function TFhirValueSetComposeIncludeConcept.GetDisplayST : String;
begin
  if FDisplay = nil then
    result := ''
  else
    result := FDisplay.value;
end;

Procedure TFhirValueSetComposeIncludeConcept.SetDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FDisplay = nil then
      FDisplay := TFhirString.create;
    FDisplay.value := value
  end
  else if FDisplay <> nil then
    FDisplay.value := '';
end;

Function TFhirValueSetComposeIncludeConcept.GetDesignationList : TFhirValueSetCodeSystemConceptDesignationList;
begin
  if FDesignationList = nil then
    FDesignationList := TFhirValueSetCodeSystemConceptDesignationList.Create;
  result := FDesignationList;
end;

Function TFhirValueSetComposeIncludeConcept.GetHasDesignationList : boolean;
begin
  result := (FDesignationList <> nil) and (FDesignationList.count > 0);
end;

function TFhirValueSetComposeIncludeConcept.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FDisplay.sizeInBytes);
  inc(result, FdesignationList.sizeInBytes);
end;

{ TFhirValueSetComposeIncludeConceptListEnumerator }

Constructor TFhirValueSetComposeIncludeConceptListEnumerator.Create(list : TFhirValueSetComposeIncludeConceptList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirValueSetComposeIncludeConceptListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirValueSetComposeIncludeConceptListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirValueSetComposeIncludeConceptListEnumerator.GetCurrent : TFhirValueSetComposeIncludeConcept;
begin
  Result := FList[FIndex];
end;

function TFhirValueSetComposeIncludeConceptListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirValueSetComposeIncludeConceptList }
procedure TFhirValueSetComposeIncludeConceptList.AddItem(value: TFhirValueSetComposeIncludeConcept);
begin
  assert(value.ClassName = 'TFhirValueSetComposeIncludeConcept', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetComposeIncludeConcept');
  add(value);
end;

function TFhirValueSetComposeIncludeConceptList.Append: TFhirValueSetComposeIncludeConcept;
begin
  result := TFhirValueSetComposeIncludeConcept.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetComposeIncludeConceptList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetComposeIncludeConceptList.GetEnumerator : TFhirValueSetComposeIncludeConceptListEnumerator;
begin
  result := TFhirValueSetComposeIncludeConceptListEnumerator.Create(self.link);
end;

function TFhirValueSetComposeIncludeConceptList.Clone: TFhirValueSetComposeIncludeConceptList;
begin
  result := TFhirValueSetComposeIncludeConceptList(inherited Clone);
end;

function TFhirValueSetComposeIncludeConceptList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetComposeIncludeConceptList.GetItemN(index: Integer): TFhirValueSetComposeIncludeConcept;
begin
  result := TFhirValueSetComposeIncludeConcept(ObjectByIndex[index]);
end;

function TFhirValueSetComposeIncludeConceptList.ItemClass: TFslObjectClass;
begin
  result := TFhirValueSetComposeIncludeConcept;
end;
function TFhirValueSetComposeIncludeConceptList.IndexOf(value: TFhirValueSetComposeIncludeConcept): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirValueSetComposeIncludeConceptList.Insert(index: Integer): TFhirValueSetComposeIncludeConcept;
begin
  result := TFhirValueSetComposeIncludeConcept.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetComposeIncludeConceptList.InsertItem(index: Integer; value: TFhirValueSetComposeIncludeConcept);
begin
  assert(value is TFhirValueSetComposeIncludeConcept);
  Inherited Insert(index, value);
end;

function TFhirValueSetComposeIncludeConceptList.Item(index: Integer): TFhirValueSetComposeIncludeConcept;
begin
  result := TFhirValueSetComposeIncludeConcept(ObjectByIndex[index]);
end;

function TFhirValueSetComposeIncludeConceptList.Link: TFhirValueSetComposeIncludeConceptList;
begin
  result := TFhirValueSetComposeIncludeConceptList(inherited Link);
end;

procedure TFhirValueSetComposeIncludeConceptList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetComposeIncludeConceptList.SetItemByIndex(index: Integer; value: TFhirValueSetComposeIncludeConcept);
begin
  assert(value is TFhirValueSetComposeIncludeConcept);
  FhirValueSetComposeIncludeConcepts[index] := value;
end;

procedure TFhirValueSetComposeIncludeConceptList.SetItemN(index: Integer; value: TFhirValueSetComposeIncludeConcept);
begin
  assert(value is TFhirValueSetComposeIncludeConcept);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetComposeIncludeFilter }

constructor TFhirValueSetComposeIncludeFilter.Create;
begin
  inherited;
end;

destructor TFhirValueSetComposeIncludeFilter.Destroy;
begin
  FProperty_.free;
  FOp.free;
  FValue.free;
  inherited;
end;

procedure TFhirValueSetComposeIncludeFilter.Assign(oSource : TFslObject);
begin
  inherited;
  property_Element := TFhirValueSetComposeIncludeFilter(oSource).property_Element.Clone;
  FOp := TFhirValueSetComposeIncludeFilter(oSource).FOp.Link;
  valueElement := TFhirValueSetComposeIncludeFilter(oSource).valueElement.Clone;
end;

procedure TFhirValueSetComposeIncludeFilter.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'property') Then
     list.add(self.link, 'property', FProperty_.Link);
  if (child_name = 'op') Then
     list.add(self.link, 'op', FOp.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirValueSetComposeIncludeFilter.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'property', 'code', false, TFhirCode, FProperty_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'op', 'code', false, TFHIREnum, FOp.Link));{1}
  oList.add(TFHIRProperty.create(self, 'value', 'code', false, TFhirCode, FValue.Link));{2}
end;

function TFhirValueSetComposeIncludeFilter.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'property') then
  begin
    Property_Element := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'op') then
  begin
    OpElement := asEnum(SYSTEMS_TFhirFilterOperatorEnum, CODES_TFhirFilterOperatorEnum, propValue);
    result := propValue
  end
  else if (propName = 'value') then
  begin
    ValueElement := asCode(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirValueSetComposeIncludeFilter.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirValueSetComposeIncludeFilter.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'property') then result := TFhirCode.create() {5b}
  else if (propName = 'value') then result := TFhirCode.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirValueSetComposeIncludeFilter.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'property') then result := 'code'
  else if (propName = 'op') then result := 'code'
  else if (propName = 'value') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirValueSetComposeIncludeFilter.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'property') then Property_Element := nil
  else if (propName = 'op') then OpElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirValueSetComposeIncludeFilter.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'property') then Property_Element := asCode(new){5b}
  else if (propName = 'op') then OpElement := asEnum(SYSTEMS_TFhirFilterOperatorEnum, CODES_TFhirFilterOperatorEnum, new){4}
  else if (propName = 'value') then ValueElement := asCode(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirValueSetComposeIncludeFilter.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirValueSetComposeIncludeFilter.fhirType : string;
begin
  result := 'filter';
end;

function TFhirValueSetComposeIncludeFilter.Link : TFhirValueSetComposeIncludeFilter;
begin
  result := TFhirValueSetComposeIncludeFilter(inherited Link);
end;

function TFhirValueSetComposeIncludeFilter.Clone : TFhirValueSetComposeIncludeFilter;
begin
  result := TFhirValueSetComposeIncludeFilter(inherited Clone);
end;

function TFhirValueSetComposeIncludeFilter.equals(other : TObject) : boolean; 
var
  o : TFhirValueSetComposeIncludeFilter;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirValueSetComposeIncludeFilter)) then
    result := false
  else
  begin
    o := TFhirValueSetComposeIncludeFilter(other);
    result := compareDeep(property_Element, o.property_Element, true) and compareDeep(opElement, o.opElement, true) and 
      compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirValueSetComposeIncludeFilter.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FProperty_) and isEmptyProp(FOp) and isEmptyProp(FValue);
end;

procedure TFhirValueSetComposeIncludeFilter.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('property');
  fields.add('op');
  fields.add('value');
end;

{ TFhirValueSetComposeIncludeFilter }

Procedure TFhirValueSetComposeIncludeFilter.SetProperty_(value : TFhirCode);
begin
  FProperty_.free;
  FProperty_ := value;
end;

Function TFhirValueSetComposeIncludeFilter.GetProperty_ST : String;
begin
  if FProperty_ = nil then
    result := ''
  else
    result := FProperty_.value;
end;

Procedure TFhirValueSetComposeIncludeFilter.SetProperty_ST(value : String);
begin
  if value <> '' then
  begin
    if FProperty_ = nil then
      FProperty_ := TFhirCode.create;
    FProperty_.value := value
  end
  else if FProperty_ <> nil then
    FProperty_.value := '';
end;

Procedure TFhirValueSetComposeIncludeFilter.SetOp(value : TFhirEnum);
begin
  FOp.free;
  FOp := value;
end;

Function TFhirValueSetComposeIncludeFilter.GetOpST : TFhirFilterOperatorEnum;
begin
  if FOp = nil then
    result := TFhirFilterOperatorEnum(0)
  else
    result := TFhirFilterOperatorEnum(StringArrayIndexOfSensitive(CODES_TFhirFilterOperatorEnum, FOp.value));
end;

Procedure TFhirValueSetComposeIncludeFilter.SetOpST(value : TFhirFilterOperatorEnum);
begin
  if ord(value) = 0 then
    OpElement := nil
  else
    OpElement := TFhirEnum.create(SYSTEMS_TFhirFilterOperatorEnum[value], CODES_TFhirFilterOperatorEnum[value]);
end;

Procedure TFhirValueSetComposeIncludeFilter.SetValue(value : TFhirCode);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirValueSetComposeIncludeFilter.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

Procedure TFhirValueSetComposeIncludeFilter.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirCode.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

function TFhirValueSetComposeIncludeFilter.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FProperty_.sizeInBytes);
  inc(result, FOp.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirValueSetComposeIncludeFilterListEnumerator }

Constructor TFhirValueSetComposeIncludeFilterListEnumerator.Create(list : TFhirValueSetComposeIncludeFilterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirValueSetComposeIncludeFilterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirValueSetComposeIncludeFilterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirValueSetComposeIncludeFilterListEnumerator.GetCurrent : TFhirValueSetComposeIncludeFilter;
begin
  Result := FList[FIndex];
end;

function TFhirValueSetComposeIncludeFilterListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirValueSetComposeIncludeFilterList }
procedure TFhirValueSetComposeIncludeFilterList.AddItem(value: TFhirValueSetComposeIncludeFilter);
begin
  assert(value.ClassName = 'TFhirValueSetComposeIncludeFilter', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetComposeIncludeFilter');
  add(value);
end;

function TFhirValueSetComposeIncludeFilterList.Append: TFhirValueSetComposeIncludeFilter;
begin
  result := TFhirValueSetComposeIncludeFilter.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetComposeIncludeFilterList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetComposeIncludeFilterList.GetEnumerator : TFhirValueSetComposeIncludeFilterListEnumerator;
begin
  result := TFhirValueSetComposeIncludeFilterListEnumerator.Create(self.link);
end;

function TFhirValueSetComposeIncludeFilterList.Clone: TFhirValueSetComposeIncludeFilterList;
begin
  result := TFhirValueSetComposeIncludeFilterList(inherited Clone);
end;

function TFhirValueSetComposeIncludeFilterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetComposeIncludeFilterList.GetItemN(index: Integer): TFhirValueSetComposeIncludeFilter;
begin
  result := TFhirValueSetComposeIncludeFilter(ObjectByIndex[index]);
end;

function TFhirValueSetComposeIncludeFilterList.ItemClass: TFslObjectClass;
begin
  result := TFhirValueSetComposeIncludeFilter;
end;
function TFhirValueSetComposeIncludeFilterList.IndexOf(value: TFhirValueSetComposeIncludeFilter): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirValueSetComposeIncludeFilterList.Insert(index: Integer): TFhirValueSetComposeIncludeFilter;
begin
  result := TFhirValueSetComposeIncludeFilter.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetComposeIncludeFilterList.InsertItem(index: Integer; value: TFhirValueSetComposeIncludeFilter);
begin
  assert(value is TFhirValueSetComposeIncludeFilter);
  Inherited Insert(index, value);
end;

function TFhirValueSetComposeIncludeFilterList.Item(index: Integer): TFhirValueSetComposeIncludeFilter;
begin
  result := TFhirValueSetComposeIncludeFilter(ObjectByIndex[index]);
end;

function TFhirValueSetComposeIncludeFilterList.Link: TFhirValueSetComposeIncludeFilterList;
begin
  result := TFhirValueSetComposeIncludeFilterList(inherited Link);
end;

procedure TFhirValueSetComposeIncludeFilterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetComposeIncludeFilterList.SetItemByIndex(index: Integer; value: TFhirValueSetComposeIncludeFilter);
begin
  assert(value is TFhirValueSetComposeIncludeFilter);
  FhirValueSetComposeIncludeFilters[index] := value;
end;

procedure TFhirValueSetComposeIncludeFilterList.SetItemN(index: Integer; value: TFhirValueSetComposeIncludeFilter);
begin
  assert(value is TFhirValueSetComposeIncludeFilter);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetExpansion }

constructor TFhirValueSetExpansion.Create;
begin
  inherited;
end;

destructor TFhirValueSetExpansion.Destroy;
begin
  FIdentifier.free;
  FTimestamp.free;
  FTotal.free;
  FOffset.free;
  FParameterList.Free;
  FContainsList.Free;
  inherited;
end;

procedure TFhirValueSetExpansion.Assign(oSource : TFslObject);
begin
  inherited;
  identifierElement := TFhirValueSetExpansion(oSource).identifierElement.Clone;
  timestampElement := TFhirValueSetExpansion(oSource).timestampElement.Clone;
  totalElement := TFhirValueSetExpansion(oSource).totalElement.Clone;
  offsetElement := TFhirValueSetExpansion(oSource).offsetElement.Clone;
  if (TFhirValueSetExpansion(oSource).FParameterList = nil) then
  begin
    FParameterList.free;
    FParameterList := nil;
  end
  else
  begin
    if FParameterList = nil then
      FParameterList := TFhirValueSetExpansionParameterList.Create;
    FParameterList.Assign(TFhirValueSetExpansion(oSource).FParameterList);
  end;
  if (TFhirValueSetExpansion(oSource).FContainsList = nil) then
  begin
    FContainsList.free;
    FContainsList := nil;
  end
  else
  begin
    if FContainsList = nil then
      FContainsList := TFhirValueSetExpansionContainsList.Create;
    FContainsList.Assign(TFhirValueSetExpansion(oSource).FContainsList);
  end;
end;

procedure TFhirValueSetExpansion.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'timestamp') Then
     list.add(self.link, 'timestamp', FTimestamp.Link);
  if (child_name = 'total') Then
     list.add(self.link, 'total', FTotal.Link);
  if (child_name = 'offset') Then
     list.add(self.link, 'offset', FOffset.Link);
  if (child_name = 'parameter') Then
    list.addAll(self, 'parameter', FParameterList);
  if (child_name = 'contains') Then
    list.addAll(self, 'contains', FContainsList);
end;

procedure TFhirValueSetExpansion.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'uri', false, TFhirUri, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'timestamp', 'dateTime', false, TFhirDateTime, FTimestamp.Link));{2}
  oList.add(TFHIRProperty.create(self, 'total', 'integer', false, TFhirInteger, FTotal.Link));{2}
  oList.add(TFHIRProperty.create(self, 'offset', 'integer', false, TFhirInteger, FOffset.Link));{2}
  oList.add(TFHIRProperty.create(self, 'parameter', '', true, TFhirValueSetExpansionParameter, FParameterList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'contains', '', true, TFhirValueSetExpansionContains, FContainsList.Link)){3};
end;

function TFhirValueSetExpansion.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'timestamp') then
  begin
    TimestampElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'total') then
  begin
    TotalElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'offset') then
  begin
    OffsetElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'parameter') then
  begin
    ParameterList.add(propValue as TFhirValueSetExpansionParameter){2a};
    result := propValue;
  end
  else if (propName = 'contains') then
  begin
    ContainsList.add(propValue as TFhirValueSetExpansionContains){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirValueSetExpansion.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'parameter') then ParameterList.insertItem(index, propValue as TFhirValueSetExpansionParameter){2a}
  else if (propName = 'contains') then ContainsList.insertItem(index, propValue as TFhirValueSetExpansionContains){2a}
  else inherited;
end;

function TFhirValueSetExpansion.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirUri.create() {5b}
  else if (propName = 'timestamp') then result := TFhirDateTime.create() {5b}
  else if (propName = 'total') then result := TFhirInteger.create() {5b}
  else if (propName = 'offset') then result := TFhirInteger.create() {5b}
  else if (propName = 'parameter') then result := ParameterList.new(){2}
  else if (propName = 'contains') then result := ContainsList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirValueSetExpansion.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'uri'
  else if (propName = 'timestamp') then result := 'dateTime'
  else if (propName = 'total') then result := 'integer'
  else if (propName = 'offset') then result := 'integer'
  else if (propName = 'parameter') then result := ''
  else if (propName = 'contains') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirValueSetExpansion.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'timestamp') then TimestampElement := nil
  else if (propName = 'total') then TotalElement := nil
  else if (propName = 'offset') then OffsetElement := nil
  else if (propName = 'parameter') then deletePropertyValue('parameter', ParameterList, value) {2}
  else if (propName = 'contains') then deletePropertyValue('contains', ContainsList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirValueSetExpansion.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := asUri(new){5b}
  else if (propName = 'timestamp') then TimestampElement := asDateTime(new){5b}
  else if (propName = 'total') then TotalElement := asInteger(new){5b}
  else if (propName = 'offset') then OffsetElement := asInteger(new){5b}
  else if (propName = 'parameter') then replacePropertyValue('parameter', ParameterList, existing, new) {2}
  else if (propName = 'contains') then replacePropertyValue('contains', ContainsList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirValueSetExpansion.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'parameter') then ParameterList.move(source, destination){2a}
  else if (propName = 'contains') then ContainsList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirValueSetExpansion.fhirType : string;
begin
  result := 'expansion';
end;

function TFhirValueSetExpansion.Link : TFhirValueSetExpansion;
begin
  result := TFhirValueSetExpansion(inherited Link);
end;

function TFhirValueSetExpansion.Clone : TFhirValueSetExpansion;
begin
  result := TFhirValueSetExpansion(inherited Clone);
end;

function TFhirValueSetExpansion.equals(other : TObject) : boolean; 
var
  o : TFhirValueSetExpansion;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirValueSetExpansion)) then
    result := false
  else
  begin
    o := TFhirValueSetExpansion(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(timestampElement, o.timestampElement, true) and 
      compareDeep(totalElement, o.totalElement, true) and compareDeep(offsetElement, o.offsetElement, true) and 
      compareDeep(parameterList, o.parameterList, true) and compareDeep(containsList, o.containsList, true);
  end;
end;

function TFhirValueSetExpansion.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FTimestamp) and isEmptyProp(FTotal) and isEmptyProp(FOffset) and isEmptyProp(FparameterList) and isEmptyProp(FcontainsList);
end;

procedure TFhirValueSetExpansion.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('timestamp');
  fields.add('total');
  fields.add('offset');
  fields.add('parameter');
  fields.add('contains');
end;

{ TFhirValueSetExpansion }

Procedure TFhirValueSetExpansion.SetIdentifier(value : TFhirUri);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Function TFhirValueSetExpansion.GetIdentifierST : String;
begin
  if FIdentifier = nil then
    result := ''
  else
    result := FIdentifier.value;
end;

Procedure TFhirValueSetExpansion.SetIdentifierST(value : String);
begin
  if value <> '' then
  begin
    if FIdentifier = nil then
      FIdentifier := TFhirUri.create;
    FIdentifier.value := value
  end
  else if FIdentifier <> nil then
    FIdentifier.value := '';
end;

Procedure TFhirValueSetExpansion.SetTimestamp(value : TFhirDateTime);
begin
  FTimestamp.free;
  FTimestamp := value;
end;

Function TFhirValueSetExpansion.GetTimestampST : TFslDateTime;
begin
  if FTimestamp = nil then
    result := TFslDateTime.makeNull
  else
    result := FTimestamp.value;
end;

Procedure TFhirValueSetExpansion.SetTimestampST(value : TFslDateTime);
begin
  if FTimestamp = nil then
    FTimestamp := TFhirDateTime.create;
  FTimestamp.value := value
end;

Procedure TFhirValueSetExpansion.SetTotal(value : TFhirInteger);
begin
  FTotal.free;
  FTotal := value;
end;

Function TFhirValueSetExpansion.GetTotalST : String;
begin
  if FTotal = nil then
    result := ''
  else
    result := FTotal.value;
end;

Procedure TFhirValueSetExpansion.SetTotalST(value : String);
begin
  if value <> '' then
  begin
    if FTotal = nil then
      FTotal := TFhirInteger.create;
    FTotal.value := value
  end
  else if FTotal <> nil then
    FTotal.value := '';
end;

Procedure TFhirValueSetExpansion.SetOffset(value : TFhirInteger);
begin
  FOffset.free;
  FOffset := value;
end;

Function TFhirValueSetExpansion.GetOffsetST : String;
begin
  if FOffset = nil then
    result := ''
  else
    result := FOffset.value;
end;

Procedure TFhirValueSetExpansion.SetOffsetST(value : String);
begin
  if value <> '' then
  begin
    if FOffset = nil then
      FOffset := TFhirInteger.create;
    FOffset.value := value
  end
  else if FOffset <> nil then
    FOffset.value := '';
end;

Function TFhirValueSetExpansion.GetParameterList : TFhirValueSetExpansionParameterList;
begin
  if FParameterList = nil then
    FParameterList := TFhirValueSetExpansionParameterList.Create;
  result := FParameterList;
end;

Function TFhirValueSetExpansion.GetHasParameterList : boolean;
begin
  result := (FParameterList <> nil) and (FParameterList.count > 0);
end;

Function TFhirValueSetExpansion.GetContainsList : TFhirValueSetExpansionContainsList;
begin
  if FContainsList = nil then
    FContainsList := TFhirValueSetExpansionContainsList.Create;
  result := FContainsList;
end;

Function TFhirValueSetExpansion.GetHasContainsList : boolean;
begin
  result := (FContainsList <> nil) and (FContainsList.count > 0);
end;

function TFhirValueSetExpansion.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FTimestamp.sizeInBytes);
  inc(result, FTotal.sizeInBytes);
  inc(result, FOffset.sizeInBytes);
  inc(result, FparameterList.sizeInBytes);
  inc(result, FcontainsList.sizeInBytes);
end;

{ TFhirValueSetExpansionListEnumerator }

Constructor TFhirValueSetExpansionListEnumerator.Create(list : TFhirValueSetExpansionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirValueSetExpansionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirValueSetExpansionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirValueSetExpansionListEnumerator.GetCurrent : TFhirValueSetExpansion;
begin
  Result := FList[FIndex];
end;

function TFhirValueSetExpansionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirValueSetExpansionList }
procedure TFhirValueSetExpansionList.AddItem(value: TFhirValueSetExpansion);
begin
  assert(value.ClassName = 'TFhirValueSetExpansion', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetExpansion');
  add(value);
end;

function TFhirValueSetExpansionList.Append: TFhirValueSetExpansion;
begin
  result := TFhirValueSetExpansion.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetExpansionList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetExpansionList.GetEnumerator : TFhirValueSetExpansionListEnumerator;
begin
  result := TFhirValueSetExpansionListEnumerator.Create(self.link);
end;

function TFhirValueSetExpansionList.Clone: TFhirValueSetExpansionList;
begin
  result := TFhirValueSetExpansionList(inherited Clone);
end;

function TFhirValueSetExpansionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetExpansionList.GetItemN(index: Integer): TFhirValueSetExpansion;
begin
  result := TFhirValueSetExpansion(ObjectByIndex[index]);
end;

function TFhirValueSetExpansionList.ItemClass: TFslObjectClass;
begin
  result := TFhirValueSetExpansion;
end;
function TFhirValueSetExpansionList.IndexOf(value: TFhirValueSetExpansion): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirValueSetExpansionList.Insert(index: Integer): TFhirValueSetExpansion;
begin
  result := TFhirValueSetExpansion.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetExpansionList.InsertItem(index: Integer; value: TFhirValueSetExpansion);
begin
  assert(value is TFhirValueSetExpansion);
  Inherited Insert(index, value);
end;

function TFhirValueSetExpansionList.Item(index: Integer): TFhirValueSetExpansion;
begin
  result := TFhirValueSetExpansion(ObjectByIndex[index]);
end;

function TFhirValueSetExpansionList.Link: TFhirValueSetExpansionList;
begin
  result := TFhirValueSetExpansionList(inherited Link);
end;

procedure TFhirValueSetExpansionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetExpansionList.SetItemByIndex(index: Integer; value: TFhirValueSetExpansion);
begin
  assert(value is TFhirValueSetExpansion);
  FhirValueSetExpansions[index] := value;
end;

procedure TFhirValueSetExpansionList.SetItemN(index: Integer; value: TFhirValueSetExpansion);
begin
  assert(value is TFhirValueSetExpansion);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetExpansionParameter }

constructor TFhirValueSetExpansionParameter.Create;
begin
  inherited;
end;

destructor TFhirValueSetExpansionParameter.Destroy;
begin
  FName.free;
  FValue.free;
  inherited;
end;

procedure TFhirValueSetExpansionParameter.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirValueSetExpansionParameter(oSource).nameElement.Clone;
  value := TFhirValueSetExpansionParameter(oSource).value.Clone;
end;

procedure TFhirValueSetExpansionParameter.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirValueSetExpansionParameter.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value[x]', 'string|boolean|integer|decimal|uri|code', false, TFhirType, FValue.Link));{2}
end;

function TFhirValueSetExpansionParameter.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['String', 'Boolean', 'Integer', 'Decimal', 'Uri', 'Code'])) then
  begin
    Value := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirValueSetExpansionParameter.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirValueSetExpansionParameter.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (isMatchingName(propName, 'value', ['String', 'Boolean', 'Integer', 'Decimal', 'Uri', 'Code'])) then raise EFHIRException.create('Cannot make property Value'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirValueSetExpansionParameter.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'value[x]') then result := 'string|boolean|integer|decimal|uri|code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirValueSetExpansionParameter.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (isMatchingName(propName, 'value', ['String', 'Boolean', 'Integer', 'Decimal', 'Uri', 'Code'])) then ValueElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirValueSetExpansionParameter.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (isMatchingName(propName, 'value', ['String', 'Boolean', 'Integer', 'Decimal', 'Uri', 'Code'])) then ValueElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirValueSetExpansionParameter.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirValueSetExpansionParameter.fhirType : string;
begin
  result := 'parameter';
end;

function TFhirValueSetExpansionParameter.Link : TFhirValueSetExpansionParameter;
begin
  result := TFhirValueSetExpansionParameter(inherited Link);
end;

function TFhirValueSetExpansionParameter.Clone : TFhirValueSetExpansionParameter;
begin
  result := TFhirValueSetExpansionParameter(inherited Clone);
end;

function TFhirValueSetExpansionParameter.equals(other : TObject) : boolean; 
var
  o : TFhirValueSetExpansionParameter;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirValueSetExpansionParameter)) then
    result := false
  else
  begin
    o := TFhirValueSetExpansionParameter(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirValueSetExpansionParameter.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FValue);
end;

procedure TFhirValueSetExpansionParameter.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('value[x]');
end;

{ TFhirValueSetExpansionParameter }

Procedure TFhirValueSetExpansionParameter.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirValueSetExpansionParameter.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirValueSetExpansionParameter.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirValueSetExpansionParameter.SetValue(value : TFhirType);
begin
  FValue.free;
  FValue := value;
end;

function TFhirValueSetExpansionParameter.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirValueSetExpansionParameterListEnumerator }

Constructor TFhirValueSetExpansionParameterListEnumerator.Create(list : TFhirValueSetExpansionParameterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirValueSetExpansionParameterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirValueSetExpansionParameterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirValueSetExpansionParameterListEnumerator.GetCurrent : TFhirValueSetExpansionParameter;
begin
  Result := FList[FIndex];
end;

function TFhirValueSetExpansionParameterListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirValueSetExpansionParameterList }
procedure TFhirValueSetExpansionParameterList.AddItem(value: TFhirValueSetExpansionParameter);
begin
  assert(value.ClassName = 'TFhirValueSetExpansionParameter', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetExpansionParameter');
  add(value);
end;

function TFhirValueSetExpansionParameterList.Append: TFhirValueSetExpansionParameter;
begin
  result := TFhirValueSetExpansionParameter.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetExpansionParameterList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetExpansionParameterList.GetEnumerator : TFhirValueSetExpansionParameterListEnumerator;
begin
  result := TFhirValueSetExpansionParameterListEnumerator.Create(self.link);
end;

function TFhirValueSetExpansionParameterList.Clone: TFhirValueSetExpansionParameterList;
begin
  result := TFhirValueSetExpansionParameterList(inherited Clone);
end;

function TFhirValueSetExpansionParameterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetExpansionParameterList.GetItemN(index: Integer): TFhirValueSetExpansionParameter;
begin
  result := TFhirValueSetExpansionParameter(ObjectByIndex[index]);
end;

function TFhirValueSetExpansionParameterList.ItemClass: TFslObjectClass;
begin
  result := TFhirValueSetExpansionParameter;
end;
function TFhirValueSetExpansionParameterList.IndexOf(value: TFhirValueSetExpansionParameter): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirValueSetExpansionParameterList.Insert(index: Integer): TFhirValueSetExpansionParameter;
begin
  result := TFhirValueSetExpansionParameter.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetExpansionParameterList.InsertItem(index: Integer; value: TFhirValueSetExpansionParameter);
begin
  assert(value is TFhirValueSetExpansionParameter);
  Inherited Insert(index, value);
end;

function TFhirValueSetExpansionParameterList.Item(index: Integer): TFhirValueSetExpansionParameter;
begin
  result := TFhirValueSetExpansionParameter(ObjectByIndex[index]);
end;

function TFhirValueSetExpansionParameterList.Link: TFhirValueSetExpansionParameterList;
begin
  result := TFhirValueSetExpansionParameterList(inherited Link);
end;

procedure TFhirValueSetExpansionParameterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetExpansionParameterList.SetItemByIndex(index: Integer; value: TFhirValueSetExpansionParameter);
begin
  assert(value is TFhirValueSetExpansionParameter);
  FhirValueSetExpansionParameters[index] := value;
end;

procedure TFhirValueSetExpansionParameterList.SetItemN(index: Integer; value: TFhirValueSetExpansionParameter);
begin
  assert(value is TFhirValueSetExpansionParameter);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetExpansionContains }

constructor TFhirValueSetExpansionContains.Create;
begin
  inherited;
end;

destructor TFhirValueSetExpansionContains.Destroy;
begin
  FSystem.free;
  FAbstract.free;
  FVersion.free;
  FCode.free;
  FDisplay.free;
  FContainsList.Free;
  inherited;
end;

procedure TFhirValueSetExpansionContains.Assign(oSource : TFslObject);
begin
  inherited;
  systemElement := TFhirValueSetExpansionContains(oSource).systemElement.Clone;
  abstractElement := TFhirValueSetExpansionContains(oSource).abstractElement.Clone;
  versionElement := TFhirValueSetExpansionContains(oSource).versionElement.Clone;
  codeElement := TFhirValueSetExpansionContains(oSource).codeElement.Clone;
  displayElement := TFhirValueSetExpansionContains(oSource).displayElement.Clone;
  if (TFhirValueSetExpansionContains(oSource).FContainsList = nil) then
  begin
    FContainsList.free;
    FContainsList := nil;
  end
  else
  begin
    if FContainsList = nil then
      FContainsList := TFhirValueSetExpansionContainsList.Create;
    FContainsList.Assign(TFhirValueSetExpansionContains(oSource).FContainsList);
  end;
end;

procedure TFhirValueSetExpansionContains.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'system') Then
     list.add(self.link, 'system', FSystem.Link);
  if (child_name = 'abstract') Then
     list.add(self.link, 'abstract', FAbstract.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'display') Then
     list.add(self.link, 'display', FDisplay.Link);
  if (child_name = 'contains') Then
    list.addAll(self, 'contains', FContainsList);
end;

procedure TFhirValueSetExpansionContains.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'system', 'uri', false, TFhirUri, FSystem.Link));{2}
  oList.add(TFHIRProperty.create(self, 'abstract', 'boolean', false, TFhirBoolean, FAbstract.Link));{2}
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirCode, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'display', 'string', false, TFhirString, FDisplay.Link));{2}
  oList.add(TFHIRProperty.create(self, 'contains', '@ValueSet.expansion.contains', true, TFhirValueSetExpansionContains, FContainsList.Link)){3};
end;

function TFhirValueSetExpansionContains.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'system') then
  begin
    SystemElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'abstract') then
  begin
    AbstractElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'display') then
  begin
    DisplayElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'contains') then
  begin
    ContainsList.add(propValue as TFhirValueSetExpansionContains){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirValueSetExpansionContains.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'contains') then ContainsList.insertItem(index, propValue as TFhirValueSetExpansionContains){2a}
  else inherited;
end;

function TFhirValueSetExpansionContains.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'system') then result := TFhirUri.create() {5b}
  else if (propName = 'abstract') then result := TFhirBoolean.create() {5b}
  else if (propName = 'version') then result := TFhirString.create() {5b}
  else if (propName = 'code') then result := TFhirCode.create() {5b}
  else if (propName = 'display') then result := TFhirString.create() {5b}
  else if (propName = 'contains') then result := ContainsList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirValueSetExpansionContains.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'system') then result := 'uri'
  else if (propName = 'abstract') then result := 'boolean'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'code') then result := 'code'
  else if (propName = 'display') then result := 'string'
  else if (propName = 'contains') then result := '@ValueSet.expansion.contains'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirValueSetExpansionContains.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'system') then SystemElement := nil
  else if (propName = 'abstract') then AbstractElement := nil
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'display') then DisplayElement := nil
  else if (propName = 'contains') then deletePropertyValue('contains', ContainsList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirValueSetExpansionContains.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'system') then SystemElement := asUri(new){5b}
  else if (propName = 'abstract') then AbstractElement := asBoolean(new){5b}
  else if (propName = 'version') then VersionElement := asString(new){5b}
  else if (propName = 'code') then CodeElement := asCode(new){5b}
  else if (propName = 'display') then DisplayElement := asString(new){5b}
  else if (propName = 'contains') then replacePropertyValue('contains', ContainsList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirValueSetExpansionContains.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'contains') then ContainsList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirValueSetExpansionContains.fhirType : string;
begin
  result := 'contains';
end;

function TFhirValueSetExpansionContains.Link : TFhirValueSetExpansionContains;
begin
  result := TFhirValueSetExpansionContains(inherited Link);
end;

function TFhirValueSetExpansionContains.Clone : TFhirValueSetExpansionContains;
begin
  result := TFhirValueSetExpansionContains(inherited Clone);
end;

function TFhirValueSetExpansionContains.equals(other : TObject) : boolean; 
var
  o : TFhirValueSetExpansionContains;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirValueSetExpansionContains)) then
    result := false
  else
  begin
    o := TFhirValueSetExpansionContains(other);
    result := compareDeep(systemElement, o.systemElement, true) and compareDeep(abstractElement, o.abstractElement, true) and 
      compareDeep(versionElement, o.versionElement, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(displayElement, o.displayElement, true) and compareDeep(containsList, o.containsList, true);
  end;
end;

function TFhirValueSetExpansionContains.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSystem) and isEmptyProp(FAbstract) and isEmptyProp(FVersion) and isEmptyProp(FCode) and isEmptyProp(FDisplay) and isEmptyProp(FcontainsList);
end;

procedure TFhirValueSetExpansionContains.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('system');
  fields.add('abstract');
  fields.add('version');
  fields.add('code');
  fields.add('display');
  fields.add('contains');
end;

{ TFhirValueSetExpansionContains }

Procedure TFhirValueSetExpansionContains.SetSystem(value : TFhirUri);
begin
  FSystem.free;
  FSystem := value;
end;

Function TFhirValueSetExpansionContains.GetSystemST : String;
begin
  if FSystem = nil then
    result := ''
  else
    result := FSystem.value;
end;

Procedure TFhirValueSetExpansionContains.SetSystemST(value : String);
begin
  if value <> '' then
  begin
    if FSystem = nil then
      FSystem := TFhirUri.create;
    FSystem.value := value
  end
  else if FSystem <> nil then
    FSystem.value := '';
end;

Procedure TFhirValueSetExpansionContains.SetAbstract(value : TFhirBoolean);
begin
  FAbstract.free;
  FAbstract := value;
end;

Function TFhirValueSetExpansionContains.GetAbstractST : Boolean;
begin
  if FAbstract = nil then
    result := false
  else
    result := FAbstract.value;
end;

Procedure TFhirValueSetExpansionContains.SetAbstractST(value : Boolean);
begin
  if FAbstract = nil then
    FAbstract := TFhirBoolean.create;
  FAbstract.value := value
end;

Procedure TFhirValueSetExpansionContains.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

Function TFhirValueSetExpansionContains.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

Procedure TFhirValueSetExpansionContains.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

Procedure TFhirValueSetExpansionContains.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirValueSetExpansionContains.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

Procedure TFhirValueSetExpansionContains.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

Procedure TFhirValueSetExpansionContains.SetDisplay(value : TFhirString);
begin
  FDisplay.free;
  FDisplay := value;
end;

Function TFhirValueSetExpansionContains.GetDisplayST : String;
begin
  if FDisplay = nil then
    result := ''
  else
    result := FDisplay.value;
end;

Procedure TFhirValueSetExpansionContains.SetDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FDisplay = nil then
      FDisplay := TFhirString.create;
    FDisplay.value := value
  end
  else if FDisplay <> nil then
    FDisplay.value := '';
end;

Function TFhirValueSetExpansionContains.GetContainsList : TFhirValueSetExpansionContainsList;
begin
  if FContainsList = nil then
    FContainsList := TFhirValueSetExpansionContainsList.Create;
  result := FContainsList;
end;

Function TFhirValueSetExpansionContains.GetHasContainsList : boolean;
begin
  result := (FContainsList <> nil) and (FContainsList.count > 0);
end;

function TFhirValueSetExpansionContains.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSystem.sizeInBytes);
  inc(result, FAbstract.sizeInBytes);
  inc(result, FVersion.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FDisplay.sizeInBytes);
  inc(result, FcontainsList.sizeInBytes);
end;

{ TFhirValueSetExpansionContainsListEnumerator }

Constructor TFhirValueSetExpansionContainsListEnumerator.Create(list : TFhirValueSetExpansionContainsList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirValueSetExpansionContainsListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirValueSetExpansionContainsListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirValueSetExpansionContainsListEnumerator.GetCurrent : TFhirValueSetExpansionContains;
begin
  Result := FList[FIndex];
end;

function TFhirValueSetExpansionContainsListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirValueSetExpansionContainsList }
procedure TFhirValueSetExpansionContainsList.AddItem(value: TFhirValueSetExpansionContains);
begin
  assert(value.ClassName = 'TFhirValueSetExpansionContains', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetExpansionContains');
  add(value);
end;

function TFhirValueSetExpansionContainsList.Append: TFhirValueSetExpansionContains;
begin
  result := TFhirValueSetExpansionContains.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetExpansionContainsList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetExpansionContainsList.GetEnumerator : TFhirValueSetExpansionContainsListEnumerator;
begin
  result := TFhirValueSetExpansionContainsListEnumerator.Create(self.link);
end;

function TFhirValueSetExpansionContainsList.Clone: TFhirValueSetExpansionContainsList;
begin
  result := TFhirValueSetExpansionContainsList(inherited Clone);
end;

function TFhirValueSetExpansionContainsList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetExpansionContainsList.GetItemN(index: Integer): TFhirValueSetExpansionContains;
begin
  result := TFhirValueSetExpansionContains(ObjectByIndex[index]);
end;

function TFhirValueSetExpansionContainsList.ItemClass: TFslObjectClass;
begin
  result := TFhirValueSetExpansionContains;
end;
function TFhirValueSetExpansionContainsList.IndexOf(value: TFhirValueSetExpansionContains): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirValueSetExpansionContainsList.Insert(index: Integer): TFhirValueSetExpansionContains;
begin
  result := TFhirValueSetExpansionContains.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetExpansionContainsList.InsertItem(index: Integer; value: TFhirValueSetExpansionContains);
begin
  assert(value is TFhirValueSetExpansionContains);
  Inherited Insert(index, value);
end;

function TFhirValueSetExpansionContainsList.Item(index: Integer): TFhirValueSetExpansionContains;
begin
  result := TFhirValueSetExpansionContains(ObjectByIndex[index]);
end;

function TFhirValueSetExpansionContainsList.Link: TFhirValueSetExpansionContainsList;
begin
  result := TFhirValueSetExpansionContainsList(inherited Link);
end;

procedure TFhirValueSetExpansionContainsList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetExpansionContainsList.SetItemByIndex(index: Integer; value: TFhirValueSetExpansionContains);
begin
  assert(value is TFhirValueSetExpansionContains);
  FhirValueSetExpansionContains[index] := value;
end;

procedure TFhirValueSetExpansionContainsList.SetItemN(index: Integer; value: TFhirValueSetExpansionContains);
begin
  assert(value is TFhirValueSetExpansionContains);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSet }

constructor TFhirValueSet.Create;
begin
  inherited;
end;

destructor TFhirValueSet.Destroy;
begin
  FUrl.free;
  FIdentifier.free;
  FVersion.free;
  FName.free;
  FStatus.free;
  FExperimental.free;
  FPublisher.free;
  FContactList.Free;
  FDate.free;
  FLockedDate.free;
  FDescription.free;
  FUseContextList.Free;
  FImmutable.free;
  FRequirements.free;
  FCopyright.free;
  FExtensible.free;
  FCodeSystem.free;
  FCompose.free;
  FExpansion.free;
  inherited;
end;

function TFhirValueSet.GetResourceType : TFhirResourceType;
begin
  result := frtValueSet;
end;

procedure TFhirValueSet.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirValueSet(oSource).urlElement.Clone;
  identifier := TFhirValueSet(oSource).identifier.Clone;
  versionElement := TFhirValueSet(oSource).versionElement.Clone;
  nameElement := TFhirValueSet(oSource).nameElement.Clone;
  FStatus := TFhirValueSet(oSource).FStatus.Link;
  experimentalElement := TFhirValueSet(oSource).experimentalElement.Clone;
  publisherElement := TFhirValueSet(oSource).publisherElement.Clone;
  if (TFhirValueSet(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirValueSetContactList.Create;
    FContactList.Assign(TFhirValueSet(oSource).FContactList);
  end;
  dateElement := TFhirValueSet(oSource).dateElement.Clone;
  lockedDateElement := TFhirValueSet(oSource).lockedDateElement.Clone;
  descriptionElement := TFhirValueSet(oSource).descriptionElement.Clone;
  if (TFhirValueSet(oSource).FUseContextList = nil) then
  begin
    FUseContextList.free;
    FUseContextList := nil;
  end
  else
  begin
    if FUseContextList = nil then
      FUseContextList := TFhirCodeableConceptList.Create;
    FUseContextList.Assign(TFhirValueSet(oSource).FUseContextList);
  end;
  immutableElement := TFhirValueSet(oSource).immutableElement.Clone;
  requirementsElement := TFhirValueSet(oSource).requirementsElement.Clone;
  copyrightElement := TFhirValueSet(oSource).copyrightElement.Clone;
  extensibleElement := TFhirValueSet(oSource).extensibleElement.Clone;
  codeSystem := TFhirValueSet(oSource).codeSystem.Clone;
  compose := TFhirValueSet(oSource).compose.Clone;
  expansion := TFhirValueSet(oSource).expansion.Clone;
end;

procedure TFhirValueSet.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'experimental') Then
     list.add(self.link, 'experimental', FExperimental.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'lockedDate') Then
     list.add(self.link, 'lockedDate', FLockedDate.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'useContext') Then
    list.addAll(self, 'useContext', FUseContextList);
  if (child_name = 'immutable') Then
     list.add(self.link, 'immutable', FImmutable.Link);
  if (child_name = 'requirements') Then
     list.add(self.link, 'requirements', FRequirements.Link);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'extensible') Then
     list.add(self.link, 'extensible', FExtensible.Link);
  if (child_name = 'codeSystem') Then
     list.add(self.link, 'codeSystem', FCodeSystem.Link);
  if (child_name = 'compose') Then
     list.add(self.link, 'compose', FCompose.Link);
  if (child_name = 'expansion') Then
     list.add(self.link, 'expansion', FExpansion.Link);
end;

procedure TFhirValueSet.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));{2}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'experimental', 'boolean', false, TFhirBoolean, FExperimental.Link));{2}
  oList.add(TFHIRProperty.create(self, 'publisher', 'string', false, TFhirString, FPublisher.Link));{2}
  oList.add(TFHIRProperty.create(self, 'contact', '', true, TFhirValueSetContact, FContactList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'lockedDate', 'date', false, TFhirDate, FLockedDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'useContext', 'CodeableConcept', true, TFhirCodeableConcept, FUseContextList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'immutable', 'boolean', false, TFhirBoolean, FImmutable.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requirements', 'string', false, TFhirString, FRequirements.Link));{2}
  oList.add(TFHIRProperty.create(self, 'copyright', 'string', false, TFhirString, FCopyright.Link));{2}
  oList.add(TFHIRProperty.create(self, 'extensible', 'boolean', false, TFhirBoolean, FExtensible.Link));{2}
  oList.add(TFHIRProperty.create(self, 'codeSystem', '', false, TFhirValueSetCodeSystem, FCodeSystem.Link));{2}
  oList.add(TFHIRProperty.create(self, 'compose', '', false, TFhirValueSetCompose, FCompose.Link));{2}
  oList.add(TFHIRProperty.create(self, 'expansion', '', false, TFhirValueSetExpansion, FExpansion.Link));{2}
end;

function TFhirValueSet.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirConformanceResourceStatusEnum, CODES_TFhirConformanceResourceStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'experimental') then
  begin
    ExperimentalElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    PublisherElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirValueSetContact){2a};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'lockedDate') then
  begin
    LockedDateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'useContext') then
  begin
    UseContextList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'immutable') then
  begin
    ImmutableElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'requirements') then
  begin
    RequirementsElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'extensible') then
  begin
    ExtensibleElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'codeSystem') then
  begin
    CodeSystem := propValue as TFhirValueSetCodeSystem{4b};
    result := propValue;
  end
  else if (propName = 'compose') then
  begin
    Compose := propValue as TFhirValueSetCompose{4b};
    result := propValue;
  end
  else if (propName = 'expansion') then
  begin
    Expansion := propValue as TFhirValueSetExpansion{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirValueSet.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirValueSetContact){2a}
  else if (propName = 'useContext') then UseContextList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirValueSet.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create() {5b}
  else if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'version') then result := TFhirString.create() {5b}
  else if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'experimental') then result := TFhirBoolean.create() {5b}
  else if (propName = 'publisher') then result := TFhirString.create() {5b}
  else if (propName = 'contact') then result := ContactList.new(){2}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'lockedDate') then result := TFhirDate.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'useContext') then result := UseContextList.new(){2}
  else if (propName = 'immutable') then result := TFhirBoolean.create() {5b}
  else if (propName = 'requirements') then result := TFhirString.create() {5b}
  else if (propName = 'copyright') then result := TFhirString.create() {5b}
  else if (propName = 'extensible') then result := TFhirBoolean.create() {5b}
  else if (propName = 'codeSystem') then result := TFhirValueSetCodeSystem.create(){4b}
  else if (propName = 'compose') then result := TFhirValueSetCompose.create(){4b}
  else if (propName = 'expansion') then result := TFhirValueSetExpansion.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirValueSet.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'uri'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'experimental') then result := 'boolean'
  else if (propName = 'publisher') then result := 'string'
  else if (propName = 'contact') then result := ''
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'lockedDate') then result := 'date'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'useContext') then result := 'CodeableConcept'
  else if (propName = 'immutable') then result := 'boolean'
  else if (propName = 'requirements') then result := 'string'
  else if (propName = 'copyright') then result := 'string'
  else if (propName = 'extensible') then result := 'boolean'
  else if (propName = 'codeSystem') then result := ''
  else if (propName = 'compose') then result := ''
  else if (propName = 'expansion') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirValueSet.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'experimental') then ExperimentalElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value) {2}
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'lockedDate') then LockedDateElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'useContext') then deletePropertyValue('useContext', UseContextList, value) {2}
  else if (propName = 'immutable') then ImmutableElement := nil
  else if (propName = 'requirements') then RequirementsElement := nil
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'extensible') then ExtensibleElement := nil
  else if (propName = 'codeSystem') then CodeSystemElement := nil
  else if (propName = 'compose') then ComposeElement := nil
  else if (propName = 'expansion') then ExpansionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirValueSet.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asUri(new){5b}
  else if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'version') then VersionElement := asString(new){5b}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirConformanceResourceStatusEnum, CODES_TFhirConformanceResourceStatusEnum, new){4}
  else if (propName = 'experimental') then ExperimentalElement := asBoolean(new){5b}
  else if (propName = 'publisher') then PublisherElement := asString(new){5b}
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new) {2}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'lockedDate') then LockedDateElement := asDate(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'useContext') then replacePropertyValue('useContext', UseContextList, existing, new) {2}
  else if (propName = 'immutable') then ImmutableElement := asBoolean(new){5b}
  else if (propName = 'requirements') then RequirementsElement := asString(new){5b}
  else if (propName = 'copyright') then CopyrightElement := asString(new){5b}
  else if (propName = 'extensible') then ExtensibleElement := asBoolean(new){5b}
  else if (propName = 'codeSystem') then CodeSystemElement := new as TFhirValueSetCodeSystem{4}
  else if (propName = 'compose') then ComposeElement := new as TFhirValueSetCompose{4}
  else if (propName = 'expansion') then ExpansionElement := new as TFhirValueSetExpansion{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirValueSet.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'contact') then ContactList.move(source, destination){2a}
  else if (propName = 'useContext') then UseContextList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirValueSet.fhirType : string;
begin
  result := 'ValueSet';
end;

function TFhirValueSet.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FIdentifier) and isEmptyProp(FVersion) and isEmptyProp(FName) and isEmptyProp(FStatus) and isEmptyProp(FExperimental) and isEmptyProp(FPublisher) and isEmptyProp(FcontactList) and isEmptyProp(FDate) and isEmptyProp(FLockedDate) and isEmptyProp(FDescription) and isEmptyProp(FuseContextList) and isEmptyProp(FImmutable) and isEmptyProp(FRequirements) and isEmptyProp(FCopyright) and isEmptyProp(FExtensible) and isEmptyProp(FCodeSystem) and isEmptyProp(FCompose) and isEmptyProp(FExpansion);
end;

function TFhirValueSet.equals(other : TObject) : boolean; 
var
  o : TFhirValueSet;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirValueSet)) then
    result := false
  else
  begin
    o := TFhirValueSet(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(identifierElement, o.identifierElement, true) and 
      compareDeep(versionElement, o.versionElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(experimentalElement, o.experimentalElement, true) and 
      compareDeep(publisherElement, o.publisherElement, true) and compareDeep(contactList, o.contactList, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(lockedDateElement, o.lockedDateElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(useContextList, o.useContextList, true) and 
      compareDeep(immutableElement, o.immutableElement, true) and compareDeep(requirementsElement, o.requirementsElement, true) and 
      compareDeep(copyrightElement, o.copyrightElement, true) and compareDeep(extensibleElement, o.extensibleElement, true) and 
      compareDeep(codeSystemElement, o.codeSystemElement, true) and compareDeep(composeElement, o.composeElement, true) and 
      compareDeep(expansionElement, o.expansionElement, true);
  end;
end;

function TFhirValueSet.Link : TFhirValueSet;
begin
  result := TFhirValueSet(inherited Link);
end;

function TFhirValueSet.Clone : TFhirValueSet;
begin
  result := TFhirValueSet(inherited Clone);
end;

procedure TFhirValueSet.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('status');
  fields.add('experimental');
  fields.add('publisher');
  fields.add('contact');
  fields.add('date');
  fields.add('lockedDate');
  fields.add('description');
  fields.add('useContext');
  fields.add('immutable');
  fields.add('requirements');
  fields.add('copyright');
  fields.add('extensible');
  fields.add('codeSystem');
  fields.add('compose');
  fields.add('expansion');
end;

{ TFhirValueSet }

Procedure TFhirValueSet.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirValueSet.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

Procedure TFhirValueSet.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

Procedure TFhirValueSet.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirValueSet.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

Function TFhirValueSet.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

Procedure TFhirValueSet.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

Procedure TFhirValueSet.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirValueSet.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirValueSet.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirValueSet.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirValueSet.GetStatusST : TFhirConformanceResourceStatusEnum;
begin
  if FStatus = nil then
    result := TFhirConformanceResourceStatusEnum(0)
  else
    result := TFhirConformanceResourceStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirConformanceResourceStatusEnum, FStatus.value));
end;

Procedure TFhirValueSet.SetStatusST(value : TFhirConformanceResourceStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirConformanceResourceStatusEnum[value], CODES_TFhirConformanceResourceStatusEnum[value]);
end;

Procedure TFhirValueSet.SetExperimental(value : TFhirBoolean);
begin
  FExperimental.free;
  FExperimental := value;
end;

Function TFhirValueSet.GetExperimentalST : Boolean;
begin
  if FExperimental = nil then
    result := false
  else
    result := FExperimental.value;
end;

Procedure TFhirValueSet.SetExperimentalST(value : Boolean);
begin
  if FExperimental = nil then
    FExperimental := TFhirBoolean.create;
  FExperimental.value := value
end;

Procedure TFhirValueSet.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

Function TFhirValueSet.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

Procedure TFhirValueSet.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

Function TFhirValueSet.GetContactList : TFhirValueSetContactList;
begin
  if FContactList = nil then
    FContactList := TFhirValueSetContactList.Create;
  result := FContactList;
end;

Function TFhirValueSet.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

Procedure TFhirValueSet.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirValueSet.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirValueSet.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirValueSet.SetLockedDate(value : TFhirDate);
begin
  FLockedDate.free;
  FLockedDate := value;
end;

Function TFhirValueSet.GetLockedDateST : TFslDateTime;
begin
  if FLockedDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FLockedDate.value;
end;

Procedure TFhirValueSet.SetLockedDateST(value : TFslDateTime);
begin
  if FLockedDate = nil then
    FLockedDate := TFhirDate.create;
  FLockedDate.value := value
end;

Procedure TFhirValueSet.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirValueSet.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirValueSet.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Function TFhirValueSet.GetUseContextList : TFhirCodeableConceptList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirCodeableConceptList.Create;
  result := FUseContextList;
end;

Function TFhirValueSet.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

Procedure TFhirValueSet.SetImmutable(value : TFhirBoolean);
begin
  FImmutable.free;
  FImmutable := value;
end;

Function TFhirValueSet.GetImmutableST : Boolean;
begin
  if FImmutable = nil then
    result := false
  else
    result := FImmutable.value;
end;

Procedure TFhirValueSet.SetImmutableST(value : Boolean);
begin
  if FImmutable = nil then
    FImmutable := TFhirBoolean.create;
  FImmutable.value := value
end;

Procedure TFhirValueSet.SetRequirements(value : TFhirString);
begin
  FRequirements.free;
  FRequirements := value;
end;

Function TFhirValueSet.GetRequirementsST : String;
begin
  if FRequirements = nil then
    result := ''
  else
    result := FRequirements.value;
end;

Procedure TFhirValueSet.SetRequirementsST(value : String);
begin
  if value <> '' then
  begin
    if FRequirements = nil then
      FRequirements := TFhirString.create;
    FRequirements.value := value
  end
  else if FRequirements <> nil then
    FRequirements.value := '';
end;

Procedure TFhirValueSet.SetCopyright(value : TFhirString);
begin
  FCopyright.free;
  FCopyright := value;
end;

Function TFhirValueSet.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

Procedure TFhirValueSet.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirString.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

Procedure TFhirValueSet.SetExtensible(value : TFhirBoolean);
begin
  FExtensible.free;
  FExtensible := value;
end;

Function TFhirValueSet.GetExtensibleST : Boolean;
begin
  if FExtensible = nil then
    result := false
  else
    result := FExtensible.value;
end;

Procedure TFhirValueSet.SetExtensibleST(value : Boolean);
begin
  if FExtensible = nil then
    FExtensible := TFhirBoolean.create;
  FExtensible.value := value
end;

Procedure TFhirValueSet.SetCodeSystem(value : TFhirValueSetCodeSystem);
begin
  FCodeSystem.free;
  FCodeSystem := value;
end;

Procedure TFhirValueSet.SetCompose(value : TFhirValueSetCompose);
begin
  FCompose.free;
  FCompose := value;
end;

Procedure TFhirValueSet.SetExpansion(value : TFhirValueSetExpansion);
begin
  FExpansion.free;
  FExpansion := value;
end;

function TFhirValueSet.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FUrl.sizeInBytes);
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FVersion.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FExperimental.sizeInBytes);
  inc(result, FPublisher.sizeInBytes);
  inc(result, FcontactList.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FLockedDate.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FuseContextList.sizeInBytes);
  inc(result, FImmutable.sizeInBytes);
  inc(result, FRequirements.sizeInBytes);
  inc(result, FCopyright.sizeInBytes);
  inc(result, FExtensible.sizeInBytes);
  inc(result, FCodeSystem.sizeInBytes);
  inc(result, FCompose.sizeInBytes);
  inc(result, FExpansion.sizeInBytes);
end;

{ TFhirValueSetListEnumerator }

Constructor TFhirValueSetListEnumerator.Create(list : TFhirValueSetList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirValueSetListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirValueSetListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirValueSetListEnumerator.GetCurrent : TFhirValueSet;
begin
  Result := FList[FIndex];
end;

function TFhirValueSetListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirValueSetList }
procedure TFhirValueSetList.AddItem(value: TFhirValueSet);
begin
  assert(value.ClassName = 'TFhirValueSet', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSet');
  add(value);
end;

function TFhirValueSetList.Append: TFhirValueSet;
begin
  result := TFhirValueSet.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetList.GetEnumerator : TFhirValueSetListEnumerator;
begin
  result := TFhirValueSetListEnumerator.Create(self.link);
end;

function TFhirValueSetList.Clone: TFhirValueSetList;
begin
  result := TFhirValueSetList(inherited Clone);
end;

function TFhirValueSetList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetList.GetItemN(index: Integer): TFhirValueSet;
begin
  result := TFhirValueSet(ObjectByIndex[index]);
end;

function TFhirValueSetList.ItemClass: TFslObjectClass;
begin
  result := TFhirValueSet;
end;
function TFhirValueSetList.IndexOf(value: TFhirValueSet): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirValueSetList.Insert(index: Integer): TFhirValueSet;
begin
  result := TFhirValueSet.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetList.InsertItem(index: Integer; value: TFhirValueSet);
begin
  assert(value is TFhirValueSet);
  Inherited Insert(index, value);
end;

function TFhirValueSetList.Item(index: Integer): TFhirValueSet;
begin
  result := TFhirValueSet(ObjectByIndex[index]);
end;

function TFhirValueSetList.Link: TFhirValueSetList;
begin
  result := TFhirValueSetList(inherited Link);
end;

procedure TFhirValueSetList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetList.SetItemByIndex(index: Integer; value: TFhirValueSet);
begin
  assert(value is TFhirValueSet);
  FhirValueSets[index] := value;
end;

procedure TFhirValueSetList.SetItemN(index: Integer; value: TFhirValueSet);
begin
  assert(value is TFhirValueSet);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_VALUESET}

{ TFHIRMetadataResource }

function TFHIRMetadataResource.link: TFHIRMetadataResource;
begin
  result := TFHIRMetadataResource(inherited link);
end;

end.

