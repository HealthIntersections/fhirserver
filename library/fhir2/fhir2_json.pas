unit fhir2_json;

{
  Copyright (c) 2011+, HL7 and Health Intersections Pty Ltd (http://www.healthintersections.com.au)
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
}

{$I fhir.inc}
{$I fhir2.inc}

interface

// FHIR v1.0.2 generated 2015-10-24T07:41:03+11:00

uses
  SysUtils, Classes,
  fsl_base, fsl_utilities,
  fhir_parser, fhir_objects, fsl_collections, fsl_json,
  fhir2_parserBase, fhir2_resources, fhir2_constants, fhir2_types,
  fhir2_resources_base, fhir2_resources_admin, fhir2_resources_clinical, fhir2_resources_canonical, fhir2_resources_other;

Type

  TFHIRJsonParser = class (TFHIRJsonParserBase2)
  protected
    function ParseElement(jsn : TJsonObject) : TFhirElement; overload;
    procedure ParseElement(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}

    procedure ParseElementProperties(jsn : TJsonObject; element : TFhirElement);
    procedure ParseBackboneElementProperties(jsn : TJsonObject; element : TFhirBackboneElement); overload;
    function ParseBackboneElement(jsn : TJsonObject) : TFhirBackboneElement; overload;
    procedure ParseBackboneElement(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}

    procedure ParseEnum(path : String; value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList; Const aNames, aSystems : Array Of String); overload;
    function ParseEnum(path : String; value : TJsonNode; jsn : TJsonObject; Const aNames, aSystems : Array Of String) : TFHIREnum; overload;
    procedure ParseDateTime(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseDateTime(value : TJsonNode; jsn : TJsonObject) : TFHIRDateTime; overload;
    procedure ParseDate(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseDate(value : TJsonNode; jsn : TJsonObject) : TFHIRDate; overload;
    procedure ParseString(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseString(value : TJsonNode; jsn : TJsonObject) : TFHIRString; overload;
    procedure ParseInteger(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseInteger(value : TJsonNode; jsn : TJsonObject) : TFHIRInteger; overload;
    procedure ParseUri(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseUri(value : TJsonNode; jsn : TJsonObject) : TFHIRUri; overload;
    procedure ParseInstant(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseInstant(value : TJsonNode; jsn : TJsonObject) : TFHIRInstant; overload;
    procedure ParseBoolean(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseBoolean(value : TJsonNode; jsn : TJsonObject) : TFHIRBoolean; overload;
    procedure ParseBase64Binary(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseBase64Binary(value : TJsonNode; jsn : TJsonObject) : TFHIRBase64Binary; overload;
    procedure ParseTime(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseTime(value : TJsonNode; jsn : TJsonObject) : TFHIRTime; overload;
    procedure ParseDecimal(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseDecimal(value : TJsonNode; jsn : TJsonObject) : TFHIRDecimal; overload;
    procedure ParseCode(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseCode(value : TJsonNode; jsn : TJsonObject) : TFHIRCode; overload;
    procedure ParseOid(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseOid(value : TJsonNode; jsn : TJsonObject) : TFHIROid; overload;
    procedure ParseUuid(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseUuid(value : TJsonNode; jsn : TJsonObject) : TFHIRUuid; overload;
    procedure ParseMarkdown(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseMarkdown(value : TJsonNode; jsn : TJsonObject) : TFHIRMarkdown; overload;
    procedure ParseUnsignedInt(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseUnsignedInt(value : TJsonNode; jsn : TJsonObject) : TFHIRUnsignedInt; overload;
    procedure ParseId(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParseId(value : TJsonNode; jsn : TJsonObject) : TFHIRId; overload;
    procedure ParsePositiveInt(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList); overload;
    function ParsePositiveInt(value : TJsonNode; jsn : TJsonObject) : TFHIRPositiveInt; overload;

    procedure ParseResourceProperties(jsn : TJsonObject; resource : TFhirResource);
{$IFDEF FHIR_PARAMETERS}
    function ParseParametersParameter(jsn : TJsonObject) : TFhirParametersParameter; overload; {b\}
    procedure ParseParametersParameterProperties(jsn : TJsonObject; result : TFhirParametersParameter); overload; {b\}
    procedure ParseParametersParameter(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseParameters(jsn : TJsonObject) : TFhirParameters; overload;
    procedure ParseParametersProperties(jsn : TJsonObject; result : TFhirParameters); overload;
    procedure ParseParameters(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_PARAMETERS}
    procedure ParseDomainResourceProperties(jsn : TJsonObject; resource : TFhirDomainResource);

    function ParseExtension(jsn : TJsonObject) : TFhirExtension; overload;
    procedure ParseExtensionProperties(jsn : TJsonObject; result : TFhirExtension); overload;
    procedure ParseExtension(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNarrative(jsn : TJsonObject) : TFhirNarrative; overload;
    procedure ParseNarrativeProperties(jsn : TJsonObject; result : TFhirNarrative); overload;
    procedure ParseNarrative(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseIdentifier(jsn : TJsonObject) : TFhirIdentifier; overload;
    procedure ParseIdentifierProperties(jsn : TJsonObject; result : TFhirIdentifier); overload;
    procedure ParseIdentifier(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCoding(jsn : TJsonObject) : TFhirCoding; overload;
    procedure ParseCodingProperties(jsn : TJsonObject; result : TFhirCoding); overload;
    procedure ParseCoding(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseReference(jsn : TJsonObject) : TFhirReference; overload;
    procedure ParseReferenceProperties(jsn : TJsonObject; result : TFhirReference); overload;
    procedure ParseReference(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSignature(jsn : TJsonObject) : TFhirSignature; overload;
    procedure ParseSignatureProperties(jsn : TJsonObject; result : TFhirSignature); overload;
    procedure ParseSignature(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSampledData(jsn : TJsonObject) : TFhirSampledData; overload;
    procedure ParseSampledDataProperties(jsn : TJsonObject; result : TFhirSampledData); overload;
    procedure ParseSampledData(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePeriod(jsn : TJsonObject) : TFhirPeriod; overload;
    procedure ParsePeriodProperties(jsn : TJsonObject; result : TFhirPeriod); overload;
    procedure ParsePeriod(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQuantity(jsn : TJsonObject) : TFhirQuantity; overload;
    procedure ParseQuantityProperties(jsn : TJsonObject; result : TFhirQuantity); overload;
    procedure ParseQuantity(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAttachment(jsn : TJsonObject) : TFhirAttachment; overload;
    procedure ParseAttachmentProperties(jsn : TJsonObject; result : TFhirAttachment); overload;
    procedure ParseAttachment(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseRatio(jsn : TJsonObject) : TFhirRatio; overload;
    procedure ParseRatioProperties(jsn : TJsonObject; result : TFhirRatio); overload;
    procedure ParseRatio(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseRange(jsn : TJsonObject) : TFhirRange; overload;
    procedure ParseRangeProperties(jsn : TJsonObject; result : TFhirRange); overload;
    procedure ParseRange(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAnnotation(jsn : TJsonObject) : TFhirAnnotation; overload;
    procedure ParseAnnotationProperties(jsn : TJsonObject; result : TFhirAnnotation); overload;
    procedure ParseAnnotation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCodeableConcept(jsn : TJsonObject) : TFhirCodeableConcept; overload;
    procedure ParseCodeableConceptProperties(jsn : TJsonObject; result : TFhirCodeableConcept); overload;
    procedure ParseCodeableConcept(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseHumanName(jsn : TJsonObject) : TFhirHumanName; overload;
    procedure ParseHumanNameProperties(jsn : TJsonObject; result : TFhirHumanName); overload;
    procedure ParseHumanName(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMeta(jsn : TJsonObject) : TFhirMeta; overload;
    procedure ParseMetaProperties(jsn : TJsonObject; result : TFhirMeta); overload;
    procedure ParseMeta(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContactPoint(jsn : TJsonObject) : TFhirContactPoint; overload;
    procedure ParseContactPointProperties(jsn : TJsonObject; result : TFhirContactPoint); overload;
    procedure ParseContactPoint(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAddress(jsn : TJsonObject) : TFhirAddress; overload;
    procedure ParseAddressProperties(jsn : TJsonObject; result : TFhirAddress); overload;
    procedure ParseAddress(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseElementDefinitionSlicing(jsn : TJsonObject) : TFhirElementDefinitionSlicing; overload; {b\}
    procedure ParseElementDefinitionSlicingProperties(jsn : TJsonObject; result : TFhirElementDefinitionSlicing); overload; {b\}
    procedure ParseElementDefinitionSlicing(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseElementDefinitionBase(jsn : TJsonObject) : TFhirElementDefinitionBase; overload; {b\}
    procedure ParseElementDefinitionBaseProperties(jsn : TJsonObject; result : TFhirElementDefinitionBase); overload; {b\}
    procedure ParseElementDefinitionBase(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseElementDefinitionType(jsn : TJsonObject) : TFhirElementDefinitionType; overload; {b\}
    procedure ParseElementDefinitionTypeProperties(jsn : TJsonObject; result : TFhirElementDefinitionType); overload; {b\}
    procedure ParseElementDefinitionType(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseElementDefinitionConstraint(jsn : TJsonObject) : TFhirElementDefinitionConstraint; overload; {b\}
    procedure ParseElementDefinitionConstraintProperties(jsn : TJsonObject; result : TFhirElementDefinitionConstraint); overload; {b\}
    procedure ParseElementDefinitionConstraint(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseElementDefinitionBinding(jsn : TJsonObject) : TFhirElementDefinitionBinding; overload; {b\}
    procedure ParseElementDefinitionBindingProperties(jsn : TJsonObject; result : TFhirElementDefinitionBinding); overload; {b\}
    procedure ParseElementDefinitionBinding(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseElementDefinitionMapping(jsn : TJsonObject) : TFhirElementDefinitionMapping; overload; {b\}
    procedure ParseElementDefinitionMappingProperties(jsn : TJsonObject; result : TFhirElementDefinitionMapping); overload; {b\}
    procedure ParseElementDefinitionMapping(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseElementDefinition(jsn : TJsonObject) : TFhirElementDefinition; overload;
    procedure ParseElementDefinitionProperties(jsn : TJsonObject; result : TFhirElementDefinition); overload;
    procedure ParseElementDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTimingRepeat(jsn : TJsonObject) : TFhirTimingRepeat; overload; {b\}
    procedure ParseTimingRepeatProperties(jsn : TJsonObject; result : TFhirTimingRepeat); overload; {b\}
    procedure ParseTimingRepeat(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTiming(jsn : TJsonObject) : TFhirTiming; overload;
    procedure ParseTimingProperties(jsn : TJsonObject; result : TFhirTiming); overload;
    procedure ParseTiming(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}

{$IFDEF FHIR_ACCOUNT}
    function ParseAccount(jsn : TJsonObject) : TFhirAccount; overload;
    procedure ParseAccountProperties(jsn : TJsonObject; result : TFhirAccount); overload;
    procedure ParseAccount(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
    function ParseAllergyIntoleranceReaction(jsn : TJsonObject) : TFhirAllergyIntoleranceReaction; overload; {b\}
    procedure ParseAllergyIntoleranceReactionProperties(jsn : TJsonObject; result : TFhirAllergyIntoleranceReaction); overload; {b\}
    procedure ParseAllergyIntoleranceReaction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAllergyIntolerance(jsn : TJsonObject) : TFhirAllergyIntolerance; overload;
    procedure ParseAllergyIntoleranceProperties(jsn : TJsonObject; result : TFhirAllergyIntolerance); overload;
    procedure ParseAllergyIntolerance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
    function ParseAppointmentParticipant(jsn : TJsonObject) : TFhirAppointmentParticipant; overload; {b\}
    procedure ParseAppointmentParticipantProperties(jsn : TJsonObject; result : TFhirAppointmentParticipant); overload; {b\}
    procedure ParseAppointmentParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAppointment(jsn : TJsonObject) : TFhirAppointment; overload;
    procedure ParseAppointmentProperties(jsn : TJsonObject; result : TFhirAppointment); overload;
    procedure ParseAppointment(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
    function ParseAppointmentResponse(jsn : TJsonObject) : TFhirAppointmentResponse; overload;
    procedure ParseAppointmentResponseProperties(jsn : TJsonObject; result : TFhirAppointmentResponse); overload;
    procedure ParseAppointmentResponse(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
    function ParseAuditEventEvent(jsn : TJsonObject) : TFhirAuditEventEvent; overload; {b\}
    procedure ParseAuditEventEventProperties(jsn : TJsonObject; result : TFhirAuditEventEvent); overload; {b\}
    procedure ParseAuditEventEvent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAuditEventParticipant(jsn : TJsonObject) : TFhirAuditEventParticipant; overload; {b\}
    procedure ParseAuditEventParticipantProperties(jsn : TJsonObject; result : TFhirAuditEventParticipant); overload; {b\}
    procedure ParseAuditEventParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAuditEventParticipantNetwork(jsn : TJsonObject) : TFhirAuditEventParticipantNetwork; overload; {b\}
    procedure ParseAuditEventParticipantNetworkProperties(jsn : TJsonObject; result : TFhirAuditEventParticipantNetwork); overload; {b\}
    procedure ParseAuditEventParticipantNetwork(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAuditEventSource(jsn : TJsonObject) : TFhirAuditEventSource; overload; {b\}
    procedure ParseAuditEventSourceProperties(jsn : TJsonObject; result : TFhirAuditEventSource); overload; {b\}
    procedure ParseAuditEventSource(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAuditEventObject(jsn : TJsonObject) : TFhirAuditEventObject; overload; {b\}
    procedure ParseAuditEventObjectProperties(jsn : TJsonObject; result : TFhirAuditEventObject); overload; {b\}
    procedure ParseAuditEventObject(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAuditEventObjectDetail(jsn : TJsonObject) : TFhirAuditEventObjectDetail; overload; {b\}
    procedure ParseAuditEventObjectDetailProperties(jsn : TJsonObject; result : TFhirAuditEventObjectDetail); overload; {b\}
    procedure ParseAuditEventObjectDetail(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseAuditEvent(jsn : TJsonObject) : TFhirAuditEvent; overload;
    procedure ParseAuditEventProperties(jsn : TJsonObject; result : TFhirAuditEvent); overload;
    procedure ParseAuditEvent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
    function ParseBasic(jsn : TJsonObject) : TFhirBasic; overload;
    procedure ParseBasicProperties(jsn : TJsonObject; result : TFhirBasic); overload;
    procedure ParseBasic(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
    function ParseBinary(jsn : TJsonObject) : TFhirBinary; overload;
    procedure ParseBinaryProperties(jsn : TJsonObject; result : TFhirBinary); overload;
    procedure ParseBinary(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BODYSITE}
    function ParseBodySite(jsn : TJsonObject) : TFhirBodySite; overload;
    procedure ParseBodySiteProperties(jsn : TJsonObject; result : TFhirBodySite); overload;
    procedure ParseBodySite(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_BODYSITE}
{$IFDEF FHIR_BUNDLE}
    function ParseBundleLink(jsn : TJsonObject) : TFhirBundleLink; overload; {b\}
    procedure ParseBundleLinkProperties(jsn : TJsonObject; result : TFhirBundleLink); overload; {b\}
    procedure ParseBundleLink(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseBundleEntry(jsn : TJsonObject) : TFhirBundleEntry; overload; {b\}
    procedure ParseBundleEntryProperties(jsn : TJsonObject; result : TFhirBundleEntry); overload; {b\}
    procedure ParseBundleEntry(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseBundleEntrySearch(jsn : TJsonObject) : TFhirBundleEntrySearch; overload; {b\}
    procedure ParseBundleEntrySearchProperties(jsn : TJsonObject; result : TFhirBundleEntrySearch); overload; {b\}
    procedure ParseBundleEntrySearch(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseBundleEntryRequest(jsn : TJsonObject) : TFhirBundleEntryRequest; overload; {b\}
    procedure ParseBundleEntryRequestProperties(jsn : TJsonObject; result : TFhirBundleEntryRequest); overload; {b\}
    procedure ParseBundleEntryRequest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseBundleEntryResponse(jsn : TJsonObject) : TFhirBundleEntryResponse; overload; {b\}
    procedure ParseBundleEntryResponseProperties(jsn : TJsonObject; result : TFhirBundleEntryResponse); overload; {b\}
    procedure ParseBundleEntryResponse(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseBundle(jsn : TJsonObject) : TFhirBundle; overload;
    procedure ParseBundleProperties(jsn : TJsonObject; result : TFhirBundle); overload;
    procedure ParseBundle(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAREPLAN}
    function ParseCarePlanRelatedPlan(jsn : TJsonObject) : TFhirCarePlanRelatedPlan; overload; {b\}
    procedure ParseCarePlanRelatedPlanProperties(jsn : TJsonObject; result : TFhirCarePlanRelatedPlan); overload; {b\}
    procedure ParseCarePlanRelatedPlan(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCarePlanParticipant(jsn : TJsonObject) : TFhirCarePlanParticipant; overload; {b\}
    procedure ParseCarePlanParticipantProperties(jsn : TJsonObject; result : TFhirCarePlanParticipant); overload; {b\}
    procedure ParseCarePlanParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCarePlanActivity(jsn : TJsonObject) : TFhirCarePlanActivity; overload; {b\}
    procedure ParseCarePlanActivityProperties(jsn : TJsonObject; result : TFhirCarePlanActivity); overload; {b\}
    procedure ParseCarePlanActivity(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCarePlanActivityDetail(jsn : TJsonObject) : TFhirCarePlanActivityDetail; overload; {b\}
    procedure ParseCarePlanActivityDetailProperties(jsn : TJsonObject; result : TFhirCarePlanActivityDetail); overload; {b\}
    procedure ParseCarePlanActivityDetail(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCarePlan(jsn : TJsonObject) : TFhirCarePlan; overload;
    procedure ParseCarePlanProperties(jsn : TJsonObject; result : TFhirCarePlan); overload;
    procedure ParseCarePlan(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CLAIM}
    function ParseClaimPayee(jsn : TJsonObject) : TFhirClaimPayee; overload; {b\}
    procedure ParseClaimPayeeProperties(jsn : TJsonObject; result : TFhirClaimPayee); overload; {b\}
    procedure ParseClaimPayee(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimDiagnosis(jsn : TJsonObject) : TFhirClaimDiagnosis; overload; {b\}
    procedure ParseClaimDiagnosisProperties(jsn : TJsonObject; result : TFhirClaimDiagnosis); overload; {b\}
    procedure ParseClaimDiagnosis(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimCoverage(jsn : TJsonObject) : TFhirClaimCoverage; overload; {b\}
    procedure ParseClaimCoverageProperties(jsn : TJsonObject; result : TFhirClaimCoverage); overload; {b\}
    procedure ParseClaimCoverage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimItem(jsn : TJsonObject) : TFhirClaimItem; overload; {b\}
    procedure ParseClaimItemProperties(jsn : TJsonObject; result : TFhirClaimItem); overload; {b\}
    procedure ParseClaimItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimItemDetail(jsn : TJsonObject) : TFhirClaimItemDetail; overload; {b\}
    procedure ParseClaimItemDetailProperties(jsn : TJsonObject; result : TFhirClaimItemDetail); overload; {b\}
    procedure ParseClaimItemDetail(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimItemDetailSubDetail(jsn : TJsonObject) : TFhirClaimItemDetailSubDetail; overload; {b\}
    procedure ParseClaimItemDetailSubDetailProperties(jsn : TJsonObject; result : TFhirClaimItemDetailSubDetail); overload; {b\}
    procedure ParseClaimItemDetailSubDetail(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimItemProsthesis(jsn : TJsonObject) : TFhirClaimItemProsthesis; overload; {b\}
    procedure ParseClaimItemProsthesisProperties(jsn : TJsonObject; result : TFhirClaimItemProsthesis); overload; {b\}
    procedure ParseClaimItemProsthesis(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimMissingTeeth(jsn : TJsonObject) : TFhirClaimMissingTeeth; overload; {b\}
    procedure ParseClaimMissingTeethProperties(jsn : TJsonObject; result : TFhirClaimMissingTeeth); overload; {b\}
    procedure ParseClaimMissingTeeth(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaim(jsn : TJsonObject) : TFhirClaim; overload;
    procedure ParseClaimProperties(jsn : TJsonObject; result : TFhirClaim); overload;
    procedure ParseClaim(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
    function ParseClaimResponseItem(jsn : TJsonObject) : TFhirClaimResponseItem; overload; {b\}
    procedure ParseClaimResponseItemProperties(jsn : TJsonObject; result : TFhirClaimResponseItem); overload; {b\}
    procedure ParseClaimResponseItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseItemAdjudication(jsn : TJsonObject) : TFhirClaimResponseItemAdjudication; overload; {b\}
    procedure ParseClaimResponseItemAdjudicationProperties(jsn : TJsonObject; result : TFhirClaimResponseItemAdjudication); overload; {b\}
    procedure ParseClaimResponseItemAdjudication(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseItemDetail(jsn : TJsonObject) : TFhirClaimResponseItemDetail; overload; {b\}
    procedure ParseClaimResponseItemDetailProperties(jsn : TJsonObject; result : TFhirClaimResponseItemDetail); overload; {b\}
    procedure ParseClaimResponseItemDetail(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseItemDetailAdjudication(jsn : TJsonObject) : TFhirClaimResponseItemDetailAdjudication; overload; {b\}
    procedure ParseClaimResponseItemDetailAdjudicationProperties(jsn : TJsonObject; result : TFhirClaimResponseItemDetailAdjudication); overload; {b\}
    procedure ParseClaimResponseItemDetailAdjudication(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseItemDetailSubDetail(jsn : TJsonObject) : TFhirClaimResponseItemDetailSubDetail; overload; {b\}
    procedure ParseClaimResponseItemDetailSubDetailProperties(jsn : TJsonObject; result : TFhirClaimResponseItemDetailSubDetail); overload; {b\}
    procedure ParseClaimResponseItemDetailSubDetail(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseItemDetailSubDetailAdjudication(jsn : TJsonObject) : TFhirClaimResponseItemDetailSubDetailAdjudication; overload; {b\}
    procedure ParseClaimResponseItemDetailSubDetailAdjudicationProperties(jsn : TJsonObject; result : TFhirClaimResponseItemDetailSubDetailAdjudication); overload; {b\}
    procedure ParseClaimResponseItemDetailSubDetailAdjudication(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseAddItem(jsn : TJsonObject) : TFhirClaimResponseAddItem; overload; {b\}
    procedure ParseClaimResponseAddItemProperties(jsn : TJsonObject; result : TFhirClaimResponseAddItem); overload; {b\}
    procedure ParseClaimResponseAddItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseAddItemAdjudication(jsn : TJsonObject) : TFhirClaimResponseAddItemAdjudication; overload; {b\}
    procedure ParseClaimResponseAddItemAdjudicationProperties(jsn : TJsonObject; result : TFhirClaimResponseAddItemAdjudication); overload; {b\}
    procedure ParseClaimResponseAddItemAdjudication(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseAddItemDetail(jsn : TJsonObject) : TFhirClaimResponseAddItemDetail; overload; {b\}
    procedure ParseClaimResponseAddItemDetailProperties(jsn : TJsonObject; result : TFhirClaimResponseAddItemDetail); overload; {b\}
    procedure ParseClaimResponseAddItemDetail(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseAddItemDetailAdjudication(jsn : TJsonObject) : TFhirClaimResponseAddItemDetailAdjudication; overload; {b\}
    procedure ParseClaimResponseAddItemDetailAdjudicationProperties(jsn : TJsonObject; result : TFhirClaimResponseAddItemDetailAdjudication); overload; {b\}
    procedure ParseClaimResponseAddItemDetailAdjudication(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseError(jsn : TJsonObject) : TFhirClaimResponseError; overload; {b\}
    procedure ParseClaimResponseErrorProperties(jsn : TJsonObject; result : TFhirClaimResponseError); overload; {b\}
    procedure ParseClaimResponseError(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseNote(jsn : TJsonObject) : TFhirClaimResponseNote; overload; {b\}
    procedure ParseClaimResponseNoteProperties(jsn : TJsonObject; result : TFhirClaimResponseNote); overload; {b\}
    procedure ParseClaimResponseNote(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponseCoverage(jsn : TJsonObject) : TFhirClaimResponseCoverage; overload; {b\}
    procedure ParseClaimResponseCoverageProperties(jsn : TJsonObject; result : TFhirClaimResponseCoverage); overload; {b\}
    procedure ParseClaimResponseCoverage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClaimResponse(jsn : TJsonObject) : TFhirClaimResponse; overload;
    procedure ParseClaimResponseProperties(jsn : TJsonObject; result : TFhirClaimResponse); overload;
    procedure ParseClaimResponse(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
    function ParseClinicalImpressionInvestigations(jsn : TJsonObject) : TFhirClinicalImpressionInvestigations; overload; {b\}
    procedure ParseClinicalImpressionInvestigationsProperties(jsn : TJsonObject; result : TFhirClinicalImpressionInvestigations); overload; {b\}
    procedure ParseClinicalImpressionInvestigations(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClinicalImpressionFinding(jsn : TJsonObject) : TFhirClinicalImpressionFinding; overload; {b\}
    procedure ParseClinicalImpressionFindingProperties(jsn : TJsonObject; result : TFhirClinicalImpressionFinding); overload; {b\}
    procedure ParseClinicalImpressionFinding(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClinicalImpressionRuledOut(jsn : TJsonObject) : TFhirClinicalImpressionRuledOut; overload; {b\}
    procedure ParseClinicalImpressionRuledOutProperties(jsn : TJsonObject; result : TFhirClinicalImpressionRuledOut); overload; {b\}
    procedure ParseClinicalImpressionRuledOut(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseClinicalImpression(jsn : TJsonObject) : TFhirClinicalImpression; overload;
    procedure ParseClinicalImpressionProperties(jsn : TJsonObject; result : TFhirClinicalImpression); overload;
    procedure ParseClinicalImpression(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_COMMUNICATION}
    function ParseCommunicationPayload(jsn : TJsonObject) : TFhirCommunicationPayload; overload; {b\}
    procedure ParseCommunicationPayloadProperties(jsn : TJsonObject; result : TFhirCommunicationPayload); overload; {b\}
    procedure ParseCommunicationPayload(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCommunication(jsn : TJsonObject) : TFhirCommunication; overload;
    procedure ParseCommunicationProperties(jsn : TJsonObject; result : TFhirCommunication); overload;
    procedure ParseCommunication(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
    function ParseCommunicationRequestPayload(jsn : TJsonObject) : TFhirCommunicationRequestPayload; overload; {b\}
    procedure ParseCommunicationRequestPayloadProperties(jsn : TJsonObject; result : TFhirCommunicationRequestPayload); overload; {b\}
    procedure ParseCommunicationRequestPayload(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCommunicationRequest(jsn : TJsonObject) : TFhirCommunicationRequest; overload;
    procedure ParseCommunicationRequestProperties(jsn : TJsonObject; result : TFhirCommunicationRequest); overload;
    procedure ParseCommunicationRequest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPOSITION}
    function ParseCompositionAttester(jsn : TJsonObject) : TFhirCompositionAttester; overload; {b\}
    procedure ParseCompositionAttesterProperties(jsn : TJsonObject; result : TFhirCompositionAttester); overload; {b\}
    procedure ParseCompositionAttester(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCompositionEvent(jsn : TJsonObject) : TFhirCompositionEvent; overload; {b\}
    procedure ParseCompositionEventProperties(jsn : TJsonObject; result : TFhirCompositionEvent); overload; {b\}
    procedure ParseCompositionEvent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCompositionSection(jsn : TJsonObject) : TFhirCompositionSection; overload; {b\}
    procedure ParseCompositionSectionProperties(jsn : TJsonObject; result : TFhirCompositionSection); overload; {b\}
    procedure ParseCompositionSection(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseComposition(jsn : TJsonObject) : TFhirComposition; overload;
    procedure ParseCompositionProperties(jsn : TJsonObject; result : TFhirComposition); overload;
    procedure ParseComposition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
    function ParseConceptMapContact(jsn : TJsonObject) : TFhirConceptMapContact; overload; {b\}
    procedure ParseConceptMapContactProperties(jsn : TJsonObject; result : TFhirConceptMapContact); overload; {b\}
    procedure ParseConceptMapContact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConceptMapElement(jsn : TJsonObject) : TFhirConceptMapElement; overload; {b\}
    procedure ParseConceptMapElementProperties(jsn : TJsonObject; result : TFhirConceptMapElement); overload; {b\}
    procedure ParseConceptMapElement(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConceptMapElementTarget(jsn : TJsonObject) : TFhirConceptMapElementTarget; overload; {b\}
    procedure ParseConceptMapElementTargetProperties(jsn : TJsonObject; result : TFhirConceptMapElementTarget); overload; {b\}
    procedure ParseConceptMapElementTarget(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConceptMapElementTargetDependsOn(jsn : TJsonObject) : TFhirConceptMapElementTargetDependsOn; overload; {b\}
    procedure ParseConceptMapElementTargetDependsOnProperties(jsn : TJsonObject; result : TFhirConceptMapElementTargetDependsOn); overload; {b\}
    procedure ParseConceptMapElementTargetDependsOn(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConceptMap(jsn : TJsonObject) : TFhirConceptMap; overload;
    procedure ParseConceptMapProperties(jsn : TJsonObject; result : TFhirConceptMap); overload;
    procedure ParseConceptMap(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
    function ParseConditionStage(jsn : TJsonObject) : TFhirConditionStage; overload; {b\}
    procedure ParseConditionStageProperties(jsn : TJsonObject; result : TFhirConditionStage); overload; {b\}
    procedure ParseConditionStage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConditionEvidence(jsn : TJsonObject) : TFhirConditionEvidence; overload; {b\}
    procedure ParseConditionEvidenceProperties(jsn : TJsonObject; result : TFhirConditionEvidence); overload; {b\}
    procedure ParseConditionEvidence(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseCondition(jsn : TJsonObject) : TFhirCondition; overload;
    procedure ParseConditionProperties(jsn : TJsonObject; result : TFhirCondition); overload;
    procedure ParseCondition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONFORMANCE}
    function ParseConformanceContact(jsn : TJsonObject) : TFhirConformanceContact; overload; {b\}
    procedure ParseConformanceContactProperties(jsn : TJsonObject; result : TFhirConformanceContact); overload; {b\}
    procedure ParseConformanceContact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceSoftware(jsn : TJsonObject) : TFhirConformanceSoftware; overload; {b\}
    procedure ParseConformanceSoftwareProperties(jsn : TJsonObject; result : TFhirConformanceSoftware); overload; {b\}
    procedure ParseConformanceSoftware(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceImplementation(jsn : TJsonObject) : TFhirConformanceImplementation; overload; {b\}
    procedure ParseConformanceImplementationProperties(jsn : TJsonObject; result : TFhirConformanceImplementation); overload; {b\}
    procedure ParseConformanceImplementation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceRest(jsn : TJsonObject) : TFhirConformanceRest; overload; {b\}
    procedure ParseConformanceRestProperties(jsn : TJsonObject; result : TFhirConformanceRest); overload; {b\}
    procedure ParseConformanceRest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceRestSecurity(jsn : TJsonObject) : TFhirConformanceRestSecurity; overload; {b\}
    procedure ParseConformanceRestSecurityProperties(jsn : TJsonObject; result : TFhirConformanceRestSecurity); overload; {b\}
    procedure ParseConformanceRestSecurity(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceRestSecurityCertificate(jsn : TJsonObject) : TFhirConformanceRestSecurityCertificate; overload; {b\}
    procedure ParseConformanceRestSecurityCertificateProperties(jsn : TJsonObject; result : TFhirConformanceRestSecurityCertificate); overload; {b\}
    procedure ParseConformanceRestSecurityCertificate(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceRestResource(jsn : TJsonObject) : TFhirConformanceRestResource; overload; {b\}
    procedure ParseConformanceRestResourceProperties(jsn : TJsonObject; result : TFhirConformanceRestResource); overload; {b\}
    procedure ParseConformanceRestResource(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceRestResourceInteraction(jsn : TJsonObject) : TFhirConformanceRestResourceInteraction; overload; {b\}
    procedure ParseConformanceRestResourceInteractionProperties(jsn : TJsonObject; result : TFhirConformanceRestResourceInteraction); overload; {b\}
    procedure ParseConformanceRestResourceInteraction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceRestResourceSearchParam(jsn : TJsonObject) : TFhirConformanceRestResourceSearchParam; overload; {b\}
    procedure ParseConformanceRestResourceSearchParamProperties(jsn : TJsonObject; result : TFhirConformanceRestResourceSearchParam); overload; {b\}
    procedure ParseConformanceRestResourceSearchParam(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceRestInteraction(jsn : TJsonObject) : TFhirConformanceRestInteraction; overload; {b\}
    procedure ParseConformanceRestInteractionProperties(jsn : TJsonObject; result : TFhirConformanceRestInteraction); overload; {b\}
    procedure ParseConformanceRestInteraction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceRestOperation(jsn : TJsonObject) : TFhirConformanceRestOperation; overload; {b\}
    procedure ParseConformanceRestOperationProperties(jsn : TJsonObject; result : TFhirConformanceRestOperation); overload; {b\}
    procedure ParseConformanceRestOperation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceMessaging(jsn : TJsonObject) : TFhirConformanceMessaging; overload; {b\}
    procedure ParseConformanceMessagingProperties(jsn : TJsonObject; result : TFhirConformanceMessaging); overload; {b\}
    procedure ParseConformanceMessaging(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceMessagingEndpoint(jsn : TJsonObject) : TFhirConformanceMessagingEndpoint; overload; {b\}
    procedure ParseConformanceMessagingEndpointProperties(jsn : TJsonObject; result : TFhirConformanceMessagingEndpoint); overload; {b\}
    procedure ParseConformanceMessagingEndpoint(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceMessagingEvent(jsn : TJsonObject) : TFhirConformanceMessagingEvent; overload; {b\}
    procedure ParseConformanceMessagingEventProperties(jsn : TJsonObject; result : TFhirConformanceMessagingEvent); overload; {b\}
    procedure ParseConformanceMessagingEvent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformanceDocument(jsn : TJsonObject) : TFhirConformanceDocument; overload; {b\}
    procedure ParseConformanceDocumentProperties(jsn : TJsonObject; result : TFhirConformanceDocument); overload; {b\}
    procedure ParseConformanceDocument(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseConformance(jsn : TJsonObject) : TFhirConformance; overload;
    procedure ParseConformanceProperties(jsn : TJsonObject; result : TFhirConformance); overload;
    procedure ParseConformance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_CONFORMANCE}
{$IFDEF FHIR_CONTRACT}
    function ParseContractActor(jsn : TJsonObject) : TFhirContractActor; overload; {b\}
    procedure ParseContractActorProperties(jsn : TJsonObject; result : TFhirContractActor); overload; {b\}
    procedure ParseContractActor(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContractValuedItem(jsn : TJsonObject) : TFhirContractValuedItem; overload; {b\}
    procedure ParseContractValuedItemProperties(jsn : TJsonObject; result : TFhirContractValuedItem); overload; {b\}
    procedure ParseContractValuedItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContractSigner(jsn : TJsonObject) : TFhirContractSigner; overload; {b\}
    procedure ParseContractSignerProperties(jsn : TJsonObject; result : TFhirContractSigner); overload; {b\}
    procedure ParseContractSigner(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContractTerm(jsn : TJsonObject) : TFhirContractTerm; overload; {b\}
    procedure ParseContractTermProperties(jsn : TJsonObject; result : TFhirContractTerm); overload; {b\}
    procedure ParseContractTerm(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContractTermActor(jsn : TJsonObject) : TFhirContractTermActor; overload; {b\}
    procedure ParseContractTermActorProperties(jsn : TJsonObject; result : TFhirContractTermActor); overload; {b\}
    procedure ParseContractTermActor(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContractTermValuedItem(jsn : TJsonObject) : TFhirContractTermValuedItem; overload; {b\}
    procedure ParseContractTermValuedItemProperties(jsn : TJsonObject; result : TFhirContractTermValuedItem); overload; {b\}
    procedure ParseContractTermValuedItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContractFriendly(jsn : TJsonObject) : TFhirContractFriendly; overload; {b\}
    procedure ParseContractFriendlyProperties(jsn : TJsonObject; result : TFhirContractFriendly); overload; {b\}
    procedure ParseContractFriendly(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContractLegal(jsn : TJsonObject) : TFhirContractLegal; overload; {b\}
    procedure ParseContractLegalProperties(jsn : TJsonObject; result : TFhirContractLegal); overload; {b\}
    procedure ParseContractLegal(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContractRule(jsn : TJsonObject) : TFhirContractRule; overload; {b\}
    procedure ParseContractRuleProperties(jsn : TJsonObject; result : TFhirContractRule); overload; {b\}
    procedure ParseContractRule(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseContract(jsn : TJsonObject) : TFhirContract; overload;
    procedure ParseContractProperties(jsn : TJsonObject; result : TFhirContract); overload;
    procedure ParseContract(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
    function ParseCoverage(jsn : TJsonObject) : TFhirCoverage; overload;
    procedure ParseCoverageProperties(jsn : TJsonObject; result : TFhirCoverage); overload;
    procedure ParseCoverage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_DATAELEMENT}
    function ParseDataElementContact(jsn : TJsonObject) : TFhirDataElementContact; overload; {b\}
    procedure ParseDataElementContactProperties(jsn : TJsonObject; result : TFhirDataElementContact); overload; {b\}
    procedure ParseDataElementContact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDataElementMapping(jsn : TJsonObject) : TFhirDataElementMapping; overload; {b\}
    procedure ParseDataElementMappingProperties(jsn : TJsonObject; result : TFhirDataElementMapping); overload; {b\}
    procedure ParseDataElementMapping(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDataElement(jsn : TJsonObject) : TFhirDataElement; overload;
    procedure ParseDataElementProperties(jsn : TJsonObject; result : TFhirDataElement); overload;
    procedure ParseDataElement(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_DATAELEMENT}
{$IFDEF FHIR_DETECTEDISSUE}
    function ParseDetectedIssueMitigation(jsn : TJsonObject) : TFhirDetectedIssueMitigation; overload; {b\}
    procedure ParseDetectedIssueMitigationProperties(jsn : TJsonObject; result : TFhirDetectedIssueMitigation); overload; {b\}
    procedure ParseDetectedIssueMitigation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDetectedIssue(jsn : TJsonObject) : TFhirDetectedIssue; overload;
    procedure ParseDetectedIssueProperties(jsn : TJsonObject; result : TFhirDetectedIssue); overload;
    procedure ParseDetectedIssue(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
    function ParseDevice(jsn : TJsonObject) : TFhirDevice; overload;
    procedure ParseDeviceProperties(jsn : TJsonObject; result : TFhirDevice); overload;
    procedure ParseDevice(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICECOMPONENT}
    function ParseDeviceComponentProductionSpecification(jsn : TJsonObject) : TFhirDeviceComponentProductionSpecification; overload; {b\}
    procedure ParseDeviceComponentProductionSpecificationProperties(jsn : TJsonObject; result : TFhirDeviceComponentProductionSpecification); overload; {b\}
    procedure ParseDeviceComponentProductionSpecification(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDeviceComponent(jsn : TJsonObject) : TFhirDeviceComponent; overload;
    procedure ParseDeviceComponentProperties(jsn : TJsonObject; result : TFhirDeviceComponent); overload;
    procedure ParseDeviceComponent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_DEVICECOMPONENT}
{$IFDEF FHIR_DEVICEMETRIC}
    function ParseDeviceMetricCalibration(jsn : TJsonObject) : TFhirDeviceMetricCalibration; overload; {b\}
    procedure ParseDeviceMetricCalibrationProperties(jsn : TJsonObject; result : TFhirDeviceMetricCalibration); overload; {b\}
    procedure ParseDeviceMetricCalibration(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDeviceMetric(jsn : TJsonObject) : TFhirDeviceMetric; overload;
    procedure ParseDeviceMetricProperties(jsn : TJsonObject; result : TFhirDeviceMetric); overload;
    procedure ParseDeviceMetric(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEUSEREQUEST}
    function ParseDeviceUseRequest(jsn : TJsonObject) : TFhirDeviceUseRequest; overload;
    procedure ParseDeviceUseRequestProperties(jsn : TJsonObject; result : TFhirDeviceUseRequest); overload;
    procedure ParseDeviceUseRequest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_DEVICEUSEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
    function ParseDeviceUseStatement(jsn : TJsonObject) : TFhirDeviceUseStatement; overload;
    procedure ParseDeviceUseStatementProperties(jsn : TJsonObject; result : TFhirDeviceUseStatement); overload;
    procedure ParseDeviceUseStatement(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICORDER}
    function ParseDiagnosticOrderEvent(jsn : TJsonObject) : TFhirDiagnosticOrderEvent; overload; {b\}
    procedure ParseDiagnosticOrderEventProperties(jsn : TJsonObject; result : TFhirDiagnosticOrderEvent); overload; {b\}
    procedure ParseDiagnosticOrderEvent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDiagnosticOrderItem(jsn : TJsonObject) : TFhirDiagnosticOrderItem; overload; {b\}
    procedure ParseDiagnosticOrderItemProperties(jsn : TJsonObject; result : TFhirDiagnosticOrderItem); overload; {b\}
    procedure ParseDiagnosticOrderItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDiagnosticOrder(jsn : TJsonObject) : TFhirDiagnosticOrder; overload;
    procedure ParseDiagnosticOrderProperties(jsn : TJsonObject; result : TFhirDiagnosticOrder); overload;
    procedure ParseDiagnosticOrder(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_DIAGNOSTICORDER}
{$IFDEF FHIR_DIAGNOSTICREPORT}
    function ParseDiagnosticReportImage(jsn : TJsonObject) : TFhirDiagnosticReportImage; overload; {b\}
    procedure ParseDiagnosticReportImageProperties(jsn : TJsonObject; result : TFhirDiagnosticReportImage); overload; {b\}
    procedure ParseDiagnosticReportImage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDiagnosticReport(jsn : TJsonObject) : TFhirDiagnosticReport; overload;
    procedure ParseDiagnosticReportProperties(jsn : TJsonObject; result : TFhirDiagnosticReport); overload;
    procedure ParseDiagnosticReport(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
    function ParseDocumentManifestContent(jsn : TJsonObject) : TFhirDocumentManifestContent; overload; {b\}
    procedure ParseDocumentManifestContentProperties(jsn : TJsonObject; result : TFhirDocumentManifestContent); overload; {b\}
    procedure ParseDocumentManifestContent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDocumentManifestRelated(jsn : TJsonObject) : TFhirDocumentManifestRelated; overload; {b\}
    procedure ParseDocumentManifestRelatedProperties(jsn : TJsonObject; result : TFhirDocumentManifestRelated); overload; {b\}
    procedure ParseDocumentManifestRelated(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDocumentManifest(jsn : TJsonObject) : TFhirDocumentManifest; overload;
    procedure ParseDocumentManifestProperties(jsn : TJsonObject; result : TFhirDocumentManifest); overload;
    procedure ParseDocumentManifest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
    function ParseDocumentReferenceRelatesTo(jsn : TJsonObject) : TFhirDocumentReferenceRelatesTo; overload; {b\}
    procedure ParseDocumentReferenceRelatesToProperties(jsn : TJsonObject; result : TFhirDocumentReferenceRelatesTo); overload; {b\}
    procedure ParseDocumentReferenceRelatesTo(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDocumentReferenceContent(jsn : TJsonObject) : TFhirDocumentReferenceContent; overload; {b\}
    procedure ParseDocumentReferenceContentProperties(jsn : TJsonObject; result : TFhirDocumentReferenceContent); overload; {b\}
    procedure ParseDocumentReferenceContent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDocumentReferenceContext(jsn : TJsonObject) : TFhirDocumentReferenceContext; overload; {b\}
    procedure ParseDocumentReferenceContextProperties(jsn : TJsonObject; result : TFhirDocumentReferenceContext); overload; {b\}
    procedure ParseDocumentReferenceContext(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDocumentReferenceContextRelated(jsn : TJsonObject) : TFhirDocumentReferenceContextRelated; overload; {b\}
    procedure ParseDocumentReferenceContextRelatedProperties(jsn : TJsonObject; result : TFhirDocumentReferenceContextRelated); overload; {b\}
    procedure ParseDocumentReferenceContextRelated(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseDocumentReference(jsn : TJsonObject) : TFhirDocumentReference; overload;
    procedure ParseDocumentReferenceProperties(jsn : TJsonObject; result : TFhirDocumentReference); overload;
    procedure ParseDocumentReference(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ELIGIBILITYREQUEST}
    function ParseEligibilityRequest(jsn : TJsonObject) : TFhirEligibilityRequest; overload;
    procedure ParseEligibilityRequestProperties(jsn : TJsonObject; result : TFhirEligibilityRequest); overload;
    procedure ParseEligibilityRequest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_ELIGIBILITYREQUEST}
{$IFDEF FHIR_ELIGIBILITYRESPONSE}
    function ParseEligibilityResponse(jsn : TJsonObject) : TFhirEligibilityResponse; overload;
    procedure ParseEligibilityResponseProperties(jsn : TJsonObject; result : TFhirEligibilityResponse); overload;
    procedure ParseEligibilityResponse(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_ELIGIBILITYRESPONSE}
{$IFDEF FHIR_ENCOUNTER}
    function ParseEncounterStatusHistory(jsn : TJsonObject) : TFhirEncounterStatusHistory; overload; {b\}
    procedure ParseEncounterStatusHistoryProperties(jsn : TJsonObject; result : TFhirEncounterStatusHistory); overload; {b\}
    procedure ParseEncounterStatusHistory(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEncounterParticipant(jsn : TJsonObject) : TFhirEncounterParticipant; overload; {b\}
    procedure ParseEncounterParticipantProperties(jsn : TJsonObject; result : TFhirEncounterParticipant); overload; {b\}
    procedure ParseEncounterParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEncounterHospitalization(jsn : TJsonObject) : TFhirEncounterHospitalization; overload; {b\}
    procedure ParseEncounterHospitalizationProperties(jsn : TJsonObject; result : TFhirEncounterHospitalization); overload; {b\}
    procedure ParseEncounterHospitalization(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEncounterLocation(jsn : TJsonObject) : TFhirEncounterLocation; overload; {b\}
    procedure ParseEncounterLocationProperties(jsn : TJsonObject; result : TFhirEncounterLocation); overload; {b\}
    procedure ParseEncounterLocation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEncounter(jsn : TJsonObject) : TFhirEncounter; overload;
    procedure ParseEncounterProperties(jsn : TJsonObject; result : TFhirEncounter); overload;
    procedure ParseEncounter(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENROLLMENTREQUEST}
    function ParseEnrollmentRequest(jsn : TJsonObject) : TFhirEnrollmentRequest; overload;
    procedure ParseEnrollmentRequestProperties(jsn : TJsonObject; result : TFhirEnrollmentRequest); overload;
    procedure ParseEnrollmentRequest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
    function ParseEnrollmentResponse(jsn : TJsonObject) : TFhirEnrollmentResponse; overload;
    procedure ParseEnrollmentResponseProperties(jsn : TJsonObject; result : TFhirEnrollmentResponse); overload;
    procedure ParseEnrollmentResponse(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
    function ParseEpisodeOfCareStatusHistory(jsn : TJsonObject) : TFhirEpisodeOfCareStatusHistory; overload; {b\}
    procedure ParseEpisodeOfCareStatusHistoryProperties(jsn : TJsonObject; result : TFhirEpisodeOfCareStatusHistory); overload; {b\}
    procedure ParseEpisodeOfCareStatusHistory(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEpisodeOfCareCareTeam(jsn : TJsonObject) : TFhirEpisodeOfCareCareTeam; overload; {b\}
    procedure ParseEpisodeOfCareCareTeamProperties(jsn : TJsonObject; result : TFhirEpisodeOfCareCareTeam); overload; {b\}
    procedure ParseEpisodeOfCareCareTeam(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseEpisodeOfCare(jsn : TJsonObject) : TFhirEpisodeOfCare; overload;
    procedure ParseEpisodeOfCareProperties(jsn : TJsonObject; result : TFhirEpisodeOfCare); overload;
    procedure ParseEpisodeOfCare(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
    function ParseExplanationOfBenefit(jsn : TJsonObject) : TFhirExplanationOfBenefit; overload;
    procedure ParseExplanationOfBenefitProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefit); overload;
    procedure ParseExplanationOfBenefit(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
    function ParseFamilyMemberHistoryCondition(jsn : TJsonObject) : TFhirFamilyMemberHistoryCondition; overload; {b\}
    procedure ParseFamilyMemberHistoryConditionProperties(jsn : TJsonObject; result : TFhirFamilyMemberHistoryCondition); overload; {b\}
    procedure ParseFamilyMemberHistoryCondition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseFamilyMemberHistory(jsn : TJsonObject) : TFhirFamilyMemberHistory; overload;
    procedure ParseFamilyMemberHistoryProperties(jsn : TJsonObject; result : TFhirFamilyMemberHistory); overload;
    procedure ParseFamilyMemberHistory(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
    function ParseFlag(jsn : TJsonObject) : TFhirFlag; overload;
    procedure ParseFlagProperties(jsn : TJsonObject; result : TFhirFlag); overload;
    procedure ParseFlag(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
    function ParseGoalOutcome(jsn : TJsonObject) : TFhirGoalOutcome; overload; {b\}
    procedure ParseGoalOutcomeProperties(jsn : TJsonObject; result : TFhirGoalOutcome); overload; {b\}
    procedure ParseGoalOutcome(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseGoal(jsn : TJsonObject) : TFhirGoal; overload;
    procedure ParseGoalProperties(jsn : TJsonObject; result : TFhirGoal); overload;
    procedure ParseGoal(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GROUP}
    function ParseGroupCharacteristic(jsn : TJsonObject) : TFhirGroupCharacteristic; overload; {b\}
    procedure ParseGroupCharacteristicProperties(jsn : TJsonObject; result : TFhirGroupCharacteristic); overload; {b\}
    procedure ParseGroupCharacteristic(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseGroupMember(jsn : TJsonObject) : TFhirGroupMember; overload; {b\}
    procedure ParseGroupMemberProperties(jsn : TJsonObject; result : TFhirGroupMember); overload; {b\}
    procedure ParseGroupMember(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseGroup(jsn : TJsonObject) : TFhirGroup; overload;
    procedure ParseGroupProperties(jsn : TJsonObject; result : TFhirGroup); overload;
    procedure ParseGroup(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_HEALTHCARESERVICE}
    function ParseHealthcareServiceServiceType(jsn : TJsonObject) : TFhirHealthcareServiceServiceType; overload; {b\}
    procedure ParseHealthcareServiceServiceTypeProperties(jsn : TJsonObject; result : TFhirHealthcareServiceServiceType); overload; {b\}
    procedure ParseHealthcareServiceServiceType(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseHealthcareServiceAvailableTime(jsn : TJsonObject) : TFhirHealthcareServiceAvailableTime; overload; {b\}
    procedure ParseHealthcareServiceAvailableTimeProperties(jsn : TJsonObject; result : TFhirHealthcareServiceAvailableTime); overload; {b\}
    procedure ParseHealthcareServiceAvailableTime(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseHealthcareServiceNotAvailable(jsn : TJsonObject) : TFhirHealthcareServiceNotAvailable; overload; {b\}
    procedure ParseHealthcareServiceNotAvailableProperties(jsn : TJsonObject; result : TFhirHealthcareServiceNotAvailable); overload; {b\}
    procedure ParseHealthcareServiceNotAvailable(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseHealthcareService(jsn : TJsonObject) : TFhirHealthcareService; overload;
    procedure ParseHealthcareServiceProperties(jsn : TJsonObject; result : TFhirHealthcareService); overload;
    procedure ParseHealthcareService(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGOBJECTSELECTION}
    function ParseImagingObjectSelectionStudy(jsn : TJsonObject) : TFhirImagingObjectSelectionStudy; overload; {b\}
    procedure ParseImagingObjectSelectionStudyProperties(jsn : TJsonObject; result : TFhirImagingObjectSelectionStudy); overload; {b\}
    procedure ParseImagingObjectSelectionStudy(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImagingObjectSelectionStudySeries(jsn : TJsonObject) : TFhirImagingObjectSelectionStudySeries; overload; {b\}
    procedure ParseImagingObjectSelectionStudySeriesProperties(jsn : TJsonObject; result : TFhirImagingObjectSelectionStudySeries); overload; {b\}
    procedure ParseImagingObjectSelectionStudySeries(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImagingObjectSelectionStudySeriesInstance(jsn : TJsonObject) : TFhirImagingObjectSelectionStudySeriesInstance; overload; {b\}
    procedure ParseImagingObjectSelectionStudySeriesInstanceProperties(jsn : TJsonObject; result : TFhirImagingObjectSelectionStudySeriesInstance); overload; {b\}
    procedure ParseImagingObjectSelectionStudySeriesInstance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImagingObjectSelectionStudySeriesInstanceFrames(jsn : TJsonObject) : TFhirImagingObjectSelectionStudySeriesInstanceFrames; overload; {b\}
    procedure ParseImagingObjectSelectionStudySeriesInstanceFramesProperties(jsn : TJsonObject; result : TFhirImagingObjectSelectionStudySeriesInstanceFrames); overload; {b\}
    procedure ParseImagingObjectSelectionStudySeriesInstanceFrames(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImagingObjectSelection(jsn : TJsonObject) : TFhirImagingObjectSelection; overload;
    procedure ParseImagingObjectSelectionProperties(jsn : TJsonObject; result : TFhirImagingObjectSelection); overload;
    procedure ParseImagingObjectSelection(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_IMAGINGOBJECTSELECTION}
{$IFDEF FHIR_IMAGINGSTUDY}
    function ParseImagingStudySeries(jsn : TJsonObject) : TFhirImagingStudySeries; overload; {b\}
    procedure ParseImagingStudySeriesProperties(jsn : TJsonObject; result : TFhirImagingStudySeries); overload; {b\}
    procedure ParseImagingStudySeries(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImagingStudySeriesInstance(jsn : TJsonObject) : TFhirImagingStudySeriesInstance; overload; {b\}
    procedure ParseImagingStudySeriesInstanceProperties(jsn : TJsonObject; result : TFhirImagingStudySeriesInstance); overload; {b\}
    procedure ParseImagingStudySeriesInstance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImagingStudy(jsn : TJsonObject) : TFhirImagingStudy; overload;
    procedure ParseImagingStudyProperties(jsn : TJsonObject; result : TFhirImagingStudy); overload;
    procedure ParseImagingStudy(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
    function ParseImmunizationExplanation(jsn : TJsonObject) : TFhirImmunizationExplanation; overload; {b\}
    procedure ParseImmunizationExplanationProperties(jsn : TJsonObject; result : TFhirImmunizationExplanation); overload; {b\}
    procedure ParseImmunizationExplanation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunizationReaction(jsn : TJsonObject) : TFhirImmunizationReaction; overload; {b\}
    procedure ParseImmunizationReactionProperties(jsn : TJsonObject; result : TFhirImmunizationReaction); overload; {b\}
    procedure ParseImmunizationReaction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunizationVaccinationProtocol(jsn : TJsonObject) : TFhirImmunizationVaccinationProtocol; overload; {b\}
    procedure ParseImmunizationVaccinationProtocolProperties(jsn : TJsonObject; result : TFhirImmunizationVaccinationProtocol); overload; {b\}
    procedure ParseImmunizationVaccinationProtocol(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunization(jsn : TJsonObject) : TFhirImmunization; overload;
    procedure ParseImmunizationProperties(jsn : TJsonObject; result : TFhirImmunization); overload;
    procedure ParseImmunization(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
    function ParseImmunizationRecommendationRecommendation(jsn : TJsonObject) : TFhirImmunizationRecommendationRecommendation; overload; {b\}
    procedure ParseImmunizationRecommendationRecommendationProperties(jsn : TJsonObject; result : TFhirImmunizationRecommendationRecommendation); overload; {b\}
    procedure ParseImmunizationRecommendationRecommendation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunizationRecommendationRecommendationDateCriterion(jsn : TJsonObject) : TFhirImmunizationRecommendationRecommendationDateCriterion; overload; {b\}
    procedure ParseImmunizationRecommendationRecommendationDateCriterionProperties(jsn : TJsonObject; result : TFhirImmunizationRecommendationRecommendationDateCriterion); overload; {b\}
    procedure ParseImmunizationRecommendationRecommendationDateCriterion(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunizationRecommendationRecommendationProtocol(jsn : TJsonObject) : TFhirImmunizationRecommendationRecommendationProtocol; overload; {b\}
    procedure ParseImmunizationRecommendationRecommendationProtocolProperties(jsn : TJsonObject; result : TFhirImmunizationRecommendationRecommendationProtocol); overload; {b\}
    procedure ParseImmunizationRecommendationRecommendationProtocol(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImmunizationRecommendation(jsn : TJsonObject) : TFhirImmunizationRecommendation; overload;
    procedure ParseImmunizationRecommendationProperties(jsn : TJsonObject; result : TFhirImmunizationRecommendation); overload;
    procedure ParseImmunizationRecommendation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
    function ParseImplementationGuideContact(jsn : TJsonObject) : TFhirImplementationGuideContact; overload; {b\}
    procedure ParseImplementationGuideContactProperties(jsn : TJsonObject; result : TFhirImplementationGuideContact); overload; {b\}
    procedure ParseImplementationGuideContact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImplementationGuideDependency(jsn : TJsonObject) : TFhirImplementationGuideDependency; overload; {b\}
    procedure ParseImplementationGuideDependencyProperties(jsn : TJsonObject; result : TFhirImplementationGuideDependency); overload; {b\}
    procedure ParseImplementationGuideDependency(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImplementationGuidePackage(jsn : TJsonObject) : TFhirImplementationGuidePackage; overload; {b\}
    procedure ParseImplementationGuidePackageProperties(jsn : TJsonObject; result : TFhirImplementationGuidePackage); overload; {b\}
    procedure ParseImplementationGuidePackage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImplementationGuidePackageResource(jsn : TJsonObject) : TFhirImplementationGuidePackageResource; overload; {b\}
    procedure ParseImplementationGuidePackageResourceProperties(jsn : TJsonObject; result : TFhirImplementationGuidePackageResource); overload; {b\}
    procedure ParseImplementationGuidePackageResource(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImplementationGuideGlobal(jsn : TJsonObject) : TFhirImplementationGuideGlobal; overload; {b\}
    procedure ParseImplementationGuideGlobalProperties(jsn : TJsonObject; result : TFhirImplementationGuideGlobal); overload; {b\}
    procedure ParseImplementationGuideGlobal(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImplementationGuidePage(jsn : TJsonObject) : TFhirImplementationGuidePage; overload; {b\}
    procedure ParseImplementationGuidePageProperties(jsn : TJsonObject; result : TFhirImplementationGuidePage); overload; {b\}
    procedure ParseImplementationGuidePage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseImplementationGuide(jsn : TJsonObject) : TFhirImplementationGuide; overload;
    procedure ParseImplementationGuideProperties(jsn : TJsonObject; result : TFhirImplementationGuide); overload;
    procedure ParseImplementationGuide(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_LIST}
    function ParseListEntry(jsn : TJsonObject) : TFhirListEntry; overload; {b\}
    procedure ParseListEntryProperties(jsn : TJsonObject; result : TFhirListEntry); overload; {b\}
    procedure ParseListEntry(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseList(jsn : TJsonObject) : TFhirList; overload;
    procedure ParseListProperties(jsn : TJsonObject; result : TFhirList); overload;
    procedure ParseList(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
    function ParseLocationPosition(jsn : TJsonObject) : TFhirLocationPosition; overload; {b\}
    procedure ParseLocationPositionProperties(jsn : TJsonObject; result : TFhirLocationPosition); overload; {b\}
    procedure ParseLocationPosition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseLocation(jsn : TJsonObject) : TFhirLocation; overload;
    procedure ParseLocationProperties(jsn : TJsonObject; result : TFhirLocation); overload;
    procedure ParseLocation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEDIA}
    function ParseMedia(jsn : TJsonObject) : TFhirMedia; overload;
    procedure ParseMediaProperties(jsn : TJsonObject; result : TFhirMedia); overload;
    procedure ParseMedia(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
    function ParseMedicationProduct(jsn : TJsonObject) : TFhirMedicationProduct; overload; {b\}
    procedure ParseMedicationProductProperties(jsn : TJsonObject; result : TFhirMedicationProduct); overload; {b\}
    procedure ParseMedicationProduct(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationProductIngredient(jsn : TJsonObject) : TFhirMedicationProductIngredient; overload; {b\}
    procedure ParseMedicationProductIngredientProperties(jsn : TJsonObject; result : TFhirMedicationProductIngredient); overload; {b\}
    procedure ParseMedicationProductIngredient(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationProductBatch(jsn : TJsonObject) : TFhirMedicationProductBatch; overload; {b\}
    procedure ParseMedicationProductBatchProperties(jsn : TJsonObject; result : TFhirMedicationProductBatch); overload; {b\}
    procedure ParseMedicationProductBatch(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationPackage(jsn : TJsonObject) : TFhirMedicationPackage; overload; {b\}
    procedure ParseMedicationPackageProperties(jsn : TJsonObject; result : TFhirMedicationPackage); overload; {b\}
    procedure ParseMedicationPackage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationPackageContent(jsn : TJsonObject) : TFhirMedicationPackageContent; overload; {b\}
    procedure ParseMedicationPackageContentProperties(jsn : TJsonObject; result : TFhirMedicationPackageContent); overload; {b\}
    procedure ParseMedicationPackageContent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedication(jsn : TJsonObject) : TFhirMedication; overload;
    procedure ParseMedicationProperties(jsn : TJsonObject; result : TFhirMedication); overload;
    procedure ParseMedication(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
    function ParseMedicationAdministrationDosage(jsn : TJsonObject) : TFhirMedicationAdministrationDosage; overload; {b\}
    procedure ParseMedicationAdministrationDosageProperties(jsn : TJsonObject; result : TFhirMedicationAdministrationDosage); overload; {b\}
    procedure ParseMedicationAdministrationDosage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationAdministration(jsn : TJsonObject) : TFhirMedicationAdministration; overload;
    procedure ParseMedicationAdministrationProperties(jsn : TJsonObject; result : TFhirMedicationAdministration); overload;
    procedure ParseMedicationAdministration(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
    function ParseMedicationDispenseDosageInstruction(jsn : TJsonObject) : TFhirMedicationDispenseDosageInstruction; overload; {b\}
    procedure ParseMedicationDispenseDosageInstructionProperties(jsn : TJsonObject; result : TFhirMedicationDispenseDosageInstruction); overload; {b\}
    procedure ParseMedicationDispenseDosageInstruction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationDispenseSubstitution(jsn : TJsonObject) : TFhirMedicationDispenseSubstitution; overload; {b\}
    procedure ParseMedicationDispenseSubstitutionProperties(jsn : TJsonObject; result : TFhirMedicationDispenseSubstitution); overload; {b\}
    procedure ParseMedicationDispenseSubstitution(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationDispense(jsn : TJsonObject) : TFhirMedicationDispense; overload;
    procedure ParseMedicationDispenseProperties(jsn : TJsonObject; result : TFhirMedicationDispense); overload;
    procedure ParseMedicationDispense(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONORDER}
    function ParseMedicationOrderDosageInstruction(jsn : TJsonObject) : TFhirMedicationOrderDosageInstruction; overload; {b\}
    procedure ParseMedicationOrderDosageInstructionProperties(jsn : TJsonObject; result : TFhirMedicationOrderDosageInstruction); overload; {b\}
    procedure ParseMedicationOrderDosageInstruction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationOrderDispenseRequest(jsn : TJsonObject) : TFhirMedicationOrderDispenseRequest; overload; {b\}
    procedure ParseMedicationOrderDispenseRequestProperties(jsn : TJsonObject; result : TFhirMedicationOrderDispenseRequest); overload; {b\}
    procedure ParseMedicationOrderDispenseRequest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationOrderSubstitution(jsn : TJsonObject) : TFhirMedicationOrderSubstitution; overload; {b\}
    procedure ParseMedicationOrderSubstitutionProperties(jsn : TJsonObject; result : TFhirMedicationOrderSubstitution); overload; {b\}
    procedure ParseMedicationOrderSubstitution(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationOrder(jsn : TJsonObject) : TFhirMedicationOrder; overload;
    procedure ParseMedicationOrderProperties(jsn : TJsonObject; result : TFhirMedicationOrder); overload;
    procedure ParseMedicationOrder(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_MEDICATIONORDER}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
    function ParseMedicationStatementDosage(jsn : TJsonObject) : TFhirMedicationStatementDosage; overload; {b\}
    procedure ParseMedicationStatementDosageProperties(jsn : TJsonObject; result : TFhirMedicationStatementDosage); overload; {b\}
    procedure ParseMedicationStatementDosage(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMedicationStatement(jsn : TJsonObject) : TFhirMedicationStatement; overload;
    procedure ParseMedicationStatementProperties(jsn : TJsonObject; result : TFhirMedicationStatement); overload;
    procedure ParseMedicationStatement(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MESSAGEHEADER}
    function ParseMessageHeaderResponse(jsn : TJsonObject) : TFhirMessageHeaderResponse; overload; {b\}
    procedure ParseMessageHeaderResponseProperties(jsn : TJsonObject; result : TFhirMessageHeaderResponse); overload; {b\}
    procedure ParseMessageHeaderResponse(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMessageHeaderSource(jsn : TJsonObject) : TFhirMessageHeaderSource; overload; {b\}
    procedure ParseMessageHeaderSourceProperties(jsn : TJsonObject; result : TFhirMessageHeaderSource); overload; {b\}
    procedure ParseMessageHeaderSource(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMessageHeaderDestination(jsn : TJsonObject) : TFhirMessageHeaderDestination; overload; {b\}
    procedure ParseMessageHeaderDestinationProperties(jsn : TJsonObject; result : TFhirMessageHeaderDestination); overload; {b\}
    procedure ParseMessageHeaderDestination(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseMessageHeader(jsn : TJsonObject) : TFhirMessageHeader; overload;
    procedure ParseMessageHeaderProperties(jsn : TJsonObject; result : TFhirMessageHeader); overload;
    procedure ParseMessageHeader(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_NAMINGSYSTEM}
    function ParseNamingSystemContact(jsn : TJsonObject) : TFhirNamingSystemContact; overload; {b\}
    procedure ParseNamingSystemContactProperties(jsn : TJsonObject; result : TFhirNamingSystemContact); overload; {b\}
    procedure ParseNamingSystemContact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNamingSystemUniqueId(jsn : TJsonObject) : TFhirNamingSystemUniqueId; overload; {b\}
    procedure ParseNamingSystemUniqueIdProperties(jsn : TJsonObject; result : TFhirNamingSystemUniqueId); overload; {b\}
    procedure ParseNamingSystemUniqueId(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNamingSystem(jsn : TJsonObject) : TFhirNamingSystem; overload;
    procedure ParseNamingSystemProperties(jsn : TJsonObject; result : TFhirNamingSystem); overload;
    procedure ParseNamingSystem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
    function ParseNutritionOrderOralDiet(jsn : TJsonObject) : TFhirNutritionOrderOralDiet; overload; {b\}
    procedure ParseNutritionOrderOralDietProperties(jsn : TJsonObject; result : TFhirNutritionOrderOralDiet); overload; {b\}
    procedure ParseNutritionOrderOralDiet(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNutritionOrderOralDietNutrient(jsn : TJsonObject) : TFhirNutritionOrderOralDietNutrient; overload; {b\}
    procedure ParseNutritionOrderOralDietNutrientProperties(jsn : TJsonObject; result : TFhirNutritionOrderOralDietNutrient); overload; {b\}
    procedure ParseNutritionOrderOralDietNutrient(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNutritionOrderOralDietTexture(jsn : TJsonObject) : TFhirNutritionOrderOralDietTexture; overload; {b\}
    procedure ParseNutritionOrderOralDietTextureProperties(jsn : TJsonObject; result : TFhirNutritionOrderOralDietTexture); overload; {b\}
    procedure ParseNutritionOrderOralDietTexture(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNutritionOrderSupplement(jsn : TJsonObject) : TFhirNutritionOrderSupplement; overload; {b\}
    procedure ParseNutritionOrderSupplementProperties(jsn : TJsonObject; result : TFhirNutritionOrderSupplement); overload; {b\}
    procedure ParseNutritionOrderSupplement(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNutritionOrderEnteralFormula(jsn : TJsonObject) : TFhirNutritionOrderEnteralFormula; overload; {b\}
    procedure ParseNutritionOrderEnteralFormulaProperties(jsn : TJsonObject; result : TFhirNutritionOrderEnteralFormula); overload; {b\}
    procedure ParseNutritionOrderEnteralFormula(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNutritionOrderEnteralFormulaAdministration(jsn : TJsonObject) : TFhirNutritionOrderEnteralFormulaAdministration; overload; {b\}
    procedure ParseNutritionOrderEnteralFormulaAdministrationProperties(jsn : TJsonObject; result : TFhirNutritionOrderEnteralFormulaAdministration); overload; {b\}
    procedure ParseNutritionOrderEnteralFormulaAdministration(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseNutritionOrder(jsn : TJsonObject) : TFhirNutritionOrder; overload;
    procedure ParseNutritionOrderProperties(jsn : TJsonObject; result : TFhirNutritionOrder); overload;
    procedure ParseNutritionOrder(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
    function ParseObservationReferenceRange(jsn : TJsonObject) : TFhirObservationReferenceRange; overload; {b\}
    procedure ParseObservationReferenceRangeProperties(jsn : TJsonObject; result : TFhirObservationReferenceRange); overload; {b\}
    procedure ParseObservationReferenceRange(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseObservationRelated(jsn : TJsonObject) : TFhirObservationRelated; overload; {b\}
    procedure ParseObservationRelatedProperties(jsn : TJsonObject; result : TFhirObservationRelated); overload; {b\}
    procedure ParseObservationRelated(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseObservationComponent(jsn : TJsonObject) : TFhirObservationComponent; overload; {b\}
    procedure ParseObservationComponentProperties(jsn : TJsonObject; result : TFhirObservationComponent); overload; {b\}
    procedure ParseObservationComponent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseObservation(jsn : TJsonObject) : TFhirObservation; overload;
    procedure ParseObservationProperties(jsn : TJsonObject; result : TFhirObservation); overload;
    procedure ParseObservation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OPERATIONDEFINITION}
    function ParseOperationDefinitionContact(jsn : TJsonObject) : TFhirOperationDefinitionContact; overload; {b\}
    procedure ParseOperationDefinitionContactProperties(jsn : TJsonObject; result : TFhirOperationDefinitionContact); overload; {b\}
    procedure ParseOperationDefinitionContact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOperationDefinitionParameter(jsn : TJsonObject) : TFhirOperationDefinitionParameter; overload; {b\}
    procedure ParseOperationDefinitionParameterProperties(jsn : TJsonObject; result : TFhirOperationDefinitionParameter); overload; {b\}
    procedure ParseOperationDefinitionParameter(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOperationDefinitionParameterBinding(jsn : TJsonObject) : TFhirOperationDefinitionParameterBinding; overload; {b\}
    procedure ParseOperationDefinitionParameterBindingProperties(jsn : TJsonObject; result : TFhirOperationDefinitionParameterBinding); overload; {b\}
    procedure ParseOperationDefinitionParameterBinding(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOperationDefinition(jsn : TJsonObject) : TFhirOperationDefinition; overload;
    procedure ParseOperationDefinitionProperties(jsn : TJsonObject; result : TFhirOperationDefinition); overload;
    procedure ParseOperationDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
    function ParseOperationOutcomeIssue(jsn : TJsonObject) : TFhirOperationOutcomeIssue; overload; {b\}
    procedure ParseOperationOutcomeIssueProperties(jsn : TJsonObject; result : TFhirOperationOutcomeIssue); overload; {b\}
    procedure ParseOperationOutcomeIssue(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOperationOutcome(jsn : TJsonObject) : TFhirOperationOutcome; overload;
    procedure ParseOperationOutcomeProperties(jsn : TJsonObject; result : TFhirOperationOutcome); overload;
    procedure ParseOperationOutcome(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORDER}
    function ParseOrderWhen(jsn : TJsonObject) : TFhirOrderWhen; overload; {b\}
    procedure ParseOrderWhenProperties(jsn : TJsonObject; result : TFhirOrderWhen); overload; {b\}
    procedure ParseOrderWhen(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOrder(jsn : TJsonObject) : TFhirOrder; overload;
    procedure ParseOrderProperties(jsn : TJsonObject; result : TFhirOrder); overload;
    procedure ParseOrder(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_ORDER}
{$IFDEF FHIR_ORDERRESPONSE}
    function ParseOrderResponse(jsn : TJsonObject) : TFhirOrderResponse; overload;
    procedure ParseOrderResponseProperties(jsn : TJsonObject; result : TFhirOrderResponse); overload;
    procedure ParseOrderResponse(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_ORDERRESPONSE}
{$IFDEF FHIR_ORGANIZATION}
    function ParseOrganizationContact(jsn : TJsonObject) : TFhirOrganizationContact; overload; {b\}
    procedure ParseOrganizationContactProperties(jsn : TJsonObject; result : TFhirOrganizationContact); overload; {b\}
    procedure ParseOrganizationContact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseOrganization(jsn : TJsonObject) : TFhirOrganization; overload;
    procedure ParseOrganizationProperties(jsn : TJsonObject; result : TFhirOrganization); overload;
    procedure ParseOrganization(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_PATIENT}
    function ParsePatientContact(jsn : TJsonObject) : TFhirPatientContact; overload; {b\}
    procedure ParsePatientContactProperties(jsn : TJsonObject; result : TFhirPatientContact); overload; {b\}
    procedure ParsePatientContact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePatientAnimal(jsn : TJsonObject) : TFhirPatientAnimal; overload; {b\}
    procedure ParsePatientAnimalProperties(jsn : TJsonObject; result : TFhirPatientAnimal); overload; {b\}
    procedure ParsePatientAnimal(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePatientCommunication(jsn : TJsonObject) : TFhirPatientCommunication; overload; {b\}
    procedure ParsePatientCommunicationProperties(jsn : TJsonObject; result : TFhirPatientCommunication); overload; {b\}
    procedure ParsePatientCommunication(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePatientLink(jsn : TJsonObject) : TFhirPatientLink; overload; {b\}
    procedure ParsePatientLinkProperties(jsn : TJsonObject; result : TFhirPatientLink); overload; {b\}
    procedure ParsePatientLink(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePatient(jsn : TJsonObject) : TFhirPatient; overload;
    procedure ParsePatientProperties(jsn : TJsonObject; result : TFhirPatient); overload;
    procedure ParsePatient(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
    function ParsePaymentNotice(jsn : TJsonObject) : TFhirPaymentNotice; overload;
    procedure ParsePaymentNoticeProperties(jsn : TJsonObject; result : TFhirPaymentNotice); overload;
    procedure ParsePaymentNotice(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
    function ParsePaymentReconciliationDetail(jsn : TJsonObject) : TFhirPaymentReconciliationDetail; overload; {b\}
    procedure ParsePaymentReconciliationDetailProperties(jsn : TJsonObject; result : TFhirPaymentReconciliationDetail); overload; {b\}
    procedure ParsePaymentReconciliationDetail(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePaymentReconciliationNote(jsn : TJsonObject) : TFhirPaymentReconciliationNote; overload; {b\}
    procedure ParsePaymentReconciliationNoteProperties(jsn : TJsonObject; result : TFhirPaymentReconciliationNote); overload; {b\}
    procedure ParsePaymentReconciliationNote(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePaymentReconciliation(jsn : TJsonObject) : TFhirPaymentReconciliation; overload;
    procedure ParsePaymentReconciliationProperties(jsn : TJsonObject; result : TFhirPaymentReconciliation); overload;
    procedure ParsePaymentReconciliation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
    function ParsePersonLink(jsn : TJsonObject) : TFhirPersonLink; overload; {b\}
    procedure ParsePersonLinkProperties(jsn : TJsonObject; result : TFhirPersonLink); overload; {b\}
    procedure ParsePersonLink(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePerson(jsn : TJsonObject) : TFhirPerson; overload;
    procedure ParsePersonProperties(jsn : TJsonObject; result : TFhirPerson); overload;
    procedure ParsePerson(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PRACTITIONER}
    function ParsePractitionerPractitionerRole(jsn : TJsonObject) : TFhirPractitionerPractitionerRole; overload; {b\}
    procedure ParsePractitionerPractitionerRoleProperties(jsn : TJsonObject; result : TFhirPractitionerPractitionerRole); overload; {b\}
    procedure ParsePractitionerPractitionerRole(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePractitionerQualification(jsn : TJsonObject) : TFhirPractitionerQualification; overload; {b\}
    procedure ParsePractitionerQualificationProperties(jsn : TJsonObject; result : TFhirPractitionerQualification); overload; {b\}
    procedure ParsePractitionerQualification(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParsePractitioner(jsn : TJsonObject) : TFhirPractitioner; overload;
    procedure ParsePractitionerProperties(jsn : TJsonObject; result : TFhirPractitioner); overload;
    procedure ParsePractitioner(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PROCEDURE}
    function ParseProcedurePerformer(jsn : TJsonObject) : TFhirProcedurePerformer; overload; {b\}
    procedure ParseProcedurePerformerProperties(jsn : TJsonObject; result : TFhirProcedurePerformer); overload; {b\}
    procedure ParseProcedurePerformer(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProcedureFocalDevice(jsn : TJsonObject) : TFhirProcedureFocalDevice; overload; {b\}
    procedure ParseProcedureFocalDeviceProperties(jsn : TJsonObject; result : TFhirProcedureFocalDevice); overload; {b\}
    procedure ParseProcedureFocalDevice(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProcedure(jsn : TJsonObject) : TFhirProcedure; overload;
    procedure ParseProcedureProperties(jsn : TJsonObject; result : TFhirProcedure); overload;
    procedure ParseProcedure(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROCEDUREREQUEST}
    function ParseProcedureRequest(jsn : TJsonObject) : TFhirProcedureRequest; overload;
    procedure ParseProcedureRequestProperties(jsn : TJsonObject; result : TFhirProcedureRequest); overload;
    procedure ParseProcedureRequest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_PROCEDUREREQUEST}
{$IFDEF FHIR_PROCESSREQUEST}
    function ParseProcessRequestItem(jsn : TJsonObject) : TFhirProcessRequestItem; overload; {b\}
    procedure ParseProcessRequestItemProperties(jsn : TJsonObject; result : TFhirProcessRequestItem); overload; {b\}
    procedure ParseProcessRequestItem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProcessRequest(jsn : TJsonObject) : TFhirProcessRequest; overload;
    procedure ParseProcessRequestProperties(jsn : TJsonObject; result : TFhirProcessRequest); overload;
    procedure ParseProcessRequest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_PROCESSREQUEST}
{$IFDEF FHIR_PROCESSRESPONSE}
    function ParseProcessResponseNotes(jsn : TJsonObject) : TFhirProcessResponseNotes; overload; {b\}
    procedure ParseProcessResponseNotesProperties(jsn : TJsonObject; result : TFhirProcessResponseNotes); overload; {b\}
    procedure ParseProcessResponseNotes(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProcessResponse(jsn : TJsonObject) : TFhirProcessResponse; overload;
    procedure ParseProcessResponseProperties(jsn : TJsonObject; result : TFhirProcessResponse); overload;
    procedure ParseProcessResponse(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_PROCESSRESPONSE}
{$IFDEF FHIR_PROVENANCE}
    function ParseProvenanceAgent(jsn : TJsonObject) : TFhirProvenanceAgent; overload; {b\}
    procedure ParseProvenanceAgentProperties(jsn : TJsonObject; result : TFhirProvenanceAgent); overload; {b\}
    procedure ParseProvenanceAgent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProvenanceAgentRelatedAgent(jsn : TJsonObject) : TFhirProvenanceAgentRelatedAgent; overload; {b\}
    procedure ParseProvenanceAgentRelatedAgentProperties(jsn : TJsonObject; result : TFhirProvenanceAgentRelatedAgent); overload; {b\}
    procedure ParseProvenanceAgentRelatedAgent(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProvenanceEntity(jsn : TJsonObject) : TFhirProvenanceEntity; overload; {b\}
    procedure ParseProvenanceEntityProperties(jsn : TJsonObject; result : TFhirProvenanceEntity); overload; {b\}
    procedure ParseProvenanceEntity(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseProvenance(jsn : TJsonObject) : TFhirProvenance; overload;
    procedure ParseProvenanceProperties(jsn : TJsonObject; result : TFhirProvenance); overload;
    procedure ParseProvenance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
    function ParseQuestionnaireGroup(jsn : TJsonObject) : TFhirQuestionnaireGroup; overload; {b\}
    procedure ParseQuestionnaireGroupProperties(jsn : TJsonObject; result : TFhirQuestionnaireGroup); overload; {b\}
    procedure ParseQuestionnaireGroup(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQuestionnaireGroupQuestion(jsn : TJsonObject) : TFhirQuestionnaireGroupQuestion; overload; {b\}
    procedure ParseQuestionnaireGroupQuestionProperties(jsn : TJsonObject; result : TFhirQuestionnaireGroupQuestion); overload; {b\}
    procedure ParseQuestionnaireGroupQuestion(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQuestionnaire(jsn : TJsonObject) : TFhirQuestionnaire; overload;
    procedure ParseQuestionnaireProperties(jsn : TJsonObject; result : TFhirQuestionnaire); overload;
    procedure ParseQuestionnaire(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
    function ParseQuestionnaireResponseGroup(jsn : TJsonObject) : TFhirQuestionnaireResponseGroup; overload; {b\}
    procedure ParseQuestionnaireResponseGroupProperties(jsn : TJsonObject; result : TFhirQuestionnaireResponseGroup); overload; {b\}
    procedure ParseQuestionnaireResponseGroup(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQuestionnaireResponseGroupQuestion(jsn : TJsonObject) : TFhirQuestionnaireResponseGroupQuestion; overload; {b\}
    procedure ParseQuestionnaireResponseGroupQuestionProperties(jsn : TJsonObject; result : TFhirQuestionnaireResponseGroupQuestion); overload; {b\}
    procedure ParseQuestionnaireResponseGroupQuestion(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQuestionnaireResponseGroupQuestionAnswer(jsn : TJsonObject) : TFhirQuestionnaireResponseGroupQuestionAnswer; overload; {b\}
    procedure ParseQuestionnaireResponseGroupQuestionAnswerProperties(jsn : TJsonObject; result : TFhirQuestionnaireResponseGroupQuestionAnswer); overload; {b\}
    procedure ParseQuestionnaireResponseGroupQuestionAnswer(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseQuestionnaireResponse(jsn : TJsonObject) : TFhirQuestionnaireResponse; overload;
    procedure ParseQuestionnaireResponseProperties(jsn : TJsonObject; result : TFhirQuestionnaireResponse); overload;
    procedure ParseQuestionnaireResponse(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REFERRALREQUEST}
    function ParseReferralRequest(jsn : TJsonObject) : TFhirReferralRequest; overload;
    procedure ParseReferralRequestProperties(jsn : TJsonObject; result : TFhirReferralRequest); overload;
    procedure ParseReferralRequest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_REFERRALREQUEST}
{$IFDEF FHIR_RELATEDPERSON}
    function ParseRelatedPerson(jsn : TJsonObject) : TFhirRelatedPerson; overload;
    procedure ParseRelatedPersonProperties(jsn : TJsonObject; result : TFhirRelatedPerson); overload;
    procedure ParseRelatedPerson(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_RISKASSESSMENT}
    function ParseRiskAssessmentPrediction(jsn : TJsonObject) : TFhirRiskAssessmentPrediction; overload; {b\}
    procedure ParseRiskAssessmentPredictionProperties(jsn : TJsonObject; result : TFhirRiskAssessmentPrediction); overload; {b\}
    procedure ParseRiskAssessmentPrediction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseRiskAssessment(jsn : TJsonObject) : TFhirRiskAssessment; overload;
    procedure ParseRiskAssessmentProperties(jsn : TJsonObject; result : TFhirRiskAssessment); overload;
    procedure ParseRiskAssessment(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
    function ParseSchedule(jsn : TJsonObject) : TFhirSchedule; overload;
    procedure ParseScheduleProperties(jsn : TJsonObject; result : TFhirSchedule); overload;
    procedure ParseSchedule(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
    function ParseSearchParameterContact(jsn : TJsonObject) : TFhirSearchParameterContact; overload; {b\}
    procedure ParseSearchParameterContactProperties(jsn : TJsonObject; result : TFhirSearchParameterContact); overload; {b\}
    procedure ParseSearchParameterContact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSearchParameter(jsn : TJsonObject) : TFhirSearchParameter; overload;
    procedure ParseSearchParameterProperties(jsn : TJsonObject; result : TFhirSearchParameter); overload;
    procedure ParseSearchParameter(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SLOT}
    function ParseSlot(jsn : TJsonObject) : TFhirSlot; overload;
    procedure ParseSlotProperties(jsn : TJsonObject; result : TFhirSlot); overload;
    procedure ParseSlot(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
    function ParseSpecimenCollection(jsn : TJsonObject) : TFhirSpecimenCollection; overload; {b\}
    procedure ParseSpecimenCollectionProperties(jsn : TJsonObject; result : TFhirSpecimenCollection); overload; {b\}
    procedure ParseSpecimenCollection(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSpecimenTreatment(jsn : TJsonObject) : TFhirSpecimenTreatment; overload; {b\}
    procedure ParseSpecimenTreatmentProperties(jsn : TJsonObject; result : TFhirSpecimenTreatment); overload; {b\}
    procedure ParseSpecimenTreatment(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSpecimenContainer(jsn : TJsonObject) : TFhirSpecimenContainer; overload; {b\}
    procedure ParseSpecimenContainerProperties(jsn : TJsonObject; result : TFhirSpecimenContainer); overload; {b\}
    procedure ParseSpecimenContainer(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSpecimen(jsn : TJsonObject) : TFhirSpecimen; overload;
    procedure ParseSpecimenProperties(jsn : TJsonObject; result : TFhirSpecimen); overload;
    procedure ParseSpecimen(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_STRUCTUREDEFINITION}
    function ParseStructureDefinitionContact(jsn : TJsonObject) : TFhirStructureDefinitionContact; overload; {b\}
    procedure ParseStructureDefinitionContactProperties(jsn : TJsonObject; result : TFhirStructureDefinitionContact); overload; {b\}
    procedure ParseStructureDefinitionContact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseStructureDefinitionMapping(jsn : TJsonObject) : TFhirStructureDefinitionMapping; overload; {b\}
    procedure ParseStructureDefinitionMappingProperties(jsn : TJsonObject; result : TFhirStructureDefinitionMapping); overload; {b\}
    procedure ParseStructureDefinitionMapping(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseStructureDefinitionSnapshot(jsn : TJsonObject) : TFhirStructureDefinitionSnapshot; overload; {b\}
    procedure ParseStructureDefinitionSnapshotProperties(jsn : TJsonObject; result : TFhirStructureDefinitionSnapshot); overload; {b\}
    procedure ParseStructureDefinitionSnapshot(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseStructureDefinitionDifferential(jsn : TJsonObject) : TFhirStructureDefinitionDifferential; overload; {b\}
    procedure ParseStructureDefinitionDifferentialProperties(jsn : TJsonObject; result : TFhirStructureDefinitionDifferential); overload; {b\}
    procedure ParseStructureDefinitionDifferential(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseStructureDefinition(jsn : TJsonObject) : TFhirStructureDefinition; overload;
    procedure ParseStructureDefinitionProperties(jsn : TJsonObject; result : TFhirStructureDefinition); overload;
    procedure ParseStructureDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_SUBSCRIPTION}
    function ParseSubscriptionChannel(jsn : TJsonObject) : TFhirSubscriptionChannel; overload; {b\}
    procedure ParseSubscriptionChannelProperties(jsn : TJsonObject; result : TFhirSubscriptionChannel); overload; {b\}
    procedure ParseSubscriptionChannel(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubscription(jsn : TJsonObject) : TFhirSubscription; overload;
    procedure ParseSubscriptionProperties(jsn : TJsonObject; result : TFhirSubscription); overload;
    procedure ParseSubscription(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
    function ParseSubstanceInstance(jsn : TJsonObject) : TFhirSubstanceInstance; overload; {b\}
    procedure ParseSubstanceInstanceProperties(jsn : TJsonObject; result : TFhirSubstanceInstance); overload; {b\}
    procedure ParseSubstanceInstance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstanceIngredient(jsn : TJsonObject) : TFhirSubstanceIngredient; overload; {b\}
    procedure ParseSubstanceIngredientProperties(jsn : TJsonObject; result : TFhirSubstanceIngredient); overload; {b\}
    procedure ParseSubstanceIngredient(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSubstance(jsn : TJsonObject) : TFhirSubstance; overload;
    procedure ParseSubstanceProperties(jsn : TJsonObject; result : TFhirSubstance); overload;
    procedure ParseSubstance(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUPPLYDELIVERY}
    function ParseSupplyDelivery(jsn : TJsonObject) : TFhirSupplyDelivery; overload;
    procedure ParseSupplyDeliveryProperties(jsn : TJsonObject; result : TFhirSupplyDelivery); overload;
    procedure ParseSupplyDelivery(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
    function ParseSupplyRequestWhen(jsn : TJsonObject) : TFhirSupplyRequestWhen; overload; {b\}
    procedure ParseSupplyRequestWhenProperties(jsn : TJsonObject; result : TFhirSupplyRequestWhen); overload; {b\}
    procedure ParseSupplyRequestWhen(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseSupplyRequest(jsn : TJsonObject) : TFhirSupplyRequest; overload;
    procedure ParseSupplyRequestProperties(jsn : TJsonObject; result : TFhirSupplyRequest); overload;
    procedure ParseSupplyRequest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TESTSCRIPT}
    function ParseTestScriptContact(jsn : TJsonObject) : TFhirTestScriptContact; overload; {b\}
    procedure ParseTestScriptContactProperties(jsn : TJsonObject; result : TFhirTestScriptContact); overload; {b\}
    procedure ParseTestScriptContact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptMetadata(jsn : TJsonObject) : TFhirTestScriptMetadata; overload; {b\}
    procedure ParseTestScriptMetadataProperties(jsn : TJsonObject; result : TFhirTestScriptMetadata); overload; {b\}
    procedure ParseTestScriptMetadata(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptMetadataLink(jsn : TJsonObject) : TFhirTestScriptMetadataLink; overload; {b\}
    procedure ParseTestScriptMetadataLinkProperties(jsn : TJsonObject; result : TFhirTestScriptMetadataLink); overload; {b\}
    procedure ParseTestScriptMetadataLink(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptMetadataCapability(jsn : TJsonObject) : TFhirTestScriptMetadataCapability; overload; {b\}
    procedure ParseTestScriptMetadataCapabilityProperties(jsn : TJsonObject; result : TFhirTestScriptMetadataCapability); overload; {b\}
    procedure ParseTestScriptMetadataCapability(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptFixture(jsn : TJsonObject) : TFhirTestScriptFixture; overload; {b\}
    procedure ParseTestScriptFixtureProperties(jsn : TJsonObject; result : TFhirTestScriptFixture); overload; {b\}
    procedure ParseTestScriptFixture(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptVariable(jsn : TJsonObject) : TFhirTestScriptVariable; overload; {b\}
    procedure ParseTestScriptVariableProperties(jsn : TJsonObject; result : TFhirTestScriptVariable); overload; {b\}
    procedure ParseTestScriptVariable(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptSetup(jsn : TJsonObject) : TFhirTestScriptSetup; overload; {b\}
    procedure ParseTestScriptSetupProperties(jsn : TJsonObject; result : TFhirTestScriptSetup); overload; {b\}
    procedure ParseTestScriptSetup(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptSetupAction(jsn : TJsonObject) : TFhirTestScriptSetupAction; overload; {b\}
    procedure ParseTestScriptSetupActionProperties(jsn : TJsonObject; result : TFhirTestScriptSetupAction); overload; {b\}
    procedure ParseTestScriptSetupAction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptSetupActionOperation(jsn : TJsonObject) : TFhirTestScriptSetupActionOperation; overload; {b\}
    procedure ParseTestScriptSetupActionOperationProperties(jsn : TJsonObject; result : TFhirTestScriptSetupActionOperation); overload; {b\}
    procedure ParseTestScriptSetupActionOperation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptSetupActionOperationRequestHeader(jsn : TJsonObject) : TFhirTestScriptSetupActionOperationRequestHeader; overload; {b\}
    procedure ParseTestScriptSetupActionOperationRequestHeaderProperties(jsn : TJsonObject; result : TFhirTestScriptSetupActionOperationRequestHeader); overload; {b\}
    procedure ParseTestScriptSetupActionOperationRequestHeader(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptSetupActionAssert(jsn : TJsonObject) : TFhirTestScriptSetupActionAssert; overload; {b\}
    procedure ParseTestScriptSetupActionAssertProperties(jsn : TJsonObject; result : TFhirTestScriptSetupActionAssert); overload; {b\}
    procedure ParseTestScriptSetupActionAssert(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptTest(jsn : TJsonObject) : TFhirTestScriptTest; overload; {b\}
    procedure ParseTestScriptTestProperties(jsn : TJsonObject; result : TFhirTestScriptTest); overload; {b\}
    procedure ParseTestScriptTest(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptTestAction(jsn : TJsonObject) : TFhirTestScriptTestAction; overload; {b\}
    procedure ParseTestScriptTestActionProperties(jsn : TJsonObject; result : TFhirTestScriptTestAction); overload; {b\}
    procedure ParseTestScriptTestAction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptTeardown(jsn : TJsonObject) : TFhirTestScriptTeardown; overload; {b\}
    procedure ParseTestScriptTeardownProperties(jsn : TJsonObject; result : TFhirTestScriptTeardown); overload; {b\}
    procedure ParseTestScriptTeardown(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScriptTeardownAction(jsn : TJsonObject) : TFhirTestScriptTeardownAction; overload; {b\}
    procedure ParseTestScriptTeardownActionProperties(jsn : TJsonObject; result : TFhirTestScriptTeardownAction); overload; {b\}
    procedure ParseTestScriptTeardownAction(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseTestScript(jsn : TJsonObject) : TFhirTestScript; overload;
    procedure ParseTestScriptProperties(jsn : TJsonObject; result : TFhirTestScript); overload;
    procedure ParseTestScript(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
    function ParseValueSetContact(jsn : TJsonObject) : TFhirValueSetContact; overload; {b\}
    procedure ParseValueSetContactProperties(jsn : TJsonObject; result : TFhirValueSetContact); overload; {b\}
    procedure ParseValueSetContact(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetCodeSystem(jsn : TJsonObject) : TFhirValueSetCodeSystem; overload; {b\}
    procedure ParseValueSetCodeSystemProperties(jsn : TJsonObject; result : TFhirValueSetCodeSystem); overload; {b\}
    procedure ParseValueSetCodeSystem(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetCodeSystemConcept(jsn : TJsonObject) : TFhirValueSetCodeSystemConcept; overload; {b\}
    procedure ParseValueSetCodeSystemConceptProperties(jsn : TJsonObject; result : TFhirValueSetCodeSystemConcept); overload; {b\}
    procedure ParseValueSetCodeSystemConcept(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetCodeSystemConceptDesignation(jsn : TJsonObject) : TFhirValueSetCodeSystemConceptDesignation; overload; {b\}
    procedure ParseValueSetCodeSystemConceptDesignationProperties(jsn : TJsonObject; result : TFhirValueSetCodeSystemConceptDesignation); overload; {b\}
    procedure ParseValueSetCodeSystemConceptDesignation(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetCompose(jsn : TJsonObject) : TFhirValueSetCompose; overload; {b\}
    procedure ParseValueSetComposeProperties(jsn : TJsonObject; result : TFhirValueSetCompose); overload; {b\}
    procedure ParseValueSetCompose(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetComposeInclude(jsn : TJsonObject) : TFhirValueSetComposeInclude; overload; {b\}
    procedure ParseValueSetComposeIncludeProperties(jsn : TJsonObject; result : TFhirValueSetComposeInclude); overload; {b\}
    procedure ParseValueSetComposeInclude(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetComposeIncludeConcept(jsn : TJsonObject) : TFhirValueSetComposeIncludeConcept; overload; {b\}
    procedure ParseValueSetComposeIncludeConceptProperties(jsn : TJsonObject; result : TFhirValueSetComposeIncludeConcept); overload; {b\}
    procedure ParseValueSetComposeIncludeConcept(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetComposeIncludeFilter(jsn : TJsonObject) : TFhirValueSetComposeIncludeFilter; overload; {b\}
    procedure ParseValueSetComposeIncludeFilterProperties(jsn : TJsonObject; result : TFhirValueSetComposeIncludeFilter); overload; {b\}
    procedure ParseValueSetComposeIncludeFilter(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetExpansion(jsn : TJsonObject) : TFhirValueSetExpansion; overload; {b\}
    procedure ParseValueSetExpansionProperties(jsn : TJsonObject; result : TFhirValueSetExpansion); overload; {b\}
    procedure ParseValueSetExpansion(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetExpansionParameter(jsn : TJsonObject) : TFhirValueSetExpansionParameter; overload; {b\}
    procedure ParseValueSetExpansionParameterProperties(jsn : TJsonObject; result : TFhirValueSetExpansionParameter); overload; {b\}
    procedure ParseValueSetExpansionParameter(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSetExpansionContains(jsn : TJsonObject) : TFhirValueSetExpansionContains; overload; {b\}
    procedure ParseValueSetExpansionContainsProperties(jsn : TJsonObject; result : TFhirValueSetExpansionContains); overload; {b\}
    procedure ParseValueSetExpansionContains(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseValueSet(jsn : TJsonObject) : TFhirValueSet; overload;
    procedure ParseValueSetProperties(jsn : TJsonObject; result : TFhirValueSet); overload;
    procedure ParseValueSet(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VISIONPRESCRIPTION}
    function ParseVisionPrescriptionDispense(jsn : TJsonObject) : TFhirVisionPrescriptionDispense; overload; {b\}
    procedure ParseVisionPrescriptionDispenseProperties(jsn : TJsonObject; result : TFhirVisionPrescriptionDispense); overload; {b\}
    procedure ParseVisionPrescriptionDispense(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
    function ParseVisionPrescription(jsn : TJsonObject) : TFhirVisionPrescription; overload;
    procedure ParseVisionPrescriptionProperties(jsn : TJsonObject; result : TFhirVisionPrescription); overload;
    procedure ParseVisionPrescription(jsn : TJsonObject; ctxt : TFHIRObjectList); overload; {b.}
{$ENDIF FHIR_VISIONPRESCRIPTION}
    function ParseResource(jsn : TJsonObject) : TFhirResource; override;
    function ParseDataType(jsn : TJsonObject; name : String; type_ : TFHIRTypeClass) : TFHIRType; override;
  public
    function ParseFragment(jsn : TJsonObject; type_ : String) : TFHIRObject;  overload;
  end;

  TFHIRJsonComposer = class (TFHIRJsonComposerBase2)
  protected
    procedure ComposeElement(json : TJSONWriter; name : string; elem : TFhirElement; noObj : boolean = false);

    Procedure ComposeElementProperties(json : TJSONWriter; elem : TFhirElement);
    Procedure ComposeBackboneElementProperties(json : TJSONWriter; elem : TFhirBackboneElement); overload;
    procedure ComposeBackboneElement(json : TJSONWriter; name : string; elem : TFhirBackboneElement; noObj : boolean = false);

    Procedure ComposeEnumValue(json : TJSONWriter; name : String; value : TFhirEnum; Const aNames : Array Of String; inArray : boolean);
    Procedure ComposeEnumProps(json : TJSONWriter; name : String; value : TFhirEnum; Const aNames : Array Of String; inArray : boolean);
    Procedure ComposeDateTimeValue(json : TJSONWriter; name : String; value : TFhirDateTime; inArray : boolean);
    Procedure ComposeDateTimeProps(json : TJSONWriter; name : String; value : TFhirDateTime; inArray : boolean);
    Procedure ComposeDateValue(json : TJSONWriter; name : String; value : TFhirDate; inArray : boolean);
    Procedure ComposeDateProps(json : TJSONWriter; name : String; value : TFhirDate; inArray : boolean);
    Procedure ComposeStringValue(json : TJSONWriter; name : String; value : TFhirString; inArray : boolean);
    Procedure ComposeStringProps(json : TJSONWriter; name : String; value : TFhirString; inArray : boolean);
    Procedure ComposeIntegerValue(json : TJSONWriter; name : String; value : TFhirInteger; inArray : boolean);
    Procedure ComposeIntegerProps(json : TJSONWriter; name : String; value : TFhirInteger; inArray : boolean);
    Procedure ComposeUriValue(json : TJSONWriter; name : String; value : TFhirUri; inArray : boolean);
    Procedure ComposeUriProps(json : TJSONWriter; name : String; value : TFhirUri; inArray : boolean);
    Procedure ComposeInstantValue(json : TJSONWriter; name : String; value : TFhirInstant; inArray : boolean);
    Procedure ComposeInstantProps(json : TJSONWriter; name : String; value : TFhirInstant; inArray : boolean);
    Procedure ComposeBooleanValue(json : TJSONWriter; name : String; value : TFhirBoolean; inArray : boolean);
    Procedure ComposeBooleanProps(json : TJSONWriter; name : String; value : TFhirBoolean; inArray : boolean);
    Procedure ComposeBase64BinaryValue(json : TJSONWriter; name : String; value : TFhirBase64Binary; inArray : boolean);
    Procedure ComposeBase64BinaryProps(json : TJSONWriter; name : String; value : TFhirBase64Binary; inArray : boolean);
    Procedure ComposeTimeValue(json : TJSONWriter; name : String; value : TFhirTime; inArray : boolean);
    Procedure ComposeTimeProps(json : TJSONWriter; name : String; value : TFhirTime; inArray : boolean);
    Procedure ComposeDecimalValue(json : TJSONWriter; name : String; value : TFhirDecimal; inArray : boolean);
    Procedure ComposeDecimalProps(json : TJSONWriter; name : String; value : TFhirDecimal; inArray : boolean);
    Procedure ComposeCodeValue(json : TJSONWriter; name : String; value : TFhirCode; inArray : boolean);
    Procedure ComposeCodeProps(json : TJSONWriter; name : String; value : TFhirCode; inArray : boolean);
    Procedure ComposeOidValue(json : TJSONWriter; name : String; value : TFhirOid; inArray : boolean);
    Procedure ComposeOidProps(json : TJSONWriter; name : String; value : TFhirOid; inArray : boolean);
    Procedure ComposeUuidValue(json : TJSONWriter; name : String; value : TFhirUuid; inArray : boolean);
    Procedure ComposeUuidProps(json : TJSONWriter; name : String; value : TFhirUuid; inArray : boolean);
    Procedure ComposeMarkdownValue(json : TJSONWriter; name : String; value : TFhirMarkdown; inArray : boolean);
    Procedure ComposeMarkdownProps(json : TJSONWriter; name : String; value : TFhirMarkdown; inArray : boolean);
    Procedure ComposeUnsignedIntValue(json : TJSONWriter; name : String; value : TFhirUnsignedInt; inArray : boolean);
    Procedure ComposeUnsignedIntProps(json : TJSONWriter; name : String; value : TFhirUnsignedInt; inArray : boolean);
    Procedure ComposeIdValue(json : TJSONWriter; name : String; value : TFhirId; inArray : boolean);
    Procedure ComposeIdProps(json : TJSONWriter; name : String; value : TFhirId; inArray : boolean);
    Procedure ComposePositiveIntValue(json : TJSONWriter; name : String; value : TFhirPositiveInt; inArray : boolean);
    Procedure ComposePositiveIntProps(json : TJSONWriter; name : String; value : TFhirPositiveInt; inArray : boolean);

    Procedure ComposeResourceProperties(json : TJSONWriter; elem : TFhirResource);
{$IFDEF FHIR_PARAMETERS}
    procedure ComposeParametersParameter(json : TJSONWriter; name : string; elem : TFhirParametersParameter; noObj : boolean = false);
    procedure ComposeParameters(json : TJSONWriter; name : string; elem : TFhirParameters; noObj : boolean = false);
{$ENDIF FHIR_PARAMETERS}
    Procedure ComposeDomainResourceProperties(json : TJSONWriter; elem : TFhirDomainResource);

    procedure ComposeExtension(json : TJSONWriter; name : string; elem : TFhirExtension; noObj : boolean = false);
    procedure ComposeNarrative(json : TJSONWriter; name : string; elem : TFhirNarrative; noObj : boolean = false);
    procedure ComposeIdentifier(json : TJSONWriter; name : string; elem : TFhirIdentifier; noObj : boolean = false);
    procedure ComposeCoding(json : TJSONWriter; name : string; elem : TFhirCoding; noObj : boolean = false);
    procedure ComposeReference(json : TJSONWriter; name : string; elem : TFhirReference; noObj : boolean = false);
    procedure ComposeSignature(json : TJSONWriter; name : string; elem : TFhirSignature; noObj : boolean = false);
    procedure ComposeSampledData(json : TJSONWriter; name : string; elem : TFhirSampledData; noObj : boolean = false);
    procedure ComposePeriod(json : TJSONWriter; name : string; elem : TFhirPeriod; noObj : boolean = false);
    procedure ComposeQuantity(json : TJSONWriter; name : string; elem : TFhirQuantity; noObj : boolean = false);
    procedure ComposeAttachment(json : TJSONWriter; name : string; elem : TFhirAttachment; noObj : boolean = false);
    procedure ComposeRatio(json : TJSONWriter; name : string; elem : TFhirRatio; noObj : boolean = false);
    procedure ComposeRange(json : TJSONWriter; name : string; elem : TFhirRange; noObj : boolean = false);
    procedure ComposeAnnotation(json : TJSONWriter; name : string; elem : TFhirAnnotation; noObj : boolean = false);
    procedure ComposeCodeableConcept(json : TJSONWriter; name : string; elem : TFhirCodeableConcept; noObj : boolean = false);
    procedure ComposeHumanName(json : TJSONWriter; name : string; elem : TFhirHumanName; noObj : boolean = false);
    procedure ComposeMeta(json : TJSONWriter; name : string; elem : TFhirMeta; noObj : boolean = false);
    procedure ComposeContactPoint(json : TJSONWriter; name : string; elem : TFhirContactPoint; noObj : boolean = false);
    procedure ComposeAddress(json : TJSONWriter; name : string; elem : TFhirAddress; noObj : boolean = false);
    procedure ComposeElementDefinitionSlicing(json : TJSONWriter; name : string; elem : TFhirElementDefinitionSlicing; noObj : boolean = false);
    procedure ComposeElementDefinitionBase(json : TJSONWriter; name : string; elem : TFhirElementDefinitionBase; noObj : boolean = false);
    procedure ComposeElementDefinitionType(json : TJSONWriter; name : string; elem : TFhirElementDefinitionType; noObj : boolean = false);
    procedure ComposeElementDefinitionConstraint(json : TJSONWriter; name : string; elem : TFhirElementDefinitionConstraint; noObj : boolean = false);
    procedure ComposeElementDefinitionBinding(json : TJSONWriter; name : string; elem : TFhirElementDefinitionBinding; noObj : boolean = false);
    procedure ComposeElementDefinitionMapping(json : TJSONWriter; name : string; elem : TFhirElementDefinitionMapping; noObj : boolean = false);
    procedure ComposeElementDefinition(json : TJSONWriter; name : string; elem : TFhirElementDefinition; noObj : boolean = false);
    procedure ComposeTimingRepeat(json : TJSONWriter; name : string; elem : TFhirTimingRepeat; noObj : boolean = false);
    procedure ComposeTiming(json : TJSONWriter; name : string; elem : TFhirTiming; noObj : boolean = false);

{$IFDEF FHIR_ACCOUNT}
    procedure ComposeAccount(json : TJSONWriter; name : string; elem : TFhirAccount; noObj : boolean = false);
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
    procedure ComposeAllergyIntoleranceReaction(json : TJSONWriter; name : string; elem : TFhirAllergyIntoleranceReaction; noObj : boolean = false);
    procedure ComposeAllergyIntolerance(json : TJSONWriter; name : string; elem : TFhirAllergyIntolerance; noObj : boolean = false);
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
    procedure ComposeAppointmentParticipant(json : TJSONWriter; name : string; elem : TFhirAppointmentParticipant; noObj : boolean = false);
    procedure ComposeAppointment(json : TJSONWriter; name : string; elem : TFhirAppointment; noObj : boolean = false);
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
    procedure ComposeAppointmentResponse(json : TJSONWriter; name : string; elem : TFhirAppointmentResponse; noObj : boolean = false);
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
    procedure ComposeAuditEventEvent(json : TJSONWriter; name : string; elem : TFhirAuditEventEvent; noObj : boolean = false);
    procedure ComposeAuditEventParticipant(json : TJSONWriter; name : string; elem : TFhirAuditEventParticipant; noObj : boolean = false);
    procedure ComposeAuditEventParticipantNetwork(json : TJSONWriter; name : string; elem : TFhirAuditEventParticipantNetwork; noObj : boolean = false);
    procedure ComposeAuditEventSource(json : TJSONWriter; name : string; elem : TFhirAuditEventSource; noObj : boolean = false);
    procedure ComposeAuditEventObject(json : TJSONWriter; name : string; elem : TFhirAuditEventObject; noObj : boolean = false);
    procedure ComposeAuditEventObjectDetail(json : TJSONWriter; name : string; elem : TFhirAuditEventObjectDetail; noObj : boolean = false);
    procedure ComposeAuditEvent(json : TJSONWriter; name : string; elem : TFhirAuditEvent; noObj : boolean = false);
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
    procedure ComposeBasic(json : TJSONWriter; name : string; elem : TFhirBasic; noObj : boolean = false);
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
    procedure ComposeBinary(json : TJSONWriter; name : string; elem : TFhirBinary; noObj : boolean = false);
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BODYSITE}
    procedure ComposeBodySite(json : TJSONWriter; name : string; elem : TFhirBodySite; noObj : boolean = false);
{$ENDIF FHIR_BODYSITE}
{$IFDEF FHIR_BUNDLE}
    procedure ComposeBundleLink(json : TJSONWriter; name : string; elem : TFhirBundleLink; noObj : boolean = false);
    procedure ComposeBundleEntry(json : TJSONWriter; name : string; elem : TFhirBundleEntry; noObj : boolean = false);
    procedure ComposeBundleEntrySearch(json : TJSONWriter; name : string; elem : TFhirBundleEntrySearch; noObj : boolean = false);
    procedure ComposeBundleEntryRequest(json : TJSONWriter; name : string; elem : TFhirBundleEntryRequest; noObj : boolean = false);
    procedure ComposeBundleEntryResponse(json : TJSONWriter; name : string; elem : TFhirBundleEntryResponse; noObj : boolean = false);
    procedure ComposeBundle(json : TJSONWriter; name : string; elem : TFhirBundle; noObj : boolean = false);
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAREPLAN}
    procedure ComposeCarePlanRelatedPlan(json : TJSONWriter; name : string; elem : TFhirCarePlanRelatedPlan; noObj : boolean = false);
    procedure ComposeCarePlanParticipant(json : TJSONWriter; name : string; elem : TFhirCarePlanParticipant; noObj : boolean = false);
    procedure ComposeCarePlanActivity(json : TJSONWriter; name : string; elem : TFhirCarePlanActivity; noObj : boolean = false);
    procedure ComposeCarePlanActivityDetail(json : TJSONWriter; name : string; elem : TFhirCarePlanActivityDetail; noObj : boolean = false);
    procedure ComposeCarePlan(json : TJSONWriter; name : string; elem : TFhirCarePlan; noObj : boolean = false);
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CLAIM}
    procedure ComposeClaimPayee(json : TJSONWriter; name : string; elem : TFhirClaimPayee; noObj : boolean = false);
    procedure ComposeClaimDiagnosis(json : TJSONWriter; name : string; elem : TFhirClaimDiagnosis; noObj : boolean = false);
    procedure ComposeClaimCoverage(json : TJSONWriter; name : string; elem : TFhirClaimCoverage; noObj : boolean = false);
    procedure ComposeClaimItem(json : TJSONWriter; name : string; elem : TFhirClaimItem; noObj : boolean = false);
    procedure ComposeClaimItemDetail(json : TJSONWriter; name : string; elem : TFhirClaimItemDetail; noObj : boolean = false);
    procedure ComposeClaimItemDetailSubDetail(json : TJSONWriter; name : string; elem : TFhirClaimItemDetailSubDetail; noObj : boolean = false);
    procedure ComposeClaimItemProsthesis(json : TJSONWriter; name : string; elem : TFhirClaimItemProsthesis; noObj : boolean = false);
    procedure ComposeClaimMissingTeeth(json : TJSONWriter; name : string; elem : TFhirClaimMissingTeeth; noObj : boolean = false);
    procedure ComposeClaim(json : TJSONWriter; name : string; elem : TFhirClaim; noObj : boolean = false);
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
    procedure ComposeClaimResponseItem(json : TJSONWriter; name : string; elem : TFhirClaimResponseItem; noObj : boolean = false);
    procedure ComposeClaimResponseItemAdjudication(json : TJSONWriter; name : string; elem : TFhirClaimResponseItemAdjudication; noObj : boolean = false);
    procedure ComposeClaimResponseItemDetail(json : TJSONWriter; name : string; elem : TFhirClaimResponseItemDetail; noObj : boolean = false);
    procedure ComposeClaimResponseItemDetailAdjudication(json : TJSONWriter; name : string; elem : TFhirClaimResponseItemDetailAdjudication; noObj : boolean = false);
    procedure ComposeClaimResponseItemDetailSubDetail(json : TJSONWriter; name : string; elem : TFhirClaimResponseItemDetailSubDetail; noObj : boolean = false);
    procedure ComposeClaimResponseItemDetailSubDetailAdjudication(json : TJSONWriter; name : string; elem : TFhirClaimResponseItemDetailSubDetailAdjudication; noObj : boolean = false);
    procedure ComposeClaimResponseAddItem(json : TJSONWriter; name : string; elem : TFhirClaimResponseAddItem; noObj : boolean = false);
    procedure ComposeClaimResponseAddItemAdjudication(json : TJSONWriter; name : string; elem : TFhirClaimResponseAddItemAdjudication; noObj : boolean = false);
    procedure ComposeClaimResponseAddItemDetail(json : TJSONWriter; name : string; elem : TFhirClaimResponseAddItemDetail; noObj : boolean = false);
    procedure ComposeClaimResponseAddItemDetailAdjudication(json : TJSONWriter; name : string; elem : TFhirClaimResponseAddItemDetailAdjudication; noObj : boolean = false);
    procedure ComposeClaimResponseError(json : TJSONWriter; name : string; elem : TFhirClaimResponseError; noObj : boolean = false);
    procedure ComposeClaimResponseNote(json : TJSONWriter; name : string; elem : TFhirClaimResponseNote; noObj : boolean = false);
    procedure ComposeClaimResponseCoverage(json : TJSONWriter; name : string; elem : TFhirClaimResponseCoverage; noObj : boolean = false);
    procedure ComposeClaimResponse(json : TJSONWriter; name : string; elem : TFhirClaimResponse; noObj : boolean = false);
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
    procedure ComposeClinicalImpressionInvestigations(json : TJSONWriter; name : string; elem : TFhirClinicalImpressionInvestigations; noObj : boolean = false);
    procedure ComposeClinicalImpressionFinding(json : TJSONWriter; name : string; elem : TFhirClinicalImpressionFinding; noObj : boolean = false);
    procedure ComposeClinicalImpressionRuledOut(json : TJSONWriter; name : string; elem : TFhirClinicalImpressionRuledOut; noObj : boolean = false);
    procedure ComposeClinicalImpression(json : TJSONWriter; name : string; elem : TFhirClinicalImpression; noObj : boolean = false);
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_COMMUNICATION}
    procedure ComposeCommunicationPayload(json : TJSONWriter; name : string; elem : TFhirCommunicationPayload; noObj : boolean = false);
    procedure ComposeCommunication(json : TJSONWriter; name : string; elem : TFhirCommunication; noObj : boolean = false);
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
    procedure ComposeCommunicationRequestPayload(json : TJSONWriter; name : string; elem : TFhirCommunicationRequestPayload; noObj : boolean = false);
    procedure ComposeCommunicationRequest(json : TJSONWriter; name : string; elem : TFhirCommunicationRequest; noObj : boolean = false);
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPOSITION}
    procedure ComposeCompositionAttester(json : TJSONWriter; name : string; elem : TFhirCompositionAttester; noObj : boolean = false);
    procedure ComposeCompositionEvent(json : TJSONWriter; name : string; elem : TFhirCompositionEvent; noObj : boolean = false);
    procedure ComposeCompositionSection(json : TJSONWriter; name : string; elem : TFhirCompositionSection; noObj : boolean = false);
    procedure ComposeComposition(json : TJSONWriter; name : string; elem : TFhirComposition; noObj : boolean = false);
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
    procedure ComposeConceptMapContact(json : TJSONWriter; name : string; elem : TFhirConceptMapContact; noObj : boolean = false);
    procedure ComposeConceptMapElement(json : TJSONWriter; name : string; elem : TFhirConceptMapElement; noObj : boolean = false);
    procedure ComposeConceptMapElementTarget(json : TJSONWriter; name : string; elem : TFhirConceptMapElementTarget; noObj : boolean = false);
    procedure ComposeConceptMapElementTargetDependsOn(json : TJSONWriter; name : string; elem : TFhirConceptMapElementTargetDependsOn; noObj : boolean = false);
    procedure ComposeConceptMap(json : TJSONWriter; name : string; elem : TFhirConceptMap; noObj : boolean = false);
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
    procedure ComposeConditionStage(json : TJSONWriter; name : string; elem : TFhirConditionStage; noObj : boolean = false);
    procedure ComposeConditionEvidence(json : TJSONWriter; name : string; elem : TFhirConditionEvidence; noObj : boolean = false);
    procedure ComposeCondition(json : TJSONWriter; name : string; elem : TFhirCondition; noObj : boolean = false);
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONFORMANCE}
    procedure ComposeConformanceContact(json : TJSONWriter; name : string; elem : TFhirConformanceContact; noObj : boolean = false);
    procedure ComposeConformanceSoftware(json : TJSONWriter; name : string; elem : TFhirConformanceSoftware; noObj : boolean = false);
    procedure ComposeConformanceImplementation(json : TJSONWriter; name : string; elem : TFhirConformanceImplementation; noObj : boolean = false);
    procedure ComposeConformanceRest(json : TJSONWriter; name : string; elem : TFhirConformanceRest; noObj : boolean = false);
    procedure ComposeConformanceRestSecurity(json : TJSONWriter; name : string; elem : TFhirConformanceRestSecurity; noObj : boolean = false);
    procedure ComposeConformanceRestSecurityCertificate(json : TJSONWriter; name : string; elem : TFhirConformanceRestSecurityCertificate; noObj : boolean = false);
    procedure ComposeConformanceRestResource(json : TJSONWriter; name : string; elem : TFhirConformanceRestResource; noObj : boolean = false);
    procedure ComposeConformanceRestResourceInteraction(json : TJSONWriter; name : string; elem : TFhirConformanceRestResourceInteraction; noObj : boolean = false);
    procedure ComposeConformanceRestResourceSearchParam(json : TJSONWriter; name : string; elem : TFhirConformanceRestResourceSearchParam; noObj : boolean = false);
    procedure ComposeConformanceRestInteraction(json : TJSONWriter; name : string; elem : TFhirConformanceRestInteraction; noObj : boolean = false);
    procedure ComposeConformanceRestOperation(json : TJSONWriter; name : string; elem : TFhirConformanceRestOperation; noObj : boolean = false);
    procedure ComposeConformanceMessaging(json : TJSONWriter; name : string; elem : TFhirConformanceMessaging; noObj : boolean = false);
    procedure ComposeConformanceMessagingEndpoint(json : TJSONWriter; name : string; elem : TFhirConformanceMessagingEndpoint; noObj : boolean = false);
    procedure ComposeConformanceMessagingEvent(json : TJSONWriter; name : string; elem : TFhirConformanceMessagingEvent; noObj : boolean = false);
    procedure ComposeConformanceDocument(json : TJSONWriter; name : string; elem : TFhirConformanceDocument; noObj : boolean = false);
    procedure ComposeConformance(json : TJSONWriter; name : string; elem : TFhirConformance; noObj : boolean = false);
{$ENDIF FHIR_CONFORMANCE}
{$IFDEF FHIR_CONTRACT}
    procedure ComposeContractActor(json : TJSONWriter; name : string; elem : TFhirContractActor; noObj : boolean = false);
    procedure ComposeContractValuedItem(json : TJSONWriter; name : string; elem : TFhirContractValuedItem; noObj : boolean = false);
    procedure ComposeContractSigner(json : TJSONWriter; name : string; elem : TFhirContractSigner; noObj : boolean = false);
    procedure ComposeContractTerm(json : TJSONWriter; name : string; elem : TFhirContractTerm; noObj : boolean = false);
    procedure ComposeContractTermActor(json : TJSONWriter; name : string; elem : TFhirContractTermActor; noObj : boolean = false);
    procedure ComposeContractTermValuedItem(json : TJSONWriter; name : string; elem : TFhirContractTermValuedItem; noObj : boolean = false);
    procedure ComposeContractFriendly(json : TJSONWriter; name : string; elem : TFhirContractFriendly; noObj : boolean = false);
    procedure ComposeContractLegal(json : TJSONWriter; name : string; elem : TFhirContractLegal; noObj : boolean = false);
    procedure ComposeContractRule(json : TJSONWriter; name : string; elem : TFhirContractRule; noObj : boolean = false);
    procedure ComposeContract(json : TJSONWriter; name : string; elem : TFhirContract; noObj : boolean = false);
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
    procedure ComposeCoverage(json : TJSONWriter; name : string; elem : TFhirCoverage; noObj : boolean = false);
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_DATAELEMENT}
    procedure ComposeDataElementContact(json : TJSONWriter; name : string; elem : TFhirDataElementContact; noObj : boolean = false);
    procedure ComposeDataElementMapping(json : TJSONWriter; name : string; elem : TFhirDataElementMapping; noObj : boolean = false);
    procedure ComposeDataElement(json : TJSONWriter; name : string; elem : TFhirDataElement; noObj : boolean = false);
{$ENDIF FHIR_DATAELEMENT}
{$IFDEF FHIR_DETECTEDISSUE}
    procedure ComposeDetectedIssueMitigation(json : TJSONWriter; name : string; elem : TFhirDetectedIssueMitigation; noObj : boolean = false);
    procedure ComposeDetectedIssue(json : TJSONWriter; name : string; elem : TFhirDetectedIssue; noObj : boolean = false);
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
    procedure ComposeDevice(json : TJSONWriter; name : string; elem : TFhirDevice; noObj : boolean = false);
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICECOMPONENT}
    procedure ComposeDeviceComponentProductionSpecification(json : TJSONWriter; name : string; elem : TFhirDeviceComponentProductionSpecification; noObj : boolean = false);
    procedure ComposeDeviceComponent(json : TJSONWriter; name : string; elem : TFhirDeviceComponent; noObj : boolean = false);
{$ENDIF FHIR_DEVICECOMPONENT}
{$IFDEF FHIR_DEVICEMETRIC}
    procedure ComposeDeviceMetricCalibration(json : TJSONWriter; name : string; elem : TFhirDeviceMetricCalibration; noObj : boolean = false);
    procedure ComposeDeviceMetric(json : TJSONWriter; name : string; elem : TFhirDeviceMetric; noObj : boolean = false);
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEUSEREQUEST}
    procedure ComposeDeviceUseRequest(json : TJSONWriter; name : string; elem : TFhirDeviceUseRequest; noObj : boolean = false);
{$ENDIF FHIR_DEVICEUSEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
    procedure ComposeDeviceUseStatement(json : TJSONWriter; name : string; elem : TFhirDeviceUseStatement; noObj : boolean = false);
{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICORDER}
    procedure ComposeDiagnosticOrderEvent(json : TJSONWriter; name : string; elem : TFhirDiagnosticOrderEvent; noObj : boolean = false);
    procedure ComposeDiagnosticOrderItem(json : TJSONWriter; name : string; elem : TFhirDiagnosticOrderItem; noObj : boolean = false);
    procedure ComposeDiagnosticOrder(json : TJSONWriter; name : string; elem : TFhirDiagnosticOrder; noObj : boolean = false);
{$ENDIF FHIR_DIAGNOSTICORDER}
{$IFDEF FHIR_DIAGNOSTICREPORT}
    procedure ComposeDiagnosticReportImage(json : TJSONWriter; name : string; elem : TFhirDiagnosticReportImage; noObj : boolean = false);
    procedure ComposeDiagnosticReport(json : TJSONWriter; name : string; elem : TFhirDiagnosticReport; noObj : boolean = false);
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
    procedure ComposeDocumentManifestContent(json : TJSONWriter; name : string; elem : TFhirDocumentManifestContent; noObj : boolean = false);
    procedure ComposeDocumentManifestRelated(json : TJSONWriter; name : string; elem : TFhirDocumentManifestRelated; noObj : boolean = false);
    procedure ComposeDocumentManifest(json : TJSONWriter; name : string; elem : TFhirDocumentManifest; noObj : boolean = false);
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
    procedure ComposeDocumentReferenceRelatesTo(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceRelatesTo; noObj : boolean = false);
    procedure ComposeDocumentReferenceContent(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceContent; noObj : boolean = false);
    procedure ComposeDocumentReferenceContext(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceContext; noObj : boolean = false);
    procedure ComposeDocumentReferenceContextRelated(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceContextRelated; noObj : boolean = false);
    procedure ComposeDocumentReference(json : TJSONWriter; name : string; elem : TFhirDocumentReference; noObj : boolean = false);
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ELIGIBILITYREQUEST}
    procedure ComposeEligibilityRequest(json : TJSONWriter; name : string; elem : TFhirEligibilityRequest; noObj : boolean = false);
{$ENDIF FHIR_ELIGIBILITYREQUEST}
{$IFDEF FHIR_ELIGIBILITYRESPONSE}
    procedure ComposeEligibilityResponse(json : TJSONWriter; name : string; elem : TFhirEligibilityResponse; noObj : boolean = false);
{$ENDIF FHIR_ELIGIBILITYRESPONSE}
{$IFDEF FHIR_ENCOUNTER}
    procedure ComposeEncounterStatusHistory(json : TJSONWriter; name : string; elem : TFhirEncounterStatusHistory; noObj : boolean = false);
    procedure ComposeEncounterParticipant(json : TJSONWriter; name : string; elem : TFhirEncounterParticipant; noObj : boolean = false);
    procedure ComposeEncounterHospitalization(json : TJSONWriter; name : string; elem : TFhirEncounterHospitalization; noObj : boolean = false);
    procedure ComposeEncounterLocation(json : TJSONWriter; name : string; elem : TFhirEncounterLocation; noObj : boolean = false);
    procedure ComposeEncounter(json : TJSONWriter; name : string; elem : TFhirEncounter; noObj : boolean = false);
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENROLLMENTREQUEST}
    procedure ComposeEnrollmentRequest(json : TJSONWriter; name : string; elem : TFhirEnrollmentRequest; noObj : boolean = false);
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
    procedure ComposeEnrollmentResponse(json : TJSONWriter; name : string; elem : TFhirEnrollmentResponse; noObj : boolean = false);
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
    procedure ComposeEpisodeOfCareStatusHistory(json : TJSONWriter; name : string; elem : TFhirEpisodeOfCareStatusHistory; noObj : boolean = false);
    procedure ComposeEpisodeOfCareCareTeam(json : TJSONWriter; name : string; elem : TFhirEpisodeOfCareCareTeam; noObj : boolean = false);
    procedure ComposeEpisodeOfCare(json : TJSONWriter; name : string; elem : TFhirEpisodeOfCare; noObj : boolean = false);
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
    procedure ComposeExplanationOfBenefit(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefit; noObj : boolean = false);
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
    procedure ComposeFamilyMemberHistoryCondition(json : TJSONWriter; name : string; elem : TFhirFamilyMemberHistoryCondition; noObj : boolean = false);
    procedure ComposeFamilyMemberHistory(json : TJSONWriter; name : string; elem : TFhirFamilyMemberHistory; noObj : boolean = false);
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
    procedure ComposeFlag(json : TJSONWriter; name : string; elem : TFhirFlag; noObj : boolean = false);
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
    procedure ComposeGoalOutcome(json : TJSONWriter; name : string; elem : TFhirGoalOutcome; noObj : boolean = false);
    procedure ComposeGoal(json : TJSONWriter; name : string; elem : TFhirGoal; noObj : boolean = false);
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GROUP}
    procedure ComposeGroupCharacteristic(json : TJSONWriter; name : string; elem : TFhirGroupCharacteristic; noObj : boolean = false);
    procedure ComposeGroupMember(json : TJSONWriter; name : string; elem : TFhirGroupMember; noObj : boolean = false);
    procedure ComposeGroup(json : TJSONWriter; name : string; elem : TFhirGroup; noObj : boolean = false);
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_HEALTHCARESERVICE}
    procedure ComposeHealthcareServiceServiceType(json : TJSONWriter; name : string; elem : TFhirHealthcareServiceServiceType; noObj : boolean = false);
    procedure ComposeHealthcareServiceAvailableTime(json : TJSONWriter; name : string; elem : TFhirHealthcareServiceAvailableTime; noObj : boolean = false);
    procedure ComposeHealthcareServiceNotAvailable(json : TJSONWriter; name : string; elem : TFhirHealthcareServiceNotAvailable; noObj : boolean = false);
    procedure ComposeHealthcareService(json : TJSONWriter; name : string; elem : TFhirHealthcareService; noObj : boolean = false);
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGOBJECTSELECTION}
    procedure ComposeImagingObjectSelectionStudy(json : TJSONWriter; name : string; elem : TFhirImagingObjectSelectionStudy; noObj : boolean = false);
    procedure ComposeImagingObjectSelectionStudySeries(json : TJSONWriter; name : string; elem : TFhirImagingObjectSelectionStudySeries; noObj : boolean = false);
    procedure ComposeImagingObjectSelectionStudySeriesInstance(json : TJSONWriter; name : string; elem : TFhirImagingObjectSelectionStudySeriesInstance; noObj : boolean = false);
    procedure ComposeImagingObjectSelectionStudySeriesInstanceFrames(json : TJSONWriter; name : string; elem : TFhirImagingObjectSelectionStudySeriesInstanceFrames; noObj : boolean = false);
    procedure ComposeImagingObjectSelection(json : TJSONWriter; name : string; elem : TFhirImagingObjectSelection; noObj : boolean = false);
{$ENDIF FHIR_IMAGINGOBJECTSELECTION}
{$IFDEF FHIR_IMAGINGSTUDY}
    procedure ComposeImagingStudySeries(json : TJSONWriter; name : string; elem : TFhirImagingStudySeries; noObj : boolean = false);
    procedure ComposeImagingStudySeriesInstance(json : TJSONWriter; name : string; elem : TFhirImagingStudySeriesInstance; noObj : boolean = false);
    procedure ComposeImagingStudy(json : TJSONWriter; name : string; elem : TFhirImagingStudy; noObj : boolean = false);
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
    procedure ComposeImmunizationExplanation(json : TJSONWriter; name : string; elem : TFhirImmunizationExplanation; noObj : boolean = false);
    procedure ComposeImmunizationReaction(json : TJSONWriter; name : string; elem : TFhirImmunizationReaction; noObj : boolean = false);
    procedure ComposeImmunizationVaccinationProtocol(json : TJSONWriter; name : string; elem : TFhirImmunizationVaccinationProtocol; noObj : boolean = false);
    procedure ComposeImmunization(json : TJSONWriter; name : string; elem : TFhirImmunization; noObj : boolean = false);
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
    procedure ComposeImmunizationRecommendationRecommendation(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendationRecommendation; noObj : boolean = false);
    procedure ComposeImmunizationRecommendationRecommendationDateCriterion(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendationRecommendationDateCriterion; noObj : boolean = false);
    procedure ComposeImmunizationRecommendationRecommendationProtocol(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendationRecommendationProtocol; noObj : boolean = false);
    procedure ComposeImmunizationRecommendation(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendation; noObj : boolean = false);
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
    procedure ComposeImplementationGuideContact(json : TJSONWriter; name : string; elem : TFhirImplementationGuideContact; noObj : boolean = false);
    procedure ComposeImplementationGuideDependency(json : TJSONWriter; name : string; elem : TFhirImplementationGuideDependency; noObj : boolean = false);
    procedure ComposeImplementationGuidePackage(json : TJSONWriter; name : string; elem : TFhirImplementationGuidePackage; noObj : boolean = false);
    procedure ComposeImplementationGuidePackageResource(json : TJSONWriter; name : string; elem : TFhirImplementationGuidePackageResource; noObj : boolean = false);
    procedure ComposeImplementationGuideGlobal(json : TJSONWriter; name : string; elem : TFhirImplementationGuideGlobal; noObj : boolean = false);
    procedure ComposeImplementationGuidePage(json : TJSONWriter; name : string; elem : TFhirImplementationGuidePage; noObj : boolean = false);
    procedure ComposeImplementationGuide(json : TJSONWriter; name : string; elem : TFhirImplementationGuide; noObj : boolean = false);
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_LIST}
    procedure ComposeListEntry(json : TJSONWriter; name : string; elem : TFhirListEntry; noObj : boolean = false);
    procedure ComposeList(json : TJSONWriter; name : string; elem : TFhirList; noObj : boolean = false);
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
    procedure ComposeLocationPosition(json : TJSONWriter; name : string; elem : TFhirLocationPosition; noObj : boolean = false);
    procedure ComposeLocation(json : TJSONWriter; name : string; elem : TFhirLocation; noObj : boolean = false);
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEDIA}
    procedure ComposeMedia(json : TJSONWriter; name : string; elem : TFhirMedia; noObj : boolean = false);
{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
    procedure ComposeMedicationProduct(json : TJSONWriter; name : string; elem : TFhirMedicationProduct; noObj : boolean = false);
    procedure ComposeMedicationProductIngredient(json : TJSONWriter; name : string; elem : TFhirMedicationProductIngredient; noObj : boolean = false);
    procedure ComposeMedicationProductBatch(json : TJSONWriter; name : string; elem : TFhirMedicationProductBatch; noObj : boolean = false);
    procedure ComposeMedicationPackage(json : TJSONWriter; name : string; elem : TFhirMedicationPackage; noObj : boolean = false);
    procedure ComposeMedicationPackageContent(json : TJSONWriter; name : string; elem : TFhirMedicationPackageContent; noObj : boolean = false);
    procedure ComposeMedication(json : TJSONWriter; name : string; elem : TFhirMedication; noObj : boolean = false);
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
    procedure ComposeMedicationAdministrationDosage(json : TJSONWriter; name : string; elem : TFhirMedicationAdministrationDosage; noObj : boolean = false);
    procedure ComposeMedicationAdministration(json : TJSONWriter; name : string; elem : TFhirMedicationAdministration; noObj : boolean = false);
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
    procedure ComposeMedicationDispenseDosageInstruction(json : TJSONWriter; name : string; elem : TFhirMedicationDispenseDosageInstruction; noObj : boolean = false);
    procedure ComposeMedicationDispenseSubstitution(json : TJSONWriter; name : string; elem : TFhirMedicationDispenseSubstitution; noObj : boolean = false);
    procedure ComposeMedicationDispense(json : TJSONWriter; name : string; elem : TFhirMedicationDispense; noObj : boolean = false);
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONORDER}
    procedure ComposeMedicationOrderDosageInstruction(json : TJSONWriter; name : string; elem : TFhirMedicationOrderDosageInstruction; noObj : boolean = false);
    procedure ComposeMedicationOrderDispenseRequest(json : TJSONWriter; name : string; elem : TFhirMedicationOrderDispenseRequest; noObj : boolean = false);
    procedure ComposeMedicationOrderSubstitution(json : TJSONWriter; name : string; elem : TFhirMedicationOrderSubstitution; noObj : boolean = false);
    procedure ComposeMedicationOrder(json : TJSONWriter; name : string; elem : TFhirMedicationOrder; noObj : boolean = false);
{$ENDIF FHIR_MEDICATIONORDER}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
    procedure ComposeMedicationStatementDosage(json : TJSONWriter; name : string; elem : TFhirMedicationStatementDosage; noObj : boolean = false);
    procedure ComposeMedicationStatement(json : TJSONWriter; name : string; elem : TFhirMedicationStatement; noObj : boolean = false);
{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MESSAGEHEADER}
    procedure ComposeMessageHeaderResponse(json : TJSONWriter; name : string; elem : TFhirMessageHeaderResponse; noObj : boolean = false);
    procedure ComposeMessageHeaderSource(json : TJSONWriter; name : string; elem : TFhirMessageHeaderSource; noObj : boolean = false);
    procedure ComposeMessageHeaderDestination(json : TJSONWriter; name : string; elem : TFhirMessageHeaderDestination; noObj : boolean = false);
    procedure ComposeMessageHeader(json : TJSONWriter; name : string; elem : TFhirMessageHeader; noObj : boolean = false);
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_NAMINGSYSTEM}
    procedure ComposeNamingSystemContact(json : TJSONWriter; name : string; elem : TFhirNamingSystemContact; noObj : boolean = false);
    procedure ComposeNamingSystemUniqueId(json : TJSONWriter; name : string; elem : TFhirNamingSystemUniqueId; noObj : boolean = false);
    procedure ComposeNamingSystem(json : TJSONWriter; name : string; elem : TFhirNamingSystem; noObj : boolean = false);
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
    procedure ComposeNutritionOrderOralDiet(json : TJSONWriter; name : string; elem : TFhirNutritionOrderOralDiet; noObj : boolean = false);
    procedure ComposeNutritionOrderOralDietNutrient(json : TJSONWriter; name : string; elem : TFhirNutritionOrderOralDietNutrient; noObj : boolean = false);
    procedure ComposeNutritionOrderOralDietTexture(json : TJSONWriter; name : string; elem : TFhirNutritionOrderOralDietTexture; noObj : boolean = false);
    procedure ComposeNutritionOrderSupplement(json : TJSONWriter; name : string; elem : TFhirNutritionOrderSupplement; noObj : boolean = false);
    procedure ComposeNutritionOrderEnteralFormula(json : TJSONWriter; name : string; elem : TFhirNutritionOrderEnteralFormula; noObj : boolean = false);
    procedure ComposeNutritionOrderEnteralFormulaAdministration(json : TJSONWriter; name : string; elem : TFhirNutritionOrderEnteralFormulaAdministration; noObj : boolean = false);
    procedure ComposeNutritionOrder(json : TJSONWriter; name : string; elem : TFhirNutritionOrder; noObj : boolean = false);
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
    procedure ComposeObservationReferenceRange(json : TJSONWriter; name : string; elem : TFhirObservationReferenceRange; noObj : boolean = false);
    procedure ComposeObservationRelated(json : TJSONWriter; name : string; elem : TFhirObservationRelated; noObj : boolean = false);
    procedure ComposeObservationComponent(json : TJSONWriter; name : string; elem : TFhirObservationComponent; noObj : boolean = false);
    procedure ComposeObservation(json : TJSONWriter; name : string; elem : TFhirObservation; noObj : boolean = false);
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OPERATIONDEFINITION}
    procedure ComposeOperationDefinitionContact(json : TJSONWriter; name : string; elem : TFhirOperationDefinitionContact; noObj : boolean = false);
    procedure ComposeOperationDefinitionParameter(json : TJSONWriter; name : string; elem : TFhirOperationDefinitionParameter; noObj : boolean = false);
    procedure ComposeOperationDefinitionParameterBinding(json : TJSONWriter; name : string; elem : TFhirOperationDefinitionParameterBinding; noObj : boolean = false);
    procedure ComposeOperationDefinition(json : TJSONWriter; name : string; elem : TFhirOperationDefinition; noObj : boolean = false);
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
    procedure ComposeOperationOutcomeIssue(json : TJSONWriter; name : string; elem : TFhirOperationOutcomeIssue; noObj : boolean = false);
    procedure ComposeOperationOutcome(json : TJSONWriter; name : string; elem : TFhirOperationOutcome; noObj : boolean = false);
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORDER}
    procedure ComposeOrderWhen(json : TJSONWriter; name : string; elem : TFhirOrderWhen; noObj : boolean = false);
    procedure ComposeOrder(json : TJSONWriter; name : string; elem : TFhirOrder; noObj : boolean = false);
{$ENDIF FHIR_ORDER}
{$IFDEF FHIR_ORDERRESPONSE}
    procedure ComposeOrderResponse(json : TJSONWriter; name : string; elem : TFhirOrderResponse; noObj : boolean = false);
{$ENDIF FHIR_ORDERRESPONSE}
{$IFDEF FHIR_ORGANIZATION}
    procedure ComposeOrganizationContact(json : TJSONWriter; name : string; elem : TFhirOrganizationContact; noObj : boolean = false);
    procedure ComposeOrganization(json : TJSONWriter; name : string; elem : TFhirOrganization; noObj : boolean = false);
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_PATIENT}
    procedure ComposePatientContact(json : TJSONWriter; name : string; elem : TFhirPatientContact; noObj : boolean = false);
    procedure ComposePatientAnimal(json : TJSONWriter; name : string; elem : TFhirPatientAnimal; noObj : boolean = false);
    procedure ComposePatientCommunication(json : TJSONWriter; name : string; elem : TFhirPatientCommunication; noObj : boolean = false);
    procedure ComposePatientLink(json : TJSONWriter; name : string; elem : TFhirPatientLink; noObj : boolean = false);
    procedure ComposePatient(json : TJSONWriter; name : string; elem : TFhirPatient; noObj : boolean = false);
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
    procedure ComposePaymentNotice(json : TJSONWriter; name : string; elem : TFhirPaymentNotice; noObj : boolean = false);
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
    procedure ComposePaymentReconciliationDetail(json : TJSONWriter; name : string; elem : TFhirPaymentReconciliationDetail; noObj : boolean = false);
    procedure ComposePaymentReconciliationNote(json : TJSONWriter; name : string; elem : TFhirPaymentReconciliationNote; noObj : boolean = false);
    procedure ComposePaymentReconciliation(json : TJSONWriter; name : string; elem : TFhirPaymentReconciliation; noObj : boolean = false);
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
    procedure ComposePersonLink(json : TJSONWriter; name : string; elem : TFhirPersonLink; noObj : boolean = false);
    procedure ComposePerson(json : TJSONWriter; name : string; elem : TFhirPerson; noObj : boolean = false);
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PRACTITIONER}
    procedure ComposePractitionerPractitionerRole(json : TJSONWriter; name : string; elem : TFhirPractitionerPractitionerRole; noObj : boolean = false);
    procedure ComposePractitionerQualification(json : TJSONWriter; name : string; elem : TFhirPractitionerQualification; noObj : boolean = false);
    procedure ComposePractitioner(json : TJSONWriter; name : string; elem : TFhirPractitioner; noObj : boolean = false);
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PROCEDURE}
    procedure ComposeProcedurePerformer(json : TJSONWriter; name : string; elem : TFhirProcedurePerformer; noObj : boolean = false);
    procedure ComposeProcedureFocalDevice(json : TJSONWriter; name : string; elem : TFhirProcedureFocalDevice; noObj : boolean = false);
    procedure ComposeProcedure(json : TJSONWriter; name : string; elem : TFhirProcedure; noObj : boolean = false);
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROCEDUREREQUEST}
    procedure ComposeProcedureRequest(json : TJSONWriter; name : string; elem : TFhirProcedureRequest; noObj : boolean = false);
{$ENDIF FHIR_PROCEDUREREQUEST}
{$IFDEF FHIR_PROCESSREQUEST}
    procedure ComposeProcessRequestItem(json : TJSONWriter; name : string; elem : TFhirProcessRequestItem; noObj : boolean = false);
    procedure ComposeProcessRequest(json : TJSONWriter; name : string; elem : TFhirProcessRequest; noObj : boolean = false);
{$ENDIF FHIR_PROCESSREQUEST}
{$IFDEF FHIR_PROCESSRESPONSE}
    procedure ComposeProcessResponseNotes(json : TJSONWriter; name : string; elem : TFhirProcessResponseNotes; noObj : boolean = false);
    procedure ComposeProcessResponse(json : TJSONWriter; name : string; elem : TFhirProcessResponse; noObj : boolean = false);
{$ENDIF FHIR_PROCESSRESPONSE}
{$IFDEF FHIR_PROVENANCE}
    procedure ComposeProvenanceAgent(json : TJSONWriter; name : string; elem : TFhirProvenanceAgent; noObj : boolean = false);
    procedure ComposeProvenanceAgentRelatedAgent(json : TJSONWriter; name : string; elem : TFhirProvenanceAgentRelatedAgent; noObj : boolean = false);
    procedure ComposeProvenanceEntity(json : TJSONWriter; name : string; elem : TFhirProvenanceEntity; noObj : boolean = false);
    procedure ComposeProvenance(json : TJSONWriter; name : string; elem : TFhirProvenance; noObj : boolean = false);
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
    procedure ComposeQuestionnaireGroup(json : TJSONWriter; name : string; elem : TFhirQuestionnaireGroup; noObj : boolean = false);
    procedure ComposeQuestionnaireGroupQuestion(json : TJSONWriter; name : string; elem : TFhirQuestionnaireGroupQuestion; noObj : boolean = false);
    procedure ComposeQuestionnaire(json : TJSONWriter; name : string; elem : TFhirQuestionnaire; noObj : boolean = false);
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
    procedure ComposeQuestionnaireResponseGroup(json : TJSONWriter; name : string; elem : TFhirQuestionnaireResponseGroup; noObj : boolean = false);
    procedure ComposeQuestionnaireResponseGroupQuestion(json : TJSONWriter; name : string; elem : TFhirQuestionnaireResponseGroupQuestion; noObj : boolean = false);
    procedure ComposeQuestionnaireResponseGroupQuestionAnswer(json : TJSONWriter; name : string; elem : TFhirQuestionnaireResponseGroupQuestionAnswer; noObj : boolean = false);
    procedure ComposeQuestionnaireResponse(json : TJSONWriter; name : string; elem : TFhirQuestionnaireResponse; noObj : boolean = false);
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REFERRALREQUEST}
    procedure ComposeReferralRequest(json : TJSONWriter; name : string; elem : TFhirReferralRequest; noObj : boolean = false);
{$ENDIF FHIR_REFERRALREQUEST}
{$IFDEF FHIR_RELATEDPERSON}
    procedure ComposeRelatedPerson(json : TJSONWriter; name : string; elem : TFhirRelatedPerson; noObj : boolean = false);
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_RISKASSESSMENT}
    procedure ComposeRiskAssessmentPrediction(json : TJSONWriter; name : string; elem : TFhirRiskAssessmentPrediction; noObj : boolean = false);
    procedure ComposeRiskAssessment(json : TJSONWriter; name : string; elem : TFhirRiskAssessment; noObj : boolean = false);
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
    procedure ComposeSchedule(json : TJSONWriter; name : string; elem : TFhirSchedule; noObj : boolean = false);
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
    procedure ComposeSearchParameterContact(json : TJSONWriter; name : string; elem : TFhirSearchParameterContact; noObj : boolean = false);
    procedure ComposeSearchParameter(json : TJSONWriter; name : string; elem : TFhirSearchParameter; noObj : boolean = false);
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SLOT}
    procedure ComposeSlot(json : TJSONWriter; name : string; elem : TFhirSlot; noObj : boolean = false);
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
    procedure ComposeSpecimenCollection(json : TJSONWriter; name : string; elem : TFhirSpecimenCollection; noObj : boolean = false);
    procedure ComposeSpecimenTreatment(json : TJSONWriter; name : string; elem : TFhirSpecimenTreatment; noObj : boolean = false);
    procedure ComposeSpecimenContainer(json : TJSONWriter; name : string; elem : TFhirSpecimenContainer; noObj : boolean = false);
    procedure ComposeSpecimen(json : TJSONWriter; name : string; elem : TFhirSpecimen; noObj : boolean = false);
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_STRUCTUREDEFINITION}
    procedure ComposeStructureDefinitionContact(json : TJSONWriter; name : string; elem : TFhirStructureDefinitionContact; noObj : boolean = false);
    procedure ComposeStructureDefinitionMapping(json : TJSONWriter; name : string; elem : TFhirStructureDefinitionMapping; noObj : boolean = false);
    procedure ComposeStructureDefinitionSnapshot(json : TJSONWriter; name : string; elem : TFhirStructureDefinitionSnapshot; noObj : boolean = false);
    procedure ComposeStructureDefinitionDifferential(json : TJSONWriter; name : string; elem : TFhirStructureDefinitionDifferential; noObj : boolean = false);
    procedure ComposeStructureDefinition(json : TJSONWriter; name : string; elem : TFhirStructureDefinition; noObj : boolean = false);
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_SUBSCRIPTION}
    procedure ComposeSubscriptionChannel(json : TJSONWriter; name : string; elem : TFhirSubscriptionChannel; noObj : boolean = false);
    procedure ComposeSubscription(json : TJSONWriter; name : string; elem : TFhirSubscription; noObj : boolean = false);
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
    procedure ComposeSubstanceInstance(json : TJSONWriter; name : string; elem : TFhirSubstanceInstance; noObj : boolean = false);
    procedure ComposeSubstanceIngredient(json : TJSONWriter; name : string; elem : TFhirSubstanceIngredient; noObj : boolean = false);
    procedure ComposeSubstance(json : TJSONWriter; name : string; elem : TFhirSubstance; noObj : boolean = false);
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUPPLYDELIVERY}
    procedure ComposeSupplyDelivery(json : TJSONWriter; name : string; elem : TFhirSupplyDelivery; noObj : boolean = false);
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
    procedure ComposeSupplyRequestWhen(json : TJSONWriter; name : string; elem : TFhirSupplyRequestWhen; noObj : boolean = false);
    procedure ComposeSupplyRequest(json : TJSONWriter; name : string; elem : TFhirSupplyRequest; noObj : boolean = false);
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TESTSCRIPT}
    procedure ComposeTestScriptContact(json : TJSONWriter; name : string; elem : TFhirTestScriptContact; noObj : boolean = false);
    procedure ComposeTestScriptMetadata(json : TJSONWriter; name : string; elem : TFhirTestScriptMetadata; noObj : boolean = false);
    procedure ComposeTestScriptMetadataLink(json : TJSONWriter; name : string; elem : TFhirTestScriptMetadataLink; noObj : boolean = false);
    procedure ComposeTestScriptMetadataCapability(json : TJSONWriter; name : string; elem : TFhirTestScriptMetadataCapability; noObj : boolean = false);
    procedure ComposeTestScriptFixture(json : TJSONWriter; name : string; elem : TFhirTestScriptFixture; noObj : boolean = false);
    procedure ComposeTestScriptVariable(json : TJSONWriter; name : string; elem : TFhirTestScriptVariable; noObj : boolean = false);
    procedure ComposeTestScriptSetup(json : TJSONWriter; name : string; elem : TFhirTestScriptSetup; noObj : boolean = false);
    procedure ComposeTestScriptSetupAction(json : TJSONWriter; name : string; elem : TFhirTestScriptSetupAction; noObj : boolean = false);
    procedure ComposeTestScriptSetupActionOperation(json : TJSONWriter; name : string; elem : TFhirTestScriptSetupActionOperation; noObj : boolean = false);
    procedure ComposeTestScriptSetupActionOperationRequestHeader(json : TJSONWriter; name : string; elem : TFhirTestScriptSetupActionOperationRequestHeader; noObj : boolean = false);
    procedure ComposeTestScriptSetupActionAssert(json : TJSONWriter; name : string; elem : TFhirTestScriptSetupActionAssert; noObj : boolean = false);
    procedure ComposeTestScriptTest(json : TJSONWriter; name : string; elem : TFhirTestScriptTest; noObj : boolean = false);
    procedure ComposeTestScriptTestAction(json : TJSONWriter; name : string; elem : TFhirTestScriptTestAction; noObj : boolean = false);
    procedure ComposeTestScriptTeardown(json : TJSONWriter; name : string; elem : TFhirTestScriptTeardown; noObj : boolean = false);
    procedure ComposeTestScriptTeardownAction(json : TJSONWriter; name : string; elem : TFhirTestScriptTeardownAction; noObj : boolean = false);
    procedure ComposeTestScript(json : TJSONWriter; name : string; elem : TFhirTestScript; noObj : boolean = false);
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
    procedure ComposeValueSetContact(json : TJSONWriter; name : string; elem : TFhirValueSetContact; noObj : boolean = false);
    procedure ComposeValueSetCodeSystem(json : TJSONWriter; name : string; elem : TFhirValueSetCodeSystem; noObj : boolean = false);
    procedure ComposeValueSetCodeSystemConcept(json : TJSONWriter; name : string; elem : TFhirValueSetCodeSystemConcept; noObj : boolean = false);
    procedure ComposeValueSetCodeSystemConceptDesignation(json : TJSONWriter; name : string; elem : TFhirValueSetCodeSystemConceptDesignation; noObj : boolean = false);
    procedure ComposeValueSetCompose(json : TJSONWriter; name : string; elem : TFhirValueSetCompose; noObj : boolean = false);
    procedure ComposeValueSetComposeInclude(json : TJSONWriter; name : string; elem : TFhirValueSetComposeInclude; noObj : boolean = false);
    procedure ComposeValueSetComposeIncludeConcept(json : TJSONWriter; name : string; elem : TFhirValueSetComposeIncludeConcept; noObj : boolean = false);
    procedure ComposeValueSetComposeIncludeFilter(json : TJSONWriter; name : string; elem : TFhirValueSetComposeIncludeFilter; noObj : boolean = false);
    procedure ComposeValueSetExpansion(json : TJSONWriter; name : string; elem : TFhirValueSetExpansion; noObj : boolean = false);
    procedure ComposeValueSetExpansionParameter(json : TJSONWriter; name : string; elem : TFhirValueSetExpansionParameter; noObj : boolean = false);
    procedure ComposeValueSetExpansionContains(json : TJSONWriter; name : string; elem : TFhirValueSetExpansionContains; noObj : boolean = false);
    procedure ComposeValueSet(json : TJSONWriter; name : string; elem : TFhirValueSet; noObj : boolean = false);
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VISIONPRESCRIPTION}
    procedure ComposeVisionPrescriptionDispense(json : TJSONWriter; name : string; elem : TFhirVisionPrescriptionDispense; noObj : boolean = false);
    procedure ComposeVisionPrescription(json : TJSONWriter; name : string; elem : TFhirVisionPrescription; noObj : boolean = false);
{$ENDIF FHIR_VISIONPRESCRIPTION}
    procedure ComposeResource(json : TJSONWriter; resource : TFhirResource); override;
  public
    procedure ComposeBase(json : TJSONWriter; name : String; base : TFHIRObject); override;
  end;


implementation

{ TFHIRJsonParser }

procedure TFHIRJsonParser.ParseElement(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseElement(jsn)); {2}
end;

function TFHIRJsonParser.ParseElement(jsn : TJsonObject) : TFhirElement;
begin
  result := TFhirElement.create;
  try
    ParseElementProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeElement(json : TJSONWriter; name : string; elem : TFhirElement; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIdValue(json, 'id', elem.idElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIdProps(json, 'id', elem.idElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.extensionList.Count > 0) then
  begin
    startArray(json, 'extension', elem.extensionList, false);
    for i := 0 to elem.extensionList.Count - 1 do
      ComposeExtension(json, '', elem.extensionList[i]); {z - Extension}
    finishArray(json, elem.extensionList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseElementProperties(jsn : TJsonObject; element : TFhirElement);
begin
  parseComments(element, jsn);

  if KeepParseLocations then
  begin
    element.LocationData.ParseStart := jsn.LocationStart;
    element.LocationData.ParseFinish := jsn.LocationEnd;
  end;
  if jsn.has('id') then
    element.Id := jsn['id']
  else if jsn.has('_id') then
    element.Id := jsn['_id'];
  if jsn.has('extension') then
    iterateArray(jsn.vArr['extension'], element.extensionList, parseExtension);
end;

procedure TFHIRJsonParser.ParseBackboneElementProperties(jsn : TJsonObject; element : TFhirBackboneElement);
begin
  parseElementProperties(jsn, element);

  if jsn.has('modifierExtension') then
    iterateArray(jsn.vArr['modifierExtension'], element.modifierExtensionList, parseExtension);
end;

Procedure TFHIRJsonComposer.ComposeElementProperties(json : TJSONWriter; elem : TFhirElement);
var
  i : integer;
begin
  {no-comments composeComments(json, elem);}
  Prop(json, 'id', elem.Id);
  if elem.hasExtensionList then
  begin
    startArray(json, 'extension', elem.extensionList, false);
    for i := 0 to elem.extensionList.Count - 1 do
      ComposeExtension(json, '',elem.extensionList[i]);
    finishArray(json, elem.extensionList);
  end;
end;

Procedure TFHIRJsonComposer.ComposeBackboneElementProperties(json : TJSONWriter; elem : TFhirBackboneElement);
var
  i : integer;
begin
  ComposeElementProperties(json, elem);
  if elem.hasModifierExtensionList then
  begin
    startArray(json, 'modifierExtension', elem.modifierExtensionList, false);
    for i := 0 to elem.modifierExtensionList.Count - 1 do
      ComposeExtension(json, '', elem.modifierExtensionList[i]);
    finishArray(json, elem.modifierExtensionList);
  end;
end;

procedure TFHIRJsonParser.ParseBackboneElement(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBackboneElement(jsn)); {2}
end;

function TFHIRJsonParser.ParseBackboneElement(jsn : TJsonObject) : TFhirBackboneElement;
begin
  result := TFhirBackboneElement.create;
  try
    ParseBackboneElementProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonComposer.ComposeBackboneElement(json : TJSONWriter; name : string; elem : TFhirBackboneElement; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeElement(json, '', elem, true);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.modifierExtensionList.Count > 0) then
  begin
    startArray(json, 'modifierExtension', elem.modifierExtensionList, false);
    for i := 0 to elem.modifierExtensionList.Count - 1 do
      ComposeExtension(json, '', elem.modifierExtensionList[i]); {z - Extension}
    finishArray(json, elem.modifierExtensionList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseEnum(path : String; value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList; Const aNames, aSystems : Array Of String);
begin
  ctxt.add(ParseEnum(path, value, jsn, aNames, aSystems));
end;

function TFHIRJsonParser.ParseEnum(path : String; value : TJsonNode; jsn : TJsonObject; Const aNames, aSystems : Array Of String) : TFHIREnum;
var
  i : integer;
begin
  i := StringArrayIndexOfSensitive(aNames, JsonToString(value));
  if (value <> nil) and (i < 0) then
    raise EJsonException.Create('unknown code: '+JsonToString(value)+' from a set of choices of '+StringArrayToCommaString(aNames)+' for "'+path+'"');
  result := TFHIREnum.create;
  try
    if (value <> nil) then
    begin
      if KeepParseLocations then
      begin
        result.LocationData.ParseStart2 := value.LocationStart;
        result.LocationData.ParseFinish2 := value.LocationEnd;
      end;
    end;
    result.value := JsonToString(value);
    result.system := aSystems[i];
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRJsonComposer.ComposeEnumValue(json : TJSONWriter; name : String; value : TFhirEnum; Const aNames : Array Of String; inArray : boolean);
begin
  if (value = nil) or (value.Value = '') then
  begin
    if inArray then
    begin
      if KeepLocationData then value.LocationData.ComposeStart2 := json.SourceLocation;
      propNull(json, name);
      if KeepLocationData then value.LocationData.ComposeFinish2 := json.SourceLocation;
    end;
    exit;
  end
  else
  begin
    if KeepLocationData then value.LocationData.ComposeStart2 := json.SourceLocation;
    prop(json, name, value.value);
    if KeepLocationData then value.LocationData.ComposeFinish2 := json.SourceLocation;
  end;
end;

Procedure TFHIRJsonComposer.ComposeEnumProps(json : TJSONWriter; name : String; value : TFhirEnum; Const aNames : Array Of String; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) {no-comments and (not value.hasComments) }) then
  begin
    if inArray then
    begin
      if KeepLocationData then value.LocationData.ComposeStart := json.SourceLocation;
      propNull(json, name);
      if KeepLocationData then value.LocationData.ComposeFinish := json.SourceLocation;
    end;
    exit;
  end
  else
  begin
    if KeepLocationData then value.LocationData.ComposeStart := json.SourceLocation;
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
    if KeepLocationData then value.LocationData.ComposeFinish := json.SourceLocation;
  end;
end;

procedure TFHIRJsonParser.ParseDateTime(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDateTime(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseDateTime(value : TJsonNode; jsn : TJsonObject) : TFHIRDateTime;
begin
  result := TFhirDateTime.Create;
  try
    if (value <> nil) then
    begin
      if KeepParseLocations then
      begin
        result.LocationData.ParseStart2 := value.LocationStart;
        result.LocationData.ParseFinish2 := value.LocationEnd;
      end;
    end;
     result.value := toTFslDateTime(JsonToString(value));
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRJsonComposer.ComposeDateTimeValue(json : TJSONWriter; name : String; value : TFhirDateTime; inArray : boolean);
begin
  if (value = nil) or (value.value.null) then
  begin
    if inArray then
    begin
      if KeepLocationData then value.LocationData.ComposeStart2 := json.SourceLocation;
      propNull(json, name);
      if KeepLocationData then value.LocationData.ComposeFinish2 := json.SourceLocation;
    end;
    exit;
  end
  else
  begin
    if KeepLocationData then value.LocationData.ComposeStart2 := json.SourceLocation;
    prop(json, name, asString(value.value));
    if KeepLocationData then value.LocationData.ComposeFinish2 := json.SourceLocation;
  end;
end;

Procedure TFHIRJsonComposer.ComposeDateTimeProps(json : TJSONWriter; name : String; value : TFhirDateTime; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) {no-comments and (not value.hasComments)}) then
  begin
    if inArray then
    begin
      if KeepLocationData then value.LocationData.ComposeStart := json.SourceLocation;
      propNull(json, name);
      if KeepLocationData then value.LocationData.ComposeFinish := json.SourceLocation;
    end;
    exit;
  end
  else
  begin
    if KeepLocationData then value.LocationData.ComposeStart := json.SourceLocation;
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
    if KeepLocationData then value.LocationData.ComposeFinish := json.SourceLocation;
  end;
end;

procedure TFHIRJsonParser.ParseDate(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDate(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseDate(value : TJsonNode; jsn : TJsonObject) : TFHIRDate;
begin
  result := TFhirDate.Create;
  try
    if (value <> nil) then
    begin
      if KeepParseLocations then
      begin
        result.LocationData.ParseStart2 := value.LocationStart;
        result.LocationData.ParseFinish2 := value.LocationEnd;
      end;
    end;
     result.value := toTFslDateTime(JsonToString(value));
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRJsonComposer.ComposeDateValue(json : TJSONWriter; name : String; value : TFhirDate; inArray : boolean);
begin
  if (value = nil) or (value.value.null) then
  begin
    if inArray then
    begin
      if KeepLocationData then value.LocationData.ComposeStart2 := json.SourceLocation;
      propNull(json, name);
      if KeepLocationData then value.LocationData.ComposeFinish2 := json.SourceLocation;
    end;
    exit;
  end
  else
  begin
    if KeepLocationData then value.LocationData.ComposeStart2 := json.SourceLocation;
    prop(json, name, asString(value.value));
    if KeepLocationData then value.LocationData.ComposeFinish2 := json.SourceLocation;
  end;
end;

Procedure TFHIRJsonComposer.ComposeDateProps(json : TJSONWriter; name : String; value : TFhirDate; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) {no-comments and (not value.hasComments)}) then
  begin
    if inArray then
    begin
      if KeepLocationData then value.LocationData.ComposeStart := json.SourceLocation;
      propNull(json, name);
      if KeepLocationData then value.LocationData.ComposeFinish := json.SourceLocation;
    end;
    exit;
  end
  else
  begin
    if KeepLocationData then value.LocationData.ComposeStart := json.SourceLocation;
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
    if KeepLocationData then value.LocationData.ComposeFinish := json.SourceLocation;
  end;
end;

procedure TFHIRJsonParser.ParseString(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseString(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseString(value : TJsonNode; jsn : TJsonObject) : TFHIRString;
begin
  result := TFhirString.Create;
  try
    if (value <> nil) then
    begin
      if KeepParseLocations then
      begin
        result.LocationData.ParseStart2 := value.LocationStart;
        result.LocationData.ParseFinish2 := value.LocationEnd;
      end;
    end;
    result.value := JsonToString(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRJsonComposer.ComposeStringValue(json : TJSONWriter; name : String; value : TFhirString; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
    begin
      if KeepLocationData then value.LocationData.ComposeStart2 := json.SourceLocation;
      propNull(json, name);
      if KeepLocationData then value.LocationData.ComposeFinish2 := json.SourceLocation;
    end;
    exit;
  end
  else
  begin
    if KeepLocationData then value.LocationData.ComposeStart2 := json.SourceLocation;
    prop(json, name, value.value);
    if KeepLocationData then value.LocationData.ComposeFinish2 := json.SourceLocation;
  end;
end;

Procedure TFHIRJsonComposer.ComposeStringProps(json : TJSONWriter; name : String; value : TFhirString; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) {no-comments and (not value.hasComments)}) then
  begin
    if inArray then
    begin
      if KeepLocationData then value.LocationData.ComposeStart := json.SourceLocation;
      propNull(json, name);
      if KeepLocationData then value.LocationData.ComposeFinish := json.SourceLocation;
    end;
    exit;
  end
  else
  begin
    if KeepLocationData then value.LocationData.ComposeStart := json.SourceLocation;
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
    if KeepLocationData then value.LocationData.ComposeFinish := json.SourceLocation;
  end;
end;

procedure TFHIRJsonParser.ParseInteger(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseInteger(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseInteger(value : TJsonNode; jsn : TJsonObject) : TFHIRInteger;
begin
  result := TFhirInteger.Create;
  try
    if (value <> nil) then
    begin
      if KeepParseLocations then
      begin
        result.LocationData.ParseStart2 := value.LocationStart;
        result.LocationData.ParseFinish2 := value.LocationEnd;
      end;
    end;
    result.value := JsonToString(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRJsonComposer.ComposeIntegerValue(json : TJSONWriter; name : String; value : TFhirInteger; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
    begin
      if KeepLocationData then value.LocationData.ComposeStart2 := json.SourceLocation;
      propNull(json, name);
      if KeepLocationData then value.LocationData.ComposeFinish2 := json.SourceLocation;
    end;
    exit;
  end
  else
  begin
    if KeepLocationData then value.LocationData.ComposeStart2 := json.SourceLocation;
    propNumber(json, name, value.value);
    if KeepLocationData then value.LocationData.ComposeFinish2 := json.SourceLocation;
  end;
end;

Procedure TFHIRJsonComposer.ComposeIntegerProps(json : TJSONWriter; name : String; value : TFhirInteger; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) {no-comments and (not value.hasComments)}) then
  begin
    if inArray then
    begin
      if KeepLocationData then value.LocationData.ComposeStart := json.SourceLocation;
      propNull(json, name);
      if KeepLocationData then value.LocationData.ComposeFinish := json.SourceLocation;
    end;
    exit;
  end
  else
  begin
    if KeepLocationData then value.LocationData.ComposeStart := json.SourceLocation;
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
    if KeepLocationData then value.LocationData.ComposeFinish := json.SourceLocation;
  end;
end;

procedure TFHIRJsonParser.ParseUri(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseUri(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseUri(value : TJsonNode; jsn : TJsonObject) : TFHIRUri;
begin
  result := TFhirUri.Create;
  try
    if (value <> nil) then
    begin
      if KeepParseLocations then
      begin
        result.LocationData.ParseStart2 := value.LocationStart;
        result.LocationData.ParseFinish2 := value.LocationEnd;
      end;
    end;
    result.value := JsonToString(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRJsonComposer.ComposeUriValue(json : TJSONWriter; name : String; value : TFhirUri; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
    begin
      if KeepLocationData then value.LocationData.ComposeStart2 := json.SourceLocation;
      propNull(json, name);
      if KeepLocationData then value.LocationData.ComposeFinish2 := json.SourceLocation;
    end;
    exit;
  end
  else
  begin
    if KeepLocationData then value.LocationData.ComposeStart2 := json.SourceLocation;
    prop(json, name, value.value);
    if KeepLocationData then value.LocationData.ComposeFinish2 := json.SourceLocation;
  end;
end;

Procedure TFHIRJsonComposer.ComposeUriProps(json : TJSONWriter; name : String; value : TFhirUri; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) {no-comments and (not value.hasComments)}) then
  begin
    if inArray then
    begin
      if KeepLocationData then value.LocationData.ComposeStart := json.SourceLocation;
      propNull(json, name);
      if KeepLocationData then value.LocationData.ComposeFinish := json.SourceLocation;
    end;
    exit;
  end
  else
  begin
    if KeepLocationData then value.LocationData.ComposeStart := json.SourceLocation;
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
    if KeepLocationData then value.LocationData.ComposeFinish := json.SourceLocation;
  end;
end;

procedure TFHIRJsonParser.ParseInstant(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseInstant(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseInstant(value : TJsonNode; jsn : TJsonObject) : TFHIRInstant;
begin
  result := TFhirInstant.Create;
  try
    if (value <> nil) then
    begin
      if KeepParseLocations then
      begin
        result.LocationData.ParseStart2 := value.LocationStart;
        result.LocationData.ParseFinish2 := value.LocationEnd;
      end;
    end;
     result.value := toTFslDateTime(JsonToString(value));
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRJsonComposer.ComposeInstantValue(json : TJSONWriter; name : String; value : TFhirInstant; inArray : boolean);
begin
  if (value = nil) or (value.value.null) then
  begin
    if inArray then
    begin
      if KeepLocationData then value.LocationData.ComposeStart2 := json.SourceLocation;
      propNull(json, name);
      if KeepLocationData then value.LocationData.ComposeFinish2 := json.SourceLocation;
    end;
    exit;
  end
  else
  begin
    if KeepLocationData then value.LocationData.ComposeStart2 := json.SourceLocation;
    prop(json, name, asString(value.value));
    if KeepLocationData then value.LocationData.ComposeFinish2 := json.SourceLocation;
  end;
end;

Procedure TFHIRJsonComposer.ComposeInstantProps(json : TJSONWriter; name : String; value : TFhirInstant; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) {no-comments and (not value.hasComments)}) then
  begin
    if inArray then
    begin
      if KeepLocationData then value.LocationData.ComposeStart := json.SourceLocation;
      propNull(json, name);
      if KeepLocationData then value.LocationData.ComposeFinish := json.SourceLocation;
    end;
    exit;
  end
  else
  begin
    if KeepLocationData then value.LocationData.ComposeStart := json.SourceLocation;
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
    if KeepLocationData then value.LocationData.ComposeFinish := json.SourceLocation;
  end;
end;

procedure TFHIRJsonParser.ParseBoolean(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBoolean(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseBoolean(value : TJsonNode; jsn : TJsonObject) : TFHIRBoolean;
begin
  result := TFhirBoolean.Create;
  try
    if (value <> nil) then
    begin
      if KeepParseLocations then
      begin
        result.LocationData.ParseStart2 := value.LocationStart;
        result.LocationData.ParseFinish2 := value.LocationEnd;
      end;
    end;
    result.value := StringToBoolean(JsonToString(value));
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRJsonComposer.ComposeBooleanValue(json : TJSONWriter; name : String; value : TFhirBoolean; inArray : boolean);
begin
  if (value = nil) then
  begin
    if inArray then
    begin
      if KeepLocationData then value.LocationData.ComposeStart2 := json.SourceLocation;
      propNull(json, name);
      if KeepLocationData then value.LocationData.ComposeFinish2 := json.SourceLocation;
    end;
    exit;
  end
  else
  begin
    if KeepLocationData then value.LocationData.ComposeStart2 := json.SourceLocation;
    prop(json, name, value.value);
    if KeepLocationData then value.LocationData.ComposeFinish2 := json.SourceLocation;
  end;
end;

Procedure TFHIRJsonComposer.ComposeBooleanProps(json : TJSONWriter; name : String; value : TFhirBoolean; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) {no-comments and (not value.hasComments)}) then
  begin
    if inArray then
    begin
      if KeepLocationData then value.LocationData.ComposeStart := json.SourceLocation;
      propNull(json, name);
      if KeepLocationData then value.LocationData.ComposeFinish := json.SourceLocation;
    end;
    exit;
  end
  else
  begin
    if KeepLocationData then value.LocationData.ComposeStart := json.SourceLocation;
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
    if KeepLocationData then value.LocationData.ComposeFinish := json.SourceLocation;
  end;
end;

procedure TFHIRJsonParser.ParseBase64Binary(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBase64Binary(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseBase64Binary(value : TJsonNode; jsn : TJsonObject) : TFHIRBase64Binary;
begin
  result := TFhirBase64Binary.Create;
  try
    if (value <> nil) then
    begin
      if KeepParseLocations then
      begin
        result.LocationData.ParseStart2 := value.LocationStart;
        result.LocationData.ParseFinish2 := value.LocationEnd;
      end;
    end;
     result.value := toTBytes(JsonToString(value));
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRJsonComposer.ComposeBase64BinaryValue(json : TJSONWriter; name : String; value : TFhirBase64Binary; inArray : boolean);
begin
  if (value = nil) or (value.value = nil) then
  begin
    if inArray then
    begin
      if KeepLocationData then value.LocationData.ComposeStart2 := json.SourceLocation;
      propNull(json, name);
      if KeepLocationData then value.LocationData.ComposeFinish2 := json.SourceLocation;
    end;
    exit;
  end
  else
  begin
    if KeepLocationData then value.LocationData.ComposeStart2 := json.SourceLocation;
    prop(json, name, asString(value.value));
    if KeepLocationData then value.LocationData.ComposeFinish2 := json.SourceLocation;
  end;
end;

Procedure TFHIRJsonComposer.ComposeBase64BinaryProps(json : TJSONWriter; name : String; value : TFhirBase64Binary; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) {no-comments and (not value.hasComments)}) then
  begin
    if inArray then
    begin
      if KeepLocationData then value.LocationData.ComposeStart := json.SourceLocation;
      propNull(json, name);
      if KeepLocationData then value.LocationData.ComposeFinish := json.SourceLocation;
    end;
    exit;
  end
  else
  begin
    if KeepLocationData then value.LocationData.ComposeStart := json.SourceLocation;
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
    if KeepLocationData then value.LocationData.ComposeFinish := json.SourceLocation;
  end;
end;

procedure TFHIRJsonParser.ParseTime(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTime(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseTime(value : TJsonNode; jsn : TJsonObject) : TFHIRTime;
begin
  result := TFhirTime.Create;
  try
    if (value <> nil) then
    begin
      if KeepParseLocations then
      begin
        result.LocationData.ParseStart2 := value.LocationStart;
        result.LocationData.ParseFinish2 := value.LocationEnd;
      end;
    end;
    result.value := JsonToString(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRJsonComposer.ComposeTimeValue(json : TJSONWriter; name : String; value : TFhirTime; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
    begin
      if KeepLocationData then value.LocationData.ComposeStart2 := json.SourceLocation;
      propNull(json, name);
      if KeepLocationData then value.LocationData.ComposeFinish2 := json.SourceLocation;
    end;
    exit;
  end
  else
  begin
    if KeepLocationData then value.LocationData.ComposeStart2 := json.SourceLocation;
    prop(json, name, value.value);
    if KeepLocationData then value.LocationData.ComposeFinish2 := json.SourceLocation;
  end;
end;

Procedure TFHIRJsonComposer.ComposeTimeProps(json : TJSONWriter; name : String; value : TFhirTime; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) {no-comments and (not value.hasComments)}) then
  begin
    if inArray then
    begin
      if KeepLocationData then value.LocationData.ComposeStart := json.SourceLocation;
      propNull(json, name);
      if KeepLocationData then value.LocationData.ComposeFinish := json.SourceLocation;
    end;
    exit;
  end
  else
  begin
    if KeepLocationData then value.LocationData.ComposeStart := json.SourceLocation;
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
    if KeepLocationData then value.LocationData.ComposeFinish := json.SourceLocation;
  end;
end;

procedure TFHIRJsonParser.ParseDecimal(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDecimal(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseDecimal(value : TJsonNode; jsn : TJsonObject) : TFHIRDecimal;
begin
  result := TFhirDecimal.Create;
  try
    if (value <> nil) then
    begin
      if KeepParseLocations then
      begin
        result.LocationData.ParseStart2 := value.LocationStart;
        result.LocationData.ParseFinish2 := value.LocationEnd;
      end;
    end;
    result.value := JsonToString(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRJsonComposer.ComposeDecimalValue(json : TJSONWriter; name : String; value : TFhirDecimal; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
    begin
      if KeepLocationData then value.LocationData.ComposeStart2 := json.SourceLocation;
      propNull(json, name);
      if KeepLocationData then value.LocationData.ComposeFinish2 := json.SourceLocation;
    end;
    exit;
  end
  else
  begin
    if KeepLocationData then value.LocationData.ComposeStart2 := json.SourceLocation;
    propNumber(json, name, value.value);
    if KeepLocationData then value.LocationData.ComposeFinish2 := json.SourceLocation;
  end;
end;

Procedure TFHIRJsonComposer.ComposeDecimalProps(json : TJSONWriter; name : String; value : TFhirDecimal; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) {no-comments and (not value.hasComments)}) then
  begin
    if inArray then
    begin
      if KeepLocationData then value.LocationData.ComposeStart := json.SourceLocation;
      propNull(json, name);
      if KeepLocationData then value.LocationData.ComposeFinish := json.SourceLocation;
    end;
    exit;
  end
  else
  begin
    if KeepLocationData then value.LocationData.ComposeStart := json.SourceLocation;
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
    if KeepLocationData then value.LocationData.ComposeFinish := json.SourceLocation;
  end;
end;

procedure TFHIRJsonParser.ParseCode(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCode(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseCode(value : TJsonNode; jsn : TJsonObject) : TFHIRCode;
begin
  result := TFhirCode.Create;
  try
    if (value <> nil) then
    begin
      if KeepParseLocations then
      begin
        result.LocationData.ParseStart2 := value.LocationStart;
        result.LocationData.ParseFinish2 := value.LocationEnd;
      end;
    end;
    result.value := JsonToString(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRJsonComposer.ComposeCodeValue(json : TJSONWriter; name : String; value : TFhirCode; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
    begin
      if KeepLocationData then value.LocationData.ComposeStart2 := json.SourceLocation;
      propNull(json, name);
      if KeepLocationData then value.LocationData.ComposeFinish2 := json.SourceLocation;
    end;
    exit;
  end
  else
  begin
    if KeepLocationData then value.LocationData.ComposeStart2 := json.SourceLocation;
    prop(json, name, value.value);
    if KeepLocationData then value.LocationData.ComposeFinish2 := json.SourceLocation;
  end;
end;

Procedure TFHIRJsonComposer.ComposeCodeProps(json : TJSONWriter; name : String; value : TFhirCode; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) {no-comments and (not value.hasComments)}) then
  begin
    if inArray then
    begin
      if KeepLocationData then value.LocationData.ComposeStart := json.SourceLocation;
      propNull(json, name);
      if KeepLocationData then value.LocationData.ComposeFinish := json.SourceLocation;
    end;
    exit;
  end
  else
  begin
    if KeepLocationData then value.LocationData.ComposeStart := json.SourceLocation;
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
    if KeepLocationData then value.LocationData.ComposeFinish := json.SourceLocation;
  end;
end;

procedure TFHIRJsonParser.ParseOid(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOid(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseOid(value : TJsonNode; jsn : TJsonObject) : TFHIROid;
begin
  result := TFhirOid.Create;
  try
    if (value <> nil) then
    begin
      if KeepParseLocations then
      begin
        result.LocationData.ParseStart2 := value.LocationStart;
        result.LocationData.ParseFinish2 := value.LocationEnd;
      end;
    end;
    result.value := JsonToString(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRJsonComposer.ComposeOidValue(json : TJSONWriter; name : String; value : TFhirOid; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
    begin
      if KeepLocationData then value.LocationData.ComposeStart2 := json.SourceLocation;
      propNull(json, name);
      if KeepLocationData then value.LocationData.ComposeFinish2 := json.SourceLocation;
    end;
    exit;
  end
  else
  begin
    if KeepLocationData then value.LocationData.ComposeStart2 := json.SourceLocation;
    prop(json, name, value.value);
    if KeepLocationData then value.LocationData.ComposeFinish2 := json.SourceLocation;
  end;
end;

Procedure TFHIRJsonComposer.ComposeOidProps(json : TJSONWriter; name : String; value : TFhirOid; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) {no-comments and (not value.hasComments)}) then
  begin
    if inArray then
    begin
      if KeepLocationData then value.LocationData.ComposeStart := json.SourceLocation;
      propNull(json, name);
      if KeepLocationData then value.LocationData.ComposeFinish := json.SourceLocation;
    end;
    exit;
  end
  else
  begin
    if KeepLocationData then value.LocationData.ComposeStart := json.SourceLocation;
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
    if KeepLocationData then value.LocationData.ComposeFinish := json.SourceLocation;
  end;
end;

procedure TFHIRJsonParser.ParseUuid(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseUuid(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseUuid(value : TJsonNode; jsn : TJsonObject) : TFHIRUuid;
begin
  result := TFhirUuid.Create;
  try
    if (value <> nil) then
    begin
      if KeepParseLocations then
      begin
        result.LocationData.ParseStart2 := value.LocationStart;
        result.LocationData.ParseFinish2 := value.LocationEnd;
      end;
    end;
    result.value := JsonToString(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRJsonComposer.ComposeUuidValue(json : TJSONWriter; name : String; value : TFhirUuid; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
    begin
      if KeepLocationData then value.LocationData.ComposeStart2 := json.SourceLocation;
      propNull(json, name);
      if KeepLocationData then value.LocationData.ComposeFinish2 := json.SourceLocation;
    end;
    exit;
  end
  else
  begin
    if KeepLocationData then value.LocationData.ComposeStart2 := json.SourceLocation;
    prop(json, name, value.value);
    if KeepLocationData then value.LocationData.ComposeFinish2 := json.SourceLocation;
  end;
end;

Procedure TFHIRJsonComposer.ComposeUuidProps(json : TJSONWriter; name : String; value : TFhirUuid; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) {no-comments and (not value.hasComments)}) then
  begin
    if inArray then
    begin
      if KeepLocationData then value.LocationData.ComposeStart := json.SourceLocation;
      propNull(json, name);
      if KeepLocationData then value.LocationData.ComposeFinish := json.SourceLocation;
    end;
    exit;
  end
  else
  begin
    if KeepLocationData then value.LocationData.ComposeStart := json.SourceLocation;
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
    if KeepLocationData then value.LocationData.ComposeFinish := json.SourceLocation;
  end;
end;

procedure TFHIRJsonParser.ParseMarkdown(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMarkdown(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseMarkdown(value : TJsonNode; jsn : TJsonObject) : TFHIRMarkdown;
begin
  result := TFhirMarkdown.Create;
  try
    if (value <> nil) then
    begin
      if KeepParseLocations then
      begin
        result.LocationData.ParseStart2 := value.LocationStart;
        result.LocationData.ParseFinish2 := value.LocationEnd;
      end;
    end;
    result.value := JsonToString(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRJsonComposer.ComposeMarkdownValue(json : TJSONWriter; name : String; value : TFhirMarkdown; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
    begin
      if KeepLocationData then value.LocationData.ComposeStart2 := json.SourceLocation;
      propNull(json, name);
      if KeepLocationData then value.LocationData.ComposeFinish2 := json.SourceLocation;
    end;
    exit;
  end
  else
  begin
    if KeepLocationData then value.LocationData.ComposeStart2 := json.SourceLocation;
    prop(json, name, value.value);
    if KeepLocationData then value.LocationData.ComposeFinish2 := json.SourceLocation;
  end;
end;

Procedure TFHIRJsonComposer.ComposeMarkdownProps(json : TJSONWriter; name : String; value : TFhirMarkdown; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) {no-comments and (not value.hasComments)}) then
  begin
    if inArray then
    begin
      if KeepLocationData then value.LocationData.ComposeStart := json.SourceLocation;
      propNull(json, name);
      if KeepLocationData then value.LocationData.ComposeFinish := json.SourceLocation;
    end;
    exit;
  end
  else
  begin
    if KeepLocationData then value.LocationData.ComposeStart := json.SourceLocation;
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
    if KeepLocationData then value.LocationData.ComposeFinish := json.SourceLocation;
  end;
end;

procedure TFHIRJsonParser.ParseUnsignedInt(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseUnsignedInt(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseUnsignedInt(value : TJsonNode; jsn : TJsonObject) : TFHIRUnsignedInt;
begin
  result := TFhirUnsignedInt.Create;
  try
    if (value <> nil) then
    begin
      if KeepParseLocations then
      begin
        result.LocationData.ParseStart2 := value.LocationStart;
        result.LocationData.ParseFinish2 := value.LocationEnd;
      end;
    end;
    result.value := JsonToString(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRJsonComposer.ComposeUnsignedIntValue(json : TJSONWriter; name : String; value : TFhirUnsignedInt; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
    begin
      if KeepLocationData then value.LocationData.ComposeStart2 := json.SourceLocation;
      propNull(json, name);
      if KeepLocationData then value.LocationData.ComposeFinish2 := json.SourceLocation;
    end;
    exit;
  end
  else
  begin
    if KeepLocationData then value.LocationData.ComposeStart2 := json.SourceLocation;
    propNumber(json, name, value.value);
    if KeepLocationData then value.LocationData.ComposeFinish2 := json.SourceLocation;
  end;
end;

Procedure TFHIRJsonComposer.ComposeUnsignedIntProps(json : TJSONWriter; name : String; value : TFhirUnsignedInt; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) {no-comments and (not value.hasComments)}) then
  begin
    if inArray then
    begin
      if KeepLocationData then value.LocationData.ComposeStart := json.SourceLocation;
      propNull(json, name);
      if KeepLocationData then value.LocationData.ComposeFinish := json.SourceLocation;
    end;
    exit;
  end
  else
  begin
    if KeepLocationData then value.LocationData.ComposeStart := json.SourceLocation;
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
    if KeepLocationData then value.LocationData.ComposeFinish := json.SourceLocation;
  end;
end;

procedure TFHIRJsonParser.ParseId(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseId(value, jsn)) {1};
end;

function TFHIRJsonParser.ParseId(value : TJsonNode; jsn : TJsonObject) : TFHIRId;
begin
  result := TFhirId.Create;
  try
    if (value <> nil) then
    begin
      if KeepParseLocations then
      begin
        result.LocationData.ParseStart2 := value.LocationStart;
        result.LocationData.ParseFinish2 := value.LocationEnd;
      end;
    end;
    result.value := JsonToString(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRJsonComposer.ComposeIdValue(json : TJSONWriter; name : String; value : TFhirId; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
    begin
      if KeepLocationData then value.LocationData.ComposeStart2 := json.SourceLocation;
      propNull(json, name);
      if KeepLocationData then value.LocationData.ComposeFinish2 := json.SourceLocation;
    end;
    exit;
  end
  else
  begin
    if KeepLocationData then value.LocationData.ComposeStart2 := json.SourceLocation;
    prop(json, name, value.value);
    if KeepLocationData then value.LocationData.ComposeFinish2 := json.SourceLocation;
  end;
end;

Procedure TFHIRJsonComposer.ComposeIdProps(json : TJSONWriter; name : String; value : TFhirId; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) {no-comments and (not value.hasComments)}) then
  begin
    if inArray then
    begin
      if KeepLocationData then value.LocationData.ComposeStart := json.SourceLocation;
      propNull(json, name);
      if KeepLocationData then value.LocationData.ComposeFinish := json.SourceLocation;
    end;
    exit;
  end
  else
  begin
    if KeepLocationData then value.LocationData.ComposeStart := json.SourceLocation;
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
    if KeepLocationData then value.LocationData.ComposeFinish := json.SourceLocation;
  end;
end;

procedure TFHIRJsonParser.ParsePositiveInt(value : TJsonNode; jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePositiveInt(value, jsn)) {1};
end;

function TFHIRJsonParser.ParsePositiveInt(value : TJsonNode; jsn : TJsonObject) : TFHIRPositiveInt;
begin
  result := TFhirPositiveInt.Create;
  try
    if (value <> nil) then
    begin
      if KeepParseLocations then
      begin
        result.LocationData.ParseStart2 := value.LocationStart;
        result.LocationData.ParseFinish2 := value.LocationEnd;
      end;
    end;
    result.value := JsonToString(value);
    if (jsn <> nil) then
      parseElementProperties(jsn, result);
    result.Link;
  finally
    result.Free;
  end;
end;

Procedure TFHIRJsonComposer.ComposePositiveIntValue(json : TJSONWriter; name : String; value : TFhirPositiveInt; inArray : boolean);
begin
  if (value = nil) or (value.value = '') then
  begin
    if inArray then
    begin
      if KeepLocationData then value.LocationData.ComposeStart2 := json.SourceLocation;
      propNull(json, name);
      if KeepLocationData then value.LocationData.ComposeFinish2 := json.SourceLocation;
    end;
    exit;
  end
  else
  begin
    if KeepLocationData then value.LocationData.ComposeStart2 := json.SourceLocation;
    propNumber(json, name, value.value);
    if KeepLocationData then value.LocationData.ComposeFinish2 := json.SourceLocation;
  end;
end;

Procedure TFHIRJsonComposer.ComposePositiveIntProps(json : TJSONWriter; name : String; value : TFhirPositiveInt; inArray : boolean);
begin
  if (value = nil) or ((value.Id = '') and (not value.hasExtensionList) {no-comments and (not value.hasComments)}) then
  begin
    if inArray then
    begin
      if KeepLocationData then value.LocationData.ComposeStart := json.SourceLocation;
      propNull(json, name);
      if KeepLocationData then value.LocationData.ComposeFinish := json.SourceLocation;
    end;
    exit;
  end
  else
  begin
    if KeepLocationData then value.LocationData.ComposeStart := json.SourceLocation;
    if (inArray) then
      json.valueObject('')
    else
      json.valueObject('_'+name);
    ComposeElementProperties(json, value);
    json.finishObject;
    if KeepLocationData then value.LocationData.ComposeFinish := json.SourceLocation;
  end;
end;

procedure TFHIRJsonParser.ParseResourceProperties(jsn : TJsonObject; resource : TFhirResource);
begin
  if KeepParseLocations then
  begin
    resource.LocationData.ParseStart := jsn.LocationStart;
    resource.LocationData.ParseFinish := jsn.LocationEnd;
  end;
  if jsn.has('id') or jsn.has('_id') then
    resource.idElement := ParseId(jsn.node['id'], jsn.vObj['_id']);{q}
  if jsn.has('meta') then
    resource.meta := ParseMeta(jsn.vObj['meta']);{q3}
  if jsn.has('implicitRules') or jsn.has('_implicitRules') then
    resource.implicitRulesElement := ParseUri(jsn.node['implicitRules'], jsn.vObj['_implicitRules']);{q}
  if jsn.has('language') or jsn.has('_language') then
    resource.languageElement := ParseCode(jsn.node['language'], jsn.vObj['_language']);{q}
end;

Procedure TFHIRJsonComposer.ComposeResourceProperties(json : TJSONWriter; elem : TFhirResource);
begin
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIdValue(json, 'id', elem.idElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIdProps(json, 'id', elem.idElement, false);
  // we always compose meta - special case. if (SummaryOption in [soFull, soSummary, soData]) and doCompose('meta') then
    ComposeMeta(json, 'meta', elem.meta); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('implicitRules') then
    ComposeUriValue(json, 'implicitRules', elem.implicitRulesElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('implicitRules') then
    ComposeUriProps(json, 'implicitRules', elem.implicitRulesElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('language') then
    ComposeCodeValue(json, 'language', elem.languageElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('language') then
    ComposeCodeProps(json, 'language', elem.languageElement, false);
end;

{$IFDEF FHIR_PARAMETERS}
procedure TFHIRJsonParser.ParseParametersParameter(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseParametersParameter(jsn)); {2}
end;

function TFHIRJsonParser.ParseParametersParameter(jsn : TJsonObject) : TFhirParametersParameter;
begin
  result := TFhirParametersParameter.create;
  try
    ParseParametersParameterProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseParametersParameterProperties(jsn : TJsonObject; result : TFhirParametersParameter);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('valueCode') or jsn.has('_valueCode') then
        result.value := ParseCode(jsn.node['valueCode'], jsn.vObj['_valueCode']);
    if jsn.has('valueOid') or jsn.has('_valueOid') then
        result.value := ParseOid(jsn.node['valueOid'], jsn.vObj['_valueOid']);
    if jsn.has('valueUuid') or jsn.has('_valueUuid') then
        result.value := ParseUuid(jsn.node['valueUuid'], jsn.vObj['_valueUuid']);
    if jsn.has('valueMarkdown') or jsn.has('_valueMarkdown') then
        result.value := ParseMarkdown(jsn.node['valueMarkdown'], jsn.vObj['_valueMarkdown']);
    if jsn.has('valueUnsignedInt') or jsn.has('_valueUnsignedInt') then
        result.value := ParseUnsignedInt(jsn.node['valueUnsignedInt'], jsn.vObj['_valueUnsignedInt']);
    if jsn.has('valueId') or jsn.has('_valueId') then
        result.value := ParseId(jsn.node['valueId'], jsn.vObj['_valueId']);
    if jsn.has('valuePositiveInt') or jsn.has('_valuePositiveInt') then
        result.value := ParsePositiveInt(jsn.node['valuePositiveInt'], jsn.vObj['_valuePositiveInt']);
    if jsn.has('valueDateTime') or jsn.has('_valueDateTime') then
        result.value := ParseDateTime(jsn.node['valueDateTime'], jsn.vObj['_valueDateTime']);
    if jsn.has('valueDate') or jsn.has('_valueDate') then
        result.value := ParseDate(jsn.node['valueDate'], jsn.vObj['_valueDate']);
    if jsn.has('valueString') or jsn.has('_valueString') then
        result.value := ParseString(jsn.node['valueString'], jsn.vObj['_valueString']);
    if jsn.has('valueInteger') or jsn.has('_valueInteger') then
        result.value := ParseInteger(jsn.node['valueInteger'], jsn.vObj['_valueInteger']);
    if jsn.has('valueUri') or jsn.has('_valueUri') then
        result.value := ParseUri(jsn.node['valueUri'], jsn.vObj['_valueUri']);
    if jsn.has('valueInstant') or jsn.has('_valueInstant') then
        result.value := ParseInstant(jsn.node['valueInstant'], jsn.vObj['_valueInstant']);
    if jsn.has('valueBoolean') or jsn.has('_valueBoolean') then
        result.value := ParseBoolean(jsn.node['valueBoolean'], jsn.vObj['_valueBoolean']);
    if jsn.has('valueBase64Binary') or jsn.has('_valueBase64Binary') then
        result.value := ParseBase64Binary(jsn.node['valueBase64Binary'], jsn.vObj['_valueBase64Binary']);
    if jsn.has('valueTime') or jsn.has('_valueTime') then
        result.value := ParseTime(jsn.node['valueTime'], jsn.vObj['_valueTime']);
    if jsn.has('valueDecimal') or jsn.has('_valueDecimal') then
        result.value := ParseDecimal(jsn.node['valueDecimal'], jsn.vObj['_valueDecimal']);
    if jsn.has('valueIdentifier') {a7} then
        result.value := ParseIdentifier(jsn.vObj['valueIdentifier']);
    if jsn.has('valueCoding') {a7} then
        result.value := ParseCoding(jsn.vObj['valueCoding']);
    if jsn.has('valueReference') {a7} then
        result.value := ParseReference(jsn.vObj['valueReference']);
    if jsn.has('valueSignature') {a7} then
        result.value := ParseSignature(jsn.vObj['valueSignature']);
    if jsn.has('valueSampledData') {a7} then
        result.value := ParseSampledData(jsn.vObj['valueSampledData']);
    if jsn.has('valuePeriod') {a7} then
        result.value := ParsePeriod(jsn.vObj['valuePeriod']);
    if jsn.has('valueQuantity') {a7} then
        result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueAttachment') {a7} then
        result.value := ParseAttachment(jsn.vObj['valueAttachment']);
    if jsn.has('valueRatio') {a7} then
        result.value := ParseRatio(jsn.vObj['valueRatio']);
    if jsn.has('valueRange') {a7} then
        result.value := ParseRange(jsn.vObj['valueRange']);
    if jsn.has('valueAnnotation') {a7} then
        result.value := ParseAnnotation(jsn.vObj['valueAnnotation']);
    if jsn.has('valueCodeableConcept') {a7} then
        result.value := ParseCodeableConcept(jsn.vObj['valueCodeableConcept']);
    if jsn.has('valueHumanName') {a9} then
        result.value := ParseHumanName(jsn.vObj['valueHumanName']);
    if jsn.has('valueMeta') {a9} then
        result.value := ParseMeta(jsn.vObj['valueMeta']);
    if jsn.has('valueContactPoint') {a9} then
        result.value := ParseContactPoint(jsn.vObj['valueContactPoint']);
    if jsn.has('valueAddress') {a9} then
        result.value := ParseAddress(jsn.vObj['valueAddress']);
    if jsn.has('valueElementDefinition') {a9} then
        result.value := ParseElementDefinition(jsn.vObj['valueElementDefinition']);
    if jsn.has('valueTiming') {a9} then
        result.value := ParseTiming(jsn.vObj['valueTiming']);
    if jsn.has('resource') then
        result.resource := ParseInnerResource(jsn.vObj['resource']);{q3}
    if jsn.has('part') then
      iterateArray(jsn.vArr['part'], result.partList, parseParametersParameter);
end;

procedure TFHIRJsonComposer.ComposeParametersParameter(json : TJSONWriter; name : string; elem : TFhirParametersParameter; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCode) then
  begin
    ComposeCodeValue(json, 'valueCode', TFhirCode(elem.value), false);
    ComposeCodeProps(json, 'valueCode', TFhirCode(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirOid) then
  begin
    ComposeOidValue(json, 'valueOid', TFhirOid(elem.value), false);
    ComposeOidProps(json, 'valueOid', TFhirOid(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUuid) then
  begin
    ComposeUuidValue(json, 'valueUuid', TFhirUuid(elem.value), false);
    ComposeUuidProps(json, 'valueUuid', TFhirUuid(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirMarkdown) then
  begin
    ComposeMarkdownValue(json, 'valueMarkdown', TFhirMarkdown(elem.value), false);
    ComposeMarkdownProps(json, 'valueMarkdown', TFhirMarkdown(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUnsignedInt) then
  begin
    ComposeUnsignedIntValue(json, 'valueUnsignedInt', TFhirUnsignedInt(elem.value), false);
    ComposeUnsignedIntProps(json, 'valueUnsignedInt', TFhirUnsignedInt(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirId) then
  begin
    ComposeIdValue(json, 'valueId', TFhirId(elem.value), false);
    ComposeIdProps(json, 'valueId', TFhirId(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirPositiveInt) then
  begin
    ComposePositiveIntValue(json, 'valuePositiveInt', TFhirPositiveInt(elem.value), false);
    ComposePositiveIntProps(json, 'valuePositiveInt', TFhirPositiveInt(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDateTime) then
  begin
    ComposeDateTimeValue(json, 'valueDateTime', TFhirDateTime(elem.value), false);
    ComposeDateTimeProps(json, 'valueDateTime', TFhirDateTime(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDate) then
  begin
    ComposeDateValue(json, 'valueDate', TFhirDate(elem.value), false);
    ComposeDateProps(json, 'valueDate', TFhirDate(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirString) then
  begin
    ComposeStringValue(json, 'valueString', TFhirString(elem.value), false);
    ComposeStringProps(json, 'valueString', TFhirString(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirInteger) then
  begin
    ComposeIntegerValue(json, 'valueInteger', TFhirInteger(elem.value), false);
    ComposeIntegerProps(json, 'valueInteger', TFhirInteger(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUri) then
  begin
    ComposeUriValue(json, 'valueUri', TFhirUri(elem.value), false);
    ComposeUriProps(json, 'valueUri', TFhirUri(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirInstant) then
  begin
    ComposeInstantValue(json, 'valueInstant', TFhirInstant(elem.value), false);
    ComposeInstantProps(json, 'valueInstant', TFhirInstant(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirBoolean) then
  begin
    ComposeBooleanValue(json, 'valueBoolean', TFhirBoolean(elem.value), false);
    ComposeBooleanProps(json, 'valueBoolean', TFhirBoolean(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirBase64Binary) then
  begin
    ComposeBase64BinaryValue(json, 'valueBase64Binary', TFhirBase64Binary(elem.value), false);
    ComposeBase64BinaryProps(json, 'valueBase64Binary', TFhirBase64Binary(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirTime) then
  begin
    ComposeTimeValue(json, 'valueTime', TFhirTime(elem.value), false);
    ComposeTimeProps(json, 'valueTime', TFhirTime(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDecimal) then
  begin
    ComposeDecimalValue(json, 'valueDecimal', TFhirDecimal(elem.value), false);
    ComposeDecimalProps(json, 'valueDecimal', TFhirDecimal(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirIdentifier) then
    ComposeIdentifier(json, 'valueIdentifier', TFhirIdentifier(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirCoding) then
    ComposeCoding(json, 'valueCoding', TFhirCoding(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirReference) then
    ComposeReference(json, 'valueReference', TFhirReference(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirSignature) then
    ComposeSignature(json, 'valueSignature', TFhirSignature(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirSampledData) then
    ComposeSampledData(json, 'valueSampledData', TFhirSampledData(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirPeriod) then
    ComposePeriod(json, 'valuePeriod', TFhirPeriod(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirQuantity) then
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirAttachment) then
    ComposeAttachment(json, 'valueAttachment', TFhirAttachment(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirRatio) then
    ComposeRatio(json, 'valueRatio', TFhirRatio(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirRange) then
    ComposeRange(json, 'valueRange', TFhirRange(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirAnnotation) then
    ComposeAnnotation(json, 'valueAnnotation', TFhirAnnotation(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirCodeableConcept) then
    ComposeCodeableConcept(json, 'valueCodeableConcept', TFhirCodeableConcept(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirHumanName) then
    ComposeHumanName(json, 'valueHumanName', TFhirHumanName(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirMeta) then
    ComposeMeta(json, 'valueMeta', TFhirMeta(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirContactPoint) then
    ComposeContactPoint(json, 'valueContactPoint', TFhirContactPoint(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirAddress) then
    ComposeAddress(json, 'valueAddress', TFhirAddress(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirElementDefinition) then
    ComposeElementDefinition(json, 'valueElementDefinition', TFhirElementDefinition(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirTiming) then
    ComposeTiming(json, 'valueTiming', TFhirTiming(elem.value));
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInnerResource(json, 'resource', elem, elem.resource); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.partList.Count > 0) then
  begin
    startArray(json, 'part', elem.partList, false);
    for i := 0 to elem.partList.Count - 1 do
      ComposeParametersParameter(json, '', elem.partList[i]); {z - @Parameters.parameter}
    finishArray(json, elem.partList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseParameters(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseParameters(jsn)); {2}
end;

function TFHIRJsonParser.ParseParameters(jsn : TJsonObject) : TFhirParameters;
begin
  result := TFhirParameters.create;
  try
    ParseParametersProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseParametersProperties(jsn : TJsonObject; result : TFhirParameters);
begin
    ParseResourceProperties(jsn, result);
    if jsn.has('parameter') then
      iterateArray(jsn.vArr['parameter'], result.parameterList, parseParametersParameter);
end;

procedure TFHIRJsonComposer.ComposeParameters(json : TJSONWriter; name : string; elem : TFhirParameters; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and doCompose('parameter') and (elem.parameterList.Count > 0) then
  begin
    startArray(json, 'parameter', elem.parameterList, false);
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeParametersParameter(json, '', elem.parameterList[i]); {z - }
    finishArray(json, elem.parameterList);
  end;
end;

{$ENDIF FHIR_PARAMETERS}
procedure TFHIRJsonParser.ParseDomainResourceProperties(jsn : TJsonObject; resource : TFhirDomainResource);
begin
  ParseResourceProperties(jsn, resource);
  if jsn.has('text') then
    resource.text := ParseNarrative(jsn.vObj['text']);{q3}
  if jsn.has('contained') then
    iterateArray(jsn.vArr['contained'], resource.containedList, parseInnerResource);
  if jsn.has('extension') then
    iterateArray(jsn.vArr['extension'], resource.extensionList, parseExtension);
  if jsn.has('modifierExtension') then
    iterateArray(jsn.vArr['modifierExtension'], resource.modifierExtensionList, parseExtension);
end;

Procedure TFHIRJsonComposer.ComposeDomainResourceProperties(json : TJSONWriter; elem : TFhirDomainResource);
var
  i : integer{z.b};
begin
  ComposeResourceProperties(json, elem);
  if (SummaryOption in [soFull, soText]) and doCompose('text') then
    ComposeNarrative(json, 'text', elem.text); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('contained') and (elem.containedList.Count > 0) then
  begin
    startArray(json, 'contained', elem.containedList, false);
    for i := 0 to elem.containedList.Count - 1 do
      ComposeInnerResource(json, '', elem, elem.containedList[i]); {z - Resource}
    finishArray(json, elem.containedList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('extension') and (elem.extensionList.Count > 0) then
  begin
    startArray(json, 'extension', elem.extensionList, false);
    for i := 0 to elem.extensionList.Count - 1 do
      ComposeExtension(json, '', elem.extensionList[i]); {z - Extension}
    finishArray(json, elem.extensionList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('modifierExtension') and (elem.modifierExtensionList.Count > 0) then
  begin
    startArray(json, 'modifierExtension', elem.modifierExtensionList, false);
    for i := 0 to elem.modifierExtensionList.Count - 1 do
      ComposeExtension(json, '', elem.modifierExtensionList[i]); {z - Extension}
    finishArray(json, elem.modifierExtensionList);
  end;
end;

procedure TFHIRJsonParser.ParseExtension(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseExtension(jsn)); {2}
end;

function TFHIRJsonParser.ParseExtension(jsn : TJsonObject) : TFhirExtension;
begin
  result := TFhirExtension.create;
  try
    ParseExtensionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseExtensionProperties(jsn : TJsonObject; result : TFhirExtension);
begin
    parseElementProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('valueCode') or jsn.has('_valueCode') then
        result.value := ParseCode(jsn.node['valueCode'], jsn.vObj['_valueCode']);
    if jsn.has('valueOid') or jsn.has('_valueOid') then
        result.value := ParseOid(jsn.node['valueOid'], jsn.vObj['_valueOid']);
    if jsn.has('valueUuid') or jsn.has('_valueUuid') then
        result.value := ParseUuid(jsn.node['valueUuid'], jsn.vObj['_valueUuid']);
    if jsn.has('valueMarkdown') or jsn.has('_valueMarkdown') then
        result.value := ParseMarkdown(jsn.node['valueMarkdown'], jsn.vObj['_valueMarkdown']);
    if jsn.has('valueUnsignedInt') or jsn.has('_valueUnsignedInt') then
        result.value := ParseUnsignedInt(jsn.node['valueUnsignedInt'], jsn.vObj['_valueUnsignedInt']);
    if jsn.has('valueId') or jsn.has('_valueId') then
        result.value := ParseId(jsn.node['valueId'], jsn.vObj['_valueId']);
    if jsn.has('valuePositiveInt') or jsn.has('_valuePositiveInt') then
        result.value := ParsePositiveInt(jsn.node['valuePositiveInt'], jsn.vObj['_valuePositiveInt']);
    if jsn.has('valueDateTime') or jsn.has('_valueDateTime') then
        result.value := ParseDateTime(jsn.node['valueDateTime'], jsn.vObj['_valueDateTime']);
    if jsn.has('valueDate') or jsn.has('_valueDate') then
        result.value := ParseDate(jsn.node['valueDate'], jsn.vObj['_valueDate']);
    if jsn.has('valueString') or jsn.has('_valueString') then
        result.value := ParseString(jsn.node['valueString'], jsn.vObj['_valueString']);
    if jsn.has('valueInteger') or jsn.has('_valueInteger') then
        result.value := ParseInteger(jsn.node['valueInteger'], jsn.vObj['_valueInteger']);
    if jsn.has('valueUri') or jsn.has('_valueUri') then
        result.value := ParseUri(jsn.node['valueUri'], jsn.vObj['_valueUri']);
    if jsn.has('valueInstant') or jsn.has('_valueInstant') then
        result.value := ParseInstant(jsn.node['valueInstant'], jsn.vObj['_valueInstant']);
    if jsn.has('valueBoolean') or jsn.has('_valueBoolean') then
        result.value := ParseBoolean(jsn.node['valueBoolean'], jsn.vObj['_valueBoolean']);
    if jsn.has('valueBase64Binary') or jsn.has('_valueBase64Binary') then
        result.value := ParseBase64Binary(jsn.node['valueBase64Binary'], jsn.vObj['_valueBase64Binary']);
    if jsn.has('valueTime') or jsn.has('_valueTime') then
        result.value := ParseTime(jsn.node['valueTime'], jsn.vObj['_valueTime']);
    if jsn.has('valueDecimal') or jsn.has('_valueDecimal') then
        result.value := ParseDecimal(jsn.node['valueDecimal'], jsn.vObj['_valueDecimal']);
    if jsn.has('valueIdentifier') {a7} then
        result.value := ParseIdentifier(jsn.vObj['valueIdentifier']);
    if jsn.has('valueCoding') {a7} then
        result.value := ParseCoding(jsn.vObj['valueCoding']);
    if jsn.has('valueReference') {a7} then
        result.value := ParseReference(jsn.vObj['valueReference']);
    if jsn.has('valueSignature') {a7} then
        result.value := ParseSignature(jsn.vObj['valueSignature']);
    if jsn.has('valueSampledData') {a7} then
        result.value := ParseSampledData(jsn.vObj['valueSampledData']);
    if jsn.has('valuePeriod') {a7} then
        result.value := ParsePeriod(jsn.vObj['valuePeriod']);
    if jsn.has('valueQuantity') {a7} then
        result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueAttachment') {a7} then
        result.value := ParseAttachment(jsn.vObj['valueAttachment']);
    if jsn.has('valueRatio') {a7} then
        result.value := ParseRatio(jsn.vObj['valueRatio']);
    if jsn.has('valueRange') {a7} then
        result.value := ParseRange(jsn.vObj['valueRange']);
    if jsn.has('valueAnnotation') {a7} then
        result.value := ParseAnnotation(jsn.vObj['valueAnnotation']);
    if jsn.has('valueCodeableConcept') {a7} then
        result.value := ParseCodeableConcept(jsn.vObj['valueCodeableConcept']);
    if jsn.has('valueHumanName') {a9} then
        result.value := ParseHumanName(jsn.vObj['valueHumanName']);
    if jsn.has('valueMeta') {a9} then
        result.value := ParseMeta(jsn.vObj['valueMeta']);
    if jsn.has('valueContactPoint') {a9} then
        result.value := ParseContactPoint(jsn.vObj['valueContactPoint']);
    if jsn.has('valueAddress') {a9} then
        result.value := ParseAddress(jsn.vObj['valueAddress']);
    if jsn.has('valueElementDefinition') {a9} then
        result.value := ParseElementDefinition(jsn.vObj['valueElementDefinition']);
    if jsn.has('valueTiming') {a9} then
        result.value := ParseTiming(jsn.vObj['valueTiming']);
end;

procedure TFHIRJsonComposer.ComposeExtension(json : TJSONWriter; name : string; elem : TFhirExtension; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  composeElement(json, '', elem, true);
  ComposeUriValue(json, 'url', elem.urlElement, false);
  ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCode) then
  begin
    ComposeCodeValue(json, 'valueCode', TFhirCode(elem.value), false);
    ComposeCodeProps(json, 'valueCode', TFhirCode(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirOid) then
  begin
    ComposeOidValue(json, 'valueOid', TFhirOid(elem.value), false);
    ComposeOidProps(json, 'valueOid', TFhirOid(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUuid) then
  begin
    ComposeUuidValue(json, 'valueUuid', TFhirUuid(elem.value), false);
    ComposeUuidProps(json, 'valueUuid', TFhirUuid(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirMarkdown) then
  begin
    ComposeMarkdownValue(json, 'valueMarkdown', TFhirMarkdown(elem.value), false);
    ComposeMarkdownProps(json, 'valueMarkdown', TFhirMarkdown(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUnsignedInt) then
  begin
    ComposeUnsignedIntValue(json, 'valueUnsignedInt', TFhirUnsignedInt(elem.value), false);
    ComposeUnsignedIntProps(json, 'valueUnsignedInt', TFhirUnsignedInt(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirId) then
  begin
    ComposeIdValue(json, 'valueId', TFhirId(elem.value), false);
    ComposeIdProps(json, 'valueId', TFhirId(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirPositiveInt) then
  begin
    ComposePositiveIntValue(json, 'valuePositiveInt', TFhirPositiveInt(elem.value), false);
    ComposePositiveIntProps(json, 'valuePositiveInt', TFhirPositiveInt(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDateTime) then
  begin
    ComposeDateTimeValue(json, 'valueDateTime', TFhirDateTime(elem.value), false);
    ComposeDateTimeProps(json, 'valueDateTime', TFhirDateTime(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDate) then
  begin
    ComposeDateValue(json, 'valueDate', TFhirDate(elem.value), false);
    ComposeDateProps(json, 'valueDate', TFhirDate(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirString) then
  begin
    ComposeStringValue(json, 'valueString', TFhirString(elem.value), false);
    ComposeStringProps(json, 'valueString', TFhirString(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirInteger) then
  begin
    ComposeIntegerValue(json, 'valueInteger', TFhirInteger(elem.value), false);
    ComposeIntegerProps(json, 'valueInteger', TFhirInteger(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUri) then
  begin
    ComposeUriValue(json, 'valueUri', TFhirUri(elem.value), false);
    ComposeUriProps(json, 'valueUri', TFhirUri(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirInstant) then
  begin
    ComposeInstantValue(json, 'valueInstant', TFhirInstant(elem.value), false);
    ComposeInstantProps(json, 'valueInstant', TFhirInstant(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirBoolean) then
  begin
    ComposeBooleanValue(json, 'valueBoolean', TFhirBoolean(elem.value), false);
    ComposeBooleanProps(json, 'valueBoolean', TFhirBoolean(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirBase64Binary) then
  begin
    ComposeBase64BinaryValue(json, 'valueBase64Binary', TFhirBase64Binary(elem.value), false);
    ComposeBase64BinaryProps(json, 'valueBase64Binary', TFhirBase64Binary(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirTime) then
  begin
    ComposeTimeValue(json, 'valueTime', TFhirTime(elem.value), false);
    ComposeTimeProps(json, 'valueTime', TFhirTime(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDecimal) then
  begin
    ComposeDecimalValue(json, 'valueDecimal', TFhirDecimal(elem.value), false);
    ComposeDecimalProps(json, 'valueDecimal', TFhirDecimal(elem.value), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirIdentifier) then
    ComposeIdentifier(json, 'valueIdentifier', TFhirIdentifier(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirCoding) then
    ComposeCoding(json, 'valueCoding', TFhirCoding(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirReference) then
    ComposeReference(json, 'valueReference', TFhirReference(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirSignature) then
    ComposeSignature(json, 'valueSignature', TFhirSignature(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirSampledData) then
    ComposeSampledData(json, 'valueSampledData', TFhirSampledData(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirPeriod) then
    ComposePeriod(json, 'valuePeriod', TFhirPeriod(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirQuantity) then
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirAttachment) then
    ComposeAttachment(json, 'valueAttachment', TFhirAttachment(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirRatio) then
    ComposeRatio(json, 'valueRatio', TFhirRatio(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirRange) then
    ComposeRange(json, 'valueRange', TFhirRange(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirAnnotation) then
    ComposeAnnotation(json, 'valueAnnotation', TFhirAnnotation(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirCodeableConcept) then
    ComposeCodeableConcept(json, 'valueCodeableConcept', TFhirCodeableConcept(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirHumanName) then
    ComposeHumanName(json, 'valueHumanName', TFhirHumanName(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirMeta) then
    ComposeMeta(json, 'valueMeta', TFhirMeta(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirContactPoint) then
    ComposeContactPoint(json, 'valueContactPoint', TFhirContactPoint(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirAddress) then
    ComposeAddress(json, 'valueAddress', TFhirAddress(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirElementDefinition) then
    ComposeElementDefinition(json, 'valueElementDefinition', TFhirElementDefinition(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirTiming) then
    ComposeTiming(json, 'valueTiming', TFhirTiming(elem.value));
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseNarrative(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNarrative(jsn)); {2}
end;

function TFHIRJsonParser.ParseNarrative(jsn : TJsonObject) : TFhirNarrative;
begin
  result := TFhirNarrative.create;
  try
    ParseNarrativeProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseNarrativeProperties(jsn : TJsonObject; result : TFhirNarrative);
begin
    parseElementProperties(jsn, result);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirNarrativeStatusEnum, SYSTEMS_TFhirNarrativeStatusEnum);
    if jsn.has('div') then
        result.div_ := ParseXHtmlNode(jsn.path+'.div', jsn.node['div']);{q2}
end;

procedure TFHIRJsonComposer.ComposeNarrative(json : TJSONWriter; name : string; elem : TFhirNarrative; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  composeElement(json, '', elem, true);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirNarrativeStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirNarrativeStatusEnum, false);
  ComposeXHtmlNode(json, 'div', elem.div_); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseIdentifier(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseIdentifier(jsn)); {2}
end;

function TFHIRJsonParser.ParseIdentifier(jsn : TJsonObject) : TFhirIdentifier;
begin
  result := TFhirIdentifier.create;
  try
    ParseIdentifierProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseIdentifierProperties(jsn : TJsonObject; result : TFhirIdentifier);
begin
    parseElementProperties(jsn, result);
    if jsn.has('use') or jsn.has('_use')  then
      result.useElement := parseEnum(jsn.path+'/use', jsn.node['use'], jsn.vObj['_use'], CODES_TFhirIdentifierUseEnum, SYSTEMS_TFhirIdentifierUseEnum);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('system') or jsn.has('_system') then
        result.systemElement := ParseUri(jsn.node['system'], jsn.vObj['_system']);{q}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := ParseString(jsn.node['value'], jsn.vObj['_value']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
    if jsn.has('assigner') then
        result.assigner := ParseReference{TFhirOrganization}(jsn.vObj['assigner']);{q3}
end;

procedure TFHIRJsonComposer.ComposeIdentifier(json : TJSONWriter; name : string; elem : TFhirIdentifier; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  composeElement(json, '', elem, true);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnumValue(json, 'use', elem.UseElement, CODES_TFhirIdentifierUseEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnumProps(json, 'use', elem.UseElement, CODES_TFhirIdentifierUseEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriValue(json, 'system', elem.systemElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriProps(json, 'system', elem.systemElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeReference{TFhirOrganization}(json, 'assigner', elem.assigner); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseCoding(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCoding(jsn)); {2}
end;

function TFHIRJsonParser.ParseCoding(jsn : TJsonObject) : TFhirCoding;
begin
  result := TFhirCoding.create;
  try
    ParseCodingProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCodingProperties(jsn : TJsonObject; result : TFhirCoding);
begin
    parseElementProperties(jsn, result);
    if jsn.has('system') or jsn.has('_system') then
        result.systemElement := ParseUri(jsn.node['system'], jsn.vObj['_system']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := ParseCode(jsn.node['code'], jsn.vObj['_code']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.displayElement := ParseString(jsn.node['display'], jsn.vObj['_display']);{q}
    if jsn.has('userSelected') or jsn.has('_userSelected') then
        result.userSelectedElement := ParseBoolean(jsn.node['userSelected'], jsn.vObj['_userSelected']);{q}
end;

procedure TFHIRJsonComposer.ComposeCoding(json : TJSONWriter; name : string; elem : TFhirCoding; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  composeElement(json, '', elem, true);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriValue(json, 'system', elem.systemElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriProps(json, 'system', elem.systemElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeValue(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeProps(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'display', elem.displayElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'display', elem.displayElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBooleanValue(json, 'userSelected', elem.userSelectedElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBooleanProps(json, 'userSelected', elem.userSelectedElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseReference(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseReference(jsn)); {2}
end;

function TFHIRJsonParser.ParseReference(jsn : TJsonObject) : TFhirReference;
begin
  result := TFhirReference.create;
  try
    ParseReferenceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseReferenceProperties(jsn : TJsonObject; result : TFhirReference);
begin
    parseElementProperties(jsn, result);
    if jsn.has('reference') or jsn.has('_reference') then
        result.referenceElement := ParseString(jsn.node['reference'], jsn.vObj['_reference']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.displayElement := ParseString(jsn.node['display'], jsn.vObj['_display']);{q}
end;

procedure TFHIRJsonComposer.ComposeReference(json : TJSONWriter; name : string; elem : TFhirReference; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  composeElement(json, '', elem, true);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'reference', elem.referenceElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'reference', elem.referenceElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'display', elem.displayElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'display', elem.displayElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseSignature(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSignature(jsn)); {2}
end;

function TFHIRJsonParser.ParseSignature(jsn : TJsonObject) : TFhirSignature;
begin
  result := TFhirSignature.create;
  try
    ParseSignatureProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSignatureProperties(jsn : TJsonObject; result : TFhirSignature);
begin
    parseElementProperties(jsn, result);
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCoding);
    if jsn.has('when') or jsn.has('_when') then
        result.whenElement := ParseInstant(jsn.node['when'], jsn.vObj['_when']);{q}
    if jsn.has('whoReference') {a3} then
      result.who := ParseReference(jsn.vObj['whoReference']);
    if jsn.has('whoUri') or jsn.has('_whoUri') then
      result.who := ParseUri(jsn.node['whoUri'], jsn.vObj['_whoUri']);
    if jsn.has('contentType') or jsn.has('_contentType') then
        result.contentTypeElement := ParseCode(jsn.node['contentType'], jsn.vObj['_contentType']);{q}
    if jsn.has('blob') or jsn.has('_blob') then
        result.blobElement := ParseBase64Binary(jsn.node['blob'], jsn.vObj['_blob']);{q}
end;

procedure TFHIRJsonComposer.ComposeSignature(json : TJSONWriter; name : string; elem : TFhirSignature; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  composeElement(json, '', elem, true);
  if (elem.type_List.Count > 0) then
  begin
    startArray(json, 'type', elem.type_List, false);
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCoding(json, '', elem.type_List[i]); {z - Coding}
    finishArray(json, elem.type_List);
  end;
  ComposeInstantValue(json, 'when', elem.whenElement, false);
  ComposeInstantProps(json, 'when', elem.whenElement, false);
  if (elem.who is TFhirReference) then
    ComposeReference(json, 'whoReference', TFhirReference(elem.who))
  else if (elem.who is TFhirUri) then 
  begin
    ComposeUriValue(json, 'whoUri', TFhirUri(elem.who), false);
    ComposeUriProps(json, 'whoUri', TFhirUri(elem.who), false);
  end;
  ComposeCodeValue(json, 'contentType', elem.contentTypeElement, false);
  ComposeCodeProps(json, 'contentType', elem.contentTypeElement, false);
  ComposeBase64BinaryValue(json, 'blob', elem.blobElement, false);
  ComposeBase64BinaryProps(json, 'blob', elem.blobElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseSampledData(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSampledData(jsn)); {2}
end;

function TFHIRJsonParser.ParseSampledData(jsn : TJsonObject) : TFhirSampledData;
begin
  result := TFhirSampledData.create;
  try
    ParseSampledDataProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSampledDataProperties(jsn : TJsonObject; result : TFhirSampledData);
begin
    parseElementProperties(jsn, result);
    if jsn.has('origin') then
        result.origin := ParseQuantity(jsn.vObj['origin']);{q3}
    if jsn.has('period') or jsn.has('_period') then
        result.periodElement := ParseDecimal(jsn.node['period'], jsn.vObj['_period']);{q}
    if jsn.has('factor') or jsn.has('_factor') then
        result.factorElement := ParseDecimal(jsn.node['factor'], jsn.vObj['_factor']);{q}
    if jsn.has('lowerLimit') or jsn.has('_lowerLimit') then
        result.lowerLimitElement := ParseDecimal(jsn.node['lowerLimit'], jsn.vObj['_lowerLimit']);{q}
    if jsn.has('upperLimit') or jsn.has('_upperLimit') then
        result.upperLimitElement := ParseDecimal(jsn.node['upperLimit'], jsn.vObj['_upperLimit']);{q}
    if jsn.has('dimensions') or jsn.has('_dimensions') then
        result.dimensionsElement := ParsePositiveInt(jsn.node['dimensions'], jsn.vObj['_dimensions']);{q}
    if jsn.has('data') or jsn.has('_data') then
        result.dataElement := ParseString(jsn.node['data'], jsn.vObj['_data']);{q}
end;

procedure TFHIRJsonComposer.ComposeSampledData(json : TJSONWriter; name : string; elem : TFhirSampledData; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  composeElement(json, '', elem, true);
  ComposeQuantity(json, 'origin', elem.origin); {a}
  ComposeDecimalValue(json, 'period', elem.periodElement, false);
  ComposeDecimalProps(json, 'period', elem.periodElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (not isCanonical or (elem.factor <> '1')) then
    ComposeDecimalValue(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (not isCanonical or (elem.factor <> '1')) then
    ComposeDecimalProps(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimalValue(json, 'lowerLimit', elem.lowerLimitElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimalProps(json, 'lowerLimit', elem.lowerLimitElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimalValue(json, 'upperLimit', elem.upperLimitElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimalProps(json, 'upperLimit', elem.upperLimitElement, false);
  ComposePositiveIntValue(json, 'dimensions', elem.dimensionsElement, false);
  ComposePositiveIntProps(json, 'dimensions', elem.dimensionsElement, false);
  ComposeStringValue(json, 'data', elem.dataElement, false);
  ComposeStringProps(json, 'data', elem.dataElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParsePeriod(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePeriod(jsn)); {2}
end;

function TFHIRJsonParser.ParsePeriod(jsn : TJsonObject) : TFhirPeriod;
begin
  result := TFhirPeriod.create;
  try
    ParsePeriodProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParsePeriodProperties(jsn : TJsonObject; result : TFhirPeriod);
begin
    parseElementProperties(jsn, result);
    if jsn.has('start') or jsn.has('_start') then
        result.startElement := ParseDateTime(jsn.node['start'], jsn.vObj['_start']);{q}
    if jsn.has('end') or jsn.has('_end') then
        result.end_Element := ParseDateTime(jsn.node['end'], jsn.vObj['_end']);{q}
end;

procedure TFHIRJsonComposer.ComposePeriod(json : TJSONWriter; name : string; elem : TFhirPeriod; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  composeElement(json, '', elem, true);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTimeValue(json, 'start', elem.startElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTimeProps(json, 'start', elem.startElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTimeValue(json, 'end', elem.end_Element, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTimeProps(json, 'end', elem.end_Element, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseQuantity(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuantity(jsn)); {2}
end;

function TFHIRJsonParser.ParseQuantity(jsn : TJsonObject) : TFhirQuantity;
begin
  result := TFhirQuantity.create;
  try
    ParseQuantityProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseQuantityProperties(jsn : TJsonObject; result : TFhirQuantity);
begin
    parseElementProperties(jsn, result);
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := ParseDecimal(jsn.node['value'], jsn.vObj['_value']);{q}
    if jsn.has('comparator') or jsn.has('_comparator')  then
      result.comparatorElement := parseEnum(jsn.path+'/comparator', jsn.node['comparator'], jsn.vObj['_comparator'], CODES_TFhirQuantityComparatorEnum, SYSTEMS_TFhirQuantityComparatorEnum);
    if jsn.has('unit') or jsn.has('_unit') then
        result.unit_Element := ParseString(jsn.node['unit'], jsn.vObj['_unit']);{q}
    if jsn.has('system') or jsn.has('_system') then
        result.systemElement := ParseUri(jsn.node['system'], jsn.vObj['_system']);{q}
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := ParseCode(jsn.node['code'], jsn.vObj['_code']);{q}
end;

procedure TFHIRJsonComposer.ComposeQuantity(json : TJSONWriter; name : string; elem : TFhirQuantity; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  composeElement(json, '', elem, true);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimalValue(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimalProps(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnumValue(json, 'comparator', elem.ComparatorElement, CODES_TFhirQuantityComparatorEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnumProps(json, 'comparator', elem.ComparatorElement, CODES_TFhirQuantityComparatorEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'unit', elem.unit_Element, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'unit', elem.unit_Element, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriValue(json, 'system', elem.systemElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriProps(json, 'system', elem.systemElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeValue(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeProps(json, 'code', elem.codeElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseAttachment(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAttachment(jsn)); {2}
end;

function TFHIRJsonParser.ParseAttachment(jsn : TJsonObject) : TFhirAttachment;
begin
  result := TFhirAttachment.create;
  try
    ParseAttachmentProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseAttachmentProperties(jsn : TJsonObject; result : TFhirAttachment);
begin
    parseElementProperties(jsn, result);
    if jsn.has('contentType') or jsn.has('_contentType') then
        result.contentTypeElement := ParseCode(jsn.node['contentType'], jsn.vObj['_contentType']);{q}
    if jsn.has('language') or jsn.has('_language') then
        result.languageElement := ParseCode(jsn.node['language'], jsn.vObj['_language']);{q}
    if jsn.has('data') or jsn.has('_data') then
        result.dataElement := ParseBase64Binary(jsn.node['data'], jsn.vObj['_data']);{q}
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('size') or jsn.has('_size') then
        result.sizeElement := ParseUnsignedInt(jsn.node['size'], jsn.vObj['_size']);{q}
    if jsn.has('hash') or jsn.has('_hash') then
        result.hashElement := ParseBase64Binary(jsn.node['hash'], jsn.vObj['_hash']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := ParseString(jsn.node['title'], jsn.vObj['_title']);{q}
    if jsn.has('creation') or jsn.has('_creation') then
        result.creationElement := ParseDateTime(jsn.node['creation'], jsn.vObj['_creation']);{q}
end;

procedure TFHIRJsonComposer.ComposeAttachment(json : TJSONWriter; name : string; elem : TFhirAttachment; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  composeElement(json, '', elem, true);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeValue(json, 'contentType', elem.contentTypeElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeProps(json, 'contentType', elem.contentTypeElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeValue(json, 'language', elem.languageElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeProps(json, 'language', elem.languageElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBase64BinaryValue(json, 'data', elem.dataElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBase64BinaryProps(json, 'data', elem.dataElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUnsignedIntValue(json, 'size', elem.sizeElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUnsignedIntProps(json, 'size', elem.sizeElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBase64BinaryValue(json, 'hash', elem.hashElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBase64BinaryProps(json, 'hash', elem.hashElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTimeValue(json, 'creation', elem.creationElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTimeProps(json, 'creation', elem.creationElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseRatio(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseRatio(jsn)); {2}
end;

function TFHIRJsonParser.ParseRatio(jsn : TJsonObject) : TFhirRatio;
begin
  result := TFhirRatio.create;
  try
    ParseRatioProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseRatioProperties(jsn : TJsonObject; result : TFhirRatio);
begin
    parseElementProperties(jsn, result);
    if jsn.has('numerator') then
        result.numerator := ParseQuantity(jsn.vObj['numerator']);{q3}
    if jsn.has('denominator') then
        result.denominator := ParseQuantity(jsn.vObj['denominator']);{q3}
end;

procedure TFHIRJsonComposer.ComposeRatio(json : TJSONWriter; name : string; elem : TFhirRatio; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  composeElement(json, '', elem, true);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(json, 'numerator', elem.numerator); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(json, 'denominator', elem.denominator); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseRange(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseRange(jsn)); {2}
end;

function TFHIRJsonParser.ParseRange(jsn : TJsonObject) : TFhirRange;
begin
  result := TFhirRange.create;
  try
    ParseRangeProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseRangeProperties(jsn : TJsonObject; result : TFhirRange);
begin
    parseElementProperties(jsn, result);
    if jsn.has('low') then
        result.low := ParseQuantity(jsn.vObj['low']);{q3}
    if jsn.has('high') then
        result.high := ParseQuantity(jsn.vObj['high']);{q3}
end;

procedure TFHIRJsonComposer.ComposeRange(json : TJSONWriter; name : string; elem : TFhirRange; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  composeElement(json, '', elem, true);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(json, 'low', elem.low); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(json, 'high', elem.high); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseAnnotation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAnnotation(jsn)); {2}
end;

function TFHIRJsonParser.ParseAnnotation(jsn : TJsonObject) : TFhirAnnotation;
begin
  result := TFhirAnnotation.create;
  try
    ParseAnnotationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseAnnotationProperties(jsn : TJsonObject; result : TFhirAnnotation);
begin
    parseElementProperties(jsn, result);
    if jsn.has('authorReference') {a3} then
      result.author := ParseReference(jsn.vObj['authorReference']);
    if jsn.has('authorString') or jsn.has('_authorString') then
      result.author := ParseString(jsn.node['authorString'], jsn.vObj['_authorString']);
    if jsn.has('time') or jsn.has('_time') then
        result.timeElement := ParseDateTime(jsn.node['time'], jsn.vObj['_time']);{q}
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn.node['text'], jsn.vObj['_text']);{q}
end;

procedure TFHIRJsonComposer.ComposeAnnotation(json : TJSONWriter; name : string; elem : TFhirAnnotation; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  composeElement(json, '', elem, true);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.author is TFhirReference) then
    ComposeReference(json, 'authorReference', TFhirReference(elem.author))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.author is TFhirString) then 
  begin
    ComposeStringValue(json, 'authorString', TFhirString(elem.author), false);
    ComposeStringProps(json, 'authorString', TFhirString(elem.author), false);
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTimeValue(json, 'time', elem.timeElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTimeProps(json, 'time', elem.timeElement, false);
  ComposeStringValue(json, 'text', elem.textElement, false);
  ComposeStringProps(json, 'text', elem.textElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseCodeableConcept(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCodeableConcept(jsn)); {2}
end;

function TFHIRJsonParser.ParseCodeableConcept(jsn : TJsonObject) : TFhirCodeableConcept;
begin
  result := TFhirCodeableConcept.create;
  try
    ParseCodeableConceptProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCodeableConceptProperties(jsn : TJsonObject; result : TFhirCodeableConcept);
begin
    parseElementProperties(jsn, result);
    if jsn.has('coding') then
      iterateArray(jsn.vArr['coding'], result.codingList, parseCoding);
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn.node['text'], jsn.vObj['_text']);{q}
end;

procedure TFHIRJsonComposer.ComposeCodeableConcept(json : TJSONWriter; name : string; elem : TFhirCodeableConcept; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  composeElement(json, '', elem, true);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.codingList.Count > 0) then
  begin
    startArray(json, 'coding', elem.codingList, false);
    for i := 0 to elem.codingList.Count - 1 do
      ComposeCoding(json, '', elem.codingList[i]); {z - Coding}
    finishArray(json, elem.codingList);
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseHumanName(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseHumanName(jsn)); {2}
end;

function TFHIRJsonParser.ParseHumanName(jsn : TJsonObject) : TFhirHumanName;
begin
  result := TFhirHumanName.create;
  try
    ParseHumanNameProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseHumanNameProperties(jsn : TJsonObject; result : TFhirHumanName);
begin
    parseElementProperties(jsn, result);
    if jsn.has('use') or jsn.has('_use')  then
      result.useElement := parseEnum(jsn.path+'/use', jsn.node['use'], jsn.vObj['_use'], CODES_TFhirNameUseEnum, SYSTEMS_TFhirNameUseEnum);
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn.node['text'], jsn.vObj['_text']);{q}
      if jsn.has('family') or jsn.has('_family') then
      iteratePrimitiveArray(jsn.vArr['family'], jsn.vArr['_family'], result.familyList, parseString);
      if jsn.has('given') or jsn.has('_given') then
      iteratePrimitiveArray(jsn.vArr['given'], jsn.vArr['_given'], result.givenList, parseString);
      if jsn.has('prefix') or jsn.has('_prefix') then
      iteratePrimitiveArray(jsn.vArr['prefix'], jsn.vArr['_prefix'], result.prefixList, parseString);
      if jsn.has('suffix') or jsn.has('_suffix') then
      iteratePrimitiveArray(jsn.vArr['suffix'], jsn.vArr['_suffix'], result.suffixList, parseString);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
end;

procedure TFHIRJsonComposer.ComposeHumanName(json : TJSONWriter; name : string; elem : TFhirHumanName; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  composeElement(json, '', elem, true);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnumValue(json, 'use', elem.UseElement, CODES_TFhirNameUseEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnumProps(json, 'use', elem.UseElement, CODES_TFhirNameUseEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.familyList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.familyList.Count - 1 do
    begin
      ext := ext or ((elem.familyList[i].id <> '') or (elem.familyList[i].hasExtensionList) {no-comments or (elem.familyList[i].hasComments)});
      val := val or (elem.familyList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      startArray(json, 'family', elem.familyList, true);
      for i := 0 to elem.familyList.Count - 1 do
        ComposeStringValue(json, '',elem.familyList[i], true);
      finishArray(json, elem.familyList);
    end;
    if ext then
    begin
      startArray(json, '_family', elem.familyList, false);
      for i := 0 to elem.familyList.Count - 1 do
        ComposeStringProps(json, '',elem.familyList[i], true);
      finishArray(json, elem.familyList);
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.givenList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.givenList.Count - 1 do
    begin
      ext := ext or ((elem.givenList[i].id <> '') or (elem.givenList[i].hasExtensionList) {no-comments or (elem.givenList[i].hasComments)});
      val := val or (elem.givenList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      startArray(json, 'given', elem.givenList, true);
      for i := 0 to elem.givenList.Count - 1 do
        ComposeStringValue(json, '',elem.givenList[i], true);
      finishArray(json, elem.givenList);
    end;
    if ext then
    begin
      startArray(json, '_given', elem.givenList, false);
      for i := 0 to elem.givenList.Count - 1 do
        ComposeStringProps(json, '',elem.givenList[i], true);
      finishArray(json, elem.givenList);
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.prefixList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.prefixList.Count - 1 do
    begin
      ext := ext or ((elem.prefixList[i].id <> '') or (elem.prefixList[i].hasExtensionList) {no-comments or (elem.prefixList[i].hasComments)});
      val := val or (elem.prefixList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      startArray(json, 'prefix', elem.prefixList, true);
      for i := 0 to elem.prefixList.Count - 1 do
        ComposeStringValue(json, '',elem.prefixList[i], true);
      finishArray(json, elem.prefixList);
    end;
    if ext then
    begin
      startArray(json, '_prefix', elem.prefixList, false);
      for i := 0 to elem.prefixList.Count - 1 do
        ComposeStringProps(json, '',elem.prefixList[i], true);
      finishArray(json, elem.prefixList);
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.suffixList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.suffixList.Count - 1 do
    begin
      ext := ext or ((elem.suffixList[i].id <> '') or (elem.suffixList[i].hasExtensionList) {no-comments or (elem.suffixList[i].hasComments)});
      val := val or (elem.suffixList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      startArray(json, 'suffix', elem.suffixList, true);
      for i := 0 to elem.suffixList.Count - 1 do
        ComposeStringValue(json, '',elem.suffixList[i], true);
      finishArray(json, elem.suffixList);
    end;
    if ext then
    begin
      startArray(json, '_suffix', elem.suffixList, false);
      for i := 0 to elem.suffixList.Count - 1 do
        ComposeStringProps(json, '',elem.suffixList[i], true);
      finishArray(json, elem.suffixList);
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseMeta(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMeta(jsn)); {2}
end;

function TFHIRJsonParser.ParseMeta(jsn : TJsonObject) : TFhirMeta;
begin
  result := TFhirMeta.create;
  try
    ParseMetaProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMetaProperties(jsn : TJsonObject; result : TFhirMeta);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('versionId') or jsn.has('_versionId') then
        result.versionIdElement := ParseId(jsn.node['versionId'], jsn.vObj['_versionId']);{q}
    if jsn.has('lastUpdated') or jsn.has('_lastUpdated') then
        result.lastUpdatedElement := ParseInstant(jsn.node['lastUpdated'], jsn.vObj['_lastUpdated']);{q}
      if jsn.has('profile') or jsn.has('_profile') then
      iteratePrimitiveArray(jsn.vArr['profile'], jsn.vArr['_profile'], result.profileList, parseUri);
    if jsn.has('security') then
      iterateArray(jsn.vArr['security'], result.securityList, parseCoding);
    if jsn.has('tag') then
      iterateArray(jsn.vArr['tag'], result.tagList, parseCoding);
end;

procedure TFHIRJsonComposer.ComposeMeta(json : TJSONWriter; name : string; elem : TFhirMeta; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeElement(json, '', elem, true);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIdValue(json, 'versionId', elem.versionIdElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIdProps(json, 'versionId', elem.versionIdElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstantValue(json, 'lastUpdated', elem.lastUpdatedElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstantProps(json, 'lastUpdated', elem.lastUpdatedElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.profileList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.profileList.Count - 1 do
    begin
      ext := ext or ((elem.profileList[i].id <> '') or (elem.profileList[i].hasExtensionList) {no-comments or (elem.profileList[i].hasComments)});
      val := val or (elem.profileList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      startArray(json, 'profile', elem.profileList, true);
      for i := 0 to elem.profileList.Count - 1 do
        ComposeUriValue(json, '',elem.profileList[i], true);
      finishArray(json, elem.profileList);
    end;
    if ext then
    begin
      startArray(json, '_profile', elem.profileList, false);
      for i := 0 to elem.profileList.Count - 1 do
        ComposeUriProps(json, '',elem.profileList[i], true);
      finishArray(json, elem.profileList);
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.securityList.Count > 0) then
  begin
    startArray(json, 'security', elem.securityList, false);
    for i := 0 to elem.securityList.Count - 1 do
      ComposeCoding(json, '', elem.securityList[i]); {z - Coding}
    finishArray(json, elem.securityList);
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.tagList.Count > 0) or (hasSubsettedTag(elem.tagList)) then
  begin
    startArray(json, 'tag', elem.tagList, false);
    for i := 0 to elem.tagList.Count - 1 do
      if (SummaryOption in [soFull, soSummary, soText, soData]) or (isSubsettedTag(elem.tagList[i])) then
        ComposeCoding(json, '', elem.tagList[i]); {z - Coding}
    finishArray(json, elem.tagList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseContactPoint(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContactPoint(jsn)); {2}
end;

function TFHIRJsonParser.ParseContactPoint(jsn : TJsonObject) : TFhirContactPoint;
begin
  result := TFhirContactPoint.create;
  try
    ParseContactPointProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseContactPointProperties(jsn : TJsonObject; result : TFhirContactPoint);
begin
    parseElementProperties(jsn, result);
    if jsn.has('system') or jsn.has('_system')  then
      result.systemElement := parseEnum(jsn.path+'/system', jsn.node['system'], jsn.vObj['_system'], CODES_TFhirContactPointSystemEnum, SYSTEMS_TFhirContactPointSystemEnum);
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := ParseString(jsn.node['value'], jsn.vObj['_value']);{q}
    if jsn.has('use') or jsn.has('_use')  then
      result.useElement := parseEnum(jsn.path+'/use', jsn.node['use'], jsn.vObj['_use'], CODES_TFhirContactPointUseEnum, SYSTEMS_TFhirContactPointUseEnum);
    if jsn.has('rank') or jsn.has('_rank') then
        result.rankElement := ParsePositiveInt(jsn.node['rank'], jsn.vObj['_rank']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
end;

procedure TFHIRJsonComposer.ComposeContactPoint(json : TJSONWriter; name : string; elem : TFhirContactPoint; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  composeElement(json, '', elem, true);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnumValue(json, 'system', elem.SystemElement, CODES_TFhirContactPointSystemEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnumProps(json, 'system', elem.SystemElement, CODES_TFhirContactPointSystemEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnumValue(json, 'use', elem.UseElement, CODES_TFhirContactPointUseEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnumProps(json, 'use', elem.UseElement, CODES_TFhirContactPointUseEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePositiveIntValue(json, 'rank', elem.rankElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePositiveIntProps(json, 'rank', elem.rankElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseAddress(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAddress(jsn)); {2}
end;

function TFHIRJsonParser.ParseAddress(jsn : TJsonObject) : TFhirAddress;
begin
  result := TFhirAddress.create;
  try
    ParseAddressProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseAddressProperties(jsn : TJsonObject; result : TFhirAddress);
begin
    parseElementProperties(jsn, result);
    if jsn.has('use') or jsn.has('_use')  then
      result.useElement := parseEnum(jsn.path+'/use', jsn.node['use'], jsn.vObj['_use'], CODES_TFhirAddressUseEnum, SYSTEMS_TFhirAddressUseEnum);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirAddressTypeEnum, SYSTEMS_TFhirAddressTypeEnum);
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn.node['text'], jsn.vObj['_text']);{q}
      if jsn.has('line') or jsn.has('_line') then
      iteratePrimitiveArray(jsn.vArr['line'], jsn.vArr['_line'], result.lineList, parseString);
    if jsn.has('city') or jsn.has('_city') then
        result.cityElement := ParseString(jsn.node['city'], jsn.vObj['_city']);{q}
    if jsn.has('district') or jsn.has('_district') then
        result.districtElement := ParseString(jsn.node['district'], jsn.vObj['_district']);{q}
    if jsn.has('state') or jsn.has('_state') then
        result.stateElement := ParseString(jsn.node['state'], jsn.vObj['_state']);{q}
    if jsn.has('postalCode') or jsn.has('_postalCode') then
        result.postalCodeElement := ParseString(jsn.node['postalCode'], jsn.vObj['_postalCode']);{q}
    if jsn.has('country') or jsn.has('_country') then
        result.countryElement := ParseString(jsn.node['country'], jsn.vObj['_country']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
end;

procedure TFHIRJsonComposer.ComposeAddress(json : TJSONWriter; name : string; elem : TFhirAddress; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  composeElement(json, '', elem, true);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnumValue(json, 'use', elem.UseElement, CODES_TFhirAddressUseEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnumProps(json, 'use', elem.UseElement, CODES_TFhirAddressUseEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirAddressTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirAddressTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.lineList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.lineList.Count - 1 do
    begin
      ext := ext or ((elem.lineList[i].id <> '') or (elem.lineList[i].hasExtensionList) {no-comments or (elem.lineList[i].hasComments)});
      val := val or (elem.lineList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      startArray(json, 'line', elem.lineList, true);
      for i := 0 to elem.lineList.Count - 1 do
        ComposeStringValue(json, '',elem.lineList[i], true);
      finishArray(json, elem.lineList);
    end;
    if ext then
    begin
      startArray(json, '_line', elem.lineList, false);
      for i := 0 to elem.lineList.Count - 1 do
        ComposeStringProps(json, '',elem.lineList[i], true);
      finishArray(json, elem.lineList);
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'city', elem.cityElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'city', elem.cityElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'district', elem.districtElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'district', elem.districtElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'state', elem.stateElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'state', elem.stateElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'postalCode', elem.postalCodeElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'postalCode', elem.postalCodeElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'country', elem.countryElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'country', elem.countryElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseElementDefinitionSlicing(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseElementDefinitionSlicing(jsn)); {2}
end;

function TFHIRJsonParser.ParseElementDefinitionSlicing(jsn : TJsonObject) : TFhirElementDefinitionSlicing;
begin
  result := TFhirElementDefinitionSlicing.create;
  try
    ParseElementDefinitionSlicingProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseElementDefinitionSlicingProperties(jsn : TJsonObject; result : TFhirElementDefinitionSlicing);
begin
    ParseElementProperties(jsn, result);
      if jsn.has('discriminator') or jsn.has('_discriminator') then
      iteratePrimitiveArray(jsn.vArr['discriminator'], jsn.vArr['_discriminator'], result.discriminatorList, parseString);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('ordered') or jsn.has('_ordered') then
        result.orderedElement := ParseBoolean(jsn.node['ordered'], jsn.vObj['_ordered']);{q}
    if jsn.has('rules') or jsn.has('_rules')  then
      result.rulesElement := parseEnum(jsn.path+'/rules', jsn.node['rules'], jsn.vObj['_rules'], CODES_TFhirResourceSlicingRulesEnum, SYSTEMS_TFhirResourceSlicingRulesEnum);
end;

procedure TFHIRJsonComposer.ComposeElementDefinitionSlicing(json : TJSONWriter; name : string; elem : TFhirElementDefinitionSlicing; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.discriminatorList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.discriminatorList.Count - 1 do
    begin
      ext := ext or ((elem.discriminatorList[i].id <> '') or (elem.discriminatorList[i].hasExtensionList) {no-comments or (elem.discriminatorList[i].hasComments)});
      val := val or (elem.discriminatorList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      startArray(json, 'discriminator', elem.discriminatorList, true);
      for i := 0 to elem.discriminatorList.Count - 1 do
        ComposeStringValue(json, '',elem.discriminatorList[i], true);
      finishArray(json, elem.discriminatorList);
    end;
    if ext then
    begin
      startArray(json, '_discriminator', elem.discriminatorList, false);
      for i := 0 to elem.discriminatorList.Count - 1 do
        ComposeStringProps(json, '',elem.discriminatorList[i], true);
      finishArray(json, elem.discriminatorList);
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.ordered <> false)) then
    ComposeBooleanValue(json, 'ordered', elem.orderedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.ordered <> false)) then
    ComposeBooleanProps(json, 'ordered', elem.orderedElement, false);
  ComposeEnumValue(json, 'rules', elem.RulesElement, CODES_TFhirResourceSlicingRulesEnum, false);
  ComposeEnumProps(json, 'rules', elem.RulesElement, CODES_TFhirResourceSlicingRulesEnum, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseElementDefinitionBase(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseElementDefinitionBase(jsn)); {2}
end;

function TFHIRJsonParser.ParseElementDefinitionBase(jsn : TJsonObject) : TFhirElementDefinitionBase;
begin
  result := TFhirElementDefinitionBase.create;
  try
    ParseElementDefinitionBaseProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseElementDefinitionBaseProperties(jsn : TJsonObject; result : TFhirElementDefinitionBase);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('path') or jsn.has('_path') then
        result.pathElement := ParseString(jsn.node['path'], jsn.vObj['_path']);{q}
    if jsn.has('min') or jsn.has('_min') then
        result.minElement := ParseInteger(jsn.node['min'], jsn.vObj['_min']);{q}
    if jsn.has('max') or jsn.has('_max') then
        result.maxElement := ParseString(jsn.node['max'], jsn.vObj['_max']);{q}
end;

procedure TFHIRJsonComposer.ComposeElementDefinitionBase(json : TJSONWriter; name : string; elem : TFhirElementDefinitionBase; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeElementProperties(json, elem);
  ComposeStringValue(json, 'path', elem.pathElement, false);
  ComposeStringProps(json, 'path', elem.pathElement, false);
  ComposeIntegerValue(json, 'min', elem.minElement, false);
  ComposeIntegerProps(json, 'min', elem.minElement, false);
  ComposeStringValue(json, 'max', elem.maxElement, false);
  ComposeStringProps(json, 'max', elem.maxElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseElementDefinitionType(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseElementDefinitionType(jsn)); {2}
end;

function TFHIRJsonParser.ParseElementDefinitionType(jsn : TJsonObject) : TFhirElementDefinitionType;
begin
  result := TFhirElementDefinitionType.create;
  try
    ParseElementDefinitionTypeProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseElementDefinitionTypeProperties(jsn : TJsonObject; result : TFhirElementDefinitionType);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := ParseCode(jsn.node['code'], jsn.vObj['_code']);{q}
      if jsn.has('profile') or jsn.has('_profile') then
      iteratePrimitiveArray(jsn.vArr['profile'], jsn.vArr['_profile'], result.profileList, parseUri);
    if jsn.has('aggregation') or jsn.has('_aggregation') then
      iterateEnumArray(jsn.vArr['aggregation'], jsn.vArr['_aggregation'], jsn.path+'/aggregation', result.aggregationList, parseEnum, CODES_TFhirResourceAggregationModeEnum, SYSTEMS_TFhirResourceAggregationModeEnum);
end;

procedure TFHIRJsonComposer.ComposeElementDefinitionType(json : TJSONWriter; name : string; elem : TFhirElementDefinitionType; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeElementProperties(json, elem);
  ComposeCodeValue(json, 'code', elem.codeElement, false);
  ComposeCodeProps(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.profileList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.profileList.Count - 1 do
    begin
      ext := ext or ((elem.profileList[i].id <> '') or (elem.profileList[i].hasExtensionList) {no-comments or (elem.profileList[i].hasComments)});
      val := val or (elem.profileList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      startArray(json, 'profile', elem.profileList, true);
      for i := 0 to elem.profileList.Count - 1 do
        ComposeUriValue(json, '',elem.profileList[i], true);
      finishArray(json, elem.profileList);
    end;
    if ext then
    begin
      startArray(json, '_profile', elem.profileList, false);
      for i := 0 to elem.profileList.Count - 1 do
        ComposeUriProps(json, '',elem.profileList[i], true);
      finishArray(json, elem.profileList);
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.aggregationList.Count > 0) then
  begin
    val := false;
    ext := false;
    for i := 0 to elem.aggregationList.Count - 1 do
    begin
      val := val or (elem.aggregationList[i].hasPrimitiveValue);
      ext := ext or ((elem.aggregationList[i].id <> '') or (elem.aggregationList[i].hasExtensionList));
    end;
    if val then
    begin
      startArray(json, 'aggregation', elem.aggregationList, true);
      for i := 0 to elem.aggregationList.Count - 1 do
        ComposeEnumValue(json, '', elem.aggregationList[i], CODES_TFhirResourceAggregationModeEnum, true);
      finishArray(json, elem.aggregationList);
    end;
    if ext then
    begin
      startArray(json, '_aggregation', elem.aggregationList, false);
      for i := 0 to elem.aggregationList.Count - 1 do
        ComposeEnumProps(json, '', elem.aggregationList[i], CODES_TFhirResourceAggregationModeEnum, true);
      finishArray(json, elem.aggregationList);
    end;
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseElementDefinitionConstraint(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseElementDefinitionConstraint(jsn)); {2}
end;

function TFHIRJsonParser.ParseElementDefinitionConstraint(jsn : TJsonObject) : TFhirElementDefinitionConstraint;
begin
  result := TFhirElementDefinitionConstraint.create;
  try
    ParseElementDefinitionConstraintProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseElementDefinitionConstraintProperties(jsn : TJsonObject; result : TFhirElementDefinitionConstraint);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('key') or jsn.has('_key') then
        result.keyElement := ParseId(jsn.node['key'], jsn.vObj['_key']);{q}
    if jsn.has('requirements') or jsn.has('_requirements') then
        result.requirementsElement := ParseString(jsn.node['requirements'], jsn.vObj['_requirements']);{q}
    if jsn.has('severity') or jsn.has('_severity')  then
      result.severityElement := parseEnum(jsn.path+'/severity', jsn.node['severity'], jsn.vObj['_severity'], CODES_TFhirConstraintSeverityEnum, SYSTEMS_TFhirConstraintSeverityEnum);
    if jsn.has('human') or jsn.has('_human') then
        result.humanElement := ParseString(jsn.node['human'], jsn.vObj['_human']);{q}
    if jsn.has('xpath') or jsn.has('_xpath') then
        result.xpathElement := ParseString(jsn.node['xpath'], jsn.vObj['_xpath']);{q}
end;

procedure TFHIRJsonComposer.ComposeElementDefinitionConstraint(json : TJSONWriter; name : string; elem : TFhirElementDefinitionConstraint; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeElementProperties(json, elem);
  ComposeIdValue(json, 'key', elem.keyElement, false);
  ComposeIdProps(json, 'key', elem.keyElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'requirements', elem.requirementsElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'requirements', elem.requirementsElement, false);
  ComposeEnumValue(json, 'severity', elem.SeverityElement, CODES_TFhirConstraintSeverityEnum, false);
  ComposeEnumProps(json, 'severity', elem.SeverityElement, CODES_TFhirConstraintSeverityEnum, false);
  ComposeStringValue(json, 'human', elem.humanElement, false);
  ComposeStringProps(json, 'human', elem.humanElement, false);
  ComposeStringValue(json, 'xpath', elem.xpathElement, false);
  ComposeStringProps(json, 'xpath', elem.xpathElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseElementDefinitionBinding(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseElementDefinitionBinding(jsn)); {2}
end;

function TFHIRJsonParser.ParseElementDefinitionBinding(jsn : TJsonObject) : TFhirElementDefinitionBinding;
begin
  result := TFhirElementDefinitionBinding.create;
  try
    ParseElementDefinitionBindingProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseElementDefinitionBindingProperties(jsn : TJsonObject; result : TFhirElementDefinitionBinding);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('strength') or jsn.has('_strength')  then
      result.strengthElement := parseEnum(jsn.path+'/strength', jsn.node['strength'], jsn.vObj['_strength'], CODES_TFhirBindingStrengthEnum, SYSTEMS_TFhirBindingStrengthEnum);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('valueSetReference') {a3} then
      result.valueSet := ParseReference(jsn.vObj['valueSetReference']);
    if jsn.has('valueSetUri') or jsn.has('_valueSetUri') then
      result.valueSet := ParseUri(jsn.node['valueSetUri'], jsn.vObj['_valueSetUri']);
end;

procedure TFHIRJsonComposer.ComposeElementDefinitionBinding(json : TJSONWriter; name : string; elem : TFhirElementDefinitionBinding; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeElementProperties(json, elem);
  ComposeEnumValue(json, 'strength', elem.StrengthElement, CODES_TFhirBindingStrengthEnum, false);
  ComposeEnumProps(json, 'strength', elem.StrengthElement, CODES_TFhirBindingStrengthEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.valueSet is TFhirReference) then
    ComposeReference(json, 'valueSetReference', TFhirReference(elem.valueSet))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.valueSet is TFhirUri) then 
  begin
    ComposeUriValue(json, 'valueSetUri', TFhirUri(elem.valueSet), false);
    ComposeUriProps(json, 'valueSetUri', TFhirUri(elem.valueSet), false);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseElementDefinitionMapping(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseElementDefinitionMapping(jsn)); {2}
end;

function TFHIRJsonParser.ParseElementDefinitionMapping(jsn : TJsonObject) : TFhirElementDefinitionMapping;
begin
  result := TFhirElementDefinitionMapping.create;
  try
    ParseElementDefinitionMappingProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseElementDefinitionMappingProperties(jsn : TJsonObject; result : TFhirElementDefinitionMapping);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('identity') or jsn.has('_identity') then
        result.identityElement := ParseId(jsn.node['identity'], jsn.vObj['_identity']);{q}
    if jsn.has('language') or jsn.has('_language') then
        result.languageElement := ParseCode(jsn.node['language'], jsn.vObj['_language']);{q}
    if jsn.has('map') or jsn.has('_map') then
        result.mapElement := ParseString(jsn.node['map'], jsn.vObj['_map']);{q}
end;

procedure TFHIRJsonComposer.ComposeElementDefinitionMapping(json : TJSONWriter; name : string; elem : TFhirElementDefinitionMapping; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeElementProperties(json, elem);
  ComposeIdValue(json, 'identity', elem.identityElement, false);
  ComposeIdProps(json, 'identity', elem.identityElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeValue(json, 'language', elem.languageElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeProps(json, 'language', elem.languageElement, false);
  ComposeStringValue(json, 'map', elem.mapElement, false);
  ComposeStringProps(json, 'map', elem.mapElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseElementDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseElementDefinition(jsn)); {2}
end;

function TFHIRJsonParser.ParseElementDefinition(jsn : TJsonObject) : TFhirElementDefinition;
begin
  result := TFhirElementDefinition.create;
  try
    ParseElementDefinitionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseElementDefinitionProperties(jsn : TJsonObject; result : TFhirElementDefinition);
begin
    parseElementProperties(jsn, result);
    if jsn.has('path') or jsn.has('_path') then
        result.pathElement := ParseString(jsn.node['path'], jsn.vObj['_path']);{q}
    if jsn.has('representation') or jsn.has('_representation') then
      iterateEnumArray(jsn.vArr['representation'], jsn.vArr['_representation'], jsn.path+'/representation', result.representationList, parseEnum, CODES_TFhirPropertyRepresentationEnum, SYSTEMS_TFhirPropertyRepresentationEnum);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('label') or jsn.has('_label') then
        result.label_Element := ParseString(jsn.node['label'], jsn.vObj['_label']);{q}
    if jsn.has('code') then
      iterateArray(jsn.vArr['code'], result.codeList, parseCoding);
    if jsn.has('slicing') then
        result.slicing := ParseElementDefinitionSlicing(jsn.vObj['slicing']);{q3}
    if jsn.has('short') or jsn.has('_short') then
        result.shortElement := ParseString(jsn.node['short'], jsn.vObj['_short']);{q}
    if jsn.has('definition') or jsn.has('_definition') then
        result.definitionElement := ParseMarkdown(jsn.node['definition'], jsn.vObj['_definition']);{q}
    if jsn.has('comments') or jsn.has('_comments') then
        result.commentsElement := ParseMarkdown(jsn.node['comments'], jsn.vObj['_comments']);{q}
    if jsn.has('requirements') or jsn.has('_requirements') then
        result.requirementsElement := ParseMarkdown(jsn.node['requirements'], jsn.vObj['_requirements']);{q}
      if jsn.has('alias') or jsn.has('_alias') then
      iteratePrimitiveArray(jsn.vArr['alias'], jsn.vArr['_alias'], result.aliasList, parseString);
    if jsn.has('min') or jsn.has('_min') then
        result.minElement := ParseInteger(jsn.node['min'], jsn.vObj['_min']);{q}
    if jsn.has('max') or jsn.has('_max') then
        result.maxElement := ParseString(jsn.node['max'], jsn.vObj['_max']);{q}
    if jsn.has('base') then
        result.base := ParseElementDefinitionBase(jsn.vObj['base']);{q3}
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseElementDefinitionType);
    if jsn.has('nameReference') or jsn.has('_nameReference') then
        result.nameReferenceElement := ParseString(jsn.node['nameReference'], jsn.vObj['_nameReference']);{q}
    if jsn.has('defaultValueCode') or jsn.has('_defaultValueCode') then
        result.defaultValue := ParseCode(jsn.node['defaultValueCode'], jsn.vObj['_defaultValueCode']);
    if jsn.has('defaultValueOid') or jsn.has('_defaultValueOid') then
        result.defaultValue := ParseOid(jsn.node['defaultValueOid'], jsn.vObj['_defaultValueOid']);
    if jsn.has('defaultValueUuid') or jsn.has('_defaultValueUuid') then
        result.defaultValue := ParseUuid(jsn.node['defaultValueUuid'], jsn.vObj['_defaultValueUuid']);
    if jsn.has('defaultValueMarkdown') or jsn.has('_defaultValueMarkdown') then
        result.defaultValue := ParseMarkdown(jsn.node['defaultValueMarkdown'], jsn.vObj['_defaultValueMarkdown']);
    if jsn.has('defaultValueUnsignedInt') or jsn.has('_defaultValueUnsignedInt') then
        result.defaultValue := ParseUnsignedInt(jsn.node['defaultValueUnsignedInt'], jsn.vObj['_defaultValueUnsignedInt']);
    if jsn.has('defaultValueId') or jsn.has('_defaultValueId') then
        result.defaultValue := ParseId(jsn.node['defaultValueId'], jsn.vObj['_defaultValueId']);
    if jsn.has('defaultValuePositiveInt') or jsn.has('_defaultValuePositiveInt') then
        result.defaultValue := ParsePositiveInt(jsn.node['defaultValuePositiveInt'], jsn.vObj['_defaultValuePositiveInt']);
    if jsn.has('defaultValueDateTime') or jsn.has('_defaultValueDateTime') then
        result.defaultValue := ParseDateTime(jsn.node['defaultValueDateTime'], jsn.vObj['_defaultValueDateTime']);
    if jsn.has('defaultValueDate') or jsn.has('_defaultValueDate') then
        result.defaultValue := ParseDate(jsn.node['defaultValueDate'], jsn.vObj['_defaultValueDate']);
    if jsn.has('defaultValueString') or jsn.has('_defaultValueString') then
        result.defaultValue := ParseString(jsn.node['defaultValueString'], jsn.vObj['_defaultValueString']);
    if jsn.has('defaultValueInteger') or jsn.has('_defaultValueInteger') then
        result.defaultValue := ParseInteger(jsn.node['defaultValueInteger'], jsn.vObj['_defaultValueInteger']);
    if jsn.has('defaultValueUri') or jsn.has('_defaultValueUri') then
        result.defaultValue := ParseUri(jsn.node['defaultValueUri'], jsn.vObj['_defaultValueUri']);
    if jsn.has('defaultValueInstant') or jsn.has('_defaultValueInstant') then
        result.defaultValue := ParseInstant(jsn.node['defaultValueInstant'], jsn.vObj['_defaultValueInstant']);
    if jsn.has('defaultValueBoolean') or jsn.has('_defaultValueBoolean') then
        result.defaultValue := ParseBoolean(jsn.node['defaultValueBoolean'], jsn.vObj['_defaultValueBoolean']);
    if jsn.has('defaultValueBase64Binary') or jsn.has('_defaultValueBase64Binary') then
        result.defaultValue := ParseBase64Binary(jsn.node['defaultValueBase64Binary'], jsn.vObj['_defaultValueBase64Binary']);
    if jsn.has('defaultValueTime') or jsn.has('_defaultValueTime') then
        result.defaultValue := ParseTime(jsn.node['defaultValueTime'], jsn.vObj['_defaultValueTime']);
    if jsn.has('defaultValueDecimal') or jsn.has('_defaultValueDecimal') then
        result.defaultValue := ParseDecimal(jsn.node['defaultValueDecimal'], jsn.vObj['_defaultValueDecimal']);
    if jsn.has('defaultValueIdentifier') {a7} then
        result.defaultValue := ParseIdentifier(jsn.vObj['defaultValueIdentifier']);
    if jsn.has('defaultValueCoding') {a7} then
        result.defaultValue := ParseCoding(jsn.vObj['defaultValueCoding']);
    if jsn.has('defaultValueReference') {a7} then
        result.defaultValue := ParseReference(jsn.vObj['defaultValueReference']);
    if jsn.has('defaultValueSignature') {a7} then
        result.defaultValue := ParseSignature(jsn.vObj['defaultValueSignature']);
    if jsn.has('defaultValueSampledData') {a7} then
        result.defaultValue := ParseSampledData(jsn.vObj['defaultValueSampledData']);
    if jsn.has('defaultValuePeriod') {a7} then
        result.defaultValue := ParsePeriod(jsn.vObj['defaultValuePeriod']);
    if jsn.has('defaultValueQuantity') {a7} then
        result.defaultValue := ParseQuantity(jsn.vObj['defaultValueQuantity']);
    if jsn.has('defaultValueAttachment') {a7} then
        result.defaultValue := ParseAttachment(jsn.vObj['defaultValueAttachment']);
    if jsn.has('defaultValueRatio') {a7} then
        result.defaultValue := ParseRatio(jsn.vObj['defaultValueRatio']);
    if jsn.has('defaultValueRange') {a7} then
        result.defaultValue := ParseRange(jsn.vObj['defaultValueRange']);
    if jsn.has('defaultValueAnnotation') {a7} then
        result.defaultValue := ParseAnnotation(jsn.vObj['defaultValueAnnotation']);
    if jsn.has('defaultValueCodeableConcept') {a7} then
        result.defaultValue := ParseCodeableConcept(jsn.vObj['defaultValueCodeableConcept']);
    if jsn.has('defaultValueHumanName') {a9} then
        result.defaultValue := ParseHumanName(jsn.vObj['defaultValueHumanName']);
    if jsn.has('defaultValueMeta') {a9} then
        result.defaultValue := ParseMeta(jsn.vObj['defaultValueMeta']);
    if jsn.has('defaultValueContactPoint') {a9} then
        result.defaultValue := ParseContactPoint(jsn.vObj['defaultValueContactPoint']);
    if jsn.has('defaultValueAddress') {a9} then
        result.defaultValue := ParseAddress(jsn.vObj['defaultValueAddress']);
    if jsn.has('defaultValueElementDefinition') {a9} then
        result.defaultValue := ParseElementDefinition(jsn.vObj['defaultValueElementDefinition']);
    if jsn.has('defaultValueTiming') {a9} then
        result.defaultValue := ParseTiming(jsn.vObj['defaultValueTiming']);
    if jsn.has('meaningWhenMissing') or jsn.has('_meaningWhenMissing') then
        result.meaningWhenMissingElement := ParseMarkdown(jsn.node['meaningWhenMissing'], jsn.vObj['_meaningWhenMissing']);{q}
    if jsn.has('fixedCode') or jsn.has('_fixedCode') then
        result.fixed := ParseCode(jsn.node['fixedCode'], jsn.vObj['_fixedCode']);
    if jsn.has('fixedOid') or jsn.has('_fixedOid') then
        result.fixed := ParseOid(jsn.node['fixedOid'], jsn.vObj['_fixedOid']);
    if jsn.has('fixedUuid') or jsn.has('_fixedUuid') then
        result.fixed := ParseUuid(jsn.node['fixedUuid'], jsn.vObj['_fixedUuid']);
    if jsn.has('fixedMarkdown') or jsn.has('_fixedMarkdown') then
        result.fixed := ParseMarkdown(jsn.node['fixedMarkdown'], jsn.vObj['_fixedMarkdown']);
    if jsn.has('fixedUnsignedInt') or jsn.has('_fixedUnsignedInt') then
        result.fixed := ParseUnsignedInt(jsn.node['fixedUnsignedInt'], jsn.vObj['_fixedUnsignedInt']);
    if jsn.has('fixedId') or jsn.has('_fixedId') then
        result.fixed := ParseId(jsn.node['fixedId'], jsn.vObj['_fixedId']);
    if jsn.has('fixedPositiveInt') or jsn.has('_fixedPositiveInt') then
        result.fixed := ParsePositiveInt(jsn.node['fixedPositiveInt'], jsn.vObj['_fixedPositiveInt']);
    if jsn.has('fixedDateTime') or jsn.has('_fixedDateTime') then
        result.fixed := ParseDateTime(jsn.node['fixedDateTime'], jsn.vObj['_fixedDateTime']);
    if jsn.has('fixedDate') or jsn.has('_fixedDate') then
        result.fixed := ParseDate(jsn.node['fixedDate'], jsn.vObj['_fixedDate']);
    if jsn.has('fixedString') or jsn.has('_fixedString') then
        result.fixed := ParseString(jsn.node['fixedString'], jsn.vObj['_fixedString']);
    if jsn.has('fixedInteger') or jsn.has('_fixedInteger') then
        result.fixed := ParseInteger(jsn.node['fixedInteger'], jsn.vObj['_fixedInteger']);
    if jsn.has('fixedUri') or jsn.has('_fixedUri') then
        result.fixed := ParseUri(jsn.node['fixedUri'], jsn.vObj['_fixedUri']);
    if jsn.has('fixedInstant') or jsn.has('_fixedInstant') then
        result.fixed := ParseInstant(jsn.node['fixedInstant'], jsn.vObj['_fixedInstant']);
    if jsn.has('fixedBoolean') or jsn.has('_fixedBoolean') then
        result.fixed := ParseBoolean(jsn.node['fixedBoolean'], jsn.vObj['_fixedBoolean']);
    if jsn.has('fixedBase64Binary') or jsn.has('_fixedBase64Binary') then
        result.fixed := ParseBase64Binary(jsn.node['fixedBase64Binary'], jsn.vObj['_fixedBase64Binary']);
    if jsn.has('fixedTime') or jsn.has('_fixedTime') then
        result.fixed := ParseTime(jsn.node['fixedTime'], jsn.vObj['_fixedTime']);
    if jsn.has('fixedDecimal') or jsn.has('_fixedDecimal') then
        result.fixed := ParseDecimal(jsn.node['fixedDecimal'], jsn.vObj['_fixedDecimal']);
    if jsn.has('fixedIdentifier') {a7} then
        result.fixed := ParseIdentifier(jsn.vObj['fixedIdentifier']);
    if jsn.has('fixedCoding') {a7} then
        result.fixed := ParseCoding(jsn.vObj['fixedCoding']);
    if jsn.has('fixedReference') {a7} then
        result.fixed := ParseReference(jsn.vObj['fixedReference']);
    if jsn.has('fixedSignature') {a7} then
        result.fixed := ParseSignature(jsn.vObj['fixedSignature']);
    if jsn.has('fixedSampledData') {a7} then
        result.fixed := ParseSampledData(jsn.vObj['fixedSampledData']);
    if jsn.has('fixedPeriod') {a7} then
        result.fixed := ParsePeriod(jsn.vObj['fixedPeriod']);
    if jsn.has('fixedQuantity') {a7} then
        result.fixed := ParseQuantity(jsn.vObj['fixedQuantity']);
    if jsn.has('fixedAttachment') {a7} then
        result.fixed := ParseAttachment(jsn.vObj['fixedAttachment']);
    if jsn.has('fixedRatio') {a7} then
        result.fixed := ParseRatio(jsn.vObj['fixedRatio']);
    if jsn.has('fixedRange') {a7} then
        result.fixed := ParseRange(jsn.vObj['fixedRange']);
    if jsn.has('fixedAnnotation') {a7} then
        result.fixed := ParseAnnotation(jsn.vObj['fixedAnnotation']);
    if jsn.has('fixedCodeableConcept') {a7} then
        result.fixed := ParseCodeableConcept(jsn.vObj['fixedCodeableConcept']);
    if jsn.has('fixedHumanName') {a9} then
        result.fixed := ParseHumanName(jsn.vObj['fixedHumanName']);
    if jsn.has('fixedMeta') {a9} then
        result.fixed := ParseMeta(jsn.vObj['fixedMeta']);
    if jsn.has('fixedContactPoint') {a9} then
        result.fixed := ParseContactPoint(jsn.vObj['fixedContactPoint']);
    if jsn.has('fixedAddress') {a9} then
        result.fixed := ParseAddress(jsn.vObj['fixedAddress']);
    if jsn.has('fixedElementDefinition') {a9} then
        result.fixed := ParseElementDefinition(jsn.vObj['fixedElementDefinition']);
    if jsn.has('fixedTiming') {a9} then
        result.fixed := ParseTiming(jsn.vObj['fixedTiming']);
    if jsn.has('patternCode') or jsn.has('_patternCode') then
        result.pattern := ParseCode(jsn.node['patternCode'], jsn.vObj['_patternCode']);
    if jsn.has('patternOid') or jsn.has('_patternOid') then
        result.pattern := ParseOid(jsn.node['patternOid'], jsn.vObj['_patternOid']);
    if jsn.has('patternUuid') or jsn.has('_patternUuid') then
        result.pattern := ParseUuid(jsn.node['patternUuid'], jsn.vObj['_patternUuid']);
    if jsn.has('patternMarkdown') or jsn.has('_patternMarkdown') then
        result.pattern := ParseMarkdown(jsn.node['patternMarkdown'], jsn.vObj['_patternMarkdown']);
    if jsn.has('patternUnsignedInt') or jsn.has('_patternUnsignedInt') then
        result.pattern := ParseUnsignedInt(jsn.node['patternUnsignedInt'], jsn.vObj['_patternUnsignedInt']);
    if jsn.has('patternId') or jsn.has('_patternId') then
        result.pattern := ParseId(jsn.node['patternId'], jsn.vObj['_patternId']);
    if jsn.has('patternPositiveInt') or jsn.has('_patternPositiveInt') then
        result.pattern := ParsePositiveInt(jsn.node['patternPositiveInt'], jsn.vObj['_patternPositiveInt']);
    if jsn.has('patternDateTime') or jsn.has('_patternDateTime') then
        result.pattern := ParseDateTime(jsn.node['patternDateTime'], jsn.vObj['_patternDateTime']);
    if jsn.has('patternDate') or jsn.has('_patternDate') then
        result.pattern := ParseDate(jsn.node['patternDate'], jsn.vObj['_patternDate']);
    if jsn.has('patternString') or jsn.has('_patternString') then
        result.pattern := ParseString(jsn.node['patternString'], jsn.vObj['_patternString']);
    if jsn.has('patternInteger') or jsn.has('_patternInteger') then
        result.pattern := ParseInteger(jsn.node['patternInteger'], jsn.vObj['_patternInteger']);
    if jsn.has('patternUri') or jsn.has('_patternUri') then
        result.pattern := ParseUri(jsn.node['patternUri'], jsn.vObj['_patternUri']);
    if jsn.has('patternInstant') or jsn.has('_patternInstant') then
        result.pattern := ParseInstant(jsn.node['patternInstant'], jsn.vObj['_patternInstant']);
    if jsn.has('patternBoolean') or jsn.has('_patternBoolean') then
        result.pattern := ParseBoolean(jsn.node['patternBoolean'], jsn.vObj['_patternBoolean']);
    if jsn.has('patternBase64Binary') or jsn.has('_patternBase64Binary') then
        result.pattern := ParseBase64Binary(jsn.node['patternBase64Binary'], jsn.vObj['_patternBase64Binary']);
    if jsn.has('patternTime') or jsn.has('_patternTime') then
        result.pattern := ParseTime(jsn.node['patternTime'], jsn.vObj['_patternTime']);
    if jsn.has('patternDecimal') or jsn.has('_patternDecimal') then
        result.pattern := ParseDecimal(jsn.node['patternDecimal'], jsn.vObj['_patternDecimal']);
    if jsn.has('patternIdentifier') {a7} then
        result.pattern := ParseIdentifier(jsn.vObj['patternIdentifier']);
    if jsn.has('patternCoding') {a7} then
        result.pattern := ParseCoding(jsn.vObj['patternCoding']);
    if jsn.has('patternReference') {a7} then
        result.pattern := ParseReference(jsn.vObj['patternReference']);
    if jsn.has('patternSignature') {a7} then
        result.pattern := ParseSignature(jsn.vObj['patternSignature']);
    if jsn.has('patternSampledData') {a7} then
        result.pattern := ParseSampledData(jsn.vObj['patternSampledData']);
    if jsn.has('patternPeriod') {a7} then
        result.pattern := ParsePeriod(jsn.vObj['patternPeriod']);
    if jsn.has('patternQuantity') {a7} then
        result.pattern := ParseQuantity(jsn.vObj['patternQuantity']);
    if jsn.has('patternAttachment') {a7} then
        result.pattern := ParseAttachment(jsn.vObj['patternAttachment']);
    if jsn.has('patternRatio') {a7} then
        result.pattern := ParseRatio(jsn.vObj['patternRatio']);
    if jsn.has('patternRange') {a7} then
        result.pattern := ParseRange(jsn.vObj['patternRange']);
    if jsn.has('patternAnnotation') {a7} then
        result.pattern := ParseAnnotation(jsn.vObj['patternAnnotation']);
    if jsn.has('patternCodeableConcept') {a7} then
        result.pattern := ParseCodeableConcept(jsn.vObj['patternCodeableConcept']);
    if jsn.has('patternHumanName') {a9} then
        result.pattern := ParseHumanName(jsn.vObj['patternHumanName']);
    if jsn.has('patternMeta') {a9} then
        result.pattern := ParseMeta(jsn.vObj['patternMeta']);
    if jsn.has('patternContactPoint') {a9} then
        result.pattern := ParseContactPoint(jsn.vObj['patternContactPoint']);
    if jsn.has('patternAddress') {a9} then
        result.pattern := ParseAddress(jsn.vObj['patternAddress']);
    if jsn.has('patternElementDefinition') {a9} then
        result.pattern := ParseElementDefinition(jsn.vObj['patternElementDefinition']);
    if jsn.has('patternTiming') {a9} then
        result.pattern := ParseTiming(jsn.vObj['patternTiming']);
    if jsn.has('exampleCode') or jsn.has('_exampleCode') then
        result.example := ParseCode(jsn.node['exampleCode'], jsn.vObj['_exampleCode']);
    if jsn.has('exampleOid') or jsn.has('_exampleOid') then
        result.example := ParseOid(jsn.node['exampleOid'], jsn.vObj['_exampleOid']);
    if jsn.has('exampleUuid') or jsn.has('_exampleUuid') then
        result.example := ParseUuid(jsn.node['exampleUuid'], jsn.vObj['_exampleUuid']);
    if jsn.has('exampleMarkdown') or jsn.has('_exampleMarkdown') then
        result.example := ParseMarkdown(jsn.node['exampleMarkdown'], jsn.vObj['_exampleMarkdown']);
    if jsn.has('exampleUnsignedInt') or jsn.has('_exampleUnsignedInt') then
        result.example := ParseUnsignedInt(jsn.node['exampleUnsignedInt'], jsn.vObj['_exampleUnsignedInt']);
    if jsn.has('exampleId') or jsn.has('_exampleId') then
        result.example := ParseId(jsn.node['exampleId'], jsn.vObj['_exampleId']);
    if jsn.has('examplePositiveInt') or jsn.has('_examplePositiveInt') then
        result.example := ParsePositiveInt(jsn.node['examplePositiveInt'], jsn.vObj['_examplePositiveInt']);
    if jsn.has('exampleDateTime') or jsn.has('_exampleDateTime') then
        result.example := ParseDateTime(jsn.node['exampleDateTime'], jsn.vObj['_exampleDateTime']);
    if jsn.has('exampleDate') or jsn.has('_exampleDate') then
        result.example := ParseDate(jsn.node['exampleDate'], jsn.vObj['_exampleDate']);
    if jsn.has('exampleString') or jsn.has('_exampleString') then
        result.example := ParseString(jsn.node['exampleString'], jsn.vObj['_exampleString']);
    if jsn.has('exampleInteger') or jsn.has('_exampleInteger') then
        result.example := ParseInteger(jsn.node['exampleInteger'], jsn.vObj['_exampleInteger']);
    if jsn.has('exampleUri') or jsn.has('_exampleUri') then
        result.example := ParseUri(jsn.node['exampleUri'], jsn.vObj['_exampleUri']);
    if jsn.has('exampleInstant') or jsn.has('_exampleInstant') then
        result.example := ParseInstant(jsn.node['exampleInstant'], jsn.vObj['_exampleInstant']);
    if jsn.has('exampleBoolean') or jsn.has('_exampleBoolean') then
        result.example := ParseBoolean(jsn.node['exampleBoolean'], jsn.vObj['_exampleBoolean']);
    if jsn.has('exampleBase64Binary') or jsn.has('_exampleBase64Binary') then
        result.example := ParseBase64Binary(jsn.node['exampleBase64Binary'], jsn.vObj['_exampleBase64Binary']);
    if jsn.has('exampleTime') or jsn.has('_exampleTime') then
        result.example := ParseTime(jsn.node['exampleTime'], jsn.vObj['_exampleTime']);
    if jsn.has('exampleDecimal') or jsn.has('_exampleDecimal') then
        result.example := ParseDecimal(jsn.node['exampleDecimal'], jsn.vObj['_exampleDecimal']);
    if jsn.has('exampleIdentifier') {a7} then
        result.example := ParseIdentifier(jsn.vObj['exampleIdentifier']);
    if jsn.has('exampleCoding') {a7} then
        result.example := ParseCoding(jsn.vObj['exampleCoding']);
    if jsn.has('exampleReference') {a7} then
        result.example := ParseReference(jsn.vObj['exampleReference']);
    if jsn.has('exampleSignature') {a7} then
        result.example := ParseSignature(jsn.vObj['exampleSignature']);
    if jsn.has('exampleSampledData') {a7} then
        result.example := ParseSampledData(jsn.vObj['exampleSampledData']);
    if jsn.has('examplePeriod') {a7} then
        result.example := ParsePeriod(jsn.vObj['examplePeriod']);
    if jsn.has('exampleQuantity') {a7} then
        result.example := ParseQuantity(jsn.vObj['exampleQuantity']);
    if jsn.has('exampleAttachment') {a7} then
        result.example := ParseAttachment(jsn.vObj['exampleAttachment']);
    if jsn.has('exampleRatio') {a7} then
        result.example := ParseRatio(jsn.vObj['exampleRatio']);
    if jsn.has('exampleRange') {a7} then
        result.example := ParseRange(jsn.vObj['exampleRange']);
    if jsn.has('exampleAnnotation') {a7} then
        result.example := ParseAnnotation(jsn.vObj['exampleAnnotation']);
    if jsn.has('exampleCodeableConcept') {a7} then
        result.example := ParseCodeableConcept(jsn.vObj['exampleCodeableConcept']);
    if jsn.has('exampleHumanName') {a9} then
        result.example := ParseHumanName(jsn.vObj['exampleHumanName']);
    if jsn.has('exampleMeta') {a9} then
        result.example := ParseMeta(jsn.vObj['exampleMeta']);
    if jsn.has('exampleContactPoint') {a9} then
        result.example := ParseContactPoint(jsn.vObj['exampleContactPoint']);
    if jsn.has('exampleAddress') {a9} then
        result.example := ParseAddress(jsn.vObj['exampleAddress']);
    if jsn.has('exampleElementDefinition') {a9} then
        result.example := ParseElementDefinition(jsn.vObj['exampleElementDefinition']);
    if jsn.has('exampleTiming') {a9} then
        result.example := ParseTiming(jsn.vObj['exampleTiming']);
    if jsn.has('minValueCode') or jsn.has('_minValueCode') then
        result.minValue := ParseCode(jsn.node['minValueCode'], jsn.vObj['_minValueCode']);
    if jsn.has('minValueOid') or jsn.has('_minValueOid') then
        result.minValue := ParseOid(jsn.node['minValueOid'], jsn.vObj['_minValueOid']);
    if jsn.has('minValueUuid') or jsn.has('_minValueUuid') then
        result.minValue := ParseUuid(jsn.node['minValueUuid'], jsn.vObj['_minValueUuid']);
    if jsn.has('minValueMarkdown') or jsn.has('_minValueMarkdown') then
        result.minValue := ParseMarkdown(jsn.node['minValueMarkdown'], jsn.vObj['_minValueMarkdown']);
    if jsn.has('minValueUnsignedInt') or jsn.has('_minValueUnsignedInt') then
        result.minValue := ParseUnsignedInt(jsn.node['minValueUnsignedInt'], jsn.vObj['_minValueUnsignedInt']);
    if jsn.has('minValueId') or jsn.has('_minValueId') then
        result.minValue := ParseId(jsn.node['minValueId'], jsn.vObj['_minValueId']);
    if jsn.has('minValuePositiveInt') or jsn.has('_minValuePositiveInt') then
        result.minValue := ParsePositiveInt(jsn.node['minValuePositiveInt'], jsn.vObj['_minValuePositiveInt']);
    if jsn.has('minValueDateTime') or jsn.has('_minValueDateTime') then
        result.minValue := ParseDateTime(jsn.node['minValueDateTime'], jsn.vObj['_minValueDateTime']);
    if jsn.has('minValueDate') or jsn.has('_minValueDate') then
        result.minValue := ParseDate(jsn.node['minValueDate'], jsn.vObj['_minValueDate']);
    if jsn.has('minValueString') or jsn.has('_minValueString') then
        result.minValue := ParseString(jsn.node['minValueString'], jsn.vObj['_minValueString']);
    if jsn.has('minValueInteger') or jsn.has('_minValueInteger') then
        result.minValue := ParseInteger(jsn.node['minValueInteger'], jsn.vObj['_minValueInteger']);
    if jsn.has('minValueUri') or jsn.has('_minValueUri') then
        result.minValue := ParseUri(jsn.node['minValueUri'], jsn.vObj['_minValueUri']);
    if jsn.has('minValueInstant') or jsn.has('_minValueInstant') then
        result.minValue := ParseInstant(jsn.node['minValueInstant'], jsn.vObj['_minValueInstant']);
    if jsn.has('minValueBoolean') or jsn.has('_minValueBoolean') then
        result.minValue := ParseBoolean(jsn.node['minValueBoolean'], jsn.vObj['_minValueBoolean']);
    if jsn.has('minValueBase64Binary') or jsn.has('_minValueBase64Binary') then
        result.minValue := ParseBase64Binary(jsn.node['minValueBase64Binary'], jsn.vObj['_minValueBase64Binary']);
    if jsn.has('minValueTime') or jsn.has('_minValueTime') then
        result.minValue := ParseTime(jsn.node['minValueTime'], jsn.vObj['_minValueTime']);
    if jsn.has('minValueDecimal') or jsn.has('_minValueDecimal') then
        result.minValue := ParseDecimal(jsn.node['minValueDecimal'], jsn.vObj['_minValueDecimal']);
    if jsn.has('minValueIdentifier') {a7} then
        result.minValue := ParseIdentifier(jsn.vObj['minValueIdentifier']);
    if jsn.has('minValueCoding') {a7} then
        result.minValue := ParseCoding(jsn.vObj['minValueCoding']);
    if jsn.has('minValueReference') {a7} then
        result.minValue := ParseReference(jsn.vObj['minValueReference']);
    if jsn.has('minValueSignature') {a7} then
        result.minValue := ParseSignature(jsn.vObj['minValueSignature']);
    if jsn.has('minValueSampledData') {a7} then
        result.minValue := ParseSampledData(jsn.vObj['minValueSampledData']);
    if jsn.has('minValuePeriod') {a7} then
        result.minValue := ParsePeriod(jsn.vObj['minValuePeriod']);
    if jsn.has('minValueQuantity') {a7} then
        result.minValue := ParseQuantity(jsn.vObj['minValueQuantity']);
    if jsn.has('minValueAttachment') {a7} then
        result.minValue := ParseAttachment(jsn.vObj['minValueAttachment']);
    if jsn.has('minValueRatio') {a7} then
        result.minValue := ParseRatio(jsn.vObj['minValueRatio']);
    if jsn.has('minValueRange') {a7} then
        result.minValue := ParseRange(jsn.vObj['minValueRange']);
    if jsn.has('minValueAnnotation') {a7} then
        result.minValue := ParseAnnotation(jsn.vObj['minValueAnnotation']);
    if jsn.has('minValueCodeableConcept') {a7} then
        result.minValue := ParseCodeableConcept(jsn.vObj['minValueCodeableConcept']);
    if jsn.has('minValueHumanName') {a9} then
        result.minValue := ParseHumanName(jsn.vObj['minValueHumanName']);
    if jsn.has('minValueMeta') {a9} then
        result.minValue := ParseMeta(jsn.vObj['minValueMeta']);
    if jsn.has('minValueContactPoint') {a9} then
        result.minValue := ParseContactPoint(jsn.vObj['minValueContactPoint']);
    if jsn.has('minValueAddress') {a9} then
        result.minValue := ParseAddress(jsn.vObj['minValueAddress']);
    if jsn.has('minValueElementDefinition') {a9} then
        result.minValue := ParseElementDefinition(jsn.vObj['minValueElementDefinition']);
    if jsn.has('minValueTiming') {a9} then
        result.minValue := ParseTiming(jsn.vObj['minValueTiming']);
    if jsn.has('maxValueCode') or jsn.has('_maxValueCode') then
        result.maxValue := ParseCode(jsn.node['maxValueCode'], jsn.vObj['_maxValueCode']);
    if jsn.has('maxValueOid') or jsn.has('_maxValueOid') then
        result.maxValue := ParseOid(jsn.node['maxValueOid'], jsn.vObj['_maxValueOid']);
    if jsn.has('maxValueUuid') or jsn.has('_maxValueUuid') then
        result.maxValue := ParseUuid(jsn.node['maxValueUuid'], jsn.vObj['_maxValueUuid']);
    if jsn.has('maxValueMarkdown') or jsn.has('_maxValueMarkdown') then
        result.maxValue := ParseMarkdown(jsn.node['maxValueMarkdown'], jsn.vObj['_maxValueMarkdown']);
    if jsn.has('maxValueUnsignedInt') or jsn.has('_maxValueUnsignedInt') then
        result.maxValue := ParseUnsignedInt(jsn.node['maxValueUnsignedInt'], jsn.vObj['_maxValueUnsignedInt']);
    if jsn.has('maxValueId') or jsn.has('_maxValueId') then
        result.maxValue := ParseId(jsn.node['maxValueId'], jsn.vObj['_maxValueId']);
    if jsn.has('maxValuePositiveInt') or jsn.has('_maxValuePositiveInt') then
        result.maxValue := ParsePositiveInt(jsn.node['maxValuePositiveInt'], jsn.vObj['_maxValuePositiveInt']);
    if jsn.has('maxValueDateTime') or jsn.has('_maxValueDateTime') then
        result.maxValue := ParseDateTime(jsn.node['maxValueDateTime'], jsn.vObj['_maxValueDateTime']);
    if jsn.has('maxValueDate') or jsn.has('_maxValueDate') then
        result.maxValue := ParseDate(jsn.node['maxValueDate'], jsn.vObj['_maxValueDate']);
    if jsn.has('maxValueString') or jsn.has('_maxValueString') then
        result.maxValue := ParseString(jsn.node['maxValueString'], jsn.vObj['_maxValueString']);
    if jsn.has('maxValueInteger') or jsn.has('_maxValueInteger') then
        result.maxValue := ParseInteger(jsn.node['maxValueInteger'], jsn.vObj['_maxValueInteger']);
    if jsn.has('maxValueUri') or jsn.has('_maxValueUri') then
        result.maxValue := ParseUri(jsn.node['maxValueUri'], jsn.vObj['_maxValueUri']);
    if jsn.has('maxValueInstant') or jsn.has('_maxValueInstant') then
        result.maxValue := ParseInstant(jsn.node['maxValueInstant'], jsn.vObj['_maxValueInstant']);
    if jsn.has('maxValueBoolean') or jsn.has('_maxValueBoolean') then
        result.maxValue := ParseBoolean(jsn.node['maxValueBoolean'], jsn.vObj['_maxValueBoolean']);
    if jsn.has('maxValueBase64Binary') or jsn.has('_maxValueBase64Binary') then
        result.maxValue := ParseBase64Binary(jsn.node['maxValueBase64Binary'], jsn.vObj['_maxValueBase64Binary']);
    if jsn.has('maxValueTime') or jsn.has('_maxValueTime') then
        result.maxValue := ParseTime(jsn.node['maxValueTime'], jsn.vObj['_maxValueTime']);
    if jsn.has('maxValueDecimal') or jsn.has('_maxValueDecimal') then
        result.maxValue := ParseDecimal(jsn.node['maxValueDecimal'], jsn.vObj['_maxValueDecimal']);
    if jsn.has('maxValueIdentifier') {a7} then
        result.maxValue := ParseIdentifier(jsn.vObj['maxValueIdentifier']);
    if jsn.has('maxValueCoding') {a7} then
        result.maxValue := ParseCoding(jsn.vObj['maxValueCoding']);
    if jsn.has('maxValueReference') {a7} then
        result.maxValue := ParseReference(jsn.vObj['maxValueReference']);
    if jsn.has('maxValueSignature') {a7} then
        result.maxValue := ParseSignature(jsn.vObj['maxValueSignature']);
    if jsn.has('maxValueSampledData') {a7} then
        result.maxValue := ParseSampledData(jsn.vObj['maxValueSampledData']);
    if jsn.has('maxValuePeriod') {a7} then
        result.maxValue := ParsePeriod(jsn.vObj['maxValuePeriod']);
    if jsn.has('maxValueQuantity') {a7} then
        result.maxValue := ParseQuantity(jsn.vObj['maxValueQuantity']);
    if jsn.has('maxValueAttachment') {a7} then
        result.maxValue := ParseAttachment(jsn.vObj['maxValueAttachment']);
    if jsn.has('maxValueRatio') {a7} then
        result.maxValue := ParseRatio(jsn.vObj['maxValueRatio']);
    if jsn.has('maxValueRange') {a7} then
        result.maxValue := ParseRange(jsn.vObj['maxValueRange']);
    if jsn.has('maxValueAnnotation') {a7} then
        result.maxValue := ParseAnnotation(jsn.vObj['maxValueAnnotation']);
    if jsn.has('maxValueCodeableConcept') {a7} then
        result.maxValue := ParseCodeableConcept(jsn.vObj['maxValueCodeableConcept']);
    if jsn.has('maxValueHumanName') {a9} then
        result.maxValue := ParseHumanName(jsn.vObj['maxValueHumanName']);
    if jsn.has('maxValueMeta') {a9} then
        result.maxValue := ParseMeta(jsn.vObj['maxValueMeta']);
    if jsn.has('maxValueContactPoint') {a9} then
        result.maxValue := ParseContactPoint(jsn.vObj['maxValueContactPoint']);
    if jsn.has('maxValueAddress') {a9} then
        result.maxValue := ParseAddress(jsn.vObj['maxValueAddress']);
    if jsn.has('maxValueElementDefinition') {a9} then
        result.maxValue := ParseElementDefinition(jsn.vObj['maxValueElementDefinition']);
    if jsn.has('maxValueTiming') {a9} then
        result.maxValue := ParseTiming(jsn.vObj['maxValueTiming']);
    if jsn.has('maxLength') or jsn.has('_maxLength') then
        result.maxLengthElement := ParseInteger(jsn.node['maxLength'], jsn.vObj['_maxLength']);{q}
      if jsn.has('condition') or jsn.has('_condition') then
      iteratePrimitiveArray(jsn.vArr['condition'], jsn.vArr['_condition'], result.conditionList, parseId);
    if jsn.has('constraint') then
      iterateArray(jsn.vArr['constraint'], result.constraintList, parseElementDefinitionConstraint);
    if jsn.has('mustSupport') or jsn.has('_mustSupport') then
        result.mustSupportElement := ParseBoolean(jsn.node['mustSupport'], jsn.vObj['_mustSupport']);{q}
    if jsn.has('isModifier') or jsn.has('_isModifier') then
        result.isModifierElement := ParseBoolean(jsn.node['isModifier'], jsn.vObj['_isModifier']);{q}
    if jsn.has('isSummary') or jsn.has('_isSummary') then
        result.isSummaryElement := ParseBoolean(jsn.node['isSummary'], jsn.vObj['_isSummary']);{q}
    if jsn.has('binding') then
        result.binding := ParseElementDefinitionBinding(jsn.vObj['binding']);{q3}
    if jsn.has('mapping') then
      iterateArray(jsn.vArr['mapping'], result.mappingList, parseElementDefinitionMapping);
end;

procedure TFHIRJsonComposer.ComposeElementDefinition(json : TJSONWriter; name : string; elem : TFhirElementDefinition; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  composeElement(json, '', elem, true);
  ComposeStringValue(json, 'path', elem.pathElement, false);
  ComposeStringProps(json, 'path', elem.pathElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.representationList.Count > 0) then
  begin
    val := false;
    ext := false;
    for i := 0 to elem.representationList.Count - 1 do
    begin
      val := val or (elem.representationList[i].hasPrimitiveValue);
      ext := ext or ((elem.representationList[i].id <> '') or (elem.representationList[i].hasExtensionList));
    end;
    if val then
    begin
      startArray(json, 'representation', elem.representationList, true);
      for i := 0 to elem.representationList.Count - 1 do
        ComposeEnumValue(json, '', elem.representationList[i], CODES_TFhirPropertyRepresentationEnum, true);
      finishArray(json, elem.representationList);
    end;
    if ext then
    begin
      startArray(json, '_representation', elem.representationList, false);
      for i := 0 to elem.representationList.Count - 1 do
        ComposeEnumProps(json, '', elem.representationList[i], CODES_TFhirPropertyRepresentationEnum, true);
      finishArray(json, elem.representationList);
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'label', elem.label_Element, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'label', elem.label_Element, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.codeList.Count > 0) then
  begin
    startArray(json, 'code', elem.codeList, false);
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCoding(json, '', elem.codeList[i]); {z - Coding}
    finishArray(json, elem.codeList);
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeElementDefinitionSlicing(json, 'slicing', elem.slicing); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'short', elem.shortElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'short', elem.shortElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeMarkdownValue(json, 'definition', elem.definitionElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeMarkdownProps(json, 'definition', elem.definitionElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeMarkdownValue(json, 'comments', elem.commentsElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeMarkdownProps(json, 'comments', elem.commentsElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeMarkdownValue(json, 'requirements', elem.requirementsElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeMarkdownProps(json, 'requirements', elem.requirementsElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.aliasList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.aliasList.Count - 1 do
    begin
      ext := ext or ((elem.aliasList[i].id <> '') or (elem.aliasList[i].hasExtensionList) {no-comments or (elem.aliasList[i].hasComments)});
      val := val or (elem.aliasList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      startArray(json, 'alias', elem.aliasList, true);
      for i := 0 to elem.aliasList.Count - 1 do
        ComposeStringValue(json, '',elem.aliasList[i], true);
      finishArray(json, elem.aliasList);
    end;
    if ext then
    begin
      startArray(json, '_alias', elem.aliasList, false);
      for i := 0 to elem.aliasList.Count - 1 do
        ComposeStringProps(json, '',elem.aliasList[i], true);
      finishArray(json, elem.aliasList);
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIntegerValue(json, 'min', elem.minElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIntegerProps(json, 'min', elem.minElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'max', elem.maxElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'max', elem.maxElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeElementDefinitionBase(json, 'base', elem.base); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.type_List.Count > 0) then
  begin
    startArray(json, 'type', elem.type_List, false);
    for i := 0 to elem.type_List.Count - 1 do
      ComposeElementDefinitionType(json, '', elem.type_List[i]); {z - }
    finishArray(json, elem.type_List);
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'nameReference', elem.nameReferenceElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'nameReference', elem.nameReferenceElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirCode) then
  begin
    ComposeCodeValue(json, 'defaultValueCode', TFhirCode(elem.defaultValue), false);
    ComposeCodeProps(json, 'defaultValueCode', TFhirCode(elem.defaultValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirOid) then
  begin
    ComposeOidValue(json, 'defaultValueOid', TFhirOid(elem.defaultValue), false);
    ComposeOidProps(json, 'defaultValueOid', TFhirOid(elem.defaultValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirUuid) then
  begin
    ComposeUuidValue(json, 'defaultValueUuid', TFhirUuid(elem.defaultValue), false);
    ComposeUuidProps(json, 'defaultValueUuid', TFhirUuid(elem.defaultValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirMarkdown) then
  begin
    ComposeMarkdownValue(json, 'defaultValueMarkdown', TFhirMarkdown(elem.defaultValue), false);
    ComposeMarkdownProps(json, 'defaultValueMarkdown', TFhirMarkdown(elem.defaultValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirUnsignedInt) then
  begin
    ComposeUnsignedIntValue(json, 'defaultValueUnsignedInt', TFhirUnsignedInt(elem.defaultValue), false);
    ComposeUnsignedIntProps(json, 'defaultValueUnsignedInt', TFhirUnsignedInt(elem.defaultValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirId) then
  begin
    ComposeIdValue(json, 'defaultValueId', TFhirId(elem.defaultValue), false);
    ComposeIdProps(json, 'defaultValueId', TFhirId(elem.defaultValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirPositiveInt) then
  begin
    ComposePositiveIntValue(json, 'defaultValuePositiveInt', TFhirPositiveInt(elem.defaultValue), false);
    ComposePositiveIntProps(json, 'defaultValuePositiveInt', TFhirPositiveInt(elem.defaultValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirDateTime) then
  begin
    ComposeDateTimeValue(json, 'defaultValueDateTime', TFhirDateTime(elem.defaultValue), false);
    ComposeDateTimeProps(json, 'defaultValueDateTime', TFhirDateTime(elem.defaultValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirDate) then
  begin
    ComposeDateValue(json, 'defaultValueDate', TFhirDate(elem.defaultValue), false);
    ComposeDateProps(json, 'defaultValueDate', TFhirDate(elem.defaultValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirString) then
  begin
    ComposeStringValue(json, 'defaultValueString', TFhirString(elem.defaultValue), false);
    ComposeStringProps(json, 'defaultValueString', TFhirString(elem.defaultValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirInteger) then
  begin
    ComposeIntegerValue(json, 'defaultValueInteger', TFhirInteger(elem.defaultValue), false);
    ComposeIntegerProps(json, 'defaultValueInteger', TFhirInteger(elem.defaultValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirUri) then
  begin
    ComposeUriValue(json, 'defaultValueUri', TFhirUri(elem.defaultValue), false);
    ComposeUriProps(json, 'defaultValueUri', TFhirUri(elem.defaultValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirInstant) then
  begin
    ComposeInstantValue(json, 'defaultValueInstant', TFhirInstant(elem.defaultValue), false);
    ComposeInstantProps(json, 'defaultValueInstant', TFhirInstant(elem.defaultValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirBoolean) then
  begin
    ComposeBooleanValue(json, 'defaultValueBoolean', TFhirBoolean(elem.defaultValue), false);
    ComposeBooleanProps(json, 'defaultValueBoolean', TFhirBoolean(elem.defaultValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirBase64Binary) then
  begin
    ComposeBase64BinaryValue(json, 'defaultValueBase64Binary', TFhirBase64Binary(elem.defaultValue), false);
    ComposeBase64BinaryProps(json, 'defaultValueBase64Binary', TFhirBase64Binary(elem.defaultValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirTime) then
  begin
    ComposeTimeValue(json, 'defaultValueTime', TFhirTime(elem.defaultValue), false);
    ComposeTimeProps(json, 'defaultValueTime', TFhirTime(elem.defaultValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirDecimal) then
  begin
    ComposeDecimalValue(json, 'defaultValueDecimal', TFhirDecimal(elem.defaultValue), false);
    ComposeDecimalProps(json, 'defaultValueDecimal', TFhirDecimal(elem.defaultValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirIdentifier) then
    ComposeIdentifier(json, 'defaultValueIdentifier', TFhirIdentifier(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirCoding) then
    ComposeCoding(json, 'defaultValueCoding', TFhirCoding(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirReference) then
    ComposeReference(json, 'defaultValueReference', TFhirReference(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirSignature) then
    ComposeSignature(json, 'defaultValueSignature', TFhirSignature(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirSampledData) then
    ComposeSampledData(json, 'defaultValueSampledData', TFhirSampledData(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirPeriod) then
    ComposePeriod(json, 'defaultValuePeriod', TFhirPeriod(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirQuantity) then
    ComposeQuantity(json, 'defaultValueQuantity', TFhirQuantity(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirAttachment) then
    ComposeAttachment(json, 'defaultValueAttachment', TFhirAttachment(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirRatio) then
    ComposeRatio(json, 'defaultValueRatio', TFhirRatio(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirRange) then
    ComposeRange(json, 'defaultValueRange', TFhirRange(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirAnnotation) then
    ComposeAnnotation(json, 'defaultValueAnnotation', TFhirAnnotation(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirCodeableConcept) then
    ComposeCodeableConcept(json, 'defaultValueCodeableConcept', TFhirCodeableConcept(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirHumanName) then
    ComposeHumanName(json, 'defaultValueHumanName', TFhirHumanName(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirMeta) then
    ComposeMeta(json, 'defaultValueMeta', TFhirMeta(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirContactPoint) then
    ComposeContactPoint(json, 'defaultValueContactPoint', TFhirContactPoint(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirAddress) then
    ComposeAddress(json, 'defaultValueAddress', TFhirAddress(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirElementDefinition) then
    ComposeElementDefinition(json, 'defaultValueElementDefinition', TFhirElementDefinition(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirTiming) then
    ComposeTiming(json, 'defaultValueTiming', TFhirTiming(elem.defaultValue));
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeMarkdownValue(json, 'meaningWhenMissing', elem.meaningWhenMissingElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeMarkdownProps(json, 'meaningWhenMissing', elem.meaningWhenMissingElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirCode) then
  begin
    ComposeCodeValue(json, 'fixedCode', TFhirCode(elem.fixed), false);
    ComposeCodeProps(json, 'fixedCode', TFhirCode(elem.fixed), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirOid) then
  begin
    ComposeOidValue(json, 'fixedOid', TFhirOid(elem.fixed), false);
    ComposeOidProps(json, 'fixedOid', TFhirOid(elem.fixed), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirUuid) then
  begin
    ComposeUuidValue(json, 'fixedUuid', TFhirUuid(elem.fixed), false);
    ComposeUuidProps(json, 'fixedUuid', TFhirUuid(elem.fixed), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirMarkdown) then
  begin
    ComposeMarkdownValue(json, 'fixedMarkdown', TFhirMarkdown(elem.fixed), false);
    ComposeMarkdownProps(json, 'fixedMarkdown', TFhirMarkdown(elem.fixed), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirUnsignedInt) then
  begin
    ComposeUnsignedIntValue(json, 'fixedUnsignedInt', TFhirUnsignedInt(elem.fixed), false);
    ComposeUnsignedIntProps(json, 'fixedUnsignedInt', TFhirUnsignedInt(elem.fixed), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirId) then
  begin
    ComposeIdValue(json, 'fixedId', TFhirId(elem.fixed), false);
    ComposeIdProps(json, 'fixedId', TFhirId(elem.fixed), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirPositiveInt) then
  begin
    ComposePositiveIntValue(json, 'fixedPositiveInt', TFhirPositiveInt(elem.fixed), false);
    ComposePositiveIntProps(json, 'fixedPositiveInt', TFhirPositiveInt(elem.fixed), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirDateTime) then
  begin
    ComposeDateTimeValue(json, 'fixedDateTime', TFhirDateTime(elem.fixed), false);
    ComposeDateTimeProps(json, 'fixedDateTime', TFhirDateTime(elem.fixed), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirDate) then
  begin
    ComposeDateValue(json, 'fixedDate', TFhirDate(elem.fixed), false);
    ComposeDateProps(json, 'fixedDate', TFhirDate(elem.fixed), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirString) then
  begin
    ComposeStringValue(json, 'fixedString', TFhirString(elem.fixed), false);
    ComposeStringProps(json, 'fixedString', TFhirString(elem.fixed), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirInteger) then
  begin
    ComposeIntegerValue(json, 'fixedInteger', TFhirInteger(elem.fixed), false);
    ComposeIntegerProps(json, 'fixedInteger', TFhirInteger(elem.fixed), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirUri) then
  begin
    ComposeUriValue(json, 'fixedUri', TFhirUri(elem.fixed), false);
    ComposeUriProps(json, 'fixedUri', TFhirUri(elem.fixed), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirInstant) then
  begin
    ComposeInstantValue(json, 'fixedInstant', TFhirInstant(elem.fixed), false);
    ComposeInstantProps(json, 'fixedInstant', TFhirInstant(elem.fixed), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirBoolean) then
  begin
    ComposeBooleanValue(json, 'fixedBoolean', TFhirBoolean(elem.fixed), false);
    ComposeBooleanProps(json, 'fixedBoolean', TFhirBoolean(elem.fixed), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirBase64Binary) then
  begin
    ComposeBase64BinaryValue(json, 'fixedBase64Binary', TFhirBase64Binary(elem.fixed), false);
    ComposeBase64BinaryProps(json, 'fixedBase64Binary', TFhirBase64Binary(elem.fixed), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirTime) then
  begin
    ComposeTimeValue(json, 'fixedTime', TFhirTime(elem.fixed), false);
    ComposeTimeProps(json, 'fixedTime', TFhirTime(elem.fixed), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirDecimal) then
  begin
    ComposeDecimalValue(json, 'fixedDecimal', TFhirDecimal(elem.fixed), false);
    ComposeDecimalProps(json, 'fixedDecimal', TFhirDecimal(elem.fixed), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirIdentifier) then
    ComposeIdentifier(json, 'fixedIdentifier', TFhirIdentifier(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirCoding) then
    ComposeCoding(json, 'fixedCoding', TFhirCoding(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirReference) then
    ComposeReference(json, 'fixedReference', TFhirReference(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirSignature) then
    ComposeSignature(json, 'fixedSignature', TFhirSignature(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirSampledData) then
    ComposeSampledData(json, 'fixedSampledData', TFhirSampledData(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirPeriod) then
    ComposePeriod(json, 'fixedPeriod', TFhirPeriod(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirQuantity) then
    ComposeQuantity(json, 'fixedQuantity', TFhirQuantity(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirAttachment) then
    ComposeAttachment(json, 'fixedAttachment', TFhirAttachment(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirRatio) then
    ComposeRatio(json, 'fixedRatio', TFhirRatio(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirRange) then
    ComposeRange(json, 'fixedRange', TFhirRange(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirAnnotation) then
    ComposeAnnotation(json, 'fixedAnnotation', TFhirAnnotation(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirCodeableConcept) then
    ComposeCodeableConcept(json, 'fixedCodeableConcept', TFhirCodeableConcept(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirHumanName) then
    ComposeHumanName(json, 'fixedHumanName', TFhirHumanName(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirMeta) then
    ComposeMeta(json, 'fixedMeta', TFhirMeta(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirContactPoint) then
    ComposeContactPoint(json, 'fixedContactPoint', TFhirContactPoint(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirAddress) then
    ComposeAddress(json, 'fixedAddress', TFhirAddress(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirElementDefinition) then
    ComposeElementDefinition(json, 'fixedElementDefinition', TFhirElementDefinition(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirTiming) then
    ComposeTiming(json, 'fixedTiming', TFhirTiming(elem.fixed));
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirCode) then
  begin
    ComposeCodeValue(json, 'patternCode', TFhirCode(elem.pattern), false);
    ComposeCodeProps(json, 'patternCode', TFhirCode(elem.pattern), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirOid) then
  begin
    ComposeOidValue(json, 'patternOid', TFhirOid(elem.pattern), false);
    ComposeOidProps(json, 'patternOid', TFhirOid(elem.pattern), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirUuid) then
  begin
    ComposeUuidValue(json, 'patternUuid', TFhirUuid(elem.pattern), false);
    ComposeUuidProps(json, 'patternUuid', TFhirUuid(elem.pattern), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirMarkdown) then
  begin
    ComposeMarkdownValue(json, 'patternMarkdown', TFhirMarkdown(elem.pattern), false);
    ComposeMarkdownProps(json, 'patternMarkdown', TFhirMarkdown(elem.pattern), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirUnsignedInt) then
  begin
    ComposeUnsignedIntValue(json, 'patternUnsignedInt', TFhirUnsignedInt(elem.pattern), false);
    ComposeUnsignedIntProps(json, 'patternUnsignedInt', TFhirUnsignedInt(elem.pattern), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirId) then
  begin
    ComposeIdValue(json, 'patternId', TFhirId(elem.pattern), false);
    ComposeIdProps(json, 'patternId', TFhirId(elem.pattern), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirPositiveInt) then
  begin
    ComposePositiveIntValue(json, 'patternPositiveInt', TFhirPositiveInt(elem.pattern), false);
    ComposePositiveIntProps(json, 'patternPositiveInt', TFhirPositiveInt(elem.pattern), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirDateTime) then
  begin
    ComposeDateTimeValue(json, 'patternDateTime', TFhirDateTime(elem.pattern), false);
    ComposeDateTimeProps(json, 'patternDateTime', TFhirDateTime(elem.pattern), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirDate) then
  begin
    ComposeDateValue(json, 'patternDate', TFhirDate(elem.pattern), false);
    ComposeDateProps(json, 'patternDate', TFhirDate(elem.pattern), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirString) then
  begin
    ComposeStringValue(json, 'patternString', TFhirString(elem.pattern), false);
    ComposeStringProps(json, 'patternString', TFhirString(elem.pattern), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirInteger) then
  begin
    ComposeIntegerValue(json, 'patternInteger', TFhirInteger(elem.pattern), false);
    ComposeIntegerProps(json, 'patternInteger', TFhirInteger(elem.pattern), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirUri) then
  begin
    ComposeUriValue(json, 'patternUri', TFhirUri(elem.pattern), false);
    ComposeUriProps(json, 'patternUri', TFhirUri(elem.pattern), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirInstant) then
  begin
    ComposeInstantValue(json, 'patternInstant', TFhirInstant(elem.pattern), false);
    ComposeInstantProps(json, 'patternInstant', TFhirInstant(elem.pattern), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirBoolean) then
  begin
    ComposeBooleanValue(json, 'patternBoolean', TFhirBoolean(elem.pattern), false);
    ComposeBooleanProps(json, 'patternBoolean', TFhirBoolean(elem.pattern), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirBase64Binary) then
  begin
    ComposeBase64BinaryValue(json, 'patternBase64Binary', TFhirBase64Binary(elem.pattern), false);
    ComposeBase64BinaryProps(json, 'patternBase64Binary', TFhirBase64Binary(elem.pattern), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirTime) then
  begin
    ComposeTimeValue(json, 'patternTime', TFhirTime(elem.pattern), false);
    ComposeTimeProps(json, 'patternTime', TFhirTime(elem.pattern), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirDecimal) then
  begin
    ComposeDecimalValue(json, 'patternDecimal', TFhirDecimal(elem.pattern), false);
    ComposeDecimalProps(json, 'patternDecimal', TFhirDecimal(elem.pattern), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirIdentifier) then
    ComposeIdentifier(json, 'patternIdentifier', TFhirIdentifier(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirCoding) then
    ComposeCoding(json, 'patternCoding', TFhirCoding(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirReference) then
    ComposeReference(json, 'patternReference', TFhirReference(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirSignature) then
    ComposeSignature(json, 'patternSignature', TFhirSignature(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirSampledData) then
    ComposeSampledData(json, 'patternSampledData', TFhirSampledData(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirPeriod) then
    ComposePeriod(json, 'patternPeriod', TFhirPeriod(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirQuantity) then
    ComposeQuantity(json, 'patternQuantity', TFhirQuantity(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirAttachment) then
    ComposeAttachment(json, 'patternAttachment', TFhirAttachment(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirRatio) then
    ComposeRatio(json, 'patternRatio', TFhirRatio(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirRange) then
    ComposeRange(json, 'patternRange', TFhirRange(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirAnnotation) then
    ComposeAnnotation(json, 'patternAnnotation', TFhirAnnotation(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirCodeableConcept) then
    ComposeCodeableConcept(json, 'patternCodeableConcept', TFhirCodeableConcept(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirHumanName) then
    ComposeHumanName(json, 'patternHumanName', TFhirHumanName(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirMeta) then
    ComposeMeta(json, 'patternMeta', TFhirMeta(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirContactPoint) then
    ComposeContactPoint(json, 'patternContactPoint', TFhirContactPoint(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirAddress) then
    ComposeAddress(json, 'patternAddress', TFhirAddress(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirElementDefinition) then
    ComposeElementDefinition(json, 'patternElementDefinition', TFhirElementDefinition(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirTiming) then
    ComposeTiming(json, 'patternTiming', TFhirTiming(elem.pattern));
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirCode) then
  begin
    ComposeCodeValue(json, 'exampleCode', TFhirCode(elem.example), false);
    ComposeCodeProps(json, 'exampleCode', TFhirCode(elem.example), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirOid) then
  begin
    ComposeOidValue(json, 'exampleOid', TFhirOid(elem.example), false);
    ComposeOidProps(json, 'exampleOid', TFhirOid(elem.example), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirUuid) then
  begin
    ComposeUuidValue(json, 'exampleUuid', TFhirUuid(elem.example), false);
    ComposeUuidProps(json, 'exampleUuid', TFhirUuid(elem.example), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirMarkdown) then
  begin
    ComposeMarkdownValue(json, 'exampleMarkdown', TFhirMarkdown(elem.example), false);
    ComposeMarkdownProps(json, 'exampleMarkdown', TFhirMarkdown(elem.example), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirUnsignedInt) then
  begin
    ComposeUnsignedIntValue(json, 'exampleUnsignedInt', TFhirUnsignedInt(elem.example), false);
    ComposeUnsignedIntProps(json, 'exampleUnsignedInt', TFhirUnsignedInt(elem.example), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirId) then
  begin
    ComposeIdValue(json, 'exampleId', TFhirId(elem.example), false);
    ComposeIdProps(json, 'exampleId', TFhirId(elem.example), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirPositiveInt) then
  begin
    ComposePositiveIntValue(json, 'examplePositiveInt', TFhirPositiveInt(elem.example), false);
    ComposePositiveIntProps(json, 'examplePositiveInt', TFhirPositiveInt(elem.example), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirDateTime) then
  begin
    ComposeDateTimeValue(json, 'exampleDateTime', TFhirDateTime(elem.example), false);
    ComposeDateTimeProps(json, 'exampleDateTime', TFhirDateTime(elem.example), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirDate) then
  begin
    ComposeDateValue(json, 'exampleDate', TFhirDate(elem.example), false);
    ComposeDateProps(json, 'exampleDate', TFhirDate(elem.example), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirString) then
  begin
    ComposeStringValue(json, 'exampleString', TFhirString(elem.example), false);
    ComposeStringProps(json, 'exampleString', TFhirString(elem.example), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirInteger) then
  begin
    ComposeIntegerValue(json, 'exampleInteger', TFhirInteger(elem.example), false);
    ComposeIntegerProps(json, 'exampleInteger', TFhirInteger(elem.example), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirUri) then
  begin
    ComposeUriValue(json, 'exampleUri', TFhirUri(elem.example), false);
    ComposeUriProps(json, 'exampleUri', TFhirUri(elem.example), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirInstant) then
  begin
    ComposeInstantValue(json, 'exampleInstant', TFhirInstant(elem.example), false);
    ComposeInstantProps(json, 'exampleInstant', TFhirInstant(elem.example), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirBoolean) then
  begin
    ComposeBooleanValue(json, 'exampleBoolean', TFhirBoolean(elem.example), false);
    ComposeBooleanProps(json, 'exampleBoolean', TFhirBoolean(elem.example), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirBase64Binary) then
  begin
    ComposeBase64BinaryValue(json, 'exampleBase64Binary', TFhirBase64Binary(elem.example), false);
    ComposeBase64BinaryProps(json, 'exampleBase64Binary', TFhirBase64Binary(elem.example), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirTime) then
  begin
    ComposeTimeValue(json, 'exampleTime', TFhirTime(elem.example), false);
    ComposeTimeProps(json, 'exampleTime', TFhirTime(elem.example), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirDecimal) then
  begin
    ComposeDecimalValue(json, 'exampleDecimal', TFhirDecimal(elem.example), false);
    ComposeDecimalProps(json, 'exampleDecimal', TFhirDecimal(elem.example), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirIdentifier) then
    ComposeIdentifier(json, 'exampleIdentifier', TFhirIdentifier(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirCoding) then
    ComposeCoding(json, 'exampleCoding', TFhirCoding(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirReference) then
    ComposeReference(json, 'exampleReference', TFhirReference(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirSignature) then
    ComposeSignature(json, 'exampleSignature', TFhirSignature(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirSampledData) then
    ComposeSampledData(json, 'exampleSampledData', TFhirSampledData(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirPeriod) then
    ComposePeriod(json, 'examplePeriod', TFhirPeriod(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirQuantity) then
    ComposeQuantity(json, 'exampleQuantity', TFhirQuantity(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirAttachment) then
    ComposeAttachment(json, 'exampleAttachment', TFhirAttachment(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirRatio) then
    ComposeRatio(json, 'exampleRatio', TFhirRatio(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirRange) then
    ComposeRange(json, 'exampleRange', TFhirRange(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirAnnotation) then
    ComposeAnnotation(json, 'exampleAnnotation', TFhirAnnotation(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirCodeableConcept) then
    ComposeCodeableConcept(json, 'exampleCodeableConcept', TFhirCodeableConcept(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirHumanName) then
    ComposeHumanName(json, 'exampleHumanName', TFhirHumanName(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirMeta) then
    ComposeMeta(json, 'exampleMeta', TFhirMeta(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirContactPoint) then
    ComposeContactPoint(json, 'exampleContactPoint', TFhirContactPoint(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirAddress) then
    ComposeAddress(json, 'exampleAddress', TFhirAddress(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirElementDefinition) then
    ComposeElementDefinition(json, 'exampleElementDefinition', TFhirElementDefinition(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirTiming) then
    ComposeTiming(json, 'exampleTiming', TFhirTiming(elem.example));
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirCode) then
  begin
    ComposeCodeValue(json, 'minValueCode', TFhirCode(elem.minValue), false);
    ComposeCodeProps(json, 'minValueCode', TFhirCode(elem.minValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirOid) then
  begin
    ComposeOidValue(json, 'minValueOid', TFhirOid(elem.minValue), false);
    ComposeOidProps(json, 'minValueOid', TFhirOid(elem.minValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirUuid) then
  begin
    ComposeUuidValue(json, 'minValueUuid', TFhirUuid(elem.minValue), false);
    ComposeUuidProps(json, 'minValueUuid', TFhirUuid(elem.minValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirMarkdown) then
  begin
    ComposeMarkdownValue(json, 'minValueMarkdown', TFhirMarkdown(elem.minValue), false);
    ComposeMarkdownProps(json, 'minValueMarkdown', TFhirMarkdown(elem.minValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirUnsignedInt) then
  begin
    ComposeUnsignedIntValue(json, 'minValueUnsignedInt', TFhirUnsignedInt(elem.minValue), false);
    ComposeUnsignedIntProps(json, 'minValueUnsignedInt', TFhirUnsignedInt(elem.minValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirId) then
  begin
    ComposeIdValue(json, 'minValueId', TFhirId(elem.minValue), false);
    ComposeIdProps(json, 'minValueId', TFhirId(elem.minValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirPositiveInt) then
  begin
    ComposePositiveIntValue(json, 'minValuePositiveInt', TFhirPositiveInt(elem.minValue), false);
    ComposePositiveIntProps(json, 'minValuePositiveInt', TFhirPositiveInt(elem.minValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirDateTime) then
  begin
    ComposeDateTimeValue(json, 'minValueDateTime', TFhirDateTime(elem.minValue), false);
    ComposeDateTimeProps(json, 'minValueDateTime', TFhirDateTime(elem.minValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirDate) then
  begin
    ComposeDateValue(json, 'minValueDate', TFhirDate(elem.minValue), false);
    ComposeDateProps(json, 'minValueDate', TFhirDate(elem.minValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirString) then
  begin
    ComposeStringValue(json, 'minValueString', TFhirString(elem.minValue), false);
    ComposeStringProps(json, 'minValueString', TFhirString(elem.minValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirInteger) then
  begin
    ComposeIntegerValue(json, 'minValueInteger', TFhirInteger(elem.minValue), false);
    ComposeIntegerProps(json, 'minValueInteger', TFhirInteger(elem.minValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirUri) then
  begin
    ComposeUriValue(json, 'minValueUri', TFhirUri(elem.minValue), false);
    ComposeUriProps(json, 'minValueUri', TFhirUri(elem.minValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirInstant) then
  begin
    ComposeInstantValue(json, 'minValueInstant', TFhirInstant(elem.minValue), false);
    ComposeInstantProps(json, 'minValueInstant', TFhirInstant(elem.minValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirBoolean) then
  begin
    ComposeBooleanValue(json, 'minValueBoolean', TFhirBoolean(elem.minValue), false);
    ComposeBooleanProps(json, 'minValueBoolean', TFhirBoolean(elem.minValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirBase64Binary) then
  begin
    ComposeBase64BinaryValue(json, 'minValueBase64Binary', TFhirBase64Binary(elem.minValue), false);
    ComposeBase64BinaryProps(json, 'minValueBase64Binary', TFhirBase64Binary(elem.minValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirTime) then
  begin
    ComposeTimeValue(json, 'minValueTime', TFhirTime(elem.minValue), false);
    ComposeTimeProps(json, 'minValueTime', TFhirTime(elem.minValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirDecimal) then
  begin
    ComposeDecimalValue(json, 'minValueDecimal', TFhirDecimal(elem.minValue), false);
    ComposeDecimalProps(json, 'minValueDecimal', TFhirDecimal(elem.minValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirIdentifier) then
    ComposeIdentifier(json, 'minValueIdentifier', TFhirIdentifier(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirCoding) then
    ComposeCoding(json, 'minValueCoding', TFhirCoding(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirReference) then
    ComposeReference(json, 'minValueReference', TFhirReference(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirSignature) then
    ComposeSignature(json, 'minValueSignature', TFhirSignature(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirSampledData) then
    ComposeSampledData(json, 'minValueSampledData', TFhirSampledData(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirPeriod) then
    ComposePeriod(json, 'minValuePeriod', TFhirPeriod(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirQuantity) then
    ComposeQuantity(json, 'minValueQuantity', TFhirQuantity(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirAttachment) then
    ComposeAttachment(json, 'minValueAttachment', TFhirAttachment(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirRatio) then
    ComposeRatio(json, 'minValueRatio', TFhirRatio(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirRange) then
    ComposeRange(json, 'minValueRange', TFhirRange(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirAnnotation) then
    ComposeAnnotation(json, 'minValueAnnotation', TFhirAnnotation(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirCodeableConcept) then
    ComposeCodeableConcept(json, 'minValueCodeableConcept', TFhirCodeableConcept(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirHumanName) then
    ComposeHumanName(json, 'minValueHumanName', TFhirHumanName(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirMeta) then
    ComposeMeta(json, 'minValueMeta', TFhirMeta(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirContactPoint) then
    ComposeContactPoint(json, 'minValueContactPoint', TFhirContactPoint(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirAddress) then
    ComposeAddress(json, 'minValueAddress', TFhirAddress(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirElementDefinition) then
    ComposeElementDefinition(json, 'minValueElementDefinition', TFhirElementDefinition(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirTiming) then
    ComposeTiming(json, 'minValueTiming', TFhirTiming(elem.minValue));
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirCode) then
  begin
    ComposeCodeValue(json, 'maxValueCode', TFhirCode(elem.maxValue), false);
    ComposeCodeProps(json, 'maxValueCode', TFhirCode(elem.maxValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirOid) then
  begin
    ComposeOidValue(json, 'maxValueOid', TFhirOid(elem.maxValue), false);
    ComposeOidProps(json, 'maxValueOid', TFhirOid(elem.maxValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirUuid) then
  begin
    ComposeUuidValue(json, 'maxValueUuid', TFhirUuid(elem.maxValue), false);
    ComposeUuidProps(json, 'maxValueUuid', TFhirUuid(elem.maxValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirMarkdown) then
  begin
    ComposeMarkdownValue(json, 'maxValueMarkdown', TFhirMarkdown(elem.maxValue), false);
    ComposeMarkdownProps(json, 'maxValueMarkdown', TFhirMarkdown(elem.maxValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirUnsignedInt) then
  begin
    ComposeUnsignedIntValue(json, 'maxValueUnsignedInt', TFhirUnsignedInt(elem.maxValue), false);
    ComposeUnsignedIntProps(json, 'maxValueUnsignedInt', TFhirUnsignedInt(elem.maxValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirId) then
  begin
    ComposeIdValue(json, 'maxValueId', TFhirId(elem.maxValue), false);
    ComposeIdProps(json, 'maxValueId', TFhirId(elem.maxValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirPositiveInt) then
  begin
    ComposePositiveIntValue(json, 'maxValuePositiveInt', TFhirPositiveInt(elem.maxValue), false);
    ComposePositiveIntProps(json, 'maxValuePositiveInt', TFhirPositiveInt(elem.maxValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirDateTime) then
  begin
    ComposeDateTimeValue(json, 'maxValueDateTime', TFhirDateTime(elem.maxValue), false);
    ComposeDateTimeProps(json, 'maxValueDateTime', TFhirDateTime(elem.maxValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirDate) then
  begin
    ComposeDateValue(json, 'maxValueDate', TFhirDate(elem.maxValue), false);
    ComposeDateProps(json, 'maxValueDate', TFhirDate(elem.maxValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirString) then
  begin
    ComposeStringValue(json, 'maxValueString', TFhirString(elem.maxValue), false);
    ComposeStringProps(json, 'maxValueString', TFhirString(elem.maxValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirInteger) then
  begin
    ComposeIntegerValue(json, 'maxValueInteger', TFhirInteger(elem.maxValue), false);
    ComposeIntegerProps(json, 'maxValueInteger', TFhirInteger(elem.maxValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirUri) then
  begin
    ComposeUriValue(json, 'maxValueUri', TFhirUri(elem.maxValue), false);
    ComposeUriProps(json, 'maxValueUri', TFhirUri(elem.maxValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirInstant) then
  begin
    ComposeInstantValue(json, 'maxValueInstant', TFhirInstant(elem.maxValue), false);
    ComposeInstantProps(json, 'maxValueInstant', TFhirInstant(elem.maxValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirBoolean) then
  begin
    ComposeBooleanValue(json, 'maxValueBoolean', TFhirBoolean(elem.maxValue), false);
    ComposeBooleanProps(json, 'maxValueBoolean', TFhirBoolean(elem.maxValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirBase64Binary) then
  begin
    ComposeBase64BinaryValue(json, 'maxValueBase64Binary', TFhirBase64Binary(elem.maxValue), false);
    ComposeBase64BinaryProps(json, 'maxValueBase64Binary', TFhirBase64Binary(elem.maxValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirTime) then
  begin
    ComposeTimeValue(json, 'maxValueTime', TFhirTime(elem.maxValue), false);
    ComposeTimeProps(json, 'maxValueTime', TFhirTime(elem.maxValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirDecimal) then
  begin
    ComposeDecimalValue(json, 'maxValueDecimal', TFhirDecimal(elem.maxValue), false);
    ComposeDecimalProps(json, 'maxValueDecimal', TFhirDecimal(elem.maxValue), false)
  end
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirIdentifier) then
    ComposeIdentifier(json, 'maxValueIdentifier', TFhirIdentifier(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirCoding) then
    ComposeCoding(json, 'maxValueCoding', TFhirCoding(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirReference) then
    ComposeReference(json, 'maxValueReference', TFhirReference(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirSignature) then
    ComposeSignature(json, 'maxValueSignature', TFhirSignature(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirSampledData) then
    ComposeSampledData(json, 'maxValueSampledData', TFhirSampledData(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirPeriod) then
    ComposePeriod(json, 'maxValuePeriod', TFhirPeriod(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirQuantity) then
    ComposeQuantity(json, 'maxValueQuantity', TFhirQuantity(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirAttachment) then
    ComposeAttachment(json, 'maxValueAttachment', TFhirAttachment(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirRatio) then
    ComposeRatio(json, 'maxValueRatio', TFhirRatio(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirRange) then
    ComposeRange(json, 'maxValueRange', TFhirRange(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirAnnotation) then
    ComposeAnnotation(json, 'maxValueAnnotation', TFhirAnnotation(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirCodeableConcept) then
    ComposeCodeableConcept(json, 'maxValueCodeableConcept', TFhirCodeableConcept(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirHumanName) then
    ComposeHumanName(json, 'maxValueHumanName', TFhirHumanName(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirMeta) then
    ComposeMeta(json, 'maxValueMeta', TFhirMeta(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirContactPoint) then
    ComposeContactPoint(json, 'maxValueContactPoint', TFhirContactPoint(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirAddress) then
    ComposeAddress(json, 'maxValueAddress', TFhirAddress(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirElementDefinition) then
    ComposeElementDefinition(json, 'maxValueElementDefinition', TFhirElementDefinition(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirTiming) then
    ComposeTiming(json, 'maxValueTiming', TFhirTiming(elem.maxValue));
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIntegerValue(json, 'maxLength', elem.maxLengthElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeIntegerProps(json, 'maxLength', elem.maxLengthElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.conditionList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.conditionList.Count - 1 do
    begin
      ext := ext or ((elem.conditionList[i].id <> '') or (elem.conditionList[i].hasExtensionList) {no-comments or (elem.conditionList[i].hasComments)});
      val := val or (elem.conditionList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      startArray(json, 'condition', elem.conditionList, true);
      for i := 0 to elem.conditionList.Count - 1 do
        ComposeIdValue(json, '',elem.conditionList[i], true);
      finishArray(json, elem.conditionList);
    end;
    if ext then
    begin
      startArray(json, '_condition', elem.conditionList, false);
      for i := 0 to elem.conditionList.Count - 1 do
        ComposeIdProps(json, '',elem.conditionList[i], true);
      finishArray(json, elem.conditionList);
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.constraintList.Count > 0) then
  begin
    startArray(json, 'constraint', elem.constraintList, false);
    for i := 0 to elem.constraintList.Count - 1 do
      ComposeElementDefinitionConstraint(json, '', elem.constraintList[i]); {z - }
    finishArray(json, elem.constraintList);
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (not isCanonical or (elem.mustSupport <> false)) then
    ComposeBooleanValue(json, 'mustSupport', elem.mustSupportElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (not isCanonical or (elem.mustSupport <> false)) then
    ComposeBooleanProps(json, 'mustSupport', elem.mustSupportElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (not isCanonical or (elem.isModifier <> false)) then
    ComposeBooleanValue(json, 'isModifier', elem.isModifierElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (not isCanonical or (elem.isModifier <> false)) then
    ComposeBooleanProps(json, 'isModifier', elem.isModifierElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (not isCanonical or (elem.isSummary <> false)) then
    ComposeBooleanValue(json, 'isSummary', elem.isSummaryElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (not isCanonical or (elem.isSummary <> false)) then
    ComposeBooleanProps(json, 'isSummary', elem.isSummaryElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeElementDefinitionBinding(json, 'binding', elem.binding); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.mappingList.Count > 0) then
  begin
    startArray(json, 'mapping', elem.mappingList, false);
    for i := 0 to elem.mappingList.Count - 1 do
      ComposeElementDefinitionMapping(json, '', elem.mappingList[i]); {z - }
    finishArray(json, elem.mappingList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseTimingRepeat(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTimingRepeat(jsn)); {2}
end;

function TFHIRJsonParser.ParseTimingRepeat(jsn : TJsonObject) : TFhirTimingRepeat;
begin
  result := TFhirTimingRepeat.create;
  try
    ParseTimingRepeatProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTimingRepeatProperties(jsn : TJsonObject; result : TFhirTimingRepeat);
begin
    ParseElementProperties(jsn, result);
    if jsn.has('boundsQuantity') {a4} then
      result.bounds := ParseQuantity(jsn.vObj['boundsQuantity']);
    if jsn.has('boundsRange') {a4} then
      result.bounds := ParseRange(jsn.vObj['boundsRange']);
    if jsn.has('boundsPeriod') {a4} then
      result.bounds := ParsePeriod(jsn.vObj['boundsPeriod']);
    if jsn.has('count') or jsn.has('_count') then
        result.countElement := ParseInteger(jsn.node['count'], jsn.vObj['_count']);{q}
    if jsn.has('duration') or jsn.has('_duration') then
        result.durationElement := ParseDecimal(jsn.node['duration'], jsn.vObj['_duration']);{q}
    if jsn.has('durationMax') or jsn.has('_durationMax') then
        result.durationMaxElement := ParseDecimal(jsn.node['durationMax'], jsn.vObj['_durationMax']);{q}
    if jsn.has('durationUnits') or jsn.has('_durationUnits')  then
      result.durationUnitsElement := parseEnum(jsn.path+'/durationUnits', jsn.node['durationUnits'], jsn.vObj['_durationUnits'], CODES_TFhirUnitsOfTimeEnum, SYSTEMS_TFhirUnitsOfTimeEnum);
    if jsn.has('frequency') or jsn.has('_frequency') then
        result.frequencyElement := ParseInteger(jsn.node['frequency'], jsn.vObj['_frequency']);{q}
    if jsn.has('frequencyMax') or jsn.has('_frequencyMax') then
        result.frequencyMaxElement := ParseInteger(jsn.node['frequencyMax'], jsn.vObj['_frequencyMax']);{q}
    if jsn.has('period') or jsn.has('_period') then
        result.periodElement := ParseDecimal(jsn.node['period'], jsn.vObj['_period']);{q}
    if jsn.has('periodMax') or jsn.has('_periodMax') then
        result.periodMaxElement := ParseDecimal(jsn.node['periodMax'], jsn.vObj['_periodMax']);{q}
    if jsn.has('periodUnits') or jsn.has('_periodUnits')  then
      result.periodUnitsElement := parseEnum(jsn.path+'/periodUnits', jsn.node['periodUnits'], jsn.vObj['_periodUnits'], CODES_TFhirUnitsOfTimeEnum, SYSTEMS_TFhirUnitsOfTimeEnum);
    if jsn.has('when') or jsn.has('_when')  then
      result.whenElement := parseEnum(jsn.path+'/when', jsn.node['when'], jsn.vObj['_when'], CODES_TFhirEventTimingEnum, SYSTEMS_TFhirEventTimingEnum);
end;

procedure TFHIRJsonComposer.ComposeTimingRepeat(json : TJSONWriter; name : string; elem : TFhirTimingRepeat; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.bounds is TFhirQuantity) then 
    ComposeQuantity(json, 'boundsQuantity', TFhirQuantity(elem.bounds)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.bounds is TFhirRange) then 
    ComposeRange(json, 'boundsRange', TFhirRange(elem.bounds)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.bounds is TFhirPeriod) then 
    ComposePeriod(json, 'boundsPeriod', TFhirPeriod(elem.bounds)) ;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerValue(json, 'count', elem.countElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerProps(json, 'count', elem.countElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'duration', elem.durationElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'duration', elem.durationElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'durationMax', elem.durationMaxElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'durationMax', elem.durationMaxElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumValue(json, 'durationUnits', elem.DurationUnitsElement, CODES_TFhirUnitsOfTimeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumProps(json, 'durationUnits', elem.DurationUnitsElement, CODES_TFhirUnitsOfTimeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.frequency <> '1')) then
    ComposeIntegerValue(json, 'frequency', elem.frequencyElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.frequency <> '1')) then
    ComposeIntegerProps(json, 'frequency', elem.frequencyElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerValue(json, 'frequencyMax', elem.frequencyMaxElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerProps(json, 'frequencyMax', elem.frequencyMaxElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'period', elem.periodElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'period', elem.periodElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'periodMax', elem.periodMaxElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'periodMax', elem.periodMaxElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumValue(json, 'periodUnits', elem.PeriodUnitsElement, CODES_TFhirUnitsOfTimeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumProps(json, 'periodUnits', elem.PeriodUnitsElement, CODES_TFhirUnitsOfTimeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumValue(json, 'when', elem.WhenElement, CODES_TFhirEventTimingEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumProps(json, 'when', elem.WhenElement, CODES_TFhirEventTimingEnum, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseTiming(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTiming(jsn)); {2}
end;

function TFHIRJsonParser.ParseTiming(jsn : TJsonObject) : TFhirTiming;
begin
  result := TFhirTiming.create;
  try
    ParseTimingProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTimingProperties(jsn : TJsonObject; result : TFhirTiming);
begin
    parseElementProperties(jsn, result);
      if jsn.has('event') or jsn.has('_event') then
      iteratePrimitiveArray(jsn.vArr['event'], jsn.vArr['_event'], result.eventList, parseDateTime);
    if jsn.has('repeat') then
        result.repeat_ := ParseTimingRepeat(jsn.vObj['repeat']);{q3}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
end;

procedure TFHIRJsonComposer.ComposeTiming(json : TJSONWriter; name : string; elem : TFhirTiming; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  composeElement(json, '', elem, true);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.eventList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.eventList.Count - 1 do
    begin
      ext := ext or ((elem.eventList[i].id <> '') or (elem.eventList[i].hasExtensionList) {no-comments or (elem.eventList[i].hasComments)});
      val := val or (elem.eventList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      startArray(json, 'event', elem.eventList, true);
      for i := 0 to elem.eventList.Count - 1 do
        ComposeDateTimeValue(json, '',elem.eventList[i], true);
      finishArray(json, elem.eventList);
    end;
    if ext then
    begin
      startArray(json, '_event', elem.eventList, false);
      for i := 0 to elem.eventList.Count - 1 do
        ComposeDateTimeProps(json, '',elem.eventList[i], true);
      finishArray(json, elem.eventList);
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeTimingRepeat(json, 'repeat', elem.repeat_); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  finishElement(json, name, elem, noObj);
end;

{$IFDEF FHIR_ACCOUNT}
procedure TFHIRJsonParser.ParseAccount(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAccount(jsn)); {2}
end;

function TFHIRJsonParser.ParseAccount(jsn : TJsonObject) : TFhirAccount;
begin
  result := TFhirAccount.create;
  try
    ParseAccountProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseAccountProperties(jsn : TJsonObject; result : TFhirAccount);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('status') or jsn.has('_status') then
        result.statusElement := ParseCode(jsn.node['status'], jsn.vObj['_status']);{q}
    if jsn.has('activePeriod') then
        result.activePeriod := ParsePeriod(jsn.vObj['activePeriod']);{q3}
    if jsn.has('currency') then
        result.currency := ParseCoding(jsn.vObj['currency']);{q3}
    if jsn.has('balance') then
        result.balance := ParseQuantity(jsn.vObj['balance']);{q3}
    if jsn.has('coveragePeriod') then
        result.coveragePeriod := ParsePeriod(jsn.vObj['coveragePeriod']);{q3}
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q3}
    if jsn.has('owner') then
        result.owner := ParseReference{TFhirOrganization}(jsn.vObj['owner']);{q3}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn.node['description'], jsn.vObj['_description']);{q}
end;

procedure TFHIRJsonComposer.ComposeAccount(json : TJSONWriter; name : string; elem : TFhirAccount; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeCodeValue(json, 'status', elem.statusElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeCodeProps(json, 'status', elem.statusElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('activePeriod') then
    ComposePeriod(json, 'activePeriod', elem.activePeriod); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('currency') then
    ComposeCoding(json, 'currency', elem.currency); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('balance') then
    ComposeQuantity(json, 'balance', elem.balance); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('coveragePeriod') then
    ComposePeriod(json, 'coveragePeriod', elem.coveragePeriod); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('owner') then
    ComposeReference{TFhirOrganization}(json, 'owner', elem.owner); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
end;

{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
procedure TFHIRJsonParser.ParseAllergyIntoleranceReaction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAllergyIntoleranceReaction(jsn)); {2}
end;

function TFHIRJsonParser.ParseAllergyIntoleranceReaction(jsn : TJsonObject) : TFhirAllergyIntoleranceReaction;
begin
  result := TFhirAllergyIntoleranceReaction.create;
  try
    ParseAllergyIntoleranceReactionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseAllergyIntoleranceReactionProperties(jsn : TJsonObject; result : TFhirAllergyIntoleranceReaction);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('substance') then
        result.substance := ParseCodeableConcept(jsn.vObj['substance']);{q3}
    if jsn.has('certainty') or jsn.has('_certainty')  then
      result.certaintyElement := parseEnum(jsn.path+'/certainty', jsn.node['certainty'], jsn.vObj['_certainty'], CODES_TFhirReactionEventCertaintyEnum, SYSTEMS_TFhirReactionEventCertaintyEnum);
    if jsn.has('manifestation') then
      iterateArray(jsn.vArr['manifestation'], result.manifestationList, parseCodeableConcept);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('onset') or jsn.has('_onset') then
        result.onsetElement := ParseDateTime(jsn.node['onset'], jsn.vObj['_onset']);{q}
    if jsn.has('severity') or jsn.has('_severity')  then
      result.severityElement := parseEnum(jsn.path+'/severity', jsn.node['severity'], jsn.vObj['_severity'], CODES_TFhirReactionEventSeverityEnum, SYSTEMS_TFhirReactionEventSeverityEnum);
    if jsn.has('exposureRoute') then
        result.exposureRoute := ParseCodeableConcept(jsn.vObj['exposureRoute']);{q3}
    if jsn.has('note') then
        result.note := ParseAnnotation(jsn.vObj['note']);{q3}
end;

procedure TFHIRJsonComposer.ComposeAllergyIntoleranceReaction(json : TJSONWriter; name : string; elem : TFhirAllergyIntoleranceReaction; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'substance', elem.substance); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumValue(json, 'certainty', elem.CertaintyElement, CODES_TFhirReactionEventCertaintyEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumProps(json, 'certainty', elem.CertaintyElement, CODES_TFhirReactionEventCertaintyEnum, false);
  if (elem.manifestationList.Count > 0) then
  begin
    startArray(json, 'manifestation', elem.manifestationList, false);
    for i := 0 to elem.manifestationList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.manifestationList[i]); {z - CodeableConcept}
    finishArray(json, elem.manifestationList);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'onset', elem.onsetElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'onset', elem.onsetElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumValue(json, 'severity', elem.SeverityElement, CODES_TFhirReactionEventSeverityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumProps(json, 'severity', elem.SeverityElement, CODES_TFhirReactionEventSeverityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'exposureRoute', elem.exposureRoute); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeAnnotation(json, 'note', elem.note); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseAllergyIntolerance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAllergyIntolerance(jsn)); {2}
end;

function TFHIRJsonParser.ParseAllergyIntolerance(jsn : TJsonObject) : TFhirAllergyIntolerance;
begin
  result := TFhirAllergyIntolerance.create;
  try
    ParseAllergyIntoleranceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseAllergyIntoleranceProperties(jsn : TJsonObject; result : TFhirAllergyIntolerance);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('onset') or jsn.has('_onset') then
        result.onsetElement := ParseDateTime(jsn.node['onset'], jsn.vObj['_onset']);{q}
    if jsn.has('recordedDate') or jsn.has('_recordedDate') then
        result.recordedDateElement := ParseDateTime(jsn.node['recordedDate'], jsn.vObj['_recordedDate']);{q}
    if jsn.has('recorder') then
        result.recorder := ParseReference{Resource}(jsn.vObj['recorder']);{q3}
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
    if jsn.has('reporter') then
        result.reporter := ParseReference{Resource}(jsn.vObj['reporter']);{q3}
    if jsn.has('substance') then
        result.substance := ParseCodeableConcept(jsn.vObj['substance']);{q3}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirAllergyIntoleranceStatusEnum, SYSTEMS_TFhirAllergyIntoleranceStatusEnum);
    if jsn.has('criticality') or jsn.has('_criticality')  then
      result.criticalityElement := parseEnum(jsn.path+'/criticality', jsn.node['criticality'], jsn.vObj['_criticality'], CODES_TFhirAllergyIntoleranceCriticalityEnum, SYSTEMS_TFhirAllergyIntoleranceCriticalityEnum);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirAllergyIntoleranceTypeEnum, SYSTEMS_TFhirAllergyIntoleranceTypeEnum);
    if jsn.has('category') or jsn.has('_category')  then
      result.categoryElement := parseEnum(jsn.path+'/category', jsn.node['category'], jsn.vObj['_category'], CODES_TFhirAllergyIntoleranceCategoryEnum, SYSTEMS_TFhirAllergyIntoleranceCategoryEnum);
    if jsn.has('lastOccurence') or jsn.has('_lastOccurence') then
        result.lastOccurenceElement := ParseDateTime(jsn.node['lastOccurence'], jsn.vObj['_lastOccurence']);{q}
    if jsn.has('note') then
        result.note := ParseAnnotation(jsn.vObj['note']);{q3}
    if jsn.has('reaction') then
      iterateArray(jsn.vArr['reaction'], result.reactionList, parseAllergyIntoleranceReaction);
end;

procedure TFHIRJsonComposer.ComposeAllergyIntolerance(json : TJSONWriter; name : string; elem : TFhirAllergyIntolerance; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('onset') then
    ComposeDateTimeValue(json, 'onset', elem.onsetElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('onset') then
    ComposeDateTimeProps(json, 'onset', elem.onsetElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recordedDate') then
    ComposeDateTimeValue(json, 'recordedDate', elem.recordedDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recordedDate') then
    ComposeDateTimeProps(json, 'recordedDate', elem.recordedDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recorder') then
    ComposeReference{Resource}(json, 'recorder', elem.recorder); {a}
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reporter') then
    ComposeReference{Resource}(json, 'reporter', elem.reporter); {a}
  ComposeCodeableConcept(json, 'substance', elem.substance); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirAllergyIntoleranceStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirAllergyIntoleranceStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('criticality') then
    ComposeEnumValue(json, 'criticality', elem.CriticalityElement, CODES_TFhirAllergyIntoleranceCriticalityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('criticality') then
    ComposeEnumProps(json, 'criticality', elem.CriticalityElement, CODES_TFhirAllergyIntoleranceCriticalityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirAllergyIntoleranceTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirAllergyIntoleranceTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeEnumValue(json, 'category', elem.CategoryElement, CODES_TFhirAllergyIntoleranceCategoryEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeEnumProps(json, 'category', elem.CategoryElement, CODES_TFhirAllergyIntoleranceCategoryEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('lastOccurence') then
    ComposeDateTimeValue(json, 'lastOccurence', elem.lastOccurenceElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('lastOccurence') then
    ComposeDateTimeProps(json, 'lastOccurence', elem.lastOccurenceElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    ComposeAnnotation(json, 'note', elem.note); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('reaction') and (elem.reactionList.Count > 0) then
  begin
    startArray(json, 'reaction', elem.reactionList, false);
    for i := 0 to elem.reactionList.Count - 1 do
      ComposeAllergyIntoleranceReaction(json, '', elem.reactionList[i]); {z - }
    finishArray(json, elem.reactionList);
  end;
end;

{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
procedure TFHIRJsonParser.ParseAppointmentParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAppointmentParticipant(jsn)); {2}
end;

function TFHIRJsonParser.ParseAppointmentParticipant(jsn : TJsonObject) : TFhirAppointmentParticipant;
begin
  result := TFhirAppointmentParticipant.create;
  try
    ParseAppointmentParticipantProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseAppointmentParticipantProperties(jsn : TJsonObject; result : TFhirAppointmentParticipant);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCodeableConcept);
    if jsn.has('actor') then
        result.actor := ParseReference{Resource}(jsn.vObj['actor']);{q3}
    if jsn.has('required') or jsn.has('_required')  then
      result.requiredElement := parseEnum(jsn.path+'/required', jsn.node['required'], jsn.vObj['_required'], CODES_TFhirParticipantrequiredEnum, SYSTEMS_TFhirParticipantrequiredEnum);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirParticipationstatusEnum, SYSTEMS_TFhirParticipationstatusEnum);
end;

procedure TFHIRJsonComposer.ComposeAppointmentParticipant(json : TJSONWriter; name : string; elem : TFhirAppointmentParticipant; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.type_List.Count > 0) then
  begin
    startArray(json, 'type', elem.type_List, false);
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(json, '', elem.type_List[i]); {z - CodeableConcept}
    finishArray(json, elem.type_List);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'actor', elem.actor); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumValue(json, 'required', elem.RequiredElement, CODES_TFhirParticipantrequiredEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumProps(json, 'required', elem.RequiredElement, CODES_TFhirParticipantrequiredEnum, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirParticipationstatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirParticipationstatusEnum, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseAppointment(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAppointment(jsn)); {2}
end;

function TFHIRJsonParser.ParseAppointment(jsn : TJsonObject) : TFhirAppointment;
begin
  result := TFhirAppointment.create;
  try
    ParseAppointmentProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseAppointmentProperties(jsn : TJsonObject; result : TFhirAppointment);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirAppointmentstatusEnum, SYSTEMS_TFhirAppointmentstatusEnum);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('reason') then
        result.reason := ParseCodeableConcept(jsn.vObj['reason']);{q3}
    if jsn.has('priority') or jsn.has('_priority') then
        result.priorityElement := ParseUnsignedInt(jsn.node['priority'], jsn.vObj['_priority']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('start') or jsn.has('_start') then
        result.startElement := ParseInstant(jsn.node['start'], jsn.vObj['_start']);{q}
    if jsn.has('end') or jsn.has('_end') then
        result.end_Element := ParseInstant(jsn.node['end'], jsn.vObj['_end']);{q}
    if jsn.has('minutesDuration') or jsn.has('_minutesDuration') then
        result.minutesDurationElement := ParsePositiveInt(jsn.node['minutesDuration'], jsn.vObj['_minutesDuration']);{q}
    if jsn.has('slot') then
      iterateArray(jsn.vArr['slot'], result.slotList, parseReference{TFhirSlot});
    if jsn.has('comment') or jsn.has('_comment') then
        result.commentElement := ParseString(jsn.node['comment'], jsn.vObj['_comment']);{q}
    if jsn.has('participant') then
      iterateArray(jsn.vArr['participant'], result.participantList, parseAppointmentParticipant);
end;

procedure TFHIRJsonComposer.ComposeAppointment(json : TJSONWriter; name : string; elem : TFhirAppointment; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirAppointmentstatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirAppointmentstatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reason') then
    ComposeCodeableConcept(json, 'reason', elem.reason); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('priority') then
    ComposeUnsignedIntValue(json, 'priority', elem.priorityElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('priority') then
    ComposeUnsignedIntProps(json, 'priority', elem.priorityElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('start') then
    ComposeInstantValue(json, 'start', elem.startElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('start') then
    ComposeInstantProps(json, 'start', elem.startElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('end_') then
    ComposeInstantValue(json, 'end', elem.end_Element, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('end_') then
    ComposeInstantProps(json, 'end', elem.end_Element, false);
  if (SummaryOption in [soFull, soData]) and doCompose('minutesDuration') then
    ComposePositiveIntValue(json, 'minutesDuration', elem.minutesDurationElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('minutesDuration') then
    ComposePositiveIntProps(json, 'minutesDuration', elem.minutesDurationElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('slot') and (elem.slotList.Count > 0) then
  begin
    startArray(json, 'slot', elem.slotList, false);
    for i := 0 to elem.slotList.Count - 1 do
      ComposeReference{TFhirSlot}(json, '', elem.slotList[i]); {z - Reference(Slot)}
    finishArray(json, elem.slotList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeStringValue(json, 'comment', elem.commentElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeStringProps(json, 'comment', elem.commentElement, false);
  if (elem.participantList.Count > 0) then
  begin
    startArray(json, 'participant', elem.participantList, false);
    for i := 0 to elem.participantList.Count - 1 do
      ComposeAppointmentParticipant(json, '', elem.participantList[i]); {z - }
    finishArray(json, elem.participantList);
  end;
end;

{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
procedure TFHIRJsonParser.ParseAppointmentResponse(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAppointmentResponse(jsn)); {2}
end;

function TFHIRJsonParser.ParseAppointmentResponse(jsn : TJsonObject) : TFhirAppointmentResponse;
begin
  result := TFhirAppointmentResponse.create;
  try
    ParseAppointmentResponseProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseAppointmentResponseProperties(jsn : TJsonObject; result : TFhirAppointmentResponse);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('appointment') then
        result.appointment := ParseReference{TFhirAppointment}(jsn.vObj['appointment']);{q3}
    if jsn.has('start') or jsn.has('_start') then
        result.startElement := ParseInstant(jsn.node['start'], jsn.vObj['_start']);{q}
    if jsn.has('end') or jsn.has('_end') then
        result.end_Element := ParseInstant(jsn.node['end'], jsn.vObj['_end']);{q}
    if jsn.has('participantType') then
      iterateArray(jsn.vArr['participantType'], result.participantTypeList, parseCodeableConcept);
    if jsn.has('actor') then
        result.actor := ParseReference{Resource}(jsn.vObj['actor']);{q3}
    if jsn.has('participantStatus') or jsn.has('_participantStatus')  then
      result.participantStatusElement := parseEnum(jsn.path+'/participantStatus', jsn.node['participantStatus'], jsn.vObj['_participantStatus'], CODES_TFhirParticipantstatusEnum, SYSTEMS_TFhirParticipantstatusEnum);
    if jsn.has('comment') or jsn.has('_comment') then
        result.commentElement := ParseString(jsn.node['comment'], jsn.vObj['_comment']);{q}
end;

procedure TFHIRJsonComposer.ComposeAppointmentResponse(json : TJSONWriter; name : string; elem : TFhirAppointmentResponse; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  ComposeReference{TFhirAppointment}(json, 'appointment', elem.appointment); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('start') then
    ComposeInstantValue(json, 'start', elem.startElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('start') then
    ComposeInstantProps(json, 'start', elem.startElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('end_') then
    ComposeInstantValue(json, 'end', elem.end_Element, false);
  if (SummaryOption in [soFull, soData]) and doCompose('end_') then
    ComposeInstantProps(json, 'end', elem.end_Element, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('participantType') and (elem.participantTypeList.Count > 0) then
  begin
    startArray(json, 'participantType', elem.participantTypeList, false);
    for i := 0 to elem.participantTypeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.participantTypeList[i]); {z - CodeableConcept}
    finishArray(json, elem.participantTypeList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('actor') then
    ComposeReference{Resource}(json, 'actor', elem.actor); {a}
  ComposeEnumValue(json, 'participantStatus', elem.ParticipantStatusElement, CODES_TFhirParticipantstatusEnum, false);
  ComposeEnumProps(json, 'participantStatus', elem.ParticipantStatusElement, CODES_TFhirParticipantstatusEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeStringValue(json, 'comment', elem.commentElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeStringProps(json, 'comment', elem.commentElement, false);
end;

{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
procedure TFHIRJsonParser.ParseAuditEventEvent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAuditEventEvent(jsn)); {2}
end;

function TFHIRJsonParser.ParseAuditEventEvent(jsn : TJsonObject) : TFhirAuditEventEvent;
begin
  result := TFhirAuditEventEvent.create;
  try
    ParseAuditEventEventProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseAuditEventEventProperties(jsn : TJsonObject; result : TFhirAuditEventEvent);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q3}
    if jsn.has('subtype') then
      iterateArray(jsn.vArr['subtype'], result.subtypeList, parseCoding);
    if jsn.has('action') or jsn.has('_action')  then
      result.actionElement := parseEnum(jsn.path+'/action', jsn.node['action'], jsn.vObj['_action'], CODES_TFhirAuditEventActionEnum, SYSTEMS_TFhirAuditEventActionEnum);
    if jsn.has('dateTime') or jsn.has('_dateTime') then
        result.dateTimeElement := ParseInstant(jsn.node['dateTime'], jsn.vObj['_dateTime']);{q}
    if jsn.has('outcome') or jsn.has('_outcome')  then
      result.outcomeElement := parseEnum(jsn.path+'/outcome', jsn.node['outcome'], jsn.vObj['_outcome'], CODES_TFhirAuditEventOutcomeEnum, SYSTEMS_TFhirAuditEventOutcomeEnum);
    if jsn.has('outcomeDesc') or jsn.has('_outcomeDesc') then
        result.outcomeDescElement := ParseString(jsn.node['outcomeDesc'], jsn.vObj['_outcomeDesc']);{q}
    if jsn.has('purposeOfEvent') then
      iterateArray(jsn.vArr['purposeOfEvent'], result.purposeOfEventList, parseCoding);
end;

procedure TFHIRJsonComposer.ComposeAuditEventEvent(json : TJSONWriter; name : string; elem : TFhirAuditEventEvent; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeCoding(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.subtypeList.Count > 0) then
  begin
    startArray(json, 'subtype', elem.subtypeList, false);
    for i := 0 to elem.subtypeList.Count - 1 do
      ComposeCoding(json, '', elem.subtypeList[i]); {z - Coding}
    finishArray(json, elem.subtypeList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumValue(json, 'action', elem.ActionElement, CODES_TFhirAuditEventActionEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumProps(json, 'action', elem.ActionElement, CODES_TFhirAuditEventActionEnum, false);
  ComposeInstantValue(json, 'dateTime', elem.dateTimeElement, false);
  ComposeInstantProps(json, 'dateTime', elem.dateTimeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumValue(json, 'outcome', elem.OutcomeElement, CODES_TFhirAuditEventOutcomeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumProps(json, 'outcome', elem.OutcomeElement, CODES_TFhirAuditEventOutcomeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'outcomeDesc', elem.outcomeDescElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'outcomeDesc', elem.outcomeDescElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.purposeOfEventList.Count > 0) then
  begin
    startArray(json, 'purposeOfEvent', elem.purposeOfEventList, false);
    for i := 0 to elem.purposeOfEventList.Count - 1 do
      ComposeCoding(json, '', elem.purposeOfEventList[i]); {z - Coding}
    finishArray(json, elem.purposeOfEventList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseAuditEventParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAuditEventParticipant(jsn)); {2}
end;

function TFHIRJsonParser.ParseAuditEventParticipant(jsn : TJsonObject) : TFhirAuditEventParticipant;
begin
  result := TFhirAuditEventParticipant.create;
  try
    ParseAuditEventParticipantProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseAuditEventParticipantProperties(jsn : TJsonObject; result : TFhirAuditEventParticipant);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('role') then
      iterateArray(jsn.vArr['role'], result.roleList, parseCodeableConcept);
    if jsn.has('reference') then
        result.reference := ParseReference{Resource}(jsn.vObj['reference']);{q3}
    if jsn.has('userId') then
        result.userId := ParseIdentifier(jsn.vObj['userId']);{q3}
    if jsn.has('altId') or jsn.has('_altId') then
        result.altIdElement := ParseString(jsn.node['altId'], jsn.vObj['_altId']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('requestor') or jsn.has('_requestor') then
        result.requestorElement := ParseBoolean(jsn.node['requestor'], jsn.vObj['_requestor']);{q}
    if jsn.has('location') then
        result.location := ParseReference{TFhirLocation}(jsn.vObj['location']);{q3}
      if jsn.has('policy') or jsn.has('_policy') then
      iteratePrimitiveArray(jsn.vArr['policy'], jsn.vArr['_policy'], result.policyList, parseUri);
    if jsn.has('media') then
        result.media := ParseCoding(jsn.vObj['media']);{q3}
    if jsn.has('network') then
        result.network := ParseAuditEventParticipantNetwork(jsn.vObj['network']);{q3}
    if jsn.has('purposeOfUse') then
      iterateArray(jsn.vArr['purposeOfUse'], result.purposeOfUseList, parseCoding);
end;

procedure TFHIRJsonComposer.ComposeAuditEventParticipant(json : TJSONWriter; name : string; elem : TFhirAuditEventParticipant; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.roleList.Count > 0) then
  begin
    startArray(json, 'role', elem.roleList, false);
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.roleList[i]); {z - CodeableConcept}
    finishArray(json, elem.roleList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'reference', elem.reference); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'userId', elem.userId); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'altId', elem.altIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'altId', elem.altIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  ComposeBooleanValue(json, 'requestor', elem.requestorElement, false);
  ComposeBooleanProps(json, 'requestor', elem.requestorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(json, 'location', elem.location); {a}
  if (SummaryOption in [soFull, soData]) and (elem.policyList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.policyList.Count - 1 do
    begin
      ext := ext or ((elem.policyList[i].id <> '') or (elem.policyList[i].hasExtensionList) {no-comments or (elem.policyList[i].hasComments)});
      val := val or (elem.policyList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      startArray(json, 'policy', elem.policyList, true);
      for i := 0 to elem.policyList.Count - 1 do
        ComposeUriValue(json, '',elem.policyList[i], true);
      finishArray(json, elem.policyList);
    end;
    if ext then
    begin
      startArray(json, '_policy', elem.policyList, false);
      for i := 0 to elem.policyList.Count - 1 do
        ComposeUriProps(json, '',elem.policyList[i], true);
      finishArray(json, elem.policyList);
    end;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(json, 'media', elem.media); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeAuditEventParticipantNetwork(json, 'network', elem.network); {a}
  if (SummaryOption in [soFull, soData]) and (elem.purposeOfUseList.Count > 0) then
  begin
    startArray(json, 'purposeOfUse', elem.purposeOfUseList, false);
    for i := 0 to elem.purposeOfUseList.Count - 1 do
      ComposeCoding(json, '', elem.purposeOfUseList[i]); {z - Coding}
    finishArray(json, elem.purposeOfUseList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseAuditEventParticipantNetwork(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAuditEventParticipantNetwork(jsn)); {2}
end;

function TFHIRJsonParser.ParseAuditEventParticipantNetwork(jsn : TJsonObject) : TFhirAuditEventParticipantNetwork;
begin
  result := TFhirAuditEventParticipantNetwork.create;
  try
    ParseAuditEventParticipantNetworkProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseAuditEventParticipantNetworkProperties(jsn : TJsonObject; result : TFhirAuditEventParticipantNetwork);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('address') or jsn.has('_address') then
        result.addressElement := ParseString(jsn.node['address'], jsn.vObj['_address']);{q}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirNetworkTypeEnum, SYSTEMS_TFhirNetworkTypeEnum);
end;

procedure TFHIRJsonComposer.ComposeAuditEventParticipantNetwork(json : TJSONWriter; name : string; elem : TFhirAuditEventParticipantNetwork; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'address', elem.addressElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'address', elem.addressElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirNetworkTypeEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirNetworkTypeEnum, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseAuditEventSource(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAuditEventSource(jsn)); {2}
end;

function TFHIRJsonParser.ParseAuditEventSource(jsn : TJsonObject) : TFhirAuditEventSource;
begin
  result := TFhirAuditEventSource.create;
  try
    ParseAuditEventSourceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseAuditEventSourceProperties(jsn : TJsonObject; result : TFhirAuditEventSource);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('site') or jsn.has('_site') then
        result.siteElement := ParseString(jsn.node['site'], jsn.vObj['_site']);{q}
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCoding);
end;

procedure TFHIRJsonComposer.ComposeAuditEventSource(json : TJSONWriter; name : string; elem : TFhirAuditEventSource; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'site', elem.siteElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'site', elem.siteElement, false);
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soData]) and (elem.type_List.Count > 0) then
  begin
    startArray(json, 'type', elem.type_List, false);
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCoding(json, '', elem.type_List[i]); {z - Coding}
    finishArray(json, elem.type_List);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseAuditEventObject(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAuditEventObject(jsn)); {2}
end;

function TFHIRJsonParser.ParseAuditEventObject(jsn : TJsonObject) : TFhirAuditEventObject;
begin
  result := TFhirAuditEventObject.create;
  try
    ParseAuditEventObjectProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseAuditEventObjectProperties(jsn : TJsonObject; result : TFhirAuditEventObject);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('reference') then
        result.reference := ParseReference{TFhirReference}(jsn.vObj['reference']);{q3}
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q3}
    if jsn.has('role') then
        result.role := ParseCoding(jsn.vObj['role']);{q3}
    if jsn.has('lifecycle') then
        result.lifecycle := ParseCoding(jsn.vObj['lifecycle']);{q3}
    if jsn.has('securityLabel') then
      iterateArray(jsn.vArr['securityLabel'], result.securityLabelList, parseCoding);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('query') or jsn.has('_query') then
        result.queryElement := ParseBase64Binary(jsn.node['query'], jsn.vObj['_query']);{q}
    if jsn.has('detail') then
      iterateArray(jsn.vArr['detail'], result.detailList, parseAuditEventObjectDetail);
end;

procedure TFHIRJsonComposer.ComposeAuditEventObject(json : TJSONWriter; name : string; elem : TFhirAuditEventObject; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(json, 'reference', elem.reference); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(json, 'role', elem.role); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(json, 'lifecycle', elem.lifecycle); {a}
  if (SummaryOption in [soFull, soData]) and (elem.securityLabelList.Count > 0) then
  begin
    startArray(json, 'securityLabel', elem.securityLabelList, false);
    for i := 0 to elem.securityLabelList.Count - 1 do
      ComposeCoding(json, '', elem.securityLabelList[i]); {z - Coding}
    finishArray(json, elem.securityLabelList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBase64BinaryValue(json, 'query', elem.queryElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBase64BinaryProps(json, 'query', elem.queryElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.detailList.Count > 0) then
  begin
    startArray(json, 'detail', elem.detailList, false);
    for i := 0 to elem.detailList.Count - 1 do
      ComposeAuditEventObjectDetail(json, '', elem.detailList[i]); {z - }
    finishArray(json, elem.detailList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseAuditEventObjectDetail(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAuditEventObjectDetail(jsn)); {2}
end;

function TFHIRJsonParser.ParseAuditEventObjectDetail(jsn : TJsonObject) : TFhirAuditEventObjectDetail;
begin
  result := TFhirAuditEventObjectDetail.create;
  try
    ParseAuditEventObjectDetailProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseAuditEventObjectDetailProperties(jsn : TJsonObject; result : TFhirAuditEventObjectDetail);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type') then
        result.type_Element := ParseString(jsn.node['type'], jsn.vObj['_type']);{q}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := ParseBase64Binary(jsn.node['value'], jsn.vObj['_value']);{q}
end;

procedure TFHIRJsonComposer.ComposeAuditEventObjectDetail(json : TJSONWriter; name : string; elem : TFhirAuditEventObjectDetail; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'type', elem.type_Element, false);
  ComposeStringProps(json, 'type', elem.type_Element, false);
  ComposeBase64BinaryValue(json, 'value', elem.valueElement, false);
  ComposeBase64BinaryProps(json, 'value', elem.valueElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseAuditEvent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseAuditEvent(jsn)); {2}
end;

function TFHIRJsonParser.ParseAuditEvent(jsn : TJsonObject) : TFhirAuditEvent;
begin
  result := TFhirAuditEvent.create;
  try
    ParseAuditEventProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseAuditEventProperties(jsn : TJsonObject; result : TFhirAuditEvent);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('event') then
        result.event := ParseAuditEventEvent(jsn.vObj['event']);{q3}
    if jsn.has('participant') then
      iterateArray(jsn.vArr['participant'], result.participantList, parseAuditEventParticipant);
    if jsn.has('source') then
        result.source := ParseAuditEventSource(jsn.vObj['source']);{q3}
    if jsn.has('object') then
      iterateArray(jsn.vArr['object'], result.object_List, parseAuditEventObject);
end;

procedure TFHIRJsonComposer.ComposeAuditEvent(json : TJSONWriter; name : string; elem : TFhirAuditEvent; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeAuditEventEvent(json, 'event', elem.event); {a}
  if (elem.participantList.Count > 0) then
  begin
    startArray(json, 'participant', elem.participantList, false);
    for i := 0 to elem.participantList.Count - 1 do
      ComposeAuditEventParticipant(json, '', elem.participantList[i]); {z - }
    finishArray(json, elem.participantList);
  end;
  ComposeAuditEventSource(json, 'source', elem.source); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('object_') and (elem.object_List.Count > 0) then
  begin
    startArray(json, 'object', elem.object_List, false);
    for i := 0 to elem.object_List.Count - 1 do
      ComposeAuditEventObject(json, '', elem.object_List[i]); {z - }
    finishArray(json, elem.object_List);
  end;
end;

{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
procedure TFHIRJsonParser.ParseBasic(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBasic(jsn)); {2}
end;

function TFHIRJsonParser.ParseBasic(jsn : TJsonObject) : TFhirBasic;
begin
  result := TFhirBasic.create;
  try
    ParseBasicProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseBasicProperties(jsn : TJsonObject; result : TFhirBasic);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirReference}(jsn.vObj['subject']);{q3}
    if jsn.has('author') then
        result.author := ParseReference{Resource}(jsn.vObj['author']);{q3}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := ParseDate(jsn.node['created'], jsn.vObj['_created']);{q}
end;

procedure TFHIRJsonComposer.ComposeBasic(json : TJSONWriter; name : string; elem : TFhirBasic; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirReference}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{Resource}(json, 'author', elem.author); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateValue(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateProps(json, 'created', elem.createdElement, false);
end;

{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
procedure TFHIRJsonParser.ParseBinary(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBinary(jsn)); {2}
end;

function TFHIRJsonParser.ParseBinary(jsn : TJsonObject) : TFhirBinary;
begin
  result := TFhirBinary.create;
  try
    ParseBinaryProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseBinaryProperties(jsn : TJsonObject; result : TFhirBinary);
begin
    ParseResourceProperties(jsn, result);
    if jsn.has('contentType') or jsn.has('_contentType') then
        result.contentTypeElement := ParseCode(jsn.node['contentType'], jsn.vObj['_contentType']);{q}
    if jsn.has('content') or jsn.has('_content') then
        result.contentElement := ParseBase64Binary(jsn.node['content'], jsn.vObj['_content']);{q}
end;

procedure TFHIRJsonComposer.ComposeBinary(json : TJSONWriter; name : string; elem : TFhirBinary; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeCodeValue(json, 'contentType', elem.contentTypeElement, false);
  ComposeCodeProps(json, 'contentType', elem.contentTypeElement, false);
  ComposeBase64BinaryValue(json, 'content', elem.contentElement, false);
  ComposeBase64BinaryProps(json, 'content', elem.contentElement, false);
end;

{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BODYSITE}
procedure TFHIRJsonParser.ParseBodySite(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBodySite(jsn)); {2}
end;

function TFHIRJsonParser.ParseBodySite(jsn : TJsonObject) : TFhirBodySite;
begin
  result := TFhirBodySite.create;
  try
    ParseBodySiteProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseBodySiteProperties(jsn : TJsonObject; result : TFhirBodySite);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('modifier') then
      iterateArray(jsn.vArr['modifier'], result.modifierList, parseCodeableConcept);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('image') then
      iterateArray(jsn.vArr['image'], result.imageList, parseAttachment);
end;

procedure TFHIRJsonComposer.ComposeBodySite(json : TJSONWriter; name : string; elem : TFhirBodySite; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('modifier') and (elem.modifierList.Count > 0) then
  begin
    startArray(json, 'modifier', elem.modifierList, false);
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.modifierList[i]); {z - CodeableConcept}
    finishArray(json, elem.modifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('image') and (elem.imageList.Count > 0) then
  begin
    startArray(json, 'image', elem.imageList, false);
    for i := 0 to elem.imageList.Count - 1 do
      ComposeAttachment(json, '', elem.imageList[i]); {z - Attachment}
    finishArray(json, elem.imageList);
  end;
end;

{$ENDIF FHIR_BODYSITE}
{$IFDEF FHIR_BUNDLE}
procedure TFHIRJsonParser.ParseBundleLink(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBundleLink(jsn)); {2}
end;

function TFHIRJsonParser.ParseBundleLink(jsn : TJsonObject) : TFhirBundleLink;
begin
  result := TFhirBundleLink.create;
  try
    ParseBundleLinkProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseBundleLinkProperties(jsn : TJsonObject; result : TFhirBundleLink);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('relation') or jsn.has('_relation') then
        result.relationElement := ParseString(jsn.node['relation'], jsn.vObj['_relation']);{q}
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn.node['url'], jsn.vObj['_url']);{q}
end;

procedure TFHIRJsonComposer.ComposeBundleLink(json : TJSONWriter; name : string; elem : TFhirBundleLink; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'relation', elem.relationElement, false);
  ComposeStringProps(json, 'relation', elem.relationElement, false);
  ComposeUriValue(json, 'url', elem.urlElement, false);
  ComposeUriProps(json, 'url', elem.urlElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseBundleEntry(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBundleEntry(jsn)); {2}
end;

function TFHIRJsonParser.ParseBundleEntry(jsn : TJsonObject) : TFhirBundleEntry;
begin
  result := TFhirBundleEntry.create;
  try
    ParseBundleEntryProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseBundleEntryProperties(jsn : TJsonObject; result : TFhirBundleEntry);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('link') then
      iterateArray(jsn.vArr['link'], result.link_List, parseBundleLink);
    if jsn.has('fullUrl') or jsn.has('_fullUrl') then
        result.fullUrlElement := ParseUri(jsn.node['fullUrl'], jsn.vObj['_fullUrl']);{q}
    if jsn.has('resource') then
        result.resource := ParseInnerResource(jsn.vObj['resource']);{q3}
    if jsn.has('search') then
        result.search := ParseBundleEntrySearch(jsn.vObj['search']);{q3}
    if jsn.has('request') then
        result.request := ParseBundleEntryRequest(jsn.vObj['request']);{q3}
    if jsn.has('response') then
        result.response := ParseBundleEntryResponse(jsn.vObj['response']);{q3}
end;

procedure TFHIRJsonComposer.ComposeBundleEntry(json : TJSONWriter; name : string; elem : TFhirBundleEntry; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.link_List.Count > 0) then
  begin
    startArray(json, 'link', elem.link_List, false);
    for i := 0 to elem.link_List.Count - 1 do
      ComposeBundleLink(json, '', elem.link_List[i]); {z - @Bundle.link}
    finishArray(json, elem.link_List);
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriValue(json, 'fullUrl', elem.fullUrlElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriProps(json, 'fullUrl', elem.fullUrlElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInnerResource(json, 'resource', elem, elem.resource); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBundleEntrySearch(json, 'search', elem.search); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBundleEntryRequest(json, 'request', elem.request); {a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBundleEntryResponse(json, 'response', elem.response); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseBundleEntrySearch(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBundleEntrySearch(jsn)); {2}
end;

function TFHIRJsonParser.ParseBundleEntrySearch(jsn : TJsonObject) : TFhirBundleEntrySearch;
begin
  result := TFhirBundleEntrySearch.create;
  try
    ParseBundleEntrySearchProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseBundleEntrySearchProperties(jsn : TJsonObject; result : TFhirBundleEntrySearch);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('mode') or jsn.has('_mode')  then
      result.modeElement := parseEnum(jsn.path+'/mode', jsn.node['mode'], jsn.vObj['_mode'], CODES_TFhirSearchEntryModeEnum, SYSTEMS_TFhirSearchEntryModeEnum);
    if jsn.has('score') or jsn.has('_score') then
        result.scoreElement := ParseDecimal(jsn.node['score'], jsn.vObj['_score']);{q}
end;

procedure TFHIRJsonComposer.ComposeBundleEntrySearch(json : TJSONWriter; name : string; elem : TFhirBundleEntrySearch; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnumValue(json, 'mode', elem.ModeElement, CODES_TFhirSearchEntryModeEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnumProps(json, 'mode', elem.ModeElement, CODES_TFhirSearchEntryModeEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimalValue(json, 'score', elem.scoreElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimalProps(json, 'score', elem.scoreElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseBundleEntryRequest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBundleEntryRequest(jsn)); {2}
end;

function TFHIRJsonParser.ParseBundleEntryRequest(jsn : TJsonObject) : TFhirBundleEntryRequest;
begin
  result := TFhirBundleEntryRequest.create;
  try
    ParseBundleEntryRequestProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseBundleEntryRequestProperties(jsn : TJsonObject; result : TFhirBundleEntryRequest);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('method') or jsn.has('_method')  then
      result.methodElement := parseEnum(jsn.path+'/method', jsn.node['method'], jsn.vObj['_method'], CODES_TFhirHttpVerbEnum, SYSTEMS_TFhirHttpVerbEnum);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('ifNoneMatch') or jsn.has('_ifNoneMatch') then
        result.ifNoneMatchElement := ParseString(jsn.node['ifNoneMatch'], jsn.vObj['_ifNoneMatch']);{q}
    if jsn.has('ifModifiedSince') or jsn.has('_ifModifiedSince') then
        result.ifModifiedSinceElement := ParseInstant(jsn.node['ifModifiedSince'], jsn.vObj['_ifModifiedSince']);{q}
    if jsn.has('ifMatch') or jsn.has('_ifMatch') then
        result.ifMatchElement := ParseString(jsn.node['ifMatch'], jsn.vObj['_ifMatch']);{q}
    if jsn.has('ifNoneExist') or jsn.has('_ifNoneExist') then
        result.ifNoneExistElement := ParseString(jsn.node['ifNoneExist'], jsn.vObj['_ifNoneExist']);{q}
end;

procedure TFHIRJsonComposer.ComposeBundleEntryRequest(json : TJSONWriter; name : string; elem : TFhirBundleEntryRequest; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'method', elem.MethodElement, CODES_TFhirHttpVerbEnum, false);
  ComposeEnumProps(json, 'method', elem.MethodElement, CODES_TFhirHttpVerbEnum, false);
  ComposeUriValue(json, 'url', elem.urlElement, false);
  ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'ifNoneMatch', elem.ifNoneMatchElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'ifNoneMatch', elem.ifNoneMatchElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstantValue(json, 'ifModifiedSince', elem.ifModifiedSinceElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstantProps(json, 'ifModifiedSince', elem.ifModifiedSinceElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'ifMatch', elem.ifMatchElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'ifMatch', elem.ifMatchElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'ifNoneExist', elem.ifNoneExistElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'ifNoneExist', elem.ifNoneExistElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseBundleEntryResponse(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBundleEntryResponse(jsn)); {2}
end;

function TFHIRJsonParser.ParseBundleEntryResponse(jsn : TJsonObject) : TFhirBundleEntryResponse;
begin
  result := TFhirBundleEntryResponse.create;
  try
    ParseBundleEntryResponseProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseBundleEntryResponseProperties(jsn : TJsonObject; result : TFhirBundleEntryResponse);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('status') or jsn.has('_status') then
        result.statusElement := ParseString(jsn.node['status'], jsn.vObj['_status']);{q}
    if jsn.has('location') or jsn.has('_location') then
        result.locationElement := ParseUri(jsn.node['location'], jsn.vObj['_location']);{q}
    if jsn.has('etag') or jsn.has('_etag') then
        result.etagElement := ParseString(jsn.node['etag'], jsn.vObj['_etag']);{q}
    if jsn.has('lastModified') or jsn.has('_lastModified') then
        result.lastModifiedElement := ParseInstant(jsn.node['lastModified'], jsn.vObj['_lastModified']);{q}
end;

procedure TFHIRJsonComposer.ComposeBundleEntryResponse(json : TJSONWriter; name : string; elem : TFhirBundleEntryResponse; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'status', elem.statusElement, false);
  ComposeStringProps(json, 'status', elem.statusElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriValue(json, 'location', elem.locationElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUriProps(json, 'location', elem.locationElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringValue(json, 'etag', elem.etagElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeStringProps(json, 'etag', elem.etagElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstantValue(json, 'lastModified', elem.lastModifiedElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstantProps(json, 'lastModified', elem.lastModifiedElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseBundle(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseBundle(jsn)); {2}
end;

function TFHIRJsonParser.ParseBundle(jsn : TJsonObject) : TFhirBundle;
begin
  result := TFhirBundle.create;
  try
    ParseBundleProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseBundleProperties(jsn : TJsonObject; result : TFhirBundle);
begin
    ParseResourceProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirBundleTypeEnum, SYSTEMS_TFhirBundleTypeEnum);
    if jsn.has('total') or jsn.has('_total') then
        result.totalElement := ParseUnsignedInt(jsn.node['total'], jsn.vObj['_total']);{q}
    if jsn.has('link') then
      iterateArray(jsn.vArr['link'], result.link_List, parseBundleLink);
    if jsn.has('entry') then
      iterateArray(jsn.vArr['entry'], result.entryList, parseBundleEntry);
    if jsn.has('signature') then
        result.signature := ParseSignature(jsn.vObj['signature']);{q3}
end;

procedure TFHIRJsonComposer.ComposeBundle(json : TJSONWriter; name : string; elem : TFhirBundle; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeResourceProperties(json, elem);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirBundleTypeEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirBundleTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soText, soData, soCount]) then
    ComposeUnsignedIntValue(json, 'total', elem.totalElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData, soCount]) then
    ComposeUnsignedIntProps(json, 'total', elem.totalElement, false);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.link_List.Count > 0) then
  begin
    startArray(json, 'link', elem.link_List, false);
    for i := 0 to elem.link_List.Count - 1 do
      ComposeBundleLink(json, '', elem.link_List[i]); {z - }
    finishArray(json, elem.link_List);
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.entryList.Count > 0) then
  begin
    startArray(json, 'entry', elem.entryList, false);
    for i := 0 to elem.entryList.Count - 1 do
      ComposeBundleEntry(json, '', elem.entryList[i]); {z - }
    finishArray(json, elem.entryList);
  end;
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeSignature(json, 'signature', elem.signature); {a}
end;

{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAREPLAN}
procedure TFHIRJsonParser.ParseCarePlanRelatedPlan(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCarePlanRelatedPlan(jsn)); {2}
end;

function TFHIRJsonParser.ParseCarePlanRelatedPlan(jsn : TJsonObject) : TFhirCarePlanRelatedPlan;
begin
  result := TFhirCarePlanRelatedPlan.create;
  try
    ParseCarePlanRelatedPlanProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCarePlanRelatedPlanProperties(jsn : TJsonObject; result : TFhirCarePlanRelatedPlan);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code')  then
      result.codeElement := parseEnum(jsn.path+'/code', jsn.node['code'], jsn.vObj['_code'], CODES_TFhirCarePlanRelationshipEnum, SYSTEMS_TFhirCarePlanRelationshipEnum);
    if jsn.has('plan') then
        result.plan := ParseReference{TFhirCarePlan}(jsn.vObj['plan']);{q3}
end;

procedure TFHIRJsonComposer.ComposeCarePlanRelatedPlan(json : TJSONWriter; name : string; elem : TFhirCarePlanRelatedPlan; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'code', elem.CodeElement, CODES_TFhirCarePlanRelationshipEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'code', elem.CodeElement, CODES_TFhirCarePlanRelationshipEnum, false);
  ComposeReference{TFhirCarePlan}(json, 'plan', elem.plan); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseCarePlanParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCarePlanParticipant(jsn)); {2}
end;

function TFHIRJsonParser.ParseCarePlanParticipant(jsn : TJsonObject) : TFhirCarePlanParticipant;
begin
  result := TFhirCarePlanParticipant.create;
  try
    ParseCarePlanParticipantProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCarePlanParticipantProperties(jsn : TJsonObject; result : TFhirCarePlanParticipant);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('role') then
        result.role := ParseCodeableConcept(jsn.vObj['role']);{q3}
    if jsn.has('member') then
        result.member := ParseReference{Resource}(jsn.vObj['member']);{q3}
end;

procedure TFHIRJsonComposer.ComposeCarePlanParticipant(json : TJSONWriter; name : string; elem : TFhirCarePlanParticipant; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'role', elem.role); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(json, 'member', elem.member); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseCarePlanActivity(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCarePlanActivity(jsn)); {2}
end;

function TFHIRJsonParser.ParseCarePlanActivity(jsn : TJsonObject) : TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity.create;
  try
    ParseCarePlanActivityProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCarePlanActivityProperties(jsn : TJsonObject; result : TFhirCarePlanActivity);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('actionResulting') then
      iterateArray(jsn.vArr['actionResulting'], result.actionResultingList, parseReference{TFhirReference});
    if jsn.has('progress') then
      iterateArray(jsn.vArr['progress'], result.progressList, parseAnnotation);
    if jsn.has('reference') then
        result.reference := ParseReference{Resource}(jsn.vObj['reference']);{q3}
    if jsn.has('detail') then
        result.detail := ParseCarePlanActivityDetail(jsn.vObj['detail']);{q3}
end;

procedure TFHIRJsonComposer.ComposeCarePlanActivity(json : TJSONWriter; name : string; elem : TFhirCarePlanActivity; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.actionResultingList.Count > 0) then
  begin
    startArray(json, 'actionResulting', elem.actionResultingList, false);
    for i := 0 to elem.actionResultingList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.actionResultingList[i]); {z - Reference(Any)}
    finishArray(json, elem.actionResultingList);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.progressList.Count > 0) then
  begin
    startArray(json, 'progress', elem.progressList, false);
    for i := 0 to elem.progressList.Count - 1 do
      ComposeAnnotation(json, '', elem.progressList[i]); {z - Annotation}
    finishArray(json, elem.progressList);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(json, 'reference', elem.reference); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCarePlanActivityDetail(json, 'detail', elem.detail); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseCarePlanActivityDetail(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCarePlanActivityDetail(jsn)); {2}
end;

function TFHIRJsonParser.ParseCarePlanActivityDetail(jsn : TJsonObject) : TFhirCarePlanActivityDetail;
begin
  result := TFhirCarePlanActivityDetail.create;
  try
    ParseCarePlanActivityDetailProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCarePlanActivityDetailProperties(jsn : TJsonObject; result : TFhirCarePlanActivityDetail);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q3}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('reasonCode') then
      iterateArray(jsn.vArr['reasonCode'], result.reasonCodeList, parseCodeableConcept);
    if jsn.has('reasonReference') then
      iterateArray(jsn.vArr['reasonReference'], result.reasonReferenceList, parseReference{TFhirCondition});
    if jsn.has('goal') then
      iterateArray(jsn.vArr['goal'], result.goalList, parseReference{TFhirGoal});
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirCarePlanActivityStatusEnum, SYSTEMS_TFhirCarePlanActivityStatusEnum);
    if jsn.has('statusReason') then
        result.statusReason := ParseCodeableConcept(jsn.vObj['statusReason']);{q3}
    if jsn.has('prohibited') or jsn.has('_prohibited') then
        result.prohibitedElement := ParseBoolean(jsn.node['prohibited'], jsn.vObj['_prohibited']);{q}
    if jsn.has('scheduledTiming') {a4} then
      result.scheduled := ParseTiming(jsn.vObj['scheduledTiming']);
    if jsn.has('scheduledPeriod') {a4} then
      result.scheduled := ParsePeriod(jsn.vObj['scheduledPeriod']);
    if jsn.has('scheduledString') or jsn.has('_scheduledString') then
      result.scheduled := ParseString(jsn.node['scheduledString'], jsn.vObj['_scheduledString']);
    if jsn.has('location') then
        result.location := ParseReference{TFhirLocation}(jsn.vObj['location']);{q3}
    if jsn.has('performer') then
      iterateArray(jsn.vArr['performer'], result.performerList, parseReference{Resource});
    if jsn.has('productCodeableConcept') {a4} then
      result.product := ParseCodeableConcept(jsn.vObj['productCodeableConcept']);
    if jsn.has('productReference') {a3} then
      result.product := ParseReference(jsn.vObj['productReference']);
    if jsn.has('dailyAmount') then
        result.dailyAmount := ParseQuantity(jsn.vObj['dailyAmount']);{q3}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn.node['description'], jsn.vObj['_description']);{q}
end;

procedure TFHIRJsonComposer.ComposeCarePlanActivityDetail(json : TJSONWriter; name : string; elem : TFhirCarePlanActivityDetail; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'category', elem.category); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soData]) and (elem.reasonCodeList.Count > 0) then
  begin
    startArray(json, 'reasonCode', elem.reasonCodeList, false);
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonCodeList[i]); {z - CodeableConcept}
    finishArray(json, elem.reasonCodeList);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.reasonReferenceList.Count > 0) then
  begin
    startArray(json, 'reasonReference', elem.reasonReferenceList, false);
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(json, '', elem.reasonReferenceList[i]); {z - Reference(Condition)}
    finishArray(json, elem.reasonReferenceList);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.goalList.Count > 0) then
  begin
    startArray(json, 'goal', elem.goalList, false);
    for i := 0 to elem.goalList.Count - 1 do
      ComposeReference{TFhirGoal}(json, '', elem.goalList[i]); {z - Reference(Goal)}
    finishArray(json, elem.goalList);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirCarePlanActivityStatusEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirCarePlanActivityStatusEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'statusReason', elem.statusReason); {a}
  ComposeBooleanValue(json, 'prohibited', elem.prohibitedElement, false);
  ComposeBooleanProps(json, 'prohibited', elem.prohibitedElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.scheduled is TFhirTiming) then 
    ComposeTiming(json, 'scheduledTiming', TFhirTiming(elem.scheduled)) 
  else if (SummaryOption in [soFull, soData]) and (elem.scheduled is TFhirPeriod) then 
    ComposePeriod(json, 'scheduledPeriod', TFhirPeriod(elem.scheduled)) 
  else if (SummaryOption in [soFull, soData]) and (elem.scheduled is TFhirString) then 
  begin
    ComposeStringValue(json, 'scheduledString', TFhirString(elem.scheduled), false);
    ComposeStringProps(json, 'scheduledString', TFhirString(elem.scheduled), false);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(json, 'location', elem.location); {a}
  if (SummaryOption in [soFull, soData]) and (elem.performerList.Count > 0) then
  begin
    startArray(json, 'performer', elem.performerList, false);
    for i := 0 to elem.performerList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.performerList[i]); {z - Reference(Practitioner|Organization|RelatedPerson|Patient)}
    finishArray(json, elem.performerList);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.product is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'productCodeableConcept', TFhirCodeableConcept(elem.product)) 
  else if (SummaryOption in [soFull, soData]) and (elem.product is TFhirReference) then
    ComposeReference(json, 'productReference', TFhirReference(elem.product));
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'dailyAmount', elem.dailyAmount); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseCarePlan(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCarePlan(jsn)); {2}
end;

function TFHIRJsonParser.ParseCarePlan(jsn : TJsonObject) : TFhirCarePlan;
begin
  result := TFhirCarePlan.create;
  try
    ParseCarePlanProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCarePlanProperties(jsn : TJsonObject; result : TFhirCarePlan);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q3}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirCarePlanStatusEnum, SYSTEMS_TFhirCarePlanStatusEnum);
    if jsn.has('context') then
        result.context := ParseReference{Resource}(jsn.vObj['context']);{q3}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
    if jsn.has('author') then
      iterateArray(jsn.vArr['author'], result.authorList, parseReference{Resource});
    if jsn.has('modified') or jsn.has('_modified') then
        result.modifiedElement := ParseDateTime(jsn.node['modified'], jsn.vObj['_modified']);{q}
    if jsn.has('category') then
      iterateArray(jsn.vArr['category'], result.categoryList, parseCodeableConcept);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('addresses') then
      iterateArray(jsn.vArr['addresses'], result.addressesList, parseReference{TFhirCondition});
    if jsn.has('support') then
      iterateArray(jsn.vArr['support'], result.supportList, parseReference{TFhirReference});
    if jsn.has('relatedPlan') then
      iterateArray(jsn.vArr['relatedPlan'], result.relatedPlanList, parseCarePlanRelatedPlan);
    if jsn.has('participant') then
      iterateArray(jsn.vArr['participant'], result.participantList, parseCarePlanParticipant);
    if jsn.has('goal') then
      iterateArray(jsn.vArr['goal'], result.goalList, parseReference{TFhirGoal});
    if jsn.has('activity') then
      iterateArray(jsn.vArr['activity'], result.activityList, parseCarePlanActivity);
    if jsn.has('note') then
        result.note := ParseAnnotation(jsn.vObj['note']);{q3}
end;

procedure TFHIRJsonComposer.ComposeCarePlan(json : TJSONWriter; name : string; elem : TFhirCarePlan; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirCarePlanStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirCarePlanStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeReference{Resource}(json, 'context', elem.context); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') and (elem.authorList.Count > 0) then
  begin
    startArray(json, 'author', elem.authorList, false);
    for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.authorList[i]); {z - Reference(Patient|Practitioner|RelatedPerson|Organization)}
    finishArray(json, elem.authorList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('modified') then
    ComposeDateTimeValue(json, 'modified', elem.modifiedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('modified') then
    ComposeDateTimeProps(json, 'modified', elem.modifiedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') and (elem.categoryList.Count > 0) then
  begin
    startArray(json, 'category', elem.categoryList, false);
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.categoryList[i]); {z - CodeableConcept}
    finishArray(json, elem.categoryList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('addresses') and (elem.addressesList.Count > 0) then
  begin
    startArray(json, 'addresses', elem.addressesList, false);
    for i := 0 to elem.addressesList.Count - 1 do
      ComposeReference{TFhirCondition}(json, '', elem.addressesList[i]); {z - Reference(Condition)}
    finishArray(json, elem.addressesList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('support') and (elem.supportList.Count > 0) then
  begin
    startArray(json, 'support', elem.supportList, false);
    for i := 0 to elem.supportList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.supportList[i]); {z - Reference(Any)}
    finishArray(json, elem.supportList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('relatedPlan') and (elem.relatedPlanList.Count > 0) then
  begin
    startArray(json, 'relatedPlan', elem.relatedPlanList, false);
    for i := 0 to elem.relatedPlanList.Count - 1 do
      ComposeCarePlanRelatedPlan(json, '', elem.relatedPlanList[i]); {z - }
    finishArray(json, elem.relatedPlanList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('participant') and (elem.participantList.Count > 0) then
  begin
    startArray(json, 'participant', elem.participantList, false);
    for i := 0 to elem.participantList.Count - 1 do
      ComposeCarePlanParticipant(json, '', elem.participantList[i]); {z - }
    finishArray(json, elem.participantList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('goal') and (elem.goalList.Count > 0) then
  begin
    startArray(json, 'goal', elem.goalList, false);
    for i := 0 to elem.goalList.Count - 1 do
      ComposeReference{TFhirGoal}(json, '', elem.goalList[i]); {z - Reference(Goal)}
    finishArray(json, elem.goalList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('activity') and (elem.activityList.Count > 0) then
  begin
    startArray(json, 'activity', elem.activityList, false);
    for i := 0 to elem.activityList.Count - 1 do
      ComposeCarePlanActivity(json, '', elem.activityList[i]); {z - }
    finishArray(json, elem.activityList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    ComposeAnnotation(json, 'note', elem.note); {a}
end;

{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CLAIM}
procedure TFHIRJsonParser.ParseClaimPayee(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimPayee(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimPayee(jsn : TJsonObject) : TFhirClaimPayee;
begin
  result := TFhirClaimPayee.create;
  try
    ParseClaimPayeeProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimPayeeProperties(jsn : TJsonObject; result : TFhirClaimPayee);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q3}
    if jsn.has('provider') then
        result.provider := ParseReference{TFhirPractitioner}(jsn.vObj['provider']);{q3}
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q3}
    if jsn.has('person') then
        result.person := ParseReference{TFhirPatient}(jsn.vObj['person']);{q3}
end;

procedure TFHIRJsonComposer.ComposeClaimPayee(json : TJSONWriter; name : string; elem : TFhirClaimPayee; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'provider', elem.provider); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(json, 'person', elem.person); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseClaimDiagnosis(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimDiagnosis(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimDiagnosis(jsn : TJsonObject) : TFhirClaimDiagnosis;
begin
  result := TFhirClaimDiagnosis.create;
  try
    ParseClaimDiagnosisProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimDiagnosisProperties(jsn : TJsonObject; result : TFhirClaimDiagnosis);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequence') or jsn.has('_sequence') then
        result.sequenceElement := ParsePositiveInt(jsn.node['sequence'], jsn.vObj['_sequence']);{q}
    if jsn.has('diagnosis') then
        result.diagnosis := ParseCoding(jsn.vObj['diagnosis']);{q3}
end;

procedure TFHIRJsonComposer.ComposeClaimDiagnosis(json : TJSONWriter; name : string; elem : TFhirClaimDiagnosis; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposePositiveIntValue(json, 'sequence', elem.sequenceElement, false);
  ComposePositiveIntProps(json, 'sequence', elem.sequenceElement, false);
  ComposeCoding(json, 'diagnosis', elem.diagnosis); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseClaimCoverage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimCoverage(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimCoverage(jsn : TJsonObject) : TFhirClaimCoverage;
begin
  result := TFhirClaimCoverage.create;
  try
    ParseClaimCoverageProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimCoverageProperties(jsn : TJsonObject; result : TFhirClaimCoverage);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequence') or jsn.has('_sequence') then
        result.sequenceElement := ParsePositiveInt(jsn.node['sequence'], jsn.vObj['_sequence']);{q}
    if jsn.has('focal') or jsn.has('_focal') then
        result.focalElement := ParseBoolean(jsn.node['focal'], jsn.vObj['_focal']);{q}
    if jsn.has('coverage') then
        result.coverage := ParseReference{TFhirCoverage}(jsn.vObj['coverage']);{q3}
    if jsn.has('businessArrangement') or jsn.has('_businessArrangement') then
        result.businessArrangementElement := ParseString(jsn.node['businessArrangement'], jsn.vObj['_businessArrangement']);{q}
    if jsn.has('relationship') then
        result.relationship := ParseCoding(jsn.vObj['relationship']);{q3}
      if jsn.has('preAuthRef') or jsn.has('_preAuthRef') then
      iteratePrimitiveArray(jsn.vArr['preAuthRef'], jsn.vArr['_preAuthRef'], result.preAuthRefList, parseString);
    if jsn.has('claimResponse') then
        result.claimResponse := ParseReference{TFhirClaimResponse}(jsn.vObj['claimResponse']);{q3}
    if jsn.has('originalRuleset') then
        result.originalRuleset := ParseCoding(jsn.vObj['originalRuleset']);{q3}
end;

procedure TFHIRJsonComposer.ComposeClaimCoverage(json : TJSONWriter; name : string; elem : TFhirClaimCoverage; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposePositiveIntValue(json, 'sequence', elem.sequenceElement, false);
  ComposePositiveIntProps(json, 'sequence', elem.sequenceElement, false);
  ComposeBooleanValue(json, 'focal', elem.focalElement, false);
  ComposeBooleanProps(json, 'focal', elem.focalElement, false);
  ComposeReference{TFhirCoverage}(json, 'coverage', elem.coverage); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'businessArrangement', elem.businessArrangementElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'businessArrangement', elem.businessArrangementElement, false);
  ComposeCoding(json, 'relationship', elem.relationship); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.preAuthRefList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.preAuthRefList.Count - 1 do
    begin
      ext := ext or ((elem.preAuthRefList[i].id <> '') or (elem.preAuthRefList[i].hasExtensionList) {no-comments or (elem.preAuthRefList[i].hasComments)});
      val := val or (elem.preAuthRefList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      startArray(json, 'preAuthRef', elem.preAuthRefList, true);
      for i := 0 to elem.preAuthRefList.Count - 1 do
        ComposeStringValue(json, '',elem.preAuthRefList[i], true);
      finishArray(json, elem.preAuthRefList);
    end;
    if ext then
    begin
      startArray(json, '_preAuthRef', elem.preAuthRefList, false);
      for i := 0 to elem.preAuthRefList.Count - 1 do
        ComposeStringProps(json, '',elem.preAuthRefList[i], true);
      finishArray(json, elem.preAuthRefList);
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirClaimResponse}(json, 'claimResponse', elem.claimResponse); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'originalRuleset', elem.originalRuleset); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseClaimItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimItem(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimItem(jsn : TJsonObject) : TFhirClaimItem;
begin
  result := TFhirClaimItem.create;
  try
    ParseClaimItemProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimItemProperties(jsn : TJsonObject; result : TFhirClaimItem);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequence') or jsn.has('_sequence') then
        result.sequenceElement := ParsePositiveInt(jsn.node['sequence'], jsn.vObj['_sequence']);{q}
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q3}
    if jsn.has('provider') then
        result.provider := ParseReference{TFhirPractitioner}(jsn.vObj['provider']);{q3}
      if jsn.has('diagnosisLinkId') or jsn.has('_diagnosisLinkId') then
      iteratePrimitiveArray(jsn.vArr['diagnosisLinkId'], jsn.vArr['_diagnosisLinkId'], result.diagnosisLinkIdList, parsePositiveInt);
    if jsn.has('service') then
        result.service := ParseCoding(jsn.vObj['service']);{q3}
    if jsn.has('serviceDate') or jsn.has('_serviceDate') then
        result.serviceDateElement := ParseDate(jsn.node['serviceDate'], jsn.vObj['_serviceDate']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
    if jsn.has('unitPrice') then
        result.unitPrice := ParseQuantity(jsn.vObj['unitPrice']);{q3}
    if jsn.has('factor') or jsn.has('_factor') then
        result.factorElement := ParseDecimal(jsn.node['factor'], jsn.vObj['_factor']);{q}
    if jsn.has('points') or jsn.has('_points') then
        result.pointsElement := ParseDecimal(jsn.node['points'], jsn.vObj['_points']);{q}
    if jsn.has('net') then
        result.net := ParseQuantity(jsn.vObj['net']);{q3}
    if jsn.has('udi') then
        result.udi := ParseCoding(jsn.vObj['udi']);{q3}
    if jsn.has('bodySite') then
        result.bodySite := ParseCoding(jsn.vObj['bodySite']);{q3}
    if jsn.has('subSite') then
      iterateArray(jsn.vArr['subSite'], result.subSiteList, parseCoding);
    if jsn.has('modifier') then
      iterateArray(jsn.vArr['modifier'], result.modifierList, parseCoding);
    if jsn.has('detail') then
      iterateArray(jsn.vArr['detail'], result.detailList, parseClaimItemDetail);
    if jsn.has('prosthesis') then
        result.prosthesis := ParseClaimItemProsthesis(jsn.vObj['prosthesis']);{q3}
end;

procedure TFHIRJsonComposer.ComposeClaimItem(json : TJSONWriter; name : string; elem : TFhirClaimItem; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposePositiveIntValue(json, 'sequence', elem.sequenceElement, false);
  ComposePositiveIntProps(json, 'sequence', elem.sequenceElement, false);
  ComposeCoding(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'provider', elem.provider); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.diagnosisLinkIdList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.diagnosisLinkIdList.Count - 1 do
    begin
      ext := ext or ((elem.diagnosisLinkIdList[i].id <> '') or (elem.diagnosisLinkIdList[i].hasExtensionList) {no-comments or (elem.diagnosisLinkIdList[i].hasComments)});
      val := val or (elem.diagnosisLinkIdList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      startArray(json, 'diagnosisLinkId', elem.diagnosisLinkIdList, true);
      for i := 0 to elem.diagnosisLinkIdList.Count - 1 do
        ComposePositiveIntValue(json, '',elem.diagnosisLinkIdList[i], true);
      finishArray(json, elem.diagnosisLinkIdList);
    end;
    if ext then
    begin
      startArray(json, '_diagnosisLinkId', elem.diagnosisLinkIdList, false);
      for i := 0 to elem.diagnosisLinkIdList.Count - 1 do
        ComposePositiveIntProps(json, '',elem.diagnosisLinkIdList[i], true);
      finishArray(json, elem.diagnosisLinkIdList);
    end;
  end;
  ComposeCoding(json, 'service', elem.service); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateValue(json, 'serviceDate', elem.serviceDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateProps(json, 'serviceDate', elem.serviceDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'unitPrice', elem.unitPrice); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'points', elem.pointsElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'points', elem.pointsElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'net', elem.net); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'udi', elem.udi); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'bodySite', elem.bodySite); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.subSiteList.Count > 0) then
  begin
    startArray(json, 'subSite', elem.subSiteList, false);
    for i := 0 to elem.subSiteList.Count - 1 do
      ComposeCoding(json, '', elem.subSiteList[i]); {z - Coding}
    finishArray(json, elem.subSiteList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.modifierList.Count > 0) then
  begin
    startArray(json, 'modifier', elem.modifierList, false);
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCoding(json, '', elem.modifierList[i]); {z - Coding}
    finishArray(json, elem.modifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.detailList.Count > 0) then
  begin
    startArray(json, 'detail', elem.detailList, false);
    for i := 0 to elem.detailList.Count - 1 do
      ComposeClaimItemDetail(json, '', elem.detailList[i]); {z - }
    finishArray(json, elem.detailList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeClaimItemProsthesis(json, 'prosthesis', elem.prosthesis); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseClaimItemDetail(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimItemDetail(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimItemDetail(jsn : TJsonObject) : TFhirClaimItemDetail;
begin
  result := TFhirClaimItemDetail.create;
  try
    ParseClaimItemDetailProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimItemDetailProperties(jsn : TJsonObject; result : TFhirClaimItemDetail);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequence') or jsn.has('_sequence') then
        result.sequenceElement := ParsePositiveInt(jsn.node['sequence'], jsn.vObj['_sequence']);{q}
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q3}
    if jsn.has('service') then
        result.service := ParseCoding(jsn.vObj['service']);{q3}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
    if jsn.has('unitPrice') then
        result.unitPrice := ParseQuantity(jsn.vObj['unitPrice']);{q3}
    if jsn.has('factor') or jsn.has('_factor') then
        result.factorElement := ParseDecimal(jsn.node['factor'], jsn.vObj['_factor']);{q}
    if jsn.has('points') or jsn.has('_points') then
        result.pointsElement := ParseDecimal(jsn.node['points'], jsn.vObj['_points']);{q}
    if jsn.has('net') then
        result.net := ParseQuantity(jsn.vObj['net']);{q3}
    if jsn.has('udi') then
        result.udi := ParseCoding(jsn.vObj['udi']);{q3}
    if jsn.has('subDetail') then
      iterateArray(jsn.vArr['subDetail'], result.subDetailList, parseClaimItemDetailSubDetail);
end;

procedure TFHIRJsonComposer.ComposeClaimItemDetail(json : TJSONWriter; name : string; elem : TFhirClaimItemDetail; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposePositiveIntValue(json, 'sequence', elem.sequenceElement, false);
  ComposePositiveIntProps(json, 'sequence', elem.sequenceElement, false);
  ComposeCoding(json, 'type', elem.type_); {a}
  ComposeCoding(json, 'service', elem.service); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'unitPrice', elem.unitPrice); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'points', elem.pointsElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'points', elem.pointsElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'net', elem.net); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'udi', elem.udi); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.subDetailList.Count > 0) then
  begin
    startArray(json, 'subDetail', elem.subDetailList, false);
    for i := 0 to elem.subDetailList.Count - 1 do
      ComposeClaimItemDetailSubDetail(json, '', elem.subDetailList[i]); {z - }
    finishArray(json, elem.subDetailList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseClaimItemDetailSubDetail(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimItemDetailSubDetail(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimItemDetailSubDetail(jsn : TJsonObject) : TFhirClaimItemDetailSubDetail;
begin
  result := TFhirClaimItemDetailSubDetail.create;
  try
    ParseClaimItemDetailSubDetailProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimItemDetailSubDetailProperties(jsn : TJsonObject; result : TFhirClaimItemDetailSubDetail);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequence') or jsn.has('_sequence') then
        result.sequenceElement := ParsePositiveInt(jsn.node['sequence'], jsn.vObj['_sequence']);{q}
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q3}
    if jsn.has('service') then
        result.service := ParseCoding(jsn.vObj['service']);{q3}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
    if jsn.has('unitPrice') then
        result.unitPrice := ParseQuantity(jsn.vObj['unitPrice']);{q3}
    if jsn.has('factor') or jsn.has('_factor') then
        result.factorElement := ParseDecimal(jsn.node['factor'], jsn.vObj['_factor']);{q}
    if jsn.has('points') or jsn.has('_points') then
        result.pointsElement := ParseDecimal(jsn.node['points'], jsn.vObj['_points']);{q}
    if jsn.has('net') then
        result.net := ParseQuantity(jsn.vObj['net']);{q3}
    if jsn.has('udi') then
        result.udi := ParseCoding(jsn.vObj['udi']);{q3}
end;

procedure TFHIRJsonComposer.ComposeClaimItemDetailSubDetail(json : TJSONWriter; name : string; elem : TFhirClaimItemDetailSubDetail; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposePositiveIntValue(json, 'sequence', elem.sequenceElement, false);
  ComposePositiveIntProps(json, 'sequence', elem.sequenceElement, false);
  ComposeCoding(json, 'type', elem.type_); {a}
  ComposeCoding(json, 'service', elem.service); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'unitPrice', elem.unitPrice); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'points', elem.pointsElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'points', elem.pointsElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'net', elem.net); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'udi', elem.udi); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseClaimItemProsthesis(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimItemProsthesis(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimItemProsthesis(jsn : TJsonObject) : TFhirClaimItemProsthesis;
begin
  result := TFhirClaimItemProsthesis.create;
  try
    ParseClaimItemProsthesisProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimItemProsthesisProperties(jsn : TJsonObject; result : TFhirClaimItemProsthesis);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('initial') or jsn.has('_initial') then
        result.initialElement := ParseBoolean(jsn.node['initial'], jsn.vObj['_initial']);{q}
    if jsn.has('priorDate') or jsn.has('_priorDate') then
        result.priorDateElement := ParseDate(jsn.node['priorDate'], jsn.vObj['_priorDate']);{q}
    if jsn.has('priorMaterial') then
        result.priorMaterial := ParseCoding(jsn.vObj['priorMaterial']);{q3}
end;

procedure TFHIRJsonComposer.ComposeClaimItemProsthesis(json : TJSONWriter; name : string; elem : TFhirClaimItemProsthesis; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanValue(json, 'initial', elem.initialElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanProps(json, 'initial', elem.initialElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateValue(json, 'priorDate', elem.priorDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateProps(json, 'priorDate', elem.priorDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'priorMaterial', elem.priorMaterial); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseClaimMissingTeeth(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimMissingTeeth(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimMissingTeeth(jsn : TJsonObject) : TFhirClaimMissingTeeth;
begin
  result := TFhirClaimMissingTeeth.create;
  try
    ParseClaimMissingTeethProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimMissingTeethProperties(jsn : TJsonObject; result : TFhirClaimMissingTeeth);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('tooth') then
        result.tooth := ParseCoding(jsn.vObj['tooth']);{q3}
    if jsn.has('reason') then
        result.reason := ParseCoding(jsn.vObj['reason']);{q3}
    if jsn.has('extractionDate') or jsn.has('_extractionDate') then
        result.extractionDateElement := ParseDate(jsn.node['extractionDate'], jsn.vObj['_extractionDate']);{q}
end;

procedure TFHIRJsonComposer.ComposeClaimMissingTeeth(json : TJSONWriter; name : string; elem : TFhirClaimMissingTeeth; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeCoding(json, 'tooth', elem.tooth); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'reason', elem.reason); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateValue(json, 'extractionDate', elem.extractionDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateProps(json, 'extractionDate', elem.extractionDateElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseClaim(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaim(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaim(jsn : TJsonObject) : TFhirClaim;
begin
  result := TFhirClaim.create;
  try
    ParseClaimProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimProperties(jsn : TJsonObject; result : TFhirClaim);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirClaimTypeLinkEnum, SYSTEMS_TFhirClaimTypeLinkEnum);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('ruleset') then
        result.ruleset := ParseCoding(jsn.vObj['ruleset']);{q3}
    if jsn.has('originalRuleset') then
        result.originalRuleset := ParseCoding(jsn.vObj['originalRuleset']);{q3}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := ParseDateTime(jsn.node['created'], jsn.vObj['_created']);{q}
    if jsn.has('target') then
        result.target := ParseReference{TFhirOrganization}(jsn.vObj['target']);{q3}
    if jsn.has('provider') then
        result.provider := ParseReference{TFhirPractitioner}(jsn.vObj['provider']);{q3}
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q3}
    if jsn.has('use') or jsn.has('_use')  then
      result.useElement := parseEnum(jsn.path+'/use', jsn.node['use'], jsn.vObj['_use'], CODES_TFhirClaimUseLinkEnum, SYSTEMS_TFhirClaimUseLinkEnum);
    if jsn.has('priority') then
        result.priority := ParseCoding(jsn.vObj['priority']);{q3}
    if jsn.has('fundsReserve') then
        result.fundsReserve := ParseCoding(jsn.vObj['fundsReserve']);{q3}
    if jsn.has('enterer') then
        result.enterer := ParseReference{TFhirPractitioner}(jsn.vObj['enterer']);{q3}
    if jsn.has('facility') then
        result.facility := ParseReference{TFhirLocation}(jsn.vObj['facility']);{q3}
    if jsn.has('prescription') then
        result.prescription := ParseReference{Resource}(jsn.vObj['prescription']);{q3}
    if jsn.has('originalPrescription') then
        result.originalPrescription := ParseReference{TFhirMedicationOrder}(jsn.vObj['originalPrescription']);{q3}
    if jsn.has('payee') then
        result.payee := ParseClaimPayee(jsn.vObj['payee']);{q3}
    if jsn.has('referral') then
        result.referral := ParseReference{TFhirReferralRequest}(jsn.vObj['referral']);{q3}
    if jsn.has('diagnosis') then
      iterateArray(jsn.vArr['diagnosis'], result.diagnosisList, parseClaimDiagnosis);
    if jsn.has('condition') then
      iterateArray(jsn.vArr['condition'], result.conditionList, parseCoding);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
    if jsn.has('coverage') then
      iterateArray(jsn.vArr['coverage'], result.coverageList, parseClaimCoverage);
    if jsn.has('exception') then
      iterateArray(jsn.vArr['exception'], result.exceptionList, parseCoding);
    if jsn.has('school') or jsn.has('_school') then
        result.schoolElement := ParseString(jsn.node['school'], jsn.vObj['_school']);{q}
    if jsn.has('accident') or jsn.has('_accident') then
        result.accidentElement := ParseDate(jsn.node['accident'], jsn.vObj['_accident']);{q}
    if jsn.has('accidentType') then
        result.accidentType := ParseCoding(jsn.vObj['accidentType']);{q3}
    if jsn.has('interventionException') then
      iterateArray(jsn.vArr['interventionException'], result.interventionExceptionList, parseCoding);
    if jsn.has('item') then
      iterateArray(jsn.vArr['item'], result.itemList, parseClaimItem);
    if jsn.has('additionalMaterials') then
      iterateArray(jsn.vArr['additionalMaterials'], result.additionalMaterialsList, parseCoding);
    if jsn.has('missingTeeth') then
      iterateArray(jsn.vArr['missingTeeth'], result.missingTeethList, parseClaimMissingTeeth);
end;

procedure TFHIRJsonComposer.ComposeClaim(json : TJSONWriter; name : string; elem : TFhirClaim; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirClaimTypeLinkEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirClaimTypeLinkEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ruleset') then
    ComposeCoding(json, 'ruleset', elem.ruleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('originalRuleset') then
    ComposeCoding(json, 'originalRuleset', elem.originalRuleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('target') then
    ComposeReference{TFhirOrganization}(json, 'target', elem.target); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('provider') then
    ComposeReference{TFhirPractitioner}(json, 'provider', elem.provider); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('use') then
    ComposeEnumValue(json, 'use', elem.UseElement, CODES_TFhirClaimUseLinkEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('use') then
    ComposeEnumProps(json, 'use', elem.UseElement, CODES_TFhirClaimUseLinkEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeCoding(json, 'priority', elem.priority); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('fundsReserve') then
    ComposeCoding(json, 'fundsReserve', elem.fundsReserve); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('enterer') then
    ComposeReference{TFhirPractitioner}(json, 'enterer', elem.enterer); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('facility') then
    ComposeReference{TFhirLocation}(json, 'facility', elem.facility); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('prescription') then
    ComposeReference{Resource}(json, 'prescription', elem.prescription); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('originalPrescription') then
    ComposeReference{TFhirMedicationOrder}(json, 'originalPrescription', elem.originalPrescription); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('payee') then
    ComposeClaimPayee(json, 'payee', elem.payee); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('referral') then
    ComposeReference{TFhirReferralRequest}(json, 'referral', elem.referral); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('diagnosis') and (elem.diagnosisList.Count > 0) then
  begin
    startArray(json, 'diagnosis', elem.diagnosisList, false);
    for i := 0 to elem.diagnosisList.Count - 1 do
      ComposeClaimDiagnosis(json, '', elem.diagnosisList[i]); {z - }
    finishArray(json, elem.diagnosisList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('condition') and (elem.conditionList.Count > 0) then
  begin
    startArray(json, 'condition', elem.conditionList, false);
    for i := 0 to elem.conditionList.Count - 1 do
      ComposeCoding(json, '', elem.conditionList[i]); {z - Coding}
    finishArray(json, elem.conditionList);
  end;
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('coverage') and (elem.coverageList.Count > 0) then
  begin
    startArray(json, 'coverage', elem.coverageList, false);
    for i := 0 to elem.coverageList.Count - 1 do
      ComposeClaimCoverage(json, '', elem.coverageList[i]); {z - }
    finishArray(json, elem.coverageList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('exception') and (elem.exceptionList.Count > 0) then
  begin
    startArray(json, 'exception', elem.exceptionList, false);
    for i := 0 to elem.exceptionList.Count - 1 do
      ComposeCoding(json, '', elem.exceptionList[i]); {z - Coding}
    finishArray(json, elem.exceptionList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('school') then
    ComposeStringValue(json, 'school', elem.schoolElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('school') then
    ComposeStringProps(json, 'school', elem.schoolElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('accident') then
    ComposeDateValue(json, 'accident', elem.accidentElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('accident') then
    ComposeDateProps(json, 'accident', elem.accidentElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('accidentType') then
    ComposeCoding(json, 'accidentType', elem.accidentType); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('interventionException') and (elem.interventionExceptionList.Count > 0) then
  begin
    startArray(json, 'interventionException', elem.interventionExceptionList, false);
    for i := 0 to elem.interventionExceptionList.Count - 1 do
      ComposeCoding(json, '', elem.interventionExceptionList[i]); {z - Coding}
    finishArray(json, elem.interventionExceptionList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('item') and (elem.itemList.Count > 0) then
  begin
    startArray(json, 'item', elem.itemList, false);
    for i := 0 to elem.itemList.Count - 1 do
      ComposeClaimItem(json, '', elem.itemList[i]); {z - }
    finishArray(json, elem.itemList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('additionalMaterials') and (elem.additionalMaterialsList.Count > 0) then
  begin
    startArray(json, 'additionalMaterials', elem.additionalMaterialsList, false);
    for i := 0 to elem.additionalMaterialsList.Count - 1 do
      ComposeCoding(json, '', elem.additionalMaterialsList[i]); {z - Coding}
    finishArray(json, elem.additionalMaterialsList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('missingTeeth') and (elem.missingTeethList.Count > 0) then
  begin
    startArray(json, 'missingTeeth', elem.missingTeethList, false);
    for i := 0 to elem.missingTeethList.Count - 1 do
      ComposeClaimMissingTeeth(json, '', elem.missingTeethList[i]); {z - }
    finishArray(json, elem.missingTeethList);
  end;
end;

{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
procedure TFHIRJsonParser.ParseClaimResponseItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseItem(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseItem(jsn : TJsonObject) : TFhirClaimResponseItem;
begin
  result := TFhirClaimResponseItem.create;
  try
    ParseClaimResponseItemProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimResponseItemProperties(jsn : TJsonObject; result : TFhirClaimResponseItem);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequenceLinkId') or jsn.has('_sequenceLinkId') then
        result.sequenceLinkIdElement := ParsePositiveInt(jsn.node['sequenceLinkId'], jsn.vObj['_sequenceLinkId']);{q}
      if jsn.has('noteNumber') or jsn.has('_noteNumber') then
      iteratePrimitiveArray(jsn.vArr['noteNumber'], jsn.vArr['_noteNumber'], result.noteNumberList, parsePositiveInt);
    if jsn.has('adjudication') then
      iterateArray(jsn.vArr['adjudication'], result.adjudicationList, parseClaimResponseItemAdjudication);
    if jsn.has('detail') then
      iterateArray(jsn.vArr['detail'], result.detailList, parseClaimResponseItemDetail);
end;

procedure TFHIRJsonComposer.ComposeClaimResponseItem(json : TJSONWriter; name : string; elem : TFhirClaimResponseItem; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposePositiveIntValue(json, 'sequenceLinkId', elem.sequenceLinkIdElement, false);
  ComposePositiveIntProps(json, 'sequenceLinkId', elem.sequenceLinkIdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.noteNumberList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.noteNumberList.Count - 1 do
    begin
      ext := ext or ((elem.noteNumberList[i].id <> '') or (elem.noteNumberList[i].hasExtensionList) {no-comments or (elem.noteNumberList[i].hasComments)});
      val := val or (elem.noteNumberList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      startArray(json, 'noteNumber', elem.noteNumberList, true);
      for i := 0 to elem.noteNumberList.Count - 1 do
        ComposePositiveIntValue(json, '',elem.noteNumberList[i], true);
      finishArray(json, elem.noteNumberList);
    end;
    if ext then
    begin
      startArray(json, '_noteNumber', elem.noteNumberList, false);
      for i := 0 to elem.noteNumberList.Count - 1 do
        ComposePositiveIntProps(json, '',elem.noteNumberList[i], true);
      finishArray(json, elem.noteNumberList);
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.adjudicationList.Count > 0) then
  begin
    startArray(json, 'adjudication', elem.adjudicationList, false);
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(json, '', elem.adjudicationList[i]); {z - }
    finishArray(json, elem.adjudicationList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.detailList.Count > 0) then
  begin
    startArray(json, 'detail', elem.detailList, false);
    for i := 0 to elem.detailList.Count - 1 do
      ComposeClaimResponseItemDetail(json, '', elem.detailList[i]); {z - }
    finishArray(json, elem.detailList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseClaimResponseItemAdjudication(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseItemAdjudication(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseItemAdjudication(jsn : TJsonObject) : TFhirClaimResponseItemAdjudication;
begin
  result := TFhirClaimResponseItemAdjudication.create;
  try
    ParseClaimResponseItemAdjudicationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimResponseItemAdjudicationProperties(jsn : TJsonObject; result : TFhirClaimResponseItemAdjudication);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCoding(jsn.vObj['code']);{q3}
    if jsn.has('amount') then
        result.amount := ParseQuantity(jsn.vObj['amount']);{q3}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := ParseDecimal(jsn.node['value'], jsn.vObj['_value']);{q}
end;

procedure TFHIRJsonComposer.ComposeClaimResponseItemAdjudication(json : TJSONWriter; name : string; elem : TFhirClaimResponseItemAdjudication; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeCoding(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'amount', elem.amount); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'value', elem.valueElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseClaimResponseItemDetail(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseItemDetail(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseItemDetail(jsn : TJsonObject) : TFhirClaimResponseItemDetail;
begin
  result := TFhirClaimResponseItemDetail.create;
  try
    ParseClaimResponseItemDetailProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimResponseItemDetailProperties(jsn : TJsonObject; result : TFhirClaimResponseItemDetail);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequenceLinkId') or jsn.has('_sequenceLinkId') then
        result.sequenceLinkIdElement := ParsePositiveInt(jsn.node['sequenceLinkId'], jsn.vObj['_sequenceLinkId']);{q}
    if jsn.has('adjudication') then
      iterateArray(jsn.vArr['adjudication'], result.adjudicationList, parseClaimResponseItemDetailAdjudication);
    if jsn.has('subDetail') then
      iterateArray(jsn.vArr['subDetail'], result.subDetailList, parseClaimResponseItemDetailSubDetail);
end;

procedure TFHIRJsonComposer.ComposeClaimResponseItemDetail(json : TJSONWriter; name : string; elem : TFhirClaimResponseItemDetail; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposePositiveIntValue(json, 'sequenceLinkId', elem.sequenceLinkIdElement, false);
  ComposePositiveIntProps(json, 'sequenceLinkId', elem.sequenceLinkIdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.adjudicationList.Count > 0) then
  begin
    startArray(json, 'adjudication', elem.adjudicationList, false);
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemDetailAdjudication(json, '', elem.adjudicationList[i]); {z - }
    finishArray(json, elem.adjudicationList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.subDetailList.Count > 0) then
  begin
    startArray(json, 'subDetail', elem.subDetailList, false);
    for i := 0 to elem.subDetailList.Count - 1 do
      ComposeClaimResponseItemDetailSubDetail(json, '', elem.subDetailList[i]); {z - }
    finishArray(json, elem.subDetailList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseClaimResponseItemDetailAdjudication(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseItemDetailAdjudication(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseItemDetailAdjudication(jsn : TJsonObject) : TFhirClaimResponseItemDetailAdjudication;
begin
  result := TFhirClaimResponseItemDetailAdjudication.create;
  try
    ParseClaimResponseItemDetailAdjudicationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimResponseItemDetailAdjudicationProperties(jsn : TJsonObject; result : TFhirClaimResponseItemDetailAdjudication);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCoding(jsn.vObj['code']);{q3}
    if jsn.has('amount') then
        result.amount := ParseQuantity(jsn.vObj['amount']);{q3}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := ParseDecimal(jsn.node['value'], jsn.vObj['_value']);{q}
end;

procedure TFHIRJsonComposer.ComposeClaimResponseItemDetailAdjudication(json : TJSONWriter; name : string; elem : TFhirClaimResponseItemDetailAdjudication; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeCoding(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'amount', elem.amount); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'value', elem.valueElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseClaimResponseItemDetailSubDetail(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseItemDetailSubDetail(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseItemDetailSubDetail(jsn : TJsonObject) : TFhirClaimResponseItemDetailSubDetail;
begin
  result := TFhirClaimResponseItemDetailSubDetail.create;
  try
    ParseClaimResponseItemDetailSubDetailProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimResponseItemDetailSubDetailProperties(jsn : TJsonObject; result : TFhirClaimResponseItemDetailSubDetail);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequenceLinkId') or jsn.has('_sequenceLinkId') then
        result.sequenceLinkIdElement := ParsePositiveInt(jsn.node['sequenceLinkId'], jsn.vObj['_sequenceLinkId']);{q}
    if jsn.has('adjudication') then
      iterateArray(jsn.vArr['adjudication'], result.adjudicationList, parseClaimResponseItemDetailSubDetailAdjudication);
end;

procedure TFHIRJsonComposer.ComposeClaimResponseItemDetailSubDetail(json : TJSONWriter; name : string; elem : TFhirClaimResponseItemDetailSubDetail; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposePositiveIntValue(json, 'sequenceLinkId', elem.sequenceLinkIdElement, false);
  ComposePositiveIntProps(json, 'sequenceLinkId', elem.sequenceLinkIdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.adjudicationList.Count > 0) then
  begin
    startArray(json, 'adjudication', elem.adjudicationList, false);
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemDetailSubDetailAdjudication(json, '', elem.adjudicationList[i]); {z - }
    finishArray(json, elem.adjudicationList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseClaimResponseItemDetailSubDetailAdjudication(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseItemDetailSubDetailAdjudication(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseItemDetailSubDetailAdjudication(jsn : TJsonObject) : TFhirClaimResponseItemDetailSubDetailAdjudication;
begin
  result := TFhirClaimResponseItemDetailSubDetailAdjudication.create;
  try
    ParseClaimResponseItemDetailSubDetailAdjudicationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimResponseItemDetailSubDetailAdjudicationProperties(jsn : TJsonObject; result : TFhirClaimResponseItemDetailSubDetailAdjudication);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCoding(jsn.vObj['code']);{q3}
    if jsn.has('amount') then
        result.amount := ParseQuantity(jsn.vObj['amount']);{q3}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := ParseDecimal(jsn.node['value'], jsn.vObj['_value']);{q}
end;

procedure TFHIRJsonComposer.ComposeClaimResponseItemDetailSubDetailAdjudication(json : TJSONWriter; name : string; elem : TFhirClaimResponseItemDetailSubDetailAdjudication; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeCoding(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'amount', elem.amount); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'value', elem.valueElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseClaimResponseAddItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseAddItem(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseAddItem(jsn : TJsonObject) : TFhirClaimResponseAddItem;
begin
  result := TFhirClaimResponseAddItem.create;
  try
    ParseClaimResponseAddItemProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimResponseAddItemProperties(jsn : TJsonObject; result : TFhirClaimResponseAddItem);
begin
    ParseBackboneElementProperties(jsn, result);
      if jsn.has('sequenceLinkId') or jsn.has('_sequenceLinkId') then
      iteratePrimitiveArray(jsn.vArr['sequenceLinkId'], jsn.vArr['_sequenceLinkId'], result.sequenceLinkIdList, parsePositiveInt);
    if jsn.has('service') then
        result.service := ParseCoding(jsn.vObj['service']);{q3}
    if jsn.has('fee') then
        result.fee := ParseQuantity(jsn.vObj['fee']);{q3}
      if jsn.has('noteNumberLinkId') or jsn.has('_noteNumberLinkId') then
      iteratePrimitiveArray(jsn.vArr['noteNumberLinkId'], jsn.vArr['_noteNumberLinkId'], result.noteNumberLinkIdList, parsePositiveInt);
    if jsn.has('adjudication') then
      iterateArray(jsn.vArr['adjudication'], result.adjudicationList, parseClaimResponseAddItemAdjudication);
    if jsn.has('detail') then
      iterateArray(jsn.vArr['detail'], result.detailList, parseClaimResponseAddItemDetail);
end;

procedure TFHIRJsonComposer.ComposeClaimResponseAddItem(json : TJSONWriter; name : string; elem : TFhirClaimResponseAddItem; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.sequenceLinkIdList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.sequenceLinkIdList.Count - 1 do
    begin
      ext := ext or ((elem.sequenceLinkIdList[i].id <> '') or (elem.sequenceLinkIdList[i].hasExtensionList) {no-comments or (elem.sequenceLinkIdList[i].hasComments)});
      val := val or (elem.sequenceLinkIdList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      startArray(json, 'sequenceLinkId', elem.sequenceLinkIdList, true);
      for i := 0 to elem.sequenceLinkIdList.Count - 1 do
        ComposePositiveIntValue(json, '',elem.sequenceLinkIdList[i], true);
      finishArray(json, elem.sequenceLinkIdList);
    end;
    if ext then
    begin
      startArray(json, '_sequenceLinkId', elem.sequenceLinkIdList, false);
      for i := 0 to elem.sequenceLinkIdList.Count - 1 do
        ComposePositiveIntProps(json, '',elem.sequenceLinkIdList[i], true);
      finishArray(json, elem.sequenceLinkIdList);
    end;
  end;
  ComposeCoding(json, 'service', elem.service); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'fee', elem.fee); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.noteNumberLinkIdList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.noteNumberLinkIdList.Count - 1 do
    begin
      ext := ext or ((elem.noteNumberLinkIdList[i].id <> '') or (elem.noteNumberLinkIdList[i].hasExtensionList) {no-comments or (elem.noteNumberLinkIdList[i].hasComments)});
      val := val or (elem.noteNumberLinkIdList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      startArray(json, 'noteNumberLinkId', elem.noteNumberLinkIdList, true);
      for i := 0 to elem.noteNumberLinkIdList.Count - 1 do
        ComposePositiveIntValue(json, '',elem.noteNumberLinkIdList[i], true);
      finishArray(json, elem.noteNumberLinkIdList);
    end;
    if ext then
    begin
      startArray(json, '_noteNumberLinkId', elem.noteNumberLinkIdList, false);
      for i := 0 to elem.noteNumberLinkIdList.Count - 1 do
        ComposePositiveIntProps(json, '',elem.noteNumberLinkIdList[i], true);
      finishArray(json, elem.noteNumberLinkIdList);
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.adjudicationList.Count > 0) then
  begin
    startArray(json, 'adjudication', elem.adjudicationList, false);
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseAddItemAdjudication(json, '', elem.adjudicationList[i]); {z - }
    finishArray(json, elem.adjudicationList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.detailList.Count > 0) then
  begin
    startArray(json, 'detail', elem.detailList, false);
    for i := 0 to elem.detailList.Count - 1 do
      ComposeClaimResponseAddItemDetail(json, '', elem.detailList[i]); {z - }
    finishArray(json, elem.detailList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseClaimResponseAddItemAdjudication(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseAddItemAdjudication(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseAddItemAdjudication(jsn : TJsonObject) : TFhirClaimResponseAddItemAdjudication;
begin
  result := TFhirClaimResponseAddItemAdjudication.create;
  try
    ParseClaimResponseAddItemAdjudicationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimResponseAddItemAdjudicationProperties(jsn : TJsonObject; result : TFhirClaimResponseAddItemAdjudication);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCoding(jsn.vObj['code']);{q3}
    if jsn.has('amount') then
        result.amount := ParseQuantity(jsn.vObj['amount']);{q3}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := ParseDecimal(jsn.node['value'], jsn.vObj['_value']);{q}
end;

procedure TFHIRJsonComposer.ComposeClaimResponseAddItemAdjudication(json : TJSONWriter; name : string; elem : TFhirClaimResponseAddItemAdjudication; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeCoding(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'amount', elem.amount); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'value', elem.valueElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseClaimResponseAddItemDetail(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseAddItemDetail(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseAddItemDetail(jsn : TJsonObject) : TFhirClaimResponseAddItemDetail;
begin
  result := TFhirClaimResponseAddItemDetail.create;
  try
    ParseClaimResponseAddItemDetailProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimResponseAddItemDetailProperties(jsn : TJsonObject; result : TFhirClaimResponseAddItemDetail);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('service') then
        result.service := ParseCoding(jsn.vObj['service']);{q3}
    if jsn.has('fee') then
        result.fee := ParseQuantity(jsn.vObj['fee']);{q3}
    if jsn.has('adjudication') then
      iterateArray(jsn.vArr['adjudication'], result.adjudicationList, parseClaimResponseAddItemDetailAdjudication);
end;

procedure TFHIRJsonComposer.ComposeClaimResponseAddItemDetail(json : TJSONWriter; name : string; elem : TFhirClaimResponseAddItemDetail; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeCoding(json, 'service', elem.service); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'fee', elem.fee); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.adjudicationList.Count > 0) then
  begin
    startArray(json, 'adjudication', elem.adjudicationList, false);
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseAddItemDetailAdjudication(json, '', elem.adjudicationList[i]); {z - }
    finishArray(json, elem.adjudicationList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseClaimResponseAddItemDetailAdjudication(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseAddItemDetailAdjudication(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseAddItemDetailAdjudication(jsn : TJsonObject) : TFhirClaimResponseAddItemDetailAdjudication;
begin
  result := TFhirClaimResponseAddItemDetailAdjudication.create;
  try
    ParseClaimResponseAddItemDetailAdjudicationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimResponseAddItemDetailAdjudicationProperties(jsn : TJsonObject; result : TFhirClaimResponseAddItemDetailAdjudication);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCoding(jsn.vObj['code']);{q3}
    if jsn.has('amount') then
        result.amount := ParseQuantity(jsn.vObj['amount']);{q3}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := ParseDecimal(jsn.node['value'], jsn.vObj['_value']);{q}
end;

procedure TFHIRJsonComposer.ComposeClaimResponseAddItemDetailAdjudication(json : TJSONWriter; name : string; elem : TFhirClaimResponseAddItemDetailAdjudication; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeCoding(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'amount', elem.amount); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'value', elem.valueElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseClaimResponseError(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseError(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseError(jsn : TJsonObject) : TFhirClaimResponseError;
begin
  result := TFhirClaimResponseError.create;
  try
    ParseClaimResponseErrorProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimResponseErrorProperties(jsn : TJsonObject; result : TFhirClaimResponseError);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequenceLinkId') or jsn.has('_sequenceLinkId') then
        result.sequenceLinkIdElement := ParsePositiveInt(jsn.node['sequenceLinkId'], jsn.vObj['_sequenceLinkId']);{q}
    if jsn.has('detailSequenceLinkId') or jsn.has('_detailSequenceLinkId') then
        result.detailSequenceLinkIdElement := ParsePositiveInt(jsn.node['detailSequenceLinkId'], jsn.vObj['_detailSequenceLinkId']);{q}
    if jsn.has('subdetailSequenceLinkId') or jsn.has('_subdetailSequenceLinkId') then
        result.subdetailSequenceLinkIdElement := ParsePositiveInt(jsn.node['subdetailSequenceLinkId'], jsn.vObj['_subdetailSequenceLinkId']);{q}
    if jsn.has('code') then
        result.code := ParseCoding(jsn.vObj['code']);{q3}
end;

procedure TFHIRJsonComposer.ComposeClaimResponseError(json : TJSONWriter; name : string; elem : TFhirClaimResponseError; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntValue(json, 'sequenceLinkId', elem.sequenceLinkIdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntProps(json, 'sequenceLinkId', elem.sequenceLinkIdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntValue(json, 'detailSequenceLinkId', elem.detailSequenceLinkIdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntProps(json, 'detailSequenceLinkId', elem.detailSequenceLinkIdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntValue(json, 'subdetailSequenceLinkId', elem.subdetailSequenceLinkIdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntProps(json, 'subdetailSequenceLinkId', elem.subdetailSequenceLinkIdElement, false);
  ComposeCoding(json, 'code', elem.code); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseClaimResponseNote(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseNote(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseNote(jsn : TJsonObject) : TFhirClaimResponseNote;
begin
  result := TFhirClaimResponseNote.create;
  try
    ParseClaimResponseNoteProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimResponseNoteProperties(jsn : TJsonObject; result : TFhirClaimResponseNote);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('number') or jsn.has('_number') then
        result.numberElement := ParsePositiveInt(jsn.node['number'], jsn.vObj['_number']);{q}
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q3}
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn.node['text'], jsn.vObj['_text']);{q}
end;

procedure TFHIRJsonComposer.ComposeClaimResponseNote(json : TJSONWriter; name : string; elem : TFhirClaimResponseNote; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntValue(json, 'number', elem.numberElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntProps(json, 'number', elem.numberElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseClaimResponseCoverage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponseCoverage(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponseCoverage(jsn : TJsonObject) : TFhirClaimResponseCoverage;
begin
  result := TFhirClaimResponseCoverage.create;
  try
    ParseClaimResponseCoverageProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimResponseCoverageProperties(jsn : TJsonObject; result : TFhirClaimResponseCoverage);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequence') or jsn.has('_sequence') then
        result.sequenceElement := ParsePositiveInt(jsn.node['sequence'], jsn.vObj['_sequence']);{q}
    if jsn.has('focal') or jsn.has('_focal') then
        result.focalElement := ParseBoolean(jsn.node['focal'], jsn.vObj['_focal']);{q}
    if jsn.has('coverage') then
        result.coverage := ParseReference{TFhirCoverage}(jsn.vObj['coverage']);{q3}
    if jsn.has('businessArrangement') or jsn.has('_businessArrangement') then
        result.businessArrangementElement := ParseString(jsn.node['businessArrangement'], jsn.vObj['_businessArrangement']);{q}
    if jsn.has('relationship') then
        result.relationship := ParseCoding(jsn.vObj['relationship']);{q3}
      if jsn.has('preAuthRef') or jsn.has('_preAuthRef') then
      iteratePrimitiveArray(jsn.vArr['preAuthRef'], jsn.vArr['_preAuthRef'], result.preAuthRefList, parseString);
    if jsn.has('claimResponse') then
        result.claimResponse := ParseReference{TFhirClaimResponse}(jsn.vObj['claimResponse']);{q3}
    if jsn.has('originalRuleset') then
        result.originalRuleset := ParseCoding(jsn.vObj['originalRuleset']);{q3}
end;

procedure TFHIRJsonComposer.ComposeClaimResponseCoverage(json : TJSONWriter; name : string; elem : TFhirClaimResponseCoverage; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposePositiveIntValue(json, 'sequence', elem.sequenceElement, false);
  ComposePositiveIntProps(json, 'sequence', elem.sequenceElement, false);
  ComposeBooleanValue(json, 'focal', elem.focalElement, false);
  ComposeBooleanProps(json, 'focal', elem.focalElement, false);
  ComposeReference{TFhirCoverage}(json, 'coverage', elem.coverage); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'businessArrangement', elem.businessArrangementElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'businessArrangement', elem.businessArrangementElement, false);
  ComposeCoding(json, 'relationship', elem.relationship); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.preAuthRefList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.preAuthRefList.Count - 1 do
    begin
      ext := ext or ((elem.preAuthRefList[i].id <> '') or (elem.preAuthRefList[i].hasExtensionList) {no-comments or (elem.preAuthRefList[i].hasComments)});
      val := val or (elem.preAuthRefList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      startArray(json, 'preAuthRef', elem.preAuthRefList, true);
      for i := 0 to elem.preAuthRefList.Count - 1 do
        ComposeStringValue(json, '',elem.preAuthRefList[i], true);
      finishArray(json, elem.preAuthRefList);
    end;
    if ext then
    begin
      startArray(json, '_preAuthRef', elem.preAuthRefList, false);
      for i := 0 to elem.preAuthRefList.Count - 1 do
        ComposeStringProps(json, '',elem.preAuthRefList[i], true);
      finishArray(json, elem.preAuthRefList);
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirClaimResponse}(json, 'claimResponse', elem.claimResponse); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'originalRuleset', elem.originalRuleset); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseClaimResponse(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClaimResponse(jsn)); {2}
end;

function TFHIRJsonParser.ParseClaimResponse(jsn : TJsonObject) : TFhirClaimResponse;
begin
  result := TFhirClaimResponse.create;
  try
    ParseClaimResponseProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClaimResponseProperties(jsn : TJsonObject; result : TFhirClaimResponse);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('request') then
        result.request := ParseReference{TFhirClaim}(jsn.vObj['request']);{q3}
    if jsn.has('ruleset') then
        result.ruleset := ParseCoding(jsn.vObj['ruleset']);{q3}
    if jsn.has('originalRuleset') then
        result.originalRuleset := ParseCoding(jsn.vObj['originalRuleset']);{q3}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := ParseDateTime(jsn.node['created'], jsn.vObj['_created']);{q}
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q3}
    if jsn.has('requestProvider') then
        result.requestProvider := ParseReference{TFhirPractitioner}(jsn.vObj['requestProvider']);{q3}
    if jsn.has('requestOrganization') then
        result.requestOrganization := ParseReference{TFhirOrganization}(jsn.vObj['requestOrganization']);{q3}
    if jsn.has('outcome') or jsn.has('_outcome')  then
      result.outcomeElement := parseEnum(jsn.path+'/outcome', jsn.node['outcome'], jsn.vObj['_outcome'], CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum);
    if jsn.has('disposition') or jsn.has('_disposition') then
        result.dispositionElement := ParseString(jsn.node['disposition'], jsn.vObj['_disposition']);{q}
    if jsn.has('payeeType') then
        result.payeeType := ParseCoding(jsn.vObj['payeeType']);{q3}
    if jsn.has('item') then
      iterateArray(jsn.vArr['item'], result.itemList, parseClaimResponseItem);
    if jsn.has('addItem') then
      iterateArray(jsn.vArr['addItem'], result.addItemList, parseClaimResponseAddItem);
    if jsn.has('error') then
      iterateArray(jsn.vArr['error'], result.errorList, parseClaimResponseError);
    if jsn.has('totalCost') then
        result.totalCost := ParseQuantity(jsn.vObj['totalCost']);{q3}
    if jsn.has('unallocDeductable') then
        result.unallocDeductable := ParseQuantity(jsn.vObj['unallocDeductable']);{q3}
    if jsn.has('totalBenefit') then
        result.totalBenefit := ParseQuantity(jsn.vObj['totalBenefit']);{q3}
    if jsn.has('paymentAdjustment') then
        result.paymentAdjustment := ParseQuantity(jsn.vObj['paymentAdjustment']);{q3}
    if jsn.has('paymentAdjustmentReason') then
        result.paymentAdjustmentReason := ParseCoding(jsn.vObj['paymentAdjustmentReason']);{q3}
    if jsn.has('paymentDate') or jsn.has('_paymentDate') then
        result.paymentDateElement := ParseDate(jsn.node['paymentDate'], jsn.vObj['_paymentDate']);{q}
    if jsn.has('paymentAmount') then
        result.paymentAmount := ParseQuantity(jsn.vObj['paymentAmount']);{q3}
    if jsn.has('paymentRef') then
        result.paymentRef := ParseIdentifier(jsn.vObj['paymentRef']);{q3}
    if jsn.has('reserved') then
        result.reserved := ParseCoding(jsn.vObj['reserved']);{q3}
    if jsn.has('form') then
        result.form := ParseCoding(jsn.vObj['form']);{q3}
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseClaimResponseNote);
    if jsn.has('coverage') then
      iterateArray(jsn.vArr['coverage'], result.coverageList, parseClaimResponseCoverage);
end;

procedure TFHIRJsonComposer.ComposeClaimResponse(json : TJSONWriter; name : string; elem : TFhirClaimResponse; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('request') then
    ComposeReference{TFhirClaim}(json, 'request', elem.request); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ruleset') then
    ComposeCoding(json, 'ruleset', elem.ruleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('originalRuleset') then
    ComposeCoding(json, 'originalRuleset', elem.originalRuleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestProvider') then
    ComposeReference{TFhirPractitioner}(json, 'requestProvider', elem.requestProvider); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestOrganization') then
    ComposeReference{TFhirOrganization}(json, 'requestOrganization', elem.requestOrganization); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcome') then
    ComposeEnumValue(json, 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcome') then
    ComposeEnumProps(json, 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('disposition') then
    ComposeStringValue(json, 'disposition', elem.dispositionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('disposition') then
    ComposeStringProps(json, 'disposition', elem.dispositionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('payeeType') then
    ComposeCoding(json, 'payeeType', elem.payeeType); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('item') and (elem.itemList.Count > 0) then
  begin
    startArray(json, 'item', elem.itemList, false);
    for i := 0 to elem.itemList.Count - 1 do
      ComposeClaimResponseItem(json, '', elem.itemList[i]); {z - }
    finishArray(json, elem.itemList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('addItem') and (elem.addItemList.Count > 0) then
  begin
    startArray(json, 'addItem', elem.addItemList, false);
    for i := 0 to elem.addItemList.Count - 1 do
      ComposeClaimResponseAddItem(json, '', elem.addItemList[i]); {z - }
    finishArray(json, elem.addItemList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('error') and (elem.errorList.Count > 0) then
  begin
    startArray(json, 'error', elem.errorList, false);
    for i := 0 to elem.errorList.Count - 1 do
      ComposeClaimResponseError(json, '', elem.errorList[i]); {z - }
    finishArray(json, elem.errorList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('totalCost') then
    ComposeQuantity(json, 'totalCost', elem.totalCost); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('unallocDeductable') then
    ComposeQuantity(json, 'unallocDeductable', elem.unallocDeductable); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('totalBenefit') then
    ComposeQuantity(json, 'totalBenefit', elem.totalBenefit); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('paymentAdjustment') then
    ComposeQuantity(json, 'paymentAdjustment', elem.paymentAdjustment); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('paymentAdjustmentReason') then
    ComposeCoding(json, 'paymentAdjustmentReason', elem.paymentAdjustmentReason); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('paymentDate') then
    ComposeDateValue(json, 'paymentDate', elem.paymentDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('paymentDate') then
    ComposeDateProps(json, 'paymentDate', elem.paymentDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('paymentAmount') then
    ComposeQuantity(json, 'paymentAmount', elem.paymentAmount); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('paymentRef') then
    ComposeIdentifier(json, 'paymentRef', elem.paymentRef); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reserved') then
    ComposeCoding(json, 'reserved', elem.reserved); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('form') then
    ComposeCoding(json, 'form', elem.form); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('note') and (elem.noteList.Count > 0) then
  begin
    startArray(json, 'note', elem.noteList, false);
    for i := 0 to elem.noteList.Count - 1 do
      ComposeClaimResponseNote(json, '', elem.noteList[i]); {z - }
    finishArray(json, elem.noteList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('coverage') and (elem.coverageList.Count > 0) then
  begin
    startArray(json, 'coverage', elem.coverageList, false);
    for i := 0 to elem.coverageList.Count - 1 do
      ComposeClaimResponseCoverage(json, '', elem.coverageList[i]); {z - }
    finishArray(json, elem.coverageList);
  end;
end;

{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
procedure TFHIRJsonParser.ParseClinicalImpressionInvestigations(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClinicalImpressionInvestigations(jsn)); {2}
end;

function TFHIRJsonParser.ParseClinicalImpressionInvestigations(jsn : TJsonObject) : TFhirClinicalImpressionInvestigations;
begin
  result := TFhirClinicalImpressionInvestigations.create;
  try
    ParseClinicalImpressionInvestigationsProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClinicalImpressionInvestigationsProperties(jsn : TJsonObject; result : TFhirClinicalImpressionInvestigations);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('item') then
      iterateArray(jsn.vArr['item'], result.itemList, parseReference{Resource});
end;

procedure TFHIRJsonComposer.ComposeClinicalImpressionInvestigations(json : TJSONWriter; name : string; elem : TFhirClinicalImpressionInvestigations; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soData]) and (elem.itemList.Count > 0) then
  begin
    startArray(json, 'item', elem.itemList, false);
    for i := 0 to elem.itemList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.itemList[i]); {z - Reference(Observation|QuestionnaireResponse|FamilyMemberHistory|DiagnosticReport)}
    finishArray(json, elem.itemList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseClinicalImpressionFinding(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClinicalImpressionFinding(jsn)); {2}
end;

function TFHIRJsonParser.ParseClinicalImpressionFinding(jsn : TJsonObject) : TFhirClinicalImpressionFinding;
begin
  result := TFhirClinicalImpressionFinding.create;
  try
    ParseClinicalImpressionFindingProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClinicalImpressionFindingProperties(jsn : TJsonObject; result : TFhirClinicalImpressionFinding);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('item') then
        result.item := ParseCodeableConcept(jsn.vObj['item']);{q3}
    if jsn.has('cause') or jsn.has('_cause') then
        result.causeElement := ParseString(jsn.node['cause'], jsn.vObj['_cause']);{q}
end;

procedure TFHIRJsonComposer.ComposeClinicalImpressionFinding(json : TJSONWriter; name : string; elem : TFhirClinicalImpressionFinding; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'item', elem.item); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'cause', elem.causeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'cause', elem.causeElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseClinicalImpressionRuledOut(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClinicalImpressionRuledOut(jsn)); {2}
end;

function TFHIRJsonParser.ParseClinicalImpressionRuledOut(jsn : TJsonObject) : TFhirClinicalImpressionRuledOut;
begin
  result := TFhirClinicalImpressionRuledOut.create;
  try
    ParseClinicalImpressionRuledOutProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClinicalImpressionRuledOutProperties(jsn : TJsonObject; result : TFhirClinicalImpressionRuledOut);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('item') then
        result.item := ParseCodeableConcept(jsn.vObj['item']);{q3}
    if jsn.has('reason') or jsn.has('_reason') then
        result.reasonElement := ParseString(jsn.node['reason'], jsn.vObj['_reason']);{q}
end;

procedure TFHIRJsonComposer.ComposeClinicalImpressionRuledOut(json : TJSONWriter; name : string; elem : TFhirClinicalImpressionRuledOut; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'item', elem.item); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'reason', elem.reasonElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'reason', elem.reasonElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseClinicalImpression(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseClinicalImpression(jsn)); {2}
end;

function TFHIRJsonParser.ParseClinicalImpression(jsn : TJsonObject) : TFhirClinicalImpression;
begin
  result := TFhirClinicalImpression.create;
  try
    ParseClinicalImpressionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseClinicalImpressionProperties(jsn : TJsonObject; result : TFhirClinicalImpression);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
    if jsn.has('assessor') then
        result.assessor := ParseReference{TFhirPractitioner}(jsn.vObj['assessor']);{q3}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirClinicalImpressionStatusEnum, SYSTEMS_TFhirClinicalImpressionStatusEnum);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('previous') then
        result.previous := ParseReference{TFhirClinicalImpression}(jsn.vObj['previous']);{q3}
    if jsn.has('problem') then
      iterateArray(jsn.vArr['problem'], result.problemList, parseReference{Resource});
    if jsn.has('triggerCodeableConcept') {a4} then
      result.trigger := ParseCodeableConcept(jsn.vObj['triggerCodeableConcept']);
    if jsn.has('triggerReference') {a3} then
      result.trigger := ParseReference(jsn.vObj['triggerReference']);
    if jsn.has('investigations') then
      iterateArray(jsn.vArr['investigations'], result.investigationsList, parseClinicalImpressionInvestigations);
    if jsn.has('protocol') or jsn.has('_protocol') then
        result.protocolElement := ParseUri(jsn.node['protocol'], jsn.vObj['_protocol']);{q}
    if jsn.has('summary') or jsn.has('_summary') then
        result.summaryElement := ParseString(jsn.node['summary'], jsn.vObj['_summary']);{q}
    if jsn.has('finding') then
      iterateArray(jsn.vArr['finding'], result.findingList, parseClinicalImpressionFinding);
    if jsn.has('resolved') then
      iterateArray(jsn.vArr['resolved'], result.resolvedList, parseCodeableConcept);
    if jsn.has('ruledOut') then
      iterateArray(jsn.vArr['ruledOut'], result.ruledOutList, parseClinicalImpressionRuledOut);
    if jsn.has('prognosis') or jsn.has('_prognosis') then
        result.prognosisElement := ParseString(jsn.node['prognosis'], jsn.vObj['_prognosis']);{q}
    if jsn.has('plan') then
      iterateArray(jsn.vArr['plan'], result.planList, parseReference{Resource});
    if jsn.has('action') then
      iterateArray(jsn.vArr['action'], result.actionList, parseReference{Resource});
end;

procedure TFHIRJsonComposer.ComposeClinicalImpression(json : TJSONWriter; name : string; elem : TFhirClinicalImpression; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('assessor') then
    ComposeReference{TFhirPractitioner}(json, 'assessor', elem.assessor); {a}
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirClinicalImpressionStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirClinicalImpressionStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('previous') then
    ComposeReference{TFhirClinicalImpression}(json, 'previous', elem.previous); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('problem') and (elem.problemList.Count > 0) then
  begin
    startArray(json, 'problem', elem.problemList, false);
    for i := 0 to elem.problemList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.problemList[i]); {z - Reference(Condition|AllergyIntolerance)}
    finishArray(json, elem.problemList);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.trigger is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'triggerCodeableConcept', TFhirCodeableConcept(elem.trigger)) 
  else if (SummaryOption in [soFull, soData]) and (elem.trigger is TFhirReference) then
    ComposeReference(json, 'triggerReference', TFhirReference(elem.trigger));
  if (SummaryOption in [soFull, soData]) and doCompose('investigations') and (elem.investigationsList.Count > 0) then
  begin
    startArray(json, 'investigations', elem.investigationsList, false);
    for i := 0 to elem.investigationsList.Count - 1 do
      ComposeClinicalImpressionInvestigations(json, '', elem.investigationsList[i]); {z - }
    finishArray(json, elem.investigationsList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('protocol') then
    ComposeUriValue(json, 'protocol', elem.protocolElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('protocol') then
    ComposeUriProps(json, 'protocol', elem.protocolElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('summary') then
    ComposeStringValue(json, 'summary', elem.summaryElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('summary') then
    ComposeStringProps(json, 'summary', elem.summaryElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('finding') and (elem.findingList.Count > 0) then
  begin
    startArray(json, 'finding', elem.findingList, false);
    for i := 0 to elem.findingList.Count - 1 do
      ComposeClinicalImpressionFinding(json, '', elem.findingList[i]); {z - }
    finishArray(json, elem.findingList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('resolved') and (elem.resolvedList.Count > 0) then
  begin
    startArray(json, 'resolved', elem.resolvedList, false);
    for i := 0 to elem.resolvedList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.resolvedList[i]); {z - CodeableConcept}
    finishArray(json, elem.resolvedList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('ruledOut') and (elem.ruledOutList.Count > 0) then
  begin
    startArray(json, 'ruledOut', elem.ruledOutList, false);
    for i := 0 to elem.ruledOutList.Count - 1 do
      ComposeClinicalImpressionRuledOut(json, '', elem.ruledOutList[i]); {z - }
    finishArray(json, elem.ruledOutList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('prognosis') then
    ComposeStringValue(json, 'prognosis', elem.prognosisElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('prognosis') then
    ComposeStringProps(json, 'prognosis', elem.prognosisElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('plan') and (elem.planList.Count > 0) then
  begin
    startArray(json, 'plan', elem.planList, false);
    for i := 0 to elem.planList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.planList[i]); {z - Reference(CarePlan|Appointment|CommunicationRequest|DeviceUseRequest|DiagnosticOrder|MedicationOrder|NutritionOrder|Order|ProcedureRequest|ProcessRequest|ReferralRequest|SupplyRequest|VisionPrescription)}
    finishArray(json, elem.planList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('action') and (elem.actionList.Count > 0) then
  begin
    startArray(json, 'action', elem.actionList, false);
    for i := 0 to elem.actionList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.actionList[i]); {z - Reference(ReferralRequest|ProcedureRequest|Procedure|MedicationOrder|DiagnosticOrder|NutritionOrder|SupplyRequest|Appointment)}
    finishArray(json, elem.actionList);
  end;
end;

{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_COMMUNICATION}
procedure TFHIRJsonParser.ParseCommunicationPayload(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCommunicationPayload(jsn)); {2}
end;

function TFHIRJsonParser.ParseCommunicationPayload(jsn : TJsonObject) : TFhirCommunicationPayload;
begin
  result := TFhirCommunicationPayload.create;
  try
    ParseCommunicationPayloadProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCommunicationPayloadProperties(jsn : TJsonObject; result : TFhirCommunicationPayload);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('contentAttachment') {a4} then
      result.content := ParseAttachment(jsn.vObj['contentAttachment']);
    if jsn.has('contentReference') {a3} then
      result.content := ParseReference(jsn.vObj['contentReference']);
    if jsn.has('contentString') or jsn.has('_contentString') then
      result.content := ParseString(jsn.node['contentString'], jsn.vObj['_contentString']);
end;

procedure TFHIRJsonComposer.ComposeCommunicationPayload(json : TJSONWriter; name : string; elem : TFhirCommunicationPayload; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (elem.content is TFhirAttachment) then 
    ComposeAttachment(json, 'contentAttachment', TFhirAttachment(elem.content)) 
  else if (elem.content is TFhirReference) then
    ComposeReference(json, 'contentReference', TFhirReference(elem.content))
  else if (elem.content is TFhirString) then 
  begin
    ComposeStringValue(json, 'contentString', TFhirString(elem.content), false);
    ComposeStringProps(json, 'contentString', TFhirString(elem.content), false);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseCommunication(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCommunication(jsn)); {2}
end;

function TFHIRJsonParser.ParseCommunication(jsn : TJsonObject) : TFhirCommunication;
begin
  result := TFhirCommunication.create;
  try
    ParseCommunicationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCommunicationProperties(jsn : TJsonObject; result : TFhirCommunication);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q3}
    if jsn.has('sender') then
        result.sender := ParseReference{Resource}(jsn.vObj['sender']);{q3}
    if jsn.has('recipient') then
      iterateArray(jsn.vArr['recipient'], result.recipientList, parseReference{Resource});
    if jsn.has('payload') then
      iterateArray(jsn.vArr['payload'], result.payloadList, parseCommunicationPayload);
    if jsn.has('medium') then
      iterateArray(jsn.vArr['medium'], result.mediumList, parseCodeableConcept);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirCommunicationStatusEnum, SYSTEMS_TFhirCommunicationStatusEnum);
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('sent') or jsn.has('_sent') then
        result.sentElement := ParseDateTime(jsn.node['sent'], jsn.vObj['_sent']);{q}
    if jsn.has('received') or jsn.has('_received') then
        result.receivedElement := ParseDateTime(jsn.node['received'], jsn.vObj['_received']);{q}
    if jsn.has('reason') then
      iterateArray(jsn.vArr['reason'], result.reasonList, parseCodeableConcept);
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q3}
    if jsn.has('requestDetail') then
        result.requestDetail := ParseReference{TFhirCommunicationRequest}(jsn.vObj['requestDetail']);{q3}
end;

procedure TFHIRJsonComposer.ComposeCommunication(json : TJSONWriter; name : string; elem : TFhirCommunication; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeCodeableConcept(json, 'category', elem.category); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('sender') then
    ComposeReference{Resource}(json, 'sender', elem.sender); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recipient') and (elem.recipientList.Count > 0) then
  begin
    startArray(json, 'recipient', elem.recipientList, false);
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.recipientList[i]); {z - Reference(Device|Organization|Patient|Practitioner|RelatedPerson|Group)}
    finishArray(json, elem.recipientList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('payload') and (elem.payloadList.Count > 0) then
  begin
    startArray(json, 'payload', elem.payloadList, false);
    for i := 0 to elem.payloadList.Count - 1 do
      ComposeCommunicationPayload(json, '', elem.payloadList[i]); {z - }
    finishArray(json, elem.payloadList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('medium') and (elem.mediumList.Count > 0) then
  begin
    startArray(json, 'medium', elem.mediumList, false);
    for i := 0 to elem.mediumList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.mediumList[i]); {z - CodeableConcept}
    finishArray(json, elem.mediumList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirCommunicationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirCommunicationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('sent') then
    ComposeDateTimeValue(json, 'sent', elem.sentElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('sent') then
    ComposeDateTimeProps(json, 'sent', elem.sentElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('received') then
    ComposeDateTimeValue(json, 'received', elem.receivedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('received') then
    ComposeDateTimeProps(json, 'received', elem.receivedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reason') and (elem.reasonList.Count > 0) then
  begin
    startArray(json, 'reason', elem.reasonList, false);
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonList[i]); {z - CodeableConcept}
    finishArray(json, elem.reasonList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestDetail') then
    ComposeReference{TFhirCommunicationRequest}(json, 'requestDetail', elem.requestDetail); {a}
end;

{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
procedure TFHIRJsonParser.ParseCommunicationRequestPayload(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCommunicationRequestPayload(jsn)); {2}
end;

function TFHIRJsonParser.ParseCommunicationRequestPayload(jsn : TJsonObject) : TFhirCommunicationRequestPayload;
begin
  result := TFhirCommunicationRequestPayload.create;
  try
    ParseCommunicationRequestPayloadProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCommunicationRequestPayloadProperties(jsn : TJsonObject; result : TFhirCommunicationRequestPayload);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('contentAttachment') {a4} then
      result.content := ParseAttachment(jsn.vObj['contentAttachment']);
    if jsn.has('contentReference') {a3} then
      result.content := ParseReference(jsn.vObj['contentReference']);
    if jsn.has('contentString') or jsn.has('_contentString') then
      result.content := ParseString(jsn.node['contentString'], jsn.vObj['_contentString']);
end;

procedure TFHIRJsonComposer.ComposeCommunicationRequestPayload(json : TJSONWriter; name : string; elem : TFhirCommunicationRequestPayload; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (elem.content is TFhirAttachment) then 
    ComposeAttachment(json, 'contentAttachment', TFhirAttachment(elem.content)) 
  else if (elem.content is TFhirReference) then
    ComposeReference(json, 'contentReference', TFhirReference(elem.content))
  else if (elem.content is TFhirString) then 
  begin
    ComposeStringValue(json, 'contentString', TFhirString(elem.content), false);
    ComposeStringProps(json, 'contentString', TFhirString(elem.content), false);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseCommunicationRequest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCommunicationRequest(jsn)); {2}
end;

function TFHIRJsonParser.ParseCommunicationRequest(jsn : TJsonObject) : TFhirCommunicationRequest;
begin
  result := TFhirCommunicationRequest.create;
  try
    ParseCommunicationRequestProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCommunicationRequestProperties(jsn : TJsonObject; result : TFhirCommunicationRequest);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q3}
    if jsn.has('sender') then
        result.sender := ParseReference{Resource}(jsn.vObj['sender']);{q3}
    if jsn.has('recipient') then
      iterateArray(jsn.vArr['recipient'], result.recipientList, parseReference{Resource});
    if jsn.has('payload') then
      iterateArray(jsn.vArr['payload'], result.payloadList, parseCommunicationRequestPayload);
    if jsn.has('medium') then
      iterateArray(jsn.vArr['medium'], result.mediumList, parseCodeableConcept);
    if jsn.has('requester') then
        result.requester := ParseReference{Resource}(jsn.vObj['requester']);{q3}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirCommunicationRequestStatusEnum, SYSTEMS_TFhirCommunicationRequestStatusEnum);
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('scheduledPeriod') {a4} then
      result.scheduled := ParsePeriod(jsn.vObj['scheduledPeriod']);
    if jsn.has('scheduledDateTime') or jsn.has('_scheduledDateTime') then
      result.scheduled := ParseDateTime(jsn.node['scheduledDateTime'], jsn.vObj['_scheduledDateTime']);
    if jsn.has('reason') then
      iterateArray(jsn.vArr['reason'], result.reasonList, parseCodeableConcept);
    if jsn.has('requestedOn') or jsn.has('_requestedOn') then
        result.requestedOnElement := ParseDateTime(jsn.node['requestedOn'], jsn.vObj['_requestedOn']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q3}
    if jsn.has('priority') then
        result.priority := ParseCodeableConcept(jsn.vObj['priority']);{q3}
end;

procedure TFHIRJsonComposer.ComposeCommunicationRequest(json : TJSONWriter; name : string; elem : TFhirCommunicationRequest; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeCodeableConcept(json, 'category', elem.category); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('sender') then
    ComposeReference{Resource}(json, 'sender', elem.sender); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recipient') and (elem.recipientList.Count > 0) then
  begin
    startArray(json, 'recipient', elem.recipientList, false);
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.recipientList[i]); {z - Reference(Device|Organization|Patient|Practitioner|RelatedPerson)}
    finishArray(json, elem.recipientList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('payload') and (elem.payloadList.Count > 0) then
  begin
    startArray(json, 'payload', elem.payloadList, false);
    for i := 0 to elem.payloadList.Count - 1 do
      ComposeCommunicationRequestPayload(json, '', elem.payloadList[i]); {z - }
    finishArray(json, elem.payloadList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('medium') and (elem.mediumList.Count > 0) then
  begin
    startArray(json, 'medium', elem.mediumList, false);
    for i := 0 to elem.mediumList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.mediumList[i]); {z - CodeableConcept}
    finishArray(json, elem.mediumList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requester') then
    ComposeReference{Resource}(json, 'requester', elem.requester); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirCommunicationRequestStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirCommunicationRequestStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.scheduled is TFhirPeriod) then 
    ComposePeriod(json, 'scheduledPeriod', TFhirPeriod(elem.scheduled)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.scheduled is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'scheduledDateTime', TFhirDateTime(elem.scheduled), false);
    ComposeDateTimeProps(json, 'scheduledDateTime', TFhirDateTime(elem.scheduled), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reason') and (elem.reasonList.Count > 0) then
  begin
    startArray(json, 'reason', elem.reasonList, false);
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonList[i]); {z - CodeableConcept}
    finishArray(json, elem.reasonList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestedOn') then
    ComposeDateTimeValue(json, 'requestedOn', elem.requestedOnElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestedOn') then
    ComposeDateTimeProps(json, 'requestedOn', elem.requestedOnElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeCodeableConcept(json, 'priority', elem.priority); {a}
end;

{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPOSITION}
procedure TFHIRJsonParser.ParseCompositionAttester(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCompositionAttester(jsn)); {2}
end;

function TFHIRJsonParser.ParseCompositionAttester(jsn : TJsonObject) : TFhirCompositionAttester;
begin
  result := TFhirCompositionAttester.create;
  try
    ParseCompositionAttesterProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCompositionAttesterProperties(jsn : TJsonObject; result : TFhirCompositionAttester);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('mode') or jsn.has('_mode') then
      iterateEnumArray(jsn.vArr['mode'], jsn.vArr['_mode'], jsn.path+'/mode', result.modeList, parseEnum, CODES_TFhirCompositionAttestationModeEnum, SYSTEMS_TFhirCompositionAttestationModeEnum);
    if jsn.has('time') or jsn.has('_time') then
        result.timeElement := ParseDateTime(jsn.node['time'], jsn.vObj['_time']);{q}
    if jsn.has('party') then
        result.party := ParseReference{Resource}(jsn.vObj['party']);{q3}
end;

procedure TFHIRJsonComposer.ComposeCompositionAttester(json : TJSONWriter; name : string; elem : TFhirCompositionAttester; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (elem.modeList.Count > 0) then
  begin
    val := false;
    ext := false;
    for i := 0 to elem.modeList.Count - 1 do
    begin
      val := val or (elem.modeList[i].hasPrimitiveValue);
      ext := ext or ((elem.modeList[i].id <> '') or (elem.modeList[i].hasExtensionList));
    end;
    if val then
    begin
      startArray(json, 'mode', elem.modeList, true);
      for i := 0 to elem.modeList.Count - 1 do
        ComposeEnumValue(json, '', elem.modeList[i], CODES_TFhirCompositionAttestationModeEnum, true);
      finishArray(json, elem.modeList);
    end;
    if ext then
    begin
      startArray(json, '_mode', elem.modeList, false);
      for i := 0 to elem.modeList.Count - 1 do
        ComposeEnumProps(json, '', elem.modeList[i], CODES_TFhirCompositionAttestationModeEnum, true);
      finishArray(json, elem.modeList);
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'time', elem.timeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'time', elem.timeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'party', elem.party); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseCompositionEvent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCompositionEvent(jsn)); {2}
end;

function TFHIRJsonParser.ParseCompositionEvent(jsn : TJsonObject) : TFhirCompositionEvent;
begin
  result := TFhirCompositionEvent.create;
  try
    ParseCompositionEventProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCompositionEventProperties(jsn : TJsonObject; result : TFhirCompositionEvent);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
      iterateArray(jsn.vArr['code'], result.codeList, parseCodeableConcept);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
    if jsn.has('detail') then
      iterateArray(jsn.vArr['detail'], result.detailList, parseReference{TFhirReference});
end;

procedure TFHIRJsonComposer.ComposeCompositionEvent(json : TJSONWriter; name : string; elem : TFhirCompositionEvent; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.codeList.Count > 0) then
  begin
    startArray(json, 'code', elem.codeList, false);
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.codeList[i]); {z - CodeableConcept}
    finishArray(json, elem.codeList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.detailList.Count > 0) then
  begin
    startArray(json, 'detail', elem.detailList, false);
    for i := 0 to elem.detailList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.detailList[i]); {z - Reference(Any)}
    finishArray(json, elem.detailList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseCompositionSection(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCompositionSection(jsn)); {2}
end;

function TFHIRJsonParser.ParseCompositionSection(jsn : TJsonObject) : TFhirCompositionSection;
begin
  result := TFhirCompositionSection.create;
  try
    ParseCompositionSectionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCompositionSectionProperties(jsn : TJsonObject; result : TFhirCompositionSection);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := ParseString(jsn.node['title'], jsn.vObj['_title']);{q}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('text') then
        result.text := ParseNarrative(jsn.vObj['text']);{q3}
    if jsn.has('mode') or jsn.has('_mode')  then
      result.modeElement := parseEnum(jsn.path+'/mode', jsn.node['mode'], jsn.vObj['_mode'], CODES_TFhirListModeEnum, SYSTEMS_TFhirListModeEnum);
    if jsn.has('orderedBy') then
        result.orderedBy := ParseCodeableConcept(jsn.vObj['orderedBy']);{q3}
    if jsn.has('entry') then
      iterateArray(jsn.vArr['entry'], result.entryList, parseReference{TFhirReference});
    if jsn.has('emptyReason') then
        result.emptyReason := ParseCodeableConcept(jsn.vObj['emptyReason']);{q3}
    if jsn.has('section') then
      iterateArray(jsn.vArr['section'], result.sectionList, parseCompositionSection);
end;

procedure TFHIRJsonComposer.ComposeCompositionSection(json : TJSONWriter; name : string; elem : TFhirCompositionSection; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeNarrative(json, 'text', elem.text); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumValue(json, 'mode', elem.ModeElement, CODES_TFhirListModeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumProps(json, 'mode', elem.ModeElement, CODES_TFhirListModeEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'orderedBy', elem.orderedBy); {a}
  if (SummaryOption in [soFull, soData]) and (elem.entryList.Count > 0) then
  begin
    startArray(json, 'entry', elem.entryList, false);
    for i := 0 to elem.entryList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.entryList[i]); {z - Reference(Any)}
    finishArray(json, elem.entryList);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'emptyReason', elem.emptyReason); {a}
  if (SummaryOption in [soFull, soData]) and (elem.sectionList.Count > 0) then
  begin
    startArray(json, 'section', elem.sectionList, false);
    for i := 0 to elem.sectionList.Count - 1 do
      ComposeCompositionSection(json, '', elem.sectionList[i]); {z - @Composition.section}
    finishArray(json, elem.sectionList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseComposition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseComposition(jsn)); {2}
end;

function TFHIRJsonParser.ParseComposition(jsn : TJsonObject) : TFhirComposition;
begin
  result := TFhirComposition.create;
  try
    ParseCompositionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCompositionProperties(jsn : TJsonObject; result : TFhirComposition);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('class') then
        result.class_ := ParseCodeableConcept(jsn.vObj['class']);{q3}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := ParseString(jsn.node['title'], jsn.vObj['_title']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirCompositionStatusEnum, SYSTEMS_TFhirCompositionStatusEnum);
    if jsn.has('confidentiality') or jsn.has('_confidentiality')  then
      result.confidentialityElement := parseEnum(jsn.path+'/confidentiality', jsn.node['confidentiality'], jsn.vObj['_confidentiality'], CODES_TFhirV3ConfidentialityEnum, SYSTEMS_TFhirV3ConfidentialityEnum);
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirReference}(jsn.vObj['subject']);{q3}
    if jsn.has('author') then
      iterateArray(jsn.vArr['author'], result.authorList, parseReference{Resource});
    if jsn.has('attester') then
      iterateArray(jsn.vArr['attester'], result.attesterList, parseCompositionAttester);
    if jsn.has('custodian') then
        result.custodian := ParseReference{TFhirOrganization}(jsn.vObj['custodian']);{q3}
    if jsn.has('event') then
      iterateArray(jsn.vArr['event'], result.eventList, parseCompositionEvent);
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('section') then
      iterateArray(jsn.vArr['section'], result.sectionList, parseCompositionSection);
end;

procedure TFHIRJsonComposer.ComposeComposition(json : TJSONWriter; name : string; elem : TFhirComposition; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('class_') then
    ComposeCodeableConcept(json, 'class', elem.class_); {a}
  ComposeStringValue(json, 'title', elem.titleElement, false);
  ComposeStringProps(json, 'title', elem.titleElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirCompositionStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirCompositionStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('confidentiality') then
    ComposeEnumValue(json, 'confidentiality', elem.ConfidentialityElement, CODES_TFhirV3ConfidentialityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('confidentiality') then
    ComposeEnumProps(json, 'confidentiality', elem.ConfidentialityElement, CODES_TFhirV3ConfidentialityEnum, false);
  ComposeReference{TFhirReference}(json, 'subject', elem.subject); {a}
  if (elem.authorList.Count > 0) then
  begin
    startArray(json, 'author', elem.authorList, false);
    for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.authorList[i]); {z - Reference(Practitioner|Device|Patient|RelatedPerson)}
    finishArray(json, elem.authorList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('attester') and (elem.attesterList.Count > 0) then
  begin
    startArray(json, 'attester', elem.attesterList, false);
    for i := 0 to elem.attesterList.Count - 1 do
      ComposeCompositionAttester(json, '', elem.attesterList[i]); {z - }
    finishArray(json, elem.attesterList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('custodian') then
    ComposeReference{TFhirOrganization}(json, 'custodian', elem.custodian); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('event') and (elem.eventList.Count > 0) then
  begin
    startArray(json, 'event', elem.eventList, false);
    for i := 0 to elem.eventList.Count - 1 do
      ComposeCompositionEvent(json, '', elem.eventList[i]); {z - }
    finishArray(json, elem.eventList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('section') and (elem.sectionList.Count > 0) then
  begin
    startArray(json, 'section', elem.sectionList, false);
    for i := 0 to elem.sectionList.Count - 1 do
      ComposeCompositionSection(json, '', elem.sectionList[i]); {z - }
    finishArray(json, elem.sectionList);
  end;
end;

{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
procedure TFHIRJsonParser.ParseConceptMapContact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConceptMapContact(jsn)); {2}
end;

function TFHIRJsonParser.ParseConceptMapContact(jsn : TJsonObject) : TFhirConceptMapContact;
begin
  result := TFhirConceptMapContact.create;
  try
    ParseConceptMapContactProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseConceptMapContactProperties(jsn : TJsonObject; result : TFhirConceptMapContact);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
end;

procedure TFHIRJsonComposer.ComposeConceptMapContact(json : TJSONWriter; name : string; elem : TFhirConceptMapContact; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.telecomList.Count > 0) then
  begin
    startArray(json, 'telecom', elem.telecomList, false);
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    finishArray(json, elem.telecomList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseConceptMapElement(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConceptMapElement(jsn)); {2}
end;

function TFHIRJsonParser.ParseConceptMapElement(jsn : TJsonObject) : TFhirConceptMapElement;
begin
  result := TFhirConceptMapElement.create;
  try
    ParseConceptMapElementProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseConceptMapElementProperties(jsn : TJsonObject; result : TFhirConceptMapElement);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('codeSystem') or jsn.has('_codeSystem') then
        result.codeSystemElement := ParseUri(jsn.node['codeSystem'], jsn.vObj['_codeSystem']);{q}
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := ParseCode(jsn.node['code'], jsn.vObj['_code']);{q}
    if jsn.has('target') then
      iterateArray(jsn.vArr['target'], result.targetList, parseConceptMapElementTarget);
end;

procedure TFHIRJsonComposer.ComposeConceptMapElement(json : TJSONWriter; name : string; elem : TFhirConceptMapElement; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriValue(json, 'codeSystem', elem.codeSystemElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriProps(json, 'codeSystem', elem.codeSystemElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeValue(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeProps(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.targetList.Count > 0) then
  begin
    startArray(json, 'target', elem.targetList, false);
    for i := 0 to elem.targetList.Count - 1 do
      ComposeConceptMapElementTarget(json, '', elem.targetList[i]); {z - }
    finishArray(json, elem.targetList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseConceptMapElementTarget(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConceptMapElementTarget(jsn)); {2}
end;

function TFHIRJsonParser.ParseConceptMapElementTarget(jsn : TJsonObject) : TFhirConceptMapElementTarget;
begin
  result := TFhirConceptMapElementTarget.create;
  try
    ParseConceptMapElementTargetProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseConceptMapElementTargetProperties(jsn : TJsonObject; result : TFhirConceptMapElementTarget);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('codeSystem') or jsn.has('_codeSystem') then
        result.codeSystemElement := ParseUri(jsn.node['codeSystem'], jsn.vObj['_codeSystem']);{q}
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := ParseCode(jsn.node['code'], jsn.vObj['_code']);{q}
    if jsn.has('equivalence') or jsn.has('_equivalence')  then
      result.equivalenceElement := parseEnum(jsn.path+'/equivalence', jsn.node['equivalence'], jsn.vObj['_equivalence'], CODES_TFhirConceptMapEquivalenceEnum, SYSTEMS_TFhirConceptMapEquivalenceEnum);
    if jsn.has('comments') or jsn.has('_comments') then
        result.commentsElement := ParseString(jsn.node['comments'], jsn.vObj['_comments']);{q}
    if jsn.has('dependsOn') then
      iterateArray(jsn.vArr['dependsOn'], result.dependsOnList, parseConceptMapElementTargetDependsOn);
    if jsn.has('product') then
      iterateArray(jsn.vArr['product'], result.productList, parseConceptMapElementTargetDependsOn);
end;

procedure TFHIRJsonComposer.ComposeConceptMapElementTarget(json : TJSONWriter; name : string; elem : TFhirConceptMapElementTarget; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriValue(json, 'codeSystem', elem.codeSystemElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriProps(json, 'codeSystem', elem.codeSystemElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeValue(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeProps(json, 'code', elem.codeElement, false);
  ComposeEnumValue(json, 'equivalence', elem.EquivalenceElement, CODES_TFhirConceptMapEquivalenceEnum, false);
  ComposeEnumProps(json, 'equivalence', elem.EquivalenceElement, CODES_TFhirConceptMapEquivalenceEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'comments', elem.commentsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'comments', elem.commentsElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.dependsOnList.Count > 0) then
  begin
    startArray(json, 'dependsOn', elem.dependsOnList, false);
    for i := 0 to elem.dependsOnList.Count - 1 do
      ComposeConceptMapElementTargetDependsOn(json, '', elem.dependsOnList[i]); {z - }
    finishArray(json, elem.dependsOnList);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.productList.Count > 0) then
  begin
    startArray(json, 'product', elem.productList, false);
    for i := 0 to elem.productList.Count - 1 do
      ComposeConceptMapElementTargetDependsOn(json, '', elem.productList[i]); {z - @ConceptMap.element.target.dependsOn}
    finishArray(json, elem.productList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseConceptMapElementTargetDependsOn(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConceptMapElementTargetDependsOn(jsn)); {2}
end;

function TFHIRJsonParser.ParseConceptMapElementTargetDependsOn(jsn : TJsonObject) : TFhirConceptMapElementTargetDependsOn;
begin
  result := TFhirConceptMapElementTargetDependsOn.create;
  try
    ParseConceptMapElementTargetDependsOnProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseConceptMapElementTargetDependsOnProperties(jsn : TJsonObject; result : TFhirConceptMapElementTargetDependsOn);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('element') or jsn.has('_element') then
        result.elementElement := ParseUri(jsn.node['element'], jsn.vObj['_element']);{q}
    if jsn.has('codeSystem') or jsn.has('_codeSystem') then
        result.codeSystemElement := ParseUri(jsn.node['codeSystem'], jsn.vObj['_codeSystem']);{q}
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := ParseString(jsn.node['code'], jsn.vObj['_code']);{q}
end;

procedure TFHIRJsonComposer.ComposeConceptMapElementTargetDependsOn(json : TJSONWriter; name : string; elem : TFhirConceptMapElementTargetDependsOn; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeUriValue(json, 'element', elem.elementElement, false);
  ComposeUriProps(json, 'element', elem.elementElement, false);
  ComposeUriValue(json, 'codeSystem', elem.codeSystemElement, false);
  ComposeUriProps(json, 'codeSystem', elem.codeSystemElement, false);
  ComposeStringValue(json, 'code', elem.codeElement, false);
  ComposeStringProps(json, 'code', elem.codeElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseConceptMap(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConceptMap(jsn)); {2}
end;

function TFHIRJsonParser.ParseConceptMap(jsn : TJsonObject) : TFhirConceptMap;
begin
  result := TFhirConceptMap.create;
  try
    ParseConceptMapProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseConceptMapProperties(jsn : TJsonObject; result : TFhirConceptMap);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := ParseBoolean(jsn.node['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := ParseString(jsn.node['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseConceptMapContact);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseCodeableConcept);
    if jsn.has('requirements') or jsn.has('_requirements') then
        result.requirementsElement := ParseString(jsn.node['requirements'], jsn.vObj['_requirements']);{q}
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := ParseString(jsn.node['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('sourceReference') {a3} then
      result.source := ParseReference(jsn.vObj['sourceReference']);
    if jsn.has('sourceUri') or jsn.has('_sourceUri') then
      result.source := ParseUri(jsn.node['sourceUri'], jsn.vObj['_sourceUri']);
    if jsn.has('targetReference') {a3} then
      result.target := ParseReference(jsn.vObj['targetReference']);
    if jsn.has('targetUri') or jsn.has('_targetUri') then
      result.target := ParseUri(jsn.node['targetUri'], jsn.vObj['_targetUri']);
    if jsn.has('element') then
      iterateArray(jsn.vArr['element'], result.elementList, parseConceptMapElement);
end;

procedure TFHIRJsonComposer.ComposeConceptMap(json : TJSONWriter; name : string; elem : TFhirConceptMap; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    startArray(json, 'contact', elem.contactList, false);
    for i := 0 to elem.contactList.Count - 1 do
      ComposeConceptMapContact(json, '', elem.contactList[i]); {z - }
    finishArray(json, elem.contactList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') and (elem.useContextList.Count > 0) then
  begin
    startArray(json, 'useContext', elem.useContextList, false);
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.useContextList[i]); {z - CodeableConcept}
    finishArray(json, elem.useContextList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('requirements') then
    ComposeStringValue(json, 'requirements', elem.requirementsElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('requirements') then
    ComposeStringProps(json, 'requirements', elem.requirementsElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeStringValue(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeStringProps(json, 'copyright', elem.copyrightElement, false);
  if (elem.source is TFhirReference) then
    ComposeReference(json, 'sourceReference', TFhirReference(elem.source))
  else if (elem.source is TFhirUri) then 
  begin
    ComposeUriValue(json, 'sourceUri', TFhirUri(elem.source), false);
    ComposeUriProps(json, 'sourceUri', TFhirUri(elem.source), false);
  end;
  if (elem.target is TFhirReference) then
    ComposeReference(json, 'targetReference', TFhirReference(elem.target))
  else if (elem.target is TFhirUri) then 
  begin
    ComposeUriValue(json, 'targetUri', TFhirUri(elem.target), false);
    ComposeUriProps(json, 'targetUri', TFhirUri(elem.target), false);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('element') and (elem.elementList.Count > 0) then
  begin
    startArray(json, 'element', elem.elementList, false);
    for i := 0 to elem.elementList.Count - 1 do
      ComposeConceptMapElement(json, '', elem.elementList[i]); {z - }
    finishArray(json, elem.elementList);
  end;
end;

{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
procedure TFHIRJsonParser.ParseConditionStage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConditionStage(jsn)); {2}
end;

function TFHIRJsonParser.ParseConditionStage(jsn : TJsonObject) : TFhirConditionStage;
begin
  result := TFhirConditionStage.create;
  try
    ParseConditionStageProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseConditionStageProperties(jsn : TJsonObject; result : TFhirConditionStage);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('summary') then
        result.summary := ParseCodeableConcept(jsn.vObj['summary']);{q3}
    if jsn.has('assessment') then
      iterateArray(jsn.vArr['assessment'], result.assessmentList, parseReference{Resource});
end;

procedure TFHIRJsonComposer.ComposeConditionStage(json : TJSONWriter; name : string; elem : TFhirConditionStage; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'summary', elem.summary); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.assessmentList.Count > 0) then
  begin
    startArray(json, 'assessment', elem.assessmentList, false);
    for i := 0 to elem.assessmentList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.assessmentList[i]); {z - Reference(ClinicalImpression|DiagnosticReport|Observation)}
    finishArray(json, elem.assessmentList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseConditionEvidence(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConditionEvidence(jsn)); {2}
end;

function TFHIRJsonParser.ParseConditionEvidence(jsn : TJsonObject) : TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence.create;
  try
    ParseConditionEvidenceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseConditionEvidenceProperties(jsn : TJsonObject; result : TFhirConditionEvidence);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('detail') then
      iterateArray(jsn.vArr['detail'], result.detailList, parseReference{TFhirReference});
end;

procedure TFHIRJsonComposer.ComposeConditionEvidence(json : TJSONWriter; name : string; elem : TFhirConditionEvidence; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.detailList.Count > 0) then
  begin
    startArray(json, 'detail', elem.detailList, false);
    for i := 0 to elem.detailList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.detailList[i]); {z - Reference(Any)}
    finishArray(json, elem.detailList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseCondition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCondition(jsn)); {2}
end;

function TFHIRJsonParser.ParseCondition(jsn : TJsonObject) : TFhirCondition;
begin
  result := TFhirCondition.create;
  try
    ParseConditionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseConditionProperties(jsn : TJsonObject; result : TFhirCondition);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('asserter') then
        result.asserter := ParseReference{Resource}(jsn.vObj['asserter']);{q3}
    if jsn.has('dateRecorded') or jsn.has('_dateRecorded') then
        result.dateRecordedElement := ParseDate(jsn.node['dateRecorded'], jsn.vObj['_dateRecorded']);{q}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q3}
    if jsn.has('clinicalStatus') or jsn.has('_clinicalStatus') then
        result.clinicalStatusElement := ParseCode(jsn.node['clinicalStatus'], jsn.vObj['_clinicalStatus']);{q}
    if jsn.has('verificationStatus') or jsn.has('_verificationStatus')  then
      result.verificationStatusElement := parseEnum(jsn.path+'/verificationStatus', jsn.node['verificationStatus'], jsn.vObj['_verificationStatus'], CODES_TFhirConditionVerStatusEnum, SYSTEMS_TFhirConditionVerStatusEnum);
    if jsn.has('severity') then
        result.severity := ParseCodeableConcept(jsn.vObj['severity']);{q3}
    if jsn.has('onsetQuantity') {a4} then
      result.onset := ParseQuantity(jsn.vObj['onsetQuantity']);
    if jsn.has('onsetPeriod') {a4} then
      result.onset := ParsePeriod(jsn.vObj['onsetPeriod']);
    if jsn.has('onsetRange') {a4} then
      result.onset := ParseRange(jsn.vObj['onsetRange']);
    if jsn.has('onsetDateTime') or jsn.has('_onsetDateTime') then
      result.onset := ParseDateTime(jsn.node['onsetDateTime'], jsn.vObj['_onsetDateTime']);
    if jsn.has('onsetString') or jsn.has('_onsetString') then
      result.onset := ParseString(jsn.node['onsetString'], jsn.vObj['_onsetString']);
    if jsn.has('abatementQuantity') {a4} then
      result.abatement := ParseQuantity(jsn.vObj['abatementQuantity']);
    if jsn.has('abatementPeriod') {a4} then
      result.abatement := ParsePeriod(jsn.vObj['abatementPeriod']);
    if jsn.has('abatementRange') {a4} then
      result.abatement := ParseRange(jsn.vObj['abatementRange']);
    if jsn.has('abatementDateTime') or jsn.has('_abatementDateTime') then
      result.abatement := ParseDateTime(jsn.node['abatementDateTime'], jsn.vObj['_abatementDateTime']);
    if jsn.has('abatementBoolean') or jsn.has('_abatementBoolean') then
      result.abatement := ParseBoolean(jsn.node['abatementBoolean'], jsn.vObj['_abatementBoolean']);
    if jsn.has('abatementString') or jsn.has('_abatementString') then
      result.abatement := ParseString(jsn.node['abatementString'], jsn.vObj['_abatementString']);
    if jsn.has('stage') then
        result.stage := ParseConditionStage(jsn.vObj['stage']);{q3}
    if jsn.has('evidence') then
      iterateArray(jsn.vArr['evidence'], result.evidenceList, parseConditionEvidence);
    if jsn.has('bodySite') then
      iterateArray(jsn.vArr['bodySite'], result.bodySiteList, parseCodeableConcept);
    if jsn.has('notes') or jsn.has('_notes') then
        result.notesElement := ParseString(jsn.node['notes'], jsn.vObj['_notes']);{q}
end;

procedure TFHIRJsonComposer.ComposeCondition(json : TJSONWriter; name : string; elem : TFhirCondition; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('asserter') then
    ComposeReference{Resource}(json, 'asserter', elem.asserter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dateRecorded') then
    ComposeDateValue(json, 'dateRecorded', elem.dateRecordedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dateRecorded') then
    ComposeDateProps(json, 'dateRecorded', elem.dateRecordedElement, false);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeCodeableConcept(json, 'category', elem.category); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('clinicalStatus') then
    ComposeCodeValue(json, 'clinicalStatus', elem.clinicalStatusElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('clinicalStatus') then
    ComposeCodeProps(json, 'clinicalStatus', elem.clinicalStatusElement, false);
  ComposeEnumValue(json, 'verificationStatus', elem.VerificationStatusElement, CODES_TFhirConditionVerStatusEnum, false);
  ComposeEnumProps(json, 'verificationStatus', elem.VerificationStatusElement, CODES_TFhirConditionVerStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('severity') then
    ComposeCodeableConcept(json, 'severity', elem.severity); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirQuantity) then 
    ComposeQuantity(json, 'onsetQuantity', TFhirQuantity(elem.onset)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirPeriod) then 
    ComposePeriod(json, 'onsetPeriod', TFhirPeriod(elem.onset)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirRange) then 
    ComposeRange(json, 'onsetRange', TFhirRange(elem.onset)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'onsetDateTime', TFhirDateTime(elem.onset), false);
    ComposeDateTimeProps(json, 'onsetDateTime', TFhirDateTime(elem.onset), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirString) then 
  begin
    ComposeStringValue(json, 'onsetString', TFhirString(elem.onset), false);
    ComposeStringProps(json, 'onsetString', TFhirString(elem.onset), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.abatement is TFhirQuantity) then 
    ComposeQuantity(json, 'abatementQuantity', TFhirQuantity(elem.abatement)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.abatement is TFhirPeriod) then 
    ComposePeriod(json, 'abatementPeriod', TFhirPeriod(elem.abatement)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.abatement is TFhirRange) then 
    ComposeRange(json, 'abatementRange', TFhirRange(elem.abatement)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.abatement is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'abatementDateTime', TFhirDateTime(elem.abatement), false);
    ComposeDateTimeProps(json, 'abatementDateTime', TFhirDateTime(elem.abatement), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.abatement is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'abatementBoolean', TFhirBoolean(elem.abatement), false);
    ComposeBooleanProps(json, 'abatementBoolean', TFhirBoolean(elem.abatement), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.abatement is TFhirString) then 
  begin
    ComposeStringValue(json, 'abatementString', TFhirString(elem.abatement), false);
    ComposeStringProps(json, 'abatementString', TFhirString(elem.abatement), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('stage') then
    ComposeConditionStage(json, 'stage', elem.stage); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('evidence') and (elem.evidenceList.Count > 0) then
  begin
    startArray(json, 'evidence', elem.evidenceList, false);
    for i := 0 to elem.evidenceList.Count - 1 do
      ComposeConditionEvidence(json, '', elem.evidenceList[i]); {z - }
    finishArray(json, elem.evidenceList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('bodySite') and (elem.bodySiteList.Count > 0) then
  begin
    startArray(json, 'bodySite', elem.bodySiteList, false);
    for i := 0 to elem.bodySiteList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.bodySiteList[i]); {z - CodeableConcept}
    finishArray(json, elem.bodySiteList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('notes') then
    ComposeStringValue(json, 'notes', elem.notesElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('notes') then
    ComposeStringProps(json, 'notes', elem.notesElement, false);
end;

{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONFORMANCE}
procedure TFHIRJsonParser.ParseConformanceContact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceContact(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceContact(jsn : TJsonObject) : TFhirConformanceContact;
begin
  result := TFhirConformanceContact.create;
  try
    ParseConformanceContactProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseConformanceContactProperties(jsn : TJsonObject; result : TFhirConformanceContact);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
end;

procedure TFHIRJsonComposer.ComposeConformanceContact(json : TJSONWriter; name : string; elem : TFhirConformanceContact; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.telecomList.Count > 0) then
  begin
    startArray(json, 'telecom', elem.telecomList, false);
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    finishArray(json, elem.telecomList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseConformanceSoftware(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceSoftware(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceSoftware(jsn : TJsonObject) : TFhirConformanceSoftware;
begin
  result := TFhirConformanceSoftware.create;
  try
    ParseConformanceSoftwareProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseConformanceSoftwareProperties(jsn : TJsonObject; result : TFhirConformanceSoftware);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('releaseDate') or jsn.has('_releaseDate') then
        result.releaseDateElement := ParseDateTime(jsn.node['releaseDate'], jsn.vObj['_releaseDate']);{q}
end;

procedure TFHIRJsonComposer.ComposeConformanceSoftware(json : TJSONWriter; name : string; elem : TFhirConformanceSoftware; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'releaseDate', elem.releaseDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'releaseDate', elem.releaseDateElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseConformanceImplementation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceImplementation(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceImplementation(jsn : TJsonObject) : TFhirConformanceImplementation;
begin
  result := TFhirConformanceImplementation.create;
  try
    ParseConformanceImplementationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseConformanceImplementationProperties(jsn : TJsonObject; result : TFhirConformanceImplementation);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn.node['url'], jsn.vObj['_url']);{q}
end;

procedure TFHIRJsonComposer.ComposeConformanceImplementation(json : TJSONWriter; name : string; elem : TFhirConformanceImplementation; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'description', elem.descriptionElement, false);
  ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseConformanceRest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceRest(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceRest(jsn : TJsonObject) : TFhirConformanceRest;
begin
  result := TFhirConformanceRest.create;
  try
    ParseConformanceRestProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseConformanceRestProperties(jsn : TJsonObject; result : TFhirConformanceRest);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('mode') or jsn.has('_mode')  then
      result.modeElement := parseEnum(jsn.path+'/mode', jsn.node['mode'], jsn.vObj['_mode'], CODES_TFhirRestfulConformanceModeEnum, SYSTEMS_TFhirRestfulConformanceModeEnum);
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationElement := ParseString(jsn.node['documentation'], jsn.vObj['_documentation']);{q}
    if jsn.has('security') then
        result.security := ParseConformanceRestSecurity(jsn.vObj['security']);{q3}
    if jsn.has('resource') then
      iterateArray(jsn.vArr['resource'], result.resourceList, parseConformanceRestResource);
    if jsn.has('interaction') then
      iterateArray(jsn.vArr['interaction'], result.interactionList, parseConformanceRestInteraction);
    if jsn.has('transactionMode') or jsn.has('_transactionMode')  then
      result.transactionModeElement := parseEnum(jsn.path+'/transactionMode', jsn.node['transactionMode'], jsn.vObj['_transactionMode'], CODES_TFhirTransactionModeEnum, SYSTEMS_TFhirTransactionModeEnum);
    if jsn.has('searchParam') then
      iterateArray(jsn.vArr['searchParam'], result.searchParamList, parseConformanceRestResourceSearchParam);
    if jsn.has('operation') then
      iterateArray(jsn.vArr['operation'], result.operationList, parseConformanceRestOperation);
      if jsn.has('compartment') or jsn.has('_compartment') then
      iteratePrimitiveArray(jsn.vArr['compartment'], jsn.vArr['_compartment'], result.compartmentList, parseUri);
end;

procedure TFHIRJsonComposer.ComposeConformanceRest(json : TJSONWriter; name : string; elem : TFhirConformanceRest; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'mode', elem.ModeElement, CODES_TFhirRestfulConformanceModeEnum, false);
  ComposeEnumProps(json, 'mode', elem.ModeElement, CODES_TFhirRestfulConformanceModeEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeConformanceRestSecurity(json, 'security', elem.security); {a}
  if (elem.resourceList.Count > 0) then
  begin
    startArray(json, 'resource', elem.resourceList, false);
    for i := 0 to elem.resourceList.Count - 1 do
      ComposeConformanceRestResource(json, '', elem.resourceList[i]); {z - }
    finishArray(json, elem.resourceList);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.interactionList.Count > 0) then
  begin
    startArray(json, 'interaction', elem.interactionList, false);
    for i := 0 to elem.interactionList.Count - 1 do
      ComposeConformanceRestInteraction(json, '', elem.interactionList[i]); {z - }
    finishArray(json, elem.interactionList);
  end;
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.transactionModeElement <> nil) and (elem.transactionModeElement.primitiveValue <> 'not-supported')) then
    ComposeEnumValue(json, 'transactionMode', elem.TransactionModeElement, CODES_TFhirTransactionModeEnum, false);
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.transactionModeElement <> nil) and (elem.transactionModeElement.primitiveValue <> 'not-supported')) then
    ComposeEnumProps(json, 'transactionMode', elem.TransactionModeElement, CODES_TFhirTransactionModeEnum, false);
  if (SummaryOption in [soFull, soData]) and (elem.searchParamList.Count > 0) then
  begin
    startArray(json, 'searchParam', elem.searchParamList, false);
    for i := 0 to elem.searchParamList.Count - 1 do
      ComposeConformanceRestResourceSearchParam(json, '', elem.searchParamList[i]); {z - @Conformance.rest.resource.searchParam}
    finishArray(json, elem.searchParamList);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.operationList.Count > 0) then
  begin
    startArray(json, 'operation', elem.operationList, false);
    for i := 0 to elem.operationList.Count - 1 do
      ComposeConformanceRestOperation(json, '', elem.operationList[i]); {z - }
    finishArray(json, elem.operationList);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.compartmentList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.compartmentList.Count - 1 do
    begin
      ext := ext or ((elem.compartmentList[i].id <> '') or (elem.compartmentList[i].hasExtensionList) {no-comments or (elem.compartmentList[i].hasComments)});
      val := val or (elem.compartmentList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      startArray(json, 'compartment', elem.compartmentList, true);
      for i := 0 to elem.compartmentList.Count - 1 do
        ComposeUriValue(json, '',elem.compartmentList[i], true);
      finishArray(json, elem.compartmentList);
    end;
    if ext then
    begin
      startArray(json, '_compartment', elem.compartmentList, false);
      for i := 0 to elem.compartmentList.Count - 1 do
        ComposeUriProps(json, '',elem.compartmentList[i], true);
      finishArray(json, elem.compartmentList);
    end;
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseConformanceRestSecurity(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceRestSecurity(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceRestSecurity(jsn : TJsonObject) : TFhirConformanceRestSecurity;
begin
  result := TFhirConformanceRestSecurity.create;
  try
    ParseConformanceRestSecurityProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseConformanceRestSecurityProperties(jsn : TJsonObject; result : TFhirConformanceRestSecurity);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('cors') or jsn.has('_cors') then
        result.corsElement := ParseBoolean(jsn.node['cors'], jsn.vObj['_cors']);{q}
    if jsn.has('service') then
      iterateArray(jsn.vArr['service'], result.serviceList, parseCodeableConcept);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('certificate') then
      iterateArray(jsn.vArr['certificate'], result.certificateList, parseConformanceRestSecurityCertificate);
end;

procedure TFHIRJsonComposer.ComposeConformanceRestSecurity(json : TJSONWriter; name : string; elem : TFhirConformanceRestSecurity; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'cors', elem.corsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'cors', elem.corsElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.serviceList.Count > 0) then
  begin
    startArray(json, 'service', elem.serviceList, false);
    for i := 0 to elem.serviceList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.serviceList[i]); {z - CodeableConcept}
    finishArray(json, elem.serviceList);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.certificateList.Count > 0) then
  begin
    startArray(json, 'certificate', elem.certificateList, false);
    for i := 0 to elem.certificateList.Count - 1 do
      ComposeConformanceRestSecurityCertificate(json, '', elem.certificateList[i]); {z - }
    finishArray(json, elem.certificateList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseConformanceRestSecurityCertificate(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceRestSecurityCertificate(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceRestSecurityCertificate(jsn : TJsonObject) : TFhirConformanceRestSecurityCertificate;
begin
  result := TFhirConformanceRestSecurityCertificate.create;
  try
    ParseConformanceRestSecurityCertificateProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseConformanceRestSecurityCertificateProperties(jsn : TJsonObject; result : TFhirConformanceRestSecurityCertificate);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type') then
        result.type_Element := ParseCode(jsn.node['type'], jsn.vObj['_type']);{q}
    if jsn.has('blob') or jsn.has('_blob') then
        result.blobElement := ParseBase64Binary(jsn.node['blob'], jsn.vObj['_blob']);{q}
end;

procedure TFHIRJsonComposer.ComposeConformanceRestSecurityCertificate(json : TJSONWriter; name : string; elem : TFhirConformanceRestSecurityCertificate; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeValue(json, 'type', elem.type_Element, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeProps(json, 'type', elem.type_Element, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBase64BinaryValue(json, 'blob', elem.blobElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBase64BinaryProps(json, 'blob', elem.blobElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseConformanceRestResource(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceRestResource(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceRestResource(jsn : TJsonObject) : TFhirConformanceRestResource;
begin
  result := TFhirConformanceRestResource.create;
  try
    ParseConformanceRestResourceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseConformanceRestResourceProperties(jsn : TJsonObject; result : TFhirConformanceRestResource);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    if jsn.has('profile') then
        result.profile := ParseReference{TFhirStructureDefinition}(jsn.vObj['profile']);{q3}
    if jsn.has('interaction') then
      iterateArray(jsn.vArr['interaction'], result.interactionList, parseConformanceRestResourceInteraction);
    if jsn.has('versioning') or jsn.has('_versioning')  then
      result.versioningElement := parseEnum(jsn.path+'/versioning', jsn.node['versioning'], jsn.vObj['_versioning'], CODES_TFhirVersioningPolicyEnum, SYSTEMS_TFhirVersioningPolicyEnum);
    if jsn.has('readHistory') or jsn.has('_readHistory') then
        result.readHistoryElement := ParseBoolean(jsn.node['readHistory'], jsn.vObj['_readHistory']);{q}
    if jsn.has('updateCreate') or jsn.has('_updateCreate') then
        result.updateCreateElement := ParseBoolean(jsn.node['updateCreate'], jsn.vObj['_updateCreate']);{q}
    if jsn.has('conditionalCreate') or jsn.has('_conditionalCreate') then
        result.conditionalCreateElement := ParseBoolean(jsn.node['conditionalCreate'], jsn.vObj['_conditionalCreate']);{q}
    if jsn.has('conditionalUpdate') or jsn.has('_conditionalUpdate') then
        result.conditionalUpdateElement := ParseBoolean(jsn.node['conditionalUpdate'], jsn.vObj['_conditionalUpdate']);{q}
    if jsn.has('conditionalDelete') or jsn.has('_conditionalDelete')  then
      result.conditionalDeleteElement := parseEnum(jsn.path+'/conditionalDelete', jsn.node['conditionalDelete'], jsn.vObj['_conditionalDelete'], CODES_TFhirConditionalDeleteStatusEnum, SYSTEMS_TFhirConditionalDeleteStatusEnum);
      if jsn.has('searchInclude') or jsn.has('_searchInclude') then
      iteratePrimitiveArray(jsn.vArr['searchInclude'], jsn.vArr['_searchInclude'], result.searchIncludeList, parseString);
      if jsn.has('searchRevInclude') or jsn.has('_searchRevInclude') then
      iteratePrimitiveArray(jsn.vArr['searchRevInclude'], jsn.vArr['_searchRevInclude'], result.searchRevIncludeList, parseString);
    if jsn.has('searchParam') then
      iterateArray(jsn.vArr['searchParam'], result.searchParamList, parseConformanceRestResourceSearchParam);
end;

procedure TFHIRJsonComposer.ComposeConformanceRestResource(json : TJSONWriter; name : string; elem : TFhirConformanceRestResource; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirResourceTypesEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirResourceTypesEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirStructureDefinition}(json, 'profile', elem.profile); {a}
  if (elem.interactionList.Count > 0) then
  begin
    startArray(json, 'interaction', elem.interactionList, false);
    for i := 0 to elem.interactionList.Count - 1 do
      ComposeConformanceRestResourceInteraction(json, '', elem.interactionList[i]); {z - }
    finishArray(json, elem.interactionList);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'versioning', elem.VersioningElement, CODES_TFhirVersioningPolicyEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'versioning', elem.VersioningElement, CODES_TFhirVersioningPolicyEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'readHistory', elem.readHistoryElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'readHistory', elem.readHistoryElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'updateCreate', elem.updateCreateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'updateCreate', elem.updateCreateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'conditionalCreate', elem.conditionalCreateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'conditionalCreate', elem.conditionalCreateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'conditionalUpdate', elem.conditionalUpdateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'conditionalUpdate', elem.conditionalUpdateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'conditionalDelete', elem.ConditionalDeleteElement, CODES_TFhirConditionalDeleteStatusEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'conditionalDelete', elem.ConditionalDeleteElement, CODES_TFhirConditionalDeleteStatusEnum, false);
  if (SummaryOption in [soFull, soData]) and (elem.searchIncludeList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.searchIncludeList.Count - 1 do
    begin
      ext := ext or ((elem.searchIncludeList[i].id <> '') or (elem.searchIncludeList[i].hasExtensionList) {no-comments or (elem.searchIncludeList[i].hasComments)});
      val := val or (elem.searchIncludeList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      startArray(json, 'searchInclude', elem.searchIncludeList, true);
      for i := 0 to elem.searchIncludeList.Count - 1 do
        ComposeStringValue(json, '',elem.searchIncludeList[i], true);
      finishArray(json, elem.searchIncludeList);
    end;
    if ext then
    begin
      startArray(json, '_searchInclude', elem.searchIncludeList, false);
      for i := 0 to elem.searchIncludeList.Count - 1 do
        ComposeStringProps(json, '',elem.searchIncludeList[i], true);
      finishArray(json, elem.searchIncludeList);
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.searchRevIncludeList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.searchRevIncludeList.Count - 1 do
    begin
      ext := ext or ((elem.searchRevIncludeList[i].id <> '') or (elem.searchRevIncludeList[i].hasExtensionList) {no-comments or (elem.searchRevIncludeList[i].hasComments)});
      val := val or (elem.searchRevIncludeList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      startArray(json, 'searchRevInclude', elem.searchRevIncludeList, true);
      for i := 0 to elem.searchRevIncludeList.Count - 1 do
        ComposeStringValue(json, '',elem.searchRevIncludeList[i], true);
      finishArray(json, elem.searchRevIncludeList);
    end;
    if ext then
    begin
      startArray(json, '_searchRevInclude', elem.searchRevIncludeList, false);
      for i := 0 to elem.searchRevIncludeList.Count - 1 do
        ComposeStringProps(json, '',elem.searchRevIncludeList[i], true);
      finishArray(json, elem.searchRevIncludeList);
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.searchParamList.Count > 0) then
  begin
    startArray(json, 'searchParam', elem.searchParamList, false);
    for i := 0 to elem.searchParamList.Count - 1 do
      ComposeConformanceRestResourceSearchParam(json, '', elem.searchParamList[i]); {z - }
    finishArray(json, elem.searchParamList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseConformanceRestResourceInteraction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceRestResourceInteraction(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceRestResourceInteraction(jsn : TJsonObject) : TFhirConformanceRestResourceInteraction;
begin
  result := TFhirConformanceRestResourceInteraction.create;
  try
    ParseConformanceRestResourceInteractionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseConformanceRestResourceInteractionProperties(jsn : TJsonObject; result : TFhirConformanceRestResourceInteraction);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code')  then
      result.codeElement := parseEnum(jsn.path+'/code', jsn.node['code'], jsn.vObj['_code'], CODES_TFhirTypeRestfulInteractionEnum, SYSTEMS_TFhirTypeRestfulInteractionEnum);
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationElement := ParseString(jsn.node['documentation'], jsn.vObj['_documentation']);{q}
end;

procedure TFHIRJsonComposer.ComposeConformanceRestResourceInteraction(json : TJSONWriter; name : string; elem : TFhirConformanceRestResourceInteraction; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'code', elem.CodeElement, CODES_TFhirTypeRestfulInteractionEnum, false);
  ComposeEnumProps(json, 'code', elem.CodeElement, CODES_TFhirTypeRestfulInteractionEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'documentation', elem.documentationElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseConformanceRestResourceSearchParam(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceRestResourceSearchParam(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceRestResourceSearchParam(jsn : TJsonObject) : TFhirConformanceRestResourceSearchParam;
begin
  result := TFhirConformanceRestResourceSearchParam.create;
  try
    ParseConformanceRestResourceSearchParamProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseConformanceRestResourceSearchParamProperties(jsn : TJsonObject; result : TFhirConformanceRestResourceSearchParam);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('definition') or jsn.has('_definition') then
        result.definitionElement := ParseUri(jsn.node['definition'], jsn.vObj['_definition']);{q}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirSearchParamTypeEnum, SYSTEMS_TFhirSearchParamTypeEnum);
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationElement := ParseString(jsn.node['documentation'], jsn.vObj['_documentation']);{q}
    if jsn.has('target') or jsn.has('_target') then
      iterateEnumArray(jsn.vArr['target'], jsn.vArr['_target'], jsn.path+'/target', result.target, parseEnum, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    if jsn.has('modifier') or jsn.has('_modifier') then
      iterateEnumArray(jsn.vArr['modifier'], jsn.vArr['_modifier'], jsn.path+'/modifier', result.modifierList, parseEnum, CODES_TFhirSearchModifierCodeEnum, SYSTEMS_TFhirSearchModifierCodeEnum);
      if jsn.has('chain') or jsn.has('_chain') then
      iteratePrimitiveArray(jsn.vArr['chain'], jsn.vArr['_chain'], result.chainList, parseString);
end;

procedure TFHIRJsonComposer.ComposeConformanceRestResourceSearchParam(json : TJSONWriter; name : string; elem : TFhirConformanceRestResourceSearchParam; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriValue(json, 'definition', elem.definitionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriProps(json, 'definition', elem.definitionElement, false);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirSearchParamTypeEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirSearchParamTypeEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.target.Count > 0) then
  begin
    val := false;
    ext := false;
    for i := 0 to elem.target.Count - 1 do
    begin
      val := val or (elem.target[i].hasPrimitiveValue);
      ext := ext or ((elem.target[i].id <> '') or (elem.target[i].hasExtensionList));
    end;
    if val then
    begin
      startArray(json, 'target', elem.targetList, true);
      for i := 0 to elem.target.Count - 1 do
        ComposeEnumValue(json, '', elem.target[i], CODES_TFhirResourceTypesEnum, true);
      finishArray(json, elem.targetList);
    end;
    if ext then
    begin
      startArray(json, '_target', elem.targetList, false);
      for i := 0 to elem.target.Count - 1 do
        ComposeEnumProps(json, '', elem.target[i], CODES_TFhirResourceTypesEnum, true);
      finishArray(json, elem.targetList);
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.modifierList.Count > 0) then
  begin
    val := false;
    ext := false;
    for i := 0 to elem.modifierList.Count - 1 do
    begin
      val := val or (elem.modifierList[i].hasPrimitiveValue);
      ext := ext or ((elem.modifierList[i].id <> '') or (elem.modifierList[i].hasExtensionList));
    end;
    if val then
    begin
      startArray(json, 'modifier', elem.modifierList, true);
      for i := 0 to elem.modifierList.Count - 1 do
        ComposeEnumValue(json, '', elem.modifierList[i], CODES_TFhirSearchModifierCodeEnum, true);
      finishArray(json, elem.modifierList);
    end;
    if ext then
    begin
      startArray(json, '_modifier', elem.modifierList, false);
      for i := 0 to elem.modifierList.Count - 1 do
        ComposeEnumProps(json, '', elem.modifierList[i], CODES_TFhirSearchModifierCodeEnum, true);
      finishArray(json, elem.modifierList);
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.chainList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.chainList.Count - 1 do
    begin
      ext := ext or ((elem.chainList[i].id <> '') or (elem.chainList[i].hasExtensionList) {no-comments or (elem.chainList[i].hasComments)});
      val := val or (elem.chainList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      startArray(json, 'chain', elem.chainList, true);
      for i := 0 to elem.chainList.Count - 1 do
        ComposeStringValue(json, '',elem.chainList[i], true);
      finishArray(json, elem.chainList);
    end;
    if ext then
    begin
      startArray(json, '_chain', elem.chainList, false);
      for i := 0 to elem.chainList.Count - 1 do
        ComposeStringProps(json, '',elem.chainList[i], true);
      finishArray(json, elem.chainList);
    end;
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseConformanceRestInteraction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceRestInteraction(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceRestInteraction(jsn : TJsonObject) : TFhirConformanceRestInteraction;
begin
  result := TFhirConformanceRestInteraction.create;
  try
    ParseConformanceRestInteractionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseConformanceRestInteractionProperties(jsn : TJsonObject; result : TFhirConformanceRestInteraction);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code')  then
      result.codeElement := parseEnum(jsn.path+'/code', jsn.node['code'], jsn.vObj['_code'], CODES_TFhirSystemRestfulInteractionEnum, SYSTEMS_TFhirSystemRestfulInteractionEnum);
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationElement := ParseString(jsn.node['documentation'], jsn.vObj['_documentation']);{q}
end;

procedure TFHIRJsonComposer.ComposeConformanceRestInteraction(json : TJSONWriter; name : string; elem : TFhirConformanceRestInteraction; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'code', elem.CodeElement, CODES_TFhirSystemRestfulInteractionEnum, false);
  ComposeEnumProps(json, 'code', elem.CodeElement, CODES_TFhirSystemRestfulInteractionEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'documentation', elem.documentationElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseConformanceRestOperation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceRestOperation(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceRestOperation(jsn : TJsonObject) : TFhirConformanceRestOperation;
begin
  result := TFhirConformanceRestOperation.create;
  try
    ParseConformanceRestOperationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseConformanceRestOperationProperties(jsn : TJsonObject; result : TFhirConformanceRestOperation);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('definition') then
        result.definition := ParseReference{TFhirOperationDefinition}(jsn.vObj['definition']);{q3}
end;

procedure TFHIRJsonComposer.ComposeConformanceRestOperation(json : TJSONWriter; name : string; elem : TFhirConformanceRestOperation; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  ComposeReference{TFhirOperationDefinition}(json, 'definition', elem.definition); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseConformanceMessaging(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceMessaging(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceMessaging(jsn : TJsonObject) : TFhirConformanceMessaging;
begin
  result := TFhirConformanceMessaging.create;
  try
    ParseConformanceMessagingProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseConformanceMessagingProperties(jsn : TJsonObject; result : TFhirConformanceMessaging);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('endpoint') then
      iterateArray(jsn.vArr['endpoint'], result.endpointList, parseConformanceMessagingEndpoint);
    if jsn.has('reliableCache') or jsn.has('_reliableCache') then
        result.reliableCacheElement := ParseUnsignedInt(jsn.node['reliableCache'], jsn.vObj['_reliableCache']);{q}
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationElement := ParseString(jsn.node['documentation'], jsn.vObj['_documentation']);{q}
    if jsn.has('event') then
      iterateArray(jsn.vArr['event'], result.eventList, parseConformanceMessagingEvent);
end;

procedure TFHIRJsonComposer.ComposeConformanceMessaging(json : TJSONWriter; name : string; elem : TFhirConformanceMessaging; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.endpointList.Count > 0) then
  begin
    startArray(json, 'endpoint', elem.endpointList, false);
    for i := 0 to elem.endpointList.Count - 1 do
      ComposeConformanceMessagingEndpoint(json, '', elem.endpointList[i]); {z - }
    finishArray(json, elem.endpointList);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedIntValue(json, 'reliableCache', elem.reliableCacheElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedIntProps(json, 'reliableCache', elem.reliableCacheElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'documentation', elem.documentationElement, false);
  if (elem.eventList.Count > 0) then
  begin
    startArray(json, 'event', elem.eventList, false);
    for i := 0 to elem.eventList.Count - 1 do
      ComposeConformanceMessagingEvent(json, '', elem.eventList[i]); {z - }
    finishArray(json, elem.eventList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseConformanceMessagingEndpoint(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceMessagingEndpoint(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceMessagingEndpoint(jsn : TJsonObject) : TFhirConformanceMessagingEndpoint;
begin
  result := TFhirConformanceMessagingEndpoint.create;
  try
    ParseConformanceMessagingEndpointProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseConformanceMessagingEndpointProperties(jsn : TJsonObject; result : TFhirConformanceMessagingEndpoint);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('protocol') then
        result.protocol := ParseCoding(jsn.vObj['protocol']);{q3}
    if jsn.has('address') or jsn.has('_address') then
        result.addressElement := ParseUri(jsn.node['address'], jsn.vObj['_address']);{q}
end;

procedure TFHIRJsonComposer.ComposeConformanceMessagingEndpoint(json : TJSONWriter; name : string; elem : TFhirConformanceMessagingEndpoint; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeCoding(json, 'protocol', elem.protocol); {a}
  ComposeUriValue(json, 'address', elem.addressElement, false);
  ComposeUriProps(json, 'address', elem.addressElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseConformanceMessagingEvent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceMessagingEvent(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceMessagingEvent(jsn : TJsonObject) : TFhirConformanceMessagingEvent;
begin
  result := TFhirConformanceMessagingEvent.create;
  try
    ParseConformanceMessagingEventProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseConformanceMessagingEventProperties(jsn : TJsonObject; result : TFhirConformanceMessagingEvent);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCoding(jsn.vObj['code']);{q3}
    if jsn.has('category') or jsn.has('_category')  then
      result.categoryElement := parseEnum(jsn.path+'/category', jsn.node['category'], jsn.vObj['_category'], CODES_TFhirMessageSignificanceCategoryEnum, SYSTEMS_TFhirMessageSignificanceCategoryEnum);
    if jsn.has('mode') or jsn.has('_mode')  then
      result.modeElement := parseEnum(jsn.path+'/mode', jsn.node['mode'], jsn.vObj['_mode'], CODES_TFhirMessageConformanceEventModeEnum, SYSTEMS_TFhirMessageConformanceEventModeEnum);
    if jsn.has('focus') or jsn.has('_focus')  then
      result.focusElement := parseEnum(jsn.path+'/focus', jsn.node['focus'], jsn.vObj['_focus'], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    if jsn.has('request') then
        result.request := ParseReference{TFhirStructureDefinition}(jsn.vObj['request']);{q3}
    if jsn.has('response') then
        result.response := ParseReference{TFhirStructureDefinition}(jsn.vObj['response']);{q3}
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationElement := ParseString(jsn.node['documentation'], jsn.vObj['_documentation']);{q}
end;

procedure TFHIRJsonComposer.ComposeConformanceMessagingEvent(json : TJSONWriter; name : string; elem : TFhirConformanceMessagingEvent; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeCoding(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'category', elem.CategoryElement, CODES_TFhirMessageSignificanceCategoryEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'category', elem.CategoryElement, CODES_TFhirMessageSignificanceCategoryEnum, false);
  ComposeEnumValue(json, 'mode', elem.ModeElement, CODES_TFhirMessageConformanceEventModeEnum, false);
  ComposeEnumProps(json, 'mode', elem.ModeElement, CODES_TFhirMessageConformanceEventModeEnum, false);
  ComposeEnumValue(json, 'focus', elem.FocusElement, CODES_TFhirResourceTypesEnum, false);
  ComposeEnumProps(json, 'focus', elem.FocusElement, CODES_TFhirResourceTypesEnum, false);
  ComposeReference{TFhirStructureDefinition}(json, 'request', elem.request); {a}
  ComposeReference{TFhirStructureDefinition}(json, 'response', elem.response); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'documentation', elem.documentationElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseConformanceDocument(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformanceDocument(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformanceDocument(jsn : TJsonObject) : TFhirConformanceDocument;
begin
  result := TFhirConformanceDocument.create;
  try
    ParseConformanceDocumentProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseConformanceDocumentProperties(jsn : TJsonObject; result : TFhirConformanceDocument);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('mode') or jsn.has('_mode')  then
      result.modeElement := parseEnum(jsn.path+'/mode', jsn.node['mode'], jsn.vObj['_mode'], CODES_TFhirDocumentModeEnum, SYSTEMS_TFhirDocumentModeEnum);
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationElement := ParseString(jsn.node['documentation'], jsn.vObj['_documentation']);{q}
    if jsn.has('profile') then
        result.profile := ParseReference{TFhirStructureDefinition}(jsn.vObj['profile']);{q3}
end;

procedure TFHIRJsonComposer.ComposeConformanceDocument(json : TJSONWriter; name : string; elem : TFhirConformanceDocument; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'mode', elem.ModeElement, CODES_TFhirDocumentModeEnum, false);
  ComposeEnumProps(json, 'mode', elem.ModeElement, CODES_TFhirDocumentModeEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'documentation', elem.documentationElement, false);
  ComposeReference{TFhirStructureDefinition}(json, 'profile', elem.profile); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseConformance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseConformance(jsn)); {2}
end;

function TFHIRJsonParser.ParseConformance(jsn : TJsonObject) : TFhirConformance;
begin
  result := TFhirConformance.create;
  try
    ParseConformanceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseConformanceProperties(jsn : TJsonObject; result : TFhirConformance);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := ParseBoolean(jsn.node['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := ParseString(jsn.node['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseConformanceContact);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('requirements') or jsn.has('_requirements') then
        result.requirementsElement := ParseString(jsn.node['requirements'], jsn.vObj['_requirements']);{q}
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := ParseString(jsn.node['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('kind') or jsn.has('_kind')  then
      result.kindElement := parseEnum(jsn.path+'/kind', jsn.node['kind'], jsn.vObj['_kind'], CODES_TFhirConformanceStatementKindEnum, SYSTEMS_TFhirConformanceStatementKindEnum);
    if jsn.has('software') then
        result.software := ParseConformanceSoftware(jsn.vObj['software']);{q3}
    if jsn.has('implementation') then
        result.implementation_ := ParseConformanceImplementation(jsn.vObj['implementation']);{q3}
    if jsn.has('fhirVersion') or jsn.has('_fhirVersion') then
        result.fhirVersionElement := ParseId(jsn.node['fhirVersion'], jsn.vObj['_fhirVersion']);{q}
    if jsn.has('acceptUnknown') or jsn.has('_acceptUnknown')  then
      result.acceptUnknownElement := parseEnum(jsn.path+'/acceptUnknown', jsn.node['acceptUnknown'], jsn.vObj['_acceptUnknown'], CODES_TFhirUnknownContentCodeEnum, SYSTEMS_TFhirUnknownContentCodeEnum);
      if jsn.has('format') or jsn.has('_format') then
      iteratePrimitiveArray(jsn.vArr['format'], jsn.vArr['_format'], result.formatList, parseCode);
    if jsn.has('profile') then
      iterateArray(jsn.vArr['profile'], result.profileList, parseReference{TFhirStructureDefinition});
    if jsn.has('rest') then
      iterateArray(jsn.vArr['rest'], result.restList, parseConformanceRest);
    if jsn.has('messaging') then
      iterateArray(jsn.vArr['messaging'], result.messagingList, parseConformanceMessaging);
    if jsn.has('document') then
      iterateArray(jsn.vArr['document'], result.documentList, parseConformanceDocument);
end;

procedure TFHIRJsonComposer.ComposeConformance(json : TJSONWriter; name : string; elem : TFhirConformance; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    startArray(json, 'contact', elem.contactList, false);
    for i := 0 to elem.contactList.Count - 1 do
      ComposeConformanceContact(json, '', elem.contactList[i]); {z - }
    finishArray(json, elem.contactList);
  end;
  ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('requirements') then
    ComposeStringValue(json, 'requirements', elem.requirementsElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('requirements') then
    ComposeStringProps(json, 'requirements', elem.requirementsElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeStringValue(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeStringProps(json, 'copyright', elem.copyrightElement, false);
  ComposeEnumValue(json, 'kind', elem.KindElement, CODES_TFhirConformanceStatementKindEnum, false);
  ComposeEnumProps(json, 'kind', elem.KindElement, CODES_TFhirConformanceStatementKindEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('software') then
    ComposeConformanceSoftware(json, 'software', elem.software); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('implementation_') then
    ComposeConformanceImplementation(json, 'implementation', elem.implementation_); {a}
  ComposeIdValue(json, 'fhirVersion', elem.fhirVersionElement, false);
  ComposeIdProps(json, 'fhirVersion', elem.fhirVersionElement, false);
  ComposeEnumValue(json, 'acceptUnknown', elem.AcceptUnknownElement, CODES_TFhirUnknownContentCodeEnum, false);
  ComposeEnumProps(json, 'acceptUnknown', elem.AcceptUnknownElement, CODES_TFhirUnknownContentCodeEnum, false);
  if (elem.formatList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.formatList.Count - 1 do
    begin
      ext := ext or ((elem.formatList[i].id <> '') or (elem.formatList[i].hasExtensionList) {no-comments or (elem.formatList[i].hasComments)});
      val := val or (elem.formatList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      startArray(json, 'format', elem.formatList, true);
      for i := 0 to elem.formatList.Count - 1 do
        ComposeCodeValue(json, '',elem.formatList[i], true);
      finishArray(json, elem.formatList);
    end;
    if ext then
    begin
      startArray(json, '_format', elem.formatList, false);
      for i := 0 to elem.formatList.Count - 1 do
        ComposeCodeProps(json, '',elem.formatList[i], true);
      finishArray(json, elem.formatList);
    end;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('profile') and (elem.profileList.Count > 0) then
  begin
    startArray(json, 'profile', elem.profileList, false);
    for i := 0 to elem.profileList.Count - 1 do
      ComposeReference{TFhirStructureDefinition}(json, '', elem.profileList[i]); {z - Reference(StructureDefinition)}
    finishArray(json, elem.profileList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('rest') and (elem.restList.Count > 0) then
  begin
    startArray(json, 'rest', elem.restList, false);
    for i := 0 to elem.restList.Count - 1 do
      ComposeConformanceRest(json, '', elem.restList[i]); {z - }
    finishArray(json, elem.restList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('messaging') and (elem.messagingList.Count > 0) then
  begin
    startArray(json, 'messaging', elem.messagingList, false);
    for i := 0 to elem.messagingList.Count - 1 do
      ComposeConformanceMessaging(json, '', elem.messagingList[i]); {z - }
    finishArray(json, elem.messagingList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('document') and (elem.documentList.Count > 0) then
  begin
    startArray(json, 'document', elem.documentList, false);
    for i := 0 to elem.documentList.Count - 1 do
      ComposeConformanceDocument(json, '', elem.documentList[i]); {z - }
    finishArray(json, elem.documentList);
  end;
end;

{$ENDIF FHIR_CONFORMANCE}
{$IFDEF FHIR_CONTRACT}
procedure TFHIRJsonParser.ParseContractActor(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContractActor(jsn)); {2}
end;

function TFHIRJsonParser.ParseContractActor(jsn : TJsonObject) : TFhirContractActor;
begin
  result := TFhirContractActor.create;
  try
    ParseContractActorProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseContractActorProperties(jsn : TJsonObject; result : TFhirContractActor);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('entity') then
        result.entity := ParseReference{Resource}(jsn.vObj['entity']);{q3}
    if jsn.has('role') then
      iterateArray(jsn.vArr['role'], result.roleList, parseCodeableConcept);
end;

procedure TFHIRJsonComposer.ComposeContractActor(json : TJSONWriter; name : string; elem : TFhirContractActor; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeReference{Resource}(json, 'entity', elem.entity); {a}
  if (SummaryOption in [soFull, soData]) and (elem.roleList.Count > 0) then
  begin
    startArray(json, 'role', elem.roleList, false);
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.roleList[i]); {z - CodeableConcept}
    finishArray(json, elem.roleList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseContractValuedItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContractValuedItem(jsn)); {2}
end;

function TFHIRJsonParser.ParseContractValuedItem(jsn : TJsonObject) : TFhirContractValuedItem;
begin
  result := TFhirContractValuedItem.create;
  try
    ParseContractValuedItemProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseContractValuedItemProperties(jsn : TJsonObject; result : TFhirContractValuedItem);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('entityCodeableConcept') {a4} then
      result.entity := ParseCodeableConcept(jsn.vObj['entityCodeableConcept']);
    if jsn.has('entityReference') {a3} then
      result.entity := ParseReference(jsn.vObj['entityReference']);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('effectiveTime') or jsn.has('_effectiveTime') then
        result.effectiveTimeElement := ParseDateTime(jsn.node['effectiveTime'], jsn.vObj['_effectiveTime']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
    if jsn.has('unitPrice') then
        result.unitPrice := ParseQuantity(jsn.vObj['unitPrice']);{q3}
    if jsn.has('factor') or jsn.has('_factor') then
        result.factorElement := ParseDecimal(jsn.node['factor'], jsn.vObj['_factor']);{q}
    if jsn.has('points') or jsn.has('_points') then
        result.pointsElement := ParseDecimal(jsn.node['points'], jsn.vObj['_points']);{q}
    if jsn.has('net') then
        result.net := ParseQuantity(jsn.vObj['net']);{q3}
end;

procedure TFHIRJsonComposer.ComposeContractValuedItem(json : TJSONWriter; name : string; elem : TFhirContractValuedItem; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.entity is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'entityCodeableConcept', TFhirCodeableConcept(elem.entity)) 
  else if (SummaryOption in [soFull, soData]) and (elem.entity is TFhirReference) then
    ComposeReference(json, 'entityReference', TFhirReference(elem.entity));
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeValue(json, 'effectiveTime', elem.effectiveTimeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeProps(json, 'effectiveTime', elem.effectiveTimeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'unitPrice', elem.unitPrice); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'points', elem.pointsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'points', elem.pointsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'net', elem.net); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseContractSigner(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContractSigner(jsn)); {2}
end;

function TFHIRJsonParser.ParseContractSigner(jsn : TJsonObject) : TFhirContractSigner;
begin
  result := TFhirContractSigner.create;
  try
    ParseContractSignerProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseContractSignerProperties(jsn : TJsonObject; result : TFhirContractSigner);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q3}
    if jsn.has('party') then
        result.party := ParseReference{Resource}(jsn.vObj['party']);{q3}
    if jsn.has('signature') or jsn.has('_signature') then
        result.signatureElement := ParseString(jsn.node['signature'], jsn.vObj['_signature']);{q}
end;

procedure TFHIRJsonComposer.ComposeContractSigner(json : TJSONWriter; name : string; elem : TFhirContractSigner; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeCoding(json, 'type', elem.type_); {a}
  ComposeReference{Resource}(json, 'party', elem.party); {a}
  ComposeStringValue(json, 'signature', elem.signatureElement, false);
  ComposeStringProps(json, 'signature', elem.signatureElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseContractTerm(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContractTerm(jsn)); {2}
end;

function TFHIRJsonParser.ParseContractTerm(jsn : TJsonObject) : TFhirContractTerm;
begin
  result := TFhirContractTerm.create;
  try
    ParseContractTermProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseContractTermProperties(jsn : TJsonObject; result : TFhirContractTerm);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('issued') or jsn.has('_issued') then
        result.issuedElement := ParseDateTime(jsn.node['issued'], jsn.vObj['_issued']);{q}
    if jsn.has('applies') then
        result.applies := ParsePeriod(jsn.vObj['applies']);{q3}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('subType') then
        result.subType := ParseCodeableConcept(jsn.vObj['subType']);{q3}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirReference}(jsn.vObj['subject']);{q3}
    if jsn.has('action') then
      iterateArray(jsn.vArr['action'], result.actionList, parseCodeableConcept);
    if jsn.has('actionReason') then
      iterateArray(jsn.vArr['actionReason'], result.actionReasonList, parseCodeableConcept);
    if jsn.has('actor') then
      iterateArray(jsn.vArr['actor'], result.actorList, parseContractTermActor);
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn.node['text'], jsn.vObj['_text']);{q}
    if jsn.has('valuedItem') then
      iterateArray(jsn.vArr['valuedItem'], result.valuedItemList, parseContractTermValuedItem);
    if jsn.has('group') then
      iterateArray(jsn.vArr['group'], result.groupList, parseContractTerm);
end;

procedure TFHIRJsonComposer.ComposeContractTerm(json : TJSONWriter; name : string; elem : TFhirContractTerm; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'issued', elem.issuedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'issued', elem.issuedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(json, 'applies', elem.applies); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'subType', elem.subType); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soData]) and (elem.actionList.Count > 0) then
  begin
    startArray(json, 'action', elem.actionList, false);
    for i := 0 to elem.actionList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.actionList[i]); {z - CodeableConcept}
    finishArray(json, elem.actionList);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.actionReasonList.Count > 0) then
  begin
    startArray(json, 'actionReason', elem.actionReasonList, false);
    for i := 0 to elem.actionReasonList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.actionReasonList[i]); {z - CodeableConcept}
    finishArray(json, elem.actionReasonList);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.actorList.Count > 0) then
  begin
    startArray(json, 'actor', elem.actorList, false);
    for i := 0 to elem.actorList.Count - 1 do
      ComposeContractTermActor(json, '', elem.actorList[i]); {z - }
    finishArray(json, elem.actorList);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.valuedItemList.Count > 0) then
  begin
    startArray(json, 'valuedItem', elem.valuedItemList, false);
    for i := 0 to elem.valuedItemList.Count - 1 do
      ComposeContractTermValuedItem(json, '', elem.valuedItemList[i]); {z - }
    finishArray(json, elem.valuedItemList);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.groupList.Count > 0) then
  begin
    startArray(json, 'group', elem.groupList, false);
    for i := 0 to elem.groupList.Count - 1 do
      ComposeContractTerm(json, '', elem.groupList[i]); {z - @Contract.term}
    finishArray(json, elem.groupList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseContractTermActor(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContractTermActor(jsn)); {2}
end;

function TFHIRJsonParser.ParseContractTermActor(jsn : TJsonObject) : TFhirContractTermActor;
begin
  result := TFhirContractTermActor.create;
  try
    ParseContractTermActorProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseContractTermActorProperties(jsn : TJsonObject; result : TFhirContractTermActor);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('entity') then
        result.entity := ParseReference{Resource}(jsn.vObj['entity']);{q3}
    if jsn.has('role') then
      iterateArray(jsn.vArr['role'], result.roleList, parseCodeableConcept);
end;

procedure TFHIRJsonComposer.ComposeContractTermActor(json : TJSONWriter; name : string; elem : TFhirContractTermActor; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeReference{Resource}(json, 'entity', elem.entity); {a}
  if (SummaryOption in [soFull, soData]) and (elem.roleList.Count > 0) then
  begin
    startArray(json, 'role', elem.roleList, false);
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.roleList[i]); {z - CodeableConcept}
    finishArray(json, elem.roleList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseContractTermValuedItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContractTermValuedItem(jsn)); {2}
end;

function TFHIRJsonParser.ParseContractTermValuedItem(jsn : TJsonObject) : TFhirContractTermValuedItem;
begin
  result := TFhirContractTermValuedItem.create;
  try
    ParseContractTermValuedItemProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseContractTermValuedItemProperties(jsn : TJsonObject; result : TFhirContractTermValuedItem);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('entityCodeableConcept') {a4} then
      result.entity := ParseCodeableConcept(jsn.vObj['entityCodeableConcept']);
    if jsn.has('entityReference') {a3} then
      result.entity := ParseReference(jsn.vObj['entityReference']);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('effectiveTime') or jsn.has('_effectiveTime') then
        result.effectiveTimeElement := ParseDateTime(jsn.node['effectiveTime'], jsn.vObj['_effectiveTime']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
    if jsn.has('unitPrice') then
        result.unitPrice := ParseQuantity(jsn.vObj['unitPrice']);{q3}
    if jsn.has('factor') or jsn.has('_factor') then
        result.factorElement := ParseDecimal(jsn.node['factor'], jsn.vObj['_factor']);{q}
    if jsn.has('points') or jsn.has('_points') then
        result.pointsElement := ParseDecimal(jsn.node['points'], jsn.vObj['_points']);{q}
    if jsn.has('net') then
        result.net := ParseQuantity(jsn.vObj['net']);{q3}
end;

procedure TFHIRJsonComposer.ComposeContractTermValuedItem(json : TJSONWriter; name : string; elem : TFhirContractTermValuedItem; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.entity is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'entityCodeableConcept', TFhirCodeableConcept(elem.entity)) 
  else if (SummaryOption in [soFull, soData]) and (elem.entity is TFhirReference) then
    ComposeReference(json, 'entityReference', TFhirReference(elem.entity));
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeValue(json, 'effectiveTime', elem.effectiveTimeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeProps(json, 'effectiveTime', elem.effectiveTimeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'unitPrice', elem.unitPrice); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'factor', elem.factorElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'points', elem.pointsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'points', elem.pointsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'net', elem.net); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseContractFriendly(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContractFriendly(jsn)); {2}
end;

function TFHIRJsonParser.ParseContractFriendly(jsn : TJsonObject) : TFhirContractFriendly;
begin
  result := TFhirContractFriendly.create;
  try
    ParseContractFriendlyProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseContractFriendlyProperties(jsn : TJsonObject; result : TFhirContractFriendly);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('contentAttachment') {a4} then
      result.content := ParseAttachment(jsn.vObj['contentAttachment']);
    if jsn.has('contentReference') {a3} then
      result.content := ParseReference(jsn.vObj['contentReference']);
end;

procedure TFHIRJsonComposer.ComposeContractFriendly(json : TJSONWriter; name : string; elem : TFhirContractFriendly; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (elem.content is TFhirAttachment) then 
    ComposeAttachment(json, 'contentAttachment', TFhirAttachment(elem.content)) 
  else if (elem.content is TFhirReference) then
    ComposeReference(json, 'contentReference', TFhirReference(elem.content));
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseContractLegal(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContractLegal(jsn)); {2}
end;

function TFHIRJsonParser.ParseContractLegal(jsn : TJsonObject) : TFhirContractLegal;
begin
  result := TFhirContractLegal.create;
  try
    ParseContractLegalProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseContractLegalProperties(jsn : TJsonObject; result : TFhirContractLegal);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('contentAttachment') {a4} then
      result.content := ParseAttachment(jsn.vObj['contentAttachment']);
    if jsn.has('contentReference') {a3} then
      result.content := ParseReference(jsn.vObj['contentReference']);
end;

procedure TFHIRJsonComposer.ComposeContractLegal(json : TJSONWriter; name : string; elem : TFhirContractLegal; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (elem.content is TFhirAttachment) then 
    ComposeAttachment(json, 'contentAttachment', TFhirAttachment(elem.content)) 
  else if (elem.content is TFhirReference) then
    ComposeReference(json, 'contentReference', TFhirReference(elem.content));
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseContractRule(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContractRule(jsn)); {2}
end;

function TFHIRJsonParser.ParseContractRule(jsn : TJsonObject) : TFhirContractRule;
begin
  result := TFhirContractRule.create;
  try
    ParseContractRuleProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseContractRuleProperties(jsn : TJsonObject; result : TFhirContractRule);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('contentAttachment') {a4} then
      result.content := ParseAttachment(jsn.vObj['contentAttachment']);
    if jsn.has('contentReference') {a3} then
      result.content := ParseReference(jsn.vObj['contentReference']);
end;

procedure TFHIRJsonComposer.ComposeContractRule(json : TJSONWriter; name : string; elem : TFhirContractRule; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (elem.content is TFhirAttachment) then 
    ComposeAttachment(json, 'contentAttachment', TFhirAttachment(elem.content)) 
  else if (elem.content is TFhirReference) then
    ComposeReference(json, 'contentReference', TFhirReference(elem.content));
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseContract(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseContract(jsn)); {2}
end;

function TFHIRJsonParser.ParseContract(jsn : TJsonObject) : TFhirContract;
begin
  result := TFhirContract.create;
  try
    ParseContractProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseContractProperties(jsn : TJsonObject; result : TFhirContract);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('issued') or jsn.has('_issued') then
        result.issuedElement := ParseDateTime(jsn.node['issued'], jsn.vObj['_issued']);{q}
    if jsn.has('applies') then
        result.applies := ParsePeriod(jsn.vObj['applies']);{q3}
    if jsn.has('subject') then
      iterateArray(jsn.vArr['subject'], result.subjectList, parseReference{TFhirReference});
    if jsn.has('authority') then
      iterateArray(jsn.vArr['authority'], result.authorityList, parseReference{TFhirOrganization});
    if jsn.has('domain') then
      iterateArray(jsn.vArr['domain'], result.domainList, parseReference{TFhirLocation});
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('subType') then
      iterateArray(jsn.vArr['subType'], result.subTypeList, parseCodeableConcept);
    if jsn.has('action') then
      iterateArray(jsn.vArr['action'], result.actionList, parseCodeableConcept);
    if jsn.has('actionReason') then
      iterateArray(jsn.vArr['actionReason'], result.actionReasonList, parseCodeableConcept);
    if jsn.has('actor') then
      iterateArray(jsn.vArr['actor'], result.actorList, parseContractActor);
    if jsn.has('valuedItem') then
      iterateArray(jsn.vArr['valuedItem'], result.valuedItemList, parseContractValuedItem);
    if jsn.has('signer') then
      iterateArray(jsn.vArr['signer'], result.signerList, parseContractSigner);
    if jsn.has('term') then
      iterateArray(jsn.vArr['term'], result.termList, parseContractTerm);
    if jsn.has('bindingAttachment') {a4} then
      result.binding := ParseAttachment(jsn.vObj['bindingAttachment']);
    if jsn.has('bindingReference') {a3} then
      result.binding := ParseReference(jsn.vObj['bindingReference']);
    if jsn.has('friendly') then
      iterateArray(jsn.vArr['friendly'], result.friendlyList, parseContractFriendly);
    if jsn.has('legal') then
      iterateArray(jsn.vArr['legal'], result.legalList, parseContractLegal);
    if jsn.has('rule') then
      iterateArray(jsn.vArr['rule'], result.ruleList, parseContractRule);
end;

procedure TFHIRJsonComposer.ComposeContract(json : TJSONWriter; name : string; elem : TFhirContract; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('issued') then
    ComposeDateTimeValue(json, 'issued', elem.issuedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('issued') then
    ComposeDateTimeProps(json, 'issued', elem.issuedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('applies') then
    ComposePeriod(json, 'applies', elem.applies); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') and (elem.subjectList.Count > 0) then
  begin
    startArray(json, 'subject', elem.subjectList, false);
    for i := 0 to elem.subjectList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.subjectList[i]); {z - Reference(Any)}
    finishArray(json, elem.subjectList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('authority') and (elem.authorityList.Count > 0) then
  begin
    startArray(json, 'authority', elem.authorityList, false);
    for i := 0 to elem.authorityList.Count - 1 do
      ComposeReference{TFhirOrganization}(json, '', elem.authorityList[i]); {z - Reference(Organization)}
    finishArray(json, elem.authorityList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('domain') and (elem.domainList.Count > 0) then
  begin
    startArray(json, 'domain', elem.domainList, false);
    for i := 0 to elem.domainList.Count - 1 do
      ComposeReference{TFhirLocation}(json, '', elem.domainList[i]); {z - Reference(Location)}
    finishArray(json, elem.domainList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subType') and (elem.subTypeList.Count > 0) then
  begin
    startArray(json, 'subType', elem.subTypeList, false);
    for i := 0 to elem.subTypeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.subTypeList[i]); {z - CodeableConcept}
    finishArray(json, elem.subTypeList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('action') and (elem.actionList.Count > 0) then
  begin
    startArray(json, 'action', elem.actionList, false);
    for i := 0 to elem.actionList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.actionList[i]); {z - CodeableConcept}
    finishArray(json, elem.actionList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('actionReason') and (elem.actionReasonList.Count > 0) then
  begin
    startArray(json, 'actionReason', elem.actionReasonList, false);
    for i := 0 to elem.actionReasonList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.actionReasonList[i]); {z - CodeableConcept}
    finishArray(json, elem.actionReasonList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('actor') and (elem.actorList.Count > 0) then
  begin
    startArray(json, 'actor', elem.actorList, false);
    for i := 0 to elem.actorList.Count - 1 do
      ComposeContractActor(json, '', elem.actorList[i]); {z - }
    finishArray(json, elem.actorList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('valuedItem') and (elem.valuedItemList.Count > 0) then
  begin
    startArray(json, 'valuedItem', elem.valuedItemList, false);
    for i := 0 to elem.valuedItemList.Count - 1 do
      ComposeContractValuedItem(json, '', elem.valuedItemList[i]); {z - }
    finishArray(json, elem.valuedItemList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('signer') and (elem.signerList.Count > 0) then
  begin
    startArray(json, 'signer', elem.signerList, false);
    for i := 0 to elem.signerList.Count - 1 do
      ComposeContractSigner(json, '', elem.signerList[i]); {z - }
    finishArray(json, elem.signerList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('term') and (elem.termList.Count > 0) then
  begin
    startArray(json, 'term', elem.termList, false);
    for i := 0 to elem.termList.Count - 1 do
      ComposeContractTerm(json, '', elem.termList[i]); {z - }
    finishArray(json, elem.termList);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.binding is TFhirAttachment) then 
    ComposeAttachment(json, 'bindingAttachment', TFhirAttachment(elem.binding)) 
  else if (SummaryOption in [soFull, soData]) and (elem.binding is TFhirReference) then
    ComposeReference(json, 'bindingReference', TFhirReference(elem.binding));
  if (SummaryOption in [soFull, soData]) and doCompose('friendly') and (elem.friendlyList.Count > 0) then
  begin
    startArray(json, 'friendly', elem.friendlyList, false);
    for i := 0 to elem.friendlyList.Count - 1 do
      ComposeContractFriendly(json, '', elem.friendlyList[i]); {z - }
    finishArray(json, elem.friendlyList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('legal') and (elem.legalList.Count > 0) then
  begin
    startArray(json, 'legal', elem.legalList, false);
    for i := 0 to elem.legalList.Count - 1 do
      ComposeContractLegal(json, '', elem.legalList[i]); {z - }
    finishArray(json, elem.legalList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('rule') and (elem.ruleList.Count > 0) then
  begin
    startArray(json, 'rule', elem.ruleList, false);
    for i := 0 to elem.ruleList.Count - 1 do
      ComposeContractRule(json, '', elem.ruleList[i]); {z - }
    finishArray(json, elem.ruleList);
  end;
end;

{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
procedure TFHIRJsonParser.ParseCoverage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseCoverage(jsn)); {2}
end;

function TFHIRJsonParser.ParseCoverage(jsn : TJsonObject) : TFhirCoverage;
begin
  result := TFhirCoverage.create;
  try
    ParseCoverageProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseCoverageProperties(jsn : TJsonObject; result : TFhirCoverage);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('issuer') then
        result.issuer := ParseReference{TFhirOrganization}(jsn.vObj['issuer']);{q3}
    if jsn.has('bin') then
        result.bin := ParseIdentifier(jsn.vObj['bin']);{q3}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q3}
    if jsn.has('subscriberId') then
        result.subscriberId := ParseIdentifier(jsn.vObj['subscriberId']);{q3}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('group') or jsn.has('_group') then
        result.groupElement := ParseString(jsn.node['group'], jsn.vObj['_group']);{q}
    if jsn.has('plan') or jsn.has('_plan') then
        result.planElement := ParseString(jsn.node['plan'], jsn.vObj['_plan']);{q}
    if jsn.has('subPlan') or jsn.has('_subPlan') then
        result.subPlanElement := ParseString(jsn.node['subPlan'], jsn.vObj['_subPlan']);{q}
    if jsn.has('dependent') or jsn.has('_dependent') then
        result.dependentElement := ParsePositiveInt(jsn.node['dependent'], jsn.vObj['_dependent']);{q}
    if jsn.has('sequence') or jsn.has('_sequence') then
        result.sequenceElement := ParsePositiveInt(jsn.node['sequence'], jsn.vObj['_sequence']);{q}
    if jsn.has('subscriber') then
        result.subscriber := ParseReference{TFhirPatient}(jsn.vObj['subscriber']);{q3}
    if jsn.has('network') then
        result.network := ParseIdentifier(jsn.vObj['network']);{q3}
    if jsn.has('contract') then
      iterateArray(jsn.vArr['contract'], result.contractList, parseReference{TFhirContract});
end;

procedure TFHIRJsonComposer.ComposeCoverage(json : TJSONWriter; name : string; elem : TFhirCoverage; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('issuer') then
    ComposeReference{TFhirOrganization}(json, 'issuer', elem.issuer); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('bin') then
    ComposeIdentifier(json, 'bin', elem.bin); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCoding(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subscriberId') then
    ComposeIdentifier(json, 'subscriberId', elem.subscriberId); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('group') then
    ComposeStringValue(json, 'group', elem.groupElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('group') then
    ComposeStringProps(json, 'group', elem.groupElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('plan') then
    ComposeStringValue(json, 'plan', elem.planElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('plan') then
    ComposeStringProps(json, 'plan', elem.planElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subPlan') then
    ComposeStringValue(json, 'subPlan', elem.subPlanElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subPlan') then
    ComposeStringProps(json, 'subPlan', elem.subPlanElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dependent') then
    ComposePositiveIntValue(json, 'dependent', elem.dependentElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dependent') then
    ComposePositiveIntProps(json, 'dependent', elem.dependentElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('sequence') then
    ComposePositiveIntValue(json, 'sequence', elem.sequenceElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('sequence') then
    ComposePositiveIntProps(json, 'sequence', elem.sequenceElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('subscriber') then
    ComposeReference{TFhirPatient}(json, 'subscriber', elem.subscriber); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('network') then
    ComposeIdentifier(json, 'network', elem.network); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('contract') and (elem.contractList.Count > 0) then
  begin
    startArray(json, 'contract', elem.contractList, false);
    for i := 0 to elem.contractList.Count - 1 do
      ComposeReference{TFhirContract}(json, '', elem.contractList[i]); {z - Reference(Contract)}
    finishArray(json, elem.contractList);
  end;
end;

{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_DATAELEMENT}
procedure TFHIRJsonParser.ParseDataElementContact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDataElementContact(jsn)); {2}
end;

function TFHIRJsonParser.ParseDataElementContact(jsn : TJsonObject) : TFhirDataElementContact;
begin
  result := TFhirDataElementContact.create;
  try
    ParseDataElementContactProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDataElementContactProperties(jsn : TJsonObject; result : TFhirDataElementContact);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
end;

procedure TFHIRJsonComposer.ComposeDataElementContact(json : TJSONWriter; name : string; elem : TFhirDataElementContact; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.telecomList.Count > 0) then
  begin
    startArray(json, 'telecom', elem.telecomList, false);
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    finishArray(json, elem.telecomList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseDataElementMapping(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDataElementMapping(jsn)); {2}
end;

function TFHIRJsonParser.ParseDataElementMapping(jsn : TJsonObject) : TFhirDataElementMapping;
begin
  result := TFhirDataElementMapping.create;
  try
    ParseDataElementMappingProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDataElementMappingProperties(jsn : TJsonObject; result : TFhirDataElementMapping);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identity') or jsn.has('_identity') then
        result.identityElement := ParseId(jsn.node['identity'], jsn.vObj['_identity']);{q}
    if jsn.has('uri') or jsn.has('_uri') then
        result.uriElement := ParseUri(jsn.node['uri'], jsn.vObj['_uri']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('comments') or jsn.has('_comments') then
        result.commentsElement := ParseString(jsn.node['comments'], jsn.vObj['_comments']);{q}
end;

procedure TFHIRJsonComposer.ComposeDataElementMapping(json : TJSONWriter; name : string; elem : TFhirDataElementMapping; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdValue(json, 'identity', elem.identityElement, false);
  ComposeIdProps(json, 'identity', elem.identityElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriValue(json, 'uri', elem.uriElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriProps(json, 'uri', elem.uriElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'comments', elem.commentsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'comments', elem.commentsElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseDataElement(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDataElement(jsn)); {2}
end;

function TFHIRJsonParser.ParseDataElement(jsn : TJsonObject) : TFhirDataElement;
begin
  result := TFhirDataElement.create;
  try
    ParseDataElementProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDataElementProperties(jsn : TJsonObject; result : TFhirDataElement);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := ParseBoolean(jsn.node['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := ParseString(jsn.node['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseDataElementContact);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseCodeableConcept);
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := ParseString(jsn.node['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('stringency') or jsn.has('_stringency')  then
      result.stringencyElement := parseEnum(jsn.path+'/stringency', jsn.node['stringency'], jsn.vObj['_stringency'], CODES_TFhirDataelementStringencyEnum, SYSTEMS_TFhirDataelementStringencyEnum);
    if jsn.has('mapping') then
      iterateArray(jsn.vArr['mapping'], result.mappingList, parseDataElementMapping);
    if jsn.has('element') then
      iterateArray(jsn.vArr['element'], result.elementList, parseElementDefinition);
end;

procedure TFHIRJsonComposer.ComposeDataElement(json : TJSONWriter; name : string; elem : TFhirDataElement; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    startArray(json, 'contact', elem.contactList, false);
    for i := 0 to elem.contactList.Count - 1 do
      ComposeDataElementContact(json, '', elem.contactList[i]); {z - }
    finishArray(json, elem.contactList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') and (elem.useContextList.Count > 0) then
  begin
    startArray(json, 'useContext', elem.useContextList, false);
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.useContextList[i]); {z - CodeableConcept}
    finishArray(json, elem.useContextList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeStringValue(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeStringProps(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('stringency') then
    ComposeEnumValue(json, 'stringency', elem.StringencyElement, CODES_TFhirDataelementStringencyEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('stringency') then
    ComposeEnumProps(json, 'stringency', elem.StringencyElement, CODES_TFhirDataelementStringencyEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('mapping') and (elem.mappingList.Count > 0) then
  begin
    startArray(json, 'mapping', elem.mappingList, false);
    for i := 0 to elem.mappingList.Count - 1 do
      ComposeDataElementMapping(json, '', elem.mappingList[i]); {z - }
    finishArray(json, elem.mappingList);
  end;
  if (elem.elementList.Count > 0) then
  begin
    startArray(json, 'element', elem.elementList, false);
    for i := 0 to elem.elementList.Count - 1 do
      ComposeElementDefinition(json, '', elem.elementList[i]); {z - ElementDefinition}
    finishArray(json, elem.elementList);
  end;
end;

{$ENDIF FHIR_DATAELEMENT}
{$IFDEF FHIR_DETECTEDISSUE}
procedure TFHIRJsonParser.ParseDetectedIssueMitigation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDetectedIssueMitigation(jsn)); {2}
end;

function TFHIRJsonParser.ParseDetectedIssueMitigation(jsn : TJsonObject) : TFhirDetectedIssueMitigation;
begin
  result := TFhirDetectedIssueMitigation.create;
  try
    ParseDetectedIssueMitigationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDetectedIssueMitigationProperties(jsn : TJsonObject; result : TFhirDetectedIssueMitigation);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('action') then
        result.action := ParseCodeableConcept(jsn.vObj['action']);{q3}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('author') then
        result.author := ParseReference{TFhirPractitioner}(jsn.vObj['author']);{q3}
end;

procedure TFHIRJsonComposer.ComposeDetectedIssueMitigation(json : TJSONWriter; name : string; elem : TFhirDetectedIssueMitigation; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'action', elem.action); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'author', elem.author); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseDetectedIssue(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDetectedIssue(jsn)); {2}
end;

function TFHIRJsonParser.ParseDetectedIssue(jsn : TJsonObject) : TFhirDetectedIssue;
begin
  result := TFhirDetectedIssue.create;
  try
    ParseDetectedIssueProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDetectedIssueProperties(jsn : TJsonObject; result : TFhirDetectedIssue);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q3}
    if jsn.has('severity') or jsn.has('_severity')  then
      result.severityElement := parseEnum(jsn.path+'/severity', jsn.node['severity'], jsn.vObj['_severity'], CODES_TFhirDetectedissueSeverityEnum, SYSTEMS_TFhirDetectedissueSeverityEnum);
    if jsn.has('implicated') then
      iterateArray(jsn.vArr['implicated'], result.implicatedList, parseReference{TFhirReference});
    if jsn.has('detail') or jsn.has('_detail') then
        result.detailElement := ParseString(jsn.node['detail'], jsn.vObj['_detail']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('author') then
        result.author := ParseReference{Resource}(jsn.vObj['author']);{q3}
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('reference') or jsn.has('_reference') then
        result.referenceElement := ParseUri(jsn.node['reference'], jsn.vObj['_reference']);{q}
    if jsn.has('mitigation') then
      iterateArray(jsn.vArr['mitigation'], result.mitigationList, parseDetectedIssueMitigation);
end;

procedure TFHIRJsonComposer.ComposeDetectedIssue(json : TJSONWriter; name : string; elem : TFhirDetectedIssue; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeCodeableConcept(json, 'category', elem.category); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('severity') then
    ComposeEnumValue(json, 'severity', elem.SeverityElement, CODES_TFhirDetectedissueSeverityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('severity') then
    ComposeEnumProps(json, 'severity', elem.SeverityElement, CODES_TFhirDetectedissueSeverityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('implicated') and (elem.implicatedList.Count > 0) then
  begin
    startArray(json, 'implicated', elem.implicatedList, false);
    for i := 0 to elem.implicatedList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.implicatedList[i]); {z - Reference(Any)}
    finishArray(json, elem.implicatedList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('detail') then
    ComposeStringValue(json, 'detail', elem.detailElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('detail') then
    ComposeStringProps(json, 'detail', elem.detailElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{Resource}(json, 'author', elem.author); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('reference') then
    ComposeUriValue(json, 'reference', elem.referenceElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('reference') then
    ComposeUriProps(json, 'reference', elem.referenceElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('mitigation') and (elem.mitigationList.Count > 0) then
  begin
    startArray(json, 'mitigation', elem.mitigationList, false);
    for i := 0 to elem.mitigationList.Count - 1 do
      ComposeDetectedIssueMitigation(json, '', elem.mitigationList[i]); {z - }
    finishArray(json, elem.mitigationList);
  end;
end;

{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
procedure TFHIRJsonParser.ParseDevice(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDevice(jsn)); {2}
end;

function TFHIRJsonParser.ParseDevice(jsn : TJsonObject) : TFhirDevice;
begin
  result := TFhirDevice.create;
  try
    ParseDeviceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDeviceProperties(jsn : TJsonObject; result : TFhirDevice);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirDevicestatusEnum, SYSTEMS_TFhirDevicestatusEnum);
    if jsn.has('manufacturer') or jsn.has('_manufacturer') then
        result.manufacturerElement := ParseString(jsn.node['manufacturer'], jsn.vObj['_manufacturer']);{q}
    if jsn.has('model') or jsn.has('_model') then
        result.modelElement := ParseString(jsn.node['model'], jsn.vObj['_model']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('manufactureDate') or jsn.has('_manufactureDate') then
        result.manufactureDateElement := ParseDateTime(jsn.node['manufactureDate'], jsn.vObj['_manufactureDate']);{q}
    if jsn.has('expiry') or jsn.has('_expiry') then
        result.expiryElement := ParseDateTime(jsn.node['expiry'], jsn.vObj['_expiry']);{q}
    if jsn.has('udi') or jsn.has('_udi') then
        result.udiElement := ParseString(jsn.node['udi'], jsn.vObj['_udi']);{q}
    if jsn.has('lotNumber') or jsn.has('_lotNumber') then
        result.lotNumberElement := ParseString(jsn.node['lotNumber'], jsn.vObj['_lotNumber']);{q}
    if jsn.has('owner') then
        result.owner := ParseReference{TFhirOrganization}(jsn.vObj['owner']);{q3}
    if jsn.has('location') then
        result.location := ParseReference{TFhirLocation}(jsn.vObj['location']);{q3}
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContactPoint);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn.node['url'], jsn.vObj['_url']);{q}
end;

procedure TFHIRJsonComposer.ComposeDevice(json : TJSONWriter; name : string; elem : TFhirDevice; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('note') and (elem.noteList.Count > 0) then
  begin
    startArray(json, 'note', elem.noteList, false);
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    finishArray(json, elem.noteList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirDevicestatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirDevicestatusEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('manufacturer') then
    ComposeStringValue(json, 'manufacturer', elem.manufacturerElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('manufacturer') then
    ComposeStringProps(json, 'manufacturer', elem.manufacturerElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('model') then
    ComposeStringValue(json, 'model', elem.modelElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('model') then
    ComposeStringProps(json, 'model', elem.modelElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('version') then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('version') then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('manufactureDate') then
    ComposeDateTimeValue(json, 'manufactureDate', elem.manufactureDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('manufactureDate') then
    ComposeDateTimeProps(json, 'manufactureDate', elem.manufactureDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('expiry') then
    ComposeDateTimeValue(json, 'expiry', elem.expiryElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('expiry') then
    ComposeDateTimeProps(json, 'expiry', elem.expiryElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('udi') then
    ComposeStringValue(json, 'udi', elem.udiElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('udi') then
    ComposeStringProps(json, 'udi', elem.udiElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('lotNumber') then
    ComposeStringValue(json, 'lotNumber', elem.lotNumberElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('lotNumber') then
    ComposeStringProps(json, 'lotNumber', elem.lotNumberElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('owner') then
    ComposeReference{TFhirOrganization}(json, 'owner', elem.owner); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('location') then
    ComposeReference{TFhirLocation}(json, 'location', elem.location); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    startArray(json, 'contact', elem.contactList, false);
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactPoint(json, '', elem.contactList[i]); {z - ContactPoint}
    finishArray(json, elem.contactList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('url') then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('url') then
    ComposeUriProps(json, 'url', elem.urlElement, false);
end;

{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICECOMPONENT}
procedure TFHIRJsonParser.ParseDeviceComponentProductionSpecification(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDeviceComponentProductionSpecification(jsn)); {2}
end;

function TFHIRJsonParser.ParseDeviceComponentProductionSpecification(jsn : TJsonObject) : TFhirDeviceComponentProductionSpecification;
begin
  result := TFhirDeviceComponentProductionSpecification.create;
  try
    ParseDeviceComponentProductionSpecificationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDeviceComponentProductionSpecificationProperties(jsn : TJsonObject; result : TFhirDeviceComponentProductionSpecification);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('specType') then
        result.specType := ParseCodeableConcept(jsn.vObj['specType']);{q3}
    if jsn.has('componentId') then
        result.componentId := ParseIdentifier(jsn.vObj['componentId']);{q3}
    if jsn.has('productionSpec') or jsn.has('_productionSpec') then
        result.productionSpecElement := ParseString(jsn.node['productionSpec'], jsn.vObj['_productionSpec']);{q}
end;

procedure TFHIRJsonComposer.ComposeDeviceComponentProductionSpecification(json : TJSONWriter; name : string; elem : TFhirDeviceComponentProductionSpecification; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'specType', elem.specType); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'componentId', elem.componentId); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'productionSpec', elem.productionSpecElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'productionSpec', elem.productionSpecElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseDeviceComponent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDeviceComponent(jsn)); {2}
end;

function TFHIRJsonParser.ParseDeviceComponent(jsn : TJsonObject) : TFhirDeviceComponent;
begin
  result := TFhirDeviceComponent.create;
  try
    ParseDeviceComponentProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDeviceComponentProperties(jsn : TJsonObject; result : TFhirDeviceComponent);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('lastSystemChange') or jsn.has('_lastSystemChange') then
        result.lastSystemChangeElement := ParseInstant(jsn.node['lastSystemChange'], jsn.vObj['_lastSystemChange']);{q}
    if jsn.has('source') then
        result.source := ParseReference{TFhirDevice}(jsn.vObj['source']);{q3}
    if jsn.has('parent') then
        result.parent := ParseReference{TFhirDeviceComponent}(jsn.vObj['parent']);{q3}
    if jsn.has('operationalStatus') then
      iterateArray(jsn.vArr['operationalStatus'], result.operationalStatusList, parseCodeableConcept);
    if jsn.has('parameterGroup') then
        result.parameterGroup := ParseCodeableConcept(jsn.vObj['parameterGroup']);{q3}
    if jsn.has('measurementPrinciple') or jsn.has('_measurementPrinciple')  then
      result.measurementPrincipleElement := parseEnum(jsn.path+'/measurementPrinciple', jsn.node['measurementPrinciple'], jsn.vObj['_measurementPrinciple'], CODES_TFhirMeasurementPrincipleEnum, SYSTEMS_TFhirMeasurementPrincipleEnum);
    if jsn.has('productionSpecification') then
      iterateArray(jsn.vArr['productionSpecification'], result.productionSpecificationList, parseDeviceComponentProductionSpecification);
    if jsn.has('languageCode') then
        result.languageCode := ParseCodeableConcept(jsn.vObj['languageCode']);{q3}
end;

procedure TFHIRJsonComposer.ComposeDeviceComponent(json : TJSONWriter; name : string; elem : TFhirDeviceComponent; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  ComposeInstantValue(json, 'lastSystemChange', elem.lastSystemChangeElement, false);
  ComposeInstantProps(json, 'lastSystemChange', elem.lastSystemChangeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('source') then
    ComposeReference{TFhirDevice}(json, 'source', elem.source); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('parent') then
    ComposeReference{TFhirDeviceComponent}(json, 'parent', elem.parent); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('operationalStatus') and (elem.operationalStatusList.Count > 0) then
  begin
    startArray(json, 'operationalStatus', elem.operationalStatusList, false);
    for i := 0 to elem.operationalStatusList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.operationalStatusList[i]); {z - CodeableConcept}
    finishArray(json, elem.operationalStatusList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('parameterGroup') then
    ComposeCodeableConcept(json, 'parameterGroup', elem.parameterGroup); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('measurementPrinciple') then
    ComposeEnumValue(json, 'measurementPrinciple', elem.MeasurementPrincipleElement, CODES_TFhirMeasurementPrincipleEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('measurementPrinciple') then
    ComposeEnumProps(json, 'measurementPrinciple', elem.MeasurementPrincipleElement, CODES_TFhirMeasurementPrincipleEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('productionSpecification') and (elem.productionSpecificationList.Count > 0) then
  begin
    startArray(json, 'productionSpecification', elem.productionSpecificationList, false);
    for i := 0 to elem.productionSpecificationList.Count - 1 do
      ComposeDeviceComponentProductionSpecification(json, '', elem.productionSpecificationList[i]); {z - }
    finishArray(json, elem.productionSpecificationList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('languageCode') then
    ComposeCodeableConcept(json, 'languageCode', elem.languageCode); {a}
end;

{$ENDIF FHIR_DEVICECOMPONENT}
{$IFDEF FHIR_DEVICEMETRIC}
procedure TFHIRJsonParser.ParseDeviceMetricCalibration(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDeviceMetricCalibration(jsn)); {2}
end;

function TFHIRJsonParser.ParseDeviceMetricCalibration(jsn : TJsonObject) : TFhirDeviceMetricCalibration;
begin
  result := TFhirDeviceMetricCalibration.create;
  try
    ParseDeviceMetricCalibrationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDeviceMetricCalibrationProperties(jsn : TJsonObject; result : TFhirDeviceMetricCalibration);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirMetricCalibrationTypeEnum, SYSTEMS_TFhirMetricCalibrationTypeEnum);
    if jsn.has('state') or jsn.has('_state')  then
      result.stateElement := parseEnum(jsn.path+'/state', jsn.node['state'], jsn.vObj['_state'], CODES_TFhirMetricCalibrationStateEnum, SYSTEMS_TFhirMetricCalibrationStateEnum);
    if jsn.has('time') or jsn.has('_time') then
        result.timeElement := ParseInstant(jsn.node['time'], jsn.vObj['_time']);{q}
end;

procedure TFHIRJsonComposer.ComposeDeviceMetricCalibration(json : TJSONWriter; name : string; elem : TFhirDeviceMetricCalibration; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirMetricCalibrationTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirMetricCalibrationTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumValue(json, 'state', elem.StateElement, CODES_TFhirMetricCalibrationStateEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumProps(json, 'state', elem.StateElement, CODES_TFhirMetricCalibrationStateEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstantValue(json, 'time', elem.timeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstantProps(json, 'time', elem.timeElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseDeviceMetric(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDeviceMetric(jsn)); {2}
end;

function TFHIRJsonParser.ParseDeviceMetric(jsn : TJsonObject) : TFhirDeviceMetric;
begin
  result := TFhirDeviceMetric.create;
  try
    ParseDeviceMetricProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDeviceMetricProperties(jsn : TJsonObject; result : TFhirDeviceMetric);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('unit') then
        result.unit_ := ParseCodeableConcept(jsn.vObj['unit']);{q3}
    if jsn.has('source') then
        result.source := ParseReference{TFhirDevice}(jsn.vObj['source']);{q3}
    if jsn.has('parent') then
        result.parent := ParseReference{TFhirDeviceComponent}(jsn.vObj['parent']);{q3}
    if jsn.has('operationalStatus') or jsn.has('_operationalStatus')  then
      result.operationalStatusElement := parseEnum(jsn.path+'/operationalStatus', jsn.node['operationalStatus'], jsn.vObj['_operationalStatus'], CODES_TFhirMetricOperationalStatusEnum, SYSTEMS_TFhirMetricOperationalStatusEnum);
    if jsn.has('color') or jsn.has('_color')  then
      result.colorElement := parseEnum(jsn.path+'/color', jsn.node['color'], jsn.vObj['_color'], CODES_TFhirMetricColorEnum, SYSTEMS_TFhirMetricColorEnum);
    if jsn.has('category') or jsn.has('_category')  then
      result.categoryElement := parseEnum(jsn.path+'/category', jsn.node['category'], jsn.vObj['_category'], CODES_TFhirMetricCategoryEnum, SYSTEMS_TFhirMetricCategoryEnum);
    if jsn.has('measurementPeriod') then
        result.measurementPeriod := ParseTiming(jsn.vObj['measurementPeriod']);{q3}
    if jsn.has('calibration') then
      iterateArray(jsn.vArr['calibration'], result.calibrationList, parseDeviceMetricCalibration);
end;

procedure TFHIRJsonComposer.ComposeDeviceMetric(json : TJSONWriter; name : string; elem : TFhirDeviceMetric; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('unit_') then
    ComposeCodeableConcept(json, 'unit', elem.unit_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('source') then
    ComposeReference{TFhirDevice}(json, 'source', elem.source); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('parent') then
    ComposeReference{TFhirDeviceComponent}(json, 'parent', elem.parent); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('operationalStatus') then
    ComposeEnumValue(json, 'operationalStatus', elem.OperationalStatusElement, CODES_TFhirMetricOperationalStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('operationalStatus') then
    ComposeEnumProps(json, 'operationalStatus', elem.OperationalStatusElement, CODES_TFhirMetricOperationalStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('color') then
    ComposeEnumValue(json, 'color', elem.ColorElement, CODES_TFhirMetricColorEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('color') then
    ComposeEnumProps(json, 'color', elem.ColorElement, CODES_TFhirMetricColorEnum, false);
  ComposeEnumValue(json, 'category', elem.CategoryElement, CODES_TFhirMetricCategoryEnum, false);
  ComposeEnumProps(json, 'category', elem.CategoryElement, CODES_TFhirMetricCategoryEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('measurementPeriod') then
    ComposeTiming(json, 'measurementPeriod', elem.measurementPeriod); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('calibration') and (elem.calibrationList.Count > 0) then
  begin
    startArray(json, 'calibration', elem.calibrationList, false);
    for i := 0 to elem.calibrationList.Count - 1 do
      ComposeDeviceMetricCalibration(json, '', elem.calibrationList[i]); {z - }
    finishArray(json, elem.calibrationList);
  end;
end;

{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEUSEREQUEST}
procedure TFHIRJsonParser.ParseDeviceUseRequest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDeviceUseRequest(jsn)); {2}
end;

function TFHIRJsonParser.ParseDeviceUseRequest(jsn : TJsonObject) : TFhirDeviceUseRequest;
begin
  result := TFhirDeviceUseRequest.create;
  try
    ParseDeviceUseRequestProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDeviceUseRequestProperties(jsn : TJsonObject; result : TFhirDeviceUseRequest);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('bodySiteCodeableConcept') {a4} then
      result.bodySite := ParseCodeableConcept(jsn.vObj['bodySiteCodeableConcept']);
    if jsn.has('bodySiteReference') {a3} then
      result.bodySite := ParseReference(jsn.vObj['bodySiteReference']);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirDeviceUseRequestStatusEnum, SYSTEMS_TFhirDeviceUseRequestStatusEnum);
    if jsn.has('device') then
        result.device := ParseReference{TFhirDevice}(jsn.vObj['device']);{q3}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('indication') then
      iterateArray(jsn.vArr['indication'], result.indicationList, parseCodeableConcept);
      if jsn.has('notes') or jsn.has('_notes') then
      iteratePrimitiveArray(jsn.vArr['notes'], jsn.vArr['_notes'], result.notesList, parseString);
    if jsn.has('prnReason') then
      iterateArray(jsn.vArr['prnReason'], result.prnReasonList, parseCodeableConcept);
    if jsn.has('orderedOn') or jsn.has('_orderedOn') then
        result.orderedOnElement := ParseDateTime(jsn.node['orderedOn'], jsn.vObj['_orderedOn']);{q}
    if jsn.has('recordedOn') or jsn.has('_recordedOn') then
        result.recordedOnElement := ParseDateTime(jsn.node['recordedOn'], jsn.vObj['_recordedOn']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q3}
    if jsn.has('timingTiming') {a4} then
      result.timing := ParseTiming(jsn.vObj['timingTiming']);
    if jsn.has('timingPeriod') {a4} then
      result.timing := ParsePeriod(jsn.vObj['timingPeriod']);
    if jsn.has('timingDateTime') or jsn.has('_timingDateTime') then
      result.timing := ParseDateTime(jsn.node['timingDateTime'], jsn.vObj['_timingDateTime']);
    if jsn.has('priority') or jsn.has('_priority')  then
      result.priorityElement := parseEnum(jsn.path+'/priority', jsn.node['priority'], jsn.vObj['_priority'], CODES_TFhirDeviceUseRequestPriorityEnum, SYSTEMS_TFhirDeviceUseRequestPriorityEnum);
end;

procedure TFHIRJsonComposer.ComposeDeviceUseRequest(json : TJSONWriter; name : string; elem : TFhirDeviceUseRequest; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.bodySite is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'bodySiteCodeableConcept', TFhirCodeableConcept(elem.bodySite)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.bodySite is TFhirReference) then
    ComposeReference(json, 'bodySiteReference', TFhirReference(elem.bodySite));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirDeviceUseRequestStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirDeviceUseRequestStatusEnum, false);
  ComposeReference{TFhirDevice}(json, 'device', elem.device); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('indication') and (elem.indicationList.Count > 0) then
  begin
    startArray(json, 'indication', elem.indicationList, false);
    for i := 0 to elem.indicationList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.indicationList[i]); {z - CodeableConcept}
    finishArray(json, elem.indicationList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('notes') and (elem.notesList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.notesList.Count - 1 do
    begin
      ext := ext or ((elem.notesList[i].id <> '') or (elem.notesList[i].hasExtensionList) {no-comments or (elem.notesList[i].hasComments)});
      val := val or (elem.notesList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      startArray(json, 'notes', elem.notesList, true);
      for i := 0 to elem.notesList.Count - 1 do
        ComposeStringValue(json, '',elem.notesList[i], true);
      finishArray(json, elem.notesList);
    end;
    if ext then
    begin
      startArray(json, '_notes', elem.notesList, false);
      for i := 0 to elem.notesList.Count - 1 do
        ComposeStringProps(json, '',elem.notesList[i], true);
      finishArray(json, elem.notesList);
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('prnReason') and (elem.prnReasonList.Count > 0) then
  begin
    startArray(json, 'prnReason', elem.prnReasonList, false);
    for i := 0 to elem.prnReasonList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.prnReasonList[i]); {z - CodeableConcept}
    finishArray(json, elem.prnReasonList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('orderedOn') then
    ComposeDateTimeValue(json, 'orderedOn', elem.orderedOnElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('orderedOn') then
    ComposeDateTimeProps(json, 'orderedOn', elem.orderedOnElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recordedOn') then
    ComposeDateTimeValue(json, 'recordedOn', elem.recordedOnElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recordedOn') then
    ComposeDateTimeProps(json, 'recordedOn', elem.recordedOnElement, false);
  ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.timing is TFhirTiming) then 
    ComposeTiming(json, 'timingTiming', TFhirTiming(elem.timing)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.timing is TFhirPeriod) then 
    ComposePeriod(json, 'timingPeriod', TFhirPeriod(elem.timing)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.timing is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'timingDateTime', TFhirDateTime(elem.timing), false);
    ComposeDateTimeProps(json, 'timingDateTime', TFhirDateTime(elem.timing), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnumValue(json, 'priority', elem.PriorityElement, CODES_TFhirDeviceUseRequestPriorityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnumProps(json, 'priority', elem.PriorityElement, CODES_TFhirDeviceUseRequestPriorityEnum, false);
end;

{$ENDIF FHIR_DEVICEUSEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
procedure TFHIRJsonParser.ParseDeviceUseStatement(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDeviceUseStatement(jsn)); {2}
end;

function TFHIRJsonParser.ParseDeviceUseStatement(jsn : TJsonObject) : TFhirDeviceUseStatement;
begin
  result := TFhirDeviceUseStatement.create;
  try
    ParseDeviceUseStatementProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDeviceUseStatementProperties(jsn : TJsonObject; result : TFhirDeviceUseStatement);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('bodySiteCodeableConcept') {a4} then
      result.bodySite := ParseCodeableConcept(jsn.vObj['bodySiteCodeableConcept']);
    if jsn.has('bodySiteReference') {a3} then
      result.bodySite := ParseReference(jsn.vObj['bodySiteReference']);
    if jsn.has('whenUsed') then
        result.whenUsed := ParsePeriod(jsn.vObj['whenUsed']);{q3}
    if jsn.has('device') then
        result.device := ParseReference{TFhirDevice}(jsn.vObj['device']);{q3}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('indication') then
      iterateArray(jsn.vArr['indication'], result.indicationList, parseCodeableConcept);
      if jsn.has('notes') or jsn.has('_notes') then
      iteratePrimitiveArray(jsn.vArr['notes'], jsn.vArr['_notes'], result.notesList, parseString);
    if jsn.has('recordedOn') or jsn.has('_recordedOn') then
        result.recordedOnElement := ParseDateTime(jsn.node['recordedOn'], jsn.vObj['_recordedOn']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q3}
    if jsn.has('timingTiming') {a4} then
      result.timing := ParseTiming(jsn.vObj['timingTiming']);
    if jsn.has('timingPeriod') {a4} then
      result.timing := ParsePeriod(jsn.vObj['timingPeriod']);
    if jsn.has('timingDateTime') or jsn.has('_timingDateTime') then
      result.timing := ParseDateTime(jsn.node['timingDateTime'], jsn.vObj['_timingDateTime']);
end;

procedure TFHIRJsonComposer.ComposeDeviceUseStatement(json : TJSONWriter; name : string; elem : TFhirDeviceUseStatement; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.bodySite is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'bodySiteCodeableConcept', TFhirCodeableConcept(elem.bodySite)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.bodySite is TFhirReference) then
    ComposeReference(json, 'bodySiteReference', TFhirReference(elem.bodySite));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('whenUsed') then
    ComposePeriod(json, 'whenUsed', elem.whenUsed); {a}
  ComposeReference{TFhirDevice}(json, 'device', elem.device); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('indication') and (elem.indicationList.Count > 0) then
  begin
    startArray(json, 'indication', elem.indicationList, false);
    for i := 0 to elem.indicationList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.indicationList[i]); {z - CodeableConcept}
    finishArray(json, elem.indicationList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('notes') and (elem.notesList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.notesList.Count - 1 do
    begin
      ext := ext or ((elem.notesList[i].id <> '') or (elem.notesList[i].hasExtensionList) {no-comments or (elem.notesList[i].hasComments)});
      val := val or (elem.notesList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      startArray(json, 'notes', elem.notesList, true);
      for i := 0 to elem.notesList.Count - 1 do
        ComposeStringValue(json, '',elem.notesList[i], true);
      finishArray(json, elem.notesList);
    end;
    if ext then
    begin
      startArray(json, '_notes', elem.notesList, false);
      for i := 0 to elem.notesList.Count - 1 do
        ComposeStringProps(json, '',elem.notesList[i], true);
      finishArray(json, elem.notesList);
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recordedOn') then
    ComposeDateTimeValue(json, 'recordedOn', elem.recordedOnElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recordedOn') then
    ComposeDateTimeProps(json, 'recordedOn', elem.recordedOnElement, false);
  ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.timing is TFhirTiming) then 
    ComposeTiming(json, 'timingTiming', TFhirTiming(elem.timing)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.timing is TFhirPeriod) then 
    ComposePeriod(json, 'timingPeriod', TFhirPeriod(elem.timing)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.timing is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'timingDateTime', TFhirDateTime(elem.timing), false);
    ComposeDateTimeProps(json, 'timingDateTime', TFhirDateTime(elem.timing), false);
  end;
end;

{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICORDER}
procedure TFHIRJsonParser.ParseDiagnosticOrderEvent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDiagnosticOrderEvent(jsn)); {2}
end;

function TFHIRJsonParser.ParseDiagnosticOrderEvent(jsn : TJsonObject) : TFhirDiagnosticOrderEvent;
begin
  result := TFhirDiagnosticOrderEvent.create;
  try
    ParseDiagnosticOrderEventProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDiagnosticOrderEventProperties(jsn : TJsonObject; result : TFhirDiagnosticOrderEvent);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirDiagnosticOrderStatusEnum, SYSTEMS_TFhirDiagnosticOrderStatusEnum);
    if jsn.has('description') then
        result.description := ParseCodeableConcept(jsn.vObj['description']);{q3}
    if jsn.has('dateTime') or jsn.has('_dateTime') then
        result.dateTimeElement := ParseDateTime(jsn.node['dateTime'], jsn.vObj['_dateTime']);{q}
    if jsn.has('actor') then
        result.actor := ParseReference{Resource}(jsn.vObj['actor']);{q3}
end;

procedure TFHIRJsonComposer.ComposeDiagnosticOrderEvent(json : TJSONWriter; name : string; elem : TFhirDiagnosticOrderEvent; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirDiagnosticOrderStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirDiagnosticOrderStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'description', elem.description); {a}
  ComposeDateTimeValue(json, 'dateTime', elem.dateTimeElement, false);
  ComposeDateTimeProps(json, 'dateTime', elem.dateTimeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(json, 'actor', elem.actor); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseDiagnosticOrderItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDiagnosticOrderItem(jsn)); {2}
end;

function TFHIRJsonParser.ParseDiagnosticOrderItem(jsn : TJsonObject) : TFhirDiagnosticOrderItem;
begin
  result := TFhirDiagnosticOrderItem.create;
  try
    ParseDiagnosticOrderItemProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDiagnosticOrderItemProperties(jsn : TJsonObject; result : TFhirDiagnosticOrderItem);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('specimen') then
      iterateArray(jsn.vArr['specimen'], result.specimenList, parseReference{TFhirSpecimen});
    if jsn.has('bodySite') then
        result.bodySite := ParseCodeableConcept(jsn.vObj['bodySite']);{q3}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirDiagnosticOrderStatusEnum, SYSTEMS_TFhirDiagnosticOrderStatusEnum);
    if jsn.has('event') then
      iterateArray(jsn.vArr['event'], result.eventList, parseDiagnosticOrderEvent);
end;

procedure TFHIRJsonComposer.ComposeDiagnosticOrderItem(json : TJSONWriter; name : string; elem : TFhirDiagnosticOrderItem; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soData]) and (elem.specimenList.Count > 0) then
  begin
    startArray(json, 'specimen', elem.specimenList, false);
    for i := 0 to elem.specimenList.Count - 1 do
      ComposeReference{TFhirSpecimen}(json, '', elem.specimenList[i]); {z - Reference(Specimen)}
    finishArray(json, elem.specimenList);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'bodySite', elem.bodySite); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirDiagnosticOrderStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirDiagnosticOrderStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.eventList.Count > 0) then
  begin
    startArray(json, 'event', elem.eventList, false);
    for i := 0 to elem.eventList.Count - 1 do
      ComposeDiagnosticOrderEvent(json, '', elem.eventList[i]); {z - @DiagnosticOrder.event}
    finishArray(json, elem.eventList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseDiagnosticOrder(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDiagnosticOrder(jsn)); {2}
end;

function TFHIRJsonParser.ParseDiagnosticOrder(jsn : TJsonObject) : TFhirDiagnosticOrder;
begin
  result := TFhirDiagnosticOrder.create;
  try
    ParseDiagnosticOrderProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDiagnosticOrderProperties(jsn : TJsonObject; result : TFhirDiagnosticOrder);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q3}
    if jsn.has('orderer') then
        result.orderer := ParseReference{TFhirPractitioner}(jsn.vObj['orderer']);{q3}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('reason') then
      iterateArray(jsn.vArr['reason'], result.reasonList, parseCodeableConcept);
    if jsn.has('supportingInformation') then
      iterateArray(jsn.vArr['supportingInformation'], result.supportingInformationList, parseReference{Resource});
    if jsn.has('specimen') then
      iterateArray(jsn.vArr['specimen'], result.specimenList, parseReference{TFhirSpecimen});
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirDiagnosticOrderStatusEnum, SYSTEMS_TFhirDiagnosticOrderStatusEnum);
    if jsn.has('priority') or jsn.has('_priority')  then
      result.priorityElement := parseEnum(jsn.path+'/priority', jsn.node['priority'], jsn.vObj['_priority'], CODES_TFhirDiagnosticOrderPriorityEnum, SYSTEMS_TFhirDiagnosticOrderPriorityEnum);
    if jsn.has('event') then
      iterateArray(jsn.vArr['event'], result.eventList, parseDiagnosticOrderEvent);
    if jsn.has('item') then
      iterateArray(jsn.vArr['item'], result.itemList, parseDiagnosticOrderItem);
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
end;

procedure TFHIRJsonComposer.ComposeDiagnosticOrder(json : TJSONWriter; name : string; elem : TFhirDiagnosticOrder; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('orderer') then
    ComposeReference{TFhirPractitioner}(json, 'orderer', elem.orderer); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('reason') and (elem.reasonList.Count > 0) then
  begin
    startArray(json, 'reason', elem.reasonList, false);
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonList[i]); {z - CodeableConcept}
    finishArray(json, elem.reasonList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInformation') and (elem.supportingInformationList.Count > 0) then
  begin
    startArray(json, 'supportingInformation', elem.supportingInformationList, false);
    for i := 0 to elem.supportingInformationList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.supportingInformationList[i]); {z - Reference(Observation|Condition|DocumentReference)}
    finishArray(json, elem.supportingInformationList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('specimen') and (elem.specimenList.Count > 0) then
  begin
    startArray(json, 'specimen', elem.specimenList, false);
    for i := 0 to elem.specimenList.Count - 1 do
      ComposeReference{TFhirSpecimen}(json, '', elem.specimenList[i]); {z - Reference(Specimen)}
    finishArray(json, elem.specimenList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirDiagnosticOrderStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirDiagnosticOrderStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnumValue(json, 'priority', elem.PriorityElement, CODES_TFhirDiagnosticOrderPriorityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnumProps(json, 'priority', elem.PriorityElement, CODES_TFhirDiagnosticOrderPriorityEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('event') and (elem.eventList.Count > 0) then
  begin
    startArray(json, 'event', elem.eventList, false);
    for i := 0 to elem.eventList.Count - 1 do
      ComposeDiagnosticOrderEvent(json, '', elem.eventList[i]); {z - }
    finishArray(json, elem.eventList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('item') and (elem.itemList.Count > 0) then
  begin
    startArray(json, 'item', elem.itemList, false);
    for i := 0 to elem.itemList.Count - 1 do
      ComposeDiagnosticOrderItem(json, '', elem.itemList[i]); {z - }
    finishArray(json, elem.itemList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('note') and (elem.noteList.Count > 0) then
  begin
    startArray(json, 'note', elem.noteList, false);
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    finishArray(json, elem.noteList);
  end;
end;

{$ENDIF FHIR_DIAGNOSTICORDER}
{$IFDEF FHIR_DIAGNOSTICREPORT}
procedure TFHIRJsonParser.ParseDiagnosticReportImage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDiagnosticReportImage(jsn)); {2}
end;

function TFHIRJsonParser.ParseDiagnosticReportImage(jsn : TJsonObject) : TFhirDiagnosticReportImage;
begin
  result := TFhirDiagnosticReportImage.create;
  try
    ParseDiagnosticReportImageProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDiagnosticReportImageProperties(jsn : TJsonObject; result : TFhirDiagnosticReportImage);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('comment') or jsn.has('_comment') then
        result.commentElement := ParseString(jsn.node['comment'], jsn.vObj['_comment']);{q}
    if jsn.has('link') then
        result.link_ := ParseReference{TFhirMedia}(jsn.vObj['link']);{q3}
end;

procedure TFHIRJsonComposer.ComposeDiagnosticReportImage(json : TJSONWriter; name : string; elem : TFhirDiagnosticReportImage; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'comment', elem.commentElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'comment', elem.commentElement, false);
  ComposeReference{TFhirMedia}(json, 'link', elem.link_); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseDiagnosticReport(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDiagnosticReport(jsn)); {2}
end;

function TFHIRJsonParser.ParseDiagnosticReport(jsn : TJsonObject) : TFhirDiagnosticReport;
begin
  result := TFhirDiagnosticReport.create;
  try
    ParseDiagnosticReportProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDiagnosticReportProperties(jsn : TJsonObject; result : TFhirDiagnosticReport);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirDiagnosticReportStatusEnum, SYSTEMS_TFhirDiagnosticReportStatusEnum);
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q3}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q3}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('effectivePeriod') {a4} then
      result.effective := ParsePeriod(jsn.vObj['effectivePeriod']);
    if jsn.has('effectiveDateTime') or jsn.has('_effectiveDateTime') then
      result.effective := ParseDateTime(jsn.node['effectiveDateTime'], jsn.vObj['_effectiveDateTime']);
    if jsn.has('issued') or jsn.has('_issued') then
        result.issuedElement := ParseInstant(jsn.node['issued'], jsn.vObj['_issued']);{q}
    if jsn.has('performer') then
        result.performer := ParseReference{Resource}(jsn.vObj['performer']);{q3}
    if jsn.has('request') then
      iterateArray(jsn.vArr['request'], result.requestList, parseReference{Resource});
    if jsn.has('specimen') then
      iterateArray(jsn.vArr['specimen'], result.specimenList, parseReference{TFhirSpecimen});
    if jsn.has('result') then
      iterateArray(jsn.vArr['result'], result.resultList, parseReference{TFhirObservation});
    if jsn.has('imagingStudy') then
      iterateArray(jsn.vArr['imagingStudy'], result.imagingStudyList, parseReference{Resource});
    if jsn.has('image') then
      iterateArray(jsn.vArr['image'], result.imageList, parseDiagnosticReportImage);
    if jsn.has('conclusion') or jsn.has('_conclusion') then
        result.conclusionElement := ParseString(jsn.node['conclusion'], jsn.vObj['_conclusion']);{q}
    if jsn.has('codedDiagnosis') then
      iterateArray(jsn.vArr['codedDiagnosis'], result.codedDiagnosisList, parseCodeableConcept);
    if jsn.has('presentedForm') then
      iterateArray(jsn.vArr['presentedForm'], result.presentedFormList, parseAttachment);
end;

procedure TFHIRJsonComposer.ComposeDiagnosticReport(json : TJSONWriter; name : string; elem : TFhirDiagnosticReport; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirDiagnosticReportStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirDiagnosticReportStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeCodeableConcept(json, 'category', elem.category); {a}
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (elem.effective is TFhirPeriod) then 
    ComposePeriod(json, 'effectivePeriod', TFhirPeriod(elem.effective)) 
  else if (elem.effective is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'effectiveDateTime', TFhirDateTime(elem.effective), false);
    ComposeDateTimeProps(json, 'effectiveDateTime', TFhirDateTime(elem.effective), false);
  end;
  ComposeInstantValue(json, 'issued', elem.issuedElement, false);
  ComposeInstantProps(json, 'issued', elem.issuedElement, false);
  ComposeReference{Resource}(json, 'performer', elem.performer); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('request') and (elem.requestList.Count > 0) then
  begin
    startArray(json, 'request', elem.requestList, false);
    for i := 0 to elem.requestList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.requestList[i]); {z - Reference(DiagnosticOrder|ProcedureRequest|ReferralRequest)}
    finishArray(json, elem.requestList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('specimen') and (elem.specimenList.Count > 0) then
  begin
    startArray(json, 'specimen', elem.specimenList, false);
    for i := 0 to elem.specimenList.Count - 1 do
      ComposeReference{TFhirSpecimen}(json, '', elem.specimenList[i]); {z - Reference(Specimen)}
    finishArray(json, elem.specimenList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('result') and (elem.resultList.Count > 0) then
  begin
    startArray(json, 'result', elem.resultList, false);
    for i := 0 to elem.resultList.Count - 1 do
      ComposeReference{TFhirObservation}(json, '', elem.resultList[i]); {z - Reference(Observation)}
    finishArray(json, elem.resultList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('imagingStudy') and (elem.imagingStudyList.Count > 0) then
  begin
    startArray(json, 'imagingStudy', elem.imagingStudyList, false);
    for i := 0 to elem.imagingStudyList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.imagingStudyList[i]); {z - Reference(ImagingStudy|ImagingObjectSelection)}
    finishArray(json, elem.imagingStudyList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('image') and (elem.imageList.Count > 0) then
  begin
    startArray(json, 'image', elem.imageList, false);
    for i := 0 to elem.imageList.Count - 1 do
      ComposeDiagnosticReportImage(json, '', elem.imageList[i]); {z - }
    finishArray(json, elem.imageList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('conclusion') then
    ComposeStringValue(json, 'conclusion', elem.conclusionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('conclusion') then
    ComposeStringProps(json, 'conclusion', elem.conclusionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('codedDiagnosis') and (elem.codedDiagnosisList.Count > 0) then
  begin
    startArray(json, 'codedDiagnosis', elem.codedDiagnosisList, false);
    for i := 0 to elem.codedDiagnosisList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.codedDiagnosisList[i]); {z - CodeableConcept}
    finishArray(json, elem.codedDiagnosisList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('presentedForm') and (elem.presentedFormList.Count > 0) then
  begin
    startArray(json, 'presentedForm', elem.presentedFormList, false);
    for i := 0 to elem.presentedFormList.Count - 1 do
      ComposeAttachment(json, '', elem.presentedFormList[i]); {z - Attachment}
    finishArray(json, elem.presentedFormList);
  end;
end;

{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
procedure TFHIRJsonParser.ParseDocumentManifestContent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDocumentManifestContent(jsn)); {2}
end;

function TFHIRJsonParser.ParseDocumentManifestContent(jsn : TJsonObject) : TFhirDocumentManifestContent;
begin
  result := TFhirDocumentManifestContent.create;
  try
    ParseDocumentManifestContentProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDocumentManifestContentProperties(jsn : TJsonObject; result : TFhirDocumentManifestContent);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('pAttachment') {a4} then
      result.p := ParseAttachment(jsn.vObj['pAttachment']);
    if jsn.has('pReference') {a3} then
      result.p := ParseReference(jsn.vObj['pReference']);
end;

procedure TFHIRJsonComposer.ComposeDocumentManifestContent(json : TJSONWriter; name : string; elem : TFhirDocumentManifestContent; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (elem.p is TFhirAttachment) then 
    ComposeAttachment(json, 'pAttachment', TFhirAttachment(elem.p)) 
  else if (elem.p is TFhirReference) then
    ComposeReference(json, 'pReference', TFhirReference(elem.p));
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseDocumentManifestRelated(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDocumentManifestRelated(jsn)); {2}
end;

function TFHIRJsonParser.ParseDocumentManifestRelated(jsn : TJsonObject) : TFhirDocumentManifestRelated;
begin
  result := TFhirDocumentManifestRelated.create;
  try
    ParseDocumentManifestRelatedProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDocumentManifestRelatedProperties(jsn : TJsonObject; result : TFhirDocumentManifestRelated);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('ref') then
        result.ref := ParseReference{TFhirReference}(jsn.vObj['ref']);{q3}
end;

procedure TFHIRJsonComposer.ComposeDocumentManifestRelated(json : TJSONWriter; name : string; elem : TFhirDocumentManifestRelated; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(json, 'ref', elem.ref); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseDocumentManifest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDocumentManifest(jsn)); {2}
end;

function TFHIRJsonParser.ParseDocumentManifest(jsn : TJsonObject) : TFhirDocumentManifest;
begin
  result := TFhirDocumentManifest.create;
  try
    ParseDocumentManifestProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDocumentManifestProperties(jsn : TJsonObject; result : TFhirDocumentManifest);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('masterIdentifier') then
        result.masterIdentifier := ParseIdentifier(jsn.vObj['masterIdentifier']);{q3}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q3}
    if jsn.has('recipient') then
      iterateArray(jsn.vArr['recipient'], result.recipientList, parseReference{Resource});
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('author') then
      iterateArray(jsn.vArr['author'], result.authorList, parseReference{Resource});
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := ParseDateTime(jsn.node['created'], jsn.vObj['_created']);{q}
    if jsn.has('source') or jsn.has('_source') then
        result.sourceElement := ParseUri(jsn.node['source'], jsn.vObj['_source']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirDocumentReferenceStatusEnum, SYSTEMS_TFhirDocumentReferenceStatusEnum);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('content') then
      iterateArray(jsn.vArr['content'], result.contentList, parseDocumentManifestContent);
    if jsn.has('related') then
      iterateArray(jsn.vArr['related'], result.relatedList, parseDocumentManifestRelated);
end;

procedure TFHIRJsonComposer.ComposeDocumentManifest(json : TJSONWriter; name : string; elem : TFhirDocumentManifest; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('masterIdentifier') then
    ComposeIdentifier(json, 'masterIdentifier', elem.masterIdentifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recipient') and (elem.recipientList.Count > 0) then
  begin
    startArray(json, 'recipient', elem.recipientList, false);
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.recipientList[i]); {z - Reference(Patient|Practitioner|RelatedPerson|Organization)}
    finishArray(json, elem.recipientList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') and (elem.authorList.Count > 0) then
  begin
    startArray(json, 'author', elem.authorList, false);
    for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.authorList[i]); {z - Reference(Practitioner|Organization|Device|Patient|RelatedPerson)}
    finishArray(json, elem.authorList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('source') then
    ComposeUriValue(json, 'source', elem.sourceElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('source') then
    ComposeUriProps(json, 'source', elem.sourceElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirDocumentReferenceStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirDocumentReferenceStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (elem.contentList.Count > 0) then
  begin
    startArray(json, 'content', elem.contentList, false);
    for i := 0 to elem.contentList.Count - 1 do
      ComposeDocumentManifestContent(json, '', elem.contentList[i]); {z - }
    finishArray(json, elem.contentList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('related') and (elem.relatedList.Count > 0) then
  begin
    startArray(json, 'related', elem.relatedList, false);
    for i := 0 to elem.relatedList.Count - 1 do
      ComposeDocumentManifestRelated(json, '', elem.relatedList[i]); {z - }
    finishArray(json, elem.relatedList);
  end;
end;

{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
procedure TFHIRJsonParser.ParseDocumentReferenceRelatesTo(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDocumentReferenceRelatesTo(jsn)); {2}
end;

function TFHIRJsonParser.ParseDocumentReferenceRelatesTo(jsn : TJsonObject) : TFhirDocumentReferenceRelatesTo;
begin
  result := TFhirDocumentReferenceRelatesTo.create;
  try
    ParseDocumentReferenceRelatesToProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDocumentReferenceRelatesToProperties(jsn : TJsonObject; result : TFhirDocumentReferenceRelatesTo);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code')  then
      result.codeElement := parseEnum(jsn.path+'/code', jsn.node['code'], jsn.vObj['_code'], CODES_TFhirDocumentRelationshipTypeEnum, SYSTEMS_TFhirDocumentRelationshipTypeEnum);
    if jsn.has('target') then
        result.target := ParseReference{TFhirDocumentReference}(jsn.vObj['target']);{q3}
end;

procedure TFHIRJsonComposer.ComposeDocumentReferenceRelatesTo(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceRelatesTo; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'code', elem.CodeElement, CODES_TFhirDocumentRelationshipTypeEnum, false);
  ComposeEnumProps(json, 'code', elem.CodeElement, CODES_TFhirDocumentRelationshipTypeEnum, false);
  ComposeReference{TFhirDocumentReference}(json, 'target', elem.target); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseDocumentReferenceContent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDocumentReferenceContent(jsn)); {2}
end;

function TFHIRJsonParser.ParseDocumentReferenceContent(jsn : TJsonObject) : TFhirDocumentReferenceContent;
begin
  result := TFhirDocumentReferenceContent.create;
  try
    ParseDocumentReferenceContentProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDocumentReferenceContentProperties(jsn : TJsonObject; result : TFhirDocumentReferenceContent);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('attachment') then
        result.attachment := ParseAttachment(jsn.vObj['attachment']);{q3}
    if jsn.has('format') then
      iterateArray(jsn.vArr['format'], result.formatList, parseCoding);
end;

procedure TFHIRJsonComposer.ComposeDocumentReferenceContent(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceContent; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeAttachment(json, 'attachment', elem.attachment); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.formatList.Count > 0) then
  begin
    startArray(json, 'format', elem.formatList, false);
    for i := 0 to elem.formatList.Count - 1 do
      ComposeCoding(json, '', elem.formatList[i]); {z - Coding}
    finishArray(json, elem.formatList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseDocumentReferenceContext(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDocumentReferenceContext(jsn)); {2}
end;

function TFHIRJsonParser.ParseDocumentReferenceContext(jsn : TJsonObject) : TFhirDocumentReferenceContext;
begin
  result := TFhirDocumentReferenceContext.create;
  try
    ParseDocumentReferenceContextProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDocumentReferenceContextProperties(jsn : TJsonObject; result : TFhirDocumentReferenceContext);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('event') then
      iterateArray(jsn.vArr['event'], result.eventList, parseCodeableConcept);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
    if jsn.has('facilityType') then
        result.facilityType := ParseCodeableConcept(jsn.vObj['facilityType']);{q3}
    if jsn.has('practiceSetting') then
        result.practiceSetting := ParseCodeableConcept(jsn.vObj['practiceSetting']);{q3}
    if jsn.has('sourcePatientInfo') then
        result.sourcePatientInfo := ParseReference{TFhirPatient}(jsn.vObj['sourcePatientInfo']);{q3}
    if jsn.has('related') then
      iterateArray(jsn.vArr['related'], result.relatedList, parseDocumentReferenceContextRelated);
end;

procedure TFHIRJsonComposer.ComposeDocumentReferenceContext(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceContext; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.eventList.Count > 0) then
  begin
    startArray(json, 'event', elem.eventList, false);
    for i := 0 to elem.eventList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.eventList[i]); {z - CodeableConcept}
    finishArray(json, elem.eventList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'facilityType', elem.facilityType); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'practiceSetting', elem.practiceSetting); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(json, 'sourcePatientInfo', elem.sourcePatientInfo); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.relatedList.Count > 0) then
  begin
    startArray(json, 'related', elem.relatedList, false);
    for i := 0 to elem.relatedList.Count - 1 do
      ComposeDocumentReferenceContextRelated(json, '', elem.relatedList[i]); {z - }
    finishArray(json, elem.relatedList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseDocumentReferenceContextRelated(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDocumentReferenceContextRelated(jsn)); {2}
end;

function TFHIRJsonParser.ParseDocumentReferenceContextRelated(jsn : TJsonObject) : TFhirDocumentReferenceContextRelated;
begin
  result := TFhirDocumentReferenceContextRelated.create;
  try
    ParseDocumentReferenceContextRelatedProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDocumentReferenceContextRelatedProperties(jsn : TJsonObject; result : TFhirDocumentReferenceContextRelated);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('ref') then
        result.ref := ParseReference{TFhirReference}(jsn.vObj['ref']);{q3}
end;

procedure TFHIRJsonComposer.ComposeDocumentReferenceContextRelated(json : TJSONWriter; name : string; elem : TFhirDocumentReferenceContextRelated; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(json, 'ref', elem.ref); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseDocumentReference(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseDocumentReference(jsn)); {2}
end;

function TFHIRJsonParser.ParseDocumentReference(jsn : TJsonObject) : TFhirDocumentReference;
begin
  result := TFhirDocumentReference.create;
  try
    ParseDocumentReferenceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseDocumentReferenceProperties(jsn : TJsonObject; result : TFhirDocumentReference);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('masterIdentifier') then
        result.masterIdentifier := ParseIdentifier(jsn.vObj['masterIdentifier']);{q3}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q3}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('class') then
        result.class_ := ParseCodeableConcept(jsn.vObj['class']);{q3}
    if jsn.has('author') then
      iterateArray(jsn.vArr['author'], result.authorList, parseReference{Resource});
    if jsn.has('custodian') then
        result.custodian := ParseReference{TFhirOrganization}(jsn.vObj['custodian']);{q3}
    if jsn.has('authenticator') then
        result.authenticator := ParseReference{Resource}(jsn.vObj['authenticator']);{q3}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := ParseDateTime(jsn.node['created'], jsn.vObj['_created']);{q}
    if jsn.has('indexed') or jsn.has('_indexed') then
        result.indexedElement := ParseInstant(jsn.node['indexed'], jsn.vObj['_indexed']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirDocumentReferenceStatusEnum, SYSTEMS_TFhirDocumentReferenceStatusEnum);
    if jsn.has('docStatus') then
        result.docStatus := ParseCodeableConcept(jsn.vObj['docStatus']);{q3}
    if jsn.has('relatesTo') then
      iterateArray(jsn.vArr['relatesTo'], result.relatesToList, parseDocumentReferenceRelatesTo);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('securityLabel') then
      iterateArray(jsn.vArr['securityLabel'], result.securityLabelList, parseCodeableConcept);
    if jsn.has('content') then
      iterateArray(jsn.vArr['content'], result.contentList, parseDocumentReferenceContent);
    if jsn.has('context') then
        result.context := ParseDocumentReferenceContext(jsn.vObj['context']);{q3}
end;

procedure TFHIRJsonComposer.ComposeDocumentReference(json : TJSONWriter; name : string; elem : TFhirDocumentReference; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('masterIdentifier') then
    ComposeIdentifier(json, 'masterIdentifier', elem.masterIdentifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('class_') then
    ComposeCodeableConcept(json, 'class', elem.class_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') and (elem.authorList.Count > 0) then
  begin
    startArray(json, 'author', elem.authorList, false);
    for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.authorList[i]); {z - Reference(Practitioner|Organization|Device|Patient|RelatedPerson)}
    finishArray(json, elem.authorList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('custodian') then
    ComposeReference{TFhirOrganization}(json, 'custodian', elem.custodian); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authenticator') then
    ComposeReference{Resource}(json, 'authenticator', elem.authenticator); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  ComposeInstantValue(json, 'indexed', elem.indexedElement, false);
  ComposeInstantProps(json, 'indexed', elem.indexedElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirDocumentReferenceStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirDocumentReferenceStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('docStatus') then
    ComposeCodeableConcept(json, 'docStatus', elem.docStatus); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('relatesTo') and (elem.relatesToList.Count > 0) then
  begin
    startArray(json, 'relatesTo', elem.relatesToList, false);
    for i := 0 to elem.relatesToList.Count - 1 do
      ComposeDocumentReferenceRelatesTo(json, '', elem.relatesToList[i]); {z - }
    finishArray(json, elem.relatesToList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('securityLabel') and (elem.securityLabelList.Count > 0) then
  begin
    startArray(json, 'securityLabel', elem.securityLabelList, false);
    for i := 0 to elem.securityLabelList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.securityLabelList[i]); {z - CodeableConcept}
    finishArray(json, elem.securityLabelList);
  end;
  if (elem.contentList.Count > 0) then
  begin
    startArray(json, 'content', elem.contentList, false);
    for i := 0 to elem.contentList.Count - 1 do
      ComposeDocumentReferenceContent(json, '', elem.contentList[i]); {z - }
    finishArray(json, elem.contentList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeDocumentReferenceContext(json, 'context', elem.context); {a}
end;

{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ELIGIBILITYREQUEST}
procedure TFHIRJsonParser.ParseEligibilityRequest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEligibilityRequest(jsn)); {2}
end;

function TFHIRJsonParser.ParseEligibilityRequest(jsn : TJsonObject) : TFhirEligibilityRequest;
begin
  result := TFhirEligibilityRequest.create;
  try
    ParseEligibilityRequestProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseEligibilityRequestProperties(jsn : TJsonObject; result : TFhirEligibilityRequest);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('ruleset') then
        result.ruleset := ParseCoding(jsn.vObj['ruleset']);{q3}
    if jsn.has('originalRuleset') then
        result.originalRuleset := ParseCoding(jsn.vObj['originalRuleset']);{q3}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := ParseDateTime(jsn.node['created'], jsn.vObj['_created']);{q}
    if jsn.has('target') then
        result.target := ParseReference{TFhirOrganization}(jsn.vObj['target']);{q3}
    if jsn.has('provider') then
        result.provider := ParseReference{TFhirPractitioner}(jsn.vObj['provider']);{q3}
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q3}
end;

procedure TFHIRJsonComposer.ComposeEligibilityRequest(json : TJSONWriter; name : string; elem : TFhirEligibilityRequest; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ruleset') then
    ComposeCoding(json, 'ruleset', elem.ruleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('originalRuleset') then
    ComposeCoding(json, 'originalRuleset', elem.originalRuleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('target') then
    ComposeReference{TFhirOrganization}(json, 'target', elem.target); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('provider') then
    ComposeReference{TFhirPractitioner}(json, 'provider', elem.provider); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
end;

{$ENDIF FHIR_ELIGIBILITYREQUEST}
{$IFDEF FHIR_ELIGIBILITYRESPONSE}
procedure TFHIRJsonParser.ParseEligibilityResponse(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEligibilityResponse(jsn)); {2}
end;

function TFHIRJsonParser.ParseEligibilityResponse(jsn : TJsonObject) : TFhirEligibilityResponse;
begin
  result := TFhirEligibilityResponse.create;
  try
    ParseEligibilityResponseProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseEligibilityResponseProperties(jsn : TJsonObject; result : TFhirEligibilityResponse);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('request') then
        result.request := ParseReference{TFhirEligibilityRequest}(jsn.vObj['request']);{q3}
    if jsn.has('outcome') or jsn.has('_outcome')  then
      result.outcomeElement := parseEnum(jsn.path+'/outcome', jsn.node['outcome'], jsn.vObj['_outcome'], CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum);
    if jsn.has('disposition') or jsn.has('_disposition') then
        result.dispositionElement := ParseString(jsn.node['disposition'], jsn.vObj['_disposition']);{q}
    if jsn.has('ruleset') then
        result.ruleset := ParseCoding(jsn.vObj['ruleset']);{q3}
    if jsn.has('originalRuleset') then
        result.originalRuleset := ParseCoding(jsn.vObj['originalRuleset']);{q3}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := ParseDateTime(jsn.node['created'], jsn.vObj['_created']);{q}
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q3}
    if jsn.has('requestProvider') then
        result.requestProvider := ParseReference{TFhirPractitioner}(jsn.vObj['requestProvider']);{q3}
    if jsn.has('requestOrganization') then
        result.requestOrganization := ParseReference{TFhirOrganization}(jsn.vObj['requestOrganization']);{q3}
end;

procedure TFHIRJsonComposer.ComposeEligibilityResponse(json : TJSONWriter; name : string; elem : TFhirEligibilityResponse; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('request') then
    ComposeReference{TFhirEligibilityRequest}(json, 'request', elem.request); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcome') then
    ComposeEnumValue(json, 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcome') then
    ComposeEnumProps(json, 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('disposition') then
    ComposeStringValue(json, 'disposition', elem.dispositionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('disposition') then
    ComposeStringProps(json, 'disposition', elem.dispositionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ruleset') then
    ComposeCoding(json, 'ruleset', elem.ruleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('originalRuleset') then
    ComposeCoding(json, 'originalRuleset', elem.originalRuleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestProvider') then
    ComposeReference{TFhirPractitioner}(json, 'requestProvider', elem.requestProvider); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestOrganization') then
    ComposeReference{TFhirOrganization}(json, 'requestOrganization', elem.requestOrganization); {a}
end;

{$ENDIF FHIR_ELIGIBILITYRESPONSE}
{$IFDEF FHIR_ENCOUNTER}
procedure TFHIRJsonParser.ParseEncounterStatusHistory(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEncounterStatusHistory(jsn)); {2}
end;

function TFHIRJsonParser.ParseEncounterStatusHistory(jsn : TJsonObject) : TFhirEncounterStatusHistory;
begin
  result := TFhirEncounterStatusHistory.create;
  try
    ParseEncounterStatusHistoryProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseEncounterStatusHistoryProperties(jsn : TJsonObject; result : TFhirEncounterStatusHistory);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirEncounterStateEnum, SYSTEMS_TFhirEncounterStateEnum);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
end;

procedure TFHIRJsonComposer.ComposeEncounterStatusHistory(json : TJSONWriter; name : string; elem : TFhirEncounterStatusHistory; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirEncounterStateEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirEncounterStateEnum, false);
  ComposePeriod(json, 'period', elem.period); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseEncounterParticipant(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEncounterParticipant(jsn)); {2}
end;

function TFHIRJsonParser.ParseEncounterParticipant(jsn : TJsonObject) : TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant.create;
  try
    ParseEncounterParticipantProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseEncounterParticipantProperties(jsn : TJsonObject; result : TFhirEncounterParticipant);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCodeableConcept);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
    if jsn.has('individual') then
        result.individual := ParseReference{Resource}(jsn.vObj['individual']);{q3}
end;

procedure TFHIRJsonComposer.ComposeEncounterParticipant(json : TJSONWriter; name : string; elem : TFhirEncounterParticipant; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.type_List.Count > 0) then
  begin
    startArray(json, 'type', elem.type_List, false);
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(json, '', elem.type_List[i]); {z - CodeableConcept}
    finishArray(json, elem.type_List);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'individual', elem.individual); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseEncounterHospitalization(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEncounterHospitalization(jsn)); {2}
end;

function TFHIRJsonParser.ParseEncounterHospitalization(jsn : TJsonObject) : TFhirEncounterHospitalization;
begin
  result := TFhirEncounterHospitalization.create;
  try
    ParseEncounterHospitalizationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseEncounterHospitalizationProperties(jsn : TJsonObject; result : TFhirEncounterHospitalization);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('preAdmissionIdentifier') then
        result.preAdmissionIdentifier := ParseIdentifier(jsn.vObj['preAdmissionIdentifier']);{q3}
    if jsn.has('origin') then
        result.origin := ParseReference{TFhirLocation}(jsn.vObj['origin']);{q3}
    if jsn.has('admitSource') then
        result.admitSource := ParseCodeableConcept(jsn.vObj['admitSource']);{q3}
    if jsn.has('admittingDiagnosis') then
      iterateArray(jsn.vArr['admittingDiagnosis'], result.admittingDiagnosisList, parseReference{TFhirCondition});
    if jsn.has('reAdmission') then
        result.reAdmission := ParseCodeableConcept(jsn.vObj['reAdmission']);{q3}
    if jsn.has('dietPreference') then
      iterateArray(jsn.vArr['dietPreference'], result.dietPreferenceList, parseCodeableConcept);
    if jsn.has('specialCourtesy') then
      iterateArray(jsn.vArr['specialCourtesy'], result.specialCourtesyList, parseCodeableConcept);
    if jsn.has('specialArrangement') then
      iterateArray(jsn.vArr['specialArrangement'], result.specialArrangementList, parseCodeableConcept);
    if jsn.has('destination') then
        result.destination := ParseReference{TFhirLocation}(jsn.vObj['destination']);{q3}
    if jsn.has('dischargeDisposition') then
        result.dischargeDisposition := ParseCodeableConcept(jsn.vObj['dischargeDisposition']);{q3}
    if jsn.has('dischargeDiagnosis') then
      iterateArray(jsn.vArr['dischargeDiagnosis'], result.dischargeDiagnosisList, parseReference{TFhirCondition});
end;

procedure TFHIRJsonComposer.ComposeEncounterHospitalization(json : TJSONWriter; name : string; elem : TFhirEncounterHospitalization; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(json, 'preAdmissionIdentifier', elem.preAdmissionIdentifier); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(json, 'origin', elem.origin); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'admitSource', elem.admitSource); {a}
  if (SummaryOption in [soFull, soData]) and (elem.admittingDiagnosisList.Count > 0) then
  begin
    startArray(json, 'admittingDiagnosis', elem.admittingDiagnosisList, false);
    for i := 0 to elem.admittingDiagnosisList.Count - 1 do
      ComposeReference{TFhirCondition}(json, '', elem.admittingDiagnosisList[i]); {z - Reference(Condition)}
    finishArray(json, elem.admittingDiagnosisList);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'reAdmission', elem.reAdmission); {a}
  if (SummaryOption in [soFull, soData]) and (elem.dietPreferenceList.Count > 0) then
  begin
    startArray(json, 'dietPreference', elem.dietPreferenceList, false);
    for i := 0 to elem.dietPreferenceList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.dietPreferenceList[i]); {z - CodeableConcept}
    finishArray(json, elem.dietPreferenceList);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.specialCourtesyList.Count > 0) then
  begin
    startArray(json, 'specialCourtesy', elem.specialCourtesyList, false);
    for i := 0 to elem.specialCourtesyList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.specialCourtesyList[i]); {z - CodeableConcept}
    finishArray(json, elem.specialCourtesyList);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.specialArrangementList.Count > 0) then
  begin
    startArray(json, 'specialArrangement', elem.specialArrangementList, false);
    for i := 0 to elem.specialArrangementList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.specialArrangementList[i]); {z - CodeableConcept}
    finishArray(json, elem.specialArrangementList);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(json, 'destination', elem.destination); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'dischargeDisposition', elem.dischargeDisposition); {a}
  if (SummaryOption in [soFull, soData]) and (elem.dischargeDiagnosisList.Count > 0) then
  begin
    startArray(json, 'dischargeDiagnosis', elem.dischargeDiagnosisList, false);
    for i := 0 to elem.dischargeDiagnosisList.Count - 1 do
      ComposeReference{TFhirCondition}(json, '', elem.dischargeDiagnosisList[i]); {z - Reference(Condition)}
    finishArray(json, elem.dischargeDiagnosisList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseEncounterLocation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEncounterLocation(jsn)); {2}
end;

function TFHIRJsonParser.ParseEncounterLocation(jsn : TJsonObject) : TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation.create;
  try
    ParseEncounterLocationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseEncounterLocationProperties(jsn : TJsonObject; result : TFhirEncounterLocation);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('location') then
        result.location := ParseReference{TFhirLocation}(jsn.vObj['location']);{q3}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirEncounterLocationStatusEnum, SYSTEMS_TFhirEncounterLocationStatusEnum);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
end;

procedure TFHIRJsonComposer.ComposeEncounterLocation(json : TJSONWriter; name : string; elem : TFhirEncounterLocation; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeReference{TFhirLocation}(json, 'location', elem.location); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirEncounterLocationStatusEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirEncounterLocationStatusEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseEncounter(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEncounter(jsn)); {2}
end;

function TFHIRJsonParser.ParseEncounter(jsn : TJsonObject) : TFhirEncounter;
begin
  result := TFhirEncounter.create;
  try
    ParseEncounterProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseEncounterProperties(jsn : TJsonObject; result : TFhirEncounter);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirEncounterStateEnum, SYSTEMS_TFhirEncounterStateEnum);
    if jsn.has('statusHistory') then
      iterateArray(jsn.vArr['statusHistory'], result.statusHistoryList, parseEncounterStatusHistory);
    if jsn.has('class') or jsn.has('_class')  then
      result.class_Element := parseEnum(jsn.path+'/class', jsn.node['class'], jsn.vObj['_class'], CODES_TFhirEncounterClassEnum, SYSTEMS_TFhirEncounterClassEnum);
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCodeableConcept);
    if jsn.has('priority') then
        result.priority := ParseCodeableConcept(jsn.vObj['priority']);{q3}
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
    if jsn.has('episodeOfCare') then
      iterateArray(jsn.vArr['episodeOfCare'], result.episodeOfCareList, parseReference{TFhirEpisodeOfCare});
    if jsn.has('incomingReferral') then
      iterateArray(jsn.vArr['incomingReferral'], result.incomingReferralList, parseReference{TFhirReferralRequest});
    if jsn.has('participant') then
      iterateArray(jsn.vArr['participant'], result.participantList, parseEncounterParticipant);
    if jsn.has('appointment') then
        result.appointment := ParseReference{TFhirAppointment}(jsn.vObj['appointment']);{q3}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
    if jsn.has('length') then
        result.length := ParseQuantity(jsn.vObj['length']);{q3}
    if jsn.has('reason') then
      iterateArray(jsn.vArr['reason'], result.reasonList, parseCodeableConcept);
    if jsn.has('indication') then
      iterateArray(jsn.vArr['indication'], result.indicationList, parseReference{Resource});
    if jsn.has('hospitalization') then
        result.hospitalization := ParseEncounterHospitalization(jsn.vObj['hospitalization']);{q3}
    if jsn.has('location') then
      iterateArray(jsn.vArr['location'], result.locationList, parseEncounterLocation);
    if jsn.has('serviceProvider') then
        result.serviceProvider := ParseReference{TFhirOrganization}(jsn.vObj['serviceProvider']);{q3}
    if jsn.has('partOf') then
        result.partOf := ParseReference{TFhirEncounter}(jsn.vObj['partOf']);{q3}
end;

procedure TFHIRJsonComposer.ComposeEncounter(json : TJSONWriter; name : string; elem : TFhirEncounter; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirEncounterStateEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirEncounterStateEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('statusHistory') and (elem.statusHistoryList.Count > 0) then
  begin
    startArray(json, 'statusHistory', elem.statusHistoryList, false);
    for i := 0 to elem.statusHistoryList.Count - 1 do
      ComposeEncounterStatusHistory(json, '', elem.statusHistoryList[i]); {z - }
    finishArray(json, elem.statusHistoryList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('class_') then
    ComposeEnumValue(json, 'class', elem.Class_Element, CODES_TFhirEncounterClassEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('class_') then
    ComposeEnumProps(json, 'class', elem.Class_Element, CODES_TFhirEncounterClassEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') and (elem.type_List.Count > 0) then
  begin
    startArray(json, 'type', elem.type_List, false);
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(json, '', elem.type_List[i]); {z - CodeableConcept}
    finishArray(json, elem.type_List);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('priority') then
    ComposeCodeableConcept(json, 'priority', elem.priority); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('episodeOfCare') and (elem.episodeOfCareList.Count > 0) then
  begin
    startArray(json, 'episodeOfCare', elem.episodeOfCareList, false);
    for i := 0 to elem.episodeOfCareList.Count - 1 do
      ComposeReference{TFhirEpisodeOfCare}(json, '', elem.episodeOfCareList[i]); {z - Reference(EpisodeOfCare)}
    finishArray(json, elem.episodeOfCareList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('incomingReferral') and (elem.incomingReferralList.Count > 0) then
  begin
    startArray(json, 'incomingReferral', elem.incomingReferralList, false);
    for i := 0 to elem.incomingReferralList.Count - 1 do
      ComposeReference{TFhirReferralRequest}(json, '', elem.incomingReferralList[i]); {z - Reference(ReferralRequest)}
    finishArray(json, elem.incomingReferralList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('participant') and (elem.participantList.Count > 0) then
  begin
    startArray(json, 'participant', elem.participantList, false);
    for i := 0 to elem.participantList.Count - 1 do
      ComposeEncounterParticipant(json, '', elem.participantList[i]); {z - }
    finishArray(json, elem.participantList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('appointment') then
    ComposeReference{TFhirAppointment}(json, 'appointment', elem.appointment); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('period') then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('length') then
    ComposeQuantity(json, 'length', elem.length); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reason') and (elem.reasonList.Count > 0) then
  begin
    startArray(json, 'reason', elem.reasonList, false);
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonList[i]); {z - CodeableConcept}
    finishArray(json, elem.reasonList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('indication') and (elem.indicationList.Count > 0) then
  begin
    startArray(json, 'indication', elem.indicationList, false);
    for i := 0 to elem.indicationList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.indicationList[i]); {z - Reference(Condition|Procedure)}
    finishArray(json, elem.indicationList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('hospitalization') then
    ComposeEncounterHospitalization(json, 'hospitalization', elem.hospitalization); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('location') and (elem.locationList.Count > 0) then
  begin
    startArray(json, 'location', elem.locationList, false);
    for i := 0 to elem.locationList.Count - 1 do
      ComposeEncounterLocation(json, '', elem.locationList[i]); {z - }
    finishArray(json, elem.locationList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('serviceProvider') then
    ComposeReference{TFhirOrganization}(json, 'serviceProvider', elem.serviceProvider); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('partOf') then
    ComposeReference{TFhirEncounter}(json, 'partOf', elem.partOf); {a}
end;

{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENROLLMENTREQUEST}
procedure TFHIRJsonParser.ParseEnrollmentRequest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEnrollmentRequest(jsn)); {2}
end;

function TFHIRJsonParser.ParseEnrollmentRequest(jsn : TJsonObject) : TFhirEnrollmentRequest;
begin
  result := TFhirEnrollmentRequest.create;
  try
    ParseEnrollmentRequestProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseEnrollmentRequestProperties(jsn : TJsonObject; result : TFhirEnrollmentRequest);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('ruleset') then
        result.ruleset := ParseCoding(jsn.vObj['ruleset']);{q3}
    if jsn.has('originalRuleset') then
        result.originalRuleset := ParseCoding(jsn.vObj['originalRuleset']);{q3}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := ParseDateTime(jsn.node['created'], jsn.vObj['_created']);{q}
    if jsn.has('target') then
        result.target := ParseReference{TFhirOrganization}(jsn.vObj['target']);{q3}
    if jsn.has('provider') then
        result.provider := ParseReference{TFhirPractitioner}(jsn.vObj['provider']);{q3}
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q3}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirPatient}(jsn.vObj['subject']);{q3}
    if jsn.has('coverage') then
        result.coverage := ParseReference{TFhirCoverage}(jsn.vObj['coverage']);{q3}
    if jsn.has('relationship') then
        result.relationship := ParseCoding(jsn.vObj['relationship']);{q3}
end;

procedure TFHIRJsonComposer.ComposeEnrollmentRequest(json : TJSONWriter; name : string; elem : TFhirEnrollmentRequest; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ruleset') then
    ComposeCoding(json, 'ruleset', elem.ruleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('originalRuleset') then
    ComposeCoding(json, 'originalRuleset', elem.originalRuleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('target') then
    ComposeReference{TFhirOrganization}(json, 'target', elem.target); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('provider') then
    ComposeReference{TFhirPractitioner}(json, 'provider', elem.provider); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  ComposeReference{TFhirPatient}(json, 'subject', elem.subject); {a}
  ComposeReference{TFhirCoverage}(json, 'coverage', elem.coverage); {a}
  ComposeCoding(json, 'relationship', elem.relationship); {a}
end;

{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
procedure TFHIRJsonParser.ParseEnrollmentResponse(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEnrollmentResponse(jsn)); {2}
end;

function TFHIRJsonParser.ParseEnrollmentResponse(jsn : TJsonObject) : TFhirEnrollmentResponse;
begin
  result := TFhirEnrollmentResponse.create;
  try
    ParseEnrollmentResponseProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseEnrollmentResponseProperties(jsn : TJsonObject; result : TFhirEnrollmentResponse);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('request') then
        result.request := ParseReference{TFhirEnrollmentRequest}(jsn.vObj['request']);{q3}
    if jsn.has('outcome') or jsn.has('_outcome')  then
      result.outcomeElement := parseEnum(jsn.path+'/outcome', jsn.node['outcome'], jsn.vObj['_outcome'], CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum);
    if jsn.has('disposition') or jsn.has('_disposition') then
        result.dispositionElement := ParseString(jsn.node['disposition'], jsn.vObj['_disposition']);{q}
    if jsn.has('ruleset') then
        result.ruleset := ParseCoding(jsn.vObj['ruleset']);{q3}
    if jsn.has('originalRuleset') then
        result.originalRuleset := ParseCoding(jsn.vObj['originalRuleset']);{q3}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := ParseDateTime(jsn.node['created'], jsn.vObj['_created']);{q}
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q3}
    if jsn.has('requestProvider') then
        result.requestProvider := ParseReference{TFhirPractitioner}(jsn.vObj['requestProvider']);{q3}
    if jsn.has('requestOrganization') then
        result.requestOrganization := ParseReference{TFhirOrganization}(jsn.vObj['requestOrganization']);{q3}
end;

procedure TFHIRJsonComposer.ComposeEnrollmentResponse(json : TJSONWriter; name : string; elem : TFhirEnrollmentResponse; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('request') then
    ComposeReference{TFhirEnrollmentRequest}(json, 'request', elem.request); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcome') then
    ComposeEnumValue(json, 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcome') then
    ComposeEnumProps(json, 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('disposition') then
    ComposeStringValue(json, 'disposition', elem.dispositionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('disposition') then
    ComposeStringProps(json, 'disposition', elem.dispositionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ruleset') then
    ComposeCoding(json, 'ruleset', elem.ruleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('originalRuleset') then
    ComposeCoding(json, 'originalRuleset', elem.originalRuleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestProvider') then
    ComposeReference{TFhirPractitioner}(json, 'requestProvider', elem.requestProvider); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestOrganization') then
    ComposeReference{TFhirOrganization}(json, 'requestOrganization', elem.requestOrganization); {a}
end;

{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
procedure TFHIRJsonParser.ParseEpisodeOfCareStatusHistory(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEpisodeOfCareStatusHistory(jsn)); {2}
end;

function TFHIRJsonParser.ParseEpisodeOfCareStatusHistory(jsn : TJsonObject) : TFhirEpisodeOfCareStatusHistory;
begin
  result := TFhirEpisodeOfCareStatusHistory.create;
  try
    ParseEpisodeOfCareStatusHistoryProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseEpisodeOfCareStatusHistoryProperties(jsn : TJsonObject; result : TFhirEpisodeOfCareStatusHistory);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirEpisodeOfCareStatusEnum, SYSTEMS_TFhirEpisodeOfCareStatusEnum);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
end;

procedure TFHIRJsonComposer.ComposeEpisodeOfCareStatusHistory(json : TJSONWriter; name : string; elem : TFhirEpisodeOfCareStatusHistory; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirEpisodeOfCareStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirEpisodeOfCareStatusEnum, false);
  ComposePeriod(json, 'period', elem.period); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseEpisodeOfCareCareTeam(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEpisodeOfCareCareTeam(jsn)); {2}
end;

function TFHIRJsonParser.ParseEpisodeOfCareCareTeam(jsn : TJsonObject) : TFhirEpisodeOfCareCareTeam;
begin
  result := TFhirEpisodeOfCareCareTeam.create;
  try
    ParseEpisodeOfCareCareTeamProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseEpisodeOfCareCareTeamProperties(jsn : TJsonObject; result : TFhirEpisodeOfCareCareTeam);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('role') then
      iterateArray(jsn.vArr['role'], result.roleList, parseCodeableConcept);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
    if jsn.has('member') then
        result.member := ParseReference{Resource}(jsn.vObj['member']);{q3}
end;

procedure TFHIRJsonComposer.ComposeEpisodeOfCareCareTeam(json : TJSONWriter; name : string; elem : TFhirEpisodeOfCareCareTeam; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.roleList.Count > 0) then
  begin
    startArray(json, 'role', elem.roleList, false);
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.roleList[i]); {z - CodeableConcept}
    finishArray(json, elem.roleList);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(json, 'member', elem.member); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseEpisodeOfCare(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseEpisodeOfCare(jsn)); {2}
end;

function TFHIRJsonParser.ParseEpisodeOfCare(jsn : TJsonObject) : TFhirEpisodeOfCare;
begin
  result := TFhirEpisodeOfCare.create;
  try
    ParseEpisodeOfCareProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseEpisodeOfCareProperties(jsn : TJsonObject; result : TFhirEpisodeOfCare);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirEpisodeOfCareStatusEnum, SYSTEMS_TFhirEpisodeOfCareStatusEnum);
    if jsn.has('statusHistory') then
      iterateArray(jsn.vArr['statusHistory'], result.statusHistoryList, parseEpisodeOfCareStatusHistory);
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCodeableConcept);
    if jsn.has('condition') then
      iterateArray(jsn.vArr['condition'], result.conditionList, parseReference{TFhirCondition});
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
    if jsn.has('managingOrganization') then
        result.managingOrganization := ParseReference{TFhirOrganization}(jsn.vObj['managingOrganization']);{q3}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
    if jsn.has('referralRequest') then
      iterateArray(jsn.vArr['referralRequest'], result.referralRequestList, parseReference{TFhirReferralRequest});
    if jsn.has('careManager') then
        result.careManager := ParseReference{TFhirPractitioner}(jsn.vObj['careManager']);{q3}
    if jsn.has('careTeam') then
      iterateArray(jsn.vArr['careTeam'], result.careTeamList, parseEpisodeOfCareCareTeam);
end;

procedure TFHIRJsonComposer.ComposeEpisodeOfCare(json : TJSONWriter; name : string; elem : TFhirEpisodeOfCare; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirEpisodeOfCareStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirEpisodeOfCareStatusEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('statusHistory') and (elem.statusHistoryList.Count > 0) then
  begin
    startArray(json, 'statusHistory', elem.statusHistoryList, false);
    for i := 0 to elem.statusHistoryList.Count - 1 do
      ComposeEpisodeOfCareStatusHistory(json, '', elem.statusHistoryList[i]); {z - }
    finishArray(json, elem.statusHistoryList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') and (elem.type_List.Count > 0) then
  begin
    startArray(json, 'type', elem.type_List, false);
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(json, '', elem.type_List[i]); {z - CodeableConcept}
    finishArray(json, elem.type_List);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('condition') and (elem.conditionList.Count > 0) then
  begin
    startArray(json, 'condition', elem.conditionList, false);
    for i := 0 to elem.conditionList.Count - 1 do
      ComposeReference{TFhirCondition}(json, '', elem.conditionList[i]); {z - Reference(Condition)}
    finishArray(json, elem.conditionList);
  end;
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('managingOrganization') then
    ComposeReference{TFhirOrganization}(json, 'managingOrganization', elem.managingOrganization); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('referralRequest') and (elem.referralRequestList.Count > 0) then
  begin
    startArray(json, 'referralRequest', elem.referralRequestList, false);
    for i := 0 to elem.referralRequestList.Count - 1 do
      ComposeReference{TFhirReferralRequest}(json, '', elem.referralRequestList[i]); {z - Reference(ReferralRequest)}
    finishArray(json, elem.referralRequestList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('careManager') then
    ComposeReference{TFhirPractitioner}(json, 'careManager', elem.careManager); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('careTeam') and (elem.careTeamList.Count > 0) then
  begin
    startArray(json, 'careTeam', elem.careTeamList, false);
    for i := 0 to elem.careTeamList.Count - 1 do
      ComposeEpisodeOfCareCareTeam(json, '', elem.careTeamList[i]); {z - }
    finishArray(json, elem.careTeamList);
  end;
end;

{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
procedure TFHIRJsonParser.ParseExplanationOfBenefit(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseExplanationOfBenefit(jsn)); {2}
end;

function TFHIRJsonParser.ParseExplanationOfBenefit(jsn : TJsonObject) : TFhirExplanationOfBenefit;
begin
  result := TFhirExplanationOfBenefit.create;
  try
    ParseExplanationOfBenefitProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseExplanationOfBenefitProperties(jsn : TJsonObject; result : TFhirExplanationOfBenefit);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('request') then
        result.request := ParseReference{TFhirClaim}(jsn.vObj['request']);{q3}
    if jsn.has('outcome') or jsn.has('_outcome')  then
      result.outcomeElement := parseEnum(jsn.path+'/outcome', jsn.node['outcome'], jsn.vObj['_outcome'], CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum);
    if jsn.has('disposition') or jsn.has('_disposition') then
        result.dispositionElement := ParseString(jsn.node['disposition'], jsn.vObj['_disposition']);{q}
    if jsn.has('ruleset') then
        result.ruleset := ParseCoding(jsn.vObj['ruleset']);{q3}
    if jsn.has('originalRuleset') then
        result.originalRuleset := ParseCoding(jsn.vObj['originalRuleset']);{q3}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := ParseDateTime(jsn.node['created'], jsn.vObj['_created']);{q}
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q3}
    if jsn.has('requestProvider') then
        result.requestProvider := ParseReference{TFhirPractitioner}(jsn.vObj['requestProvider']);{q3}
    if jsn.has('requestOrganization') then
        result.requestOrganization := ParseReference{TFhirOrganization}(jsn.vObj['requestOrganization']);{q3}
end;

procedure TFHIRJsonComposer.ComposeExplanationOfBenefit(json : TJSONWriter; name : string; elem : TFhirExplanationOfBenefit; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('request') then
    ComposeReference{TFhirClaim}(json, 'request', elem.request); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcome') then
    ComposeEnumValue(json, 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcome') then
    ComposeEnumProps(json, 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('disposition') then
    ComposeStringValue(json, 'disposition', elem.dispositionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('disposition') then
    ComposeStringProps(json, 'disposition', elem.dispositionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ruleset') then
    ComposeCoding(json, 'ruleset', elem.ruleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('originalRuleset') then
    ComposeCoding(json, 'originalRuleset', elem.originalRuleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestProvider') then
    ComposeReference{TFhirPractitioner}(json, 'requestProvider', elem.requestProvider); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestOrganization') then
    ComposeReference{TFhirOrganization}(json, 'requestOrganization', elem.requestOrganization); {a}
end;

{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
procedure TFHIRJsonParser.ParseFamilyMemberHistoryCondition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseFamilyMemberHistoryCondition(jsn)); {2}
end;

function TFHIRJsonParser.ParseFamilyMemberHistoryCondition(jsn : TJsonObject) : TFhirFamilyMemberHistoryCondition;
begin
  result := TFhirFamilyMemberHistoryCondition.create;
  try
    ParseFamilyMemberHistoryConditionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseFamilyMemberHistoryConditionProperties(jsn : TJsonObject; result : TFhirFamilyMemberHistoryCondition);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('outcome') then
        result.outcome := ParseCodeableConcept(jsn.vObj['outcome']);{q3}
    if jsn.has('onsetQuantity') {a4} then
      result.onset := ParseQuantity(jsn.vObj['onsetQuantity']);
    if jsn.has('onsetRange') {a4} then
      result.onset := ParseRange(jsn.vObj['onsetRange']);
    if jsn.has('onsetPeriod') {a4} then
      result.onset := ParsePeriod(jsn.vObj['onsetPeriod']);
    if jsn.has('onsetString') or jsn.has('_onsetString') then
      result.onset := ParseString(jsn.node['onsetString'], jsn.vObj['_onsetString']);
    if jsn.has('note') then
        result.note := ParseAnnotation(jsn.vObj['note']);{q3}
end;

procedure TFHIRJsonComposer.ComposeFamilyMemberHistoryCondition(json : TJSONWriter; name : string; elem : TFhirFamilyMemberHistoryCondition; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'outcome', elem.outcome); {a}
  if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirQuantity) then 
    ComposeQuantity(json, 'onsetQuantity', TFhirQuantity(elem.onset)) 
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirRange) then 
    ComposeRange(json, 'onsetRange', TFhirRange(elem.onset)) 
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirPeriod) then 
    ComposePeriod(json, 'onsetPeriod', TFhirPeriod(elem.onset)) 
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirString) then 
  begin
    ComposeStringValue(json, 'onsetString', TFhirString(elem.onset), false);
    ComposeStringProps(json, 'onsetString', TFhirString(elem.onset), false);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeAnnotation(json, 'note', elem.note); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseFamilyMemberHistory(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseFamilyMemberHistory(jsn)); {2}
end;

function TFHIRJsonParser.ParseFamilyMemberHistory(jsn : TJsonObject) : TFhirFamilyMemberHistory;
begin
  result := TFhirFamilyMemberHistory.create;
  try
    ParseFamilyMemberHistoryProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseFamilyMemberHistoryProperties(jsn : TJsonObject; result : TFhirFamilyMemberHistory);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirHistoryStatusEnum, SYSTEMS_TFhirHistoryStatusEnum);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('relationship') then
        result.relationship := ParseCodeableConcept(jsn.vObj['relationship']);{q3}
    if jsn.has('gender') or jsn.has('_gender')  then
      result.genderElement := parseEnum(jsn.path+'/gender', jsn.node['gender'], jsn.vObj['_gender'], CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum);
    if jsn.has('bornPeriod') {a4} then
      result.born := ParsePeriod(jsn.vObj['bornPeriod']);
    if jsn.has('bornDate') or jsn.has('_bornDate') then
      result.born := ParseDate(jsn.node['bornDate'], jsn.vObj['_bornDate']);
    if jsn.has('bornString') or jsn.has('_bornString') then
      result.born := ParseString(jsn.node['bornString'], jsn.vObj['_bornString']);
    if jsn.has('ageQuantity') {a4} then
      result.age := ParseQuantity(jsn.vObj['ageQuantity']);
    if jsn.has('ageRange') {a4} then
      result.age := ParseRange(jsn.vObj['ageRange']);
    if jsn.has('ageString') or jsn.has('_ageString') then
      result.age := ParseString(jsn.node['ageString'], jsn.vObj['_ageString']);
    if jsn.has('deceasedQuantity') {a4} then
      result.deceased := ParseQuantity(jsn.vObj['deceasedQuantity']);
    if jsn.has('deceasedRange') {a4} then
      result.deceased := ParseRange(jsn.vObj['deceasedRange']);
    if jsn.has('deceasedBoolean') or jsn.has('_deceasedBoolean') then
      result.deceased := ParseBoolean(jsn.node['deceasedBoolean'], jsn.vObj['_deceasedBoolean']);
    if jsn.has('deceasedDate') or jsn.has('_deceasedDate') then
      result.deceased := ParseDate(jsn.node['deceasedDate'], jsn.vObj['_deceasedDate']);
    if jsn.has('deceasedString') or jsn.has('_deceasedString') then
      result.deceased := ParseString(jsn.node['deceasedString'], jsn.vObj['_deceasedString']);
    if jsn.has('note') then
        result.note := ParseAnnotation(jsn.vObj['note']);{q3}
    if jsn.has('condition') then
      iterateArray(jsn.vArr['condition'], result.conditionList, parseFamilyMemberHistoryCondition);
end;

procedure TFHIRJsonComposer.ComposeFamilyMemberHistory(json : TJSONWriter; name : string; elem : TFhirFamilyMemberHistory; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirHistoryStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirHistoryStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  ComposeCodeableConcept(json, 'relationship', elem.relationship); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gender') then
    ComposeEnumValue(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gender') then
    ComposeEnumProps(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, false);
  if (SummaryOption in [soFull, soData]) and (elem.born is TFhirPeriod) then 
    ComposePeriod(json, 'bornPeriod', TFhirPeriod(elem.born)) 
  else if (SummaryOption in [soFull, soData]) and (elem.born is TFhirDate) then 
  begin
    ComposeDateValue(json, 'bornDate', TFhirDate(elem.born), false);
    ComposeDateProps(json, 'bornDate', TFhirDate(elem.born), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.born is TFhirString) then 
  begin
    ComposeStringValue(json, 'bornString', TFhirString(elem.born), false);
    ComposeStringProps(json, 'bornString', TFhirString(elem.born), false);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.age is TFhirQuantity) then 
    ComposeQuantity(json, 'ageQuantity', TFhirQuantity(elem.age)) 
  else if (SummaryOption in [soFull, soData]) and (elem.age is TFhirRange) then 
    ComposeRange(json, 'ageRange', TFhirRange(elem.age)) 
  else if (SummaryOption in [soFull, soData]) and (elem.age is TFhirString) then 
  begin
    ComposeStringValue(json, 'ageString', TFhirString(elem.age), false);
    ComposeStringProps(json, 'ageString', TFhirString(elem.age), false);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.deceased is TFhirQuantity) then 
    ComposeQuantity(json, 'deceasedQuantity', TFhirQuantity(elem.deceased)) 
  else if (SummaryOption in [soFull, soData]) and (elem.deceased is TFhirRange) then 
    ComposeRange(json, 'deceasedRange', TFhirRange(elem.deceased)) 
  else if (SummaryOption in [soFull, soData]) and (elem.deceased is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'deceasedBoolean', TFhirBoolean(elem.deceased), false);
    ComposeBooleanProps(json, 'deceasedBoolean', TFhirBoolean(elem.deceased), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.deceased is TFhirDate) then 
  begin
    ComposeDateValue(json, 'deceasedDate', TFhirDate(elem.deceased), false);
    ComposeDateProps(json, 'deceasedDate', TFhirDate(elem.deceased), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.deceased is TFhirString) then 
  begin
    ComposeStringValue(json, 'deceasedString', TFhirString(elem.deceased), false);
    ComposeStringProps(json, 'deceasedString', TFhirString(elem.deceased), false);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    ComposeAnnotation(json, 'note', elem.note); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('condition') and (elem.conditionList.Count > 0) then
  begin
    startArray(json, 'condition', elem.conditionList, false);
    for i := 0 to elem.conditionList.Count - 1 do
      ComposeFamilyMemberHistoryCondition(json, '', elem.conditionList[i]); {z - }
    finishArray(json, elem.conditionList);
  end;
end;

{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
procedure TFHIRJsonParser.ParseFlag(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseFlag(jsn)); {2}
end;

function TFHIRJsonParser.ParseFlag(jsn : TJsonObject) : TFhirFlag;
begin
  result := TFhirFlag.create;
  try
    ParseFlagProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseFlagProperties(jsn : TJsonObject; result : TFhirFlag);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q3}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirFlagStatusEnum, SYSTEMS_TFhirFlagStatusEnum);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q3}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('author') then
        result.author := ParseReference{Resource}(jsn.vObj['author']);{q3}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
end;

procedure TFHIRJsonComposer.ComposeFlag(json : TJSONWriter; name : string; elem : TFhirFlag; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeCodeableConcept(json, 'category', elem.category); {a}
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirFlagStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirFlagStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(json, 'period', elem.period); {a}
  ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{Resource}(json, 'author', elem.author); {a}
  ComposeCodeableConcept(json, 'code', elem.code); {a}
end;

{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
procedure TFHIRJsonParser.ParseGoalOutcome(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseGoalOutcome(jsn)); {2}
end;

function TFHIRJsonParser.ParseGoalOutcome(jsn : TJsonObject) : TFhirGoalOutcome;
begin
  result := TFhirGoalOutcome.create;
  try
    ParseGoalOutcomeProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseGoalOutcomeProperties(jsn : TJsonObject; result : TFhirGoalOutcome);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('resultCodeableConcept') {a4} then
      result.result := ParseCodeableConcept(jsn.vObj['resultCodeableConcept']);
    if jsn.has('resultReference') {a3} then
      result.result := ParseReference(jsn.vObj['resultReference']);
end;

procedure TFHIRJsonComposer.ComposeGoalOutcome(json : TJSONWriter; name : string; elem : TFhirGoalOutcome; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.result is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'resultCodeableConcept', TFhirCodeableConcept(elem.result)) 
  else if (SummaryOption in [soFull, soData]) and (elem.result is TFhirReference) then
    ComposeReference(json, 'resultReference', TFhirReference(elem.result));
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseGoal(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseGoal(jsn)); {2}
end;

function TFHIRJsonParser.ParseGoal(jsn : TJsonObject) : TFhirGoal;
begin
  result := TFhirGoal.create;
  try
    ParseGoalProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseGoalProperties(jsn : TJsonObject; result : TFhirGoal);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q3}
    if jsn.has('startCodeableConcept') {a4} then
      result.start := ParseCodeableConcept(jsn.vObj['startCodeableConcept']);
    if jsn.has('startDate') or jsn.has('_startDate') then
      result.start := ParseDate(jsn.node['startDate'], jsn.vObj['_startDate']);
    if jsn.has('targetQuantity') {a4} then
      result.target := ParseQuantity(jsn.vObj['targetQuantity']);
    if jsn.has('targetDate') or jsn.has('_targetDate') then
      result.target := ParseDate(jsn.node['targetDate'], jsn.vObj['_targetDate']);
    if jsn.has('category') then
      iterateArray(jsn.vArr['category'], result.categoryList, parseCodeableConcept);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirGoalStatusEnum, SYSTEMS_TFhirGoalStatusEnum);
    if jsn.has('statusDate') or jsn.has('_statusDate') then
        result.statusDateElement := ParseDate(jsn.node['statusDate'], jsn.vObj['_statusDate']);{q}
    if jsn.has('statusReason') then
        result.statusReason := ParseCodeableConcept(jsn.vObj['statusReason']);{q3}
    if jsn.has('author') then
        result.author := ParseReference{Resource}(jsn.vObj['author']);{q3}
    if jsn.has('priority') then
        result.priority := ParseCodeableConcept(jsn.vObj['priority']);{q3}
    if jsn.has('addresses') then
      iterateArray(jsn.vArr['addresses'], result.addressesList, parseReference{Resource});
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
    if jsn.has('outcome') then
      iterateArray(jsn.vArr['outcome'], result.outcomeList, parseGoalOutcome);
end;

procedure TFHIRJsonComposer.ComposeGoal(json : TJSONWriter; name : string; elem : TFhirGoal; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.start is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'startCodeableConcept', TFhirCodeableConcept(elem.start)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.start is TFhirDate) then 
  begin
    ComposeDateValue(json, 'startDate', TFhirDate(elem.start), false);
    ComposeDateProps(json, 'startDate', TFhirDate(elem.start), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.target is TFhirQuantity) then 
    ComposeQuantity(json, 'targetQuantity', TFhirQuantity(elem.target)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.target is TFhirDate) then 
  begin
    ComposeDateValue(json, 'targetDate', TFhirDate(elem.target), false);
    ComposeDateProps(json, 'targetDate', TFhirDate(elem.target), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') and (elem.categoryList.Count > 0) then
  begin
    startArray(json, 'category', elem.categoryList, false);
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.categoryList[i]); {z - CodeableConcept}
    finishArray(json, elem.categoryList);
  end;
  ComposeStringValue(json, 'description', elem.descriptionElement, false);
  ComposeStringProps(json, 'description', elem.descriptionElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirGoalStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirGoalStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('statusDate') then
    ComposeDateValue(json, 'statusDate', elem.statusDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('statusDate') then
    ComposeDateProps(json, 'statusDate', elem.statusDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('statusReason') then
    ComposeCodeableConcept(json, 'statusReason', elem.statusReason); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{Resource}(json, 'author', elem.author); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeCodeableConcept(json, 'priority', elem.priority); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('addresses') and (elem.addressesList.Count > 0) then
  begin
    startArray(json, 'addresses', elem.addressesList, false);
    for i := 0 to elem.addressesList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.addressesList[i]); {z - Reference(Condition|Observation|MedicationStatement|NutritionOrder|ProcedureRequest|RiskAssessment)}
    finishArray(json, elem.addressesList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('note') and (elem.noteList.Count > 0) then
  begin
    startArray(json, 'note', elem.noteList, false);
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    finishArray(json, elem.noteList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('outcome') and (elem.outcomeList.Count > 0) then
  begin
    startArray(json, 'outcome', elem.outcomeList, false);
    for i := 0 to elem.outcomeList.Count - 1 do
      ComposeGoalOutcome(json, '', elem.outcomeList[i]); {z - }
    finishArray(json, elem.outcomeList);
  end;
end;

{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GROUP}
procedure TFHIRJsonParser.ParseGroupCharacteristic(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseGroupCharacteristic(jsn)); {2}
end;

function TFHIRJsonParser.ParseGroupCharacteristic(jsn : TJsonObject) : TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic.create;
  try
    ParseGroupCharacteristicProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseGroupCharacteristicProperties(jsn : TJsonObject; result : TFhirGroupCharacteristic);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('valueCodeableConcept') {a4} then
      result.value := ParseCodeableConcept(jsn.vObj['valueCodeableConcept']);
    if jsn.has('valueQuantity') {a4} then
      result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueRange') {a4} then
      result.value := ParseRange(jsn.vObj['valueRange']);
    if jsn.has('valueBoolean') or jsn.has('_valueBoolean') then
      result.value := ParseBoolean(jsn.node['valueBoolean'], jsn.vObj['_valueBoolean']);
    if jsn.has('exclude') or jsn.has('_exclude') then
        result.excludeElement := ParseBoolean(jsn.node['exclude'], jsn.vObj['_exclude']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
end;

procedure TFHIRJsonComposer.ComposeGroupCharacteristic(json : TJSONWriter; name : string; elem : TFhirGroupCharacteristic; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (elem.value is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'valueCodeableConcept', TFhirCodeableConcept(elem.value)) 
  else if (elem.value is TFhirQuantity) then 
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value)) 
  else if (elem.value is TFhirRange) then 
    ComposeRange(json, 'valueRange', TFhirRange(elem.value)) 
  else if (elem.value is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'valueBoolean', TFhirBoolean(elem.value), false);
    ComposeBooleanProps(json, 'valueBoolean', TFhirBoolean(elem.value), false);
  end;
  ComposeBooleanValue(json, 'exclude', elem.excludeElement, false);
  ComposeBooleanProps(json, 'exclude', elem.excludeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseGroupMember(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseGroupMember(jsn)); {2}
end;

function TFHIRJsonParser.ParseGroupMember(jsn : TJsonObject) : TFhirGroupMember;
begin
  result := TFhirGroupMember.create;
  try
    ParseGroupMemberProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseGroupMemberProperties(jsn : TJsonObject; result : TFhirGroupMember);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('entity') then
        result.entity := ParseReference{Resource}(jsn.vObj['entity']);{q3}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
    if jsn.has('inactive') or jsn.has('_inactive') then
        result.inactiveElement := ParseBoolean(jsn.node['inactive'], jsn.vObj['_inactive']);{q}
end;

procedure TFHIRJsonComposer.ComposeGroupMember(json : TJSONWriter; name : string; elem : TFhirGroupMember; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeReference{Resource}(json, 'entity', elem.entity); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.inactive <> false)) then
    ComposeBooleanValue(json, 'inactive', elem.inactiveElement, false);
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.inactive <> false)) then
    ComposeBooleanProps(json, 'inactive', elem.inactiveElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseGroup(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseGroup(jsn)); {2}
end;

function TFHIRJsonParser.ParseGroup(jsn : TJsonObject) : TFhirGroup;
begin
  result := TFhirGroup.create;
  try
    ParseGroupProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseGroupProperties(jsn : TJsonObject; result : TFhirGroup);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirGroupTypeEnum, SYSTEMS_TFhirGroupTypeEnum);
    if jsn.has('actual') or jsn.has('_actual') then
        result.actualElement := ParseBoolean(jsn.node['actual'], jsn.vObj['_actual']);{q}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('quantity') or jsn.has('_quantity') then
        result.quantityElement := ParseUnsignedInt(jsn.node['quantity'], jsn.vObj['_quantity']);{q}
    if jsn.has('characteristic') then
      iterateArray(jsn.vArr['characteristic'], result.characteristicList, parseGroupCharacteristic);
    if jsn.has('member') then
      iterateArray(jsn.vArr['member'], result.memberList, parseGroupMember);
end;

procedure TFHIRJsonComposer.ComposeGroup(json : TJSONWriter; name : string; elem : TFhirGroup; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirGroupTypeEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirGroupTypeEnum, false);
  ComposeBooleanValue(json, 'actual', elem.actualElement, false);
  ComposeBooleanProps(json, 'actual', elem.actualElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('quantity') then
    ComposeUnsignedIntValue(json, 'quantity', elem.quantityElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('quantity') then
    ComposeUnsignedIntProps(json, 'quantity', elem.quantityElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('characteristic') and (elem.characteristicList.Count > 0) then
  begin
    startArray(json, 'characteristic', elem.characteristicList, false);
    for i := 0 to elem.characteristicList.Count - 1 do
      ComposeGroupCharacteristic(json, '', elem.characteristicList[i]); {z - }
    finishArray(json, elem.characteristicList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('member') and (elem.memberList.Count > 0) then
  begin
    startArray(json, 'member', elem.memberList, false);
    for i := 0 to elem.memberList.Count - 1 do
      ComposeGroupMember(json, '', elem.memberList[i]); {z - }
    finishArray(json, elem.memberList);
  end;
end;

{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_HEALTHCARESERVICE}
procedure TFHIRJsonParser.ParseHealthcareServiceServiceType(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseHealthcareServiceServiceType(jsn)); {2}
end;

function TFHIRJsonParser.ParseHealthcareServiceServiceType(jsn : TJsonObject) : TFhirHealthcareServiceServiceType;
begin
  result := TFhirHealthcareServiceServiceType.create;
  try
    ParseHealthcareServiceServiceTypeProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseHealthcareServiceServiceTypeProperties(jsn : TJsonObject; result : TFhirHealthcareServiceServiceType);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('specialty') then
      iterateArray(jsn.vArr['specialty'], result.specialtyList, parseCodeableConcept);
end;

procedure TFHIRJsonComposer.ComposeHealthcareServiceServiceType(json : TJSONWriter; name : string; elem : TFhirHealthcareServiceServiceType; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.specialtyList.Count > 0) then
  begin
    startArray(json, 'specialty', elem.specialtyList, false);
    for i := 0 to elem.specialtyList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.specialtyList[i]); {z - CodeableConcept}
    finishArray(json, elem.specialtyList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseHealthcareServiceAvailableTime(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseHealthcareServiceAvailableTime(jsn)); {2}
end;

function TFHIRJsonParser.ParseHealthcareServiceAvailableTime(jsn : TJsonObject) : TFhirHealthcareServiceAvailableTime;
begin
  result := TFhirHealthcareServiceAvailableTime.create;
  try
    ParseHealthcareServiceAvailableTimeProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseHealthcareServiceAvailableTimeProperties(jsn : TJsonObject; result : TFhirHealthcareServiceAvailableTime);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('daysOfWeek') or jsn.has('_daysOfWeek') then
      iterateEnumArray(jsn.vArr['daysOfWeek'], jsn.vArr['_daysOfWeek'], jsn.path+'/daysOfWeek', result.daysOfWeekList, parseEnum, CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum);
    if jsn.has('allDay') or jsn.has('_allDay') then
        result.allDayElement := ParseBoolean(jsn.node['allDay'], jsn.vObj['_allDay']);{q}
    if jsn.has('availableStartTime') or jsn.has('_availableStartTime') then
        result.availableStartTimeElement := ParseTime(jsn.node['availableStartTime'], jsn.vObj['_availableStartTime']);{q}
    if jsn.has('availableEndTime') or jsn.has('_availableEndTime') then
        result.availableEndTimeElement := ParseTime(jsn.node['availableEndTime'], jsn.vObj['_availableEndTime']);{q}
end;

procedure TFHIRJsonComposer.ComposeHealthcareServiceAvailableTime(json : TJSONWriter; name : string; elem : TFhirHealthcareServiceAvailableTime; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.daysOfWeekList.Count > 0) then
  begin
    val := false;
    ext := false;
    for i := 0 to elem.daysOfWeekList.Count - 1 do
    begin
      val := val or (elem.daysOfWeekList[i].hasPrimitiveValue);
      ext := ext or ((elem.daysOfWeekList[i].id <> '') or (elem.daysOfWeekList[i].hasExtensionList));
    end;
    if val then
    begin
      startArray(json, 'daysOfWeek', elem.daysOfWeekList, true);
      for i := 0 to elem.daysOfWeekList.Count - 1 do
        ComposeEnumValue(json, '', elem.daysOfWeekList[i], CODES_TFhirDaysOfWeekEnum, true);
      finishArray(json, elem.daysOfWeekList);
    end;
    if ext then
    begin
      startArray(json, '_daysOfWeek', elem.daysOfWeekList, false);
      for i := 0 to elem.daysOfWeekList.Count - 1 do
        ComposeEnumProps(json, '', elem.daysOfWeekList[i], CODES_TFhirDaysOfWeekEnum, true);
      finishArray(json, elem.daysOfWeekList);
    end;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'allDay', elem.allDayElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'allDay', elem.allDayElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeTimeValue(json, 'availableStartTime', elem.availableStartTimeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeTimeProps(json, 'availableStartTime', elem.availableStartTimeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeTimeValue(json, 'availableEndTime', elem.availableEndTimeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeTimeProps(json, 'availableEndTime', elem.availableEndTimeElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseHealthcareServiceNotAvailable(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseHealthcareServiceNotAvailable(jsn)); {2}
end;

function TFHIRJsonParser.ParseHealthcareServiceNotAvailable(jsn : TJsonObject) : TFhirHealthcareServiceNotAvailable;
begin
  result := TFhirHealthcareServiceNotAvailable.create;
  try
    ParseHealthcareServiceNotAvailableProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseHealthcareServiceNotAvailableProperties(jsn : TJsonObject; result : TFhirHealthcareServiceNotAvailable);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('during') then
        result.during := ParsePeriod(jsn.vObj['during']);{q3}
end;

procedure TFHIRJsonComposer.ComposeHealthcareServiceNotAvailable(json : TJSONWriter; name : string; elem : TFhirHealthcareServiceNotAvailable; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'description', elem.descriptionElement, false);
  ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(json, 'during', elem.during); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseHealthcareService(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseHealthcareService(jsn)); {2}
end;

function TFHIRJsonParser.ParseHealthcareService(jsn : TJsonObject) : TFhirHealthcareService;
begin
  result := TFhirHealthcareService.create;
  try
    ParseHealthcareServiceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseHealthcareServiceProperties(jsn : TJsonObject; result : TFhirHealthcareService);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('providedBy') then
        result.providedBy := ParseReference{TFhirOrganization}(jsn.vObj['providedBy']);{q3}
    if jsn.has('serviceCategory') then
        result.serviceCategory := ParseCodeableConcept(jsn.vObj['serviceCategory']);{q3}
    if jsn.has('serviceType') then
      iterateArray(jsn.vArr['serviceType'], result.serviceTypeList, parseHealthcareServiceServiceType);
    if jsn.has('location') then
        result.location := ParseReference{TFhirLocation}(jsn.vObj['location']);{q3}
    if jsn.has('serviceName') or jsn.has('_serviceName') then
        result.serviceNameElement := ParseString(jsn.node['serviceName'], jsn.vObj['_serviceName']);{q}
    if jsn.has('comment') or jsn.has('_comment') then
        result.commentElement := ParseString(jsn.node['comment'], jsn.vObj['_comment']);{q}
    if jsn.has('extraDetails') or jsn.has('_extraDetails') then
        result.extraDetailsElement := ParseString(jsn.node['extraDetails'], jsn.vObj['_extraDetails']);{q}
    if jsn.has('photo') then
        result.photo := ParseAttachment(jsn.vObj['photo']);{q3}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('coverageArea') then
      iterateArray(jsn.vArr['coverageArea'], result.coverageAreaList, parseReference{TFhirLocation});
    if jsn.has('serviceProvisionCode') then
      iterateArray(jsn.vArr['serviceProvisionCode'], result.serviceProvisionCodeList, parseCodeableConcept);
    if jsn.has('eligibility') then
        result.eligibility := ParseCodeableConcept(jsn.vObj['eligibility']);{q3}
    if jsn.has('eligibilityNote') or jsn.has('_eligibilityNote') then
        result.eligibilityNoteElement := ParseString(jsn.node['eligibilityNote'], jsn.vObj['_eligibilityNote']);{q}
      if jsn.has('programName') or jsn.has('_programName') then
      iteratePrimitiveArray(jsn.vArr['programName'], jsn.vArr['_programName'], result.programNameList, parseString);
    if jsn.has('characteristic') then
      iterateArray(jsn.vArr['characteristic'], result.characteristicList, parseCodeableConcept);
    if jsn.has('referralMethod') then
      iterateArray(jsn.vArr['referralMethod'], result.referralMethodList, parseCodeableConcept);
    if jsn.has('publicKey') or jsn.has('_publicKey') then
        result.publicKeyElement := ParseString(jsn.node['publicKey'], jsn.vObj['_publicKey']);{q}
    if jsn.has('appointmentRequired') or jsn.has('_appointmentRequired') then
        result.appointmentRequiredElement := ParseBoolean(jsn.node['appointmentRequired'], jsn.vObj['_appointmentRequired']);{q}
    if jsn.has('availableTime') then
      iterateArray(jsn.vArr['availableTime'], result.availableTimeList, parseHealthcareServiceAvailableTime);
    if jsn.has('notAvailable') then
      iterateArray(jsn.vArr['notAvailable'], result.notAvailableList, parseHealthcareServiceNotAvailable);
    if jsn.has('availabilityExceptions') or jsn.has('_availabilityExceptions') then
        result.availabilityExceptionsElement := ParseString(jsn.node['availabilityExceptions'], jsn.vObj['_availabilityExceptions']);{q}
end;

procedure TFHIRJsonComposer.ComposeHealthcareService(json : TJSONWriter; name : string; elem : TFhirHealthcareService; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('providedBy') then
    ComposeReference{TFhirOrganization}(json, 'providedBy', elem.providedBy); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('serviceCategory') then
    ComposeCodeableConcept(json, 'serviceCategory', elem.serviceCategory); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('serviceType') and (elem.serviceTypeList.Count > 0) then
  begin
    startArray(json, 'serviceType', elem.serviceTypeList, false);
    for i := 0 to elem.serviceTypeList.Count - 1 do
      ComposeHealthcareServiceServiceType(json, '', elem.serviceTypeList[i]); {z - }
    finishArray(json, elem.serviceTypeList);
  end;
  ComposeReference{TFhirLocation}(json, 'location', elem.location); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('serviceName') then
    ComposeStringValue(json, 'serviceName', elem.serviceNameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('serviceName') then
    ComposeStringProps(json, 'serviceName', elem.serviceNameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('comment') then
    ComposeStringValue(json, 'comment', elem.commentElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('comment') then
    ComposeStringProps(json, 'comment', elem.commentElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('extraDetails') then
    ComposeStringValue(json, 'extraDetails', elem.extraDetailsElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('extraDetails') then
    ComposeStringProps(json, 'extraDetails', elem.extraDetailsElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('photo') then
    ComposeAttachment(json, 'photo', elem.photo); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('telecom') and (elem.telecomList.Count > 0) then
  begin
    startArray(json, 'telecom', elem.telecomList, false);
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    finishArray(json, elem.telecomList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('coverageArea') and (elem.coverageAreaList.Count > 0) then
  begin
    startArray(json, 'coverageArea', elem.coverageAreaList, false);
    for i := 0 to elem.coverageAreaList.Count - 1 do
      ComposeReference{TFhirLocation}(json, '', elem.coverageAreaList[i]); {z - Reference(Location)}
    finishArray(json, elem.coverageAreaList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('serviceProvisionCode') and (elem.serviceProvisionCodeList.Count > 0) then
  begin
    startArray(json, 'serviceProvisionCode', elem.serviceProvisionCodeList, false);
    for i := 0 to elem.serviceProvisionCodeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.serviceProvisionCodeList[i]); {z - CodeableConcept}
    finishArray(json, elem.serviceProvisionCodeList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('eligibility') then
    ComposeCodeableConcept(json, 'eligibility', elem.eligibility); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('eligibilityNote') then
    ComposeStringValue(json, 'eligibilityNote', elem.eligibilityNoteElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('eligibilityNote') then
    ComposeStringProps(json, 'eligibilityNote', elem.eligibilityNoteElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('programName') and (elem.programNameList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.programNameList.Count - 1 do
    begin
      ext := ext or ((elem.programNameList[i].id <> '') or (elem.programNameList[i].hasExtensionList) {no-comments or (elem.programNameList[i].hasComments)});
      val := val or (elem.programNameList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      startArray(json, 'programName', elem.programNameList, true);
      for i := 0 to elem.programNameList.Count - 1 do
        ComposeStringValue(json, '',elem.programNameList[i], true);
      finishArray(json, elem.programNameList);
    end;
    if ext then
    begin
      startArray(json, '_programName', elem.programNameList, false);
      for i := 0 to elem.programNameList.Count - 1 do
        ComposeStringProps(json, '',elem.programNameList[i], true);
      finishArray(json, elem.programNameList);
    end;
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('characteristic') and (elem.characteristicList.Count > 0) then
  begin
    startArray(json, 'characteristic', elem.characteristicList, false);
    for i := 0 to elem.characteristicList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.characteristicList[i]); {z - CodeableConcept}
    finishArray(json, elem.characteristicList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('referralMethod') and (elem.referralMethodList.Count > 0) then
  begin
    startArray(json, 'referralMethod', elem.referralMethodList, false);
    for i := 0 to elem.referralMethodList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.referralMethodList[i]); {z - CodeableConcept}
    finishArray(json, elem.referralMethodList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('publicKey') then
    ComposeStringValue(json, 'publicKey', elem.publicKeyElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('publicKey') then
    ComposeStringProps(json, 'publicKey', elem.publicKeyElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('appointmentRequired') then
    ComposeBooleanValue(json, 'appointmentRequired', elem.appointmentRequiredElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('appointmentRequired') then
    ComposeBooleanProps(json, 'appointmentRequired', elem.appointmentRequiredElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('availableTime') and (elem.availableTimeList.Count > 0) then
  begin
    startArray(json, 'availableTime', elem.availableTimeList, false);
    for i := 0 to elem.availableTimeList.Count - 1 do
      ComposeHealthcareServiceAvailableTime(json, '', elem.availableTimeList[i]); {z - }
    finishArray(json, elem.availableTimeList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('notAvailable') and (elem.notAvailableList.Count > 0) then
  begin
    startArray(json, 'notAvailable', elem.notAvailableList, false);
    for i := 0 to elem.notAvailableList.Count - 1 do
      ComposeHealthcareServiceNotAvailable(json, '', elem.notAvailableList[i]); {z - }
    finishArray(json, elem.notAvailableList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('availabilityExceptions') then
    ComposeStringValue(json, 'availabilityExceptions', elem.availabilityExceptionsElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('availabilityExceptions') then
    ComposeStringProps(json, 'availabilityExceptions', elem.availabilityExceptionsElement, false);
end;

{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGOBJECTSELECTION}
procedure TFHIRJsonParser.ParseImagingObjectSelectionStudy(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImagingObjectSelectionStudy(jsn)); {2}
end;

function TFHIRJsonParser.ParseImagingObjectSelectionStudy(jsn : TJsonObject) : TFhirImagingObjectSelectionStudy;
begin
  result := TFhirImagingObjectSelectionStudy.create;
  try
    ParseImagingObjectSelectionStudyProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImagingObjectSelectionStudyProperties(jsn : TJsonObject; result : TFhirImagingObjectSelectionStudy);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('uid') or jsn.has('_uid') then
        result.uidElement := ParseOid(jsn.node['uid'], jsn.vObj['_uid']);{q}
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('imagingStudy') then
        result.imagingStudy := ParseReference{TFhirImagingStudy}(jsn.vObj['imagingStudy']);{q3}
    if jsn.has('series') then
      iterateArray(jsn.vArr['series'], result.seriesList, parseImagingObjectSelectionStudySeries);
end;

procedure TFHIRJsonComposer.ComposeImagingObjectSelectionStudy(json : TJSONWriter; name : string; elem : TFhirImagingObjectSelectionStudy; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeOidValue(json, 'uid', elem.uidElement, false);
  ComposeOidProps(json, 'uid', elem.uidElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirImagingStudy}(json, 'imagingStudy', elem.imagingStudy); {a}
  if (elem.seriesList.Count > 0) then
  begin
    startArray(json, 'series', elem.seriesList, false);
    for i := 0 to elem.seriesList.Count - 1 do
      ComposeImagingObjectSelectionStudySeries(json, '', elem.seriesList[i]); {z - }
    finishArray(json, elem.seriesList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseImagingObjectSelectionStudySeries(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImagingObjectSelectionStudySeries(jsn)); {2}
end;

function TFHIRJsonParser.ParseImagingObjectSelectionStudySeries(jsn : TJsonObject) : TFhirImagingObjectSelectionStudySeries;
begin
  result := TFhirImagingObjectSelectionStudySeries.create;
  try
    ParseImagingObjectSelectionStudySeriesProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImagingObjectSelectionStudySeriesProperties(jsn : TJsonObject; result : TFhirImagingObjectSelectionStudySeries);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('uid') or jsn.has('_uid') then
        result.uidElement := ParseOid(jsn.node['uid'], jsn.vObj['_uid']);{q}
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('instance') then
      iterateArray(jsn.vArr['instance'], result.instanceList, parseImagingObjectSelectionStudySeriesInstance);
end;

procedure TFHIRJsonComposer.ComposeImagingObjectSelectionStudySeries(json : TJSONWriter; name : string; elem : TFhirImagingObjectSelectionStudySeries; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeOidValue(json, 'uid', elem.uidElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeOidProps(json, 'uid', elem.uidElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (elem.instanceList.Count > 0) then
  begin
    startArray(json, 'instance', elem.instanceList, false);
    for i := 0 to elem.instanceList.Count - 1 do
      ComposeImagingObjectSelectionStudySeriesInstance(json, '', elem.instanceList[i]); {z - }
    finishArray(json, elem.instanceList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseImagingObjectSelectionStudySeriesInstance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImagingObjectSelectionStudySeriesInstance(jsn)); {2}
end;

function TFHIRJsonParser.ParseImagingObjectSelectionStudySeriesInstance(jsn : TJsonObject) : TFhirImagingObjectSelectionStudySeriesInstance;
begin
  result := TFhirImagingObjectSelectionStudySeriesInstance.create;
  try
    ParseImagingObjectSelectionStudySeriesInstanceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImagingObjectSelectionStudySeriesInstanceProperties(jsn : TJsonObject; result : TFhirImagingObjectSelectionStudySeriesInstance);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sopClass') or jsn.has('_sopClass') then
        result.sopClassElement := ParseOid(jsn.node['sopClass'], jsn.vObj['_sopClass']);{q}
    if jsn.has('uid') or jsn.has('_uid') then
        result.uidElement := ParseOid(jsn.node['uid'], jsn.vObj['_uid']);{q}
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('frames') then
      iterateArray(jsn.vArr['frames'], result.framesList, parseImagingObjectSelectionStudySeriesInstanceFrames);
end;

procedure TFHIRJsonComposer.ComposeImagingObjectSelectionStudySeriesInstance(json : TJSONWriter; name : string; elem : TFhirImagingObjectSelectionStudySeriesInstance; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeOidValue(json, 'sopClass', elem.sopClassElement, false);
  ComposeOidProps(json, 'sopClass', elem.sopClassElement, false);
  ComposeOidValue(json, 'uid', elem.uidElement, false);
  ComposeOidProps(json, 'uid', elem.uidElement, false);
  ComposeUriValue(json, 'url', elem.urlElement, false);
  ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.framesList.Count > 0) then
  begin
    startArray(json, 'frames', elem.framesList, false);
    for i := 0 to elem.framesList.Count - 1 do
      ComposeImagingObjectSelectionStudySeriesInstanceFrames(json, '', elem.framesList[i]); {z - }
    finishArray(json, elem.framesList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseImagingObjectSelectionStudySeriesInstanceFrames(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImagingObjectSelectionStudySeriesInstanceFrames(jsn)); {2}
end;

function TFHIRJsonParser.ParseImagingObjectSelectionStudySeriesInstanceFrames(jsn : TJsonObject) : TFhirImagingObjectSelectionStudySeriesInstanceFrames;
begin
  result := TFhirImagingObjectSelectionStudySeriesInstanceFrames.create;
  try
    ParseImagingObjectSelectionStudySeriesInstanceFramesProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImagingObjectSelectionStudySeriesInstanceFramesProperties(jsn : TJsonObject; result : TFhirImagingObjectSelectionStudySeriesInstanceFrames);
begin
    ParseBackboneElementProperties(jsn, result);
      if jsn.has('frameNumbers') or jsn.has('_frameNumbers') then
      iteratePrimitiveArray(jsn.vArr['frameNumbers'], jsn.vArr['_frameNumbers'], result.frameNumbersList, parseUnsignedInt);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn.node['url'], jsn.vObj['_url']);{q}
end;

procedure TFHIRJsonComposer.ComposeImagingObjectSelectionStudySeriesInstanceFrames(json : TJSONWriter; name : string; elem : TFhirImagingObjectSelectionStudySeriesInstanceFrames; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (elem.frameNumbersList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.frameNumbersList.Count - 1 do
    begin
      ext := ext or ((elem.frameNumbersList[i].id <> '') or (elem.frameNumbersList[i].hasExtensionList) {no-comments or (elem.frameNumbersList[i].hasComments)});
      val := val or (elem.frameNumbersList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      startArray(json, 'frameNumbers', elem.frameNumbersList, true);
      for i := 0 to elem.frameNumbersList.Count - 1 do
        ComposeUnsignedIntValue(json, '',elem.frameNumbersList[i], true);
      finishArray(json, elem.frameNumbersList);
    end;
    if ext then
    begin
      startArray(json, '_frameNumbers', elem.frameNumbersList, false);
      for i := 0 to elem.frameNumbersList.Count - 1 do
        ComposeUnsignedIntProps(json, '',elem.frameNumbersList[i], true);
      finishArray(json, elem.frameNumbersList);
    end;
  end;
  ComposeUriValue(json, 'url', elem.urlElement, false);
  ComposeUriProps(json, 'url', elem.urlElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseImagingObjectSelection(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImagingObjectSelection(jsn)); {2}
end;

function TFHIRJsonParser.ParseImagingObjectSelection(jsn : TJsonObject) : TFhirImagingObjectSelection;
begin
  result := TFhirImagingObjectSelection.create;
  try
    ParseImagingObjectSelectionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImagingObjectSelectionProperties(jsn : TJsonObject; result : TFhirImagingObjectSelection);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('uid') or jsn.has('_uid') then
        result.uidElement := ParseOid(jsn.node['uid'], jsn.vObj['_uid']);{q}
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
    if jsn.has('title') then
        result.title := ParseCodeableConcept(jsn.vObj['title']);{q3}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('author') then
        result.author := ParseReference{Resource}(jsn.vObj['author']);{q3}
    if jsn.has('authoringTime') or jsn.has('_authoringTime') then
        result.authoringTimeElement := ParseDateTime(jsn.node['authoringTime'], jsn.vObj['_authoringTime']);{q}
    if jsn.has('study') then
      iterateArray(jsn.vArr['study'], result.studyList, parseImagingObjectSelectionStudy);
end;

procedure TFHIRJsonComposer.ComposeImagingObjectSelection(json : TJSONWriter; name : string; elem : TFhirImagingObjectSelection; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeOidValue(json, 'uid', elem.uidElement, false);
  ComposeOidProps(json, 'uid', elem.uidElement, false);
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  ComposeCodeableConcept(json, 'title', elem.title); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{Resource}(json, 'author', elem.author); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authoringTime') then
    ComposeDateTimeValue(json, 'authoringTime', elem.authoringTimeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authoringTime') then
    ComposeDateTimeProps(json, 'authoringTime', elem.authoringTimeElement, false);
  if (elem.studyList.Count > 0) then
  begin
    startArray(json, 'study', elem.studyList, false);
    for i := 0 to elem.studyList.Count - 1 do
      ComposeImagingObjectSelectionStudy(json, '', elem.studyList[i]); {z - }
    finishArray(json, elem.studyList);
  end;
end;

{$ENDIF FHIR_IMAGINGOBJECTSELECTION}
{$IFDEF FHIR_IMAGINGSTUDY}
procedure TFHIRJsonParser.ParseImagingStudySeries(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImagingStudySeries(jsn)); {2}
end;

function TFHIRJsonParser.ParseImagingStudySeries(jsn : TJsonObject) : TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries.create;
  try
    ParseImagingStudySeriesProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImagingStudySeriesProperties(jsn : TJsonObject; result : TFhirImagingStudySeries);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('number') or jsn.has('_number') then
        result.numberElement := ParseUnsignedInt(jsn.node['number'], jsn.vObj['_number']);{q}
    if jsn.has('modality') then
        result.modality := ParseCoding(jsn.vObj['modality']);{q3}
    if jsn.has('uid') or jsn.has('_uid') then
        result.uidElement := ParseOid(jsn.node['uid'], jsn.vObj['_uid']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('numberOfInstances') or jsn.has('_numberOfInstances') then
        result.numberOfInstancesElement := ParseUnsignedInt(jsn.node['numberOfInstances'], jsn.vObj['_numberOfInstances']);{q}
    if jsn.has('availability') or jsn.has('_availability')  then
      result.availabilityElement := parseEnum(jsn.path+'/availability', jsn.node['availability'], jsn.vObj['_availability'], CODES_TFhirInstanceAvailabilityEnum, SYSTEMS_TFhirInstanceAvailabilityEnum);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('bodySite') then
        result.bodySite := ParseCoding(jsn.vObj['bodySite']);{q3}
    if jsn.has('laterality') then
        result.laterality := ParseCoding(jsn.vObj['laterality']);{q3}
    if jsn.has('started') or jsn.has('_started') then
        result.startedElement := ParseDateTime(jsn.node['started'], jsn.vObj['_started']);{q}
    if jsn.has('instance') then
      iterateArray(jsn.vArr['instance'], result.instanceList, parseImagingStudySeriesInstance);
end;

procedure TFHIRJsonComposer.ComposeImagingStudySeries(json : TJSONWriter; name : string; elem : TFhirImagingStudySeries; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedIntValue(json, 'number', elem.numberElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedIntProps(json, 'number', elem.numberElement, false);
  ComposeCoding(json, 'modality', elem.modality); {a}
  ComposeOidValue(json, 'uid', elem.uidElement, false);
  ComposeOidProps(json, 'uid', elem.uidElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  ComposeUnsignedIntValue(json, 'numberOfInstances', elem.numberOfInstancesElement, false);
  ComposeUnsignedIntProps(json, 'numberOfInstances', elem.numberOfInstancesElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumValue(json, 'availability', elem.AvailabilityElement, CODES_TFhirInstanceAvailabilityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumProps(json, 'availability', elem.AvailabilityElement, CODES_TFhirInstanceAvailabilityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'bodySite', elem.bodySite); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'laterality', elem.laterality); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'started', elem.startedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'started', elem.startedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.instanceList.Count > 0) then
  begin
    startArray(json, 'instance', elem.instanceList, false);
    for i := 0 to elem.instanceList.Count - 1 do
      ComposeImagingStudySeriesInstance(json, '', elem.instanceList[i]); {z - }
    finishArray(json, elem.instanceList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseImagingStudySeriesInstance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImagingStudySeriesInstance(jsn)); {2}
end;

function TFHIRJsonParser.ParseImagingStudySeriesInstance(jsn : TJsonObject) : TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance.create;
  try
    ParseImagingStudySeriesInstanceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImagingStudySeriesInstanceProperties(jsn : TJsonObject; result : TFhirImagingStudySeriesInstance);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('number') or jsn.has('_number') then
        result.numberElement := ParseUnsignedInt(jsn.node['number'], jsn.vObj['_number']);{q}
    if jsn.has('uid') or jsn.has('_uid') then
        result.uidElement := ParseOid(jsn.node['uid'], jsn.vObj['_uid']);{q}
    if jsn.has('sopClass') or jsn.has('_sopClass') then
        result.sopClassElement := ParseOid(jsn.node['sopClass'], jsn.vObj['_sopClass']);{q}
    if jsn.has('type') or jsn.has('_type') then
        result.type_Element := ParseString(jsn.node['type'], jsn.vObj['_type']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := ParseString(jsn.node['title'], jsn.vObj['_title']);{q}
    if jsn.has('content') then
      iterateArray(jsn.vArr['content'], result.contentList, parseAttachment);
end;

procedure TFHIRJsonComposer.ComposeImagingStudySeriesInstance(json : TJSONWriter; name : string; elem : TFhirImagingStudySeriesInstance; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedIntValue(json, 'number', elem.numberElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedIntProps(json, 'number', elem.numberElement, false);
  ComposeOidValue(json, 'uid', elem.uidElement, false);
  ComposeOidProps(json, 'uid', elem.uidElement, false);
  ComposeOidValue(json, 'sopClass', elem.sopClassElement, false);
  ComposeOidProps(json, 'sopClass', elem.sopClassElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'type', elem.type_Element, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'type', elem.type_Element, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.contentList.Count > 0) then
  begin
    startArray(json, 'content', elem.contentList, false);
    for i := 0 to elem.contentList.Count - 1 do
      ComposeAttachment(json, '', elem.contentList[i]); {z - Attachment}
    finishArray(json, elem.contentList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseImagingStudy(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImagingStudy(jsn)); {2}
end;

function TFHIRJsonParser.ParseImagingStudy(jsn : TJsonObject) : TFhirImagingStudy;
begin
  result := TFhirImagingStudy.create;
  try
    ParseImagingStudyProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImagingStudyProperties(jsn : TJsonObject; result : TFhirImagingStudy);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('started') or jsn.has('_started') then
        result.startedElement := ParseDateTime(jsn.node['started'], jsn.vObj['_started']);{q}
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
    if jsn.has('uid') or jsn.has('_uid') then
        result.uidElement := ParseOid(jsn.node['uid'], jsn.vObj['_uid']);{q}
    if jsn.has('accession') then
        result.accession := ParseIdentifier(jsn.vObj['accession']);{q3}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('order') then
      iterateArray(jsn.vArr['order'], result.orderList, parseReference{TFhirDiagnosticOrder});
    if jsn.has('modalityList') then
      iterateArray(jsn.vArr['modalityList'], result.modalityListList, parseCoding);
    if jsn.has('referrer') then
        result.referrer := ParseReference{TFhirPractitioner}(jsn.vObj['referrer']);{q3}
    if jsn.has('availability') or jsn.has('_availability')  then
      result.availabilityElement := parseEnum(jsn.path+'/availability', jsn.node['availability'], jsn.vObj['_availability'], CODES_TFhirInstanceAvailabilityEnum, SYSTEMS_TFhirInstanceAvailabilityEnum);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('numberOfSeries') or jsn.has('_numberOfSeries') then
        result.numberOfSeriesElement := ParseUnsignedInt(jsn.node['numberOfSeries'], jsn.vObj['_numberOfSeries']);{q}
    if jsn.has('numberOfInstances') or jsn.has('_numberOfInstances') then
        result.numberOfInstancesElement := ParseUnsignedInt(jsn.node['numberOfInstances'], jsn.vObj['_numberOfInstances']);{q}
    if jsn.has('procedure') then
      iterateArray(jsn.vArr['procedure'], result.procedure_List, parseReference{TFhirProcedure});
    if jsn.has('interpreter') then
        result.interpreter := ParseReference{TFhirPractitioner}(jsn.vObj['interpreter']);{q3}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('series') then
      iterateArray(jsn.vArr['series'], result.seriesList, parseImagingStudySeries);
end;

procedure TFHIRJsonComposer.ComposeImagingStudy(json : TJSONWriter; name : string; elem : TFhirImagingStudy; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('started') then
    ComposeDateTimeValue(json, 'started', elem.startedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('started') then
    ComposeDateTimeProps(json, 'started', elem.startedElement, false);
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  ComposeOidValue(json, 'uid', elem.uidElement, false);
  ComposeOidProps(json, 'uid', elem.uidElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('accession') then
    ComposeIdentifier(json, 'accession', elem.accession); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('order') and (elem.orderList.Count > 0) then
  begin
    startArray(json, 'order', elem.orderList, false);
    for i := 0 to elem.orderList.Count - 1 do
      ComposeReference{TFhirDiagnosticOrder}(json, '', elem.orderList[i]); {z - Reference(DiagnosticOrder)}
    finishArray(json, elem.orderList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('modalityList') and (elem.modalityListList.Count > 0) then
  begin
    startArray(json, 'modalityList', elem.modalityListList, false);
    for i := 0 to elem.modalityListList.Count - 1 do
      ComposeCoding(json, '', elem.modalityListList[i]); {z - Coding}
    finishArray(json, elem.modalityListList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('referrer') then
    ComposeReference{TFhirPractitioner}(json, 'referrer', elem.referrer); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('availability') then
    ComposeEnumValue(json, 'availability', elem.AvailabilityElement, CODES_TFhirInstanceAvailabilityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('availability') then
    ComposeEnumProps(json, 'availability', elem.AvailabilityElement, CODES_TFhirInstanceAvailabilityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  ComposeUnsignedIntValue(json, 'numberOfSeries', elem.numberOfSeriesElement, false);
  ComposeUnsignedIntProps(json, 'numberOfSeries', elem.numberOfSeriesElement, false);
  ComposeUnsignedIntValue(json, 'numberOfInstances', elem.numberOfInstancesElement, false);
  ComposeUnsignedIntProps(json, 'numberOfInstances', elem.numberOfInstancesElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('procedure_') and (elem.procedure_List.Count > 0) then
  begin
    startArray(json, 'procedure', elem.procedure_List, false);
    for i := 0 to elem.procedure_List.Count - 1 do
      ComposeReference{TFhirProcedure}(json, '', elem.procedure_List[i]); {z - Reference(Procedure)}
    finishArray(json, elem.procedure_List);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('interpreter') then
    ComposeReference{TFhirPractitioner}(json, 'interpreter', elem.interpreter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('series') and (elem.seriesList.Count > 0) then
  begin
    startArray(json, 'series', elem.seriesList, false);
    for i := 0 to elem.seriesList.Count - 1 do
      ComposeImagingStudySeries(json, '', elem.seriesList[i]); {z - }
    finishArray(json, elem.seriesList);
  end;
end;

{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
procedure TFHIRJsonParser.ParseImmunizationExplanation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunizationExplanation(jsn)); {2}
end;

function TFHIRJsonParser.ParseImmunizationExplanation(jsn : TJsonObject) : TFhirImmunizationExplanation;
begin
  result := TFhirImmunizationExplanation.create;
  try
    ParseImmunizationExplanationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImmunizationExplanationProperties(jsn : TJsonObject; result : TFhirImmunizationExplanation);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('reason') then
      iterateArray(jsn.vArr['reason'], result.reasonList, parseCodeableConcept);
    if jsn.has('reasonNotGiven') then
      iterateArray(jsn.vArr['reasonNotGiven'], result.reasonNotGivenList, parseCodeableConcept);
end;

procedure TFHIRJsonComposer.ComposeImmunizationExplanation(json : TJSONWriter; name : string; elem : TFhirImmunizationExplanation; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.reasonList.Count > 0) then
  begin
    startArray(json, 'reason', elem.reasonList, false);
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonList[i]); {z - CodeableConcept}
    finishArray(json, elem.reasonList);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.reasonNotGivenList.Count > 0) then
  begin
    startArray(json, 'reasonNotGiven', elem.reasonNotGivenList, false);
    for i := 0 to elem.reasonNotGivenList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonNotGivenList[i]); {z - CodeableConcept}
    finishArray(json, elem.reasonNotGivenList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseImmunizationReaction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunizationReaction(jsn)); {2}
end;

function TFHIRJsonParser.ParseImmunizationReaction(jsn : TJsonObject) : TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction.create;
  try
    ParseImmunizationReactionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImmunizationReactionProperties(jsn : TJsonObject; result : TFhirImmunizationReaction);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('detail') then
        result.detail := ParseReference{TFhirObservation}(jsn.vObj['detail']);{q3}
    if jsn.has('reported') or jsn.has('_reported') then
        result.reportedElement := ParseBoolean(jsn.node['reported'], jsn.vObj['_reported']);{q}
end;

procedure TFHIRJsonComposer.ComposeImmunizationReaction(json : TJSONWriter; name : string; elem : TFhirImmunizationReaction; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirObservation}(json, 'detail', elem.detail); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'reported', elem.reportedElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'reported', elem.reportedElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseImmunizationVaccinationProtocol(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunizationVaccinationProtocol(jsn)); {2}
end;

function TFHIRJsonParser.ParseImmunizationVaccinationProtocol(jsn : TJsonObject) : TFhirImmunizationVaccinationProtocol;
begin
  result := TFhirImmunizationVaccinationProtocol.create;
  try
    ParseImmunizationVaccinationProtocolProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImmunizationVaccinationProtocolProperties(jsn : TJsonObject; result : TFhirImmunizationVaccinationProtocol);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('doseSequence') or jsn.has('_doseSequence') then
        result.doseSequenceElement := ParsePositiveInt(jsn.node['doseSequence'], jsn.vObj['_doseSequence']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('authority') then
        result.authority := ParseReference{TFhirOrganization}(jsn.vObj['authority']);{q3}
    if jsn.has('series') or jsn.has('_series') then
        result.seriesElement := ParseString(jsn.node['series'], jsn.vObj['_series']);{q}
    if jsn.has('seriesDoses') or jsn.has('_seriesDoses') then
        result.seriesDosesElement := ParsePositiveInt(jsn.node['seriesDoses'], jsn.vObj['_seriesDoses']);{q}
    if jsn.has('targetDisease') then
      iterateArray(jsn.vArr['targetDisease'], result.targetDiseaseList, parseCodeableConcept);
    if jsn.has('doseStatus') then
        result.doseStatus := ParseCodeableConcept(jsn.vObj['doseStatus']);{q3}
    if jsn.has('doseStatusReason') then
        result.doseStatusReason := ParseCodeableConcept(jsn.vObj['doseStatusReason']);{q3}
end;

procedure TFHIRJsonComposer.ComposeImmunizationVaccinationProtocol(json : TJSONWriter; name : string; elem : TFhirImmunizationVaccinationProtocol; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposePositiveIntValue(json, 'doseSequence', elem.doseSequenceElement, false);
  ComposePositiveIntProps(json, 'doseSequence', elem.doseSequenceElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(json, 'authority', elem.authority); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'series', elem.seriesElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'series', elem.seriesElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveIntValue(json, 'seriesDoses', elem.seriesDosesElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveIntProps(json, 'seriesDoses', elem.seriesDosesElement, false);
  if (elem.targetDiseaseList.Count > 0) then
  begin
    startArray(json, 'targetDisease', elem.targetDiseaseList, false);
    for i := 0 to elem.targetDiseaseList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.targetDiseaseList[i]); {z - CodeableConcept}
    finishArray(json, elem.targetDiseaseList);
  end;
  ComposeCodeableConcept(json, 'doseStatus', elem.doseStatus); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'doseStatusReason', elem.doseStatusReason); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseImmunization(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunization(jsn)); {2}
end;

function TFHIRJsonParser.ParseImmunization(jsn : TJsonObject) : TFhirImmunization;
begin
  result := TFhirImmunization.create;
  try
    ParseImmunizationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImmunizationProperties(jsn : TJsonObject; result : TFhirImmunization);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirMedicationAdminStatusEnum, SYSTEMS_TFhirMedicationAdminStatusEnum);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('vaccineCode') then
        result.vaccineCode := ParseCodeableConcept(jsn.vObj['vaccineCode']);{q3}
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
    if jsn.has('wasNotGiven') or jsn.has('_wasNotGiven') then
        result.wasNotGivenElement := ParseBoolean(jsn.node['wasNotGiven'], jsn.vObj['_wasNotGiven']);{q}
    if jsn.has('reported') or jsn.has('_reported') then
        result.reportedElement := ParseBoolean(jsn.node['reported'], jsn.vObj['_reported']);{q}
    if jsn.has('performer') then
        result.performer := ParseReference{TFhirPractitioner}(jsn.vObj['performer']);{q3}
    if jsn.has('requester') then
        result.requester := ParseReference{TFhirPractitioner}(jsn.vObj['requester']);{q3}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('manufacturer') then
        result.manufacturer := ParseReference{TFhirOrganization}(jsn.vObj['manufacturer']);{q3}
    if jsn.has('location') then
        result.location := ParseReference{TFhirLocation}(jsn.vObj['location']);{q3}
    if jsn.has('lotNumber') or jsn.has('_lotNumber') then
        result.lotNumberElement := ParseString(jsn.node['lotNumber'], jsn.vObj['_lotNumber']);{q}
    if jsn.has('expirationDate') or jsn.has('_expirationDate') then
        result.expirationDateElement := ParseDate(jsn.node['expirationDate'], jsn.vObj['_expirationDate']);{q}
    if jsn.has('site') then
        result.site := ParseCodeableConcept(jsn.vObj['site']);{q3}
    if jsn.has('route') then
        result.route := ParseCodeableConcept(jsn.vObj['route']);{q3}
    if jsn.has('doseQuantity') then
        result.doseQuantity := ParseQuantity(jsn.vObj['doseQuantity']);{q3}
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parseAnnotation);
    if jsn.has('explanation') then
        result.explanation := ParseImmunizationExplanation(jsn.vObj['explanation']);{q3}
    if jsn.has('reaction') then
      iterateArray(jsn.vArr['reaction'], result.reactionList, parseImmunizationReaction);
    if jsn.has('vaccinationProtocol') then
      iterateArray(jsn.vArr['vaccinationProtocol'], result.vaccinationProtocolList, parseImmunizationVaccinationProtocol);
end;

procedure TFHIRJsonComposer.ComposeImmunization(json : TJSONWriter; name : string; elem : TFhirImmunization; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirMedicationAdminStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirMedicationAdminStatusEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  ComposeCodeableConcept(json, 'vaccineCode', elem.vaccineCode); {a}
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  ComposeBooleanValue(json, 'wasNotGiven', elem.wasNotGivenElement, false);
  ComposeBooleanProps(json, 'wasNotGiven', elem.wasNotGivenElement, false);
  ComposeBooleanValue(json, 'reported', elem.reportedElement, false);
  ComposeBooleanProps(json, 'reported', elem.reportedElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('performer') then
    ComposeReference{TFhirPractitioner}(json, 'performer', elem.performer); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('requester') then
    ComposeReference{TFhirPractitioner}(json, 'requester', elem.requester); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('manufacturer') then
    ComposeReference{TFhirOrganization}(json, 'manufacturer', elem.manufacturer); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('location') then
    ComposeReference{TFhirLocation}(json, 'location', elem.location); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('lotNumber') then
    ComposeStringValue(json, 'lotNumber', elem.lotNumberElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('lotNumber') then
    ComposeStringProps(json, 'lotNumber', elem.lotNumberElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('expirationDate') then
    ComposeDateValue(json, 'expirationDate', elem.expirationDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('expirationDate') then
    ComposeDateProps(json, 'expirationDate', elem.expirationDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('site') then
    ComposeCodeableConcept(json, 'site', elem.site); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('route') then
    ComposeCodeableConcept(json, 'route', elem.route); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('doseQuantity') then
    ComposeQuantity(json, 'doseQuantity', elem.doseQuantity); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('note') and (elem.noteList.Count > 0) then
  begin
    startArray(json, 'note', elem.noteList, false);
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(json, '', elem.noteList[i]); {z - Annotation}
    finishArray(json, elem.noteList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('explanation') then
    ComposeImmunizationExplanation(json, 'explanation', elem.explanation); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('reaction') and (elem.reactionList.Count > 0) then
  begin
    startArray(json, 'reaction', elem.reactionList, false);
    for i := 0 to elem.reactionList.Count - 1 do
      ComposeImmunizationReaction(json, '', elem.reactionList[i]); {z - }
    finishArray(json, elem.reactionList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('vaccinationProtocol') and (elem.vaccinationProtocolList.Count > 0) then
  begin
    startArray(json, 'vaccinationProtocol', elem.vaccinationProtocolList, false);
    for i := 0 to elem.vaccinationProtocolList.Count - 1 do
      ComposeImmunizationVaccinationProtocol(json, '', elem.vaccinationProtocolList[i]); {z - }
    finishArray(json, elem.vaccinationProtocolList);
  end;
end;

{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
procedure TFHIRJsonParser.ParseImmunizationRecommendationRecommendation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunizationRecommendationRecommendation(jsn)); {2}
end;

function TFHIRJsonParser.ParseImmunizationRecommendationRecommendation(jsn : TJsonObject) : TFhirImmunizationRecommendationRecommendation;
begin
  result := TFhirImmunizationRecommendationRecommendation.create;
  try
    ParseImmunizationRecommendationRecommendationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImmunizationRecommendationRecommendationProperties(jsn : TJsonObject; result : TFhirImmunizationRecommendationRecommendation);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('vaccineCode') then
        result.vaccineCode := ParseCodeableConcept(jsn.vObj['vaccineCode']);{q3}
    if jsn.has('doseNumber') or jsn.has('_doseNumber') then
        result.doseNumberElement := ParsePositiveInt(jsn.node['doseNumber'], jsn.vObj['_doseNumber']);{q}
    if jsn.has('forecastStatus') then
        result.forecastStatus := ParseCodeableConcept(jsn.vObj['forecastStatus']);{q3}
    if jsn.has('dateCriterion') then
      iterateArray(jsn.vArr['dateCriterion'], result.dateCriterionList, parseImmunizationRecommendationRecommendationDateCriterion);
    if jsn.has('protocol') then
        result.protocol := ParseImmunizationRecommendationRecommendationProtocol(jsn.vObj['protocol']);{q3}
    if jsn.has('supportingImmunization') then
      iterateArray(jsn.vArr['supportingImmunization'], result.supportingImmunizationList, parseReference{TFhirImmunization});
    if jsn.has('supportingPatientInformation') then
      iterateArray(jsn.vArr['supportingPatientInformation'], result.supportingPatientInformationList, parseReference{Resource});
end;

procedure TFHIRJsonComposer.ComposeImmunizationRecommendationRecommendation(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendationRecommendation; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  ComposeCodeableConcept(json, 'vaccineCode', elem.vaccineCode); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntValue(json, 'doseNumber', elem.doseNumberElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntProps(json, 'doseNumber', elem.doseNumberElement, false);
  ComposeCodeableConcept(json, 'forecastStatus', elem.forecastStatus); {a}
  if (SummaryOption in [soFull, soData]) and (elem.dateCriterionList.Count > 0) then
  begin
    startArray(json, 'dateCriterion', elem.dateCriterionList, false);
    for i := 0 to elem.dateCriterionList.Count - 1 do
      ComposeImmunizationRecommendationRecommendationDateCriterion(json, '', elem.dateCriterionList[i]); {z - }
    finishArray(json, elem.dateCriterionList);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeImmunizationRecommendationRecommendationProtocol(json, 'protocol', elem.protocol); {a}
  if (SummaryOption in [soFull, soData]) and (elem.supportingImmunizationList.Count > 0) then
  begin
    startArray(json, 'supportingImmunization', elem.supportingImmunizationList, false);
    for i := 0 to elem.supportingImmunizationList.Count - 1 do
      ComposeReference{TFhirImmunization}(json, '', elem.supportingImmunizationList[i]); {z - Reference(Immunization)}
    finishArray(json, elem.supportingImmunizationList);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.supportingPatientInformationList.Count > 0) then
  begin
    startArray(json, 'supportingPatientInformation', elem.supportingPatientInformationList, false);
    for i := 0 to elem.supportingPatientInformationList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.supportingPatientInformationList[i]); {z - Reference(Observation|AllergyIntolerance)}
    finishArray(json, elem.supportingPatientInformationList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseImmunizationRecommendationRecommendationDateCriterion(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunizationRecommendationRecommendationDateCriterion(jsn)); {2}
end;

function TFHIRJsonParser.ParseImmunizationRecommendationRecommendationDateCriterion(jsn : TJsonObject) : TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion.create;
  try
    ParseImmunizationRecommendationRecommendationDateCriterionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImmunizationRecommendationRecommendationDateCriterionProperties(jsn : TJsonObject; result : TFhirImmunizationRecommendationRecommendationDateCriterion);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := ParseDateTime(jsn.node['value'], jsn.vObj['_value']);{q}
end;

procedure TFHIRJsonComposer.ComposeImmunizationRecommendationRecommendationDateCriterion(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendationRecommendationDateCriterion; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  ComposeDateTimeValue(json, 'value', elem.valueElement, false);
  ComposeDateTimeProps(json, 'value', elem.valueElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseImmunizationRecommendationRecommendationProtocol(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunizationRecommendationRecommendationProtocol(jsn)); {2}
end;

function TFHIRJsonParser.ParseImmunizationRecommendationRecommendationProtocol(jsn : TJsonObject) : TFhirImmunizationRecommendationRecommendationProtocol;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocol.create;
  try
    ParseImmunizationRecommendationRecommendationProtocolProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImmunizationRecommendationRecommendationProtocolProperties(jsn : TJsonObject; result : TFhirImmunizationRecommendationRecommendationProtocol);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('doseSequence') or jsn.has('_doseSequence') then
        result.doseSequenceElement := ParseInteger(jsn.node['doseSequence'], jsn.vObj['_doseSequence']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('authority') then
        result.authority := ParseReference{TFhirOrganization}(jsn.vObj['authority']);{q3}
    if jsn.has('series') or jsn.has('_series') then
        result.seriesElement := ParseString(jsn.node['series'], jsn.vObj['_series']);{q}
end;

procedure TFHIRJsonComposer.ComposeImmunizationRecommendationRecommendationProtocol(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendationRecommendationProtocol; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerValue(json, 'doseSequence', elem.doseSequenceElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerProps(json, 'doseSequence', elem.doseSequenceElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(json, 'authority', elem.authority); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'series', elem.seriesElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'series', elem.seriesElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseImmunizationRecommendation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImmunizationRecommendation(jsn)); {2}
end;

function TFHIRJsonParser.ParseImmunizationRecommendation(jsn : TJsonObject) : TFhirImmunizationRecommendation;
begin
  result := TFhirImmunizationRecommendation.create;
  try
    ParseImmunizationRecommendationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImmunizationRecommendationProperties(jsn : TJsonObject; result : TFhirImmunizationRecommendation);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
    if jsn.has('recommendation') then
      iterateArray(jsn.vArr['recommendation'], result.recommendationList, parseImmunizationRecommendationRecommendation);
end;

procedure TFHIRJsonComposer.ComposeImmunizationRecommendation(json : TJSONWriter; name : string; elem : TFhirImmunizationRecommendation; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (elem.recommendationList.Count > 0) then
  begin
    startArray(json, 'recommendation', elem.recommendationList, false);
    for i := 0 to elem.recommendationList.Count - 1 do
      ComposeImmunizationRecommendationRecommendation(json, '', elem.recommendationList[i]); {z - }
    finishArray(json, elem.recommendationList);
  end;
end;

{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
procedure TFHIRJsonParser.ParseImplementationGuideContact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImplementationGuideContact(jsn)); {2}
end;

function TFHIRJsonParser.ParseImplementationGuideContact(jsn : TJsonObject) : TFhirImplementationGuideContact;
begin
  result := TFhirImplementationGuideContact.create;
  try
    ParseImplementationGuideContactProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImplementationGuideContactProperties(jsn : TJsonObject; result : TFhirImplementationGuideContact);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
end;

procedure TFHIRJsonComposer.ComposeImplementationGuideContact(json : TJSONWriter; name : string; elem : TFhirImplementationGuideContact; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.telecomList.Count > 0) then
  begin
    startArray(json, 'telecom', elem.telecomList, false);
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    finishArray(json, elem.telecomList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseImplementationGuideDependency(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImplementationGuideDependency(jsn)); {2}
end;

function TFHIRJsonParser.ParseImplementationGuideDependency(jsn : TJsonObject) : TFhirImplementationGuideDependency;
begin
  result := TFhirImplementationGuideDependency.create;
  try
    ParseImplementationGuideDependencyProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImplementationGuideDependencyProperties(jsn : TJsonObject; result : TFhirImplementationGuideDependency);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirGuideDependencyTypeEnum, SYSTEMS_TFhirGuideDependencyTypeEnum);
    if jsn.has('uri') or jsn.has('_uri') then
        result.uriElement := ParseUri(jsn.node['uri'], jsn.vObj['_uri']);{q}
end;

procedure TFHIRJsonComposer.ComposeImplementationGuideDependency(json : TJSONWriter; name : string; elem : TFhirImplementationGuideDependency; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirGuideDependencyTypeEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirGuideDependencyTypeEnum, false);
  ComposeUriValue(json, 'uri', elem.uriElement, false);
  ComposeUriProps(json, 'uri', elem.uriElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseImplementationGuidePackage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImplementationGuidePackage(jsn)); {2}
end;

function TFHIRJsonParser.ParseImplementationGuidePackage(jsn : TJsonObject) : TFhirImplementationGuidePackage;
begin
  result := TFhirImplementationGuidePackage.create;
  try
    ParseImplementationGuidePackageProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImplementationGuidePackageProperties(jsn : TJsonObject; result : TFhirImplementationGuidePackage);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('resource') then
      iterateArray(jsn.vArr['resource'], result.resourceList, parseImplementationGuidePackageResource);
end;

procedure TFHIRJsonComposer.ComposeImplementationGuidePackage(json : TJSONWriter; name : string; elem : TFhirImplementationGuidePackage; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (elem.resourceList.Count > 0) then
  begin
    startArray(json, 'resource', elem.resourceList, false);
    for i := 0 to elem.resourceList.Count - 1 do
      ComposeImplementationGuidePackageResource(json, '', elem.resourceList[i]); {z - }
    finishArray(json, elem.resourceList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseImplementationGuidePackageResource(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImplementationGuidePackageResource(jsn)); {2}
end;

function TFHIRJsonParser.ParseImplementationGuidePackageResource(jsn : TJsonObject) : TFhirImplementationGuidePackageResource;
begin
  result := TFhirImplementationGuidePackageResource.create;
  try
    ParseImplementationGuidePackageResourceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImplementationGuidePackageResourceProperties(jsn : TJsonObject; result : TFhirImplementationGuidePackageResource);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('purpose') or jsn.has('_purpose')  then
      result.purposeElement := parseEnum(jsn.path+'/purpose', jsn.node['purpose'], jsn.vObj['_purpose'], CODES_TFhirGuideResourcePurposeEnum, SYSTEMS_TFhirGuideResourcePurposeEnum);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('acronym') or jsn.has('_acronym') then
        result.acronymElement := ParseString(jsn.node['acronym'], jsn.vObj['_acronym']);{q}
    if jsn.has('sourceReference') {a3} then
      result.source := ParseReference(jsn.vObj['sourceReference']);
    if jsn.has('sourceUri') or jsn.has('_sourceUri') then
      result.source := ParseUri(jsn.node['sourceUri'], jsn.vObj['_sourceUri']);
    if jsn.has('exampleFor') then
        result.exampleFor := ParseReference{TFhirStructureDefinition}(jsn.vObj['exampleFor']);{q3}
end;

procedure TFHIRJsonComposer.ComposeImplementationGuidePackageResource(json : TJSONWriter; name : string; elem : TFhirImplementationGuidePackageResource; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'purpose', elem.PurposeElement, CODES_TFhirGuideResourcePurposeEnum, false);
  ComposeEnumProps(json, 'purpose', elem.PurposeElement, CODES_TFhirGuideResourcePurposeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'acronym', elem.acronymElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'acronym', elem.acronymElement, false);
  if (elem.source is TFhirReference) then
    ComposeReference(json, 'sourceReference', TFhirReference(elem.source))
  else if (elem.source is TFhirUri) then 
  begin
    ComposeUriValue(json, 'sourceUri', TFhirUri(elem.source), false);
    ComposeUriProps(json, 'sourceUri', TFhirUri(elem.source), false);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirStructureDefinition}(json, 'exampleFor', elem.exampleFor); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseImplementationGuideGlobal(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImplementationGuideGlobal(jsn)); {2}
end;

function TFHIRJsonParser.ParseImplementationGuideGlobal(jsn : TJsonObject) : TFhirImplementationGuideGlobal;
begin
  result := TFhirImplementationGuideGlobal.create;
  try
    ParseImplementationGuideGlobalProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImplementationGuideGlobalProperties(jsn : TJsonObject; result : TFhirImplementationGuideGlobal);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    if jsn.has('profile') then
        result.profile := ParseReference{TFhirStructureDefinition}(jsn.vObj['profile']);{q3}
end;

procedure TFHIRJsonComposer.ComposeImplementationGuideGlobal(json : TJSONWriter; name : string; elem : TFhirImplementationGuideGlobal; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirResourceTypesEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirResourceTypesEnum, false);
  ComposeReference{TFhirStructureDefinition}(json, 'profile', elem.profile); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseImplementationGuidePage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImplementationGuidePage(jsn)); {2}
end;

function TFHIRJsonParser.ParseImplementationGuidePage(jsn : TJsonObject) : TFhirImplementationGuidePage;
begin
  result := TFhirImplementationGuidePage.create;
  try
    ParseImplementationGuidePageProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImplementationGuidePageProperties(jsn : TJsonObject; result : TFhirImplementationGuidePage);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('source') or jsn.has('_source') then
        result.sourceElement := ParseUri(jsn.node['source'], jsn.vObj['_source']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('kind') or jsn.has('_kind')  then
      result.kindElement := parseEnum(jsn.path+'/kind', jsn.node['kind'], jsn.vObj['_kind'], CODES_TFhirGuidePageKindEnum, SYSTEMS_TFhirGuidePageKindEnum);
    if jsn.has('type') or jsn.has('_type') then
      iterateEnumArray(jsn.vArr['type'], jsn.vArr['_type'], jsn.path+'/type', result.type_, parseEnum, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
      if jsn.has('package') or jsn.has('_package') then
      iteratePrimitiveArray(jsn.vArr['package'], jsn.vArr['_package'], result.packageList, parseString);
    if jsn.has('format') or jsn.has('_format') then
        result.formatElement := ParseCode(jsn.node['format'], jsn.vObj['_format']);{q}
    if jsn.has('page') then
      iterateArray(jsn.vArr['page'], result.pageList, parseImplementationGuidePage);
end;

procedure TFHIRJsonComposer.ComposeImplementationGuidePage(json : TJSONWriter; name : string; elem : TFhirImplementationGuidePage; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeUriValue(json, 'source', elem.sourceElement, false);
  ComposeUriProps(json, 'source', elem.sourceElement, false);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  ComposeEnumValue(json, 'kind', elem.KindElement, CODES_TFhirGuidePageKindEnum, false);
  ComposeEnumProps(json, 'kind', elem.KindElement, CODES_TFhirGuidePageKindEnum, false);
  if (SummaryOption in [soFull, soData]) and (elem.type_.Count > 0) then
  begin
    val := false;
    ext := false;
    for i := 0 to elem.type_.Count - 1 do
    begin
      val := val or (elem.type_[i].hasPrimitiveValue);
      ext := ext or ((elem.type_[i].id <> '') or (elem.type_[i].hasExtensionList));
    end;
    if val then
    begin
      startArray(json, 'type', elem.type_List, true);
      for i := 0 to elem.type_.Count - 1 do
        ComposeEnumValue(json, '', elem.type_[i], CODES_TFhirResourceTypesEnum, true);
      finishArray(json, elem.type_List);
    end;
    if ext then
    begin
      startArray(json, '_type', elem.type_List, false);
      for i := 0 to elem.type_.Count - 1 do
        ComposeEnumProps(json, '', elem.type_[i], CODES_TFhirResourceTypesEnum, true);
      finishArray(json, elem.type_List);
    end;
  end;
  if (SummaryOption in [soFull, soData]) and (elem.packageList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.packageList.Count - 1 do
    begin
      ext := ext or ((elem.packageList[i].id <> '') or (elem.packageList[i].hasExtensionList) {no-comments or (elem.packageList[i].hasComments)});
      val := val or (elem.packageList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      startArray(json, 'package', elem.packageList, true);
      for i := 0 to elem.packageList.Count - 1 do
        ComposeStringValue(json, '',elem.packageList[i], true);
      finishArray(json, elem.packageList);
    end;
    if ext then
    begin
      startArray(json, '_package', elem.packageList, false);
      for i := 0 to elem.packageList.Count - 1 do
        ComposeStringProps(json, '',elem.packageList[i], true);
      finishArray(json, elem.packageList);
    end;
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeValue(json, 'format', elem.formatElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeProps(json, 'format', elem.formatElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.pageList.Count > 0) then
  begin
    startArray(json, 'page', elem.pageList, false);
    for i := 0 to elem.pageList.Count - 1 do
      ComposeImplementationGuidePage(json, '', elem.pageList[i]); {z - @ImplementationGuide.page}
    finishArray(json, elem.pageList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseImplementationGuide(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseImplementationGuide(jsn)); {2}
end;

function TFHIRJsonParser.ParseImplementationGuide(jsn : TJsonObject) : TFhirImplementationGuide;
begin
  result := TFhirImplementationGuide.create;
  try
    ParseImplementationGuideProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseImplementationGuideProperties(jsn : TJsonObject; result : TFhirImplementationGuide);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := ParseBoolean(jsn.node['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := ParseString(jsn.node['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseImplementationGuideContact);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseCodeableConcept);
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := ParseString(jsn.node['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('fhirVersion') or jsn.has('_fhirVersion') then
        result.fhirVersionElement := ParseId(jsn.node['fhirVersion'], jsn.vObj['_fhirVersion']);{q}
    if jsn.has('dependency') then
      iterateArray(jsn.vArr['dependency'], result.dependencyList, parseImplementationGuideDependency);
    if jsn.has('package') then
      iterateArray(jsn.vArr['package'], result.packageList, parseImplementationGuidePackage);
    if jsn.has('global') then
      iterateArray(jsn.vArr['global'], result.globalList, parseImplementationGuideGlobal);
      if jsn.has('binary') or jsn.has('_binary') then
      iteratePrimitiveArray(jsn.vArr['binary'], jsn.vArr['_binary'], result.binaryList, parseUri);
    if jsn.has('page') then
        result.page := ParseImplementationGuidePage(jsn.vObj['page']);{q3}
end;

procedure TFHIRJsonComposer.ComposeImplementationGuide(json : TJSONWriter; name : string; elem : TFhirImplementationGuide; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeUriValue(json, 'url', elem.urlElement, false);
  ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    startArray(json, 'contact', elem.contactList, false);
    for i := 0 to elem.contactList.Count - 1 do
      ComposeImplementationGuideContact(json, '', elem.contactList[i]); {z - }
    finishArray(json, elem.contactList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') and (elem.useContextList.Count > 0) then
  begin
    startArray(json, 'useContext', elem.useContextList, false);
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.useContextList[i]); {z - CodeableConcept}
    finishArray(json, elem.useContextList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeStringValue(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeStringProps(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('fhirVersion') then
    ComposeIdValue(json, 'fhirVersion', elem.fhirVersionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('fhirVersion') then
    ComposeIdProps(json, 'fhirVersion', elem.fhirVersionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dependency') and (elem.dependencyList.Count > 0) then
  begin
    startArray(json, 'dependency', elem.dependencyList, false);
    for i := 0 to elem.dependencyList.Count - 1 do
      ComposeImplementationGuideDependency(json, '', elem.dependencyList[i]); {z - }
    finishArray(json, elem.dependencyList);
  end;
  if (elem.packageList.Count > 0) then
  begin
    startArray(json, 'package', elem.packageList, false);
    for i := 0 to elem.packageList.Count - 1 do
      ComposeImplementationGuidePackage(json, '', elem.packageList[i]); {z - }
    finishArray(json, elem.packageList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('global') and (elem.globalList.Count > 0) then
  begin
    startArray(json, 'global', elem.globalList, false);
    for i := 0 to elem.globalList.Count - 1 do
      ComposeImplementationGuideGlobal(json, '', elem.globalList[i]); {z - }
    finishArray(json, elem.globalList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('binary') and (elem.binaryList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.binaryList.Count - 1 do
    begin
      ext := ext or ((elem.binaryList[i].id <> '') or (elem.binaryList[i].hasExtensionList) {no-comments or (elem.binaryList[i].hasComments)});
      val := val or (elem.binaryList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      startArray(json, 'binary', elem.binaryList, true);
      for i := 0 to elem.binaryList.Count - 1 do
        ComposeUriValue(json, '',elem.binaryList[i], true);
      finishArray(json, elem.binaryList);
    end;
    if ext then
    begin
      startArray(json, '_binary', elem.binaryList, false);
      for i := 0 to elem.binaryList.Count - 1 do
        ComposeUriProps(json, '',elem.binaryList[i], true);
      finishArray(json, elem.binaryList);
    end;
  end;
  ComposeImplementationGuidePage(json, 'page', elem.page); {a}
end;

{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_LIST}
procedure TFHIRJsonParser.ParseListEntry(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseListEntry(jsn)); {2}
end;

function TFHIRJsonParser.ParseListEntry(jsn : TJsonObject) : TFhirListEntry;
begin
  result := TFhirListEntry.create;
  try
    ParseListEntryProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseListEntryProperties(jsn : TJsonObject; result : TFhirListEntry);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('flag') then
        result.flag := ParseCodeableConcept(jsn.vObj['flag']);{q3}
    if jsn.has('deleted') or jsn.has('_deleted') then
        result.deletedElement := ParseBoolean(jsn.node['deleted'], jsn.vObj['_deleted']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('item') then
        result.item := ParseReference{TFhirReference}(jsn.vObj['item']);{q3}
end;

procedure TFHIRJsonComposer.ComposeListEntry(json : TJSONWriter; name : string; elem : TFhirListEntry; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'flag', elem.flag); {a}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.deleted <> false)) then
    ComposeBooleanValue(json, 'deleted', elem.deletedElement, false);
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.deleted <> false)) then
    ComposeBooleanProps(json, 'deleted', elem.deletedElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  ComposeReference{TFhirReference}(json, 'item', elem.item); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseList(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseList(jsn)); {2}
end;

function TFHIRJsonParser.ParseList(jsn : TJsonObject) : TFhirList;
begin
  result := TFhirList.create;
  try
    ParseListProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseListProperties(jsn : TJsonObject; result : TFhirList);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := ParseString(jsn.node['title'], jsn.vObj['_title']);{q}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q3}
    if jsn.has('source') then
        result.source := ParseReference{Resource}(jsn.vObj['source']);{q3}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirListStatusEnum, SYSTEMS_TFhirListStatusEnum);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('orderedBy') then
        result.orderedBy := ParseCodeableConcept(jsn.vObj['orderedBy']);{q3}
    if jsn.has('mode') or jsn.has('_mode')  then
      result.modeElement := parseEnum(jsn.path+'/mode', jsn.node['mode'], jsn.vObj['_mode'], CODES_TFhirListModeEnum, SYSTEMS_TFhirListModeEnum);
    if jsn.has('note') or jsn.has('_note') then
        result.noteElement := ParseString(jsn.node['note'], jsn.vObj['_note']);{q}
    if jsn.has('entry') then
      iterateArray(jsn.vArr['entry'], result.entryList, parseListEntry);
    if jsn.has('emptyReason') then
        result.emptyReason := ParseCodeableConcept(jsn.vObj['emptyReason']);{q3}
end;

procedure TFHIRJsonComposer.ComposeList(json : TJSONWriter; name : string; elem : TFhirList; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('source') then
    ComposeReference{Resource}(json, 'source', elem.source); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirListStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirListStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('orderedBy') then
    ComposeCodeableConcept(json, 'orderedBy', elem.orderedBy); {a}
  ComposeEnumValue(json, 'mode', elem.ModeElement, CODES_TFhirListModeEnum, false);
  ComposeEnumProps(json, 'mode', elem.ModeElement, CODES_TFhirListModeEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    ComposeStringValue(json, 'note', elem.noteElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    ComposeStringProps(json, 'note', elem.noteElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('entry') and (elem.entryList.Count > 0) then
  begin
    startArray(json, 'entry', elem.entryList, false);
    for i := 0 to elem.entryList.Count - 1 do
      ComposeListEntry(json, '', elem.entryList[i]); {z - }
    finishArray(json, elem.entryList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('emptyReason') then
    ComposeCodeableConcept(json, 'emptyReason', elem.emptyReason); {a}
end;

{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
procedure TFHIRJsonParser.ParseLocationPosition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseLocationPosition(jsn)); {2}
end;

function TFHIRJsonParser.ParseLocationPosition(jsn : TJsonObject) : TFhirLocationPosition;
begin
  result := TFhirLocationPosition.create;
  try
    ParseLocationPositionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseLocationPositionProperties(jsn : TJsonObject; result : TFhirLocationPosition);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('longitude') or jsn.has('_longitude') then
        result.longitudeElement := ParseDecimal(jsn.node['longitude'], jsn.vObj['_longitude']);{q}
    if jsn.has('latitude') or jsn.has('_latitude') then
        result.latitudeElement := ParseDecimal(jsn.node['latitude'], jsn.vObj['_latitude']);{q}
    if jsn.has('altitude') or jsn.has('_altitude') then
        result.altitudeElement := ParseDecimal(jsn.node['altitude'], jsn.vObj['_altitude']);{q}
end;

procedure TFHIRJsonComposer.ComposeLocationPosition(json : TJSONWriter; name : string; elem : TFhirLocationPosition; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeDecimalValue(json, 'longitude', elem.longitudeElement, false);
  ComposeDecimalProps(json, 'longitude', elem.longitudeElement, false);
  ComposeDecimalValue(json, 'latitude', elem.latitudeElement, false);
  ComposeDecimalProps(json, 'latitude', elem.latitudeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'altitude', elem.altitudeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'altitude', elem.altitudeElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseLocation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseLocation(jsn)); {2}
end;

function TFHIRJsonParser.ParseLocation(jsn : TJsonObject) : TFhirLocation;
begin
  result := TFhirLocation.create;
  try
    ParseLocationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseLocationProperties(jsn : TJsonObject; result : TFhirLocation);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirLocationStatusEnum, SYSTEMS_TFhirLocationStatusEnum);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('mode') or jsn.has('_mode')  then
      result.modeElement := parseEnum(jsn.path+'/mode', jsn.node['mode'], jsn.vObj['_mode'], CODES_TFhirLocationModeEnum, SYSTEMS_TFhirLocationModeEnum);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('address') then
        result.address := ParseAddress(jsn.vObj['address']);{q3}
    if jsn.has('physicalType') then
        result.physicalType := ParseCodeableConcept(jsn.vObj['physicalType']);{q3}
    if jsn.has('position') then
        result.position := ParseLocationPosition(jsn.vObj['position']);{q3}
    if jsn.has('managingOrganization') then
        result.managingOrganization := ParseReference{TFhirOrganization}(jsn.vObj['managingOrganization']);{q3}
    if jsn.has('partOf') then
        result.partOf := ParseReference{TFhirLocation}(jsn.vObj['partOf']);{q3}
end;

procedure TFHIRJsonComposer.ComposeLocation(json : TJSONWriter; name : string; elem : TFhirLocation; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirLocationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirLocationStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('mode') then
    ComposeEnumValue(json, 'mode', elem.ModeElement, CODES_TFhirLocationModeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('mode') then
    ComposeEnumProps(json, 'mode', elem.ModeElement, CODES_TFhirLocationModeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('telecom') and (elem.telecomList.Count > 0) then
  begin
    startArray(json, 'telecom', elem.telecomList, false);
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    finishArray(json, elem.telecomList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('address') then
    ComposeAddress(json, 'address', elem.address); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('physicalType') then
    ComposeCodeableConcept(json, 'physicalType', elem.physicalType); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('position') then
    ComposeLocationPosition(json, 'position', elem.position); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('managingOrganization') then
    ComposeReference{TFhirOrganization}(json, 'managingOrganization', elem.managingOrganization); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('partOf') then
    ComposeReference{TFhirLocation}(json, 'partOf', elem.partOf); {a}
end;

{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEDIA}
procedure TFHIRJsonParser.ParseMedia(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedia(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedia(jsn : TJsonObject) : TFhirMedia;
begin
  result := TFhirMedia.create;
  try
    ParseMediaProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMediaProperties(jsn : TJsonObject; result : TFhirMedia);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirDigitalMediaTypeEnum, SYSTEMS_TFhirDigitalMediaTypeEnum);
    if jsn.has('subtype') then
        result.subtype := ParseCodeableConcept(jsn.vObj['subtype']);{q3}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q3}
    if jsn.has('operator') then
        result.operator := ParseReference{TFhirPractitioner}(jsn.vObj['operator']);{q3}
    if jsn.has('view') then
        result.view := ParseCodeableConcept(jsn.vObj['view']);{q3}
    if jsn.has('deviceName') or jsn.has('_deviceName') then
        result.deviceNameElement := ParseString(jsn.node['deviceName'], jsn.vObj['_deviceName']);{q}
    if jsn.has('height') or jsn.has('_height') then
        result.heightElement := ParsePositiveInt(jsn.node['height'], jsn.vObj['_height']);{q}
    if jsn.has('width') or jsn.has('_width') then
        result.widthElement := ParsePositiveInt(jsn.node['width'], jsn.vObj['_width']);{q}
    if jsn.has('frames') or jsn.has('_frames') then
        result.framesElement := ParsePositiveInt(jsn.node['frames'], jsn.vObj['_frames']);{q}
    if jsn.has('duration') or jsn.has('_duration') then
        result.durationElement := ParseUnsignedInt(jsn.node['duration'], jsn.vObj['_duration']);{q}
    if jsn.has('content') then
        result.content := ParseAttachment(jsn.vObj['content']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMedia(json : TJSONWriter; name : string; elem : TFhirMedia; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirDigitalMediaTypeEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirDigitalMediaTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subtype') then
    ComposeCodeableConcept(json, 'subtype', elem.subtype); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('operator') then
    ComposeReference{TFhirPractitioner}(json, 'operator', elem.operator); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('view') then
    ComposeCodeableConcept(json, 'view', elem.view); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('deviceName') then
    ComposeStringValue(json, 'deviceName', elem.deviceNameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('deviceName') then
    ComposeStringProps(json, 'deviceName', elem.deviceNameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('height') then
    ComposePositiveIntValue(json, 'height', elem.heightElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('height') then
    ComposePositiveIntProps(json, 'height', elem.heightElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('width') then
    ComposePositiveIntValue(json, 'width', elem.widthElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('width') then
    ComposePositiveIntProps(json, 'width', elem.widthElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.frames <> '1')) and doCompose('frames') then
    ComposePositiveIntValue(json, 'frames', elem.framesElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.frames <> '1')) and doCompose('frames') then
    ComposePositiveIntProps(json, 'frames', elem.framesElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('duration') then
    ComposeUnsignedIntValue(json, 'duration', elem.durationElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('duration') then
    ComposeUnsignedIntProps(json, 'duration', elem.durationElement, false);
  ComposeAttachment(json, 'content', elem.content); {a}
end;

{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
procedure TFHIRJsonParser.ParseMedicationProduct(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationProduct(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationProduct(jsn : TJsonObject) : TFhirMedicationProduct;
begin
  result := TFhirMedicationProduct.create;
  try
    ParseMedicationProductProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationProductProperties(jsn : TJsonObject; result : TFhirMedicationProduct);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('form') then
        result.form := ParseCodeableConcept(jsn.vObj['form']);{q3}
    if jsn.has('ingredient') then
      iterateArray(jsn.vArr['ingredient'], result.ingredientList, parseMedicationProductIngredient);
    if jsn.has('batch') then
      iterateArray(jsn.vArr['batch'], result.batchList, parseMedicationProductBatch);
end;

procedure TFHIRJsonComposer.ComposeMedicationProduct(json : TJSONWriter; name : string; elem : TFhirMedicationProduct; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'form', elem.form); {a}
  if (SummaryOption in [soFull, soData]) and (elem.ingredientList.Count > 0) then
  begin
    startArray(json, 'ingredient', elem.ingredientList, false);
    for i := 0 to elem.ingredientList.Count - 1 do
      ComposeMedicationProductIngredient(json, '', elem.ingredientList[i]); {z - }
    finishArray(json, elem.ingredientList);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.batchList.Count > 0) then
  begin
    startArray(json, 'batch', elem.batchList, false);
    for i := 0 to elem.batchList.Count - 1 do
      ComposeMedicationProductBatch(json, '', elem.batchList[i]); {z - }
    finishArray(json, elem.batchList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseMedicationProductIngredient(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationProductIngredient(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationProductIngredient(jsn : TJsonObject) : TFhirMedicationProductIngredient;
begin
  result := TFhirMedicationProductIngredient.create;
  try
    ParseMedicationProductIngredientProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationProductIngredientProperties(jsn : TJsonObject; result : TFhirMedicationProductIngredient);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('item') then
        result.item := ParseReference{Resource}(jsn.vObj['item']);{q3}
    if jsn.has('amount') then
        result.amount := ParseRatio(jsn.vObj['amount']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMedicationProductIngredient(json : TJSONWriter; name : string; elem : TFhirMedicationProductIngredient; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeReference{Resource}(json, 'item', elem.item); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeRatio(json, 'amount', elem.amount); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseMedicationProductBatch(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationProductBatch(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationProductBatch(jsn : TJsonObject) : TFhirMedicationProductBatch;
begin
  result := TFhirMedicationProductBatch.create;
  try
    ParseMedicationProductBatchProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationProductBatchProperties(jsn : TJsonObject; result : TFhirMedicationProductBatch);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('lotNumber') or jsn.has('_lotNumber') then
        result.lotNumberElement := ParseString(jsn.node['lotNumber'], jsn.vObj['_lotNumber']);{q}
    if jsn.has('expirationDate') or jsn.has('_expirationDate') then
        result.expirationDateElement := ParseDateTime(jsn.node['expirationDate'], jsn.vObj['_expirationDate']);{q}
end;

procedure TFHIRJsonComposer.ComposeMedicationProductBatch(json : TJSONWriter; name : string; elem : TFhirMedicationProductBatch; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'lotNumber', elem.lotNumberElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'lotNumber', elem.lotNumberElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeValue(json, 'expirationDate', elem.expirationDateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTimeProps(json, 'expirationDate', elem.expirationDateElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseMedicationPackage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationPackage(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationPackage(jsn : TJsonObject) : TFhirMedicationPackage;
begin
  result := TFhirMedicationPackage.create;
  try
    ParseMedicationPackageProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationPackageProperties(jsn : TJsonObject; result : TFhirMedicationPackage);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('container') then
        result.container := ParseCodeableConcept(jsn.vObj['container']);{q3}
    if jsn.has('content') then
      iterateArray(jsn.vArr['content'], result.contentList, parseMedicationPackageContent);
end;

procedure TFHIRJsonComposer.ComposeMedicationPackage(json : TJSONWriter; name : string; elem : TFhirMedicationPackage; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'container', elem.container); {a}
  if (SummaryOption in [soFull, soData]) and (elem.contentList.Count > 0) then
  begin
    startArray(json, 'content', elem.contentList, false);
    for i := 0 to elem.contentList.Count - 1 do
      ComposeMedicationPackageContent(json, '', elem.contentList[i]); {z - }
    finishArray(json, elem.contentList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseMedicationPackageContent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationPackageContent(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationPackageContent(jsn : TJsonObject) : TFhirMedicationPackageContent;
begin
  result := TFhirMedicationPackageContent.create;
  try
    ParseMedicationPackageContentProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationPackageContentProperties(jsn : TJsonObject; result : TFhirMedicationPackageContent);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('item') then
        result.item := ParseReference{TFhirMedication}(jsn.vObj['item']);{q3}
    if jsn.has('amount') then
        result.amount := ParseQuantity(jsn.vObj['amount']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMedicationPackageContent(json : TJSONWriter; name : string; elem : TFhirMedicationPackageContent; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeReference{TFhirMedication}(json, 'item', elem.item); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'amount', elem.amount); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseMedication(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedication(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedication(jsn : TJsonObject) : TFhirMedication;
begin
  result := TFhirMedication.create;
  try
    ParseMedicationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationProperties(jsn : TJsonObject; result : TFhirMedication);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('isBrand') or jsn.has('_isBrand') then
        result.isBrandElement := ParseBoolean(jsn.node['isBrand'], jsn.vObj['_isBrand']);{q}
    if jsn.has('manufacturer') then
        result.manufacturer := ParseReference{TFhirOrganization}(jsn.vObj['manufacturer']);{q3}
    if jsn.has('product') then
        result.product := ParseMedicationProduct(jsn.vObj['product']);{q3}
    if jsn.has('package') then
        result.package := ParseMedicationPackage(jsn.vObj['package']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMedication(json : TJSONWriter; name : string; elem : TFhirMedication; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('isBrand') then
    ComposeBooleanValue(json, 'isBrand', elem.isBrandElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('isBrand') then
    ComposeBooleanProps(json, 'isBrand', elem.isBrandElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('manufacturer') then
    ComposeReference{TFhirOrganization}(json, 'manufacturer', elem.manufacturer); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('product') then
    ComposeMedicationProduct(json, 'product', elem.product); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('package') then
    ComposeMedicationPackage(json, 'package', elem.package); {a}
end;

{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
procedure TFHIRJsonParser.ParseMedicationAdministrationDosage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationAdministrationDosage(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationAdministrationDosage(jsn : TJsonObject) : TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage.create;
  try
    ParseMedicationAdministrationDosageProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationAdministrationDosageProperties(jsn : TJsonObject; result : TFhirMedicationAdministrationDosage);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn.node['text'], jsn.vObj['_text']);{q}
    if jsn.has('siteCodeableConcept') {a4} then
      result.site := ParseCodeableConcept(jsn.vObj['siteCodeableConcept']);
    if jsn.has('siteReference') {a3} then
      result.site := ParseReference(jsn.vObj['siteReference']);
    if jsn.has('route') then
        result.route := ParseCodeableConcept(jsn.vObj['route']);{q3}
    if jsn.has('method') then
        result.method := ParseCodeableConcept(jsn.vObj['method']);{q3}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
    if jsn.has('rateRatio') {a4} then
      result.rate := ParseRatio(jsn.vObj['rateRatio']);
    if jsn.has('rateRange') {a4} then
      result.rate := ParseRange(jsn.vObj['rateRange']);
end;

procedure TFHIRJsonComposer.ComposeMedicationAdministrationDosage(json : TJSONWriter; name : string; elem : TFhirMedicationAdministrationDosage; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'siteCodeableConcept', TFhirCodeableConcept(elem.site)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirReference) then
    ComposeReference(json, 'siteReference', TFhirReference(elem.site));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'route', elem.route); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'method', elem.method); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRatio) then 
    ComposeRatio(json, 'rateRatio', TFhirRatio(elem.rate)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRange) then 
    ComposeRange(json, 'rateRange', TFhirRange(elem.rate)) ;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseMedicationAdministration(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationAdministration(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationAdministration(jsn : TJsonObject) : TFhirMedicationAdministration;
begin
  result := TFhirMedicationAdministration.create;
  try
    ParseMedicationAdministrationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationAdministrationProperties(jsn : TJsonObject; result : TFhirMedicationAdministration);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirMedicationAdminStatusEnum, SYSTEMS_TFhirMedicationAdminStatusEnum);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
    if jsn.has('practitioner') then
        result.practitioner := ParseReference{Resource}(jsn.vObj['practitioner']);{q3}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('prescription') then
        result.prescription := ParseReference{TFhirMedicationOrder}(jsn.vObj['prescription']);{q3}
    if jsn.has('wasNotGiven') or jsn.has('_wasNotGiven') then
        result.wasNotGivenElement := ParseBoolean(jsn.node['wasNotGiven'], jsn.vObj['_wasNotGiven']);{q}
    if jsn.has('reasonNotGiven') then
      iterateArray(jsn.vArr['reasonNotGiven'], result.reasonNotGivenList, parseCodeableConcept);
    if jsn.has('reasonGiven') then
      iterateArray(jsn.vArr['reasonGiven'], result.reasonGivenList, parseCodeableConcept);
    if jsn.has('effectiveTimePeriod') {a4} then
      result.effectiveTime := ParsePeriod(jsn.vObj['effectiveTimePeriod']);
    if jsn.has('effectiveTimeDateTime') or jsn.has('_effectiveTimeDateTime') then
      result.effectiveTime := ParseDateTime(jsn.node['effectiveTimeDateTime'], jsn.vObj['_effectiveTimeDateTime']);
    if jsn.has('medicationCodeableConcept') {a4} then
      result.medication := ParseCodeableConcept(jsn.vObj['medicationCodeableConcept']);
    if jsn.has('medicationReference') {a3} then
      result.medication := ParseReference(jsn.vObj['medicationReference']);
    if jsn.has('device') then
      iterateArray(jsn.vArr['device'], result.deviceList, parseReference{TFhirDevice});
    if jsn.has('note') or jsn.has('_note') then
        result.noteElement := ParseString(jsn.node['note'], jsn.vObj['_note']);{q}
    if jsn.has('dosage') then
        result.dosage := ParseMedicationAdministrationDosage(jsn.vObj['dosage']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMedicationAdministration(json : TJSONWriter; name : string; elem : TFhirMedicationAdministration; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirMedicationAdminStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirMedicationAdminStatusEnum, false);
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('practitioner') then
    ComposeReference{Resource}(json, 'practitioner', elem.practitioner); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('prescription') then
    ComposeReference{TFhirMedicationOrder}(json, 'prescription', elem.prescription); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('wasNotGiven') then
    ComposeBooleanValue(json, 'wasNotGiven', elem.wasNotGivenElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('wasNotGiven') then
    ComposeBooleanProps(json, 'wasNotGiven', elem.wasNotGivenElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonNotGiven') and (elem.reasonNotGivenList.Count > 0) then
  begin
    startArray(json, 'reasonNotGiven', elem.reasonNotGivenList, false);
    for i := 0 to elem.reasonNotGivenList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonNotGivenList[i]); {z - CodeableConcept}
    finishArray(json, elem.reasonNotGivenList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonGiven') and (elem.reasonGivenList.Count > 0) then
  begin
    startArray(json, 'reasonGiven', elem.reasonGivenList, false);
    for i := 0 to elem.reasonGivenList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonGivenList[i]); {z - CodeableConcept}
    finishArray(json, elem.reasonGivenList);
  end;
  if (elem.effectiveTime is TFhirPeriod) then 
    ComposePeriod(json, 'effectiveTimePeriod', TFhirPeriod(elem.effectiveTime)) 
  else if (elem.effectiveTime is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'effectiveTimeDateTime', TFhirDateTime(elem.effectiveTime), false);
    ComposeDateTimeProps(json, 'effectiveTimeDateTime', TFhirDateTime(elem.effectiveTime), false);
  end;
  if (elem.medication is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication)) 
  else if (elem.medication is TFhirReference) then
    ComposeReference(json, 'medicationReference', TFhirReference(elem.medication));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('device') and (elem.deviceList.Count > 0) then
  begin
    startArray(json, 'device', elem.deviceList, false);
    for i := 0 to elem.deviceList.Count - 1 do
      ComposeReference{TFhirDevice}(json, '', elem.deviceList[i]); {z - Reference(Device)}
    finishArray(json, elem.deviceList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('note') then
    ComposeStringValue(json, 'note', elem.noteElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('note') then
    ComposeStringProps(json, 'note', elem.noteElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dosage') then
    ComposeMedicationAdministrationDosage(json, 'dosage', elem.dosage); {a}
end;

{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
procedure TFHIRJsonParser.ParseMedicationDispenseDosageInstruction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationDispenseDosageInstruction(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationDispenseDosageInstruction(jsn : TJsonObject) : TFhirMedicationDispenseDosageInstruction;
begin
  result := TFhirMedicationDispenseDosageInstruction.create;
  try
    ParseMedicationDispenseDosageInstructionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationDispenseDosageInstructionProperties(jsn : TJsonObject; result : TFhirMedicationDispenseDosageInstruction);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn.node['text'], jsn.vObj['_text']);{q}
    if jsn.has('additionalInstructions') then
        result.additionalInstructions := ParseCodeableConcept(jsn.vObj['additionalInstructions']);{q3}
    if jsn.has('timing') then
        result.timing := ParseTiming(jsn.vObj['timing']);{q3}
    if jsn.has('asNeededCodeableConcept') {a4} then
      result.asNeeded := ParseCodeableConcept(jsn.vObj['asNeededCodeableConcept']);
    if jsn.has('asNeededBoolean') or jsn.has('_asNeededBoolean') then
      result.asNeeded := ParseBoolean(jsn.node['asNeededBoolean'], jsn.vObj['_asNeededBoolean']);
    if jsn.has('siteCodeableConcept') {a4} then
      result.site := ParseCodeableConcept(jsn.vObj['siteCodeableConcept']);
    if jsn.has('siteReference') {a3} then
      result.site := ParseReference(jsn.vObj['siteReference']);
    if jsn.has('route') then
        result.route := ParseCodeableConcept(jsn.vObj['route']);{q3}
    if jsn.has('method') then
        result.method := ParseCodeableConcept(jsn.vObj['method']);{q3}
    if jsn.has('doseRange') {a4} then
      result.dose := ParseRange(jsn.vObj['doseRange']);
    if jsn.has('doseQuantity') {a4} then
      result.dose := ParseQuantity(jsn.vObj['doseQuantity']);
    if jsn.has('rateRatio') {a4} then
      result.rate := ParseRatio(jsn.vObj['rateRatio']);
    if jsn.has('rateRange') {a4} then
      result.rate := ParseRange(jsn.vObj['rateRange']);
    if jsn.has('maxDosePerPeriod') then
        result.maxDosePerPeriod := ParseRatio(jsn.vObj['maxDosePerPeriod']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMedicationDispenseDosageInstruction(json : TJSONWriter; name : string; elem : TFhirMedicationDispenseDosageInstruction; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'additionalInstructions', elem.additionalInstructions); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTiming(json, 'timing', elem.timing); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
    ComposeBooleanProps(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'siteCodeableConcept', TFhirCodeableConcept(elem.site)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirReference) then
    ComposeReference(json, 'siteReference', TFhirReference(elem.site));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'route', elem.route); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'method', elem.method); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.dose is TFhirRange) then 
    ComposeRange(json, 'doseRange', TFhirRange(elem.dose)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.dose is TFhirQuantity) then 
    ComposeQuantity(json, 'doseQuantity', TFhirQuantity(elem.dose)) ;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRatio) then 
    ComposeRatio(json, 'rateRatio', TFhirRatio(elem.rate)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRange) then 
    ComposeRange(json, 'rateRange', TFhirRange(elem.rate)) ;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(json, 'maxDosePerPeriod', elem.maxDosePerPeriod); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseMedicationDispenseSubstitution(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationDispenseSubstitution(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationDispenseSubstitution(jsn : TJsonObject) : TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution.create;
  try
    ParseMedicationDispenseSubstitutionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationDispenseSubstitutionProperties(jsn : TJsonObject; result : TFhirMedicationDispenseSubstitution);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('reason') then
      iterateArray(jsn.vArr['reason'], result.reasonList, parseCodeableConcept);
    if jsn.has('responsibleParty') then
      iterateArray(jsn.vArr['responsibleParty'], result.responsiblePartyList, parseReference{TFhirPractitioner});
end;

procedure TFHIRJsonComposer.ComposeMedicationDispenseSubstitution(json : TJSONWriter; name : string; elem : TFhirMedicationDispenseSubstitution; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reasonList.Count > 0) then
  begin
    startArray(json, 'reason', elem.reasonList, false);
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonList[i]); {z - CodeableConcept}
    finishArray(json, elem.reasonList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.responsiblePartyList.Count > 0) then
  begin
    startArray(json, 'responsibleParty', elem.responsiblePartyList, false);
    for i := 0 to elem.responsiblePartyList.Count - 1 do
      ComposeReference{TFhirPractitioner}(json, '', elem.responsiblePartyList[i]); {z - Reference(Practitioner)}
    finishArray(json, elem.responsiblePartyList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseMedicationDispense(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationDispense(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationDispense(jsn : TJsonObject) : TFhirMedicationDispense;
begin
  result := TFhirMedicationDispense.create;
  try
    ParseMedicationDispenseProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationDispenseProperties(jsn : TJsonObject; result : TFhirMedicationDispense);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirMedicationDispenseStatusEnum, SYSTEMS_TFhirMedicationDispenseStatusEnum);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
    if jsn.has('dispenser') then
        result.dispenser := ParseReference{TFhirPractitioner}(jsn.vObj['dispenser']);{q3}
    if jsn.has('authorizingPrescription') then
      iterateArray(jsn.vArr['authorizingPrescription'], result.authorizingPrescriptionList, parseReference{TFhirMedicationOrder});
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
    if jsn.has('daysSupply') then
        result.daysSupply := ParseQuantity(jsn.vObj['daysSupply']);{q3}
    if jsn.has('medicationCodeableConcept') {a4} then
      result.medication := ParseCodeableConcept(jsn.vObj['medicationCodeableConcept']);
    if jsn.has('medicationReference') {a3} then
      result.medication := ParseReference(jsn.vObj['medicationReference']);
    if jsn.has('whenPrepared') or jsn.has('_whenPrepared') then
        result.whenPreparedElement := ParseDateTime(jsn.node['whenPrepared'], jsn.vObj['_whenPrepared']);{q}
    if jsn.has('whenHandedOver') or jsn.has('_whenHandedOver') then
        result.whenHandedOverElement := ParseDateTime(jsn.node['whenHandedOver'], jsn.vObj['_whenHandedOver']);{q}
    if jsn.has('destination') then
        result.destination := ParseReference{TFhirLocation}(jsn.vObj['destination']);{q3}
    if jsn.has('receiver') then
      iterateArray(jsn.vArr['receiver'], result.receiverList, parseReference{Resource});
    if jsn.has('note') or jsn.has('_note') then
        result.noteElement := ParseString(jsn.node['note'], jsn.vObj['_note']);{q}
    if jsn.has('dosageInstruction') then
      iterateArray(jsn.vArr['dosageInstruction'], result.dosageInstructionList, parseMedicationDispenseDosageInstruction);
    if jsn.has('substitution') then
        result.substitution := ParseMedicationDispenseSubstitution(jsn.vObj['substitution']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMedicationDispense(json : TJSONWriter; name : string; elem : TFhirMedicationDispense; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirMedicationDispenseStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirMedicationDispenseStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dispenser') then
    ComposeReference{TFhirPractitioner}(json, 'dispenser', elem.dispenser); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authorizingPrescription') and (elem.authorizingPrescriptionList.Count > 0) then
  begin
    startArray(json, 'authorizingPrescription', elem.authorizingPrescriptionList, false);
    for i := 0 to elem.authorizingPrescriptionList.Count - 1 do
      ComposeReference{TFhirMedicationOrder}(json, '', elem.authorizingPrescriptionList[i]); {z - Reference(MedicationOrder)}
    finishArray(json, elem.authorizingPrescriptionList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('quantity') then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('daysSupply') then
    ComposeQuantity(json, 'daysSupply', elem.daysSupply); {a}
  if (elem.medication is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication)) 
  else if (elem.medication is TFhirReference) then
    ComposeReference(json, 'medicationReference', TFhirReference(elem.medication));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('whenPrepared') then
    ComposeDateTimeValue(json, 'whenPrepared', elem.whenPreparedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('whenPrepared') then
    ComposeDateTimeProps(json, 'whenPrepared', elem.whenPreparedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('whenHandedOver') then
    ComposeDateTimeValue(json, 'whenHandedOver', elem.whenHandedOverElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('whenHandedOver') then
    ComposeDateTimeProps(json, 'whenHandedOver', elem.whenHandedOverElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('destination') then
    ComposeReference{TFhirLocation}(json, 'destination', elem.destination); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('receiver') and (elem.receiverList.Count > 0) then
  begin
    startArray(json, 'receiver', elem.receiverList, false);
    for i := 0 to elem.receiverList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.receiverList[i]); {z - Reference(Patient|Practitioner)}
    finishArray(json, elem.receiverList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('note') then
    ComposeStringValue(json, 'note', elem.noteElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('note') then
    ComposeStringProps(json, 'note', elem.noteElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dosageInstruction') and (elem.dosageInstructionList.Count > 0) then
  begin
    startArray(json, 'dosageInstruction', elem.dosageInstructionList, false);
    for i := 0 to elem.dosageInstructionList.Count - 1 do
      ComposeMedicationDispenseDosageInstruction(json, '', elem.dosageInstructionList[i]); {z - }
    finishArray(json, elem.dosageInstructionList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('substitution') then
    ComposeMedicationDispenseSubstitution(json, 'substitution', elem.substitution); {a}
end;

{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONORDER}
procedure TFHIRJsonParser.ParseMedicationOrderDosageInstruction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationOrderDosageInstruction(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationOrderDosageInstruction(jsn : TJsonObject) : TFhirMedicationOrderDosageInstruction;
begin
  result := TFhirMedicationOrderDosageInstruction.create;
  try
    ParseMedicationOrderDosageInstructionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationOrderDosageInstructionProperties(jsn : TJsonObject; result : TFhirMedicationOrderDosageInstruction);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn.node['text'], jsn.vObj['_text']);{q}
    if jsn.has('additionalInstructions') then
        result.additionalInstructions := ParseCodeableConcept(jsn.vObj['additionalInstructions']);{q3}
    if jsn.has('timing') then
        result.timing := ParseTiming(jsn.vObj['timing']);{q3}
    if jsn.has('asNeededCodeableConcept') {a4} then
      result.asNeeded := ParseCodeableConcept(jsn.vObj['asNeededCodeableConcept']);
    if jsn.has('asNeededBoolean') or jsn.has('_asNeededBoolean') then
      result.asNeeded := ParseBoolean(jsn.node['asNeededBoolean'], jsn.vObj['_asNeededBoolean']);
    if jsn.has('siteCodeableConcept') {a4} then
      result.site := ParseCodeableConcept(jsn.vObj['siteCodeableConcept']);
    if jsn.has('siteReference') {a3} then
      result.site := ParseReference(jsn.vObj['siteReference']);
    if jsn.has('route') then
        result.route := ParseCodeableConcept(jsn.vObj['route']);{q3}
    if jsn.has('method') then
        result.method := ParseCodeableConcept(jsn.vObj['method']);{q3}
    if jsn.has('doseRange') {a4} then
      result.dose := ParseRange(jsn.vObj['doseRange']);
    if jsn.has('doseQuantity') {a4} then
      result.dose := ParseQuantity(jsn.vObj['doseQuantity']);
    if jsn.has('rateRatio') {a4} then
      result.rate := ParseRatio(jsn.vObj['rateRatio']);
    if jsn.has('rateRange') {a4} then
      result.rate := ParseRange(jsn.vObj['rateRange']);
    if jsn.has('maxDosePerPeriod') then
        result.maxDosePerPeriod := ParseRatio(jsn.vObj['maxDosePerPeriod']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMedicationOrderDosageInstruction(json : TJSONWriter; name : string; elem : TFhirMedicationOrderDosageInstruction; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'additionalInstructions', elem.additionalInstructions); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTiming(json, 'timing', elem.timing); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
    ComposeBooleanProps(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'siteCodeableConcept', TFhirCodeableConcept(elem.site)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirReference) then
    ComposeReference(json, 'siteReference', TFhirReference(elem.site));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'route', elem.route); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'method', elem.method); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.dose is TFhirRange) then 
    ComposeRange(json, 'doseRange', TFhirRange(elem.dose)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.dose is TFhirQuantity) then 
    ComposeQuantity(json, 'doseQuantity', TFhirQuantity(elem.dose)) ;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRatio) then 
    ComposeRatio(json, 'rateRatio', TFhirRatio(elem.rate)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRange) then 
    ComposeRange(json, 'rateRange', TFhirRange(elem.rate)) ;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(json, 'maxDosePerPeriod', elem.maxDosePerPeriod); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseMedicationOrderDispenseRequest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationOrderDispenseRequest(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationOrderDispenseRequest(jsn : TJsonObject) : TFhirMedicationOrderDispenseRequest;
begin
  result := TFhirMedicationOrderDispenseRequest.create;
  try
    ParseMedicationOrderDispenseRequestProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationOrderDispenseRequestProperties(jsn : TJsonObject; result : TFhirMedicationOrderDispenseRequest);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('medicationCodeableConcept') {a4} then
      result.medication := ParseCodeableConcept(jsn.vObj['medicationCodeableConcept']);
    if jsn.has('medicationReference') {a3} then
      result.medication := ParseReference(jsn.vObj['medicationReference']);
    if jsn.has('validityPeriod') then
        result.validityPeriod := ParsePeriod(jsn.vObj['validityPeriod']);{q3}
    if jsn.has('numberOfRepeatsAllowed') or jsn.has('_numberOfRepeatsAllowed') then
        result.numberOfRepeatsAllowedElement := ParsePositiveInt(jsn.node['numberOfRepeatsAllowed'], jsn.vObj['_numberOfRepeatsAllowed']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
    if jsn.has('expectedSupplyDuration') then
        result.expectedSupplyDuration := ParseQuantity(jsn.vObj['expectedSupplyDuration']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMedicationOrderDispenseRequest(json : TJSONWriter; name : string; elem : TFhirMedicationOrderDispenseRequest; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.medication is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.medication is TFhirReference) then
    ComposeReference(json, 'medicationReference', TFhirReference(elem.medication));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(json, 'validityPeriod', elem.validityPeriod); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntValue(json, 'numberOfRepeatsAllowed', elem.numberOfRepeatsAllowedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveIntProps(json, 'numberOfRepeatsAllowed', elem.numberOfRepeatsAllowedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'expectedSupplyDuration', elem.expectedSupplyDuration); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseMedicationOrderSubstitution(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationOrderSubstitution(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationOrderSubstitution(jsn : TJsonObject) : TFhirMedicationOrderSubstitution;
begin
  result := TFhirMedicationOrderSubstitution.create;
  try
    ParseMedicationOrderSubstitutionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationOrderSubstitutionProperties(jsn : TJsonObject; result : TFhirMedicationOrderSubstitution);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('reason') then
        result.reason := ParseCodeableConcept(jsn.vObj['reason']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMedicationOrderSubstitution(json : TJSONWriter; name : string; elem : TFhirMedicationOrderSubstitution; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'reason', elem.reason); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseMedicationOrder(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationOrder(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationOrder(jsn : TJsonObject) : TFhirMedicationOrder;
begin
  result := TFhirMedicationOrder.create;
  try
    ParseMedicationOrderProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationOrderProperties(jsn : TJsonObject; result : TFhirMedicationOrder);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('dateWritten') or jsn.has('_dateWritten') then
        result.dateWrittenElement := ParseDateTime(jsn.node['dateWritten'], jsn.vObj['_dateWritten']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirMedicationOrderStatusEnum, SYSTEMS_TFhirMedicationOrderStatusEnum);
    if jsn.has('dateEnded') or jsn.has('_dateEnded') then
        result.dateEndedElement := ParseDateTime(jsn.node['dateEnded'], jsn.vObj['_dateEnded']);{q}
    if jsn.has('reasonEnded') then
        result.reasonEnded := ParseCodeableConcept(jsn.vObj['reasonEnded']);{q3}
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
    if jsn.has('prescriber') then
        result.prescriber := ParseReference{TFhirPractitioner}(jsn.vObj['prescriber']);{q3}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('reasonCodeableConcept') {a4} then
      result.reason := ParseCodeableConcept(jsn.vObj['reasonCodeableConcept']);
    if jsn.has('reasonReference') {a3} then
      result.reason := ParseReference(jsn.vObj['reasonReference']);
    if jsn.has('note') or jsn.has('_note') then
        result.noteElement := ParseString(jsn.node['note'], jsn.vObj['_note']);{q}
    if jsn.has('medicationCodeableConcept') {a4} then
      result.medication := ParseCodeableConcept(jsn.vObj['medicationCodeableConcept']);
    if jsn.has('medicationReference') {a3} then
      result.medication := ParseReference(jsn.vObj['medicationReference']);
    if jsn.has('dosageInstruction') then
      iterateArray(jsn.vArr['dosageInstruction'], result.dosageInstructionList, parseMedicationOrderDosageInstruction);
    if jsn.has('dispenseRequest') then
        result.dispenseRequest := ParseMedicationOrderDispenseRequest(jsn.vObj['dispenseRequest']);{q3}
    if jsn.has('substitution') then
        result.substitution := ParseMedicationOrderSubstitution(jsn.vObj['substitution']);{q3}
    if jsn.has('priorPrescription') then
        result.priorPrescription := ParseReference{TFhirMedicationOrder}(jsn.vObj['priorPrescription']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMedicationOrder(json : TJSONWriter; name : string; elem : TFhirMedicationOrder; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dateWritten') then
    ComposeDateTimeValue(json, 'dateWritten', elem.dateWrittenElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dateWritten') then
    ComposeDateTimeProps(json, 'dateWritten', elem.dateWrittenElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirMedicationOrderStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirMedicationOrderStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dateEnded') then
    ComposeDateTimeValue(json, 'dateEnded', elem.dateEndedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dateEnded') then
    ComposeDateTimeProps(json, 'dateEnded', elem.dateEndedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonEnded') then
    ComposeCodeableConcept(json, 'reasonEnded', elem.reasonEnded); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('prescriber') then
    ComposeReference{TFhirPractitioner}(json, 'prescriber', elem.prescriber); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirReference) then
    ComposeReference(json, 'reasonReference', TFhirReference(elem.reason));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('note') then
    ComposeStringValue(json, 'note', elem.noteElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('note') then
    ComposeStringProps(json, 'note', elem.noteElement, false);
  if (elem.medication is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication)) 
  else if (elem.medication is TFhirReference) then
    ComposeReference(json, 'medicationReference', TFhirReference(elem.medication));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dosageInstruction') and (elem.dosageInstructionList.Count > 0) then
  begin
    startArray(json, 'dosageInstruction', elem.dosageInstructionList, false);
    for i := 0 to elem.dosageInstructionList.Count - 1 do
      ComposeMedicationOrderDosageInstruction(json, '', elem.dosageInstructionList[i]); {z - }
    finishArray(json, elem.dosageInstructionList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dispenseRequest') then
    ComposeMedicationOrderDispenseRequest(json, 'dispenseRequest', elem.dispenseRequest); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('substitution') then
    ComposeMedicationOrderSubstitution(json, 'substitution', elem.substitution); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priorPrescription') then
    ComposeReference{TFhirMedicationOrder}(json, 'priorPrescription', elem.priorPrescription); {a}
end;

{$ENDIF FHIR_MEDICATIONORDER}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
procedure TFHIRJsonParser.ParseMedicationStatementDosage(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationStatementDosage(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationStatementDosage(jsn : TJsonObject) : TFhirMedicationStatementDosage;
begin
  result := TFhirMedicationStatementDosage.create;
  try
    ParseMedicationStatementDosageProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationStatementDosageProperties(jsn : TJsonObject; result : TFhirMedicationStatementDosage);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn.node['text'], jsn.vObj['_text']);{q}
    if jsn.has('timing') then
        result.timing := ParseTiming(jsn.vObj['timing']);{q3}
    if jsn.has('asNeededCodeableConcept') {a4} then
      result.asNeeded := ParseCodeableConcept(jsn.vObj['asNeededCodeableConcept']);
    if jsn.has('asNeededBoolean') or jsn.has('_asNeededBoolean') then
      result.asNeeded := ParseBoolean(jsn.node['asNeededBoolean'], jsn.vObj['_asNeededBoolean']);
    if jsn.has('siteCodeableConcept') {a4} then
      result.site := ParseCodeableConcept(jsn.vObj['siteCodeableConcept']);
    if jsn.has('siteReference') {a3} then
      result.site := ParseReference(jsn.vObj['siteReference']);
    if jsn.has('route') then
        result.route := ParseCodeableConcept(jsn.vObj['route']);{q3}
    if jsn.has('method') then
        result.method := ParseCodeableConcept(jsn.vObj['method']);{q3}
    if jsn.has('quantityQuantity') {a4} then
      result.quantity := ParseQuantity(jsn.vObj['quantityQuantity']);
    if jsn.has('quantityRange') {a4} then
      result.quantity := ParseRange(jsn.vObj['quantityRange']);
    if jsn.has('rateRatio') {a4} then
      result.rate := ParseRatio(jsn.vObj['rateRatio']);
    if jsn.has('rateRange') {a4} then
      result.rate := ParseRange(jsn.vObj['rateRange']);
    if jsn.has('maxDosePerPeriod') then
        result.maxDosePerPeriod := ParseRatio(jsn.vObj['maxDosePerPeriod']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMedicationStatementDosage(json : TJSONWriter; name : string; elem : TFhirMedicationStatementDosage; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTiming(json, 'timing', elem.timing); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
    ComposeBooleanProps(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'siteCodeableConcept', TFhirCodeableConcept(elem.site)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirReference) then
    ComposeReference(json, 'siteReference', TFhirReference(elem.site));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'route', elem.route); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'method', elem.method); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.quantity is TFhirQuantity) then 
    ComposeQuantity(json, 'quantityQuantity', TFhirQuantity(elem.quantity)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.quantity is TFhirRange) then 
    ComposeRange(json, 'quantityRange', TFhirRange(elem.quantity)) ;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRatio) then 
    ComposeRatio(json, 'rateRatio', TFhirRatio(elem.rate)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRange) then 
    ComposeRange(json, 'rateRange', TFhirRange(elem.rate)) ;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(json, 'maxDosePerPeriod', elem.maxDosePerPeriod); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseMedicationStatement(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMedicationStatement(jsn)); {2}
end;

function TFHIRJsonParser.ParseMedicationStatement(jsn : TJsonObject) : TFhirMedicationStatement;
begin
  result := TFhirMedicationStatement.create;
  try
    ParseMedicationStatementProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMedicationStatementProperties(jsn : TJsonObject; result : TFhirMedicationStatement);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
    if jsn.has('informationSource') then
        result.informationSource := ParseReference{Resource}(jsn.vObj['informationSource']);{q3}
    if jsn.has('dateAsserted') or jsn.has('_dateAsserted') then
        result.dateAssertedElement := ParseDateTime(jsn.node['dateAsserted'], jsn.vObj['_dateAsserted']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirMedicationStatementStatusEnum, SYSTEMS_TFhirMedicationStatementStatusEnum);
    if jsn.has('wasNotTaken') or jsn.has('_wasNotTaken') then
        result.wasNotTakenElement := ParseBoolean(jsn.node['wasNotTaken'], jsn.vObj['_wasNotTaken']);{q}
    if jsn.has('reasonNotTaken') then
      iterateArray(jsn.vArr['reasonNotTaken'], result.reasonNotTakenList, parseCodeableConcept);
    if jsn.has('reasonForUseCodeableConcept') {a4} then
      result.reasonForUse := ParseCodeableConcept(jsn.vObj['reasonForUseCodeableConcept']);
    if jsn.has('reasonForUseReference') {a3} then
      result.reasonForUse := ParseReference(jsn.vObj['reasonForUseReference']);
    if jsn.has('effectivePeriod') {a4} then
      result.effective := ParsePeriod(jsn.vObj['effectivePeriod']);
    if jsn.has('effectiveDateTime') or jsn.has('_effectiveDateTime') then
      result.effective := ParseDateTime(jsn.node['effectiveDateTime'], jsn.vObj['_effectiveDateTime']);
    if jsn.has('note') or jsn.has('_note') then
        result.noteElement := ParseString(jsn.node['note'], jsn.vObj['_note']);{q}
    if jsn.has('supportingInformation') then
      iterateArray(jsn.vArr['supportingInformation'], result.supportingInformationList, parseReference{TFhirReference});
    if jsn.has('medicationCodeableConcept') {a4} then
      result.medication := ParseCodeableConcept(jsn.vObj['medicationCodeableConcept']);
    if jsn.has('medicationReference') {a3} then
      result.medication := ParseReference(jsn.vObj['medicationReference']);
    if jsn.has('dosage') then
      iterateArray(jsn.vArr['dosage'], result.dosageList, parseMedicationStatementDosage);
end;

procedure TFHIRJsonComposer.ComposeMedicationStatement(json : TJSONWriter; name : string; elem : TFhirMedicationStatement; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('informationSource') then
    ComposeReference{Resource}(json, 'informationSource', elem.informationSource); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dateAsserted') then
    ComposeDateTimeValue(json, 'dateAsserted', elem.dateAssertedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dateAsserted') then
    ComposeDateTimeProps(json, 'dateAsserted', elem.dateAssertedElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirMedicationStatementStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirMedicationStatementStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('wasNotTaken') then
    ComposeBooleanValue(json, 'wasNotTaken', elem.wasNotTakenElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('wasNotTaken') then
    ComposeBooleanProps(json, 'wasNotTaken', elem.wasNotTakenElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonNotTaken') and (elem.reasonNotTakenList.Count > 0) then
  begin
    startArray(json, 'reasonNotTaken', elem.reasonNotTakenList, false);
    for i := 0 to elem.reasonNotTakenList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonNotTakenList[i]); {z - CodeableConcept}
    finishArray(json, elem.reasonNotTakenList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reasonForUse is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'reasonForUseCodeableConcept', TFhirCodeableConcept(elem.reasonForUse)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reasonForUse is TFhirReference) then
    ComposeReference(json, 'reasonForUseReference', TFhirReference(elem.reasonForUse));
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirPeriod) then 
    ComposePeriod(json, 'effectivePeriod', TFhirPeriod(elem.effective)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'effectiveDateTime', TFhirDateTime(elem.effective), false);
    ComposeDateTimeProps(json, 'effectiveDateTime', TFhirDateTime(elem.effective), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('note') then
    ComposeStringValue(json, 'note', elem.noteElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('note') then
    ComposeStringProps(json, 'note', elem.noteElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('supportingInformation') and (elem.supportingInformationList.Count > 0) then
  begin
    startArray(json, 'supportingInformation', elem.supportingInformationList, false);
    for i := 0 to elem.supportingInformationList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.supportingInformationList[i]); {z - Reference(Any)}
    finishArray(json, elem.supportingInformationList);
  end;
  if (elem.medication is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication)) 
  else if (elem.medication is TFhirReference) then
    ComposeReference(json, 'medicationReference', TFhirReference(elem.medication));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dosage') and (elem.dosageList.Count > 0) then
  begin
    startArray(json, 'dosage', elem.dosageList, false);
    for i := 0 to elem.dosageList.Count - 1 do
      ComposeMedicationStatementDosage(json, '', elem.dosageList[i]); {z - }
    finishArray(json, elem.dosageList);
  end;
end;

{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MESSAGEHEADER}
procedure TFHIRJsonParser.ParseMessageHeaderResponse(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMessageHeaderResponse(jsn)); {2}
end;

function TFHIRJsonParser.ParseMessageHeaderResponse(jsn : TJsonObject) : TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse.create;
  try
    ParseMessageHeaderResponseProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMessageHeaderResponseProperties(jsn : TJsonObject; result : TFhirMessageHeaderResponse);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') or jsn.has('_identifier') then
        result.identifierElement := ParseId(jsn.node['identifier'], jsn.vObj['_identifier']);{q}
    if jsn.has('code') or jsn.has('_code')  then
      result.codeElement := parseEnum(jsn.path+'/code', jsn.node['code'], jsn.vObj['_code'], CODES_TFhirResponseCodeEnum, SYSTEMS_TFhirResponseCodeEnum);
    if jsn.has('details') then
        result.details := ParseReference{TFhirOperationOutcome}(jsn.vObj['details']);{q3}
end;

procedure TFHIRJsonComposer.ComposeMessageHeaderResponse(json : TJSONWriter; name : string; elem : TFhirMessageHeaderResponse; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdValue(json, 'identifier', elem.identifierElement, false);
  ComposeIdProps(json, 'identifier', elem.identifierElement, false);
  ComposeEnumValue(json, 'code', elem.CodeElement, CODES_TFhirResponseCodeEnum, false);
  ComposeEnumProps(json, 'code', elem.CodeElement, CODES_TFhirResponseCodeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOperationOutcome}(json, 'details', elem.details); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseMessageHeaderSource(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMessageHeaderSource(jsn)); {2}
end;

function TFHIRJsonParser.ParseMessageHeaderSource(jsn : TJsonObject) : TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource.create;
  try
    ParseMessageHeaderSourceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMessageHeaderSourceProperties(jsn : TJsonObject; result : TFhirMessageHeaderSource);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('software') or jsn.has('_software') then
        result.softwareElement := ParseString(jsn.node['software'], jsn.vObj['_software']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('contact') then
        result.contact := ParseContactPoint(jsn.vObj['contact']);{q3}
    if jsn.has('endpoint') or jsn.has('_endpoint') then
        result.endpointElement := ParseUri(jsn.node['endpoint'], jsn.vObj['_endpoint']);{q}
end;

procedure TFHIRJsonComposer.ComposeMessageHeaderSource(json : TJSONWriter; name : string; elem : TFhirMessageHeaderSource; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'software', elem.softwareElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'software', elem.softwareElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeContactPoint(json, 'contact', elem.contact); {a}
  ComposeUriValue(json, 'endpoint', elem.endpointElement, false);
  ComposeUriProps(json, 'endpoint', elem.endpointElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseMessageHeaderDestination(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMessageHeaderDestination(jsn)); {2}
end;

function TFHIRJsonParser.ParseMessageHeaderDestination(jsn : TJsonObject) : TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination.create;
  try
    ParseMessageHeaderDestinationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMessageHeaderDestinationProperties(jsn : TJsonObject; result : TFhirMessageHeaderDestination);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('target') then
        result.target := ParseReference{TFhirDevice}(jsn.vObj['target']);{q3}
    if jsn.has('endpoint') or jsn.has('_endpoint') then
        result.endpointElement := ParseUri(jsn.node['endpoint'], jsn.vObj['_endpoint']);{q}
end;

procedure TFHIRJsonComposer.ComposeMessageHeaderDestination(json : TJSONWriter; name : string; elem : TFhirMessageHeaderDestination; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirDevice}(json, 'target', elem.target); {a}
  ComposeUriValue(json, 'endpoint', elem.endpointElement, false);
  ComposeUriProps(json, 'endpoint', elem.endpointElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseMessageHeader(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseMessageHeader(jsn)); {2}
end;

function TFHIRJsonParser.ParseMessageHeader(jsn : TJsonObject) : TFhirMessageHeader;
begin
  result := TFhirMessageHeader.create;
  try
    ParseMessageHeaderProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseMessageHeaderProperties(jsn : TJsonObject; result : TFhirMessageHeader);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('timestamp') or jsn.has('_timestamp') then
        result.timestampElement := ParseInstant(jsn.node['timestamp'], jsn.vObj['_timestamp']);{q}
    if jsn.has('event') then
        result.event := ParseCoding(jsn.vObj['event']);{q3}
    if jsn.has('response') then
        result.response := ParseMessageHeaderResponse(jsn.vObj['response']);{q3}
    if jsn.has('source') then
        result.source := ParseMessageHeaderSource(jsn.vObj['source']);{q3}
    if jsn.has('destination') then
      iterateArray(jsn.vArr['destination'], result.destinationList, parseMessageHeaderDestination);
    if jsn.has('enterer') then
        result.enterer := ParseReference{TFhirPractitioner}(jsn.vObj['enterer']);{q3}
    if jsn.has('author') then
        result.author := ParseReference{TFhirPractitioner}(jsn.vObj['author']);{q3}
    if jsn.has('receiver') then
        result.receiver := ParseReference{Resource}(jsn.vObj['receiver']);{q3}
    if jsn.has('responsible') then
        result.responsible := ParseReference{Resource}(jsn.vObj['responsible']);{q3}
    if jsn.has('reason') then
        result.reason := ParseCodeableConcept(jsn.vObj['reason']);{q3}
    if jsn.has('data') then
      iterateArray(jsn.vArr['data'], result.dataList, parseReference{TFhirReference});
end;

procedure TFHIRJsonComposer.ComposeMessageHeader(json : TJSONWriter; name : string; elem : TFhirMessageHeader; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeInstantValue(json, 'timestamp', elem.timestampElement, false);
  ComposeInstantProps(json, 'timestamp', elem.timestampElement, false);
  ComposeCoding(json, 'event', elem.event); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('response') then
    ComposeMessageHeaderResponse(json, 'response', elem.response); {a}
  ComposeMessageHeaderSource(json, 'source', elem.source); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('destination') and (elem.destinationList.Count > 0) then
  begin
    startArray(json, 'destination', elem.destinationList, false);
    for i := 0 to elem.destinationList.Count - 1 do
      ComposeMessageHeaderDestination(json, '', elem.destinationList[i]); {z - }
    finishArray(json, elem.destinationList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('enterer') then
    ComposeReference{TFhirPractitioner}(json, 'enterer', elem.enterer); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{TFhirPractitioner}(json, 'author', elem.author); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('receiver') then
    ComposeReference{Resource}(json, 'receiver', elem.receiver); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('responsible') then
    ComposeReference{Resource}(json, 'responsible', elem.responsible); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reason') then
    ComposeCodeableConcept(json, 'reason', elem.reason); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('data') and (elem.dataList.Count > 0) then
  begin
    startArray(json, 'data', elem.dataList, false);
    for i := 0 to elem.dataList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.dataList[i]); {z - Reference(Any)}
    finishArray(json, elem.dataList);
  end;
end;

{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_NAMINGSYSTEM}
procedure TFHIRJsonParser.ParseNamingSystemContact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNamingSystemContact(jsn)); {2}
end;

function TFHIRJsonParser.ParseNamingSystemContact(jsn : TJsonObject) : TFhirNamingSystemContact;
begin
  result := TFhirNamingSystemContact.create;
  try
    ParseNamingSystemContactProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseNamingSystemContactProperties(jsn : TJsonObject; result : TFhirNamingSystemContact);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
end;

procedure TFHIRJsonComposer.ComposeNamingSystemContact(json : TJSONWriter; name : string; elem : TFhirNamingSystemContact; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.telecomList.Count > 0) then
  begin
    startArray(json, 'telecom', elem.telecomList, false);
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    finishArray(json, elem.telecomList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseNamingSystemUniqueId(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNamingSystemUniqueId(jsn)); {2}
end;

function TFHIRJsonParser.ParseNamingSystemUniqueId(jsn : TJsonObject) : TFhirNamingSystemUniqueId;
begin
  result := TFhirNamingSystemUniqueId.create;
  try
    ParseNamingSystemUniqueIdProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseNamingSystemUniqueIdProperties(jsn : TJsonObject; result : TFhirNamingSystemUniqueId);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirNamingsystemIdentifierTypeEnum, SYSTEMS_TFhirNamingsystemIdentifierTypeEnum);
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := ParseString(jsn.node['value'], jsn.vObj['_value']);{q}
    if jsn.has('preferred') or jsn.has('_preferred') then
        result.preferredElement := ParseBoolean(jsn.node['preferred'], jsn.vObj['_preferred']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
end;

procedure TFHIRJsonComposer.ComposeNamingSystemUniqueId(json : TJSONWriter; name : string; elem : TFhirNamingSystemUniqueId; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirNamingsystemIdentifierTypeEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirNamingsystemIdentifierTypeEnum, false);
  ComposeStringValue(json, 'value', elem.valueElement, false);
  ComposeStringProps(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'preferred', elem.preferredElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'preferred', elem.preferredElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseNamingSystem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNamingSystem(jsn)); {2}
end;

function TFHIRJsonParser.ParseNamingSystem(jsn : TJsonObject) : TFhirNamingSystem;
begin
  result := TFhirNamingSystem.create;
  try
    ParseNamingSystemProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseNamingSystemProperties(jsn : TJsonObject; result : TFhirNamingSystem);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum);
    if jsn.has('kind') or jsn.has('_kind')  then
      result.kindElement := parseEnum(jsn.path+'/kind', jsn.node['kind'], jsn.vObj['_kind'], CODES_TFhirNamingsystemTypeEnum, SYSTEMS_TFhirNamingsystemTypeEnum);
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := ParseString(jsn.node['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseNamingSystemContact);
    if jsn.has('responsible') or jsn.has('_responsible') then
        result.responsibleElement := ParseString(jsn.node['responsible'], jsn.vObj['_responsible']);{q}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseCodeableConcept);
    if jsn.has('usage') or jsn.has('_usage') then
        result.usageElement := ParseString(jsn.node['usage'], jsn.vObj['_usage']);{q}
    if jsn.has('uniqueId') then
      iterateArray(jsn.vArr['uniqueId'], result.uniqueIdList, parseNamingSystemUniqueId);
    if jsn.has('replacedBy') then
        result.replacedBy := ParseReference{TFhirNamingSystem}(jsn.vObj['replacedBy']);{q3}
end;

procedure TFHIRJsonComposer.ComposeNamingSystem(json : TJSONWriter; name : string; elem : TFhirNamingSystem; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, false);
  ComposeEnumValue(json, 'kind', elem.KindElement, CODES_TFhirNamingsystemTypeEnum, false);
  ComposeEnumProps(json, 'kind', elem.KindElement, CODES_TFhirNamingsystemTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    startArray(json, 'contact', elem.contactList, false);
    for i := 0 to elem.contactList.Count - 1 do
      ComposeNamingSystemContact(json, '', elem.contactList[i]); {z - }
    finishArray(json, elem.contactList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('responsible') then
    ComposeStringValue(json, 'responsible', elem.responsibleElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('responsible') then
    ComposeStringProps(json, 'responsible', elem.responsibleElement, false);
  ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('type_') then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') and (elem.useContextList.Count > 0) then
  begin
    startArray(json, 'useContext', elem.useContextList, false);
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.useContextList[i]); {z - CodeableConcept}
    finishArray(json, elem.useContextList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('usage') then
    ComposeStringValue(json, 'usage', elem.usageElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('usage') then
    ComposeStringProps(json, 'usage', elem.usageElement, false);
  if (elem.uniqueIdList.Count > 0) then
  begin
    startArray(json, 'uniqueId', elem.uniqueIdList, false);
    for i := 0 to elem.uniqueIdList.Count - 1 do
      ComposeNamingSystemUniqueId(json, '', elem.uniqueIdList[i]); {z - }
    finishArray(json, elem.uniqueIdList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('replacedBy') then
    ComposeReference{TFhirNamingSystem}(json, 'replacedBy', elem.replacedBy); {a}
end;

{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
procedure TFHIRJsonParser.ParseNutritionOrderOralDiet(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNutritionOrderOralDiet(jsn)); {2}
end;

function TFHIRJsonParser.ParseNutritionOrderOralDiet(jsn : TJsonObject) : TFhirNutritionOrderOralDiet;
begin
  result := TFhirNutritionOrderOralDiet.create;
  try
    ParseNutritionOrderOralDietProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseNutritionOrderOralDietProperties(jsn : TJsonObject; result : TFhirNutritionOrderOralDiet);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCodeableConcept);
    if jsn.has('schedule') then
      iterateArray(jsn.vArr['schedule'], result.scheduleList, parseTiming);
    if jsn.has('nutrient') then
      iterateArray(jsn.vArr['nutrient'], result.nutrientList, parseNutritionOrderOralDietNutrient);
    if jsn.has('texture') then
      iterateArray(jsn.vArr['texture'], result.textureList, parseNutritionOrderOralDietTexture);
    if jsn.has('fluidConsistencyType') then
      iterateArray(jsn.vArr['fluidConsistencyType'], result.fluidConsistencyTypeList, parseCodeableConcept);
    if jsn.has('instruction') or jsn.has('_instruction') then
        result.instructionElement := ParseString(jsn.node['instruction'], jsn.vObj['_instruction']);{q}
end;

procedure TFHIRJsonComposer.ComposeNutritionOrderOralDiet(json : TJSONWriter; name : string; elem : TFhirNutritionOrderOralDiet; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.type_List.Count > 0) then
  begin
    startArray(json, 'type', elem.type_List, false);
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(json, '', elem.type_List[i]); {z - CodeableConcept}
    finishArray(json, elem.type_List);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.scheduleList.Count > 0) then
  begin
    startArray(json, 'schedule', elem.scheduleList, false);
    for i := 0 to elem.scheduleList.Count - 1 do
      ComposeTiming(json, '', elem.scheduleList[i]); {z - Timing}
    finishArray(json, elem.scheduleList);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.nutrientList.Count > 0) then
  begin
    startArray(json, 'nutrient', elem.nutrientList, false);
    for i := 0 to elem.nutrientList.Count - 1 do
      ComposeNutritionOrderOralDietNutrient(json, '', elem.nutrientList[i]); {z - }
    finishArray(json, elem.nutrientList);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.textureList.Count > 0) then
  begin
    startArray(json, 'texture', elem.textureList, false);
    for i := 0 to elem.textureList.Count - 1 do
      ComposeNutritionOrderOralDietTexture(json, '', elem.textureList[i]); {z - }
    finishArray(json, elem.textureList);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.fluidConsistencyTypeList.Count > 0) then
  begin
    startArray(json, 'fluidConsistencyType', elem.fluidConsistencyTypeList, false);
    for i := 0 to elem.fluidConsistencyTypeList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.fluidConsistencyTypeList[i]); {z - CodeableConcept}
    finishArray(json, elem.fluidConsistencyTypeList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'instruction', elem.instructionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'instruction', elem.instructionElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseNutritionOrderOralDietNutrient(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNutritionOrderOralDietNutrient(jsn)); {2}
end;

function TFHIRJsonParser.ParseNutritionOrderOralDietNutrient(jsn : TJsonObject) : TFhirNutritionOrderOralDietNutrient;
begin
  result := TFhirNutritionOrderOralDietNutrient.create;
  try
    ParseNutritionOrderOralDietNutrientProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseNutritionOrderOralDietNutrientProperties(jsn : TJsonObject; result : TFhirNutritionOrderOralDietNutrient);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('modifier') then
        result.modifier := ParseCodeableConcept(jsn.vObj['modifier']);{q3}
    if jsn.has('amount') then
        result.amount := ParseQuantity(jsn.vObj['amount']);{q3}
end;

procedure TFHIRJsonComposer.ComposeNutritionOrderOralDietNutrient(json : TJSONWriter; name : string; elem : TFhirNutritionOrderOralDietNutrient; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'modifier', elem.modifier); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'amount', elem.amount); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseNutritionOrderOralDietTexture(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNutritionOrderOralDietTexture(jsn)); {2}
end;

function TFHIRJsonParser.ParseNutritionOrderOralDietTexture(jsn : TJsonObject) : TFhirNutritionOrderOralDietTexture;
begin
  result := TFhirNutritionOrderOralDietTexture.create;
  try
    ParseNutritionOrderOralDietTextureProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseNutritionOrderOralDietTextureProperties(jsn : TJsonObject; result : TFhirNutritionOrderOralDietTexture);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('modifier') then
        result.modifier := ParseCodeableConcept(jsn.vObj['modifier']);{q3}
    if jsn.has('foodType') then
        result.foodType := ParseCodeableConcept(jsn.vObj['foodType']);{q3}
end;

procedure TFHIRJsonComposer.ComposeNutritionOrderOralDietTexture(json : TJSONWriter; name : string; elem : TFhirNutritionOrderOralDietTexture; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'modifier', elem.modifier); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'foodType', elem.foodType); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseNutritionOrderSupplement(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNutritionOrderSupplement(jsn)); {2}
end;

function TFHIRJsonParser.ParseNutritionOrderSupplement(jsn : TJsonObject) : TFhirNutritionOrderSupplement;
begin
  result := TFhirNutritionOrderSupplement.create;
  try
    ParseNutritionOrderSupplementProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseNutritionOrderSupplementProperties(jsn : TJsonObject; result : TFhirNutritionOrderSupplement);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('productName') or jsn.has('_productName') then
        result.productNameElement := ParseString(jsn.node['productName'], jsn.vObj['_productName']);{q}
    if jsn.has('schedule') then
      iterateArray(jsn.vArr['schedule'], result.scheduleList, parseTiming);
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
    if jsn.has('instruction') or jsn.has('_instruction') then
        result.instructionElement := ParseString(jsn.node['instruction'], jsn.vObj['_instruction']);{q}
end;

procedure TFHIRJsonComposer.ComposeNutritionOrderSupplement(json : TJSONWriter; name : string; elem : TFhirNutritionOrderSupplement; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'productName', elem.productNameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'productName', elem.productNameElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.scheduleList.Count > 0) then
  begin
    startArray(json, 'schedule', elem.scheduleList, false);
    for i := 0 to elem.scheduleList.Count - 1 do
      ComposeTiming(json, '', elem.scheduleList[i]); {z - Timing}
    finishArray(json, elem.scheduleList);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'instruction', elem.instructionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'instruction', elem.instructionElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseNutritionOrderEnteralFormula(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNutritionOrderEnteralFormula(jsn)); {2}
end;

function TFHIRJsonParser.ParseNutritionOrderEnteralFormula(jsn : TJsonObject) : TFhirNutritionOrderEnteralFormula;
begin
  result := TFhirNutritionOrderEnteralFormula.create;
  try
    ParseNutritionOrderEnteralFormulaProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseNutritionOrderEnteralFormulaProperties(jsn : TJsonObject; result : TFhirNutritionOrderEnteralFormula);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('baseFormulaType') then
        result.baseFormulaType := ParseCodeableConcept(jsn.vObj['baseFormulaType']);{q3}
    if jsn.has('baseFormulaProductName') or jsn.has('_baseFormulaProductName') then
        result.baseFormulaProductNameElement := ParseString(jsn.node['baseFormulaProductName'], jsn.vObj['_baseFormulaProductName']);{q}
    if jsn.has('additiveType') then
        result.additiveType := ParseCodeableConcept(jsn.vObj['additiveType']);{q3}
    if jsn.has('additiveProductName') or jsn.has('_additiveProductName') then
        result.additiveProductNameElement := ParseString(jsn.node['additiveProductName'], jsn.vObj['_additiveProductName']);{q}
    if jsn.has('caloricDensity') then
        result.caloricDensity := ParseQuantity(jsn.vObj['caloricDensity']);{q3}
    if jsn.has('routeofAdministration') then
        result.routeofAdministration := ParseCodeableConcept(jsn.vObj['routeofAdministration']);{q3}
    if jsn.has('administration') then
      iterateArray(jsn.vArr['administration'], result.administrationList, parseNutritionOrderEnteralFormulaAdministration);
    if jsn.has('maxVolumeToDeliver') then
        result.maxVolumeToDeliver := ParseQuantity(jsn.vObj['maxVolumeToDeliver']);{q3}
    if jsn.has('administrationInstruction') or jsn.has('_administrationInstruction') then
        result.administrationInstructionElement := ParseString(jsn.node['administrationInstruction'], jsn.vObj['_administrationInstruction']);{q}
end;

procedure TFHIRJsonComposer.ComposeNutritionOrderEnteralFormula(json : TJSONWriter; name : string; elem : TFhirNutritionOrderEnteralFormula; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'baseFormulaType', elem.baseFormulaType); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'baseFormulaProductName', elem.baseFormulaProductNameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'baseFormulaProductName', elem.baseFormulaProductNameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'additiveType', elem.additiveType); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'additiveProductName', elem.additiveProductNameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'additiveProductName', elem.additiveProductNameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'caloricDensity', elem.caloricDensity); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'routeofAdministration', elem.routeofAdministration); {a}
  if (SummaryOption in [soFull, soData]) and (elem.administrationList.Count > 0) then
  begin
    startArray(json, 'administration', elem.administrationList, false);
    for i := 0 to elem.administrationList.Count - 1 do
      ComposeNutritionOrderEnteralFormulaAdministration(json, '', elem.administrationList[i]); {z - }
    finishArray(json, elem.administrationList);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'maxVolumeToDeliver', elem.maxVolumeToDeliver); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'administrationInstruction', elem.administrationInstructionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'administrationInstruction', elem.administrationInstructionElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseNutritionOrderEnteralFormulaAdministration(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNutritionOrderEnteralFormulaAdministration(jsn)); {2}
end;

function TFHIRJsonParser.ParseNutritionOrderEnteralFormulaAdministration(jsn : TJsonObject) : TFhirNutritionOrderEnteralFormulaAdministration;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministration.create;
  try
    ParseNutritionOrderEnteralFormulaAdministrationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseNutritionOrderEnteralFormulaAdministrationProperties(jsn : TJsonObject; result : TFhirNutritionOrderEnteralFormulaAdministration);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('schedule') then
        result.schedule := ParseTiming(jsn.vObj['schedule']);{q3}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
    if jsn.has('rateQuantity') {a4} then
      result.rate := ParseQuantity(jsn.vObj['rateQuantity']);
    if jsn.has('rateRatio') {a4} then
      result.rate := ParseRatio(jsn.vObj['rateRatio']);
end;

procedure TFHIRJsonComposer.ComposeNutritionOrderEnteralFormulaAdministration(json : TJSONWriter; name : string; elem : TFhirNutritionOrderEnteralFormulaAdministration; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeTiming(json, 'schedule', elem.schedule); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soData]) and (elem.rate is TFhirQuantity) then 
    ComposeQuantity(json, 'rateQuantity', TFhirQuantity(elem.rate)) 
  else if (SummaryOption in [soFull, soData]) and (elem.rate is TFhirRatio) then 
    ComposeRatio(json, 'rateRatio', TFhirRatio(elem.rate)) ;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseNutritionOrder(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseNutritionOrder(jsn)); {2}
end;

function TFHIRJsonParser.ParseNutritionOrder(jsn : TJsonObject) : TFhirNutritionOrder;
begin
  result := TFhirNutritionOrder.create;
  try
    ParseNutritionOrderProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseNutritionOrderProperties(jsn : TJsonObject; result : TFhirNutritionOrder);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
    if jsn.has('orderer') then
        result.orderer := ParseReference{TFhirPractitioner}(jsn.vObj['orderer']);{q3}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('dateTime') or jsn.has('_dateTime') then
        result.dateTimeElement := ParseDateTime(jsn.node['dateTime'], jsn.vObj['_dateTime']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirNutritionOrderStatusEnum, SYSTEMS_TFhirNutritionOrderStatusEnum);
    if jsn.has('allergyIntolerance') then
      iterateArray(jsn.vArr['allergyIntolerance'], result.allergyIntoleranceList, parseReference{TFhirAllergyIntolerance});
    if jsn.has('foodPreferenceModifier') then
      iterateArray(jsn.vArr['foodPreferenceModifier'], result.foodPreferenceModifierList, parseCodeableConcept);
    if jsn.has('excludeFoodModifier') then
      iterateArray(jsn.vArr['excludeFoodModifier'], result.excludeFoodModifierList, parseCodeableConcept);
    if jsn.has('oralDiet') then
        result.oralDiet := ParseNutritionOrderOralDiet(jsn.vObj['oralDiet']);{q3}
    if jsn.has('supplement') then
      iterateArray(jsn.vArr['supplement'], result.supplementList, parseNutritionOrderSupplement);
    if jsn.has('enteralFormula') then
        result.enteralFormula := ParseNutritionOrderEnteralFormula(jsn.vObj['enteralFormula']);{q3}
end;

procedure TFHIRJsonComposer.ComposeNutritionOrder(json : TJSONWriter; name : string; elem : TFhirNutritionOrder; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('orderer') then
    ComposeReference{TFhirPractitioner}(json, 'orderer', elem.orderer); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  ComposeDateTimeValue(json, 'dateTime', elem.dateTimeElement, false);
  ComposeDateTimeProps(json, 'dateTime', elem.dateTimeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirNutritionOrderStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirNutritionOrderStatusEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('allergyIntolerance') and (elem.allergyIntoleranceList.Count > 0) then
  begin
    startArray(json, 'allergyIntolerance', elem.allergyIntoleranceList, false);
    for i := 0 to elem.allergyIntoleranceList.Count - 1 do
      ComposeReference{TFhirAllergyIntolerance}(json, '', elem.allergyIntoleranceList[i]); {z - Reference(AllergyIntolerance)}
    finishArray(json, elem.allergyIntoleranceList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('foodPreferenceModifier') and (elem.foodPreferenceModifierList.Count > 0) then
  begin
    startArray(json, 'foodPreferenceModifier', elem.foodPreferenceModifierList, false);
    for i := 0 to elem.foodPreferenceModifierList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.foodPreferenceModifierList[i]); {z - CodeableConcept}
    finishArray(json, elem.foodPreferenceModifierList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('excludeFoodModifier') and (elem.excludeFoodModifierList.Count > 0) then
  begin
    startArray(json, 'excludeFoodModifier', elem.excludeFoodModifierList, false);
    for i := 0 to elem.excludeFoodModifierList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.excludeFoodModifierList[i]); {z - CodeableConcept}
    finishArray(json, elem.excludeFoodModifierList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('oralDiet') then
    ComposeNutritionOrderOralDiet(json, 'oralDiet', elem.oralDiet); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('supplement') and (elem.supplementList.Count > 0) then
  begin
    startArray(json, 'supplement', elem.supplementList, false);
    for i := 0 to elem.supplementList.Count - 1 do
      ComposeNutritionOrderSupplement(json, '', elem.supplementList[i]); {z - }
    finishArray(json, elem.supplementList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('enteralFormula') then
    ComposeNutritionOrderEnteralFormula(json, 'enteralFormula', elem.enteralFormula); {a}
end;

{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
procedure TFHIRJsonParser.ParseObservationReferenceRange(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseObservationReferenceRange(jsn)); {2}
end;

function TFHIRJsonParser.ParseObservationReferenceRange(jsn : TJsonObject) : TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange.create;
  try
    ParseObservationReferenceRangeProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseObservationReferenceRangeProperties(jsn : TJsonObject; result : TFhirObservationReferenceRange);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('low') then
        result.low := ParseQuantity(jsn.vObj['low']);{q3}
    if jsn.has('high') then
        result.high := ParseQuantity(jsn.vObj['high']);{q3}
    if jsn.has('meaning') then
        result.meaning := ParseCodeableConcept(jsn.vObj['meaning']);{q3}
    if jsn.has('age') then
        result.age := ParseRange(jsn.vObj['age']);{q3}
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn.node['text'], jsn.vObj['_text']);{q}
end;

procedure TFHIRJsonComposer.ComposeObservationReferenceRange(json : TJSONWriter; name : string; elem : TFhirObservationReferenceRange; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'low', elem.low); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'high', elem.high); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'meaning', elem.meaning); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeRange(json, 'age', elem.age); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseObservationRelated(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseObservationRelated(jsn)); {2}
end;

function TFHIRJsonParser.ParseObservationRelated(jsn : TJsonObject) : TFhirObservationRelated;
begin
  result := TFhirObservationRelated.create;
  try
    ParseObservationRelatedProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseObservationRelatedProperties(jsn : TJsonObject; result : TFhirObservationRelated);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirObservationRelationshiptypesEnum, SYSTEMS_TFhirObservationRelationshiptypesEnum);
    if jsn.has('target') then
        result.target := ParseReference{Resource}(jsn.vObj['target']);{q3}
end;

procedure TFHIRJsonComposer.ComposeObservationRelated(json : TJSONWriter; name : string; elem : TFhirObservationRelated; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirObservationRelationshiptypesEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirObservationRelationshiptypesEnum, false);
  ComposeReference{Resource}(json, 'target', elem.target); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseObservationComponent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseObservationComponent(jsn)); {2}
end;

function TFHIRJsonParser.ParseObservationComponent(jsn : TJsonObject) : TFhirObservationComponent;
begin
  result := TFhirObservationComponent.create;
  try
    ParseObservationComponentProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseObservationComponentProperties(jsn : TJsonObject; result : TFhirObservationComponent);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('valueQuantity') {a4} then
      result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueCodeableConcept') {a4} then
      result.value := ParseCodeableConcept(jsn.vObj['valueCodeableConcept']);
    if jsn.has('valueRange') {a4} then
      result.value := ParseRange(jsn.vObj['valueRange']);
    if jsn.has('valueRatio') {a4} then
      result.value := ParseRatio(jsn.vObj['valueRatio']);
    if jsn.has('valueSampledData') {a4} then
      result.value := ParseSampledData(jsn.vObj['valueSampledData']);
    if jsn.has('valueAttachment') {a4} then
      result.value := ParseAttachment(jsn.vObj['valueAttachment']);
    if jsn.has('valuePeriod') {a4} then
      result.value := ParsePeriod(jsn.vObj['valuePeriod']);
    if jsn.has('valueString') or jsn.has('_valueString') then
      result.value := ParseString(jsn.node['valueString'], jsn.vObj['_valueString']);
    if jsn.has('valueTime') or jsn.has('_valueTime') then
      result.value := ParseTime(jsn.node['valueTime'], jsn.vObj['_valueTime']);
    if jsn.has('valueDateTime') or jsn.has('_valueDateTime') then
      result.value := ParseDateTime(jsn.node['valueDateTime'], jsn.vObj['_valueDateTime']);
    if jsn.has('dataAbsentReason') then
        result.dataAbsentReason := ParseCodeableConcept(jsn.vObj['dataAbsentReason']);{q3}
    if jsn.has('referenceRange') then
      iterateArray(jsn.vArr['referenceRange'], result.referenceRangeList, parseObservationReferenceRange);
end;

procedure TFHIRJsonComposer.ComposeObservationComponent(json : TJSONWriter; name : string; elem : TFhirObservationComponent; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirQuantity) then 
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'valueCodeableConcept', TFhirCodeableConcept(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirRange) then 
    ComposeRange(json, 'valueRange', TFhirRange(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirRatio) then 
    ComposeRatio(json, 'valueRatio', TFhirRatio(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirSampledData) then 
    ComposeSampledData(json, 'valueSampledData', TFhirSampledData(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirAttachment) then 
    ComposeAttachment(json, 'valueAttachment', TFhirAttachment(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirPeriod) then 
    ComposePeriod(json, 'valuePeriod', TFhirPeriod(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirString) then 
  begin
    ComposeStringValue(json, 'valueString', TFhirString(elem.value), false);
    ComposeStringProps(json, 'valueString', TFhirString(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirTime) then 
  begin
    ComposeTimeValue(json, 'valueTime', TFhirTime(elem.value), false);
    ComposeTimeProps(json, 'valueTime', TFhirTime(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'valueDateTime', TFhirDateTime(elem.value), false);
    ComposeDateTimeProps(json, 'valueDateTime', TFhirDateTime(elem.value), false);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'dataAbsentReason', elem.dataAbsentReason); {a}
  if (SummaryOption in [soFull, soData]) and (elem.referenceRangeList.Count > 0) then
  begin
    startArray(json, 'referenceRange', elem.referenceRangeList, false);
    for i := 0 to elem.referenceRangeList.Count - 1 do
      ComposeObservationReferenceRange(json, '', elem.referenceRangeList[i]); {z - @Observation.referenceRange}
    finishArray(json, elem.referenceRangeList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseObservation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseObservation(jsn)); {2}
end;

function TFHIRJsonParser.ParseObservation(jsn : TJsonObject) : TFhirObservation;
begin
  result := TFhirObservation.create;
  try
    ParseObservationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseObservationProperties(jsn : TJsonObject; result : TFhirObservation);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirObservationStatusEnum, SYSTEMS_TFhirObservationStatusEnum);
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q3}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q3}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('effectivePeriod') {a4} then
      result.effective := ParsePeriod(jsn.vObj['effectivePeriod']);
    if jsn.has('effectiveDateTime') or jsn.has('_effectiveDateTime') then
      result.effective := ParseDateTime(jsn.node['effectiveDateTime'], jsn.vObj['_effectiveDateTime']);
    if jsn.has('issued') or jsn.has('_issued') then
        result.issuedElement := ParseInstant(jsn.node['issued'], jsn.vObj['_issued']);{q}
    if jsn.has('performer') then
      iterateArray(jsn.vArr['performer'], result.performerList, parseReference{Resource});
    if jsn.has('valueQuantity') {a4} then
      result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueCodeableConcept') {a4} then
      result.value := ParseCodeableConcept(jsn.vObj['valueCodeableConcept']);
    if jsn.has('valueRange') {a4} then
      result.value := ParseRange(jsn.vObj['valueRange']);
    if jsn.has('valueRatio') {a4} then
      result.value := ParseRatio(jsn.vObj['valueRatio']);
    if jsn.has('valueSampledData') {a4} then
      result.value := ParseSampledData(jsn.vObj['valueSampledData']);
    if jsn.has('valueAttachment') {a4} then
      result.value := ParseAttachment(jsn.vObj['valueAttachment']);
    if jsn.has('valuePeriod') {a4} then
      result.value := ParsePeriod(jsn.vObj['valuePeriod']);
    if jsn.has('valueString') or jsn.has('_valueString') then
      result.value := ParseString(jsn.node['valueString'], jsn.vObj['_valueString']);
    if jsn.has('valueTime') or jsn.has('_valueTime') then
      result.value := ParseTime(jsn.node['valueTime'], jsn.vObj['_valueTime']);
    if jsn.has('valueDateTime') or jsn.has('_valueDateTime') then
      result.value := ParseDateTime(jsn.node['valueDateTime'], jsn.vObj['_valueDateTime']);
    if jsn.has('dataAbsentReason') then
        result.dataAbsentReason := ParseCodeableConcept(jsn.vObj['dataAbsentReason']);{q3}
    if jsn.has('interpretation') then
        result.interpretation := ParseCodeableConcept(jsn.vObj['interpretation']);{q3}
    if jsn.has('comments') or jsn.has('_comments') then
        result.commentsElement := ParseString(jsn.node['comments'], jsn.vObj['_comments']);{q}
    if jsn.has('bodySite') then
        result.bodySite := ParseCodeableConcept(jsn.vObj['bodySite']);{q3}
    if jsn.has('method') then
        result.method := ParseCodeableConcept(jsn.vObj['method']);{q3}
    if jsn.has('specimen') then
        result.specimen := ParseReference{TFhirSpecimen}(jsn.vObj['specimen']);{q3}
    if jsn.has('device') then
        result.device := ParseReference{Resource}(jsn.vObj['device']);{q3}
    if jsn.has('referenceRange') then
      iterateArray(jsn.vArr['referenceRange'], result.referenceRangeList, parseObservationReferenceRange);
    if jsn.has('related') then
      iterateArray(jsn.vArr['related'], result.relatedList, parseObservationRelated);
    if jsn.has('component') then
      iterateArray(jsn.vArr['component'], result.componentList, parseObservationComponent);
end;

procedure TFHIRJsonComposer.ComposeObservation(json : TJSONWriter; name : string; elem : TFhirObservation; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirObservationStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirObservationStatusEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('category') then
    ComposeCodeableConcept(json, 'category', elem.category); {a}
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirPeriod) then 
    ComposePeriod(json, 'effectivePeriod', TFhirPeriod(elem.effective)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'effectiveDateTime', TFhirDateTime(elem.effective), false);
    ComposeDateTimeProps(json, 'effectiveDateTime', TFhirDateTime(elem.effective), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('issued') then
    ComposeInstantValue(json, 'issued', elem.issuedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('issued') then
    ComposeInstantProps(json, 'issued', elem.issuedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') and (elem.performerList.Count > 0) then
  begin
    startArray(json, 'performer', elem.performerList, false);
    for i := 0 to elem.performerList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.performerList[i]); {z - Reference(Practitioner|Organization|Patient|RelatedPerson)}
    finishArray(json, elem.performerList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirQuantity) then 
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'valueCodeableConcept', TFhirCodeableConcept(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirRange) then 
    ComposeRange(json, 'valueRange', TFhirRange(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirRatio) then 
    ComposeRatio(json, 'valueRatio', TFhirRatio(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirSampledData) then 
    ComposeSampledData(json, 'valueSampledData', TFhirSampledData(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirAttachment) then 
    ComposeAttachment(json, 'valueAttachment', TFhirAttachment(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirPeriod) then 
    ComposePeriod(json, 'valuePeriod', TFhirPeriod(elem.value)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirString) then 
  begin
    ComposeStringValue(json, 'valueString', TFhirString(elem.value), false);
    ComposeStringProps(json, 'valueString', TFhirString(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirTime) then 
  begin
    ComposeTimeValue(json, 'valueTime', TFhirTime(elem.value), false);
    ComposeTimeProps(json, 'valueTime', TFhirTime(elem.value), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'valueDateTime', TFhirDateTime(elem.value), false);
    ComposeDateTimeProps(json, 'valueDateTime', TFhirDateTime(elem.value), false);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('dataAbsentReason') then
    ComposeCodeableConcept(json, 'dataAbsentReason', elem.dataAbsentReason); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('interpretation') then
    ComposeCodeableConcept(json, 'interpretation', elem.interpretation); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('comments') then
    ComposeStringValue(json, 'comments', elem.commentsElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('comments') then
    ComposeStringProps(json, 'comments', elem.commentsElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('bodySite') then
    ComposeCodeableConcept(json, 'bodySite', elem.bodySite); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('method') then
    ComposeCodeableConcept(json, 'method', elem.method); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('specimen') then
    ComposeReference{TFhirSpecimen}(json, 'specimen', elem.specimen); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('device') then
    ComposeReference{Resource}(json, 'device', elem.device); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('referenceRange') and (elem.referenceRangeList.Count > 0) then
  begin
    startArray(json, 'referenceRange', elem.referenceRangeList, false);
    for i := 0 to elem.referenceRangeList.Count - 1 do
      ComposeObservationReferenceRange(json, '', elem.referenceRangeList[i]); {z - }
    finishArray(json, elem.referenceRangeList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('related') and (elem.relatedList.Count > 0) then
  begin
    startArray(json, 'related', elem.relatedList, false);
    for i := 0 to elem.relatedList.Count - 1 do
      ComposeObservationRelated(json, '', elem.relatedList[i]); {z - }
    finishArray(json, elem.relatedList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('component') and (elem.componentList.Count > 0) then
  begin
    startArray(json, 'component', elem.componentList, false);
    for i := 0 to elem.componentList.Count - 1 do
      ComposeObservationComponent(json, '', elem.componentList[i]); {z - }
    finishArray(json, elem.componentList);
  end;
end;

{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OPERATIONDEFINITION}
procedure TFHIRJsonParser.ParseOperationDefinitionContact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOperationDefinitionContact(jsn)); {2}
end;

function TFHIRJsonParser.ParseOperationDefinitionContact(jsn : TJsonObject) : TFhirOperationDefinitionContact;
begin
  result := TFhirOperationDefinitionContact.create;
  try
    ParseOperationDefinitionContactProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseOperationDefinitionContactProperties(jsn : TJsonObject; result : TFhirOperationDefinitionContact);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
end;

procedure TFHIRJsonComposer.ComposeOperationDefinitionContact(json : TJSONWriter; name : string; elem : TFhirOperationDefinitionContact; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.telecomList.Count > 0) then
  begin
    startArray(json, 'telecom', elem.telecomList, false);
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    finishArray(json, elem.telecomList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseOperationDefinitionParameter(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOperationDefinitionParameter(jsn)); {2}
end;

function TFHIRJsonParser.ParseOperationDefinitionParameter(jsn : TJsonObject) : TFhirOperationDefinitionParameter;
begin
  result := TFhirOperationDefinitionParameter.create;
  try
    ParseOperationDefinitionParameterProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseOperationDefinitionParameterProperties(jsn : TJsonObject; result : TFhirOperationDefinitionParameter);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseCode(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('use') or jsn.has('_use')  then
      result.useElement := parseEnum(jsn.path+'/use', jsn.node['use'], jsn.vObj['_use'], CODES_TFhirOperationParameterUseEnum, SYSTEMS_TFhirOperationParameterUseEnum);
    if jsn.has('min') or jsn.has('_min') then
        result.minElement := ParseInteger(jsn.node['min'], jsn.vObj['_min']);{q}
    if jsn.has('max') or jsn.has('_max') then
        result.maxElement := ParseString(jsn.node['max'], jsn.vObj['_max']);{q}
    if jsn.has('documentation') or jsn.has('_documentation') then
        result.documentationElement := ParseString(jsn.node['documentation'], jsn.vObj['_documentation']);{q}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirOperationParameterTypeEnum, SYSTEMS_TFhirOperationParameterTypeEnum);
    if jsn.has('profile') then
        result.profile := ParseReference{TFhirStructureDefinition}(jsn.vObj['profile']);{q3}
    if jsn.has('binding') then
        result.binding := ParseOperationDefinitionParameterBinding(jsn.vObj['binding']);{q3}
    if jsn.has('part') then
      iterateArray(jsn.vArr['part'], result.partList, parseOperationDefinitionParameter);
end;

procedure TFHIRJsonComposer.ComposeOperationDefinitionParameter(json : TJSONWriter; name : string; elem : TFhirOperationDefinitionParameter; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeValue(json, 'name', elem.nameElement, false);
  ComposeCodeProps(json, 'name', elem.nameElement, false);
  ComposeEnumValue(json, 'use', elem.UseElement, CODES_TFhirOperationParameterUseEnum, false);
  ComposeEnumProps(json, 'use', elem.UseElement, CODES_TFhirOperationParameterUseEnum, false);
  ComposeIntegerValue(json, 'min', elem.minElement, false);
  ComposeIntegerProps(json, 'min', elem.minElement, false);
  ComposeStringValue(json, 'max', elem.maxElement, false);
  ComposeStringProps(json, 'max', elem.maxElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'documentation', elem.documentationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirOperationParameterTypeEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirOperationParameterTypeEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirStructureDefinition}(json, 'profile', elem.profile); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeOperationDefinitionParameterBinding(json, 'binding', elem.binding); {a}
  if (SummaryOption in [soFull, soData]) and (elem.partList.Count > 0) then
  begin
    startArray(json, 'part', elem.partList, false);
    for i := 0 to elem.partList.Count - 1 do
      ComposeOperationDefinitionParameter(json, '', elem.partList[i]); {z - @OperationDefinition.parameter}
    finishArray(json, elem.partList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseOperationDefinitionParameterBinding(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOperationDefinitionParameterBinding(jsn)); {2}
end;

function TFHIRJsonParser.ParseOperationDefinitionParameterBinding(jsn : TJsonObject) : TFhirOperationDefinitionParameterBinding;
begin
  result := TFhirOperationDefinitionParameterBinding.create;
  try
    ParseOperationDefinitionParameterBindingProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseOperationDefinitionParameterBindingProperties(jsn : TJsonObject; result : TFhirOperationDefinitionParameterBinding);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('strength') or jsn.has('_strength')  then
      result.strengthElement := parseEnum(jsn.path+'/strength', jsn.node['strength'], jsn.vObj['_strength'], CODES_TFhirBindingStrengthEnum, SYSTEMS_TFhirBindingStrengthEnum);
    if jsn.has('valueSetReference') {a3} then
      result.valueSet := ParseReference(jsn.vObj['valueSetReference']);
    if jsn.has('valueSetUri') or jsn.has('_valueSetUri') then
      result.valueSet := ParseUri(jsn.node['valueSetUri'], jsn.vObj['_valueSetUri']);
end;

procedure TFHIRJsonComposer.ComposeOperationDefinitionParameterBinding(json : TJSONWriter; name : string; elem : TFhirOperationDefinitionParameterBinding; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'strength', elem.StrengthElement, CODES_TFhirBindingStrengthEnum, false);
  ComposeEnumProps(json, 'strength', elem.StrengthElement, CODES_TFhirBindingStrengthEnum, false);
  if (elem.valueSet is TFhirReference) then
    ComposeReference(json, 'valueSetReference', TFhirReference(elem.valueSet))
  else if (elem.valueSet is TFhirUri) then 
  begin
    ComposeUriValue(json, 'valueSetUri', TFhirUri(elem.valueSet), false);
    ComposeUriProps(json, 'valueSetUri', TFhirUri(elem.valueSet), false);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseOperationDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOperationDefinition(jsn)); {2}
end;

function TFHIRJsonParser.ParseOperationDefinition(jsn : TJsonObject) : TFhirOperationDefinition;
begin
  result := TFhirOperationDefinition.create;
  try
    ParseOperationDefinitionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseOperationDefinitionProperties(jsn : TJsonObject; result : TFhirOperationDefinition);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum);
    if jsn.has('kind') or jsn.has('_kind')  then
      result.kindElement := parseEnum(jsn.path+'/kind', jsn.node['kind'], jsn.vObj['_kind'], CODES_TFhirOperationKindEnum, SYSTEMS_TFhirOperationKindEnum);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := ParseBoolean(jsn.node['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := ParseString(jsn.node['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseOperationDefinitionContact);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('requirements') or jsn.has('_requirements') then
        result.requirementsElement := ParseString(jsn.node['requirements'], jsn.vObj['_requirements']);{q}
    if jsn.has('idempotent') or jsn.has('_idempotent') then
        result.idempotentElement := ParseBoolean(jsn.node['idempotent'], jsn.vObj['_idempotent']);{q}
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := ParseCode(jsn.node['code'], jsn.vObj['_code']);{q}
    if jsn.has('notes') or jsn.has('_notes') then
        result.notesElement := ParseString(jsn.node['notes'], jsn.vObj['_notes']);{q}
    if jsn.has('base') then
        result.base := ParseReference{TFhirOperationDefinition}(jsn.vObj['base']);{q3}
    if jsn.has('system') or jsn.has('_system') then
        result.systemElement := ParseBoolean(jsn.node['system'], jsn.vObj['_system']);{q}
    if jsn.has('type') or jsn.has('_type') then
      iterateEnumArray(jsn.vArr['type'], jsn.vArr['_type'], jsn.path+'/type', result.type_, parseEnum, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    if jsn.has('instance') or jsn.has('_instance') then
        result.instanceElement := ParseBoolean(jsn.node['instance'], jsn.vObj['_instance']);{q}
    if jsn.has('parameter') then
      iterateArray(jsn.vArr['parameter'], result.parameterList, parseOperationDefinitionParameter);
end;

procedure TFHIRJsonComposer.ComposeOperationDefinition(json : TJSONWriter; name : string; elem : TFhirOperationDefinition; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('url') then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('url') then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('version') then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('version') then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, false);
  ComposeEnumValue(json, 'kind', elem.KindElement, CODES_TFhirOperationKindEnum, false);
  ComposeEnumProps(json, 'kind', elem.KindElement, CODES_TFhirOperationKindEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('experimental') then
    ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('experimental') then
    ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    startArray(json, 'contact', elem.contactList, false);
    for i := 0 to elem.contactList.Count - 1 do
      ComposeOperationDefinitionContact(json, '', elem.contactList[i]); {z - }
    finishArray(json, elem.contactList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('requirements') then
    ComposeStringValue(json, 'requirements', elem.requirementsElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('requirements') then
    ComposeStringProps(json, 'requirements', elem.requirementsElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('idempotent') then
    ComposeBooleanValue(json, 'idempotent', elem.idempotentElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('idempotent') then
    ComposeBooleanProps(json, 'idempotent', elem.idempotentElement, false);
  ComposeCodeValue(json, 'code', elem.codeElement, false);
  ComposeCodeProps(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('notes') then
    ComposeStringValue(json, 'notes', elem.notesElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('notes') then
    ComposeStringProps(json, 'notes', elem.notesElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('base') then
    ComposeReference{TFhirOperationDefinition}(json, 'base', elem.base); {a}
  ComposeBooleanValue(json, 'system', elem.systemElement, false);
  ComposeBooleanProps(json, 'system', elem.systemElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('type_') and (elem.type_.Count > 0) then
  begin
    val := false;
    ext := false;
    for i := 0 to elem.type_.Count - 1 do
    begin
      val := val or (elem.type_[i].hasPrimitiveValue);
      ext := ext or ((elem.type_[i].id <> '') or (elem.type_[i].hasExtensionList));
    end;
    if val then
    begin
      startArray(json, 'type', elem.type_List, true);
      for i := 0 to elem.type_.Count - 1 do
        ComposeEnumValue(json, '', elem.type_[i], CODES_TFhirResourceTypesEnum, true);
      finishArray(json, elem.type_List);
    end;
    if ext then
    begin
      startArray(json, '_type', elem.type_List, false);
      for i := 0 to elem.type_.Count - 1 do
        ComposeEnumProps(json, '', elem.type_[i], CODES_TFhirResourceTypesEnum, true);
      finishArray(json, elem.type_List);
    end;
  end;
  ComposeBooleanValue(json, 'instance', elem.instanceElement, false);
  ComposeBooleanProps(json, 'instance', elem.instanceElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('parameter') and (elem.parameterList.Count > 0) then
  begin
    startArray(json, 'parameter', elem.parameterList, false);
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeOperationDefinitionParameter(json, '', elem.parameterList[i]); {z - }
    finishArray(json, elem.parameterList);
  end;
end;

{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
procedure TFHIRJsonParser.ParseOperationOutcomeIssue(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOperationOutcomeIssue(jsn)); {2}
end;

function TFHIRJsonParser.ParseOperationOutcomeIssue(jsn : TJsonObject) : TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue.create;
  try
    ParseOperationOutcomeIssueProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseOperationOutcomeIssueProperties(jsn : TJsonObject; result : TFhirOperationOutcomeIssue);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('severity') or jsn.has('_severity')  then
      result.severityElement := parseEnum(jsn.path+'/severity', jsn.node['severity'], jsn.vObj['_severity'], CODES_TFhirIssueSeverityEnum, SYSTEMS_TFhirIssueSeverityEnum);
    if jsn.has('code') or jsn.has('_code')  then
      result.codeElement := parseEnum(jsn.path+'/code', jsn.node['code'], jsn.vObj['_code'], CODES_TFhirIssueTypeEnum, SYSTEMS_TFhirIssueTypeEnum);
    if jsn.has('details') then
        result.details := ParseCodeableConcept(jsn.vObj['details']);{q3}
    if jsn.has('diagnostics') or jsn.has('_diagnostics') then
        result.diagnosticsElement := ParseString(jsn.node['diagnostics'], jsn.vObj['_diagnostics']);{q}
      if jsn.has('location') or jsn.has('_location') then
      iteratePrimitiveArray(jsn.vArr['location'], jsn.vArr['_location'], result.locationList, parseString);
end;

procedure TFHIRJsonComposer.ComposeOperationOutcomeIssue(json : TJSONWriter; name : string; elem : TFhirOperationOutcomeIssue; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'severity', elem.SeverityElement, CODES_TFhirIssueSeverityEnum, false);
  ComposeEnumProps(json, 'severity', elem.SeverityElement, CODES_TFhirIssueSeverityEnum, false);
  ComposeEnumValue(json, 'code', elem.CodeElement, CODES_TFhirIssueTypeEnum, false);
  ComposeEnumProps(json, 'code', elem.CodeElement, CODES_TFhirIssueTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'details', elem.details); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'diagnostics', elem.diagnosticsElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'diagnostics', elem.diagnosticsElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.locationList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.locationList.Count - 1 do
    begin
      ext := ext or ((elem.locationList[i].id <> '') or (elem.locationList[i].hasExtensionList) {no-comments or (elem.locationList[i].hasComments)});
      val := val or (elem.locationList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      startArray(json, 'location', elem.locationList, true);
      for i := 0 to elem.locationList.Count - 1 do
        ComposeStringValue(json, '',elem.locationList[i], true);
      finishArray(json, elem.locationList);
    end;
    if ext then
    begin
      startArray(json, '_location', elem.locationList, false);
      for i := 0 to elem.locationList.Count - 1 do
        ComposeStringProps(json, '',elem.locationList[i], true);
      finishArray(json, elem.locationList);
    end;
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseOperationOutcome(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOperationOutcome(jsn)); {2}
end;

function TFHIRJsonParser.ParseOperationOutcome(jsn : TJsonObject) : TFhirOperationOutcome;
begin
  result := TFhirOperationOutcome.create;
  try
    ParseOperationOutcomeProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseOperationOutcomeProperties(jsn : TJsonObject; result : TFhirOperationOutcome);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('issue') then
      iterateArray(jsn.vArr['issue'], result.issueList, parseOperationOutcomeIssue);
end;

procedure TFHIRJsonComposer.ComposeOperationOutcome(json : TJSONWriter; name : string; elem : TFhirOperationOutcome; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (elem.issueList.Count > 0) then
  begin
    startArray(json, 'issue', elem.issueList, false);
    for i := 0 to elem.issueList.Count - 1 do
      ComposeOperationOutcomeIssue(json, '', elem.issueList[i]); {z - }
    finishArray(json, elem.issueList);
  end;
end;

{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORDER}
procedure TFHIRJsonParser.ParseOrderWhen(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOrderWhen(jsn)); {2}
end;

function TFHIRJsonParser.ParseOrderWhen(jsn : TJsonObject) : TFhirOrderWhen;
begin
  result := TFhirOrderWhen.create;
  try
    ParseOrderWhenProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseOrderWhenProperties(jsn : TJsonObject; result : TFhirOrderWhen);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('schedule') then
        result.schedule := ParseTiming(jsn.vObj['schedule']);{q3}
end;

procedure TFHIRJsonComposer.ComposeOrderWhen(json : TJSONWriter; name : string; elem : TFhirOrderWhen; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTiming(json, 'schedule', elem.schedule); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseOrder(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOrder(jsn)); {2}
end;

function TFHIRJsonParser.ParseOrder(jsn : TJsonObject) : TFhirOrder;
begin
  result := TFhirOrder.create;
  try
    ParseOrderProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseOrderProperties(jsn : TJsonObject; result : TFhirOrder);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q3}
    if jsn.has('source') then
        result.source := ParseReference{Resource}(jsn.vObj['source']);{q3}
    if jsn.has('target') then
        result.target := ParseReference{Resource}(jsn.vObj['target']);{q3}
    if jsn.has('reasonCodeableConcept') {a4} then
      result.reason := ParseCodeableConcept(jsn.vObj['reasonCodeableConcept']);
    if jsn.has('reasonReference') {a3} then
      result.reason := ParseReference(jsn.vObj['reasonReference']);
    if jsn.has('when') then
        result.when := ParseOrderWhen(jsn.vObj['when']);{q3}
    if jsn.has('detail') then
      iterateArray(jsn.vArr['detail'], result.detailList, parseReference{TFhirReference});
end;

procedure TFHIRJsonComposer.ComposeOrder(json : TJSONWriter; name : string; elem : TFhirOrder; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('source') then
    ComposeReference{Resource}(json, 'source', elem.source); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('target') then
    ComposeReference{Resource}(json, 'target', elem.target); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirReference) then
    ComposeReference(json, 'reasonReference', TFhirReference(elem.reason));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('when') then
    ComposeOrderWhen(json, 'when', elem.when); {a}
  if (elem.detailList.Count > 0) then
  begin
    startArray(json, 'detail', elem.detailList, false);
    for i := 0 to elem.detailList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.detailList[i]); {z - Reference(Any)}
    finishArray(json, elem.detailList);
  end;
end;

{$ENDIF FHIR_ORDER}
{$IFDEF FHIR_ORDERRESPONSE}
procedure TFHIRJsonParser.ParseOrderResponse(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOrderResponse(jsn)); {2}
end;

function TFHIRJsonParser.ParseOrderResponse(jsn : TJsonObject) : TFhirOrderResponse;
begin
  result := TFhirOrderResponse.create;
  try
    ParseOrderResponseProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseOrderResponseProperties(jsn : TJsonObject; result : TFhirOrderResponse);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('request') then
        result.request := ParseReference{TFhirOrder}(jsn.vObj['request']);{q3}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('who') then
        result.who := ParseReference{Resource}(jsn.vObj['who']);{q3}
    if jsn.has('orderStatus') or jsn.has('_orderStatus')  then
      result.orderStatusElement := parseEnum(jsn.path+'/orderStatus', jsn.node['orderStatus'], jsn.vObj['_orderStatus'], CODES_TFhirOrderStatusEnum, SYSTEMS_TFhirOrderStatusEnum);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('fulfillment') then
      iterateArray(jsn.vArr['fulfillment'], result.fulfillmentList, parseReference{TFhirReference});
end;

procedure TFHIRJsonComposer.ComposeOrderResponse(json : TJSONWriter; name : string; elem : TFhirOrderResponse; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  ComposeReference{TFhirOrder}(json, 'request', elem.request); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('who') then
    ComposeReference{Resource}(json, 'who', elem.who); {a}
  ComposeEnumValue(json, 'orderStatus', elem.OrderStatusElement, CODES_TFhirOrderStatusEnum, false);
  ComposeEnumProps(json, 'orderStatus', elem.OrderStatusElement, CODES_TFhirOrderStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('fulfillment') and (elem.fulfillmentList.Count > 0) then
  begin
    startArray(json, 'fulfillment', elem.fulfillmentList, false);
    for i := 0 to elem.fulfillmentList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.fulfillmentList[i]); {z - Reference(Any)}
    finishArray(json, elem.fulfillmentList);
  end;
end;

{$ENDIF FHIR_ORDERRESPONSE}
{$IFDEF FHIR_ORGANIZATION}
procedure TFHIRJsonParser.ParseOrganizationContact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOrganizationContact(jsn)); {2}
end;

function TFHIRJsonParser.ParseOrganizationContact(jsn : TJsonObject) : TFhirOrganizationContact;
begin
  result := TFhirOrganizationContact.create;
  try
    ParseOrganizationContactProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseOrganizationContactProperties(jsn : TJsonObject; result : TFhirOrganizationContact);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('purpose') then
        result.purpose := ParseCodeableConcept(jsn.vObj['purpose']);{q3}
    if jsn.has('name') then
        result.name := ParseHumanName(jsn.vObj['name']);{q3}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('address') then
        result.address := ParseAddress(jsn.vObj['address']);{q3}
end;

procedure TFHIRJsonComposer.ComposeOrganizationContact(json : TJSONWriter; name : string; elem : TFhirOrganizationContact; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'purpose', elem.purpose); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeHumanName(json, 'name', elem.name); {a}
  if (SummaryOption in [soFull, soData]) and (elem.telecomList.Count > 0) then
  begin
    startArray(json, 'telecom', elem.telecomList, false);
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    finishArray(json, elem.telecomList);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeAddress(json, 'address', elem.address); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseOrganization(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseOrganization(jsn)); {2}
end;

function TFHIRJsonParser.ParseOrganization(jsn : TJsonObject) : TFhirOrganization;
begin
  result := TFhirOrganization.create;
  try
    ParseOrganizationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseOrganizationProperties(jsn : TJsonObject; result : TFhirOrganization);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('active') or jsn.has('_active') then
        result.activeElement := ParseBoolean(jsn.node['active'], jsn.vObj['_active']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('address') then
      iterateArray(jsn.vArr['address'], result.addressList, parseAddress);
    if jsn.has('partOf') then
        result.partOf := ParseReference{TFhirOrganization}(jsn.vObj['partOf']);{q3}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseOrganizationContact);
end;

procedure TFHIRJsonComposer.ComposeOrganization(json : TJSONWriter; name : string; elem : TFhirOrganization; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.active <> true)) and doCompose('active') then
    ComposeBooleanValue(json, 'active', elem.activeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.active <> true)) and doCompose('active') then
    ComposeBooleanProps(json, 'active', elem.activeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('telecom') and (elem.telecomList.Count > 0) then
  begin
    startArray(json, 'telecom', elem.telecomList, false);
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    finishArray(json, elem.telecomList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('address') and (elem.addressList.Count > 0) then
  begin
    startArray(json, 'address', elem.addressList, false);
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(json, '', elem.addressList[i]); {z - Address}
    finishArray(json, elem.addressList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') then
    ComposeReference{TFhirOrganization}(json, 'partOf', elem.partOf); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    startArray(json, 'contact', elem.contactList, false);
    for i := 0 to elem.contactList.Count - 1 do
      ComposeOrganizationContact(json, '', elem.contactList[i]); {z - }
    finishArray(json, elem.contactList);
  end;
end;

{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_PATIENT}
procedure TFHIRJsonParser.ParsePatientContact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePatientContact(jsn)); {2}
end;

function TFHIRJsonParser.ParsePatientContact(jsn : TJsonObject) : TFhirPatientContact;
begin
  result := TFhirPatientContact.create;
  try
    ParsePatientContactProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParsePatientContactProperties(jsn : TJsonObject; result : TFhirPatientContact);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('relationship') then
      iterateArray(jsn.vArr['relationship'], result.relationshipList, parseCodeableConcept);
    if jsn.has('name') then
        result.name := ParseHumanName(jsn.vObj['name']);{q3}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('address') then
        result.address := ParseAddress(jsn.vObj['address']);{q3}
    if jsn.has('gender') or jsn.has('_gender')  then
      result.genderElement := parseEnum(jsn.path+'/gender', jsn.node['gender'], jsn.vObj['_gender'], CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum);
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q3}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
end;

procedure TFHIRJsonComposer.ComposePatientContact(json : TJSONWriter; name : string; elem : TFhirPatientContact; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.relationshipList.Count > 0) then
  begin
    startArray(json, 'relationship', elem.relationshipList, false);
    for i := 0 to elem.relationshipList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.relationshipList[i]); {z - CodeableConcept}
    finishArray(json, elem.relationshipList);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeHumanName(json, 'name', elem.name); {a}
  if (SummaryOption in [soFull, soData]) and (elem.telecomList.Count > 0) then
  begin
    startArray(json, 'telecom', elem.telecomList, false);
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    finishArray(json, elem.telecomList);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeAddress(json, 'address', elem.address); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParsePatientAnimal(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePatientAnimal(jsn)); {2}
end;

function TFHIRJsonParser.ParsePatientAnimal(jsn : TJsonObject) : TFhirPatientAnimal;
begin
  result := TFhirPatientAnimal.create;
  try
    ParsePatientAnimalProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParsePatientAnimalProperties(jsn : TJsonObject; result : TFhirPatientAnimal);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('species') then
        result.species := ParseCodeableConcept(jsn.vObj['species']);{q3}
    if jsn.has('breed') then
        result.breed := ParseCodeableConcept(jsn.vObj['breed']);{q3}
    if jsn.has('genderStatus') then
        result.genderStatus := ParseCodeableConcept(jsn.vObj['genderStatus']);{q3}
end;

procedure TFHIRJsonComposer.ComposePatientAnimal(json : TJSONWriter; name : string; elem : TFhirPatientAnimal; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'species', elem.species); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'breed', elem.breed); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'genderStatus', elem.genderStatus); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParsePatientCommunication(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePatientCommunication(jsn)); {2}
end;

function TFHIRJsonParser.ParsePatientCommunication(jsn : TJsonObject) : TFhirPatientCommunication;
begin
  result := TFhirPatientCommunication.create;
  try
    ParsePatientCommunicationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParsePatientCommunicationProperties(jsn : TJsonObject; result : TFhirPatientCommunication);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('language') then
        result.language := ParseCodeableConcept(jsn.vObj['language']);{q3}
    if jsn.has('preferred') or jsn.has('_preferred') then
        result.preferredElement := ParseBoolean(jsn.node['preferred'], jsn.vObj['_preferred']);{q}
end;

procedure TFHIRJsonComposer.ComposePatientCommunication(json : TJSONWriter; name : string; elem : TFhirPatientCommunication; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'language', elem.language); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'preferred', elem.preferredElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'preferred', elem.preferredElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParsePatientLink(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePatientLink(jsn)); {2}
end;

function TFHIRJsonParser.ParsePatientLink(jsn : TJsonObject) : TFhirPatientLink;
begin
  result := TFhirPatientLink.create;
  try
    ParsePatientLinkProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParsePatientLinkProperties(jsn : TJsonObject; result : TFhirPatientLink);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('other') then
        result.other := ParseReference{TFhirPatient}(jsn.vObj['other']);{q3}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirLinkTypeEnum, SYSTEMS_TFhirLinkTypeEnum);
end;

procedure TFHIRJsonComposer.ComposePatientLink(json : TJSONWriter; name : string; elem : TFhirPatientLink; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeReference{TFhirPatient}(json, 'other', elem.other); {a}
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirLinkTypeEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirLinkTypeEnum, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParsePatient(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePatient(jsn)); {2}
end;

function TFHIRJsonParser.ParsePatient(jsn : TJsonObject) : TFhirPatient;
begin
  result := TFhirPatient.create;
  try
    ParsePatientProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParsePatientProperties(jsn : TJsonObject; result : TFhirPatient);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('active') or jsn.has('_active') then
        result.activeElement := ParseBoolean(jsn.node['active'], jsn.vObj['_active']);{q}
    if jsn.has('name') then
      iterateArray(jsn.vArr['name'], result.nameList, parseHumanName);
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('gender') or jsn.has('_gender')  then
      result.genderElement := parseEnum(jsn.path+'/gender', jsn.node['gender'], jsn.vObj['_gender'], CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum);
    if jsn.has('birthDate') or jsn.has('_birthDate') then
        result.birthDateElement := ParseDate(jsn.node['birthDate'], jsn.vObj['_birthDate']);{q}
    if jsn.has('deceasedBoolean') or jsn.has('_deceasedBoolean') then
      result.deceased := ParseBoolean(jsn.node['deceasedBoolean'], jsn.vObj['_deceasedBoolean']);
    if jsn.has('deceasedDateTime') or jsn.has('_deceasedDateTime') then
      result.deceased := ParseDateTime(jsn.node['deceasedDateTime'], jsn.vObj['_deceasedDateTime']);
    if jsn.has('address') then
      iterateArray(jsn.vArr['address'], result.addressList, parseAddress);
    if jsn.has('maritalStatus') then
        result.maritalStatus := ParseCodeableConcept(jsn.vObj['maritalStatus']);{q3}
    if jsn.has('multipleBirthBoolean') or jsn.has('_multipleBirthBoolean') then
      result.multipleBirth := ParseBoolean(jsn.node['multipleBirthBoolean'], jsn.vObj['_multipleBirthBoolean']);
    if jsn.has('multipleBirthInteger') or jsn.has('_multipleBirthInteger') then
      result.multipleBirth := ParseInteger(jsn.node['multipleBirthInteger'], jsn.vObj['_multipleBirthInteger']);
    if jsn.has('photo') then
      iterateArray(jsn.vArr['photo'], result.photoList, parseAttachment);
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parsePatientContact);
    if jsn.has('animal') then
        result.animal := ParsePatientAnimal(jsn.vObj['animal']);{q3}
    if jsn.has('communication') then
      iterateArray(jsn.vArr['communication'], result.communicationList, parsePatientCommunication);
    if jsn.has('careProvider') then
      iterateArray(jsn.vArr['careProvider'], result.careProviderList, parseReference{Resource});
    if jsn.has('managingOrganization') then
        result.managingOrganization := ParseReference{TFhirOrganization}(jsn.vObj['managingOrganization']);{q3}
    if jsn.has('link') then
      iterateArray(jsn.vArr['link'], result.link_List, parsePatientLink);
end;

procedure TFHIRJsonComposer.ComposePatient(json : TJSONWriter; name : string; elem : TFhirPatient; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.active <> true)) and doCompose('active') then
    ComposeBooleanValue(json, 'active', elem.activeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.active <> true)) and doCompose('active') then
    ComposeBooleanProps(json, 'active', elem.activeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') and (elem.nameList.Count > 0) then
  begin
    startArray(json, 'name', elem.nameList, false);
    for i := 0 to elem.nameList.Count - 1 do
      ComposeHumanName(json, '', elem.nameList[i]); {z - HumanName}
    finishArray(json, elem.nameList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('telecom') and (elem.telecomList.Count > 0) then
  begin
    startArray(json, 'telecom', elem.telecomList, false);
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    finishArray(json, elem.telecomList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gender') then
    ComposeEnumValue(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gender') then
    ComposeEnumProps(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('birthDate') then
    ComposeDateValue(json, 'birthDate', elem.birthDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('birthDate') then
    ComposeDateProps(json, 'birthDate', elem.birthDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.deceased is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'deceasedBoolean', TFhirBoolean(elem.deceased), false);
    ComposeBooleanProps(json, 'deceasedBoolean', TFhirBoolean(elem.deceased), false);
  end
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.deceased is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'deceasedDateTime', TFhirDateTime(elem.deceased), false);
    ComposeDateTimeProps(json, 'deceasedDateTime', TFhirDateTime(elem.deceased), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('address') and (elem.addressList.Count > 0) then
  begin
    startArray(json, 'address', elem.addressList, false);
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(json, '', elem.addressList[i]); {z - Address}
    finishArray(json, elem.addressList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('maritalStatus') then
    ComposeCodeableConcept(json, 'maritalStatus', elem.maritalStatus); {a}
  if (SummaryOption in [soFull, soData]) and (elem.multipleBirth is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'multipleBirthBoolean', TFhirBoolean(elem.multipleBirth), false);
    ComposeBooleanProps(json, 'multipleBirthBoolean', TFhirBoolean(elem.multipleBirth), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.multipleBirth is TFhirInteger) then 
  begin
    ComposeIntegerValue(json, 'multipleBirthInteger', TFhirInteger(elem.multipleBirth), false);
    ComposeIntegerProps(json, 'multipleBirthInteger', TFhirInteger(elem.multipleBirth), false);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('photo') and (elem.photoList.Count > 0) then
  begin
    startArray(json, 'photo', elem.photoList, false);
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(json, '', elem.photoList[i]); {z - Attachment}
    finishArray(json, elem.photoList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    startArray(json, 'contact', elem.contactList, false);
    for i := 0 to elem.contactList.Count - 1 do
      ComposePatientContact(json, '', elem.contactList[i]); {z - }
    finishArray(json, elem.contactList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('animal') then
    ComposePatientAnimal(json, 'animal', elem.animal); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('communication') and (elem.communicationList.Count > 0) then
  begin
    startArray(json, 'communication', elem.communicationList, false);
    for i := 0 to elem.communicationList.Count - 1 do
      ComposePatientCommunication(json, '', elem.communicationList[i]); {z - }
    finishArray(json, elem.communicationList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('careProvider') and (elem.careProviderList.Count > 0) then
  begin
    startArray(json, 'careProvider', elem.careProviderList, false);
    for i := 0 to elem.careProviderList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.careProviderList[i]); {z - Reference(Organization|Practitioner)}
    finishArray(json, elem.careProviderList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('managingOrganization') then
    ComposeReference{TFhirOrganization}(json, 'managingOrganization', elem.managingOrganization); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('link_') and (elem.link_List.Count > 0) then
  begin
    startArray(json, 'link', elem.link_List, false);
    for i := 0 to elem.link_List.Count - 1 do
      ComposePatientLink(json, '', elem.link_List[i]); {z - }
    finishArray(json, elem.link_List);
  end;
end;

{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
procedure TFHIRJsonParser.ParsePaymentNotice(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePaymentNotice(jsn)); {2}
end;

function TFHIRJsonParser.ParsePaymentNotice(jsn : TJsonObject) : TFhirPaymentNotice;
begin
  result := TFhirPaymentNotice.create;
  try
    ParsePaymentNoticeProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParsePaymentNoticeProperties(jsn : TJsonObject; result : TFhirPaymentNotice);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('ruleset') then
        result.ruleset := ParseCoding(jsn.vObj['ruleset']);{q3}
    if jsn.has('originalRuleset') then
        result.originalRuleset := ParseCoding(jsn.vObj['originalRuleset']);{q3}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := ParseDateTime(jsn.node['created'], jsn.vObj['_created']);{q}
    if jsn.has('target') then
        result.target := ParseReference{TFhirOrganization}(jsn.vObj['target']);{q3}
    if jsn.has('provider') then
        result.provider := ParseReference{TFhirPractitioner}(jsn.vObj['provider']);{q3}
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q3}
    if jsn.has('request') then
        result.request := ParseReference{TFhirReference}(jsn.vObj['request']);{q3}
    if jsn.has('response') then
        result.response := ParseReference{TFhirReference}(jsn.vObj['response']);{q3}
    if jsn.has('paymentStatus') then
        result.paymentStatus := ParseCoding(jsn.vObj['paymentStatus']);{q3}
end;

procedure TFHIRJsonComposer.ComposePaymentNotice(json : TJSONWriter; name : string; elem : TFhirPaymentNotice; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ruleset') then
    ComposeCoding(json, 'ruleset', elem.ruleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('originalRuleset') then
    ComposeCoding(json, 'originalRuleset', elem.originalRuleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('target') then
    ComposeReference{TFhirOrganization}(json, 'target', elem.target); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('provider') then
    ComposeReference{TFhirPractitioner}(json, 'provider', elem.provider); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('request') then
    ComposeReference{TFhirReference}(json, 'request', elem.request); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('response') then
    ComposeReference{TFhirReference}(json, 'response', elem.response); {a}
  ComposeCoding(json, 'paymentStatus', elem.paymentStatus); {a}
end;

{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
procedure TFHIRJsonParser.ParsePaymentReconciliationDetail(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePaymentReconciliationDetail(jsn)); {2}
end;

function TFHIRJsonParser.ParsePaymentReconciliationDetail(jsn : TJsonObject) : TFhirPaymentReconciliationDetail;
begin
  result := TFhirPaymentReconciliationDetail.create;
  try
    ParsePaymentReconciliationDetailProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParsePaymentReconciliationDetailProperties(jsn : TJsonObject; result : TFhirPaymentReconciliationDetail);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q3}
    if jsn.has('request') then
        result.request := ParseReference{TFhirReference}(jsn.vObj['request']);{q3}
    if jsn.has('responce') then
        result.responce := ParseReference{TFhirReference}(jsn.vObj['responce']);{q3}
    if jsn.has('submitter') then
        result.submitter := ParseReference{TFhirOrganization}(jsn.vObj['submitter']);{q3}
    if jsn.has('payee') then
        result.payee := ParseReference{TFhirOrganization}(jsn.vObj['payee']);{q3}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDate(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('amount') then
        result.amount := ParseQuantity(jsn.vObj['amount']);{q3}
end;

procedure TFHIRJsonComposer.ComposePaymentReconciliationDetail(json : TJSONWriter; name : string; elem : TFhirPaymentReconciliationDetail; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeCoding(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(json, 'request', elem.request); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(json, 'responce', elem.responce); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(json, 'submitter', elem.submitter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(json, 'payee', elem.payee); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'amount', elem.amount); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParsePaymentReconciliationNote(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePaymentReconciliationNote(jsn)); {2}
end;

function TFHIRJsonParser.ParsePaymentReconciliationNote(jsn : TJsonObject) : TFhirPaymentReconciliationNote;
begin
  result := TFhirPaymentReconciliationNote.create;
  try
    ParsePaymentReconciliationNoteProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParsePaymentReconciliationNoteProperties(jsn : TJsonObject; result : TFhirPaymentReconciliationNote);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q3}
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn.node['text'], jsn.vObj['_text']);{q}
end;

procedure TFHIRJsonComposer.ComposePaymentReconciliationNote(json : TJSONWriter; name : string; elem : TFhirPaymentReconciliationNote; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParsePaymentReconciliation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePaymentReconciliation(jsn)); {2}
end;

function TFHIRJsonParser.ParsePaymentReconciliation(jsn : TJsonObject) : TFhirPaymentReconciliation;
begin
  result := TFhirPaymentReconciliation.create;
  try
    ParsePaymentReconciliationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParsePaymentReconciliationProperties(jsn : TJsonObject; result : TFhirPaymentReconciliation);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('request') then
        result.request := ParseReference{TFhirProcessRequest}(jsn.vObj['request']);{q3}
    if jsn.has('outcome') or jsn.has('_outcome')  then
      result.outcomeElement := parseEnum(jsn.path+'/outcome', jsn.node['outcome'], jsn.vObj['_outcome'], CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum);
    if jsn.has('disposition') or jsn.has('_disposition') then
        result.dispositionElement := ParseString(jsn.node['disposition'], jsn.vObj['_disposition']);{q}
    if jsn.has('ruleset') then
        result.ruleset := ParseCoding(jsn.vObj['ruleset']);{q3}
    if jsn.has('originalRuleset') then
        result.originalRuleset := ParseCoding(jsn.vObj['originalRuleset']);{q3}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := ParseDateTime(jsn.node['created'], jsn.vObj['_created']);{q}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q3}
    if jsn.has('requestProvider') then
        result.requestProvider := ParseReference{TFhirPractitioner}(jsn.vObj['requestProvider']);{q3}
    if jsn.has('requestOrganization') then
        result.requestOrganization := ParseReference{TFhirOrganization}(jsn.vObj['requestOrganization']);{q3}
    if jsn.has('detail') then
      iterateArray(jsn.vArr['detail'], result.detailList, parsePaymentReconciliationDetail);
    if jsn.has('form') then
        result.form := ParseCoding(jsn.vObj['form']);{q3}
    if jsn.has('total') then
        result.total := ParseQuantity(jsn.vObj['total']);{q3}
    if jsn.has('note') then
      iterateArray(jsn.vArr['note'], result.noteList, parsePaymentReconciliationNote);
end;

procedure TFHIRJsonComposer.ComposePaymentReconciliation(json : TJSONWriter; name : string; elem : TFhirPaymentReconciliation; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('request') then
    ComposeReference{TFhirProcessRequest}(json, 'request', elem.request); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcome') then
    ComposeEnumValue(json, 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcome') then
    ComposeEnumProps(json, 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('disposition') then
    ComposeStringValue(json, 'disposition', elem.dispositionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('disposition') then
    ComposeStringProps(json, 'disposition', elem.dispositionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ruleset') then
    ComposeCoding(json, 'ruleset', elem.ruleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('originalRuleset') then
    ComposeCoding(json, 'originalRuleset', elem.originalRuleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestProvider') then
    ComposeReference{TFhirPractitioner}(json, 'requestProvider', elem.requestProvider); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestOrganization') then
    ComposeReference{TFhirOrganization}(json, 'requestOrganization', elem.requestOrganization); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('detail') and (elem.detailList.Count > 0) then
  begin
    startArray(json, 'detail', elem.detailList, false);
    for i := 0 to elem.detailList.Count - 1 do
      ComposePaymentReconciliationDetail(json, '', elem.detailList[i]); {z - }
    finishArray(json, elem.detailList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('form') then
    ComposeCoding(json, 'form', elem.form); {a}
  ComposeQuantity(json, 'total', elem.total); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('note') and (elem.noteList.Count > 0) then
  begin
    startArray(json, 'note', elem.noteList, false);
    for i := 0 to elem.noteList.Count - 1 do
      ComposePaymentReconciliationNote(json, '', elem.noteList[i]); {z - }
    finishArray(json, elem.noteList);
  end;
end;

{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
procedure TFHIRJsonParser.ParsePersonLink(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePersonLink(jsn)); {2}
end;

function TFHIRJsonParser.ParsePersonLink(jsn : TJsonObject) : TFhirPersonLink;
begin
  result := TFhirPersonLink.create;
  try
    ParsePersonLinkProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParsePersonLinkProperties(jsn : TJsonObject; result : TFhirPersonLink);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('target') then
        result.target := ParseReference{Resource}(jsn.vObj['target']);{q3}
    if jsn.has('assurance') or jsn.has('_assurance')  then
      result.assuranceElement := parseEnum(jsn.path+'/assurance', jsn.node['assurance'], jsn.vObj['_assurance'], CODES_TFhirIdentityAssuranceLevelEnum, SYSTEMS_TFhirIdentityAssuranceLevelEnum);
end;

procedure TFHIRJsonComposer.ComposePersonLink(json : TJSONWriter; name : string; elem : TFhirPersonLink; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeReference{Resource}(json, 'target', elem.target); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'assurance', elem.AssuranceElement, CODES_TFhirIdentityAssuranceLevelEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'assurance', elem.AssuranceElement, CODES_TFhirIdentityAssuranceLevelEnum, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParsePerson(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePerson(jsn)); {2}
end;

function TFHIRJsonParser.ParsePerson(jsn : TJsonObject) : TFhirPerson;
begin
  result := TFhirPerson.create;
  try
    ParsePersonProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParsePersonProperties(jsn : TJsonObject; result : TFhirPerson);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('name') then
      iterateArray(jsn.vArr['name'], result.nameList, parseHumanName);
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('gender') or jsn.has('_gender')  then
      result.genderElement := parseEnum(jsn.path+'/gender', jsn.node['gender'], jsn.vObj['_gender'], CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum);
    if jsn.has('birthDate') or jsn.has('_birthDate') then
        result.birthDateElement := ParseDate(jsn.node['birthDate'], jsn.vObj['_birthDate']);{q}
    if jsn.has('address') then
      iterateArray(jsn.vArr['address'], result.addressList, parseAddress);
    if jsn.has('photo') then
        result.photo := ParseAttachment(jsn.vObj['photo']);{q3}
    if jsn.has('managingOrganization') then
        result.managingOrganization := ParseReference{TFhirOrganization}(jsn.vObj['managingOrganization']);{q3}
    if jsn.has('active') or jsn.has('_active') then
        result.activeElement := ParseBoolean(jsn.node['active'], jsn.vObj['_active']);{q}
    if jsn.has('link') then
      iterateArray(jsn.vArr['link'], result.link_List, parsePersonLink);
end;

procedure TFHIRJsonComposer.ComposePerson(json : TJSONWriter; name : string; elem : TFhirPerson; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') and (elem.nameList.Count > 0) then
  begin
    startArray(json, 'name', elem.nameList, false);
    for i := 0 to elem.nameList.Count - 1 do
      ComposeHumanName(json, '', elem.nameList[i]); {z - HumanName}
    finishArray(json, elem.nameList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('telecom') and (elem.telecomList.Count > 0) then
  begin
    startArray(json, 'telecom', elem.telecomList, false);
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    finishArray(json, elem.telecomList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gender') then
    ComposeEnumValue(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gender') then
    ComposeEnumProps(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('birthDate') then
    ComposeDateValue(json, 'birthDate', elem.birthDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('birthDate') then
    ComposeDateProps(json, 'birthDate', elem.birthDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('address') and (elem.addressList.Count > 0) then
  begin
    startArray(json, 'address', elem.addressList, false);
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(json, '', elem.addressList[i]); {z - Address}
    finishArray(json, elem.addressList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('photo') then
    ComposeAttachment(json, 'photo', elem.photo); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('managingOrganization') then
    ComposeReference{TFhirOrganization}(json, 'managingOrganization', elem.managingOrganization); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposeBooleanValue(json, 'active', elem.activeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposeBooleanProps(json, 'active', elem.activeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('link_') and (elem.link_List.Count > 0) then
  begin
    startArray(json, 'link', elem.link_List, false);
    for i := 0 to elem.link_List.Count - 1 do
      ComposePersonLink(json, '', elem.link_List[i]); {z - }
    finishArray(json, elem.link_List);
  end;
end;

{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PRACTITIONER}
procedure TFHIRJsonParser.ParsePractitionerPractitionerRole(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePractitionerPractitionerRole(jsn)); {2}
end;

function TFHIRJsonParser.ParsePractitionerPractitionerRole(jsn : TJsonObject) : TFhirPractitionerPractitionerRole;
begin
  result := TFhirPractitionerPractitionerRole.create;
  try
    ParsePractitionerPractitionerRoleProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParsePractitionerPractitionerRoleProperties(jsn : TJsonObject; result : TFhirPractitionerPractitionerRole);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('managingOrganization') then
        result.managingOrganization := ParseReference{TFhirOrganization}(jsn.vObj['managingOrganization']);{q3}
    if jsn.has('role') then
        result.role := ParseCodeableConcept(jsn.vObj['role']);{q3}
    if jsn.has('specialty') then
      iterateArray(jsn.vArr['specialty'], result.specialtyList, parseCodeableConcept);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
    if jsn.has('location') then
      iterateArray(jsn.vArr['location'], result.locationList, parseReference{TFhirLocation});
    if jsn.has('healthcareService') then
      iterateArray(jsn.vArr['healthcareService'], result.healthcareServiceList, parseReference{TFhirHealthcareService});
end;

procedure TFHIRJsonComposer.ComposePractitionerPractitionerRole(json : TJSONWriter; name : string; elem : TFhirPractitionerPractitionerRole; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(json, 'managingOrganization', elem.managingOrganization); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'role', elem.role); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.specialtyList.Count > 0) then
  begin
    startArray(json, 'specialty', elem.specialtyList, false);
    for i := 0 to elem.specialtyList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.specialtyList[i]); {z - CodeableConcept}
    finishArray(json, elem.specialtyList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soData]) and (elem.locationList.Count > 0) then
  begin
    startArray(json, 'location', elem.locationList, false);
    for i := 0 to elem.locationList.Count - 1 do
      ComposeReference{TFhirLocation}(json, '', elem.locationList[i]); {z - Reference(Location)}
    finishArray(json, elem.locationList);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.healthcareServiceList.Count > 0) then
  begin
    startArray(json, 'healthcareService', elem.healthcareServiceList, false);
    for i := 0 to elem.healthcareServiceList.Count - 1 do
      ComposeReference{TFhirHealthcareService}(json, '', elem.healthcareServiceList[i]); {z - Reference(HealthcareService)}
    finishArray(json, elem.healthcareServiceList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParsePractitionerQualification(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePractitionerQualification(jsn)); {2}
end;

function TFHIRJsonParser.ParsePractitionerQualification(jsn : TJsonObject) : TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification.create;
  try
    ParsePractitionerQualificationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParsePractitionerQualificationProperties(jsn : TJsonObject; result : TFhirPractitionerQualification);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
    if jsn.has('issuer') then
        result.issuer := ParseReference{TFhirOrganization}(jsn.vObj['issuer']);{q3}
end;

procedure TFHIRJsonComposer.ComposePractitionerQualification(json : TJSONWriter; name : string; elem : TFhirPractitionerQualification; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(json, 'period', elem.period); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(json, 'issuer', elem.issuer); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParsePractitioner(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParsePractitioner(jsn)); {2}
end;

function TFHIRJsonParser.ParsePractitioner(jsn : TJsonObject) : TFhirPractitioner;
begin
  result := TFhirPractitioner.create;
  try
    ParsePractitionerProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParsePractitionerProperties(jsn : TJsonObject; result : TFhirPractitioner);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('active') or jsn.has('_active') then
        result.activeElement := ParseBoolean(jsn.node['active'], jsn.vObj['_active']);{q}
    if jsn.has('name') then
        result.name := ParseHumanName(jsn.vObj['name']);{q3}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('address') then
      iterateArray(jsn.vArr['address'], result.addressList, parseAddress);
    if jsn.has('gender') or jsn.has('_gender')  then
      result.genderElement := parseEnum(jsn.path+'/gender', jsn.node['gender'], jsn.vObj['_gender'], CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum);
    if jsn.has('birthDate') or jsn.has('_birthDate') then
        result.birthDateElement := ParseDate(jsn.node['birthDate'], jsn.vObj['_birthDate']);{q}
    if jsn.has('photo') then
      iterateArray(jsn.vArr['photo'], result.photoList, parseAttachment);
    if jsn.has('practitionerRole') then
      iterateArray(jsn.vArr['practitionerRole'], result.practitionerRoleList, parsePractitionerPractitionerRole);
    if jsn.has('qualification') then
      iterateArray(jsn.vArr['qualification'], result.qualificationList, parsePractitionerQualification);
    if jsn.has('communication') then
      iterateArray(jsn.vArr['communication'], result.communicationList, parseCodeableConcept);
end;

procedure TFHIRJsonComposer.ComposePractitioner(json : TJSONWriter; name : string; elem : TFhirPractitioner; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.active <> true)) and doCompose('active') then
    ComposeBooleanValue(json, 'active', elem.activeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.active <> true)) and doCompose('active') then
    ComposeBooleanProps(json, 'active', elem.activeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeHumanName(json, 'name', elem.name); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('telecom') and (elem.telecomList.Count > 0) then
  begin
    startArray(json, 'telecom', elem.telecomList, false);
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    finishArray(json, elem.telecomList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('address') and (elem.addressList.Count > 0) then
  begin
    startArray(json, 'address', elem.addressList, false);
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(json, '', elem.addressList[i]); {z - Address}
    finishArray(json, elem.addressList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gender') then
    ComposeEnumValue(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gender') then
    ComposeEnumProps(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('birthDate') then
    ComposeDateValue(json, 'birthDate', elem.birthDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('birthDate') then
    ComposeDateProps(json, 'birthDate', elem.birthDateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('photo') and (elem.photoList.Count > 0) then
  begin
    startArray(json, 'photo', elem.photoList, false);
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(json, '', elem.photoList[i]); {z - Attachment}
    finishArray(json, elem.photoList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('practitionerRole') and (elem.practitionerRoleList.Count > 0) then
  begin
    startArray(json, 'practitionerRole', elem.practitionerRoleList, false);
    for i := 0 to elem.practitionerRoleList.Count - 1 do
      ComposePractitionerPractitionerRole(json, '', elem.practitionerRoleList[i]); {z - }
    finishArray(json, elem.practitionerRoleList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('qualification') and (elem.qualificationList.Count > 0) then
  begin
    startArray(json, 'qualification', elem.qualificationList, false);
    for i := 0 to elem.qualificationList.Count - 1 do
      ComposePractitionerQualification(json, '', elem.qualificationList[i]); {z - }
    finishArray(json, elem.qualificationList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('communication') and (elem.communicationList.Count > 0) then
  begin
    startArray(json, 'communication', elem.communicationList, false);
    for i := 0 to elem.communicationList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.communicationList[i]); {z - CodeableConcept}
    finishArray(json, elem.communicationList);
  end;
end;

{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PROCEDURE}
procedure TFHIRJsonParser.ParseProcedurePerformer(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProcedurePerformer(jsn)); {2}
end;

function TFHIRJsonParser.ParseProcedurePerformer(jsn : TJsonObject) : TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer.create;
  try
    ParseProcedurePerformerProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseProcedurePerformerProperties(jsn : TJsonObject; result : TFhirProcedurePerformer);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('actor') then
        result.actor := ParseReference{Resource}(jsn.vObj['actor']);{q3}
    if jsn.has('role') then
        result.role := ParseCodeableConcept(jsn.vObj['role']);{q3}
end;

procedure TFHIRJsonComposer.ComposeProcedurePerformer(json : TJSONWriter; name : string; elem : TFhirProcedurePerformer; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'actor', elem.actor); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'role', elem.role); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseProcedureFocalDevice(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProcedureFocalDevice(jsn)); {2}
end;

function TFHIRJsonParser.ParseProcedureFocalDevice(jsn : TJsonObject) : TFhirProcedureFocalDevice;
begin
  result := TFhirProcedureFocalDevice.create;
  try
    ParseProcedureFocalDeviceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseProcedureFocalDeviceProperties(jsn : TJsonObject; result : TFhirProcedureFocalDevice);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('action') then
        result.action := ParseCodeableConcept(jsn.vObj['action']);{q3}
    if jsn.has('manipulated') then
        result.manipulated := ParseReference{TFhirDevice}(jsn.vObj['manipulated']);{q3}
end;

procedure TFHIRJsonComposer.ComposeProcedureFocalDevice(json : TJSONWriter; name : string; elem : TFhirProcedureFocalDevice; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'action', elem.action); {a}
  ComposeReference{TFhirDevice}(json, 'manipulated', elem.manipulated); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseProcedure(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProcedure(jsn)); {2}
end;

function TFHIRJsonParser.ParseProcedure(jsn : TJsonObject) : TFhirProcedure;
begin
  result := TFhirProcedure.create;
  try
    ParseProcedureProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseProcedureProperties(jsn : TJsonObject; result : TFhirProcedure);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q3}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirProcedureStatusEnum, SYSTEMS_TFhirProcedureStatusEnum);
    if jsn.has('category') then
        result.category := ParseCodeableConcept(jsn.vObj['category']);{q3}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('notPerformed') or jsn.has('_notPerformed') then
        result.notPerformedElement := ParseBoolean(jsn.node['notPerformed'], jsn.vObj['_notPerformed']);{q}
    if jsn.has('reasonNotPerformed') then
      iterateArray(jsn.vArr['reasonNotPerformed'], result.reasonNotPerformedList, parseCodeableConcept);
    if jsn.has('bodySite') then
      iterateArray(jsn.vArr['bodySite'], result.bodySiteList, parseCodeableConcept);
    if jsn.has('reasonCodeableConcept') {a4} then
      result.reason := ParseCodeableConcept(jsn.vObj['reasonCodeableConcept']);
    if jsn.has('reasonReference') {a3} then
      result.reason := ParseReference(jsn.vObj['reasonReference']);
    if jsn.has('performer') then
      iterateArray(jsn.vArr['performer'], result.performerList, parseProcedurePerformer);
    if jsn.has('performedPeriod') {a4} then
      result.performed := ParsePeriod(jsn.vObj['performedPeriod']);
    if jsn.has('performedDateTime') or jsn.has('_performedDateTime') then
      result.performed := ParseDateTime(jsn.node['performedDateTime'], jsn.vObj['_performedDateTime']);
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('location') then
        result.location := ParseReference{TFhirLocation}(jsn.vObj['location']);{q3}
    if jsn.has('outcome') then
        result.outcome := ParseCodeableConcept(jsn.vObj['outcome']);{q3}
    if jsn.has('report') then
      iterateArray(jsn.vArr['report'], result.reportList, parseReference{TFhirDiagnosticReport});
    if jsn.has('complication') then
      iterateArray(jsn.vArr['complication'], result.complicationList, parseCodeableConcept);
    if jsn.has('followUp') then
      iterateArray(jsn.vArr['followUp'], result.followUpList, parseCodeableConcept);
    if jsn.has('request') then
        result.request := ParseReference{Resource}(jsn.vObj['request']);{q3}
    if jsn.has('notes') then
      iterateArray(jsn.vArr['notes'], result.notesList, parseAnnotation);
    if jsn.has('focalDevice') then
      iterateArray(jsn.vArr['focalDevice'], result.focalDeviceList, parseProcedureFocalDevice);
    if jsn.has('used') then
      iterateArray(jsn.vArr['used'], result.usedList, parseReference{Resource});
end;

procedure TFHIRJsonComposer.ComposeProcedure(json : TJSONWriter; name : string; elem : TFhirProcedure; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirProcedureStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirProcedureStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeCodeableConcept(json, 'category', elem.category); {a}
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.notPerformed <> false)) and doCompose('notPerformed') then
    ComposeBooleanValue(json, 'notPerformed', elem.notPerformedElement, false);
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.notPerformed <> false)) and doCompose('notPerformed') then
    ComposeBooleanProps(json, 'notPerformed', elem.notPerformedElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('reasonNotPerformed') and (elem.reasonNotPerformedList.Count > 0) then
  begin
    startArray(json, 'reasonNotPerformed', elem.reasonNotPerformedList, false);
    for i := 0 to elem.reasonNotPerformedList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonNotPerformedList[i]); {z - CodeableConcept}
    finishArray(json, elem.reasonNotPerformedList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('bodySite') and (elem.bodySiteList.Count > 0) then
  begin
    startArray(json, 'bodySite', elem.bodySiteList, false);
    for i := 0 to elem.bodySiteList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.bodySiteList[i]); {z - CodeableConcept}
    finishArray(json, elem.bodySiteList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirReference) then
    ComposeReference(json, 'reasonReference', TFhirReference(elem.reason));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') and (elem.performerList.Count > 0) then
  begin
    startArray(json, 'performer', elem.performerList, false);
    for i := 0 to elem.performerList.Count - 1 do
      ComposeProcedurePerformer(json, '', elem.performerList[i]); {z - }
    finishArray(json, elem.performerList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.performed is TFhirPeriod) then 
    ComposePeriod(json, 'performedPeriod', TFhirPeriod(elem.performed)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.performed is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'performedDateTime', TFhirDateTime(elem.performed), false);
    ComposeDateTimeProps(json, 'performedDateTime', TFhirDateTime(elem.performed), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('location') then
    ComposeReference{TFhirLocation}(json, 'location', elem.location); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcome') then
    ComposeCodeableConcept(json, 'outcome', elem.outcome); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('report') and (elem.reportList.Count > 0) then
  begin
    startArray(json, 'report', elem.reportList, false);
    for i := 0 to elem.reportList.Count - 1 do
      ComposeReference{TFhirDiagnosticReport}(json, '', elem.reportList[i]); {z - Reference(DiagnosticReport)}
    finishArray(json, elem.reportList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('complication') and (elem.complicationList.Count > 0) then
  begin
    startArray(json, 'complication', elem.complicationList, false);
    for i := 0 to elem.complicationList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.complicationList[i]); {z - CodeableConcept}
    finishArray(json, elem.complicationList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('followUp') and (elem.followUpList.Count > 0) then
  begin
    startArray(json, 'followUp', elem.followUpList, false);
    for i := 0 to elem.followUpList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.followUpList[i]); {z - CodeableConcept}
    finishArray(json, elem.followUpList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('request') then
    ComposeReference{Resource}(json, 'request', elem.request); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('notes') and (elem.notesList.Count > 0) then
  begin
    startArray(json, 'notes', elem.notesList, false);
    for i := 0 to elem.notesList.Count - 1 do
      ComposeAnnotation(json, '', elem.notesList[i]); {z - Annotation}
    finishArray(json, elem.notesList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('focalDevice') and (elem.focalDeviceList.Count > 0) then
  begin
    startArray(json, 'focalDevice', elem.focalDeviceList, false);
    for i := 0 to elem.focalDeviceList.Count - 1 do
      ComposeProcedureFocalDevice(json, '', elem.focalDeviceList[i]); {z - }
    finishArray(json, elem.focalDeviceList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('used') and (elem.usedList.Count > 0) then
  begin
    startArray(json, 'used', elem.usedList, false);
    for i := 0 to elem.usedList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.usedList[i]); {z - Reference(Device|Medication|Substance)}
    finishArray(json, elem.usedList);
  end;
end;

{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROCEDUREREQUEST}
procedure TFHIRJsonParser.ParseProcedureRequest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProcedureRequest(jsn)); {2}
end;

function TFHIRJsonParser.ParseProcedureRequest(jsn : TJsonObject) : TFhirProcedureRequest;
begin
  result := TFhirProcedureRequest.create;
  try
    ParseProcedureRequestProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseProcedureRequestProperties(jsn : TJsonObject; result : TFhirProcedureRequest);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q3}
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('bodySite') then
      iterateArray(jsn.vArr['bodySite'], result.bodySiteList, parseCodeableConcept);
    if jsn.has('reasonCodeableConcept') {a4} then
      result.reason := ParseCodeableConcept(jsn.vObj['reasonCodeableConcept']);
    if jsn.has('reasonReference') {a3} then
      result.reason := ParseReference(jsn.vObj['reasonReference']);
    if jsn.has('scheduledPeriod') {a4} then
      result.scheduled := ParsePeriod(jsn.vObj['scheduledPeriod']);
    if jsn.has('scheduledTiming') {a4} then
      result.scheduled := ParseTiming(jsn.vObj['scheduledTiming']);
    if jsn.has('scheduledDateTime') or jsn.has('_scheduledDateTime') then
      result.scheduled := ParseDateTime(jsn.node['scheduledDateTime'], jsn.vObj['_scheduledDateTime']);
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('performer') then
        result.performer := ParseReference{Resource}(jsn.vObj['performer']);{q3}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirProcedureRequestStatusEnum, SYSTEMS_TFhirProcedureRequestStatusEnum);
    if jsn.has('notes') then
      iterateArray(jsn.vArr['notes'], result.notesList, parseAnnotation);
    if jsn.has('asNeededCodeableConcept') {a4} then
      result.asNeeded := ParseCodeableConcept(jsn.vObj['asNeededCodeableConcept']);
    if jsn.has('asNeededBoolean') or jsn.has('_asNeededBoolean') then
      result.asNeeded := ParseBoolean(jsn.node['asNeededBoolean'], jsn.vObj['_asNeededBoolean']);
    if jsn.has('orderedOn') or jsn.has('_orderedOn') then
        result.orderedOnElement := ParseDateTime(jsn.node['orderedOn'], jsn.vObj['_orderedOn']);{q}
    if jsn.has('orderer') then
        result.orderer := ParseReference{Resource}(jsn.vObj['orderer']);{q3}
    if jsn.has('priority') or jsn.has('_priority')  then
      result.priorityElement := parseEnum(jsn.path+'/priority', jsn.node['priority'], jsn.vObj['_priority'], CODES_TFhirProcedureRequestPriorityEnum, SYSTEMS_TFhirProcedureRequestPriorityEnum);
end;

procedure TFHIRJsonComposer.ComposeProcedureRequest(json : TJSONWriter; name : string; elem : TFhirProcedureRequest; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('bodySite') and (elem.bodySiteList.Count > 0) then
  begin
    startArray(json, 'bodySite', elem.bodySiteList, false);
    for i := 0 to elem.bodySiteList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.bodySiteList[i]); {z - CodeableConcept}
    finishArray(json, elem.bodySiteList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirReference) then
    ComposeReference(json, 'reasonReference', TFhirReference(elem.reason));
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.scheduled is TFhirPeriod) then 
    ComposePeriod(json, 'scheduledPeriod', TFhirPeriod(elem.scheduled)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.scheduled is TFhirTiming) then 
    ComposeTiming(json, 'scheduledTiming', TFhirTiming(elem.scheduled)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.scheduled is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'scheduledDateTime', TFhirDateTime(elem.scheduled), false);
    ComposeDateTimeProps(json, 'scheduledDateTime', TFhirDateTime(elem.scheduled), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') then
    ComposeReference{Resource}(json, 'performer', elem.performer); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirProcedureRequestStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirProcedureRequestStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('notes') and (elem.notesList.Count > 0) then
  begin
    startArray(json, 'notes', elem.notesList, false);
    for i := 0 to elem.notesList.Count - 1 do
      ComposeAnnotation(json, '', elem.notesList[i]); {z - Annotation}
    finishArray(json, elem.notesList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
    ComposeBooleanProps(json, 'asNeededBoolean', TFhirBoolean(elem.asNeeded), false);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('orderedOn') then
    ComposeDateTimeValue(json, 'orderedOn', elem.orderedOnElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('orderedOn') then
    ComposeDateTimeProps(json, 'orderedOn', elem.orderedOnElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('orderer') then
    ComposeReference{Resource}(json, 'orderer', elem.orderer); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnumValue(json, 'priority', elem.PriorityElement, CODES_TFhirProcedureRequestPriorityEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnumProps(json, 'priority', elem.PriorityElement, CODES_TFhirProcedureRequestPriorityEnum, false);
end;

{$ENDIF FHIR_PROCEDUREREQUEST}
{$IFDEF FHIR_PROCESSREQUEST}
procedure TFHIRJsonParser.ParseProcessRequestItem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProcessRequestItem(jsn)); {2}
end;

function TFHIRJsonParser.ParseProcessRequestItem(jsn : TJsonObject) : TFhirProcessRequestItem;
begin
  result := TFhirProcessRequestItem.create;
  try
    ParseProcessRequestItemProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseProcessRequestItemProperties(jsn : TJsonObject; result : TFhirProcessRequestItem);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('sequenceLinkId') or jsn.has('_sequenceLinkId') then
        result.sequenceLinkIdElement := ParseInteger(jsn.node['sequenceLinkId'], jsn.vObj['_sequenceLinkId']);{q}
end;

procedure TFHIRJsonComposer.ComposeProcessRequestItem(json : TJSONWriter; name : string; elem : TFhirProcessRequestItem; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeIntegerValue(json, 'sequenceLinkId', elem.sequenceLinkIdElement, false);
  ComposeIntegerProps(json, 'sequenceLinkId', elem.sequenceLinkIdElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseProcessRequest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProcessRequest(jsn)); {2}
end;

function TFHIRJsonParser.ParseProcessRequest(jsn : TJsonObject) : TFhirProcessRequest;
begin
  result := TFhirProcessRequest.create;
  try
    ParseProcessRequestProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseProcessRequestProperties(jsn : TJsonObject; result : TFhirProcessRequest);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('action') or jsn.has('_action')  then
      result.actionElement := parseEnum(jsn.path+'/action', jsn.node['action'], jsn.vObj['_action'], CODES_TFhirActionlistEnum, SYSTEMS_TFhirActionlistEnum);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('ruleset') then
        result.ruleset := ParseCoding(jsn.vObj['ruleset']);{q3}
    if jsn.has('originalRuleset') then
        result.originalRuleset := ParseCoding(jsn.vObj['originalRuleset']);{q3}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := ParseDateTime(jsn.node['created'], jsn.vObj['_created']);{q}
    if jsn.has('target') then
        result.target := ParseReference{TFhirOrganization}(jsn.vObj['target']);{q3}
    if jsn.has('provider') then
        result.provider := ParseReference{TFhirPractitioner}(jsn.vObj['provider']);{q3}
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q3}
    if jsn.has('request') then
        result.request := ParseReference{TFhirReference}(jsn.vObj['request']);{q3}
    if jsn.has('response') then
        result.response := ParseReference{TFhirReference}(jsn.vObj['response']);{q3}
    if jsn.has('nullify') or jsn.has('_nullify') then
        result.nullifyElement := ParseBoolean(jsn.node['nullify'], jsn.vObj['_nullify']);{q}
    if jsn.has('reference') or jsn.has('_reference') then
        result.referenceElement := ParseString(jsn.node['reference'], jsn.vObj['_reference']);{q}
    if jsn.has('item') then
      iterateArray(jsn.vArr['item'], result.itemList, parseProcessRequestItem);
      if jsn.has('include') or jsn.has('_include') then
      iteratePrimitiveArray(jsn.vArr['include'], jsn.vArr['_include'], result.includeList, parseString);
      if jsn.has('exclude') or jsn.has('_exclude') then
      iteratePrimitiveArray(jsn.vArr['exclude'], jsn.vArr['_exclude'], result.excludeList, parseString);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
end;

procedure TFHIRJsonComposer.ComposeProcessRequest(json : TJSONWriter; name : string; elem : TFhirProcessRequest; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeEnumValue(json, 'action', elem.ActionElement, CODES_TFhirActionlistEnum, false);
  ComposeEnumProps(json, 'action', elem.ActionElement, CODES_TFhirActionlistEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ruleset') then
    ComposeCoding(json, 'ruleset', elem.ruleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('originalRuleset') then
    ComposeCoding(json, 'originalRuleset', elem.originalRuleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('target') then
    ComposeReference{TFhirOrganization}(json, 'target', elem.target); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('provider') then
    ComposeReference{TFhirPractitioner}(json, 'provider', elem.provider); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('request') then
    ComposeReference{TFhirReference}(json, 'request', elem.request); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('response') then
    ComposeReference{TFhirReference}(json, 'response', elem.response); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('nullify') then
    ComposeBooleanValue(json, 'nullify', elem.nullifyElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('nullify') then
    ComposeBooleanProps(json, 'nullify', elem.nullifyElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reference') then
    ComposeStringValue(json, 'reference', elem.referenceElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reference') then
    ComposeStringProps(json, 'reference', elem.referenceElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('item') and (elem.itemList.Count > 0) then
  begin
    startArray(json, 'item', elem.itemList, false);
    for i := 0 to elem.itemList.Count - 1 do
      ComposeProcessRequestItem(json, '', elem.itemList[i]); {z - }
    finishArray(json, elem.itemList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('include') and (elem.includeList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.includeList.Count - 1 do
    begin
      ext := ext or ((elem.includeList[i].id <> '') or (elem.includeList[i].hasExtensionList) {no-comments or (elem.includeList[i].hasComments)});
      val := val or (elem.includeList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      startArray(json, 'include', elem.includeList, true);
      for i := 0 to elem.includeList.Count - 1 do
        ComposeStringValue(json, '',elem.includeList[i], true);
      finishArray(json, elem.includeList);
    end;
    if ext then
    begin
      startArray(json, '_include', elem.includeList, false);
      for i := 0 to elem.includeList.Count - 1 do
        ComposeStringProps(json, '',elem.includeList[i], true);
      finishArray(json, elem.includeList);
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('exclude') and (elem.excludeList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.excludeList.Count - 1 do
    begin
      ext := ext or ((elem.excludeList[i].id <> '') or (elem.excludeList[i].hasExtensionList) {no-comments or (elem.excludeList[i].hasComments)});
      val := val or (elem.excludeList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      startArray(json, 'exclude', elem.excludeList, true);
      for i := 0 to elem.excludeList.Count - 1 do
        ComposeStringValue(json, '',elem.excludeList[i], true);
      finishArray(json, elem.excludeList);
    end;
    if ext then
    begin
      startArray(json, '_exclude', elem.excludeList, false);
      for i := 0 to elem.excludeList.Count - 1 do
        ComposeStringProps(json, '',elem.excludeList[i], true);
      finishArray(json, elem.excludeList);
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(json, 'period', elem.period); {a}
end;

{$ENDIF FHIR_PROCESSREQUEST}
{$IFDEF FHIR_PROCESSRESPONSE}
procedure TFHIRJsonParser.ParseProcessResponseNotes(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProcessResponseNotes(jsn)); {2}
end;

function TFHIRJsonParser.ParseProcessResponseNotes(jsn : TJsonObject) : TFhirProcessResponseNotes;
begin
  result := TFhirProcessResponseNotes.create;
  try
    ParseProcessResponseNotesProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseProcessResponseNotesProperties(jsn : TJsonObject; result : TFhirProcessResponseNotes);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q3}
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn.node['text'], jsn.vObj['_text']);{q}
end;

procedure TFHIRJsonComposer.ComposeProcessResponseNotes(json : TJSONWriter; name : string; elem : TFhirProcessResponseNotes; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseProcessResponse(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProcessResponse(jsn)); {2}
end;

function TFHIRJsonParser.ParseProcessResponse(jsn : TJsonObject) : TFhirProcessResponse;
begin
  result := TFhirProcessResponse.create;
  try
    ParseProcessResponseProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseProcessResponseProperties(jsn : TJsonObject; result : TFhirProcessResponse);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('request') then
        result.request := ParseReference{TFhirReference}(jsn.vObj['request']);{q3}
    if jsn.has('outcome') then
        result.outcome := ParseCoding(jsn.vObj['outcome']);{q3}
    if jsn.has('disposition') or jsn.has('_disposition') then
        result.dispositionElement := ParseString(jsn.node['disposition'], jsn.vObj['_disposition']);{q}
    if jsn.has('ruleset') then
        result.ruleset := ParseCoding(jsn.vObj['ruleset']);{q3}
    if jsn.has('originalRuleset') then
        result.originalRuleset := ParseCoding(jsn.vObj['originalRuleset']);{q3}
    if jsn.has('created') or jsn.has('_created') then
        result.createdElement := ParseDateTime(jsn.node['created'], jsn.vObj['_created']);{q}
    if jsn.has('organization') then
        result.organization := ParseReference{TFhirOrganization}(jsn.vObj['organization']);{q3}
    if jsn.has('requestProvider') then
        result.requestProvider := ParseReference{TFhirPractitioner}(jsn.vObj['requestProvider']);{q3}
    if jsn.has('requestOrganization') then
        result.requestOrganization := ParseReference{TFhirOrganization}(jsn.vObj['requestOrganization']);{q3}
    if jsn.has('form') then
        result.form := ParseCoding(jsn.vObj['form']);{q3}
    if jsn.has('notes') then
      iterateArray(jsn.vArr['notes'], result.notesList, parseProcessResponseNotes);
    if jsn.has('error') then
      iterateArray(jsn.vArr['error'], result.errorList, parseCoding);
end;

procedure TFHIRJsonComposer.ComposeProcessResponse(json : TJSONWriter; name : string; elem : TFhirProcessResponse; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('request') then
    ComposeReference{TFhirReference}(json, 'request', elem.request); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcome') then
    ComposeCoding(json, 'outcome', elem.outcome); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('disposition') then
    ComposeStringValue(json, 'disposition', elem.dispositionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('disposition') then
    ComposeStringProps(json, 'disposition', elem.dispositionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ruleset') then
    ComposeCoding(json, 'ruleset', elem.ruleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('originalRuleset') then
    ComposeCoding(json, 'originalRuleset', elem.originalRuleset); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTimeValue(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTimeProps(json, 'created', elem.createdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(json, 'organization', elem.organization); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestProvider') then
    ComposeReference{TFhirPractitioner}(json, 'requestProvider', elem.requestProvider); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestOrganization') then
    ComposeReference{TFhirOrganization}(json, 'requestOrganization', elem.requestOrganization); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('form') then
    ComposeCoding(json, 'form', elem.form); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('notes') and (elem.notesList.Count > 0) then
  begin
    startArray(json, 'notes', elem.notesList, false);
    for i := 0 to elem.notesList.Count - 1 do
      ComposeProcessResponseNotes(json, '', elem.notesList[i]); {z - }
    finishArray(json, elem.notesList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('error') and (elem.errorList.Count > 0) then
  begin
    startArray(json, 'error', elem.errorList, false);
    for i := 0 to elem.errorList.Count - 1 do
      ComposeCoding(json, '', elem.errorList[i]); {z - Coding}
    finishArray(json, elem.errorList);
  end;
end;

{$ENDIF FHIR_PROCESSRESPONSE}
{$IFDEF FHIR_PROVENANCE}
procedure TFHIRJsonParser.ParseProvenanceAgent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProvenanceAgent(jsn)); {2}
end;

function TFHIRJsonParser.ParseProvenanceAgent(jsn : TJsonObject) : TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent.create;
  try
    ParseProvenanceAgentProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseProvenanceAgentProperties(jsn : TJsonObject; result : TFhirProvenanceAgent);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('role') then
        result.role := ParseCoding(jsn.vObj['role']);{q3}
    if jsn.has('actor') then
        result.actor := ParseReference{Resource}(jsn.vObj['actor']);{q3}
    if jsn.has('userId') then
        result.userId := ParseIdentifier(jsn.vObj['userId']);{q3}
    if jsn.has('relatedAgent') then
      iterateArray(jsn.vArr['relatedAgent'], result.relatedAgentList, parseProvenanceAgentRelatedAgent);
end;

procedure TFHIRJsonComposer.ComposeProvenanceAgent(json : TJSONWriter; name : string; elem : TFhirProvenanceAgent; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeCoding(json, 'role', elem.role); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(json, 'actor', elem.actor); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'userId', elem.userId); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.relatedAgentList.Count > 0) then
  begin
    startArray(json, 'relatedAgent', elem.relatedAgentList, false);
    for i := 0 to elem.relatedAgentList.Count - 1 do
      ComposeProvenanceAgentRelatedAgent(json, '', elem.relatedAgentList[i]); {z - }
    finishArray(json, elem.relatedAgentList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseProvenanceAgentRelatedAgent(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProvenanceAgentRelatedAgent(jsn)); {2}
end;

function TFHIRJsonParser.ParseProvenanceAgentRelatedAgent(jsn : TJsonObject) : TFhirProvenanceAgentRelatedAgent;
begin
  result := TFhirProvenanceAgentRelatedAgent.create;
  try
    ParseProvenanceAgentRelatedAgentProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseProvenanceAgentRelatedAgentProperties(jsn : TJsonObject; result : TFhirProvenanceAgentRelatedAgent);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('target') or jsn.has('_target') then
        result.targetElement := ParseUri(jsn.node['target'], jsn.vObj['_target']);{q}
end;

procedure TFHIRJsonComposer.ComposeProvenanceAgentRelatedAgent(json : TJSONWriter; name : string; elem : TFhirProvenanceAgentRelatedAgent; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeUriValue(json, 'target', elem.targetElement, false);
  ComposeUriProps(json, 'target', elem.targetElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseProvenanceEntity(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProvenanceEntity(jsn)); {2}
end;

function TFHIRJsonParser.ParseProvenanceEntity(jsn : TJsonObject) : TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity.create;
  try
    ParseProvenanceEntityProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseProvenanceEntityProperties(jsn : TJsonObject; result : TFhirProvenanceEntity);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('role') or jsn.has('_role')  then
      result.roleElement := parseEnum(jsn.path+'/role', jsn.node['role'], jsn.vObj['_role'], CODES_TFhirProvenanceEntityRoleEnum, SYSTEMS_TFhirProvenanceEntityRoleEnum);
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q3}
    if jsn.has('reference') or jsn.has('_reference') then
        result.referenceElement := ParseUri(jsn.node['reference'], jsn.vObj['_reference']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.displayElement := ParseString(jsn.node['display'], jsn.vObj['_display']);{q}
    if jsn.has('agent') then
        result.agent := ParseProvenanceAgent(jsn.vObj['agent']);{q3}
end;

procedure TFHIRJsonComposer.ComposeProvenanceEntity(json : TJSONWriter; name : string; elem : TFhirProvenanceEntity; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'role', elem.RoleElement, CODES_TFhirProvenanceEntityRoleEnum, false);
  ComposeEnumProps(json, 'role', elem.RoleElement, CODES_TFhirProvenanceEntityRoleEnum, false);
  ComposeCoding(json, 'type', elem.type_); {a}
  ComposeUriValue(json, 'reference', elem.referenceElement, false);
  ComposeUriProps(json, 'reference', elem.referenceElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'display', elem.displayElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'display', elem.displayElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeProvenanceAgent(json, 'agent', elem.agent); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseProvenance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseProvenance(jsn)); {2}
end;

function TFHIRJsonParser.ParseProvenance(jsn : TJsonObject) : TFhirProvenance;
begin
  result := TFhirProvenance.create;
  try
    ParseProvenanceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseProvenanceProperties(jsn : TJsonObject; result : TFhirProvenance);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('target') then
      iterateArray(jsn.vArr['target'], result.targetList, parseReference{TFhirReference});
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
    if jsn.has('recorded') or jsn.has('_recorded') then
        result.recordedElement := ParseInstant(jsn.node['recorded'], jsn.vObj['_recorded']);{q}
    if jsn.has('reason') then
      iterateArray(jsn.vArr['reason'], result.reasonList, parseCodeableConcept);
    if jsn.has('activity') then
        result.activity := ParseCodeableConcept(jsn.vObj['activity']);{q3}
    if jsn.has('location') then
        result.location := ParseReference{TFhirLocation}(jsn.vObj['location']);{q3}
      if jsn.has('policy') or jsn.has('_policy') then
      iteratePrimitiveArray(jsn.vArr['policy'], jsn.vArr['_policy'], result.policyList, parseUri);
    if jsn.has('agent') then
      iterateArray(jsn.vArr['agent'], result.agentList, parseProvenanceAgent);
    if jsn.has('entity') then
      iterateArray(jsn.vArr['entity'], result.entityList, parseProvenanceEntity);
    if jsn.has('signature') then
      iterateArray(jsn.vArr['signature'], result.signatureList, parseSignature);
end;

procedure TFHIRJsonComposer.ComposeProvenance(json : TJSONWriter; name : string; elem : TFhirProvenance; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (elem.targetList.Count > 0) then
  begin
    startArray(json, 'target', elem.targetList, false);
    for i := 0 to elem.targetList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.targetList[i]); {z - Reference(Any)}
    finishArray(json, elem.targetList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(json, 'period', elem.period); {a}
  ComposeInstantValue(json, 'recorded', elem.recordedElement, false);
  ComposeInstantProps(json, 'recorded', elem.recordedElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reason') and (elem.reasonList.Count > 0) then
  begin
    startArray(json, 'reason', elem.reasonList, false);
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.reasonList[i]); {z - CodeableConcept}
    finishArray(json, elem.reasonList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('activity') then
    ComposeCodeableConcept(json, 'activity', elem.activity); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('location') then
    ComposeReference{TFhirLocation}(json, 'location', elem.location); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('policy') and (elem.policyList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.policyList.Count - 1 do
    begin
      ext := ext or ((elem.policyList[i].id <> '') or (elem.policyList[i].hasExtensionList) {no-comments or (elem.policyList[i].hasComments)});
      val := val or (elem.policyList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      startArray(json, 'policy', elem.policyList, true);
      for i := 0 to elem.policyList.Count - 1 do
        ComposeUriValue(json, '',elem.policyList[i], true);
      finishArray(json, elem.policyList);
    end;
    if ext then
    begin
      startArray(json, '_policy', elem.policyList, false);
      for i := 0 to elem.policyList.Count - 1 do
        ComposeUriProps(json, '',elem.policyList[i], true);
      finishArray(json, elem.policyList);
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('agent') and (elem.agentList.Count > 0) then
  begin
    startArray(json, 'agent', elem.agentList, false);
    for i := 0 to elem.agentList.Count - 1 do
      ComposeProvenanceAgent(json, '', elem.agentList[i]); {z - }
    finishArray(json, elem.agentList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('entity') and (elem.entityList.Count > 0) then
  begin
    startArray(json, 'entity', elem.entityList, false);
    for i := 0 to elem.entityList.Count - 1 do
      ComposeProvenanceEntity(json, '', elem.entityList[i]); {z - }
    finishArray(json, elem.entityList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('signature') and (elem.signatureList.Count > 0) then
  begin
    startArray(json, 'signature', elem.signatureList, false);
    for i := 0 to elem.signatureList.Count - 1 do
      ComposeSignature(json, '', elem.signatureList[i]); {z - Signature}
    finishArray(json, elem.signatureList);
  end;
end;

{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
procedure TFHIRJsonParser.ParseQuestionnaireGroup(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuestionnaireGroup(jsn)); {2}
end;

function TFHIRJsonParser.ParseQuestionnaireGroup(jsn : TJsonObject) : TFhirQuestionnaireGroup;
begin
  result := TFhirQuestionnaireGroup.create;
  try
    ParseQuestionnaireGroupProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseQuestionnaireGroupProperties(jsn : TJsonObject; result : TFhirQuestionnaireGroup);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('linkId') or jsn.has('_linkId') then
        result.linkIdElement := ParseString(jsn.node['linkId'], jsn.vObj['_linkId']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := ParseString(jsn.node['title'], jsn.vObj['_title']);{q}
    if jsn.has('concept') then
      iterateArray(jsn.vArr['concept'], result.conceptList, parseCoding);
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn.node['text'], jsn.vObj['_text']);{q}
    if jsn.has('required') or jsn.has('_required') then
        result.requiredElement := ParseBoolean(jsn.node['required'], jsn.vObj['_required']);{q}
    if jsn.has('repeats') or jsn.has('_repeats') then
        result.repeatsElement := ParseBoolean(jsn.node['repeats'], jsn.vObj['_repeats']);{q}
    if jsn.has('group') then
      iterateArray(jsn.vArr['group'], result.groupList, parseQuestionnaireGroup);
    if jsn.has('question') then
      iterateArray(jsn.vArr['question'], result.questionList, parseQuestionnaireGroupQuestion);
end;

procedure TFHIRJsonComposer.ComposeQuestionnaireGroup(json : TJSONWriter; name : string; elem : TFhirQuestionnaireGroup; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'linkId', elem.linkIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'linkId', elem.linkIdElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.conceptList.Count > 0) then
  begin
    startArray(json, 'concept', elem.conceptList, false);
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeCoding(json, '', elem.conceptList[i]); {z - Coding}
    finishArray(json, elem.conceptList);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.required <> false)) then
    ComposeBooleanValue(json, 'required', elem.requiredElement, false);
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.required <> false)) then
    ComposeBooleanProps(json, 'required', elem.requiredElement, false);
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.repeats <> false)) then
    ComposeBooleanValue(json, 'repeats', elem.repeatsElement, false);
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.repeats <> false)) then
    ComposeBooleanProps(json, 'repeats', elem.repeatsElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.groupList.Count > 0) then
  begin
    startArray(json, 'group', elem.groupList, false);
    for i := 0 to elem.groupList.Count - 1 do
      ComposeQuestionnaireGroup(json, '', elem.groupList[i]); {z - @Questionnaire.group}
    finishArray(json, elem.groupList);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.questionList.Count > 0) then
  begin
    startArray(json, 'question', elem.questionList, false);
    for i := 0 to elem.questionList.Count - 1 do
      ComposeQuestionnaireGroupQuestion(json, '', elem.questionList[i]); {z - }
    finishArray(json, elem.questionList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseQuestionnaireGroupQuestion(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuestionnaireGroupQuestion(jsn)); {2}
end;

function TFHIRJsonParser.ParseQuestionnaireGroupQuestion(jsn : TJsonObject) : TFhirQuestionnaireGroupQuestion;
begin
  result := TFhirQuestionnaireGroupQuestion.create;
  try
    ParseQuestionnaireGroupQuestionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseQuestionnaireGroupQuestionProperties(jsn : TJsonObject; result : TFhirQuestionnaireGroupQuestion);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('linkId') or jsn.has('_linkId') then
        result.linkIdElement := ParseString(jsn.node['linkId'], jsn.vObj['_linkId']);{q}
    if jsn.has('concept') then
      iterateArray(jsn.vArr['concept'], result.conceptList, parseCoding);
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn.node['text'], jsn.vObj['_text']);{q}
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirAnswerFormatEnum, SYSTEMS_TFhirAnswerFormatEnum);
    if jsn.has('required') or jsn.has('_required') then
        result.requiredElement := ParseBoolean(jsn.node['required'], jsn.vObj['_required']);{q}
    if jsn.has('repeats') or jsn.has('_repeats') then
        result.repeatsElement := ParseBoolean(jsn.node['repeats'], jsn.vObj['_repeats']);{q}
    if jsn.has('options') then
        result.options := ParseReference{TFhirValueSet}(jsn.vObj['options']);{q3}
    if jsn.has('option') then
      iterateArray(jsn.vArr['option'], result.optionList, parseCoding);
    if jsn.has('group') then
      iterateArray(jsn.vArr['group'], result.groupList, parseQuestionnaireGroup);
end;

procedure TFHIRJsonComposer.ComposeQuestionnaireGroupQuestion(json : TJSONWriter; name : string; elem : TFhirQuestionnaireGroupQuestion; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'linkId', elem.linkIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'linkId', elem.linkIdElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.conceptList.Count > 0) then
  begin
    startArray(json, 'concept', elem.conceptList, false);
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeCoding(json, '', elem.conceptList[i]); {z - Coding}
    finishArray(json, elem.conceptList);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirAnswerFormatEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirAnswerFormatEnum, false);
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.required <> false)) then
    ComposeBooleanValue(json, 'required', elem.requiredElement, false);
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.required <> false)) then
    ComposeBooleanProps(json, 'required', elem.requiredElement, false);
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.repeats <> false)) then
    ComposeBooleanValue(json, 'repeats', elem.repeatsElement, false);
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.repeats <> false)) then
    ComposeBooleanProps(json, 'repeats', elem.repeatsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirValueSet}(json, 'options', elem.options); {a}
  if (SummaryOption in [soFull, soData]) and (elem.optionList.Count > 0) then
  begin
    startArray(json, 'option', elem.optionList, false);
    for i := 0 to elem.optionList.Count - 1 do
      ComposeCoding(json, '', elem.optionList[i]); {z - Coding}
    finishArray(json, elem.optionList);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.groupList.Count > 0) then
  begin
    startArray(json, 'group', elem.groupList, false);
    for i := 0 to elem.groupList.Count - 1 do
      ComposeQuestionnaireGroup(json, '', elem.groupList[i]); {z - @Questionnaire.group}
    finishArray(json, elem.groupList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseQuestionnaire(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuestionnaire(jsn)); {2}
end;

function TFHIRJsonParser.ParseQuestionnaire(jsn : TJsonObject) : TFhirQuestionnaire;
begin
  result := TFhirQuestionnaire.create;
  try
    ParseQuestionnaireProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseQuestionnaireProperties(jsn : TJsonObject; result : TFhirQuestionnaire);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirQuestionnaireStatusEnum, SYSTEMS_TFhirQuestionnaireStatusEnum);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := ParseString(jsn.node['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('subjectType') or jsn.has('_subjectType') then
      iterateEnumArray(jsn.vArr['subjectType'], jsn.vArr['_subjectType'], jsn.path+'/subjectType', result.subjectType, parseEnum, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    if jsn.has('group') then
        result.group := ParseQuestionnaireGroup(jsn.vObj['group']);{q3}
end;

procedure TFHIRJsonComposer.ComposeQuestionnaire(json : TJSONWriter; name : string; elem : TFhirQuestionnaire; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirQuestionnaireStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirQuestionnaireStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('telecom') and (elem.telecomList.Count > 0) then
  begin
    startArray(json, 'telecom', elem.telecomList, false);
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    finishArray(json, elem.telecomList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subjectType') and (elem.subjectType.Count > 0) then
  begin
    val := false;
    ext := false;
    for i := 0 to elem.subjectType.Count - 1 do
    begin
      val := val or (elem.subjectType[i].hasPrimitiveValue);
      ext := ext or ((elem.subjectType[i].id <> '') or (elem.subjectType[i].hasExtensionList));
    end;
    if val then
    begin
      startArray(json, 'subjectType', elem.subjectTypeList, true);
      for i := 0 to elem.subjectType.Count - 1 do
        ComposeEnumValue(json, '', elem.subjectType[i], CODES_TFhirResourceTypesEnum, true);
      finishArray(json, elem.subjectTypeList);
    end;
    if ext then
    begin
      startArray(json, '_subjectType', elem.subjectTypeList, false);
      for i := 0 to elem.subjectType.Count - 1 do
        ComposeEnumProps(json, '', elem.subjectType[i], CODES_TFhirResourceTypesEnum, true);
      finishArray(json, elem.subjectTypeList);
    end;
  end;
  ComposeQuestionnaireGroup(json, 'group', elem.group); {a}
end;

{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
procedure TFHIRJsonParser.ParseQuestionnaireResponseGroup(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuestionnaireResponseGroup(jsn)); {2}
end;

function TFHIRJsonParser.ParseQuestionnaireResponseGroup(jsn : TJsonObject) : TFhirQuestionnaireResponseGroup;
begin
  result := TFhirQuestionnaireResponseGroup.create;
  try
    ParseQuestionnaireResponseGroupProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseQuestionnaireResponseGroupProperties(jsn : TJsonObject; result : TFhirQuestionnaireResponseGroup);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('linkId') or jsn.has('_linkId') then
        result.linkIdElement := ParseString(jsn.node['linkId'], jsn.vObj['_linkId']);{q}
    if jsn.has('title') or jsn.has('_title') then
        result.titleElement := ParseString(jsn.node['title'], jsn.vObj['_title']);{q}
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn.node['text'], jsn.vObj['_text']);{q}
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirReference}(jsn.vObj['subject']);{q3}
    if jsn.has('group') then
      iterateArray(jsn.vArr['group'], result.groupList, parseQuestionnaireResponseGroup);
    if jsn.has('question') then
      iterateArray(jsn.vArr['question'], result.questionList, parseQuestionnaireResponseGroupQuestion);
end;

procedure TFHIRJsonComposer.ComposeQuestionnaireResponseGroup(json : TJSONWriter; name : string; elem : TFhirQuestionnaireResponseGroup; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'linkId', elem.linkIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'linkId', elem.linkIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'title', elem.titleElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soData]) and (elem.groupList.Count > 0) then
  begin
    startArray(json, 'group', elem.groupList, false);
    for i := 0 to elem.groupList.Count - 1 do
      ComposeQuestionnaireResponseGroup(json, '', elem.groupList[i]); {z - @QuestionnaireResponse.group}
    finishArray(json, elem.groupList);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.questionList.Count > 0) then
  begin
    startArray(json, 'question', elem.questionList, false);
    for i := 0 to elem.questionList.Count - 1 do
      ComposeQuestionnaireResponseGroupQuestion(json, '', elem.questionList[i]); {z - }
    finishArray(json, elem.questionList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseQuestionnaireResponseGroupQuestion(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuestionnaireResponseGroupQuestion(jsn)); {2}
end;

function TFHIRJsonParser.ParseQuestionnaireResponseGroupQuestion(jsn : TJsonObject) : TFhirQuestionnaireResponseGroupQuestion;
begin
  result := TFhirQuestionnaireResponseGroupQuestion.create;
  try
    ParseQuestionnaireResponseGroupQuestionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseQuestionnaireResponseGroupQuestionProperties(jsn : TJsonObject; result : TFhirQuestionnaireResponseGroupQuestion);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('linkId') or jsn.has('_linkId') then
        result.linkIdElement := ParseString(jsn.node['linkId'], jsn.vObj['_linkId']);{q}
    if jsn.has('text') or jsn.has('_text') then
        result.textElement := ParseString(jsn.node['text'], jsn.vObj['_text']);{q}
    if jsn.has('answer') then
      iterateArray(jsn.vArr['answer'], result.answerList, parseQuestionnaireResponseGroupQuestionAnswer);
end;

procedure TFHIRJsonComposer.ComposeQuestionnaireResponseGroupQuestion(json : TJSONWriter; name : string; elem : TFhirQuestionnaireResponseGroupQuestion; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'linkId', elem.linkIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'linkId', elem.linkIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'text', elem.textElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.answerList.Count > 0) then
  begin
    startArray(json, 'answer', elem.answerList, false);
    for i := 0 to elem.answerList.Count - 1 do
      ComposeQuestionnaireResponseGroupQuestionAnswer(json, '', elem.answerList[i]); {z - }
    finishArray(json, elem.answerList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseQuestionnaireResponseGroupQuestionAnswer(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuestionnaireResponseGroupQuestionAnswer(jsn)); {2}
end;

function TFHIRJsonParser.ParseQuestionnaireResponseGroupQuestionAnswer(jsn : TJsonObject) : TFhirQuestionnaireResponseGroupQuestionAnswer;
begin
  result := TFhirQuestionnaireResponseGroupQuestionAnswer.create;
  try
    ParseQuestionnaireResponseGroupQuestionAnswerProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseQuestionnaireResponseGroupQuestionAnswerProperties(jsn : TJsonObject; result : TFhirQuestionnaireResponseGroupQuestionAnswer);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('valueAttachment') {a4} then
      result.value := ParseAttachment(jsn.vObj['valueAttachment']);
    if jsn.has('valueCoding') {a4} then
      result.value := ParseCoding(jsn.vObj['valueCoding']);
    if jsn.has('valueQuantity') {a4} then
      result.value := ParseQuantity(jsn.vObj['valueQuantity']);
    if jsn.has('valueReference') {a3} then
      result.value := ParseReference(jsn.vObj['valueReference']);
    if jsn.has('valueBoolean') or jsn.has('_valueBoolean') then
      result.value := ParseBoolean(jsn.node['valueBoolean'], jsn.vObj['_valueBoolean']);
    if jsn.has('valueDecimal') or jsn.has('_valueDecimal') then
      result.value := ParseDecimal(jsn.node['valueDecimal'], jsn.vObj['_valueDecimal']);
    if jsn.has('valueInteger') or jsn.has('_valueInteger') then
      result.value := ParseInteger(jsn.node['valueInteger'], jsn.vObj['_valueInteger']);
    if jsn.has('valueDate') or jsn.has('_valueDate') then
      result.value := ParseDate(jsn.node['valueDate'], jsn.vObj['_valueDate']);
    if jsn.has('valueDateTime') or jsn.has('_valueDateTime') then
      result.value := ParseDateTime(jsn.node['valueDateTime'], jsn.vObj['_valueDateTime']);
    if jsn.has('valueInstant') or jsn.has('_valueInstant') then
      result.value := ParseInstant(jsn.node['valueInstant'], jsn.vObj['_valueInstant']);
    if jsn.has('valueTime') or jsn.has('_valueTime') then
      result.value := ParseTime(jsn.node['valueTime'], jsn.vObj['_valueTime']);
    if jsn.has('valueString') or jsn.has('_valueString') then
      result.value := ParseString(jsn.node['valueString'], jsn.vObj['_valueString']);
    if jsn.has('valueUri') or jsn.has('_valueUri') then
      result.value := ParseUri(jsn.node['valueUri'], jsn.vObj['_valueUri']);
    if jsn.has('group') then
      iterateArray(jsn.vArr['group'], result.groupList, parseQuestionnaireResponseGroup);
end;

procedure TFHIRJsonComposer.ComposeQuestionnaireResponseGroupQuestionAnswer(json : TJSONWriter; name : string; elem : TFhirQuestionnaireResponseGroupQuestionAnswer; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.value is TFhirAttachment) then 
    ComposeAttachment(json, 'valueAttachment', TFhirAttachment(elem.value)) 
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirCoding) then 
    ComposeCoding(json, 'valueCoding', TFhirCoding(elem.value)) 
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirQuantity) then 
    ComposeQuantity(json, 'valueQuantity', TFhirQuantity(elem.value)) 
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirReference) then
    ComposeReference(json, 'valueReference', TFhirReference(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'valueBoolean', TFhirBoolean(elem.value), false);
    ComposeBooleanProps(json, 'valueBoolean', TFhirBoolean(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirDecimal) then 
  begin
    ComposeDecimalValue(json, 'valueDecimal', TFhirDecimal(elem.value), false);
    ComposeDecimalProps(json, 'valueDecimal', TFhirDecimal(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirInteger) then 
  begin
    ComposeIntegerValue(json, 'valueInteger', TFhirInteger(elem.value), false);
    ComposeIntegerProps(json, 'valueInteger', TFhirInteger(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirDate) then 
  begin
    ComposeDateValue(json, 'valueDate', TFhirDate(elem.value), false);
    ComposeDateProps(json, 'valueDate', TFhirDate(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'valueDateTime', TFhirDateTime(elem.value), false);
    ComposeDateTimeProps(json, 'valueDateTime', TFhirDateTime(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirInstant) then 
  begin
    ComposeInstantValue(json, 'valueInstant', TFhirInstant(elem.value), false);
    ComposeInstantProps(json, 'valueInstant', TFhirInstant(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirTime) then 
  begin
    ComposeTimeValue(json, 'valueTime', TFhirTime(elem.value), false);
    ComposeTimeProps(json, 'valueTime', TFhirTime(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirString) then 
  begin
    ComposeStringValue(json, 'valueString', TFhirString(elem.value), false);
    ComposeStringProps(json, 'valueString', TFhirString(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirUri) then 
  begin
    ComposeUriValue(json, 'valueUri', TFhirUri(elem.value), false);
    ComposeUriProps(json, 'valueUri', TFhirUri(elem.value), false);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.groupList.Count > 0) then
  begin
    startArray(json, 'group', elem.groupList, false);
    for i := 0 to elem.groupList.Count - 1 do
      ComposeQuestionnaireResponseGroup(json, '', elem.groupList[i]); {z - @QuestionnaireResponse.group}
    finishArray(json, elem.groupList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseQuestionnaireResponse(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseQuestionnaireResponse(jsn)); {2}
end;

function TFHIRJsonParser.ParseQuestionnaireResponse(jsn : TJsonObject) : TFhirQuestionnaireResponse;
begin
  result := TFhirQuestionnaireResponse.create;
  try
    ParseQuestionnaireResponseProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseQuestionnaireResponseProperties(jsn : TJsonObject; result : TFhirQuestionnaireResponse);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('questionnaire') then
        result.questionnaire := ParseReference{TFhirQuestionnaire}(jsn.vObj['questionnaire']);{q3}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirQuestionnaireAnswersStatusEnum, SYSTEMS_TFhirQuestionnaireAnswersStatusEnum);
    if jsn.has('subject') then
        result.subject := ParseReference{TFhirReference}(jsn.vObj['subject']);{q3}
    if jsn.has('author') then
        result.author := ParseReference{Resource}(jsn.vObj['author']);{q3}
    if jsn.has('authored') or jsn.has('_authored') then
        result.authoredElement := ParseDateTime(jsn.node['authored'], jsn.vObj['_authored']);{q}
    if jsn.has('source') then
        result.source := ParseReference{Resource}(jsn.vObj['source']);{q3}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('group') then
        result.group := ParseQuestionnaireResponseGroup(jsn.vObj['group']);{q3}
end;

procedure TFHIRJsonComposer.ComposeQuestionnaireResponse(json : TJSONWriter; name : string; elem : TFhirQuestionnaireResponse; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('questionnaire') then
    ComposeReference{TFhirQuestionnaire}(json, 'questionnaire', elem.questionnaire); {a}
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirQuestionnaireAnswersStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirQuestionnaireAnswersStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirReference}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{Resource}(json, 'author', elem.author); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authored') then
    ComposeDateTimeValue(json, 'authored', elem.authoredElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authored') then
    ComposeDateTimeProps(json, 'authored', elem.authoredElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('source') then
    ComposeReference{Resource}(json, 'source', elem.source); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('group') then
    ComposeQuestionnaireResponseGroup(json, 'group', elem.group); {a}
end;

{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REFERRALREQUEST}
procedure TFHIRJsonParser.ParseReferralRequest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseReferralRequest(jsn)); {2}
end;

function TFHIRJsonParser.ParseReferralRequest(jsn : TJsonObject) : TFhirReferralRequest;
begin
  result := TFhirReferralRequest.create;
  try
    ParseReferralRequestProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseReferralRequestProperties(jsn : TJsonObject; result : TFhirReferralRequest);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirReferralstatusEnum, SYSTEMS_TFhirReferralstatusEnum);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('specialty') then
        result.specialty := ParseCodeableConcept(jsn.vObj['specialty']);{q3}
    if jsn.has('priority') then
        result.priority := ParseCodeableConcept(jsn.vObj['priority']);{q3}
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
    if jsn.has('requester') then
        result.requester := ParseReference{Resource}(jsn.vObj['requester']);{q3}
    if jsn.has('recipient') then
      iterateArray(jsn.vArr['recipient'], result.recipientList, parseReference{Resource});
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('dateSent') or jsn.has('_dateSent') then
        result.dateSentElement := ParseDateTime(jsn.node['dateSent'], jsn.vObj['_dateSent']);{q}
    if jsn.has('reason') then
        result.reason := ParseCodeableConcept(jsn.vObj['reason']);{q3}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('serviceRequested') then
      iterateArray(jsn.vArr['serviceRequested'], result.serviceRequestedList, parseCodeableConcept);
    if jsn.has('supportingInformation') then
      iterateArray(jsn.vArr['supportingInformation'], result.supportingInformationList, parseReference{TFhirReference});
    if jsn.has('fulfillmentTime') then
        result.fulfillmentTime := ParsePeriod(jsn.vObj['fulfillmentTime']);{q3}
end;

procedure TFHIRJsonComposer.ComposeReferralRequest(json : TJSONWriter; name : string; elem : TFhirReferralRequest; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirReferralstatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirReferralstatusEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('specialty') then
    ComposeCodeableConcept(json, 'specialty', elem.specialty); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeCodeableConcept(json, 'priority', elem.priority); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requester') then
    ComposeReference{Resource}(json, 'requester', elem.requester); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recipient') and (elem.recipientList.Count > 0) then
  begin
    startArray(json, 'recipient', elem.recipientList, false);
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{Resource}(json, '', elem.recipientList[i]); {z - Reference(Practitioner|Organization)}
    finishArray(json, elem.recipientList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dateSent') then
    ComposeDateTimeValue(json, 'dateSent', elem.dateSentElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dateSent') then
    ComposeDateTimeProps(json, 'dateSent', elem.dateSentElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reason') then
    ComposeCodeableConcept(json, 'reason', elem.reason); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('serviceRequested') and (elem.serviceRequestedList.Count > 0) then
  begin
    startArray(json, 'serviceRequested', elem.serviceRequestedList, false);
    for i := 0 to elem.serviceRequestedList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.serviceRequestedList[i]); {z - CodeableConcept}
    finishArray(json, elem.serviceRequestedList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('supportingInformation') and (elem.supportingInformationList.Count > 0) then
  begin
    startArray(json, 'supportingInformation', elem.supportingInformationList, false);
    for i := 0 to elem.supportingInformationList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.supportingInformationList[i]); {z - Reference(Any)}
    finishArray(json, elem.supportingInformationList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('fulfillmentTime') then
    ComposePeriod(json, 'fulfillmentTime', elem.fulfillmentTime); {a}
end;

{$ENDIF FHIR_REFERRALREQUEST}
{$IFDEF FHIR_RELATEDPERSON}
procedure TFHIRJsonParser.ParseRelatedPerson(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseRelatedPerson(jsn)); {2}
end;

function TFHIRJsonParser.ParseRelatedPerson(jsn : TJsonObject) : TFhirRelatedPerson;
begin
  result := TFhirRelatedPerson.create;
  try
    ParseRelatedPersonProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseRelatedPersonProperties(jsn : TJsonObject; result : TFhirRelatedPerson);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
    if jsn.has('relationship') then
        result.relationship := ParseCodeableConcept(jsn.vObj['relationship']);{q3}
    if jsn.has('name') then
        result.name := ParseHumanName(jsn.vObj['name']);{q3}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
    if jsn.has('gender') or jsn.has('_gender')  then
      result.genderElement := parseEnum(jsn.path+'/gender', jsn.node['gender'], jsn.vObj['_gender'], CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum);
    if jsn.has('birthDate') or jsn.has('_birthDate') then
        result.birthDateElement := ParseDate(jsn.node['birthDate'], jsn.vObj['_birthDate']);{q}
    if jsn.has('address') then
      iterateArray(jsn.vArr['address'], result.addressList, parseAddress);
    if jsn.has('photo') then
      iterateArray(jsn.vArr['photo'], result.photoList, parseAttachment);
    if jsn.has('period') then
        result.period := ParsePeriod(jsn.vObj['period']);{q3}
end;

procedure TFHIRJsonComposer.ComposeRelatedPerson(json : TJSONWriter; name : string; elem : TFhirRelatedPerson; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('relationship') then
    ComposeCodeableConcept(json, 'relationship', elem.relationship); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeHumanName(json, 'name', elem.name); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('telecom') and (elem.telecomList.Count > 0) then
  begin
    startArray(json, 'telecom', elem.telecomList, false);
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    finishArray(json, elem.telecomList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gender') then
    ComposeEnumValue(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gender') then
    ComposeEnumProps(json, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('birthDate') then
    ComposeDateValue(json, 'birthDate', elem.birthDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('birthDate') then
    ComposeDateProps(json, 'birthDate', elem.birthDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('address') and (elem.addressList.Count > 0) then
  begin
    startArray(json, 'address', elem.addressList, false);
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(json, '', elem.addressList[i]); {z - Address}
    finishArray(json, elem.addressList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('photo') and (elem.photoList.Count > 0) then
  begin
    startArray(json, 'photo', elem.photoList, false);
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(json, '', elem.photoList[i]); {z - Attachment}
    finishArray(json, elem.photoList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('period') then
    ComposePeriod(json, 'period', elem.period); {a}
end;

{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_RISKASSESSMENT}
procedure TFHIRJsonParser.ParseRiskAssessmentPrediction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseRiskAssessmentPrediction(jsn)); {2}
end;

function TFHIRJsonParser.ParseRiskAssessmentPrediction(jsn : TJsonObject) : TFhirRiskAssessmentPrediction;
begin
  result := TFhirRiskAssessmentPrediction.create;
  try
    ParseRiskAssessmentPredictionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseRiskAssessmentPredictionProperties(jsn : TJsonObject; result : TFhirRiskAssessmentPrediction);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('outcome') then
        result.outcome := ParseCodeableConcept(jsn.vObj['outcome']);{q3}
    if jsn.has('probabilityRange') {a4} then
      result.probability := ParseRange(jsn.vObj['probabilityRange']);
    if jsn.has('probabilityCodeableConcept') {a4} then
      result.probability := ParseCodeableConcept(jsn.vObj['probabilityCodeableConcept']);
    if jsn.has('probabilityDecimal') or jsn.has('_probabilityDecimal') then
      result.probability := ParseDecimal(jsn.node['probabilityDecimal'], jsn.vObj['_probabilityDecimal']);
    if jsn.has('relativeRisk') or jsn.has('_relativeRisk') then
        result.relativeRiskElement := ParseDecimal(jsn.node['relativeRisk'], jsn.vObj['_relativeRisk']);{q}
    if jsn.has('whenPeriod') {a4} then
      result.when := ParsePeriod(jsn.vObj['whenPeriod']);
    if jsn.has('whenRange') {a4} then
      result.when := ParseRange(jsn.vObj['whenRange']);
    if jsn.has('rationale') or jsn.has('_rationale') then
        result.rationaleElement := ParseString(jsn.node['rationale'], jsn.vObj['_rationale']);{q}
end;

procedure TFHIRJsonComposer.ComposeRiskAssessmentPrediction(json : TJSONWriter; name : string; elem : TFhirRiskAssessmentPrediction; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeableConcept(json, 'outcome', elem.outcome); {a}
  if (SummaryOption in [soFull, soData]) and (elem.probability is TFhirRange) then 
    ComposeRange(json, 'probabilityRange', TFhirRange(elem.probability)) 
  else if (SummaryOption in [soFull, soData]) and (elem.probability is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'probabilityCodeableConcept', TFhirCodeableConcept(elem.probability)) 
  else if (SummaryOption in [soFull, soData]) and (elem.probability is TFhirDecimal) then 
  begin
    ComposeDecimalValue(json, 'probabilityDecimal', TFhirDecimal(elem.probability), false);
    ComposeDecimalProps(json, 'probabilityDecimal', TFhirDecimal(elem.probability), false);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalValue(json, 'relativeRisk', elem.relativeRiskElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimalProps(json, 'relativeRisk', elem.relativeRiskElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.when is TFhirPeriod) then 
    ComposePeriod(json, 'whenPeriod', TFhirPeriod(elem.when)) 
  else if (SummaryOption in [soFull, soData]) and (elem.when is TFhirRange) then 
    ComposeRange(json, 'whenRange', TFhirRange(elem.when)) ;
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'rationale', elem.rationaleElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'rationale', elem.rationaleElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseRiskAssessment(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseRiskAssessment(jsn)); {2}
end;

function TFHIRJsonParser.ParseRiskAssessment(jsn : TJsonObject) : TFhirRiskAssessment;
begin
  result := TFhirRiskAssessment.create;
  try
    ParseRiskAssessmentProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseRiskAssessmentProperties(jsn : TJsonObject; result : TFhirRiskAssessment);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q3}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('condition') then
        result.condition := ParseReference{TFhirCondition}(jsn.vObj['condition']);{q3}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('performer') then
        result.performer := ParseReference{Resource}(jsn.vObj['performer']);{q3}
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('method') then
        result.method := ParseCodeableConcept(jsn.vObj['method']);{q3}
    if jsn.has('basis') then
      iterateArray(jsn.vArr['basis'], result.basisList, parseReference{TFhirReference});
    if jsn.has('prediction') then
      iterateArray(jsn.vArr['prediction'], result.predictionList, parseRiskAssessmentPrediction);
    if jsn.has('mitigation') or jsn.has('_mitigation') then
        result.mitigationElement := ParseString(jsn.node['mitigation'], jsn.vObj['_mitigation']);{q}
end;

procedure TFHIRJsonComposer.ComposeRiskAssessment(json : TJSONWriter; name : string; elem : TFhirRiskAssessment; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('condition') then
    ComposeReference{TFhirCondition}(json, 'condition', elem.condition); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') then
    ComposeReference{Resource}(json, 'performer', elem.performer); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('method') then
    ComposeCodeableConcept(json, 'method', elem.method); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('basis') and (elem.basisList.Count > 0) then
  begin
    startArray(json, 'basis', elem.basisList, false);
    for i := 0 to elem.basisList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.basisList[i]); {z - Reference(Any)}
    finishArray(json, elem.basisList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('prediction') and (elem.predictionList.Count > 0) then
  begin
    startArray(json, 'prediction', elem.predictionList, false);
    for i := 0 to elem.predictionList.Count - 1 do
      ComposeRiskAssessmentPrediction(json, '', elem.predictionList[i]); {z - }
    finishArray(json, elem.predictionList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('mitigation') then
    ComposeStringValue(json, 'mitigation', elem.mitigationElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('mitigation') then
    ComposeStringProps(json, 'mitigation', elem.mitigationElement, false);
end;

{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
procedure TFHIRJsonParser.ParseSchedule(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSchedule(jsn)); {2}
end;

function TFHIRJsonParser.ParseSchedule(jsn : TJsonObject) : TFhirSchedule;
begin
  result := TFhirSchedule.create;
  try
    ParseScheduleProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseScheduleProperties(jsn : TJsonObject; result : TFhirSchedule);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('type') then
      iterateArray(jsn.vArr['type'], result.type_List, parseCodeableConcept);
    if jsn.has('actor') then
        result.actor := ParseReference{Resource}(jsn.vObj['actor']);{q3}
    if jsn.has('planningHorizon') then
        result.planningHorizon := ParsePeriod(jsn.vObj['planningHorizon']);{q3}
    if jsn.has('comment') or jsn.has('_comment') then
        result.commentElement := ParseString(jsn.node['comment'], jsn.vObj['_comment']);{q}
end;

procedure TFHIRJsonComposer.ComposeSchedule(json : TJSONWriter; name : string; elem : TFhirSchedule; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('type_') and (elem.type_List.Count > 0) then
  begin
    startArray(json, 'type', elem.type_List, false);
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(json, '', elem.type_List[i]); {z - CodeableConcept}
    finishArray(json, elem.type_List);
  end;
  ComposeReference{Resource}(json, 'actor', elem.actor); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('planningHorizon') then
    ComposePeriod(json, 'planningHorizon', elem.planningHorizon); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeStringValue(json, 'comment', elem.commentElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeStringProps(json, 'comment', elem.commentElement, false);
end;

{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
procedure TFHIRJsonParser.ParseSearchParameterContact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSearchParameterContact(jsn)); {2}
end;

function TFHIRJsonParser.ParseSearchParameterContact(jsn : TJsonObject) : TFhirSearchParameterContact;
begin
  result := TFhirSearchParameterContact.create;
  try
    ParseSearchParameterContactProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSearchParameterContactProperties(jsn : TJsonObject; result : TFhirSearchParameterContact);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
end;

procedure TFHIRJsonComposer.ComposeSearchParameterContact(json : TJSONWriter; name : string; elem : TFhirSearchParameterContact; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.telecomList.Count > 0) then
  begin
    startArray(json, 'telecom', elem.telecomList, false);
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    finishArray(json, elem.telecomList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseSearchParameter(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSearchParameter(jsn)); {2}
end;

function TFHIRJsonParser.ParseSearchParameter(jsn : TJsonObject) : TFhirSearchParameter;
begin
  result := TFhirSearchParameter.create;
  try
    ParseSearchParameterProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSearchParameterProperties(jsn : TJsonObject; result : TFhirSearchParameter);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := ParseBoolean(jsn.node['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := ParseString(jsn.node['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseSearchParameterContact);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('requirements') or jsn.has('_requirements') then
        result.requirementsElement := ParseString(jsn.node['requirements'], jsn.vObj['_requirements']);{q}
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := ParseCode(jsn.node['code'], jsn.vObj['_code']);{q}
    if jsn.has('base') or jsn.has('_base')  then
      result.baseElement := parseEnum(jsn.path+'/base', jsn.node['base'], jsn.vObj['_base'], CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirSearchParamTypeEnum, SYSTEMS_TFhirSearchParamTypeEnum);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('xpath') or jsn.has('_xpath') then
        result.xpathElement := ParseString(jsn.node['xpath'], jsn.vObj['_xpath']);{q}
    if jsn.has('xpathUsage') or jsn.has('_xpathUsage')  then
      result.xpathUsageElement := parseEnum(jsn.path+'/xpathUsage', jsn.node['xpathUsage'], jsn.vObj['_xpathUsage'], CODES_TFhirSearchXpathUsageEnum, SYSTEMS_TFhirSearchXpathUsageEnum);
    if jsn.has('target') or jsn.has('_target') then
      iterateEnumArray(jsn.vArr['target'], jsn.vArr['_target'], jsn.path+'/target', result.target, parseEnum, CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum);
end;

procedure TFHIRJsonComposer.ComposeSearchParameter(json : TJSONWriter; name : string; elem : TFhirSearchParameter; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeUriValue(json, 'url', elem.urlElement, false);
  ComposeUriProps(json, 'url', elem.urlElement, false);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    startArray(json, 'contact', elem.contactList, false);
    for i := 0 to elem.contactList.Count - 1 do
      ComposeSearchParameterContact(json, '', elem.contactList[i]); {z - }
    finishArray(json, elem.contactList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('requirements') then
    ComposeStringValue(json, 'requirements', elem.requirementsElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('requirements') then
    ComposeStringProps(json, 'requirements', elem.requirementsElement, false);
  ComposeCodeValue(json, 'code', elem.codeElement, false);
  ComposeCodeProps(json, 'code', elem.codeElement, false);
  ComposeEnumValue(json, 'base', elem.BaseElement, CODES_TFhirResourceTypesEnum, false);
  ComposeEnumProps(json, 'base', elem.BaseElement, CODES_TFhirResourceTypesEnum, false);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirSearchParamTypeEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirSearchParamTypeEnum, false);
  ComposeStringValue(json, 'description', elem.descriptionElement, false);
  ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('xpath') then
    ComposeStringValue(json, 'xpath', elem.xpathElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('xpath') then
    ComposeStringProps(json, 'xpath', elem.xpathElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('xpathUsage') then
    ComposeEnumValue(json, 'xpathUsage', elem.XpathUsageElement, CODES_TFhirSearchXpathUsageEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('xpathUsage') then
    ComposeEnumProps(json, 'xpathUsage', elem.XpathUsageElement, CODES_TFhirSearchXpathUsageEnum, false);
  if (SummaryOption in [soFull, soData]) and doCompose('target') and (elem.target.Count > 0) then
  begin
    val := false;
    ext := false;
    for i := 0 to elem.target.Count - 1 do
    begin
      val := val or (elem.target[i].hasPrimitiveValue);
      ext := ext or ((elem.target[i].id <> '') or (elem.target[i].hasExtensionList));
    end;
    if val then
    begin
      startArray(json, 'target', elem.targetList, true);
      for i := 0 to elem.target.Count - 1 do
        ComposeEnumValue(json, '', elem.target[i], CODES_TFhirResourceTypesEnum, true);
      finishArray(json, elem.targetList);
    end;
    if ext then
    begin
      startArray(json, '_target', elem.targetList, false);
      for i := 0 to elem.target.Count - 1 do
        ComposeEnumProps(json, '', elem.target[i], CODES_TFhirResourceTypesEnum, true);
      finishArray(json, elem.targetList);
    end;
  end;
end;

{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SLOT}
procedure TFHIRJsonParser.ParseSlot(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSlot(jsn)); {2}
end;

function TFHIRJsonParser.ParseSlot(jsn : TJsonObject) : TFhirSlot;
begin
  result := TFhirSlot.create;
  try
    ParseSlotProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSlotProperties(jsn : TJsonObject; result : TFhirSlot);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('schedule') then
        result.schedule := ParseReference{TFhirSchedule}(jsn.vObj['schedule']);{q3}
    if jsn.has('freeBusyType') or jsn.has('_freeBusyType')  then
      result.freeBusyTypeElement := parseEnum(jsn.path+'/freeBusyType', jsn.node['freeBusyType'], jsn.vObj['_freeBusyType'], CODES_TFhirSlotstatusEnum, SYSTEMS_TFhirSlotstatusEnum);
    if jsn.has('start') or jsn.has('_start') then
        result.startElement := ParseInstant(jsn.node['start'], jsn.vObj['_start']);{q}
    if jsn.has('end') or jsn.has('_end') then
        result.end_Element := ParseInstant(jsn.node['end'], jsn.vObj['_end']);{q}
    if jsn.has('overbooked') or jsn.has('_overbooked') then
        result.overbookedElement := ParseBoolean(jsn.node['overbooked'], jsn.vObj['_overbooked']);{q}
    if jsn.has('comment') or jsn.has('_comment') then
        result.commentElement := ParseString(jsn.node['comment'], jsn.vObj['_comment']);{q}
end;

procedure TFHIRJsonComposer.ComposeSlot(json : TJSONWriter; name : string; elem : TFhirSlot; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('type_') then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  ComposeReference{TFhirSchedule}(json, 'schedule', elem.schedule); {a}
  ComposeEnumValue(json, 'freeBusyType', elem.FreeBusyTypeElement, CODES_TFhirSlotstatusEnum, false);
  ComposeEnumProps(json, 'freeBusyType', elem.FreeBusyTypeElement, CODES_TFhirSlotstatusEnum, false);
  ComposeInstantValue(json, 'start', elem.startElement, false);
  ComposeInstantProps(json, 'start', elem.startElement, false);
  ComposeInstantValue(json, 'end', elem.end_Element, false);
  ComposeInstantProps(json, 'end', elem.end_Element, false);
  if (SummaryOption in [soFull, soData]) and doCompose('overbooked') then
    ComposeBooleanValue(json, 'overbooked', elem.overbookedElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('overbooked') then
    ComposeBooleanProps(json, 'overbooked', elem.overbookedElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeStringValue(json, 'comment', elem.commentElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeStringProps(json, 'comment', elem.commentElement, false);
end;

{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
procedure TFHIRJsonParser.ParseSpecimenCollection(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSpecimenCollection(jsn)); {2}
end;

function TFHIRJsonParser.ParseSpecimenCollection(jsn : TJsonObject) : TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection.create;
  try
    ParseSpecimenCollectionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSpecimenCollectionProperties(jsn : TJsonObject; result : TFhirSpecimenCollection);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('collector') then
        result.collector := ParseReference{TFhirPractitioner}(jsn.vObj['collector']);{q3}
      if jsn.has('comment') or jsn.has('_comment') then
      iteratePrimitiveArray(jsn.vArr['comment'], jsn.vArr['_comment'], result.commentList, parseString);
    if jsn.has('collectedPeriod') {a4} then
      result.collected := ParsePeriod(jsn.vObj['collectedPeriod']);
    if jsn.has('collectedDateTime') or jsn.has('_collectedDateTime') then
      result.collected := ParseDateTime(jsn.node['collectedDateTime'], jsn.vObj['_collectedDateTime']);
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
    if jsn.has('method') then
        result.method := ParseCodeableConcept(jsn.vObj['method']);{q3}
    if jsn.has('bodySite') then
        result.bodySite := ParseCodeableConcept(jsn.vObj['bodySite']);{q3}
end;

procedure TFHIRJsonComposer.ComposeSpecimenCollection(json : TJSONWriter; name : string; elem : TFhirSpecimenCollection; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(json, 'collector', elem.collector); {a}
  if (SummaryOption in [soFull, soData]) and (elem.commentList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.commentList.Count - 1 do
    begin
      ext := ext or ((elem.commentList[i].id <> '') or (elem.commentList[i].hasExtensionList) {no-comments or (elem.commentList[i].hasComments)});
      val := val or (elem.commentList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      startArray(json, 'comment', elem.commentList, true);
      for i := 0 to elem.commentList.Count - 1 do
        ComposeStringValue(json, '',elem.commentList[i], true);
      finishArray(json, elem.commentList);
    end;
    if ext then
    begin
      startArray(json, '_comment', elem.commentList, false);
      for i := 0 to elem.commentList.Count - 1 do
        ComposeStringProps(json, '',elem.commentList[i], true);
      finishArray(json, elem.commentList);
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.collected is TFhirPeriod) then 
    ComposePeriod(json, 'collectedPeriod', TFhirPeriod(elem.collected)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.collected is TFhirDateTime) then 
  begin
    ComposeDateTimeValue(json, 'collectedDateTime', TFhirDateTime(elem.collected), false);
    ComposeDateTimeProps(json, 'collectedDateTime', TFhirDateTime(elem.collected), false);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'method', elem.method); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'bodySite', elem.bodySite); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseSpecimenTreatment(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSpecimenTreatment(jsn)); {2}
end;

function TFHIRJsonParser.ParseSpecimenTreatment(jsn : TJsonObject) : TFhirSpecimenTreatment;
begin
  result := TFhirSpecimenTreatment.create;
  try
    ParseSpecimenTreatmentProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSpecimenTreatmentProperties(jsn : TJsonObject; result : TFhirSpecimenTreatment);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('procedure') then
        result.procedure_ := ParseCodeableConcept(jsn.vObj['procedure']);{q3}
    if jsn.has('additive') then
      iterateArray(jsn.vArr['additive'], result.additiveList, parseReference{TFhirSubstance});
end;

procedure TFHIRJsonComposer.ComposeSpecimenTreatment(json : TJSONWriter; name : string; elem : TFhirSpecimenTreatment; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'procedure', elem.procedure_); {a}
  if (SummaryOption in [soFull, soData]) and (elem.additiveList.Count > 0) then
  begin
    startArray(json, 'additive', elem.additiveList, false);
    for i := 0 to elem.additiveList.Count - 1 do
      ComposeReference{TFhirSubstance}(json, '', elem.additiveList[i]); {z - Reference(Substance)}
    finishArray(json, elem.additiveList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseSpecimenContainer(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSpecimenContainer(jsn)); {2}
end;

function TFHIRJsonParser.ParseSpecimenContainer(jsn : TJsonObject) : TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer.create;
  try
    ParseSpecimenContainerProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSpecimenContainerProperties(jsn : TJsonObject; result : TFhirSpecimenContainer);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('capacity') then
        result.capacity := ParseQuantity(jsn.vObj['capacity']);{q3}
    if jsn.has('specimenQuantity') then
        result.specimenQuantity := ParseQuantity(jsn.vObj['specimenQuantity']);{q3}
    if jsn.has('additiveCodeableConcept') {a4} then
      result.additive := ParseCodeableConcept(jsn.vObj['additiveCodeableConcept']);
    if jsn.has('additiveReference') {a3} then
      result.additive := ParseReference(jsn.vObj['additiveReference']);
end;

procedure TFHIRJsonComposer.ComposeSpecimenContainer(json : TJSONWriter; name : string; elem : TFhirSpecimenContainer; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'capacity', elem.capacity); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(json, 'specimenQuantity', elem.specimenQuantity); {a}
  if (SummaryOption in [soFull, soData]) and (elem.additive is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'additiveCodeableConcept', TFhirCodeableConcept(elem.additive)) 
  else if (SummaryOption in [soFull, soData]) and (elem.additive is TFhirReference) then
    ComposeReference(json, 'additiveReference', TFhirReference(elem.additive));
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseSpecimen(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSpecimen(jsn)); {2}
end;

function TFHIRJsonParser.ParseSpecimen(jsn : TJsonObject) : TFhirSpecimen;
begin
  result := TFhirSpecimen.create;
  try
    ParseSpecimenProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSpecimenProperties(jsn : TJsonObject; result : TFhirSpecimen);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirSpecimenStatusEnum, SYSTEMS_TFhirSpecimenStatusEnum);
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('parent') then
      iterateArray(jsn.vArr['parent'], result.parentList, parseReference{TFhirSpecimen});
    if jsn.has('subject') then
        result.subject := ParseReference{Resource}(jsn.vObj['subject']);{q3}
    if jsn.has('accessionIdentifier') then
        result.accessionIdentifier := ParseIdentifier(jsn.vObj['accessionIdentifier']);{q3}
    if jsn.has('receivedTime') or jsn.has('_receivedTime') then
        result.receivedTimeElement := ParseDateTime(jsn.node['receivedTime'], jsn.vObj['_receivedTime']);{q}
    if jsn.has('collection') then
        result.collection := ParseSpecimenCollection(jsn.vObj['collection']);{q3}
    if jsn.has('treatment') then
      iterateArray(jsn.vArr['treatment'], result.treatmentList, parseSpecimenTreatment);
    if jsn.has('container') then
      iterateArray(jsn.vArr['container'], result.containerList, parseSpecimenContainer);
end;

procedure TFHIRJsonComposer.ComposeSpecimen(json : TJSONWriter; name : string; elem : TFhirSpecimen; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirSpecimenStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirSpecimenStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('parent') and (elem.parentList.Count > 0) then
  begin
    startArray(json, 'parent', elem.parentList, false);
    for i := 0 to elem.parentList.Count - 1 do
      ComposeReference{TFhirSpecimen}(json, '', elem.parentList[i]); {z - Reference(Specimen)}
    finishArray(json, elem.parentList);
  end;
  ComposeReference{Resource}(json, 'subject', elem.subject); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('accessionIdentifier') then
    ComposeIdentifier(json, 'accessionIdentifier', elem.accessionIdentifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('receivedTime') then
    ComposeDateTimeValue(json, 'receivedTime', elem.receivedTimeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('receivedTime') then
    ComposeDateTimeProps(json, 'receivedTime', elem.receivedTimeElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('collection') then
    ComposeSpecimenCollection(json, 'collection', elem.collection); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('treatment') and (elem.treatmentList.Count > 0) then
  begin
    startArray(json, 'treatment', elem.treatmentList, false);
    for i := 0 to elem.treatmentList.Count - 1 do
      ComposeSpecimenTreatment(json, '', elem.treatmentList[i]); {z - }
    finishArray(json, elem.treatmentList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('container') and (elem.containerList.Count > 0) then
  begin
    startArray(json, 'container', elem.containerList, false);
    for i := 0 to elem.containerList.Count - 1 do
      ComposeSpecimenContainer(json, '', elem.containerList[i]); {z - }
    finishArray(json, elem.containerList);
  end;
end;

{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_STRUCTUREDEFINITION}
procedure TFHIRJsonParser.ParseStructureDefinitionContact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseStructureDefinitionContact(jsn)); {2}
end;

function TFHIRJsonParser.ParseStructureDefinitionContact(jsn : TJsonObject) : TFhirStructureDefinitionContact;
begin
  result := TFhirStructureDefinitionContact.create;
  try
    ParseStructureDefinitionContactProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseStructureDefinitionContactProperties(jsn : TJsonObject; result : TFhirStructureDefinitionContact);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
end;

procedure TFHIRJsonComposer.composeStructureDefinitionContact(json : TJSONWriter; name : string; elem : TFhirStructureDefinitionContact; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.telecomList.Count > 0) then
  begin
    startArray(json, 'telecom', elem.telecomList, false);
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    finishArray(json, elem.telecomList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseStructureDefinitionMapping(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseStructureDefinitionMapping(jsn)); {2}
end;

function TFHIRJsonParser.ParseStructureDefinitionMapping(jsn : TJsonObject) : TFhirStructureDefinitionMapping;
begin
  result := TFhirStructureDefinitionMapping.create;
  try
    ParseStructureDefinitionMappingProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseStructureDefinitionMappingProperties(jsn : TJsonObject; result : TFhirStructureDefinitionMapping);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identity') or jsn.has('_identity') then
        result.identityElement := ParseId(jsn.node['identity'], jsn.vObj['_identity']);{q}
    if jsn.has('uri') or jsn.has('_uri') then
        result.uriElement := ParseUri(jsn.node['uri'], jsn.vObj['_uri']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('comments') or jsn.has('_comments') then
        result.commentsElement := ParseString(jsn.node['comments'], jsn.vObj['_comments']);{q}
end;

procedure TFHIRJsonComposer.composeStructureDefinitionMapping(json : TJSONWriter; name : string; elem : TFhirStructureDefinitionMapping; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeIdValue(json, 'identity', elem.identityElement, false);
  ComposeIdProps(json, 'identity', elem.identityElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriValue(json, 'uri', elem.uriElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriProps(json, 'uri', elem.uriElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'comments', elem.commentsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'comments', elem.commentsElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseStructureDefinitionSnapshot(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseStructureDefinitionSnapshot(jsn)); {2}
end;

function TFHIRJsonParser.ParseStructureDefinitionSnapshot(jsn : TJsonObject) : TFhirStructureDefinitionSnapshot;
begin
  result := TFhirStructureDefinitionSnapshot.create;
  try
    ParseStructureDefinitionSnapshotProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseStructureDefinitionSnapshotProperties(jsn : TJsonObject; result : TFhirStructureDefinitionSnapshot);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('element') then
      iterateArray(jsn.vArr['element'], result.elementList, parseElementDefinition);
end;

procedure TFHIRJsonComposer.composeStructureDefinitionSnapshot(json : TJSONWriter; name : string; elem : TFhirStructureDefinitionSnapshot; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (elem.elementList.Count > 0) then
  begin
    startArray(json, 'element', elem.elementList, false);
    for i := 0 to elem.elementList.Count - 1 do
      composeElementDefinition(json, '', elem.elementList[i]); {z - ElementDefinition}
    finishArray(json, elem.elementList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseStructureDefinitionDifferential(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseStructureDefinitionDifferential(jsn)); {2}
end;

function TFHIRJsonParser.ParseStructureDefinitionDifferential(jsn : TJsonObject) : TFhirStructureDefinitionDifferential;
begin
  result := TFhirStructureDefinitionDifferential.create;
  try
    ParseStructureDefinitionDifferentialProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseStructureDefinitionDifferentialProperties(jsn : TJsonObject; result : TFhirStructureDefinitionDifferential);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('element') then
      iterateArray(jsn.vArr['element'], result.elementList, parseElementDefinition);
end;

procedure TFHIRJsonComposer.composeStructureDefinitionDifferential(json : TJSONWriter; name : string; elem : TFhirStructureDefinitionDifferential; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (elem.elementList.Count > 0) then
  begin
    startArray(json, 'element', elem.elementList, false);
    for i := 0 to elem.elementList.Count - 1 do
      composeElementDefinition(json, '', elem.elementList[i]); {z - ElementDefinition}
    finishArray(json, elem.elementList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseStructureDefinition(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseStructureDefinition(jsn)); {2}
end;

function TFHIRJsonParser.ParseStructureDefinition(jsn : TJsonObject) : TFhirStructureDefinition;
begin
  result := TFhirStructureDefinition.create;
  try
    ParseStructureDefinitionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseStructureDefinitionProperties(jsn : TJsonObject; result : TFhirStructureDefinition);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.displayElement := ParseString(jsn.node['display'], jsn.vObj['_display']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := ParseBoolean(jsn.node['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := ParseString(jsn.node['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseStructureDefinitionContact);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseCodeableConcept);
    if jsn.has('requirements') or jsn.has('_requirements') then
        result.requirementsElement := ParseString(jsn.node['requirements'], jsn.vObj['_requirements']);{q}
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := ParseString(jsn.node['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('code') then
      iterateArray(jsn.vArr['code'], result.codeList, parseCoding);
    if jsn.has('fhirVersion') or jsn.has('_fhirVersion') then
        result.fhirVersionElement := ParseId(jsn.node['fhirVersion'], jsn.vObj['_fhirVersion']);{q}
    if jsn.has('mapping') then
      iterateArray(jsn.vArr['mapping'], result.mappingList, parseStructureDefinitionMapping);
    if jsn.has('kind') or jsn.has('_kind')  then
      result.kindElement := parseEnum(jsn.path+'/kind', jsn.node['kind'], jsn.vObj['_kind'], CODES_TFhirStructureDefinitionKindEnum, SYSTEMS_TFhirStructureDefinitionKindEnum);
    if jsn.has('constrainedType') or jsn.has('_constrainedType') then
        result.constrainedTypeElement := ParseCode(jsn.node['constrainedType'], jsn.vObj['_constrainedType']);{q}
    if jsn.has('abstract') or jsn.has('_abstract') then
        result.abstractElement := ParseBoolean(jsn.node['abstract'], jsn.vObj['_abstract']);{q}
    if jsn.has('contextType') or jsn.has('_contextType')  then
      result.contextTypeElement := parseEnum(jsn.path+'/contextType', jsn.node['contextType'], jsn.vObj['_contextType'], CODES_TFhirExtensionContextEnum, SYSTEMS_TFhirExtensionContextEnum);
      if jsn.has('context') or jsn.has('_context') then
      iteratePrimitiveArray(jsn.vArr['context'], jsn.vArr['_context'], result.contextList, parseString);
    if jsn.has('base') or jsn.has('_base') then
        result.baseElement := ParseUri(jsn.node['base'], jsn.vObj['_base']);{q}
    if jsn.has('snapshot') then
        result.snapshot := ParseStructureDefinitionSnapshot(jsn.vObj['snapshot']);{q3}
    if jsn.has('differential') then
        result.differential := ParseStructureDefinitionDifferential(jsn.vObj['differential']);{q3}
end;

procedure TFHIRJsonComposer.composeStructureDefinition(json : TJSONWriter; name : string; elem : TFhirStructureDefinition; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeUriValue(json, 'url', elem.urlElement, false);
  ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('display') then
    ComposeStringValue(json, 'display', elem.displayElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('display') then
    ComposeStringProps(json, 'display', elem.displayElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    startArray(json, 'contact', elem.contactList, false);
    for i := 0 to elem.contactList.Count - 1 do
      composeStructureDefinitionContact(json, '', elem.contactList[i]); {z - }
    finishArray(json, elem.contactList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') and (elem.useContextList.Count > 0) then
  begin
    startArray(json, 'useContext', elem.useContextList, false);
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.useContextList[i]); {z - CodeableConcept}
    finishArray(json, elem.useContextList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('requirements') then
    ComposeStringValue(json, 'requirements', elem.requirementsElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('requirements') then
    ComposeStringProps(json, 'requirements', elem.requirementsElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeStringValue(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeStringProps(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') and (elem.codeList.Count > 0) then
  begin
    startArray(json, 'code', elem.codeList, false);
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCoding(json, '', elem.codeList[i]); {z - Coding}
    finishArray(json, elem.codeList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('fhirVersion') then
    ComposeIdValue(json, 'fhirVersion', elem.fhirVersionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('fhirVersion') then
    ComposeIdProps(json, 'fhirVersion', elem.fhirVersionElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('mapping') and (elem.mappingList.Count > 0) then
  begin
    startArray(json, 'mapping', elem.mappingList, false);
    for i := 0 to elem.mappingList.Count - 1 do
      composeStructureDefinitionMapping(json, '', elem.mappingList[i]); {z - }
    finishArray(json, elem.mappingList);
  end;
  ComposeEnumValue(json, 'kind', elem.KindElement, CODES_TFhirStructureDefinitionKindEnum, false);
  ComposeEnumProps(json, 'kind', elem.KindElement, CODES_TFhirStructureDefinitionKindEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('constrainedType') then
    ComposeCodeValue(json, 'constrainedType', elem.constrainedTypeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('constrainedType') then
    ComposeCodeProps(json, 'constrainedType', elem.constrainedTypeElement, false);
  ComposeBooleanValue(json, 'abstract', elem.abstractElement, false);
  ComposeBooleanProps(json, 'abstract', elem.abstractElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contextType') then
    ComposeEnumValue(json, 'contextType', elem.ContextTypeElement, CODES_TFhirExtensionContextEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contextType') then
    ComposeEnumProps(json, 'contextType', elem.ContextTypeElement, CODES_TFhirExtensionContextEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') and (elem.contextList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.contextList.Count - 1 do
    begin
      ext := ext or ((elem.contextList[i].id <> '') or (elem.contextList[i].hasExtensionList) {no-comments or (elem.contextList[i].hasComments)});
      val := val or (elem.contextList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      startArray(json, 'context', elem.contextList, true);
      for i := 0 to elem.contextList.Count - 1 do
        ComposeStringValue(json, '',elem.contextList[i], true);
      finishArray(json, elem.contextList);
    end;
    if ext then
    begin
      startArray(json, '_context', elem.contextList, false);
      for i := 0 to elem.contextList.Count - 1 do
        ComposeStringProps(json, '',elem.contextList[i], true);
      finishArray(json, elem.contextList);
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('base') then
    ComposeUriValue(json, 'base', elem.baseElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('base') then
    ComposeUriProps(json, 'base', elem.baseElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('snapshot') then
    composeStructureDefinitionSnapshot(json, 'snapshot', elem.snapshot); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('differential') then
    composeStructureDefinitionDifferential(json, 'differential', elem.differential); {a}
end;

{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_SUBSCRIPTION}
procedure TFHIRJsonParser.ParseSubscriptionChannel(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubscriptionChannel(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubscriptionChannel(jsn : TJsonObject) : TFhirSubscriptionChannel;
begin
  result := TFhirSubscriptionChannel.create;
  try
    ParseSubscriptionChannelProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubscriptionChannelProperties(jsn : TJsonObject; result : TFhirSubscriptionChannel);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') or jsn.has('_type')  then
      result.type_Element := parseEnum(jsn.path+'/type', jsn.node['type'], jsn.vObj['_type'], CODES_TFhirSubscriptionChannelTypeEnum, SYSTEMS_TFhirSubscriptionChannelTypeEnum);
    if jsn.has('endpoint') or jsn.has('_endpoint') then
        result.endpointElement := ParseUri(jsn.node['endpoint'], jsn.vObj['_endpoint']);{q}
    if jsn.has('payload') or jsn.has('_payload') then
        result.payloadElement := ParseString(jsn.node['payload'], jsn.vObj['_payload']);{q}
    if jsn.has('header') or jsn.has('_header') then
        result.headerElement := ParseString(jsn.node['header'], jsn.vObj['_header']);{q}
end;

procedure TFHIRJsonComposer.ComposeSubscriptionChannel(json : TJSONWriter; name : string; elem : TFhirSubscriptionChannel; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeEnumValue(json, 'type', elem.Type_Element, CODES_TFhirSubscriptionChannelTypeEnum, false);
  ComposeEnumProps(json, 'type', elem.Type_Element, CODES_TFhirSubscriptionChannelTypeEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriValue(json, 'endpoint', elem.endpointElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUriProps(json, 'endpoint', elem.endpointElement, false);
  ComposeStringValue(json, 'payload', elem.payloadElement, false);
  ComposeStringProps(json, 'payload', elem.payloadElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'header', elem.headerElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'header', elem.headerElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseSubscription(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubscription(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubscription(jsn : TJsonObject) : TFhirSubscription;
begin
  result := TFhirSubscription.create;
  try
    ParseSubscriptionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubscriptionProperties(jsn : TJsonObject; result : TFhirSubscription);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('criteria') or jsn.has('_criteria') then
        result.criteriaElement := ParseString(jsn.node['criteria'], jsn.vObj['_criteria']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseContactPoint);
    if jsn.has('reason') or jsn.has('_reason') then
        result.reasonElement := ParseString(jsn.node['reason'], jsn.vObj['_reason']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirSubscriptionStatusEnum, SYSTEMS_TFhirSubscriptionStatusEnum);
    if jsn.has('error') or jsn.has('_error') then
        result.errorElement := ParseString(jsn.node['error'], jsn.vObj['_error']);{q}
    if jsn.has('channel') then
        result.channel := ParseSubscriptionChannel(jsn.vObj['channel']);{q3}
    if jsn.has('end') or jsn.has('_end') then
        result.end_Element := ParseInstant(jsn.node['end'], jsn.vObj['_end']);{q}
    if jsn.has('tag') then
      iterateArray(jsn.vArr['tag'], result.tagList, parseCoding);
end;

procedure TFHIRJsonComposer.ComposeSubscription(json : TJSONWriter; name : string; elem : TFhirSubscription; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeStringValue(json, 'criteria', elem.criteriaElement, false);
  ComposeStringProps(json, 'criteria', elem.criteriaElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    startArray(json, 'contact', elem.contactList, false);
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactPoint(json, '', elem.contactList[i]); {z - ContactPoint}
    finishArray(json, elem.contactList);
  end;
  ComposeStringValue(json, 'reason', elem.reasonElement, false);
  ComposeStringProps(json, 'reason', elem.reasonElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirSubscriptionStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirSubscriptionStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('error') then
    ComposeStringValue(json, 'error', elem.errorElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('error') then
    ComposeStringProps(json, 'error', elem.errorElement, false);
  ComposeSubscriptionChannel(json, 'channel', elem.channel); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('end_') then
    ComposeInstantValue(json, 'end', elem.end_Element, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('end_') then
    ComposeInstantProps(json, 'end', elem.end_Element, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('tag') and (elem.tagList.Count > 0) then
  begin
    startArray(json, 'tag', elem.tagList, false);
    for i := 0 to elem.tagList.Count - 1 do
      ComposeCoding(json, '', elem.tagList[i]); {z - Coding}
    finishArray(json, elem.tagList);
  end;
end;

{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
procedure TFHIRJsonParser.ParseSubstanceInstance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstanceInstance(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstanceInstance(jsn : TJsonObject) : TFhirSubstanceInstance;
begin
  result := TFhirSubstanceInstance.create;
  try
    ParseSubstanceInstanceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstanceInstanceProperties(jsn : TJsonObject; result : TFhirSubstanceInstance);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('expiry') or jsn.has('_expiry') then
        result.expiryElement := ParseDateTime(jsn.node['expiry'], jsn.vObj['_expiry']);{q}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
end;

procedure TFHIRJsonComposer.ComposeSubstanceInstance(json : TJSONWriter; name : string; elem : TFhirSubstanceInstance; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeValue(json, 'expiry', elem.expiryElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTimeProps(json, 'expiry', elem.expiryElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseSubstanceIngredient(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstanceIngredient(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstanceIngredient(jsn : TJsonObject) : TFhirSubstanceIngredient;
begin
  result := TFhirSubstanceIngredient.create;
  try
    ParseSubstanceIngredientProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstanceIngredientProperties(jsn : TJsonObject; result : TFhirSubstanceIngredient);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('quantity') then
        result.quantity := ParseRatio(jsn.vObj['quantity']);{q3}
    if jsn.has('substance') then
        result.substance := ParseReference{TFhirSubstance}(jsn.vObj['substance']);{q3}
end;

procedure TFHIRJsonComposer.ComposeSubstanceIngredient(json : TJSONWriter; name : string; elem : TFhirSubstanceIngredient; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(json, 'quantity', elem.quantity); {a}
  ComposeReference{TFhirSubstance}(json, 'substance', elem.substance); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseSubstance(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSubstance(jsn)); {2}
end;

function TFHIRJsonParser.ParseSubstance(jsn : TJsonObject) : TFhirSubstance;
begin
  result := TFhirSubstance.create;
  try
    ParseSubstanceProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSubstanceProperties(jsn : TJsonObject; result : TFhirSubstance);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('category') then
      iterateArray(jsn.vArr['category'], result.categoryList, parseCodeableConcept);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('instance') then
      iterateArray(jsn.vArr['instance'], result.instanceList, parseSubstanceInstance);
    if jsn.has('ingredient') then
      iterateArray(jsn.vArr['ingredient'], result.ingredientList, parseSubstanceIngredient);
end;

procedure TFHIRJsonComposer.ComposeSubstance(json : TJSONWriter; name : string; elem : TFhirSubstance; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') and (elem.categoryList.Count > 0) then
  begin
    startArray(json, 'category', elem.categoryList, false);
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.categoryList[i]); {z - CodeableConcept}
    finishArray(json, elem.categoryList);
  end;
  ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instance') and (elem.instanceList.Count > 0) then
  begin
    startArray(json, 'instance', elem.instanceList, false);
    for i := 0 to elem.instanceList.Count - 1 do
      ComposeSubstanceInstance(json, '', elem.instanceList[i]); {z - }
    finishArray(json, elem.instanceList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ingredient') and (elem.ingredientList.Count > 0) then
  begin
    startArray(json, 'ingredient', elem.ingredientList, false);
    for i := 0 to elem.ingredientList.Count - 1 do
      ComposeSubstanceIngredient(json, '', elem.ingredientList[i]); {z - }
    finishArray(json, elem.ingredientList);
  end;
end;

{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUPPLYDELIVERY}
procedure TFHIRJsonParser.ParseSupplyDelivery(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSupplyDelivery(jsn)); {2}
end;

function TFHIRJsonParser.ParseSupplyDelivery(jsn : TJsonObject) : TFhirSupplyDelivery;
begin
  result := TFhirSupplyDelivery.create;
  try
    ParseSupplyDeliveryProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSupplyDeliveryProperties(jsn : TJsonObject; result : TFhirSupplyDelivery);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirSupplydeliveryStatusEnum, SYSTEMS_TFhirSupplydeliveryStatusEnum);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
    if jsn.has('type') then
        result.type_ := ParseCodeableConcept(jsn.vObj['type']);{q3}
    if jsn.has('quantity') then
        result.quantity := ParseQuantity(jsn.vObj['quantity']);{q3}
    if jsn.has('suppliedItem') then
        result.suppliedItem := ParseReference{Resource}(jsn.vObj['suppliedItem']);{q3}
    if jsn.has('supplier') then
        result.supplier := ParseReference{TFhirPractitioner}(jsn.vObj['supplier']);{q3}
    if jsn.has('whenPrepared') then
        result.whenPrepared := ParsePeriod(jsn.vObj['whenPrepared']);{q3}
    if jsn.has('time') or jsn.has('_time') then
        result.timeElement := ParseDateTime(jsn.node['time'], jsn.vObj['_time']);{q}
    if jsn.has('destination') then
        result.destination := ParseReference{TFhirLocation}(jsn.vObj['destination']);{q3}
    if jsn.has('receiver') then
      iterateArray(jsn.vArr['receiver'], result.receiverList, parseReference{TFhirPractitioner});
end;

procedure TFHIRJsonComposer.ComposeSupplyDelivery(json : TJSONWriter; name : string; elem : TFhirSupplyDelivery; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirSupplydeliveryStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirSupplydeliveryStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('quantity') then
    ComposeQuantity(json, 'quantity', elem.quantity); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('suppliedItem') then
    ComposeReference{Resource}(json, 'suppliedItem', elem.suppliedItem); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('supplier') then
    ComposeReference{TFhirPractitioner}(json, 'supplier', elem.supplier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('whenPrepared') then
    ComposePeriod(json, 'whenPrepared', elem.whenPrepared); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('time') then
    ComposeDateTimeValue(json, 'time', elem.timeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('time') then
    ComposeDateTimeProps(json, 'time', elem.timeElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('destination') then
    ComposeReference{TFhirLocation}(json, 'destination', elem.destination); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('receiver') and (elem.receiverList.Count > 0) then
  begin
    startArray(json, 'receiver', elem.receiverList, false);
    for i := 0 to elem.receiverList.Count - 1 do
      ComposeReference{TFhirPractitioner}(json, '', elem.receiverList[i]); {z - Reference(Practitioner)}
    finishArray(json, elem.receiverList);
  end;
end;

{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
procedure TFHIRJsonParser.ParseSupplyRequestWhen(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSupplyRequestWhen(jsn)); {2}
end;

function TFHIRJsonParser.ParseSupplyRequestWhen(jsn : TJsonObject) : TFhirSupplyRequestWhen;
begin
  result := TFhirSupplyRequestWhen.create;
  try
    ParseSupplyRequestWhenProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSupplyRequestWhenProperties(jsn : TJsonObject; result : TFhirSupplyRequestWhen);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') then
        result.code := ParseCodeableConcept(jsn.vObj['code']);{q3}
    if jsn.has('schedule') then
        result.schedule := ParseTiming(jsn.vObj['schedule']);{q3}
end;

procedure TFHIRJsonComposer.ComposeSupplyRequestWhen(json : TJSONWriter; name : string; elem : TFhirSupplyRequestWhen; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(json, 'code', elem.code); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTiming(json, 'schedule', elem.schedule); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseSupplyRequest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseSupplyRequest(jsn)); {2}
end;

function TFHIRJsonParser.ParseSupplyRequest(jsn : TJsonObject) : TFhirSupplyRequest;
begin
  result := TFhirSupplyRequest.create;
  try
    ParseSupplyRequestProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseSupplyRequestProperties(jsn : TJsonObject; result : TFhirSupplyRequest);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
    if jsn.has('source') then
        result.source := ParseReference{Resource}(jsn.vObj['source']);{q3}
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirSupplyrequestStatusEnum, SYSTEMS_TFhirSupplyrequestStatusEnum);
    if jsn.has('kind') then
        result.kind := ParseCodeableConcept(jsn.vObj['kind']);{q3}
    if jsn.has('orderedItem') then
        result.orderedItem := ParseReference{Resource}(jsn.vObj['orderedItem']);{q3}
    if jsn.has('supplier') then
      iterateArray(jsn.vArr['supplier'], result.supplierList, parseReference{TFhirOrganization});
    if jsn.has('reasonCodeableConcept') {a4} then
      result.reason := ParseCodeableConcept(jsn.vObj['reasonCodeableConcept']);
    if jsn.has('reasonReference') {a3} then
      result.reason := ParseReference(jsn.vObj['reasonReference']);
    if jsn.has('when') then
        result.when := ParseSupplyRequestWhen(jsn.vObj['when']);{q3}
end;

procedure TFHIRJsonComposer.ComposeSupplyRequest(json : TJSONWriter; name : string; elem : TFhirSupplyRequest; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('source') then
    ComposeReference{Resource}(json, 'source', elem.source); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirSupplyrequestStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirSupplyrequestStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('kind') then
    ComposeCodeableConcept(json, 'kind', elem.kind); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('orderedItem') then
    ComposeReference{Resource}(json, 'orderedItem', elem.orderedItem); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('supplier') and (elem.supplierList.Count > 0) then
  begin
    startArray(json, 'supplier', elem.supplierList, false);
    for i := 0 to elem.supplierList.Count - 1 do
      ComposeReference{TFhirOrganization}(json, '', elem.supplierList[i]); {z - Reference(Organization)}
    finishArray(json, elem.supplierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirReference) then
    ComposeReference(json, 'reasonReference', TFhirReference(elem.reason));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('when') then
    ComposeSupplyRequestWhen(json, 'when', elem.when); {a}
end;

{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TESTSCRIPT}
procedure TFHIRJsonParser.ParseTestScriptContact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptContact(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptContact(jsn : TJsonObject) : TFhirTestScriptContact;
begin
  result := TFhirTestScriptContact.create;
  try
    ParseTestScriptContactProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTestScriptContactProperties(jsn : TJsonObject; result : TFhirTestScriptContact);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
end;

procedure TFHIRJsonComposer.ComposeTestScriptContact(json : TJSONWriter; name : string; elem : TFhirTestScriptContact; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.telecomList.Count > 0) then
  begin
    startArray(json, 'telecom', elem.telecomList, false);
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    finishArray(json, elem.telecomList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseTestScriptMetadata(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptMetadata(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptMetadata(jsn : TJsonObject) : TFhirTestScriptMetadata;
begin
  result := TFhirTestScriptMetadata.create;
  try
    ParseTestScriptMetadataProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTestScriptMetadataProperties(jsn : TJsonObject; result : TFhirTestScriptMetadata);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('link') then
      iterateArray(jsn.vArr['link'], result.link_List, parseTestScriptMetadataLink);
    if jsn.has('capability') then
      iterateArray(jsn.vArr['capability'], result.capabilityList, parseTestScriptMetadataCapability);
end;

procedure TFHIRJsonComposer.ComposeTestScriptMetadata(json : TJSONWriter; name : string; elem : TFhirTestScriptMetadata; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (elem.link_List.Count > 0) then
  begin
    startArray(json, 'link', elem.link_List, false);
    for i := 0 to elem.link_List.Count - 1 do
      ComposeTestScriptMetadataLink(json, '', elem.link_List[i]); {z - }
    finishArray(json, elem.link_List);
  end;
  if (elem.capabilityList.Count > 0) then
  begin
    startArray(json, 'capability', elem.capabilityList, false);
    for i := 0 to elem.capabilityList.Count - 1 do
      ComposeTestScriptMetadataCapability(json, '', elem.capabilityList[i]); {z - }
    finishArray(json, elem.capabilityList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseTestScriptMetadataLink(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptMetadataLink(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptMetadataLink(jsn : TJsonObject) : TFhirTestScriptMetadataLink;
begin
  result := TFhirTestScriptMetadataLink.create;
  try
    ParseTestScriptMetadataLinkProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTestScriptMetadataLinkProperties(jsn : TJsonObject; result : TFhirTestScriptMetadataLink);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn.node['description'], jsn.vObj['_description']);{q}
end;

procedure TFHIRJsonComposer.ComposeTestScriptMetadataLink(json : TJSONWriter; name : string; elem : TFhirTestScriptMetadataLink; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeUriValue(json, 'url', elem.urlElement, false);
  ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseTestScriptMetadataCapability(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptMetadataCapability(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptMetadataCapability(jsn : TJsonObject) : TFhirTestScriptMetadataCapability;
begin
  result := TFhirTestScriptMetadataCapability.create;
  try
    ParseTestScriptMetadataCapabilityProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTestScriptMetadataCapabilityProperties(jsn : TJsonObject; result : TFhirTestScriptMetadataCapability);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('required') or jsn.has('_required') then
        result.requiredElement := ParseBoolean(jsn.node['required'], jsn.vObj['_required']);{q}
    if jsn.has('validated') or jsn.has('_validated') then
        result.validatedElement := ParseBoolean(jsn.node['validated'], jsn.vObj['_validated']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('destination') or jsn.has('_destination') then
        result.destinationElement := ParseInteger(jsn.node['destination'], jsn.vObj['_destination']);{q}
      if jsn.has('link') or jsn.has('_link') then
      iteratePrimitiveArray(jsn.vArr['link'], jsn.vArr['_link'], result.link_List, parseUri);
    if jsn.has('conformance') then
        result.conformance := ParseReference{TFhirConformance}(jsn.vObj['conformance']);{q3}
end;

procedure TFHIRJsonComposer.ComposeTestScriptMetadataCapability(json : TJSONWriter; name : string; elem : TFhirTestScriptMetadataCapability; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.required <> false)) then
    ComposeBooleanValue(json, 'required', elem.requiredElement, false);
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.required <> false)) then
    ComposeBooleanProps(json, 'required', elem.requiredElement, false);
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.validated <> false)) then
    ComposeBooleanValue(json, 'validated', elem.validatedElement, false);
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.validated <> false)) then
    ComposeBooleanProps(json, 'validated', elem.validatedElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerValue(json, 'destination', elem.destinationElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerProps(json, 'destination', elem.destinationElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.link_List.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.link_List.Count - 1 do
    begin
      ext := ext or ((elem.link_List[i].id <> '') or (elem.link_List[i].hasExtensionList) {no-comments or (elem.link_List[i].hasComments)});
      val := val or (elem.link_List[i].hasPrimitiveValue);
    end;
    if val then
    begin
      startArray(json, 'link', elem.link_List, true);
      for i := 0 to elem.link_List.Count - 1 do
        ComposeUriValue(json, '',elem.link_List[i], true);
      finishArray(json, elem.link_List);
    end;
    if ext then
    begin
      startArray(json, '_link', elem.link_List, false);
      for i := 0 to elem.link_List.Count - 1 do
        ComposeUriProps(json, '',elem.link_List[i], true);
      finishArray(json, elem.link_List);
    end;
  end;
  ComposeReference{TFhirConformance}(json, 'conformance', elem.conformance); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseTestScriptFixture(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptFixture(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptFixture(jsn : TJsonObject) : TFhirTestScriptFixture;
begin
  result := TFhirTestScriptFixture.create;
  try
    ParseTestScriptFixtureProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTestScriptFixtureProperties(jsn : TJsonObject; result : TFhirTestScriptFixture);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('autocreate') or jsn.has('_autocreate') then
        result.autocreateElement := ParseBoolean(jsn.node['autocreate'], jsn.vObj['_autocreate']);{q}
    if jsn.has('autodelete') or jsn.has('_autodelete') then
        result.autodeleteElement := ParseBoolean(jsn.node['autodelete'], jsn.vObj['_autodelete']);{q}
    if jsn.has('resource') then
        result.resource := ParseReference{TFhirReference}(jsn.vObj['resource']);{q3}
end;

procedure TFHIRJsonComposer.ComposeTestScriptFixture(json : TJSONWriter; name : string; elem : TFhirTestScriptFixture; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'autocreate', elem.autocreateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'autocreate', elem.autocreateElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'autodelete', elem.autodeleteElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'autodelete', elem.autodeleteElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(json, 'resource', elem.resource); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseTestScriptVariable(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptVariable(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptVariable(jsn : TJsonObject) : TFhirTestScriptVariable;
begin
  result := TFhirTestScriptVariable.create;
  try
    ParseTestScriptVariableProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTestScriptVariableProperties(jsn : TJsonObject; result : TFhirTestScriptVariable);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('headerField') or jsn.has('_headerField') then
        result.headerFieldElement := ParseString(jsn.node['headerField'], jsn.vObj['_headerField']);{q}
    if jsn.has('path') or jsn.has('_path') then
        result.pathElement := ParseString(jsn.node['path'], jsn.vObj['_path']);{q}
    if jsn.has('sourceId') or jsn.has('_sourceId') then
        result.sourceIdElement := ParseId(jsn.node['sourceId'], jsn.vObj['_sourceId']);{q}
end;

procedure TFHIRJsonComposer.ComposeTestScriptVariable(json : TJSONWriter; name : string; elem : TFhirTestScriptVariable; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'headerField', elem.headerFieldElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'headerField', elem.headerFieldElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'path', elem.pathElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'path', elem.pathElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdValue(json, 'sourceId', elem.sourceIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdProps(json, 'sourceId', elem.sourceIdElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseTestScriptSetup(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptSetup(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptSetup(jsn : TJsonObject) : TFhirTestScriptSetup;
begin
  result := TFhirTestScriptSetup.create;
  try
    ParseTestScriptSetupProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTestScriptSetupProperties(jsn : TJsonObject; result : TFhirTestScriptSetup);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('metadata') then
        result.metadata := ParseTestScriptMetadata(jsn.vObj['metadata']);{q3}
    if jsn.has('action') then
      iterateArray(jsn.vArr['action'], result.actionList, parseTestScriptSetupAction);
end;

procedure TFHIRJsonComposer.ComposeTestScriptSetup(json : TJSONWriter; name : string; elem : TFhirTestScriptSetup; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptMetadata(json, 'metadata', elem.metadata); {a}
  if (elem.actionList.Count > 0) then
  begin
    startArray(json, 'action', elem.actionList, false);
    for i := 0 to elem.actionList.Count - 1 do
      ComposeTestScriptSetupAction(json, '', elem.actionList[i]); {z - }
    finishArray(json, elem.actionList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseTestScriptSetupAction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptSetupAction(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptSetupAction(jsn : TJsonObject) : TFhirTestScriptSetupAction;
begin
  result := TFhirTestScriptSetupAction.create;
  try
    ParseTestScriptSetupActionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTestScriptSetupActionProperties(jsn : TJsonObject; result : TFhirTestScriptSetupAction);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('operation') then
        result.operation := ParseTestScriptSetupActionOperation(jsn.vObj['operation']);{q3}
    if jsn.has('assert') then
        result.assert := ParseTestScriptSetupActionAssert(jsn.vObj['assert']);{q3}
end;

procedure TFHIRJsonComposer.ComposeTestScriptSetupAction(json : TJSONWriter; name : string; elem : TFhirTestScriptSetupAction; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionOperation(json, 'operation', elem.operation); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionAssert(json, 'assert', elem.assert); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseTestScriptSetupActionOperation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptSetupActionOperation(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptSetupActionOperation(jsn : TJsonObject) : TFhirTestScriptSetupActionOperation;
begin
  result := TFhirTestScriptSetupActionOperation.create;
  try
    ParseTestScriptSetupActionOperationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTestScriptSetupActionOperationProperties(jsn : TJsonObject; result : TFhirTestScriptSetupActionOperation);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('type') then
        result.type_ := ParseCoding(jsn.vObj['type']);{q3}
    if jsn.has('resource') or jsn.has('_resource') then
        result.resourceElement := ParseCode(jsn.node['resource'], jsn.vObj['_resource']);{q}
    if jsn.has('label') or jsn.has('_label') then
        result.label_Element := ParseString(jsn.node['label'], jsn.vObj['_label']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('accept') or jsn.has('_accept')  then
      result.acceptElement := parseEnum(jsn.path+'/accept', jsn.node['accept'], jsn.vObj['_accept'], CODES_TFhirContentTypeEnum, SYSTEMS_TFhirContentTypeEnum);
    if jsn.has('contentType') or jsn.has('_contentType')  then
      result.contentTypeElement := parseEnum(jsn.path+'/contentType', jsn.node['contentType'], jsn.vObj['_contentType'], CODES_TFhirContentTypeEnum, SYSTEMS_TFhirContentTypeEnum);
    if jsn.has('destination') or jsn.has('_destination') then
        result.destinationElement := ParseInteger(jsn.node['destination'], jsn.vObj['_destination']);{q}
    if jsn.has('encodeRequestUrl') or jsn.has('_encodeRequestUrl') then
        result.encodeRequestUrlElement := ParseBoolean(jsn.node['encodeRequestUrl'], jsn.vObj['_encodeRequestUrl']);{q}
    if jsn.has('params') or jsn.has('_params') then
        result.paramsElement := ParseString(jsn.node['params'], jsn.vObj['_params']);{q}
    if jsn.has('requestHeader') then
      iterateArray(jsn.vArr['requestHeader'], result.requestHeaderList, parseTestScriptSetupActionOperationRequestHeader);
    if jsn.has('responseId') or jsn.has('_responseId') then
        result.responseIdElement := ParseId(jsn.node['responseId'], jsn.vObj['_responseId']);{q}
    if jsn.has('sourceId') or jsn.has('_sourceId') then
        result.sourceIdElement := ParseId(jsn.node['sourceId'], jsn.vObj['_sourceId']);{q}
    if jsn.has('targetId') or jsn.has('_targetId') then
        result.targetIdElement := ParseId(jsn.node['targetId'], jsn.vObj['_targetId']);{q}
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseString(jsn.node['url'], jsn.vObj['_url']);{q}
end;

procedure TFHIRJsonComposer.ComposeTestScriptSetupActionOperation(json : TJSONWriter; name : string; elem : TFhirTestScriptSetupActionOperation; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(json, 'type', elem.type_); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeValue(json, 'resource', elem.resourceElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeProps(json, 'resource', elem.resourceElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'label', elem.label_Element, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'label', elem.label_Element, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'accept', elem.AcceptElement, CODES_TFhirContentTypeEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'accept', elem.AcceptElement, CODES_TFhirContentTypeEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'contentType', elem.ContentTypeElement, CODES_TFhirContentTypeEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'contentType', elem.ContentTypeElement, CODES_TFhirContentTypeEnum, false);
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.destination <> '0')) then
    ComposeIntegerValue(json, 'destination', elem.destinationElement, false);
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.destination <> '0')) then
    ComposeIntegerProps(json, 'destination', elem.destinationElement, false);
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.encodeRequestUrl <> true)) then
    ComposeBooleanValue(json, 'encodeRequestUrl', elem.encodeRequestUrlElement, false);
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.encodeRequestUrl <> true)) then
    ComposeBooleanProps(json, 'encodeRequestUrl', elem.encodeRequestUrlElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'params', elem.paramsElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'params', elem.paramsElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.requestHeaderList.Count > 0) then
  begin
    startArray(json, 'requestHeader', elem.requestHeaderList, false);
    for i := 0 to elem.requestHeaderList.Count - 1 do
      ComposeTestScriptSetupActionOperationRequestHeader(json, '', elem.requestHeaderList[i]); {z - }
    finishArray(json, elem.requestHeaderList);
  end;
  if (SummaryOption in [soFull, soData]) then
    ComposeIdValue(json, 'responseId', elem.responseIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdProps(json, 'responseId', elem.responseIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdValue(json, 'sourceId', elem.sourceIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdProps(json, 'sourceId', elem.sourceIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdValue(json, 'targetId', elem.targetIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdProps(json, 'targetId', elem.targetIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'url', elem.urlElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseTestScriptSetupActionOperationRequestHeader(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptSetupActionOperationRequestHeader(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptSetupActionOperationRequestHeader(jsn : TJsonObject) : TFhirTestScriptSetupActionOperationRequestHeader;
begin
  result := TFhirTestScriptSetupActionOperationRequestHeader.create;
  try
    ParseTestScriptSetupActionOperationRequestHeaderProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTestScriptSetupActionOperationRequestHeaderProperties(jsn : TJsonObject; result : TFhirTestScriptSetupActionOperationRequestHeader);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('field') or jsn.has('_field') then
        result.fieldElement := ParseString(jsn.node['field'], jsn.vObj['_field']);{q}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := ParseString(jsn.node['value'], jsn.vObj['_value']);{q}
end;

procedure TFHIRJsonComposer.ComposeTestScriptSetupActionOperationRequestHeader(json : TJSONWriter; name : string; elem : TFhirTestScriptSetupActionOperationRequestHeader; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'field', elem.fieldElement, false);
  ComposeStringProps(json, 'field', elem.fieldElement, false);
  ComposeStringValue(json, 'value', elem.valueElement, false);
  ComposeStringProps(json, 'value', elem.valueElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseTestScriptSetupActionAssert(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptSetupActionAssert(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptSetupActionAssert(jsn : TJsonObject) : TFhirTestScriptSetupActionAssert;
begin
  result := TFhirTestScriptSetupActionAssert.create;
  try
    ParseTestScriptSetupActionAssertProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTestScriptSetupActionAssertProperties(jsn : TJsonObject; result : TFhirTestScriptSetupActionAssert);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('label') or jsn.has('_label') then
        result.label_Element := ParseString(jsn.node['label'], jsn.vObj['_label']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('direction') or jsn.has('_direction')  then
      result.directionElement := parseEnum(jsn.path+'/direction', jsn.node['direction'], jsn.vObj['_direction'], CODES_TFhirAssertDirectionCodesEnum, SYSTEMS_TFhirAssertDirectionCodesEnum);
    if jsn.has('compareToSourceId') or jsn.has('_compareToSourceId') then
        result.compareToSourceIdElement := ParseString(jsn.node['compareToSourceId'], jsn.vObj['_compareToSourceId']);{q}
    if jsn.has('compareToSourcePath') or jsn.has('_compareToSourcePath') then
        result.compareToSourcePathElement := ParseString(jsn.node['compareToSourcePath'], jsn.vObj['_compareToSourcePath']);{q}
    if jsn.has('contentType') or jsn.has('_contentType')  then
      result.contentTypeElement := parseEnum(jsn.path+'/contentType', jsn.node['contentType'], jsn.vObj['_contentType'], CODES_TFhirContentTypeEnum, SYSTEMS_TFhirContentTypeEnum);
    if jsn.has('headerField') or jsn.has('_headerField') then
        result.headerFieldElement := ParseString(jsn.node['headerField'], jsn.vObj['_headerField']);{q}
    if jsn.has('minimumId') or jsn.has('_minimumId') then
        result.minimumIdElement := ParseString(jsn.node['minimumId'], jsn.vObj['_minimumId']);{q}
    if jsn.has('navigationLinks') or jsn.has('_navigationLinks') then
        result.navigationLinksElement := ParseBoolean(jsn.node['navigationLinks'], jsn.vObj['_navigationLinks']);{q}
    if jsn.has('operator') or jsn.has('_operator')  then
      result.operatorElement := parseEnum(jsn.path+'/operator', jsn.node['operator'], jsn.vObj['_operator'], CODES_TFhirAssertOperatorCodesEnum, SYSTEMS_TFhirAssertOperatorCodesEnum);
    if jsn.has('path') or jsn.has('_path') then
        result.pathElement := ParseString(jsn.node['path'], jsn.vObj['_path']);{q}
    if jsn.has('resource') or jsn.has('_resource') then
        result.resourceElement := ParseCode(jsn.node['resource'], jsn.vObj['_resource']);{q}
    if jsn.has('response') or jsn.has('_response')  then
      result.responseElement := parseEnum(jsn.path+'/response', jsn.node['response'], jsn.vObj['_response'], CODES_TFhirAssertResponseCodeTypesEnum, SYSTEMS_TFhirAssertResponseCodeTypesEnum);
    if jsn.has('responseCode') or jsn.has('_responseCode') then
        result.responseCodeElement := ParseString(jsn.node['responseCode'], jsn.vObj['_responseCode']);{q}
    if jsn.has('sourceId') or jsn.has('_sourceId') then
        result.sourceIdElement := ParseId(jsn.node['sourceId'], jsn.vObj['_sourceId']);{q}
    if jsn.has('validateProfileId') or jsn.has('_validateProfileId') then
        result.validateProfileIdElement := ParseId(jsn.node['validateProfileId'], jsn.vObj['_validateProfileId']);{q}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := ParseString(jsn.node['value'], jsn.vObj['_value']);{q}
    if jsn.has('warningOnly') or jsn.has('_warningOnly') then
        result.warningOnlyElement := ParseBoolean(jsn.node['warningOnly'], jsn.vObj['_warningOnly']);{q}
end;

procedure TFHIRJsonComposer.ComposeTestScriptSetupActionAssert(json : TJSONWriter; name : string; elem : TFhirTestScriptSetupActionAssert; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'label', elem.label_Element, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'label', elem.label_Element, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'direction', elem.DirectionElement, CODES_TFhirAssertDirectionCodesEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'direction', elem.DirectionElement, CODES_TFhirAssertDirectionCodesEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'compareToSourceId', elem.compareToSourceIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'compareToSourceId', elem.compareToSourceIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'compareToSourcePath', elem.compareToSourcePathElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'compareToSourcePath', elem.compareToSourcePathElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'contentType', elem.ContentTypeElement, CODES_TFhirContentTypeEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'contentType', elem.ContentTypeElement, CODES_TFhirContentTypeEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'headerField', elem.headerFieldElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'headerField', elem.headerFieldElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'minimumId', elem.minimumIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'minimumId', elem.minimumIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'navigationLinks', elem.navigationLinksElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'navigationLinks', elem.navigationLinksElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'operator', elem.OperatorElement, CODES_TFhirAssertOperatorCodesEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'operator', elem.OperatorElement, CODES_TFhirAssertOperatorCodesEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'path', elem.pathElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'path', elem.pathElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeValue(json, 'resource', elem.resourceElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeProps(json, 'resource', elem.resourceElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumValue(json, 'response', elem.ResponseElement, CODES_TFhirAssertResponseCodeTypesEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnumProps(json, 'response', elem.ResponseElement, CODES_TFhirAssertResponseCodeTypesEnum, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'responseCode', elem.responseCodeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'responseCode', elem.responseCodeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdValue(json, 'sourceId', elem.sourceIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdProps(json, 'sourceId', elem.sourceIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdValue(json, 'validateProfileId', elem.validateProfileIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdProps(json, 'validateProfileId', elem.validateProfileIdElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'value', elem.valueElement, false);
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.warningOnly <> false)) then
    ComposeBooleanValue(json, 'warningOnly', elem.warningOnlyElement, false);
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.warningOnly <> false)) then
    ComposeBooleanProps(json, 'warningOnly', elem.warningOnlyElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseTestScriptTest(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptTest(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptTest(jsn : TJsonObject) : TFhirTestScriptTest;
begin
  result := TFhirTestScriptTest.create;
  try
    ParseTestScriptTestProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTestScriptTestProperties(jsn : TJsonObject; result : TFhirTestScriptTest);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('metadata') then
        result.metadata := ParseTestScriptMetadata(jsn.vObj['metadata']);{q3}
    if jsn.has('action') then
      iterateArray(jsn.vArr['action'], result.actionList, parseTestScriptTestAction);
end;

procedure TFHIRJsonComposer.ComposeTestScriptTest(json : TJSONWriter; name : string; elem : TFhirTestScriptTest; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptMetadata(json, 'metadata', elem.metadata); {a}
  if (elem.actionList.Count > 0) then
  begin
    startArray(json, 'action', elem.actionList, false);
    for i := 0 to elem.actionList.Count - 1 do
      ComposeTestScriptTestAction(json, '', elem.actionList[i]); {z - }
    finishArray(json, elem.actionList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseTestScriptTestAction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptTestAction(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptTestAction(jsn : TJsonObject) : TFhirTestScriptTestAction;
begin
  result := TFhirTestScriptTestAction.create;
  try
    ParseTestScriptTestActionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTestScriptTestActionProperties(jsn : TJsonObject; result : TFhirTestScriptTestAction);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('operation') then
        result.operation := ParseTestScriptSetupActionOperation(jsn.vObj['operation']);{q3}
    if jsn.has('assert') then
        result.assert := ParseTestScriptSetupActionAssert(jsn.vObj['assert']);{q3}
end;

procedure TFHIRJsonComposer.ComposeTestScriptTestAction(json : TJSONWriter; name : string; elem : TFhirTestScriptTestAction; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionOperation(json, 'operation', elem.operation); {a}
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionAssert(json, 'assert', elem.assert); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseTestScriptTeardown(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptTeardown(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptTeardown(jsn : TJsonObject) : TFhirTestScriptTeardown;
begin
  result := TFhirTestScriptTeardown.create;
  try
    ParseTestScriptTeardownProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTestScriptTeardownProperties(jsn : TJsonObject; result : TFhirTestScriptTeardown);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('action') then
      iterateArray(jsn.vArr['action'], result.actionList, parseTestScriptTeardownAction);
end;

procedure TFHIRJsonComposer.ComposeTestScriptTeardown(json : TJSONWriter; name : string; elem : TFhirTestScriptTeardown; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (elem.actionList.Count > 0) then
  begin
    startArray(json, 'action', elem.actionList, false);
    for i := 0 to elem.actionList.Count - 1 do
      ComposeTestScriptTeardownAction(json, '', elem.actionList[i]); {z - }
    finishArray(json, elem.actionList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseTestScriptTeardownAction(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScriptTeardownAction(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScriptTeardownAction(jsn : TJsonObject) : TFhirTestScriptTeardownAction;
begin
  result := TFhirTestScriptTeardownAction.create;
  try
    ParseTestScriptTeardownActionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTestScriptTeardownActionProperties(jsn : TJsonObject; result : TFhirTestScriptTeardownAction);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('operation') then
        result.operation := ParseTestScriptSetupActionOperation(jsn.vObj['operation']);{q3}
end;

procedure TFHIRJsonComposer.ComposeTestScriptTeardownAction(json : TJSONWriter; name : string; elem : TFhirTestScriptTeardownAction; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionOperation(json, 'operation', elem.operation); {a}
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseTestScript(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseTestScript(jsn)); {2}
end;

function TFHIRJsonParser.ParseTestScript(jsn : TJsonObject) : TFhirTestScript;
begin
  result := TFhirTestScript.create;
  try
    ParseTestScriptProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseTestScriptProperties(jsn : TJsonObject; result : TFhirTestScript);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum);
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := ParseBoolean(jsn.node['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := ParseString(jsn.node['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseTestScriptContact);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseCodeableConcept);
    if jsn.has('requirements') or jsn.has('_requirements') then
        result.requirementsElement := ParseString(jsn.node['requirements'], jsn.vObj['_requirements']);{q}
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := ParseString(jsn.node['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('metadata') then
        result.metadata := ParseTestScriptMetadata(jsn.vObj['metadata']);{q3}
    if jsn.has('multiserver') or jsn.has('_multiserver') then
        result.multiserverElement := ParseBoolean(jsn.node['multiserver'], jsn.vObj['_multiserver']);{q}
    if jsn.has('fixture') then
      iterateArray(jsn.vArr['fixture'], result.fixtureList, parseTestScriptFixture);
    if jsn.has('profile') then
      iterateArray(jsn.vArr['profile'], result.profileList, parseReference{TFhirReference});
    if jsn.has('variable') then
      iterateArray(jsn.vArr['variable'], result.variableList, parseTestScriptVariable);
    if jsn.has('setup') then
        result.setup := ParseTestScriptSetup(jsn.vObj['setup']);{q3}
    if jsn.has('test') then
      iterateArray(jsn.vArr['test'], result.testList, parseTestScriptTest);
    if jsn.has('teardown') then
        result.teardown := ParseTestScriptTeardown(jsn.vObj['teardown']);{q3}
end;

procedure TFHIRJsonComposer.ComposeTestScript(json : TJSONWriter; name : string; elem : TFhirTestScript; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  ComposeUriValue(json, 'url', elem.urlElement, false);
  ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    startArray(json, 'contact', elem.contactList, false);
    for i := 0 to elem.contactList.Count - 1 do
      ComposeTestScriptContact(json, '', elem.contactList[i]); {z - }
    finishArray(json, elem.contactList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') and (elem.useContextList.Count > 0) then
  begin
    startArray(json, 'useContext', elem.useContextList, false);
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.useContextList[i]); {z - CodeableConcept}
    finishArray(json, elem.useContextList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('requirements') then
    ComposeStringValue(json, 'requirements', elem.requirementsElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('requirements') then
    ComposeStringProps(json, 'requirements', elem.requirementsElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeStringValue(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeStringProps(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('metadata') then
    ComposeTestScriptMetadata(json, 'metadata', elem.metadata); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('multiserver') then
    ComposeBooleanValue(json, 'multiserver', elem.multiserverElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('multiserver') then
    ComposeBooleanProps(json, 'multiserver', elem.multiserverElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('fixture') and (elem.fixtureList.Count > 0) then
  begin
    startArray(json, 'fixture', elem.fixtureList, false);
    for i := 0 to elem.fixtureList.Count - 1 do
      ComposeTestScriptFixture(json, '', elem.fixtureList[i]); {z - }
    finishArray(json, elem.fixtureList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('profile') and (elem.profileList.Count > 0) then
  begin
    startArray(json, 'profile', elem.profileList, false);
    for i := 0 to elem.profileList.Count - 1 do
      ComposeReference{TFhirReference}(json, '', elem.profileList[i]); {z - Reference(Any)}
    finishArray(json, elem.profileList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('variable') and (elem.variableList.Count > 0) then
  begin
    startArray(json, 'variable', elem.variableList, false);
    for i := 0 to elem.variableList.Count - 1 do
      ComposeTestScriptVariable(json, '', elem.variableList[i]); {z - }
    finishArray(json, elem.variableList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('setup') then
    ComposeTestScriptSetup(json, 'setup', elem.setup); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('test') and (elem.testList.Count > 0) then
  begin
    startArray(json, 'test', elem.testList, false);
    for i := 0 to elem.testList.Count - 1 do
      ComposeTestScriptTest(json, '', elem.testList[i]); {z - }
    finishArray(json, elem.testList);
  end;
  if (SummaryOption in [soFull, soData]) and doCompose('teardown') then
    ComposeTestScriptTeardown(json, 'teardown', elem.teardown); {a}
end;

{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
procedure TFHIRJsonParser.ParseValueSetContact(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetContact(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSetContact(jsn : TJsonObject) : TFhirValueSetContact;
begin
  result := TFhirValueSetContact.create;
  try
    ParseValueSetContactProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseValueSetContactProperties(jsn : TJsonObject; result : TFhirValueSetContact);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('telecom') then
      iterateArray(jsn.vArr['telecom'], result.telecomList, parseContactPoint);
end;

procedure TFHIRJsonComposer.ComposeValueSetContact(json : TJSONWriter; name : string; elem : TFhirValueSetContact; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.telecomList.Count > 0) then
  begin
    startArray(json, 'telecom', elem.telecomList, false);
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(json, '', elem.telecomList[i]); {z - ContactPoint}
    finishArray(json, elem.telecomList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseValueSetCodeSystem(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetCodeSystem(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSetCodeSystem(jsn : TJsonObject) : TFhirValueSetCodeSystem;
begin
  result := TFhirValueSetCodeSystem.create;
  try
    ParseValueSetCodeSystemProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseValueSetCodeSystemProperties(jsn : TJsonObject; result : TFhirValueSetCodeSystem);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('system') or jsn.has('_system') then
        result.systemElement := ParseUri(jsn.node['system'], jsn.vObj['_system']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('caseSensitive') or jsn.has('_caseSensitive') then
        result.caseSensitiveElement := ParseBoolean(jsn.node['caseSensitive'], jsn.vObj['_caseSensitive']);{q}
    if jsn.has('concept') then
      iterateArray(jsn.vArr['concept'], result.conceptList, parseValueSetCodeSystemConcept);
end;

procedure TFHIRJsonComposer.ComposeValueSetCodeSystem(json : TJSONWriter; name : string; elem : TFhirValueSetCodeSystem; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeUriValue(json, 'system', elem.systemElement, false);
  ComposeUriProps(json, 'system', elem.systemElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanValue(json, 'caseSensitive', elem.caseSensitiveElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBooleanProps(json, 'caseSensitive', elem.caseSensitiveElement, false);
  if (elem.conceptList.Count > 0) then
  begin
    startArray(json, 'concept', elem.conceptList, false);
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeValueSetCodeSystemConcept(json, '', elem.conceptList[i]); {z - }
    finishArray(json, elem.conceptList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseValueSetCodeSystemConcept(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetCodeSystemConcept(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSetCodeSystemConcept(jsn : TJsonObject) : TFhirValueSetCodeSystemConcept;
begin
  result := TFhirValueSetCodeSystemConcept.create;
  try
    ParseValueSetCodeSystemConceptProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseValueSetCodeSystemConceptProperties(jsn : TJsonObject; result : TFhirValueSetCodeSystemConcept);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := ParseCode(jsn.node['code'], jsn.vObj['_code']);{q}
    if jsn.has('abstract') or jsn.has('_abstract') then
        result.abstractElement := ParseBoolean(jsn.node['abstract'], jsn.vObj['_abstract']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.displayElement := ParseString(jsn.node['display'], jsn.vObj['_display']);{q}
    if jsn.has('definition') or jsn.has('_definition') then
        result.definitionElement := ParseString(jsn.node['definition'], jsn.vObj['_definition']);{q}
    if jsn.has('designation') then
      iterateArray(jsn.vArr['designation'], result.designationList, parseValueSetCodeSystemConceptDesignation);
    if jsn.has('concept') then
      iterateArray(jsn.vArr['concept'], result.conceptList, parseValueSetCodeSystemConcept);
end;

procedure TFHIRJsonComposer.ComposeValueSetCodeSystemConcept(json : TJSONWriter; name : string; elem : TFhirValueSetCodeSystemConcept; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeValue(json, 'code', elem.codeElement, false);
  ComposeCodeProps(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.abstract <> false)) then
    ComposeBooleanValue(json, 'abstract', elem.abstractElement, false);
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.abstract <> false)) then
    ComposeBooleanProps(json, 'abstract', elem.abstractElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'display', elem.displayElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'display', elem.displayElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'definition', elem.definitionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'definition', elem.definitionElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.designationList.Count > 0) then
  begin
    startArray(json, 'designation', elem.designationList, false);
    for i := 0 to elem.designationList.Count - 1 do
      ComposeValueSetCodeSystemConceptDesignation(json, '', elem.designationList[i]); {z - }
    finishArray(json, elem.designationList);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.conceptList.Count > 0) then
  begin
    startArray(json, 'concept', elem.conceptList, false);
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeValueSetCodeSystemConcept(json, '', elem.conceptList[i]); {z - @ValueSet.codeSystem.concept}
    finishArray(json, elem.conceptList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseValueSetCodeSystemConceptDesignation(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetCodeSystemConceptDesignation(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSetCodeSystemConceptDesignation(jsn : TJsonObject) : TFhirValueSetCodeSystemConceptDesignation;
begin
  result := TFhirValueSetCodeSystemConceptDesignation.create;
  try
    ParseValueSetCodeSystemConceptDesignationProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseValueSetCodeSystemConceptDesignationProperties(jsn : TJsonObject; result : TFhirValueSetCodeSystemConceptDesignation);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('language') or jsn.has('_language') then
        result.languageElement := ParseCode(jsn.node['language'], jsn.vObj['_language']);{q}
    if jsn.has('use') then
        result.use := ParseCoding(jsn.vObj['use']);{q3}
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := ParseString(jsn.node['value'], jsn.vObj['_value']);{q}
end;

procedure TFHIRJsonComposer.ComposeValueSetCodeSystemConceptDesignation(json : TJSONWriter; name : string; elem : TFhirValueSetCodeSystemConceptDesignation; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeValue(json, 'language', elem.languageElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeProps(json, 'language', elem.languageElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(json, 'use', elem.use); {a}
  ComposeStringValue(json, 'value', elem.valueElement, false);
  ComposeStringProps(json, 'value', elem.valueElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseValueSetCompose(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetCompose(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSetCompose(jsn : TJsonObject) : TFhirValueSetCompose;
begin
  result := TFhirValueSetCompose.create;
  try
    ParseValueSetComposeProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseValueSetComposeProperties(jsn : TJsonObject; result : TFhirValueSetCompose);
begin
    ParseBackboneElementProperties(jsn, result);
      if jsn.has('import') or jsn.has('_import') then
      iteratePrimitiveArray(jsn.vArr['import'], jsn.vArr['_import'], result.importList, parseUri);
    if jsn.has('include') then
      iterateArray(jsn.vArr['include'], result.includeList, parseValueSetComposeInclude);
    if jsn.has('exclude') then
      iterateArray(jsn.vArr['exclude'], result.excludeList, parseValueSetComposeInclude);
end;

procedure TFHIRJsonComposer.ComposeValueSetCompose(json : TJSONWriter; name : string; elem : TFhirValueSetCompose; noObj : boolean = false);
var
  i : integer;
  ext : boolean;
  val : boolean;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.importList.Count > 0) then
  begin
    ext := false;
    val := false;
    for i := 0 to elem.importList.Count - 1 do
    begin
      ext := ext or ((elem.importList[i].id <> '') or (elem.importList[i].hasExtensionList) {no-comments or (elem.importList[i].hasComments)});
      val := val or (elem.importList[i].hasPrimitiveValue);
    end;
    if val then
    begin
      startArray(json, 'import', elem.importList, true);
      for i := 0 to elem.importList.Count - 1 do
        ComposeUriValue(json, '',elem.importList[i], true);
      finishArray(json, elem.importList);
    end;
    if ext then
    begin
      startArray(json, '_import', elem.importList, false);
      for i := 0 to elem.importList.Count - 1 do
        ComposeUriProps(json, '',elem.importList[i], true);
      finishArray(json, elem.importList);
    end;
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.includeList.Count > 0) then
  begin
    startArray(json, 'include', elem.includeList, false);
    for i := 0 to elem.includeList.Count - 1 do
      ComposeValueSetComposeInclude(json, '', elem.includeList[i]); {z - }
    finishArray(json, elem.includeList);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.excludeList.Count > 0) then
  begin
    startArray(json, 'exclude', elem.excludeList, false);
    for i := 0 to elem.excludeList.Count - 1 do
      ComposeValueSetComposeInclude(json, '', elem.excludeList[i]); {z - @ValueSet.compose.include}
    finishArray(json, elem.excludeList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseValueSetComposeInclude(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetComposeInclude(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSetComposeInclude(jsn : TJsonObject) : TFhirValueSetComposeInclude;
begin
  result := TFhirValueSetComposeInclude.create;
  try
    ParseValueSetComposeIncludeProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseValueSetComposeIncludeProperties(jsn : TJsonObject; result : TFhirValueSetComposeInclude);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('system') or jsn.has('_system') then
        result.systemElement := ParseUri(jsn.node['system'], jsn.vObj['_system']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('concept') then
      iterateArray(jsn.vArr['concept'], result.conceptList, parseValueSetComposeIncludeConcept);
    if jsn.has('filter') then
      iterateArray(jsn.vArr['filter'], result.filterList, parseValueSetComposeIncludeFilter);
end;

procedure TFHIRJsonComposer.ComposeValueSetComposeInclude(json : TJSONWriter; name : string; elem : TFhirValueSetComposeInclude; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeUriValue(json, 'system', elem.systemElement, false);
  ComposeUriProps(json, 'system', elem.systemElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.conceptList.Count > 0) then
  begin
    startArray(json, 'concept', elem.conceptList, false);
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeValueSetComposeIncludeConcept(json, '', elem.conceptList[i]); {z - }
    finishArray(json, elem.conceptList);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.filterList.Count > 0) then
  begin
    startArray(json, 'filter', elem.filterList, false);
    for i := 0 to elem.filterList.Count - 1 do
      ComposeValueSetComposeIncludeFilter(json, '', elem.filterList[i]); {z - }
    finishArray(json, elem.filterList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseValueSetComposeIncludeConcept(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetComposeIncludeConcept(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSetComposeIncludeConcept(jsn : TJsonObject) : TFhirValueSetComposeIncludeConcept;
begin
  result := TFhirValueSetComposeIncludeConcept.create;
  try
    ParseValueSetComposeIncludeConceptProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseValueSetComposeIncludeConceptProperties(jsn : TJsonObject; result : TFhirValueSetComposeIncludeConcept);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := ParseCode(jsn.node['code'], jsn.vObj['_code']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.displayElement := ParseString(jsn.node['display'], jsn.vObj['_display']);{q}
    if jsn.has('designation') then
      iterateArray(jsn.vArr['designation'], result.designationList, parseValueSetCodeSystemConceptDesignation);
end;

procedure TFHIRJsonComposer.ComposeValueSetComposeIncludeConcept(json : TJSONWriter; name : string; elem : TFhirValueSetComposeIncludeConcept; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeValue(json, 'code', elem.codeElement, false);
  ComposeCodeProps(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'display', elem.displayElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'display', elem.displayElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.designationList.Count > 0) then
  begin
    startArray(json, 'designation', elem.designationList, false);
    for i := 0 to elem.designationList.Count - 1 do
      ComposeValueSetCodeSystemConceptDesignation(json, '', elem.designationList[i]); {z - @ValueSet.codeSystem.concept.designation}
    finishArray(json, elem.designationList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseValueSetComposeIncludeFilter(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetComposeIncludeFilter(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSetComposeIncludeFilter(jsn : TJsonObject) : TFhirValueSetComposeIncludeFilter;
begin
  result := TFhirValueSetComposeIncludeFilter.create;
  try
    ParseValueSetComposeIncludeFilterProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseValueSetComposeIncludeFilterProperties(jsn : TJsonObject; result : TFhirValueSetComposeIncludeFilter);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('property') or jsn.has('_property') then
        result.property_Element := ParseCode(jsn.node['property'], jsn.vObj['_property']);{q}
    if jsn.has('op') or jsn.has('_op')  then
      result.opElement := parseEnum(jsn.path+'/op', jsn.node['op'], jsn.vObj['_op'], CODES_TFhirFilterOperatorEnum, SYSTEMS_TFhirFilterOperatorEnum);
    if jsn.has('value') or jsn.has('_value') then
        result.valueElement := ParseCode(jsn.node['value'], jsn.vObj['_value']);{q}
end;

procedure TFHIRJsonComposer.ComposeValueSetComposeIncludeFilter(json : TJSONWriter; name : string; elem : TFhirValueSetComposeIncludeFilter; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeCodeValue(json, 'property', elem.property_Element, false);
  ComposeCodeProps(json, 'property', elem.property_Element, false);
  ComposeEnumValue(json, 'op', elem.OpElement, CODES_TFhirFilterOperatorEnum, false);
  ComposeEnumProps(json, 'op', elem.OpElement, CODES_TFhirFilterOperatorEnum, false);
  ComposeCodeValue(json, 'value', elem.valueElement, false);
  ComposeCodeProps(json, 'value', elem.valueElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseValueSetExpansion(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetExpansion(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSetExpansion(jsn : TJsonObject) : TFhirValueSetExpansion;
begin
  result := TFhirValueSetExpansion.create;
  try
    ParseValueSetExpansionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseValueSetExpansionProperties(jsn : TJsonObject; result : TFhirValueSetExpansion);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('identifier') or jsn.has('_identifier') then
        result.identifierElement := ParseUri(jsn.node['identifier'], jsn.vObj['_identifier']);{q}
    if jsn.has('timestamp') or jsn.has('_timestamp') then
        result.timestampElement := ParseDateTime(jsn.node['timestamp'], jsn.vObj['_timestamp']);{q}
    if jsn.has('total') or jsn.has('_total') then
        result.totalElement := ParseInteger(jsn.node['total'], jsn.vObj['_total']);{q}
    if jsn.has('offset') or jsn.has('_offset') then
        result.offsetElement := ParseInteger(jsn.node['offset'], jsn.vObj['_offset']);{q}
    if jsn.has('parameter') then
      iterateArray(jsn.vArr['parameter'], result.parameterList, parseValueSetExpansionParameter);
    if jsn.has('contains') then
      iterateArray(jsn.vArr['contains'], result.containsList, parseValueSetExpansionContains);
end;

procedure TFHIRJsonComposer.ComposeValueSetExpansion(json : TJSONWriter; name : string; elem : TFhirValueSetExpansion; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeUriValue(json, 'identifier', elem.identifierElement, false);
  ComposeUriProps(json, 'identifier', elem.identifierElement, false);
  ComposeDateTimeValue(json, 'timestamp', elem.timestampElement, false);
  ComposeDateTimeProps(json, 'timestamp', elem.timestampElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerValue(json, 'total', elem.totalElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerProps(json, 'total', elem.totalElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerValue(json, 'offset', elem.offsetElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeIntegerProps(json, 'offset', elem.offsetElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.parameterList.Count > 0) then
  begin
    startArray(json, 'parameter', elem.parameterList, false);
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeValueSetExpansionParameter(json, '', elem.parameterList[i]); {z - }
    finishArray(json, elem.parameterList);
  end;
  if (SummaryOption in [soFull, soData]) and (elem.containsList.Count > 0) then
  begin
    startArray(json, 'contains', elem.containsList, false);
    for i := 0 to elem.containsList.Count - 1 do
      ComposeValueSetExpansionContains(json, '', elem.containsList[i]); {z - }
    finishArray(json, elem.containsList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseValueSetExpansionParameter(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetExpansionParameter(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSetExpansionParameter(jsn : TJsonObject) : TFhirValueSetExpansionParameter;
begin
  result := TFhirValueSetExpansionParameter.create;
  try
    ParseValueSetExpansionParameterProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseValueSetExpansionParameterProperties(jsn : TJsonObject; result : TFhirValueSetExpansionParameter);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('valueCode') or jsn.has('_valueCode') then
      result.value := ParseCode(jsn.node['valueCode'], jsn.vObj['_valueCode']);
    if jsn.has('valueString') or jsn.has('_valueString') then
      result.value := ParseString(jsn.node['valueString'], jsn.vObj['_valueString']);
    if jsn.has('valueBoolean') or jsn.has('_valueBoolean') then
      result.value := ParseBoolean(jsn.node['valueBoolean'], jsn.vObj['_valueBoolean']);
    if jsn.has('valueInteger') or jsn.has('_valueInteger') then
      result.value := ParseInteger(jsn.node['valueInteger'], jsn.vObj['_valueInteger']);
    if jsn.has('valueDecimal') or jsn.has('_valueDecimal') then
      result.value := ParseDecimal(jsn.node['valueDecimal'], jsn.vObj['_valueDecimal']);
    if jsn.has('valueUri') or jsn.has('_valueUri') then
      result.value := ParseUri(jsn.node['valueUri'], jsn.vObj['_valueUri']);
end;

procedure TFHIRJsonComposer.ComposeValueSetExpansionParameter(json : TJSONWriter; name : string; elem : TFhirValueSetExpansionParameter; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeStringValue(json, 'name', elem.nameElement, false);
  ComposeStringProps(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.value is TFhirCode) then 
  begin
    ComposeCodeValue(json, 'valueCode', TFhirCode(elem.value), false);
    ComposeCodeProps(json, 'valueCode', TFhirCode(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirString) then 
  begin
    ComposeStringValue(json, 'valueString', TFhirString(elem.value), false);
    ComposeStringProps(json, 'valueString', TFhirString(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirBoolean) then 
  begin
    ComposeBooleanValue(json, 'valueBoolean', TFhirBoolean(elem.value), false);
    ComposeBooleanProps(json, 'valueBoolean', TFhirBoolean(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirInteger) then 
  begin
    ComposeIntegerValue(json, 'valueInteger', TFhirInteger(elem.value), false);
    ComposeIntegerProps(json, 'valueInteger', TFhirInteger(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirDecimal) then 
  begin
    ComposeDecimalValue(json, 'valueDecimal', TFhirDecimal(elem.value), false);
    ComposeDecimalProps(json, 'valueDecimal', TFhirDecimal(elem.value), false);
  end
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirUri) then 
  begin
    ComposeUriValue(json, 'valueUri', TFhirUri(elem.value), false);
    ComposeUriProps(json, 'valueUri', TFhirUri(elem.value), false);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseValueSetExpansionContains(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSetExpansionContains(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSetExpansionContains(jsn : TJsonObject) : TFhirValueSetExpansionContains;
begin
  result := TFhirValueSetExpansionContains.create;
  try
    ParseValueSetExpansionContainsProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseValueSetExpansionContainsProperties(jsn : TJsonObject; result : TFhirValueSetExpansionContains);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('system') or jsn.has('_system') then
        result.systemElement := ParseUri(jsn.node['system'], jsn.vObj['_system']);{q}
    if jsn.has('abstract') or jsn.has('_abstract') then
        result.abstractElement := ParseBoolean(jsn.node['abstract'], jsn.vObj['_abstract']);{q}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('code') or jsn.has('_code') then
        result.codeElement := ParseCode(jsn.node['code'], jsn.vObj['_code']);{q}
    if jsn.has('display') or jsn.has('_display') then
        result.displayElement := ParseString(jsn.node['display'], jsn.vObj['_display']);{q}
    if jsn.has('contains') then
      iterateArray(jsn.vArr['contains'], result.containsList, parseValueSetExpansionContains);
end;

procedure TFHIRJsonComposer.ComposeValueSetExpansionContains(json : TJSONWriter; name : string; elem : TFhirValueSetExpansionContains; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriValue(json, 'system', elem.systemElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeUriProps(json, 'system', elem.systemElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanValue(json, 'abstract', elem.abstractElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeBooleanProps(json, 'abstract', elem.abstractElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeValue(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeProps(json, 'code', elem.codeElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringValue(json, 'display', elem.displayElement, false);
  if (SummaryOption in [soFull, soData]) then
    ComposeStringProps(json, 'display', elem.displayElement, false);
  if (SummaryOption in [soFull, soData]) and (elem.containsList.Count > 0) then
  begin
    startArray(json, 'contains', elem.containsList, false);
    for i := 0 to elem.containsList.Count - 1 do
      ComposeValueSetExpansionContains(json, '', elem.containsList[i]); {z - @ValueSet.expansion.contains}
    finishArray(json, elem.containsList);
  end;
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseValueSet(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseValueSet(jsn)); {2}
end;

function TFHIRJsonParser.ParseValueSet(jsn : TJsonObject) : TFhirValueSet;
begin
  result := TFhirValueSet.create;
  try
    ParseValueSetProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseValueSetProperties(jsn : TJsonObject; result : TFhirValueSet);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('url') or jsn.has('_url') then
        result.urlElement := ParseUri(jsn.node['url'], jsn.vObj['_url']);{q}
    if jsn.has('identifier') then
        result.identifier := ParseIdentifier(jsn.vObj['identifier']);{q3}
    if jsn.has('version') or jsn.has('_version') then
        result.versionElement := ParseString(jsn.node['version'], jsn.vObj['_version']);{q}
    if jsn.has('name') or jsn.has('_name') then
        result.nameElement := ParseString(jsn.node['name'], jsn.vObj['_name']);{q}
    if jsn.has('status') or jsn.has('_status')  then
      result.statusElement := parseEnum(jsn.path+'/status', jsn.node['status'], jsn.vObj['_status'], CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum);
    if jsn.has('experimental') or jsn.has('_experimental') then
        result.experimentalElement := ParseBoolean(jsn.node['experimental'], jsn.vObj['_experimental']);{q}
    if jsn.has('publisher') or jsn.has('_publisher') then
        result.publisherElement := ParseString(jsn.node['publisher'], jsn.vObj['_publisher']);{q}
    if jsn.has('contact') then
      iterateArray(jsn.vArr['contact'], result.contactList, parseValueSetContact);
    if jsn.has('date') or jsn.has('_date') then
        result.dateElement := ParseDateTime(jsn.node['date'], jsn.vObj['_date']);{q}
    if jsn.has('lockedDate') or jsn.has('_lockedDate') then
        result.lockedDateElement := ParseDate(jsn.node['lockedDate'], jsn.vObj['_lockedDate']);{q}
    if jsn.has('description') or jsn.has('_description') then
        result.descriptionElement := ParseString(jsn.node['description'], jsn.vObj['_description']);{q}
    if jsn.has('useContext') then
      iterateArray(jsn.vArr['useContext'], result.useContextList, parseCodeableConcept);
    if jsn.has('immutable') or jsn.has('_immutable') then
        result.immutableElement := ParseBoolean(jsn.node['immutable'], jsn.vObj['_immutable']);{q}
    if jsn.has('requirements') or jsn.has('_requirements') then
        result.requirementsElement := ParseString(jsn.node['requirements'], jsn.vObj['_requirements']);{q}
    if jsn.has('copyright') or jsn.has('_copyright') then
        result.copyrightElement := ParseString(jsn.node['copyright'], jsn.vObj['_copyright']);{q}
    if jsn.has('extensible') or jsn.has('_extensible') then
        result.extensibleElement := ParseBoolean(jsn.node['extensible'], jsn.vObj['_extensible']);{q}
    if jsn.has('codeSystem') then
        result.codeSystem := ParseValueSetCodeSystem(jsn.vObj['codeSystem']);{q3}
    if jsn.has('compose') then
        result.compose := ParseValueSetCompose(jsn.vObj['compose']);{q3}
    if jsn.has('expansion') then
        result.expansion := ParseValueSetExpansion(jsn.vObj['expansion']);{q3}
end;

procedure TFHIRJsonComposer.ComposeValueSet(json : TJSONWriter; name : string; elem : TFhirValueSet; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriValue(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUriProps(json, 'url', elem.urlElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(json, 'identifier', elem.identifier); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringValue(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeStringProps(json, 'version', elem.versionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringValue(json, 'name', elem.nameElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeStringProps(json, 'name', elem.nameElement, false);
  ComposeEnumValue(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, false);
  ComposeEnumProps(json, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanValue(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBooleanProps(json, 'experimental', elem.experimentalElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringValue(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeStringProps(json, 'publisher', elem.publisherElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') and (elem.contactList.Count > 0) then
  begin
    startArray(json, 'contact', elem.contactList, false);
    for i := 0 to elem.contactList.Count - 1 do
      ComposeValueSetContact(json, '', elem.contactList[i]); {z - }
    finishArray(json, elem.contactList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeValue(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTimeProps(json, 'date', elem.dateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('lockedDate') then
    ComposeDateValue(json, 'lockedDate', elem.lockedDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('lockedDate') then
    ComposeDateProps(json, 'lockedDate', elem.lockedDateElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringValue(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeStringProps(json, 'description', elem.descriptionElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') and (elem.useContextList.Count > 0) then
  begin
    startArray(json, 'useContext', elem.useContextList, false);
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(json, '', elem.useContextList[i]); {z - CodeableConcept}
    finishArray(json, elem.useContextList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('immutable') then
    ComposeBooleanValue(json, 'immutable', elem.immutableElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('immutable') then
    ComposeBooleanProps(json, 'immutable', elem.immutableElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('requirements') then
    ComposeStringValue(json, 'requirements', elem.requirementsElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('requirements') then
    ComposeStringProps(json, 'requirements', elem.requirementsElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeStringValue(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeStringProps(json, 'copyright', elem.copyrightElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('extensible') then
    ComposeBooleanValue(json, 'extensible', elem.extensibleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('extensible') then
    ComposeBooleanProps(json, 'extensible', elem.extensibleElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('codeSystem') then
    ComposeValueSetCodeSystem(json, 'codeSystem', elem.codeSystem); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('compose') then
    ComposeValueSetCompose(json, 'compose', elem.compose); {a}
  if (SummaryOption in [soFull, soData]) and doCompose('expansion') then
    ComposeValueSetExpansion(json, 'expansion', elem.expansion); {a}
end;

{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VISIONPRESCRIPTION}
procedure TFHIRJsonParser.ParseVisionPrescriptionDispense(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseVisionPrescriptionDispense(jsn)); {2}
end;

function TFHIRJsonParser.ParseVisionPrescriptionDispense(jsn : TJsonObject) : TFhirVisionPrescriptionDispense;
begin
  result := TFhirVisionPrescriptionDispense.create;
  try
    ParseVisionPrescriptionDispenseProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseVisionPrescriptionDispenseProperties(jsn : TJsonObject; result : TFhirVisionPrescriptionDispense);
begin
    ParseBackboneElementProperties(jsn, result);
    if jsn.has('product') then
        result.product := ParseCoding(jsn.vObj['product']);{q3}
    if jsn.has('eye') or jsn.has('_eye')  then
      result.eyeElement := parseEnum(jsn.path+'/eye', jsn.node['eye'], jsn.vObj['_eye'], CODES_TFhirVisionEyeCodesEnum, SYSTEMS_TFhirVisionEyeCodesEnum);
    if jsn.has('sphere') or jsn.has('_sphere') then
        result.sphereElement := ParseDecimal(jsn.node['sphere'], jsn.vObj['_sphere']);{q}
    if jsn.has('cylinder') or jsn.has('_cylinder') then
        result.cylinderElement := ParseDecimal(jsn.node['cylinder'], jsn.vObj['_cylinder']);{q}
    if jsn.has('axis') or jsn.has('_axis') then
        result.axisElement := ParseInteger(jsn.node['axis'], jsn.vObj['_axis']);{q}
    if jsn.has('prism') or jsn.has('_prism') then
        result.prismElement := ParseDecimal(jsn.node['prism'], jsn.vObj['_prism']);{q}
    if jsn.has('base') or jsn.has('_base')  then
      result.baseElement := parseEnum(jsn.path+'/base', jsn.node['base'], jsn.vObj['_base'], CODES_TFhirVisionBaseCodesEnum, SYSTEMS_TFhirVisionBaseCodesEnum);
    if jsn.has('add') or jsn.has('_add') then
        result.addElement := ParseDecimal(jsn.node['add'], jsn.vObj['_add']);{q}
    if jsn.has('power') or jsn.has('_power') then
        result.powerElement := ParseDecimal(jsn.node['power'], jsn.vObj['_power']);{q}
    if jsn.has('backCurve') or jsn.has('_backCurve') then
        result.backCurveElement := ParseDecimal(jsn.node['backCurve'], jsn.vObj['_backCurve']);{q}
    if jsn.has('diameter') or jsn.has('_diameter') then
        result.diameterElement := ParseDecimal(jsn.node['diameter'], jsn.vObj['_diameter']);{q}
    if jsn.has('duration') then
        result.duration := ParseQuantity(jsn.vObj['duration']);{q3}
    if jsn.has('color') or jsn.has('_color') then
        result.colorElement := ParseString(jsn.node['color'], jsn.vObj['_color']);{q}
    if jsn.has('brand') or jsn.has('_brand') then
        result.brandElement := ParseString(jsn.node['brand'], jsn.vObj['_brand']);{q}
    if jsn.has('notes') or jsn.has('_notes') then
        result.notesElement := ParseString(jsn.node['notes'], jsn.vObj['_notes']);{q}
end;

procedure TFHIRJsonComposer.ComposeVisionPrescriptionDispense(json : TJSONWriter; name : string; elem : TFhirVisionPrescriptionDispense; noObj : boolean = false);
begin
  if (elem = nil) then
    exit;
  startElement(json, name, elem, noObj);
  ComposeBackboneElementProperties(json, elem);
  ComposeCoding(json, 'product', elem.product); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumValue(json, 'eye', elem.EyeElement, CODES_TFhirVisionEyeCodesEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumProps(json, 'eye', elem.EyeElement, CODES_TFhirVisionEyeCodesEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'sphere', elem.sphereElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'sphere', elem.sphereElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'cylinder', elem.cylinderElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'cylinder', elem.cylinderElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerValue(json, 'axis', elem.axisElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIntegerProps(json, 'axis', elem.axisElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'prism', elem.prismElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'prism', elem.prismElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumValue(json, 'base', elem.BaseElement, CODES_TFhirVisionBaseCodesEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnumProps(json, 'base', elem.BaseElement, CODES_TFhirVisionBaseCodesEnum, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'add', elem.addElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'add', elem.addElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'power', elem.powerElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'power', elem.powerElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'backCurve', elem.backCurveElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'backCurve', elem.backCurveElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalValue(json, 'diameter', elem.diameterElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimalProps(json, 'diameter', elem.diameterElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(json, 'duration', elem.duration); {a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'color', elem.colorElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'color', elem.colorElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'brand', elem.brandElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'brand', elem.brandElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringValue(json, 'notes', elem.notesElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeStringProps(json, 'notes', elem.notesElement, false);
  finishElement(json, name, elem, noObj);
end;

procedure TFHIRJsonParser.ParseVisionPrescription(jsn : TJsonObject; ctxt : TFHIRObjectList);
begin
  ctxt.add(ParseVisionPrescription(jsn)); {2}
end;

function TFHIRJsonParser.ParseVisionPrescription(jsn : TJsonObject) : TFhirVisionPrescription;
begin
  result := TFhirVisionPrescription.create;
  try
    ParseVisionPrescriptionProperties(jsn, result);
    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRJsonParser.ParseVisionPrescriptionProperties(jsn : TJsonObject; result : TFhirVisionPrescription);
begin
    ParseDomainResourceProperties(jsn, result);
    if jsn.has('identifier') then
      iterateArray(jsn.vArr['identifier'], result.identifierList, parseIdentifier);
    if jsn.has('dateWritten') or jsn.has('_dateWritten') then
        result.dateWrittenElement := ParseDateTime(jsn.node['dateWritten'], jsn.vObj['_dateWritten']);{q}
    if jsn.has('patient') then
        result.patient := ParseReference{TFhirPatient}(jsn.vObj['patient']);{q3}
    if jsn.has('prescriber') then
        result.prescriber := ParseReference{TFhirPractitioner}(jsn.vObj['prescriber']);{q3}
    if jsn.has('encounter') then
        result.encounter := ParseReference{TFhirEncounter}(jsn.vObj['encounter']);{q3}
    if jsn.has('reasonCodeableConcept') {a4} then
      result.reason := ParseCodeableConcept(jsn.vObj['reasonCodeableConcept']);
    if jsn.has('reasonReference') {a3} then
      result.reason := ParseReference(jsn.vObj['reasonReference']);
    if jsn.has('dispense') then
      iterateArray(jsn.vArr['dispense'], result.dispenseList, parseVisionPrescriptionDispense);
end;

procedure TFHIRJsonComposer.ComposeVisionPrescription(json : TJSONWriter; name : string; elem : TFhirVisionPrescription; noObj : boolean = false);
var
  i : integer;
begin
  if (elem = nil) then
    exit;
  ComposeDomainResourceProperties(json, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') and (elem.identifierList.Count > 0) then
  begin
    startArray(json, 'identifier', elem.identifierList, false);
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(json, '', elem.identifierList[i]); {z - Identifier}
    finishArray(json, elem.identifierList);
  end;
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dateWritten') then
    ComposeDateTimeValue(json, 'dateWritten', elem.dateWrittenElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dateWritten') then
    ComposeDateTimeProps(json, 'dateWritten', elem.dateWrittenElement, false);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(json, 'patient', elem.patient); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('prescriber') then
    ComposeReference{TFhirPractitioner}(json, 'prescriber', elem.prescriber); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(json, 'encounter', elem.encounter); {a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirCodeableConcept) then 
    ComposeCodeableConcept(json, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason)) 
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirReference) then
    ComposeReference(json, 'reasonReference', TFhirReference(elem.reason));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dispense') and (elem.dispenseList.Count > 0) then
  begin
    startArray(json, 'dispense', elem.dispenseList, false);
    for i := 0 to elem.dispenseList.Count - 1 do
      ComposeVisionPrescriptionDispense(json, '', elem.dispenseList[i]); {z - }
    finishArray(json, elem.dispenseList);
  end;
end;

{$ENDIF FHIR_VISIONPRESCRIPTION}
function TFHIRJsonParser.ParseResource(jsn : TJsonObject) : TFhirResource;
var
  s : String;
begin
  s := jsn['resourceType'];
 {$IFDEF FHIR_PARAMETERS}
  if s = 'Parameters' Then
    result := ParseParameters(jsn)
{$ENDIF FHIR_PARAMETERS}
{$IFDEF FHIR_ACCOUNT}
  {$IFDEF FHIR_ACCOUNT}
   else if s = 'Account' Then
    result := ParseAccount(jsn) 
  {$ENDIF}
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
  {$IFDEF FHIR_ALLERGYINTOLERANCE}
   else if s = 'AllergyIntolerance' Then
    result := ParseAllergyIntolerance(jsn) 
  {$ENDIF}
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
  {$IFDEF FHIR_APPOINTMENT}
   else if s = 'Appointment' Then
    result := ParseAppointment(jsn) 
  {$ENDIF}
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
  {$IFDEF FHIR_APPOINTMENTRESPONSE}
   else if s = 'AppointmentResponse' Then
    result := ParseAppointmentResponse(jsn) 
  {$ENDIF}
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
  {$IFDEF FHIR_AUDITEVENT}
   else if s = 'AuditEvent' Then
    result := ParseAuditEvent(jsn) 
  {$ENDIF}
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
  {$IFDEF FHIR_BASIC}
   else if s = 'Basic' Then
    result := ParseBasic(jsn) 
  {$ENDIF}
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
  {$IFDEF FHIR_BINARY}
   else if s = 'Binary' Then
    result := ParseBinary(jsn) 
  {$ENDIF}
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BODYSITE}
  {$IFDEF FHIR_BODYSITE}
   else if s = 'BodySite' Then
    result := ParseBodySite(jsn) 
  {$ENDIF}
{$ENDIF FHIR_BODYSITE}
{$IFDEF FHIR_BUNDLE}
  {$IFDEF FHIR_BUNDLE}
   else if s = 'Bundle' Then
    result := ParseBundle(jsn) 
  {$ENDIF}
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAREPLAN}
  {$IFDEF FHIR_CAREPLAN}
   else if s = 'CarePlan' Then
    result := ParseCarePlan(jsn) 
  {$ENDIF}
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CLAIM}
  {$IFDEF FHIR_CLAIM}
   else if s = 'Claim' Then
    result := ParseClaim(jsn) 
  {$ENDIF}
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
  {$IFDEF FHIR_CLAIMRESPONSE}
   else if s = 'ClaimResponse' Then
    result := ParseClaimResponse(jsn) 
  {$ENDIF}
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
  {$IFDEF FHIR_CLINICALIMPRESSION}
   else if s = 'ClinicalImpression' Then
    result := ParseClinicalImpression(jsn) 
  {$ENDIF}
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_COMMUNICATION}
  {$IFDEF FHIR_COMMUNICATION}
   else if s = 'Communication' Then
    result := ParseCommunication(jsn) 
  {$ENDIF}
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
  {$IFDEF FHIR_COMMUNICATIONREQUEST}
   else if s = 'CommunicationRequest' Then
    result := ParseCommunicationRequest(jsn) 
  {$ENDIF}
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPOSITION}
  {$IFDEF FHIR_COMPOSITION}
   else if s = 'Composition' Then
    result := ParseComposition(jsn) 
  {$ENDIF}
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
  {$IFDEF FHIR_CONCEPTMAP}
   else if s = 'ConceptMap' Then
    result := ParseConceptMap(jsn) 
  {$ENDIF}
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
  {$IFDEF FHIR_CONDITION}
   else if s = 'Condition' Then
    result := ParseCondition(jsn) 
  {$ENDIF}
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONFORMANCE}
  {$IFDEF FHIR_CONFORMANCE}
   else if s = 'Conformance' Then
    result := ParseConformance(jsn) 
  {$ENDIF}
{$ENDIF FHIR_CONFORMANCE}
{$IFDEF FHIR_CONTRACT}
  {$IFDEF FHIR_CONTRACT}
   else if s = 'Contract' Then
    result := ParseContract(jsn) 
  {$ENDIF}
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
  {$IFDEF FHIR_COVERAGE}
   else if s = 'Coverage' Then
    result := ParseCoverage(jsn) 
  {$ENDIF}
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_DATAELEMENT}
  {$IFDEF FHIR_DATAELEMENT}
   else if s = 'DataElement' Then
    result := ParseDataElement(jsn) 
  {$ENDIF}
{$ENDIF FHIR_DATAELEMENT}
{$IFDEF FHIR_DETECTEDISSUE}
  {$IFDEF FHIR_DETECTEDISSUE}
   else if s = 'DetectedIssue' Then
    result := ParseDetectedIssue(jsn) 
  {$ENDIF}
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
  {$IFDEF FHIR_DEVICE}
   else if s = 'Device' Then
    result := ParseDevice(jsn) 
  {$ENDIF}
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICECOMPONENT}
  {$IFDEF FHIR_DEVICECOMPONENT}
   else if s = 'DeviceComponent' Then
    result := ParseDeviceComponent(jsn) 
  {$ENDIF}
{$ENDIF FHIR_DEVICECOMPONENT}
{$IFDEF FHIR_DEVICEMETRIC}
  {$IFDEF FHIR_DEVICEMETRIC}
   else if s = 'DeviceMetric' Then
    result := ParseDeviceMetric(jsn) 
  {$ENDIF}
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEUSEREQUEST}
  {$IFDEF FHIR_DEVICEUSEREQUEST}
   else if s = 'DeviceUseRequest' Then
    result := ParseDeviceUseRequest(jsn) 
  {$ENDIF}
{$ENDIF FHIR_DEVICEUSEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
  {$IFDEF FHIR_DEVICEUSESTATEMENT}
   else if s = 'DeviceUseStatement' Then
    result := ParseDeviceUseStatement(jsn) 
  {$ENDIF}
{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICORDER}
  {$IFDEF FHIR_DIAGNOSTICORDER}
   else if s = 'DiagnosticOrder' Then
    result := ParseDiagnosticOrder(jsn) 
  {$ENDIF}
{$ENDIF FHIR_DIAGNOSTICORDER}
{$IFDEF FHIR_DIAGNOSTICREPORT}
  {$IFDEF FHIR_DIAGNOSTICREPORT}
   else if s = 'DiagnosticReport' Then
    result := ParseDiagnosticReport(jsn) 
  {$ENDIF}
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
  {$IFDEF FHIR_DOCUMENTMANIFEST}
   else if s = 'DocumentManifest' Then
    result := ParseDocumentManifest(jsn) 
  {$ENDIF}
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
  {$IFDEF FHIR_DOCUMENTREFERENCE}
   else if s = 'DocumentReference' Then
    result := ParseDocumentReference(jsn) 
  {$ENDIF}
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ELIGIBILITYREQUEST}
  {$IFDEF FHIR_ELIGIBILITYREQUEST}
   else if s = 'EligibilityRequest' Then
    result := ParseEligibilityRequest(jsn) 
  {$ENDIF}
{$ENDIF FHIR_ELIGIBILITYREQUEST}
{$IFDEF FHIR_ELIGIBILITYRESPONSE}
  {$IFDEF FHIR_ELIGIBILITYRESPONSE}
   else if s = 'EligibilityResponse' Then
    result := ParseEligibilityResponse(jsn) 
  {$ENDIF}
{$ENDIF FHIR_ELIGIBILITYRESPONSE}
{$IFDEF FHIR_ENCOUNTER}
  {$IFDEF FHIR_ENCOUNTER}
   else if s = 'Encounter' Then
    result := ParseEncounter(jsn) 
  {$ENDIF}
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENROLLMENTREQUEST}
  {$IFDEF FHIR_ENROLLMENTREQUEST}
   else if s = 'EnrollmentRequest' Then
    result := ParseEnrollmentRequest(jsn) 
  {$ENDIF}
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
  {$IFDEF FHIR_ENROLLMENTRESPONSE}
   else if s = 'EnrollmentResponse' Then
    result := ParseEnrollmentResponse(jsn) 
  {$ENDIF}
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
  {$IFDEF FHIR_EPISODEOFCARE}
   else if s = 'EpisodeOfCare' Then
    result := ParseEpisodeOfCare(jsn) 
  {$ENDIF}
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
  {$IFDEF FHIR_EXPLANATIONOFBENEFIT}
   else if s = 'ExplanationOfBenefit' Then
    result := ParseExplanationOfBenefit(jsn) 
  {$ENDIF}
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
  {$IFDEF FHIR_FAMILYMEMBERHISTORY}
   else if s = 'FamilyMemberHistory' Then
    result := ParseFamilyMemberHistory(jsn) 
  {$ENDIF}
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
  {$IFDEF FHIR_FLAG}
   else if s = 'Flag' Then
    result := ParseFlag(jsn) 
  {$ENDIF}
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
  {$IFDEF FHIR_GOAL}
   else if s = 'Goal' Then
    result := ParseGoal(jsn) 
  {$ENDIF}
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GROUP}
  {$IFDEF FHIR_GROUP}
   else if s = 'Group' Then
    result := ParseGroup(jsn) 
  {$ENDIF}
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_HEALTHCARESERVICE}
  {$IFDEF FHIR_HEALTHCARESERVICE}
   else if s = 'HealthcareService' Then
    result := ParseHealthcareService(jsn) 
  {$ENDIF}
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGOBJECTSELECTION}
  {$IFDEF FHIR_IMAGINGOBJECTSELECTION}
   else if s = 'ImagingObjectSelection' Then
    result := ParseImagingObjectSelection(jsn) 
  {$ENDIF}
{$ENDIF FHIR_IMAGINGOBJECTSELECTION}
{$IFDEF FHIR_IMAGINGSTUDY}
  {$IFDEF FHIR_IMAGINGSTUDY}
   else if s = 'ImagingStudy' Then
    result := ParseImagingStudy(jsn) 
  {$ENDIF}
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
  {$IFDEF FHIR_IMMUNIZATION}
   else if s = 'Immunization' Then
    result := ParseImmunization(jsn) 
  {$ENDIF}
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
  {$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
   else if s = 'ImmunizationRecommendation' Then
    result := ParseImmunizationRecommendation(jsn) 
  {$ENDIF}
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
  {$IFDEF FHIR_IMPLEMENTATIONGUIDE}
   else if s = 'ImplementationGuide' Then
    result := ParseImplementationGuide(jsn) 
  {$ENDIF}
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_LIST}
  {$IFDEF FHIR_LIST}
   else if s = 'List' Then
    result := ParseList(jsn) 
  {$ENDIF}
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
  {$IFDEF FHIR_LOCATION}
   else if s = 'Location' Then
    result := ParseLocation(jsn) 
  {$ENDIF}
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEDIA}
  {$IFDEF FHIR_MEDIA}
   else if s = 'Media' Then
    result := ParseMedia(jsn) 
  {$ENDIF}
{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
  {$IFDEF FHIR_MEDICATION}
   else if s = 'Medication' Then
    result := ParseMedication(jsn) 
  {$ENDIF}
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
  {$IFDEF FHIR_MEDICATIONADMINISTRATION}
   else if s = 'MedicationAdministration' Then
    result := ParseMedicationAdministration(jsn) 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
  {$IFDEF FHIR_MEDICATIONDISPENSE}
   else if s = 'MedicationDispense' Then
    result := ParseMedicationDispense(jsn) 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONORDER}
  {$IFDEF FHIR_MEDICATIONORDER}
   else if s = 'MedicationOrder' Then
    result := ParseMedicationOrder(jsn) 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONORDER}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
  {$IFDEF FHIR_MEDICATIONSTATEMENT}
   else if s = 'MedicationStatement' Then
    result := ParseMedicationStatement(jsn) 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MESSAGEHEADER}
  {$IFDEF FHIR_MESSAGEHEADER}
   else if s = 'MessageHeader' Then
    result := ParseMessageHeader(jsn) 
  {$ENDIF}
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_NAMINGSYSTEM}
  {$IFDEF FHIR_NAMINGSYSTEM}
   else if s = 'NamingSystem' Then
    result := ParseNamingSystem(jsn) 
  {$ENDIF}
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
  {$IFDEF FHIR_NUTRITIONORDER}
   else if s = 'NutritionOrder' Then
    result := ParseNutritionOrder(jsn) 
  {$ENDIF}
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
  {$IFDEF FHIR_OBSERVATION}
   else if s = 'Observation' Then
    result := ParseObservation(jsn) 
  {$ENDIF}
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OPERATIONDEFINITION}
  {$IFDEF FHIR_OPERATIONDEFINITION}
   else if s = 'OperationDefinition' Then
    result := ParseOperationDefinition(jsn) 
  {$ENDIF}
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
  {$IFDEF FHIR_OPERATIONOUTCOME}
   else if s = 'OperationOutcome' Then
    result := ParseOperationOutcome(jsn) 
  {$ENDIF}
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORDER}
  {$IFDEF FHIR_ORDER}
   else if s = 'Order' Then
    result := ParseOrder(jsn) 
  {$ENDIF}
{$ENDIF FHIR_ORDER}
{$IFDEF FHIR_ORDERRESPONSE}
  {$IFDEF FHIR_ORDERRESPONSE}
   else if s = 'OrderResponse' Then
    result := ParseOrderResponse(jsn) 
  {$ENDIF}
{$ENDIF FHIR_ORDERRESPONSE}
{$IFDEF FHIR_ORGANIZATION}
  {$IFDEF FHIR_ORGANIZATION}
   else if s = 'Organization' Then
    result := ParseOrganization(jsn) 
  {$ENDIF}
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_PATIENT}
  {$IFDEF FHIR_PATIENT}
   else if s = 'Patient' Then
    result := ParsePatient(jsn) 
  {$ENDIF}
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
  {$IFDEF FHIR_PAYMENTNOTICE}
   else if s = 'PaymentNotice' Then
    result := ParsePaymentNotice(jsn) 
  {$ENDIF}
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
  {$IFDEF FHIR_PAYMENTRECONCILIATION}
   else if s = 'PaymentReconciliation' Then
    result := ParsePaymentReconciliation(jsn) 
  {$ENDIF}
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
  {$IFDEF FHIR_PERSON}
   else if s = 'Person' Then
    result := ParsePerson(jsn) 
  {$ENDIF}
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PRACTITIONER}
  {$IFDEF FHIR_PRACTITIONER}
   else if s = 'Practitioner' Then
    result := ParsePractitioner(jsn) 
  {$ENDIF}
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PROCEDURE}
  {$IFDEF FHIR_PROCEDURE}
   else if s = 'Procedure' Then
    result := ParseProcedure(jsn) 
  {$ENDIF}
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROCEDUREREQUEST}
  {$IFDEF FHIR_PROCEDUREREQUEST}
   else if s = 'ProcedureRequest' Then
    result := ParseProcedureRequest(jsn) 
  {$ENDIF}
{$ENDIF FHIR_PROCEDUREREQUEST}
{$IFDEF FHIR_PROCESSREQUEST}
  {$IFDEF FHIR_PROCESSREQUEST}
   else if s = 'ProcessRequest' Then
    result := ParseProcessRequest(jsn) 
  {$ENDIF}
{$ENDIF FHIR_PROCESSREQUEST}
{$IFDEF FHIR_PROCESSRESPONSE}
  {$IFDEF FHIR_PROCESSRESPONSE}
   else if s = 'ProcessResponse' Then
    result := ParseProcessResponse(jsn) 
  {$ENDIF}
{$ENDIF FHIR_PROCESSRESPONSE}
{$IFDEF FHIR_PROVENANCE}
  {$IFDEF FHIR_PROVENANCE}
   else if s = 'Provenance' Then
    result := ParseProvenance(jsn) 
  {$ENDIF}
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
  {$IFDEF FHIR_QUESTIONNAIRE}
   else if s = 'Questionnaire' Then
    result := ParseQuestionnaire(jsn) 
  {$ENDIF}
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
  {$IFDEF FHIR_QUESTIONNAIRERESPONSE}
   else if s = 'QuestionnaireResponse' Then
    result := ParseQuestionnaireResponse(jsn) 
  {$ENDIF}
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REFERRALREQUEST}
  {$IFDEF FHIR_REFERRALREQUEST}
   else if s = 'ReferralRequest' Then
    result := ParseReferralRequest(jsn) 
  {$ENDIF}
{$ENDIF FHIR_REFERRALREQUEST}
{$IFDEF FHIR_RELATEDPERSON}
  {$IFDEF FHIR_RELATEDPERSON}
   else if s = 'RelatedPerson' Then
    result := ParseRelatedPerson(jsn) 
  {$ENDIF}
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_RISKASSESSMENT}
  {$IFDEF FHIR_RISKASSESSMENT}
   else if s = 'RiskAssessment' Then
    result := ParseRiskAssessment(jsn) 
  {$ENDIF}
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
  {$IFDEF FHIR_SCHEDULE}
   else if s = 'Schedule' Then
    result := ParseSchedule(jsn) 
  {$ENDIF}
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
  {$IFDEF FHIR_SEARCHPARAMETER}
   else if s = 'SearchParameter' Then
    result := ParseSearchParameter(jsn) 
  {$ENDIF}
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SLOT}
  {$IFDEF FHIR_SLOT}
   else if s = 'Slot' Then
    result := ParseSlot(jsn) 
  {$ENDIF}
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
  {$IFDEF FHIR_SPECIMEN}
   else if s = 'Specimen' Then
    result := ParseSpecimen(jsn) 
  {$ENDIF}
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_STRUCTUREDEFINITION}
  {$IFDEF FHIR_STRUCTUREDEFINITION}
   else if s = 'StructureDefinition' Then
    result := ParseStructureDefinition(jsn) 
  {$ENDIF}
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_SUBSCRIPTION}
  {$IFDEF FHIR_SUBSCRIPTION}
   else if s = 'Subscription' Then
    result := ParseSubscription(jsn) 
  {$ENDIF}
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
  {$IFDEF FHIR_SUBSTANCE}
   else if s = 'Substance' Then
    result := ParseSubstance(jsn) 
  {$ENDIF}
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUPPLYDELIVERY}
  {$IFDEF FHIR_SUPPLYDELIVERY}
   else if s = 'SupplyDelivery' Then
    result := ParseSupplyDelivery(jsn) 
  {$ENDIF}
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
  {$IFDEF FHIR_SUPPLYREQUEST}
   else if s = 'SupplyRequest' Then
    result := ParseSupplyRequest(jsn) 
  {$ENDIF}
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TESTSCRIPT}
  {$IFDEF FHIR_TESTSCRIPT}
   else if s = 'TestScript' Then
    result := ParseTestScript(jsn) 
  {$ENDIF}
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
  {$IFDEF FHIR_VALUESET}
   else if s = 'ValueSet' Then
    result := ParseValueSet(jsn) 
  {$ENDIF}
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VISIONPRESCRIPTION}
  {$IFDEF FHIR_VISIONPRESCRIPTION}
   else if s = 'VisionPrescription' Then
    result := ParseVisionPrescription(jsn) 
  {$ENDIF}
{$ENDIF FHIR_VISIONPRESCRIPTION}
  else
    raise EJsonException.Create('error: the element '+s+' is not a valid resource name');
end;

function TFHIRJsonParser.ParseFragment(jsn : TJsonObject; type_ : String) : TFHIRObject;
begin
   if (type_ = 'TFhirElement') then
    result := parseElement(jsn)
  else if (type_ = 'TFhirBackboneElement') then
    result := parseBackboneElement(jsn)
{$IFDEF FHIR_PARAMETERS}
  else if (type_ = 'TFhirParameters') then
    result := parseParameters(jsn)
{$ENDIF FHIR_PARAMETERS}
  else if (type_ = 'TFhirExtension') then
    result := parseExtension(jsn)
  else if (type_ = 'TFhirNarrative') then
    result := parseNarrative(jsn)
  else if (type_ = 'TFhirIdentifier') then
    result := parseIdentifier(jsn)
  else if (type_ = 'TFhirCoding') then
    result := parseCoding(jsn)
  else if (type_ = 'TFhirReference') then
    result := parseReference(jsn)
  else if (type_ = 'TFhirSignature') then
    result := parseSignature(jsn)
  else if (type_ = 'TFhirSampledData') then
    result := parseSampledData(jsn)
  else if (type_ = 'TFhirPeriod') then
    result := parsePeriod(jsn)
  else if (type_ = 'TFhirQuantity') then
    result := parseQuantity(jsn)
  else if (type_ = 'TFhirAttachment') then
    result := parseAttachment(jsn)
  else if (type_ = 'TFhirRatio') then
    result := parseRatio(jsn)
  else if (type_ = 'TFhirRange') then
    result := parseRange(jsn)
  else if (type_ = 'TFhirAnnotation') then
    result := parseAnnotation(jsn)
  else if (type_ = 'TFhirCodeableConcept') then
    result := parseCodeableConcept(jsn)
  else if (type_ = 'TFhirHumanName') then
    result := parseHumanName(jsn)
  else if (type_ = 'TFhirMeta') then
    result := parseMeta(jsn)
  else if (type_ = 'TFhirContactPoint') then
    result := parseContactPoint(jsn)
  else if (type_ = 'TFhirAddress') then
    result := parseAddress(jsn)
  else if (type_ = 'TFhirElementDefinition') then
    result := parseElementDefinition(jsn)
  else if (type_ = 'TFhirTiming') then
    result := parseTiming(jsn)
{$IFDEF FHIR_ACCOUNT}
  else if (type_ = 'TFhirAccount') then
    result := parseAccount(jsn)
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
  else if (type_ = 'TFhirAllergyIntolerance') then
    result := parseAllergyIntolerance(jsn)
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
  else if (type_ = 'TFhirAppointment') then
    result := parseAppointment(jsn)
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
  else if (type_ = 'TFhirAppointmentResponse') then
    result := parseAppointmentResponse(jsn)
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
  else if (type_ = 'TFhirAuditEvent') then
    result := parseAuditEvent(jsn)
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
  else if (type_ = 'TFhirBasic') then
    result := parseBasic(jsn)
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
  else if (type_ = 'TFhirBinary') then
    result := parseBinary(jsn)
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BODYSITE}
  else if (type_ = 'TFhirBodySite') then
    result := parseBodySite(jsn)
{$ENDIF FHIR_BODYSITE}
{$IFDEF FHIR_BUNDLE}
  else if (type_ = 'TFhirBundle') then
    result := parseBundle(jsn)
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAREPLAN}
  else if (type_ = 'TFhirCarePlan') then
    result := parseCarePlan(jsn)
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CLAIM}
  else if (type_ = 'TFhirClaim') then
    result := parseClaim(jsn)
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
  else if (type_ = 'TFhirClaimResponse') then
    result := parseClaimResponse(jsn)
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
  else if (type_ = 'TFhirClinicalImpression') then
    result := parseClinicalImpression(jsn)
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_COMMUNICATION}
  else if (type_ = 'TFhirCommunication') then
    result := parseCommunication(jsn)
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
  else if (type_ = 'TFhirCommunicationRequest') then
    result := parseCommunicationRequest(jsn)
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPOSITION}
  else if (type_ = 'TFhirComposition') then
    result := parseComposition(jsn)
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
  else if (type_ = 'TFhirConceptMap') then
    result := parseConceptMap(jsn)
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
  else if (type_ = 'TFhirCondition') then
    result := parseCondition(jsn)
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONFORMANCE}
  else if (type_ = 'TFhirConformance') then
    result := parseConformance(jsn)
{$ENDIF FHIR_CONFORMANCE}
{$IFDEF FHIR_CONTRACT}
  else if (type_ = 'TFhirContract') then
    result := parseContract(jsn)
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
  else if (type_ = 'TFhirCoverage') then
    result := parseCoverage(jsn)
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_DATAELEMENT}
  else if (type_ = 'TFhirDataElement') then
    result := parseDataElement(jsn)
{$ENDIF FHIR_DATAELEMENT}
{$IFDEF FHIR_DETECTEDISSUE}
  else if (type_ = 'TFhirDetectedIssue') then
    result := parseDetectedIssue(jsn)
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
  else if (type_ = 'TFhirDevice') then
    result := parseDevice(jsn)
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICECOMPONENT}
  else if (type_ = 'TFhirDeviceComponent') then
    result := parseDeviceComponent(jsn)
{$ENDIF FHIR_DEVICECOMPONENT}
{$IFDEF FHIR_DEVICEMETRIC}
  else if (type_ = 'TFhirDeviceMetric') then
    result := parseDeviceMetric(jsn)
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEUSEREQUEST}
  else if (type_ = 'TFhirDeviceUseRequest') then
    result := parseDeviceUseRequest(jsn)
{$ENDIF FHIR_DEVICEUSEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
  else if (type_ = 'TFhirDeviceUseStatement') then
    result := parseDeviceUseStatement(jsn)
{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICORDER}
  else if (type_ = 'TFhirDiagnosticOrder') then
    result := parseDiagnosticOrder(jsn)
{$ENDIF FHIR_DIAGNOSTICORDER}
{$IFDEF FHIR_DIAGNOSTICREPORT}
  else if (type_ = 'TFhirDiagnosticReport') then
    result := parseDiagnosticReport(jsn)
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
  else if (type_ = 'TFhirDocumentManifest') then
    result := parseDocumentManifest(jsn)
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
  else if (type_ = 'TFhirDocumentReference') then
    result := parseDocumentReference(jsn)
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ELIGIBILITYREQUEST}
  else if (type_ = 'TFhirEligibilityRequest') then
    result := parseEligibilityRequest(jsn)
{$ENDIF FHIR_ELIGIBILITYREQUEST}
{$IFDEF FHIR_ELIGIBILITYRESPONSE}
  else if (type_ = 'TFhirEligibilityResponse') then
    result := parseEligibilityResponse(jsn)
{$ENDIF FHIR_ELIGIBILITYRESPONSE}
{$IFDEF FHIR_ENCOUNTER}
  else if (type_ = 'TFhirEncounter') then
    result := parseEncounter(jsn)
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENROLLMENTREQUEST}
  else if (type_ = 'TFhirEnrollmentRequest') then
    result := parseEnrollmentRequest(jsn)
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
  else if (type_ = 'TFhirEnrollmentResponse') then
    result := parseEnrollmentResponse(jsn)
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
  else if (type_ = 'TFhirEpisodeOfCare') then
    result := parseEpisodeOfCare(jsn)
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
  else if (type_ = 'TFhirExplanationOfBenefit') then
    result := parseExplanationOfBenefit(jsn)
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
  else if (type_ = 'TFhirFamilyMemberHistory') then
    result := parseFamilyMemberHistory(jsn)
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
  else if (type_ = 'TFhirFlag') then
    result := parseFlag(jsn)
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
  else if (type_ = 'TFhirGoal') then
    result := parseGoal(jsn)
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GROUP}
  else if (type_ = 'TFhirGroup') then
    result := parseGroup(jsn)
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_HEALTHCARESERVICE}
  else if (type_ = 'TFhirHealthcareService') then
    result := parseHealthcareService(jsn)
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGOBJECTSELECTION}
  else if (type_ = 'TFhirImagingObjectSelection') then
    result := parseImagingObjectSelection(jsn)
{$ENDIF FHIR_IMAGINGOBJECTSELECTION}
{$IFDEF FHIR_IMAGINGSTUDY}
  else if (type_ = 'TFhirImagingStudy') then
    result := parseImagingStudy(jsn)
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
  else if (type_ = 'TFhirImmunization') then
    result := parseImmunization(jsn)
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
  else if (type_ = 'TFhirImmunizationRecommendation') then
    result := parseImmunizationRecommendation(jsn)
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
  else if (type_ = 'TFhirImplementationGuide') then
    result := parseImplementationGuide(jsn)
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_LIST}
  else if (type_ = 'TFhirList') then
    result := parseList(jsn)
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
  else if (type_ = 'TFhirLocation') then
    result := parseLocation(jsn)
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEDIA}
  else if (type_ = 'TFhirMedia') then
    result := parseMedia(jsn)
{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
  else if (type_ = 'TFhirMedication') then
    result := parseMedication(jsn)
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
  else if (type_ = 'TFhirMedicationAdministration') then
    result := parseMedicationAdministration(jsn)
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
  else if (type_ = 'TFhirMedicationDispense') then
    result := parseMedicationDispense(jsn)
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONORDER}
  else if (type_ = 'TFhirMedicationOrder') then
    result := parseMedicationOrder(jsn)
{$ENDIF FHIR_MEDICATIONORDER}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
  else if (type_ = 'TFhirMedicationStatement') then
    result := parseMedicationStatement(jsn)
{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MESSAGEHEADER}
  else if (type_ = 'TFhirMessageHeader') then
    result := parseMessageHeader(jsn)
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_NAMINGSYSTEM}
  else if (type_ = 'TFhirNamingSystem') then
    result := parseNamingSystem(jsn)
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
  else if (type_ = 'TFhirNutritionOrder') then
    result := parseNutritionOrder(jsn)
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
  else if (type_ = 'TFhirObservation') then
    result := parseObservation(jsn)
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OPERATIONDEFINITION}
  else if (type_ = 'TFhirOperationDefinition') then
    result := parseOperationDefinition(jsn)
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
  else if (type_ = 'TFhirOperationOutcome') then
    result := parseOperationOutcome(jsn)
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORDER}
  else if (type_ = 'TFhirOrder') then
    result := parseOrder(jsn)
{$ENDIF FHIR_ORDER}
{$IFDEF FHIR_ORDERRESPONSE}
  else if (type_ = 'TFhirOrderResponse') then
    result := parseOrderResponse(jsn)
{$ENDIF FHIR_ORDERRESPONSE}
{$IFDEF FHIR_ORGANIZATION}
  else if (type_ = 'TFhirOrganization') then
    result := parseOrganization(jsn)
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_PATIENT}
  else if (type_ = 'TFhirPatient') then
    result := parsePatient(jsn)
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
  else if (type_ = 'TFhirPaymentNotice') then
    result := parsePaymentNotice(jsn)
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
  else if (type_ = 'TFhirPaymentReconciliation') then
    result := parsePaymentReconciliation(jsn)
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
  else if (type_ = 'TFhirPerson') then
    result := parsePerson(jsn)
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PRACTITIONER}
  else if (type_ = 'TFhirPractitioner') then
    result := parsePractitioner(jsn)
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PROCEDURE}
  else if (type_ = 'TFhirProcedure') then
    result := parseProcedure(jsn)
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROCEDUREREQUEST}
  else if (type_ = 'TFhirProcedureRequest') then
    result := parseProcedureRequest(jsn)
{$ENDIF FHIR_PROCEDUREREQUEST}
{$IFDEF FHIR_PROCESSREQUEST}
  else if (type_ = 'TFhirProcessRequest') then
    result := parseProcessRequest(jsn)
{$ENDIF FHIR_PROCESSREQUEST}
{$IFDEF FHIR_PROCESSRESPONSE}
  else if (type_ = 'TFhirProcessResponse') then
    result := parseProcessResponse(jsn)
{$ENDIF FHIR_PROCESSRESPONSE}
{$IFDEF FHIR_PROVENANCE}
  else if (type_ = 'TFhirProvenance') then
    result := parseProvenance(jsn)
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
  else if (type_ = 'TFhirQuestionnaire') then
    result := parseQuestionnaire(jsn)
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
  else if (type_ = 'TFhirQuestionnaireResponse') then
    result := parseQuestionnaireResponse(jsn)
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REFERRALREQUEST}
  else if (type_ = 'TFhirReferralRequest') then
    result := parseReferralRequest(jsn)
{$ENDIF FHIR_REFERRALREQUEST}
{$IFDEF FHIR_RELATEDPERSON}
  else if (type_ = 'TFhirRelatedPerson') then
    result := parseRelatedPerson(jsn)
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_RISKASSESSMENT}
  else if (type_ = 'TFhirRiskAssessment') then
    result := parseRiskAssessment(jsn)
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
  else if (type_ = 'TFhirSchedule') then
    result := parseSchedule(jsn)
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
  else if (type_ = 'TFhirSearchParameter') then
    result := parseSearchParameter(jsn)
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SLOT}
  else if (type_ = 'TFhirSlot') then
    result := parseSlot(jsn)
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
  else if (type_ = 'TFhirSpecimen') then
    result := parseSpecimen(jsn)
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_STRUCTUREDEFINITION}
  else if (type_ = 'TFhirStructureDefinition') then
    result := parseStructureDefinition(jsn)
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_SUBSCRIPTION}
  else if (type_ = 'TFhirSubscription') then
    result := parseSubscription(jsn)
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
  else if (type_ = 'TFhirSubstance') then
    result := parseSubstance(jsn)
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUPPLYDELIVERY}
  else if (type_ = 'TFhirSupplyDelivery') then
    result := parseSupplyDelivery(jsn)
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
  else if (type_ = 'TFhirSupplyRequest') then
    result := parseSupplyRequest(jsn)
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TESTSCRIPT}
  else if (type_ = 'TFhirTestScript') then
    result := parseTestScript(jsn)
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
  else if (type_ = 'TFhirValueSet') then
    result := parseValueSet(jsn)
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VISIONPRESCRIPTION}
  else if (type_ = 'TFhirVisionPrescription') then
    result := parseVisionPrescription(jsn)
{$ENDIF FHIR_VISIONPRESCRIPTION}
  else
    raise EJsonException.Create('error: the element '+type_+' is not a valid fragment name');
end;

function TFHIRJsonParser.ParseDataType(jsn : TJsonObject; name : String; type_ : TFHIRTypeClass) : TFHIRType;
begin
   if (type_ = TFhirExtension) then
    result := parseExtension(jsn)
  else if (type_ = TFhirNarrative) then
    result := parseNarrative(jsn)
  else if (type_ = TFhirIdentifier) then
    result := parseIdentifier(jsn)
  else if (type_ = TFhirCoding) then
    result := parseCoding(jsn)
  else if (type_ = TFhirReference) then
    result := parseReference(jsn)
  else if (type_ = TFhirSignature) then
    result := parseSignature(jsn)
  else if (type_ = TFhirSampledData) then
    result := parseSampledData(jsn)
  else if (type_ = TFhirPeriod) then
    result := parsePeriod(jsn)
  else if (type_ = TFhirQuantity) then
    result := parseQuantity(jsn)
  else if (type_ = TFhirAttachment) then
    result := parseAttachment(jsn)
  else if (type_ = TFhirRatio) then
    result := parseRatio(jsn)
  else if (type_ = TFhirRange) then
    result := parseRange(jsn)
  else if (type_ = TFhirAnnotation) then
    result := parseAnnotation(jsn)
  else if (type_ = TFhirCodeableConcept) then
    result := parseCodeableConcept(jsn)
  else if (type_ = TFhirHumanName) then
    result := parseHumanName(jsn)
  else if (type_ = TFhirMeta) then
    result := parseMeta(jsn)
  else if (type_ = TFhirContactPoint) then
    result := parseContactPoint(jsn)
  else if (type_ = TFhirAddress) then
    result := parseAddress(jsn)
  else if (type_ = TFhirElementDefinition) then
    result := parseElementDefinition(jsn)
  else if (type_ = TFhirTiming) then
    result := parseTiming(jsn)
  else
    raise EJsonException.Create('Unknown Type');
end;

procedure TFHIRJsonComposer.ComposeBase(json: TJSONWriter; name: String; base: TFHIRObject);
begin
   if (base is TFhirDateTime) then
    composeDateTimeValue(json, name, TFhirDateTime(base), false)
  else if (base is TFhirDate) then
    composeDateValue(json, name, TFhirDate(base), false)
  else if (base is TFhirString) then
    composeStringValue(json, name, TFhirString(base), false)
  else if (base is TFhirInteger) then
    composeIntegerValue(json, name, TFhirInteger(base), false)
  else if (base is TFhirUri) then
    composeUriValue(json, name, TFhirUri(base), false)
  else if (base is TFhirInstant) then
    composeInstantValue(json, name, TFhirInstant(base), false)
  else if (base is TFhirBoolean) then
    composeBooleanValue(json, name, TFhirBoolean(base), false)
  else if (base is TFhirBase64Binary) then
    composeBase64BinaryValue(json, name, TFhirBase64Binary(base), false)
  else if (base is TFhirTime) then
    composeTimeValue(json, name, TFhirTime(base), false)
  else if (base is TFhirDecimal) then
    composeDecimalValue(json, name, TFhirDecimal(base), false)
  else if (base is TFhirCode) then
    composeCodeValue(json, name, TFhirCode(base), false)
  else if (base is TFhirOid) then
    composeOidValue(json, name, TFhirOid(base), false)
  else if (base is TFhirUuid) then
    composeUuidValue(json, name, TFhirUuid(base), false)
  else if (base is TFhirMarkdown) then
    composeMarkdownValue(json, name, TFhirMarkdown(base), false)
  else if (base is TFhirUnsignedInt) then
    composeUnsignedIntValue(json, name, TFhirUnsignedInt(base), false)
  else if (base is TFhirId) then
    composeIdValue(json, name, TFhirId(base), false)
  else if (base is TFhirPositiveInt) then
    composePositiveIntValue(json, name, TFhirPositiveInt(base), false)
{$IFDEF FHIR_PARAMETERS}
  else if (base is TFhirParametersParameter) then
    composeParametersParameter(json, name, TFhirParametersParameter(base), false)
  else if (base is TFhirParameters) then
    composeParameters(json, name, TFhirParameters(base), false)
{$ENDIF FHIR_PARAMETERS}
  else if (base is TFhirExtension) then
    composeExtension(json, name, TFhirExtension(base), false)
  else if (base is TFhirNarrative) then
    composeNarrative(json, name, TFhirNarrative(base), false)
  else if (base is TFhirIdentifier) then
    composeIdentifier(json, name, TFhirIdentifier(base), false)
  else if (base is TFhirCoding) then
    composeCoding(json, name, TFhirCoding(base), false)
  else if (base is TFhirReference) then
    composeReference(json, name, TFhirReference(base), false)
  else if (base is TFhirSignature) then
    composeSignature(json, name, TFhirSignature(base), false)
  else if (base is TFhirSampledData) then
    composeSampledData(json, name, TFhirSampledData(base), false)
  else if (base is TFhirPeriod) then
    composePeriod(json, name, TFhirPeriod(base), false)
  else if (base is TFhirQuantity) then
    composeQuantity(json, name, TFhirQuantity(base), false)
  else if (base is TFhirAttachment) then
    composeAttachment(json, name, TFhirAttachment(base), false)
  else if (base is TFhirRatio) then
    composeRatio(json, name, TFhirRatio(base), false)
  else if (base is TFhirRange) then
    composeRange(json, name, TFhirRange(base), false)
  else if (base is TFhirAnnotation) then
    composeAnnotation(json, name, TFhirAnnotation(base), false)
  else if (base is TFhirCodeableConcept) then
    composeCodeableConcept(json, name, TFhirCodeableConcept(base), false)
  else if (base is TFhirHumanName) then
    composeHumanName(json, name, TFhirHumanName(base), false)
  else if (base is TFhirMeta) then
    composeMeta(json, name, TFhirMeta(base), false)
  else if (base is TFhirContactPoint) then
    composeContactPoint(json, name, TFhirContactPoint(base), false)
  else if (base is TFhirAddress) then
    composeAddress(json, name, TFhirAddress(base), false)
  else if (base is TFhirElementDefinitionSlicing) then
    composeElementDefinitionSlicing(json, name, TFhirElementDefinitionSlicing(base), false)
  else if (base is TFhirElementDefinitionBase) then
    composeElementDefinitionBase(json, name, TFhirElementDefinitionBase(base), false)
  else if (base is TFhirElementDefinitionType) then
    composeElementDefinitionType(json, name, TFhirElementDefinitionType(base), false)
  else if (base is TFhirElementDefinitionConstraint) then
    composeElementDefinitionConstraint(json, name, TFhirElementDefinitionConstraint(base), false)
  else if (base is TFhirElementDefinitionBinding) then
    composeElementDefinitionBinding(json, name, TFhirElementDefinitionBinding(base), false)
  else if (base is TFhirElementDefinitionMapping) then
    composeElementDefinitionMapping(json, name, TFhirElementDefinitionMapping(base), false)
  else if (base is TFhirElementDefinition) then
    composeElementDefinition(json, name, TFhirElementDefinition(base), false)
  else if (base is TFhirTimingRepeat) then
    composeTimingRepeat(json, name, TFhirTimingRepeat(base), false)
  else if (base is TFhirTiming) then
    composeTiming(json, name, TFhirTiming(base), false)
{$IFDEF FHIR_ACCOUNT}
  else if (base is TFhirAccount) then
    composeAccount(json, name, TFhirAccount(base), false)
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
  else if (base is TFhirAllergyIntoleranceReaction) then
    composeAllergyIntoleranceReaction(json, name, TFhirAllergyIntoleranceReaction(base), false)
  else if (base is TFhirAllergyIntolerance) then
    composeAllergyIntolerance(json, name, TFhirAllergyIntolerance(base), false)
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
  else if (base is TFhirAppointmentParticipant) then
    composeAppointmentParticipant(json, name, TFhirAppointmentParticipant(base), false)
  else if (base is TFhirAppointment) then
    composeAppointment(json, name, TFhirAppointment(base), false)
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
  else if (base is TFhirAppointmentResponse) then
    composeAppointmentResponse(json, name, TFhirAppointmentResponse(base), false)
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
  else if (base is TFhirAuditEventEvent) then
    composeAuditEventEvent(json, name, TFhirAuditEventEvent(base), false)
  else if (base is TFhirAuditEventParticipant) then
    composeAuditEventParticipant(json, name, TFhirAuditEventParticipant(base), false)
  else if (base is TFhirAuditEventParticipantNetwork) then
    composeAuditEventParticipantNetwork(json, name, TFhirAuditEventParticipantNetwork(base), false)
  else if (base is TFhirAuditEventSource) then
    composeAuditEventSource(json, name, TFhirAuditEventSource(base), false)
  else if (base is TFhirAuditEventObject) then
    composeAuditEventObject(json, name, TFhirAuditEventObject(base), false)
  else if (base is TFhirAuditEventObjectDetail) then
    composeAuditEventObjectDetail(json, name, TFhirAuditEventObjectDetail(base), false)
  else if (base is TFhirAuditEvent) then
    composeAuditEvent(json, name, TFhirAuditEvent(base), false)
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
  else if (base is TFhirBasic) then
    composeBasic(json, name, TFhirBasic(base), false)
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
  else if (base is TFhirBinary) then
    composeBinary(json, name, TFhirBinary(base), false)
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BODYSITE}
  else if (base is TFhirBodySite) then
    composeBodySite(json, name, TFhirBodySite(base), false)
{$ENDIF FHIR_BODYSITE}
{$IFDEF FHIR_BUNDLE}
  else if (base is TFhirBundleLink) then
    composeBundleLink(json, name, TFhirBundleLink(base), false)
  else if (base is TFhirBundleEntry) then
    composeBundleEntry(json, name, TFhirBundleEntry(base), false)
  else if (base is TFhirBundleEntrySearch) then
    composeBundleEntrySearch(json, name, TFhirBundleEntrySearch(base), false)
  else if (base is TFhirBundleEntryRequest) then
    composeBundleEntryRequest(json, name, TFhirBundleEntryRequest(base), false)
  else if (base is TFhirBundleEntryResponse) then
    composeBundleEntryResponse(json, name, TFhirBundleEntryResponse(base), false)
  else if (base is TFhirBundle) then
    composeBundle(json, name, TFhirBundle(base), false)
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAREPLAN}
  else if (base is TFhirCarePlanRelatedPlan) then
    composeCarePlanRelatedPlan(json, name, TFhirCarePlanRelatedPlan(base), false)
  else if (base is TFhirCarePlanParticipant) then
    composeCarePlanParticipant(json, name, TFhirCarePlanParticipant(base), false)
  else if (base is TFhirCarePlanActivity) then
    composeCarePlanActivity(json, name, TFhirCarePlanActivity(base), false)
  else if (base is TFhirCarePlanActivityDetail) then
    composeCarePlanActivityDetail(json, name, TFhirCarePlanActivityDetail(base), false)
  else if (base is TFhirCarePlan) then
    composeCarePlan(json, name, TFhirCarePlan(base), false)
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CLAIM}
  else if (base is TFhirClaimPayee) then
    composeClaimPayee(json, name, TFhirClaimPayee(base), false)
  else if (base is TFhirClaimDiagnosis) then
    composeClaimDiagnosis(json, name, TFhirClaimDiagnosis(base), false)
  else if (base is TFhirClaimCoverage) then
    composeClaimCoverage(json, name, TFhirClaimCoverage(base), false)
  else if (base is TFhirClaimItem) then
    composeClaimItem(json, name, TFhirClaimItem(base), false)
  else if (base is TFhirClaimItemDetail) then
    composeClaimItemDetail(json, name, TFhirClaimItemDetail(base), false)
  else if (base is TFhirClaimItemDetailSubDetail) then
    composeClaimItemDetailSubDetail(json, name, TFhirClaimItemDetailSubDetail(base), false)
  else if (base is TFhirClaimItemProsthesis) then
    composeClaimItemProsthesis(json, name, TFhirClaimItemProsthesis(base), false)
  else if (base is TFhirClaimMissingTeeth) then
    composeClaimMissingTeeth(json, name, TFhirClaimMissingTeeth(base), false)
  else if (base is TFhirClaim) then
    composeClaim(json, name, TFhirClaim(base), false)
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
  else if (base is TFhirClaimResponseItem) then
    composeClaimResponseItem(json, name, TFhirClaimResponseItem(base), false)
  else if (base is TFhirClaimResponseItemAdjudication) then
    composeClaimResponseItemAdjudication(json, name, TFhirClaimResponseItemAdjudication(base), false)
  else if (base is TFhirClaimResponseItemDetail) then
    composeClaimResponseItemDetail(json, name, TFhirClaimResponseItemDetail(base), false)
  else if (base is TFhirClaimResponseItemDetailAdjudication) then
    composeClaimResponseItemDetailAdjudication(json, name, TFhirClaimResponseItemDetailAdjudication(base), false)
  else if (base is TFhirClaimResponseItemDetailSubDetail) then
    composeClaimResponseItemDetailSubDetail(json, name, TFhirClaimResponseItemDetailSubDetail(base), false)
  else if (base is TFhirClaimResponseItemDetailSubDetailAdjudication) then
    composeClaimResponseItemDetailSubDetailAdjudication(json, name, TFhirClaimResponseItemDetailSubDetailAdjudication(base), false)
  else if (base is TFhirClaimResponseAddItem) then
    composeClaimResponseAddItem(json, name, TFhirClaimResponseAddItem(base), false)
  else if (base is TFhirClaimResponseAddItemAdjudication) then
    composeClaimResponseAddItemAdjudication(json, name, TFhirClaimResponseAddItemAdjudication(base), false)
  else if (base is TFhirClaimResponseAddItemDetail) then
    composeClaimResponseAddItemDetail(json, name, TFhirClaimResponseAddItemDetail(base), false)
  else if (base is TFhirClaimResponseAddItemDetailAdjudication) then
    composeClaimResponseAddItemDetailAdjudication(json, name, TFhirClaimResponseAddItemDetailAdjudication(base), false)
  else if (base is TFhirClaimResponseError) then
    composeClaimResponseError(json, name, TFhirClaimResponseError(base), false)
  else if (base is TFhirClaimResponseNote) then
    composeClaimResponseNote(json, name, TFhirClaimResponseNote(base), false)
  else if (base is TFhirClaimResponseCoverage) then
    composeClaimResponseCoverage(json, name, TFhirClaimResponseCoverage(base), false)
  else if (base is TFhirClaimResponse) then
    composeClaimResponse(json, name, TFhirClaimResponse(base), false)
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
  else if (base is TFhirClinicalImpressionInvestigations) then
    composeClinicalImpressionInvestigations(json, name, TFhirClinicalImpressionInvestigations(base), false)
  else if (base is TFhirClinicalImpressionFinding) then
    composeClinicalImpressionFinding(json, name, TFhirClinicalImpressionFinding(base), false)
  else if (base is TFhirClinicalImpressionRuledOut) then
    composeClinicalImpressionRuledOut(json, name, TFhirClinicalImpressionRuledOut(base), false)
  else if (base is TFhirClinicalImpression) then
    composeClinicalImpression(json, name, TFhirClinicalImpression(base), false)
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_COMMUNICATION}
  else if (base is TFhirCommunicationPayload) then
    composeCommunicationPayload(json, name, TFhirCommunicationPayload(base), false)
  else if (base is TFhirCommunication) then
    composeCommunication(json, name, TFhirCommunication(base), false)
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
  else if (base is TFhirCommunicationRequestPayload) then
    composeCommunicationRequestPayload(json, name, TFhirCommunicationRequestPayload(base), false)
  else if (base is TFhirCommunicationRequest) then
    composeCommunicationRequest(json, name, TFhirCommunicationRequest(base), false)
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPOSITION}
  else if (base is TFhirCompositionAttester) then
    composeCompositionAttester(json, name, TFhirCompositionAttester(base), false)
  else if (base is TFhirCompositionEvent) then
    composeCompositionEvent(json, name, TFhirCompositionEvent(base), false)
  else if (base is TFhirCompositionSection) then
    composeCompositionSection(json, name, TFhirCompositionSection(base), false)
  else if (base is TFhirComposition) then
    composeComposition(json, name, TFhirComposition(base), false)
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
  else if (base is TFhirConceptMapContact) then
    composeConceptMapContact(json, name, TFhirConceptMapContact(base), false)
  else if (base is TFhirConceptMapElement) then
    composeConceptMapElement(json, name, TFhirConceptMapElement(base), false)
  else if (base is TFhirConceptMapElementTarget) then
    composeConceptMapElementTarget(json, name, TFhirConceptMapElementTarget(base), false)
  else if (base is TFhirConceptMapElementTargetDependsOn) then
    composeConceptMapElementTargetDependsOn(json, name, TFhirConceptMapElementTargetDependsOn(base), false)
  else if (base is TFhirConceptMap) then
    composeConceptMap(json, name, TFhirConceptMap(base), false)
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
  else if (base is TFhirConditionStage) then
    composeConditionStage(json, name, TFhirConditionStage(base), false)
  else if (base is TFhirConditionEvidence) then
    composeConditionEvidence(json, name, TFhirConditionEvidence(base), false)
  else if (base is TFhirCondition) then
    composeCondition(json, name, TFhirCondition(base), false)
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONFORMANCE}
  else if (base is TFhirConformanceContact) then
    composeConformanceContact(json, name, TFhirConformanceContact(base), false)
  else if (base is TFhirConformanceSoftware) then
    composeConformanceSoftware(json, name, TFhirConformanceSoftware(base), false)
  else if (base is TFhirConformanceImplementation) then
    composeConformanceImplementation(json, name, TFhirConformanceImplementation(base), false)
  else if (base is TFhirConformanceRest) then
    composeConformanceRest(json, name, TFhirConformanceRest(base), false)
  else if (base is TFhirConformanceRestSecurity) then
    composeConformanceRestSecurity(json, name, TFhirConformanceRestSecurity(base), false)
  else if (base is TFhirConformanceRestSecurityCertificate) then
    composeConformanceRestSecurityCertificate(json, name, TFhirConformanceRestSecurityCertificate(base), false)
  else if (base is TFhirConformanceRestResource) then
    composeConformanceRestResource(json, name, TFhirConformanceRestResource(base), false)
  else if (base is TFhirConformanceRestResourceInteraction) then
    composeConformanceRestResourceInteraction(json, name, TFhirConformanceRestResourceInteraction(base), false)
  else if (base is TFhirConformanceRestResourceSearchParam) then
    composeConformanceRestResourceSearchParam(json, name, TFhirConformanceRestResourceSearchParam(base), false)
  else if (base is TFhirConformanceRestInteraction) then
    composeConformanceRestInteraction(json, name, TFhirConformanceRestInteraction(base), false)
  else if (base is TFhirConformanceRestOperation) then
    composeConformanceRestOperation(json, name, TFhirConformanceRestOperation(base), false)
  else if (base is TFhirConformanceMessaging) then
    composeConformanceMessaging(json, name, TFhirConformanceMessaging(base), false)
  else if (base is TFhirConformanceMessagingEndpoint) then
    composeConformanceMessagingEndpoint(json, name, TFhirConformanceMessagingEndpoint(base), false)
  else if (base is TFhirConformanceMessagingEvent) then
    composeConformanceMessagingEvent(json, name, TFhirConformanceMessagingEvent(base), false)
  else if (base is TFhirConformanceDocument) then
    composeConformanceDocument(json, name, TFhirConformanceDocument(base), false)
  else if (base is TFhirConformance) then
    composeConformance(json, name, TFhirConformance(base), false)
{$ENDIF FHIR_CONFORMANCE}
{$IFDEF FHIR_CONTRACT}
  else if (base is TFhirContractActor) then
    composeContractActor(json, name, TFhirContractActor(base), false)
  else if (base is TFhirContractValuedItem) then
    composeContractValuedItem(json, name, TFhirContractValuedItem(base), false)
  else if (base is TFhirContractSigner) then
    composeContractSigner(json, name, TFhirContractSigner(base), false)
  else if (base is TFhirContractTerm) then
    composeContractTerm(json, name, TFhirContractTerm(base), false)
  else if (base is TFhirContractTermActor) then
    composeContractTermActor(json, name, TFhirContractTermActor(base), false)
  else if (base is TFhirContractTermValuedItem) then
    composeContractTermValuedItem(json, name, TFhirContractTermValuedItem(base), false)
  else if (base is TFhirContractFriendly) then
    composeContractFriendly(json, name, TFhirContractFriendly(base), false)
  else if (base is TFhirContractLegal) then
    composeContractLegal(json, name, TFhirContractLegal(base), false)
  else if (base is TFhirContractRule) then
    composeContractRule(json, name, TFhirContractRule(base), false)
  else if (base is TFhirContract) then
    composeContract(json, name, TFhirContract(base), false)
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
  else if (base is TFhirCoverage) then
    composeCoverage(json, name, TFhirCoverage(base), false)
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_DATAELEMENT}
  else if (base is TFhirDataElementContact) then
    composeDataElementContact(json, name, TFhirDataElementContact(base), false)
  else if (base is TFhirDataElementMapping) then
    composeDataElementMapping(json, name, TFhirDataElementMapping(base), false)
  else if (base is TFhirDataElement) then
    composeDataElement(json, name, TFhirDataElement(base), false)
{$ENDIF FHIR_DATAELEMENT}
{$IFDEF FHIR_DETECTEDISSUE}
  else if (base is TFhirDetectedIssueMitigation) then
    composeDetectedIssueMitigation(json, name, TFhirDetectedIssueMitigation(base), false)
  else if (base is TFhirDetectedIssue) then
    composeDetectedIssue(json, name, TFhirDetectedIssue(base), false)
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
  else if (base is TFhirDevice) then
    composeDevice(json, name, TFhirDevice(base), false)
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICECOMPONENT}
  else if (base is TFhirDeviceComponentProductionSpecification) then
    composeDeviceComponentProductionSpecification(json, name, TFhirDeviceComponentProductionSpecification(base), false)
  else if (base is TFhirDeviceComponent) then
    composeDeviceComponent(json, name, TFhirDeviceComponent(base), false)
{$ENDIF FHIR_DEVICECOMPONENT}
{$IFDEF FHIR_DEVICEMETRIC}
  else if (base is TFhirDeviceMetricCalibration) then
    composeDeviceMetricCalibration(json, name, TFhirDeviceMetricCalibration(base), false)
  else if (base is TFhirDeviceMetric) then
    composeDeviceMetric(json, name, TFhirDeviceMetric(base), false)
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEUSEREQUEST}
  else if (base is TFhirDeviceUseRequest) then
    composeDeviceUseRequest(json, name, TFhirDeviceUseRequest(base), false)
{$ENDIF FHIR_DEVICEUSEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
  else if (base is TFhirDeviceUseStatement) then
    composeDeviceUseStatement(json, name, TFhirDeviceUseStatement(base), false)
{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICORDER}
  else if (base is TFhirDiagnosticOrderEvent) then
    composeDiagnosticOrderEvent(json, name, TFhirDiagnosticOrderEvent(base), false)
  else if (base is TFhirDiagnosticOrderItem) then
    composeDiagnosticOrderItem(json, name, TFhirDiagnosticOrderItem(base), false)
  else if (base is TFhirDiagnosticOrder) then
    composeDiagnosticOrder(json, name, TFhirDiagnosticOrder(base), false)
{$ENDIF FHIR_DIAGNOSTICORDER}
{$IFDEF FHIR_DIAGNOSTICREPORT}
  else if (base is TFhirDiagnosticReportImage) then
    composeDiagnosticReportImage(json, name, TFhirDiagnosticReportImage(base), false)
  else if (base is TFhirDiagnosticReport) then
    composeDiagnosticReport(json, name, TFhirDiagnosticReport(base), false)
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
  else if (base is TFhirDocumentManifestContent) then
    composeDocumentManifestContent(json, name, TFhirDocumentManifestContent(base), false)
  else if (base is TFhirDocumentManifestRelated) then
    composeDocumentManifestRelated(json, name, TFhirDocumentManifestRelated(base), false)
  else if (base is TFhirDocumentManifest) then
    composeDocumentManifest(json, name, TFhirDocumentManifest(base), false)
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
  else if (base is TFhirDocumentReferenceRelatesTo) then
    composeDocumentReferenceRelatesTo(json, name, TFhirDocumentReferenceRelatesTo(base), false)
  else if (base is TFhirDocumentReferenceContent) then
    composeDocumentReferenceContent(json, name, TFhirDocumentReferenceContent(base), false)
  else if (base is TFhirDocumentReferenceContext) then
    composeDocumentReferenceContext(json, name, TFhirDocumentReferenceContext(base), false)
  else if (base is TFhirDocumentReferenceContextRelated) then
    composeDocumentReferenceContextRelated(json, name, TFhirDocumentReferenceContextRelated(base), false)
  else if (base is TFhirDocumentReference) then
    composeDocumentReference(json, name, TFhirDocumentReference(base), false)
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ELIGIBILITYREQUEST}
  else if (base is TFhirEligibilityRequest) then
    composeEligibilityRequest(json, name, TFhirEligibilityRequest(base), false)
{$ENDIF FHIR_ELIGIBILITYREQUEST}
{$IFDEF FHIR_ELIGIBILITYRESPONSE}
  else if (base is TFhirEligibilityResponse) then
    composeEligibilityResponse(json, name, TFhirEligibilityResponse(base), false)
{$ENDIF FHIR_ELIGIBILITYRESPONSE}
{$IFDEF FHIR_ENCOUNTER}
  else if (base is TFhirEncounterStatusHistory) then
    composeEncounterStatusHistory(json, name, TFhirEncounterStatusHistory(base), false)
  else if (base is TFhirEncounterParticipant) then
    composeEncounterParticipant(json, name, TFhirEncounterParticipant(base), false)
  else if (base is TFhirEncounterHospitalization) then
    composeEncounterHospitalization(json, name, TFhirEncounterHospitalization(base), false)
  else if (base is TFhirEncounterLocation) then
    composeEncounterLocation(json, name, TFhirEncounterLocation(base), false)
  else if (base is TFhirEncounter) then
    composeEncounter(json, name, TFhirEncounter(base), false)
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENROLLMENTREQUEST}
  else if (base is TFhirEnrollmentRequest) then
    composeEnrollmentRequest(json, name, TFhirEnrollmentRequest(base), false)
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
  else if (base is TFhirEnrollmentResponse) then
    composeEnrollmentResponse(json, name, TFhirEnrollmentResponse(base), false)
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
  else if (base is TFhirEpisodeOfCareStatusHistory) then
    composeEpisodeOfCareStatusHistory(json, name, TFhirEpisodeOfCareStatusHistory(base), false)
  else if (base is TFhirEpisodeOfCareCareTeam) then
    composeEpisodeOfCareCareTeam(json, name, TFhirEpisodeOfCareCareTeam(base), false)
  else if (base is TFhirEpisodeOfCare) then
    composeEpisodeOfCare(json, name, TFhirEpisodeOfCare(base), false)
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
  else if (base is TFhirExplanationOfBenefit) then
    composeExplanationOfBenefit(json, name, TFhirExplanationOfBenefit(base), false)
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
  else if (base is TFhirFamilyMemberHistoryCondition) then
    composeFamilyMemberHistoryCondition(json, name, TFhirFamilyMemberHistoryCondition(base), false)
  else if (base is TFhirFamilyMemberHistory) then
    composeFamilyMemberHistory(json, name, TFhirFamilyMemberHistory(base), false)
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
  else if (base is TFhirFlag) then
    composeFlag(json, name, TFhirFlag(base), false)
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
  else if (base is TFhirGoalOutcome) then
    composeGoalOutcome(json, name, TFhirGoalOutcome(base), false)
  else if (base is TFhirGoal) then
    composeGoal(json, name, TFhirGoal(base), false)
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GROUP}
  else if (base is TFhirGroupCharacteristic) then
    composeGroupCharacteristic(json, name, TFhirGroupCharacteristic(base), false)
  else if (base is TFhirGroupMember) then
    composeGroupMember(json, name, TFhirGroupMember(base), false)
  else if (base is TFhirGroup) then
    composeGroup(json, name, TFhirGroup(base), false)
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_HEALTHCARESERVICE}
  else if (base is TFhirHealthcareServiceServiceType) then
    composeHealthcareServiceServiceType(json, name, TFhirHealthcareServiceServiceType(base), false)
  else if (base is TFhirHealthcareServiceAvailableTime) then
    composeHealthcareServiceAvailableTime(json, name, TFhirHealthcareServiceAvailableTime(base), false)
  else if (base is TFhirHealthcareServiceNotAvailable) then
    composeHealthcareServiceNotAvailable(json, name, TFhirHealthcareServiceNotAvailable(base), false)
  else if (base is TFhirHealthcareService) then
    composeHealthcareService(json, name, TFhirHealthcareService(base), false)
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGOBJECTSELECTION}
  else if (base is TFhirImagingObjectSelectionStudy) then
    composeImagingObjectSelectionStudy(json, name, TFhirImagingObjectSelectionStudy(base), false)
  else if (base is TFhirImagingObjectSelectionStudySeries) then
    composeImagingObjectSelectionStudySeries(json, name, TFhirImagingObjectSelectionStudySeries(base), false)
  else if (base is TFhirImagingObjectSelectionStudySeriesInstance) then
    composeImagingObjectSelectionStudySeriesInstance(json, name, TFhirImagingObjectSelectionStudySeriesInstance(base), false)
  else if (base is TFhirImagingObjectSelectionStudySeriesInstanceFrames) then
    composeImagingObjectSelectionStudySeriesInstanceFrames(json, name, TFhirImagingObjectSelectionStudySeriesInstanceFrames(base), false)
  else if (base is TFhirImagingObjectSelection) then
    composeImagingObjectSelection(json, name, TFhirImagingObjectSelection(base), false)
{$ENDIF FHIR_IMAGINGOBJECTSELECTION}
{$IFDEF FHIR_IMAGINGSTUDY}
  else if (base is TFhirImagingStudySeries) then
    composeImagingStudySeries(json, name, TFhirImagingStudySeries(base), false)
  else if (base is TFhirImagingStudySeriesInstance) then
    composeImagingStudySeriesInstance(json, name, TFhirImagingStudySeriesInstance(base), false)
  else if (base is TFhirImagingStudy) then
    composeImagingStudy(json, name, TFhirImagingStudy(base), false)
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
  else if (base is TFhirImmunizationExplanation) then
    composeImmunizationExplanation(json, name, TFhirImmunizationExplanation(base), false)
  else if (base is TFhirImmunizationReaction) then
    composeImmunizationReaction(json, name, TFhirImmunizationReaction(base), false)
  else if (base is TFhirImmunizationVaccinationProtocol) then
    composeImmunizationVaccinationProtocol(json, name, TFhirImmunizationVaccinationProtocol(base), false)
  else if (base is TFhirImmunization) then
    composeImmunization(json, name, TFhirImmunization(base), false)
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
  else if (base is TFhirImmunizationRecommendationRecommendation) then
    composeImmunizationRecommendationRecommendation(json, name, TFhirImmunizationRecommendationRecommendation(base), false)
  else if (base is TFhirImmunizationRecommendationRecommendationDateCriterion) then
    composeImmunizationRecommendationRecommendationDateCriterion(json, name, TFhirImmunizationRecommendationRecommendationDateCriterion(base), false)
  else if (base is TFhirImmunizationRecommendationRecommendationProtocol) then
    composeImmunizationRecommendationRecommendationProtocol(json, name, TFhirImmunizationRecommendationRecommendationProtocol(base), false)
  else if (base is TFhirImmunizationRecommendation) then
    composeImmunizationRecommendation(json, name, TFhirImmunizationRecommendation(base), false)
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
  else if (base is TFhirImplementationGuideContact) then
    composeImplementationGuideContact(json, name, TFhirImplementationGuideContact(base), false)
  else if (base is TFhirImplementationGuideDependency) then
    composeImplementationGuideDependency(json, name, TFhirImplementationGuideDependency(base), false)
  else if (base is TFhirImplementationGuidePackage) then
    composeImplementationGuidePackage(json, name, TFhirImplementationGuidePackage(base), false)
  else if (base is TFhirImplementationGuidePackageResource) then
    composeImplementationGuidePackageResource(json, name, TFhirImplementationGuidePackageResource(base), false)
  else if (base is TFhirImplementationGuideGlobal) then
    composeImplementationGuideGlobal(json, name, TFhirImplementationGuideGlobal(base), false)
  else if (base is TFhirImplementationGuidePage) then
    composeImplementationGuidePage(json, name, TFhirImplementationGuidePage(base), false)
  else if (base is TFhirImplementationGuide) then
    composeImplementationGuide(json, name, TFhirImplementationGuide(base), false)
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_LIST}
  else if (base is TFhirListEntry) then
    composeListEntry(json, name, TFhirListEntry(base), false)
  else if (base is TFhirList) then
    composeList(json, name, TFhirList(base), false)
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
  else if (base is TFhirLocationPosition) then
    composeLocationPosition(json, name, TFhirLocationPosition(base), false)
  else if (base is TFhirLocation) then
    composeLocation(json, name, TFhirLocation(base), false)
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEDIA}
  else if (base is TFhirMedia) then
    composeMedia(json, name, TFhirMedia(base), false)
{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
  else if (base is TFhirMedicationProduct) then
    composeMedicationProduct(json, name, TFhirMedicationProduct(base), false)
  else if (base is TFhirMedicationProductIngredient) then
    composeMedicationProductIngredient(json, name, TFhirMedicationProductIngredient(base), false)
  else if (base is TFhirMedicationProductBatch) then
    composeMedicationProductBatch(json, name, TFhirMedicationProductBatch(base), false)
  else if (base is TFhirMedicationPackage) then
    composeMedicationPackage(json, name, TFhirMedicationPackage(base), false)
  else if (base is TFhirMedicationPackageContent) then
    composeMedicationPackageContent(json, name, TFhirMedicationPackageContent(base), false)
  else if (base is TFhirMedication) then
    composeMedication(json, name, TFhirMedication(base), false)
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
  else if (base is TFhirMedicationAdministrationDosage) then
    composeMedicationAdministrationDosage(json, name, TFhirMedicationAdministrationDosage(base), false)
  else if (base is TFhirMedicationAdministration) then
    composeMedicationAdministration(json, name, TFhirMedicationAdministration(base), false)
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
  else if (base is TFhirMedicationDispenseDosageInstruction) then
    composeMedicationDispenseDosageInstruction(json, name, TFhirMedicationDispenseDosageInstruction(base), false)
  else if (base is TFhirMedicationDispenseSubstitution) then
    composeMedicationDispenseSubstitution(json, name, TFhirMedicationDispenseSubstitution(base), false)
  else if (base is TFhirMedicationDispense) then
    composeMedicationDispense(json, name, TFhirMedicationDispense(base), false)
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONORDER}
  else if (base is TFhirMedicationOrderDosageInstruction) then
    composeMedicationOrderDosageInstruction(json, name, TFhirMedicationOrderDosageInstruction(base), false)
  else if (base is TFhirMedicationOrderDispenseRequest) then
    composeMedicationOrderDispenseRequest(json, name, TFhirMedicationOrderDispenseRequest(base), false)
  else if (base is TFhirMedicationOrderSubstitution) then
    composeMedicationOrderSubstitution(json, name, TFhirMedicationOrderSubstitution(base), false)
  else if (base is TFhirMedicationOrder) then
    composeMedicationOrder(json, name, TFhirMedicationOrder(base), false)
{$ENDIF FHIR_MEDICATIONORDER}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
  else if (base is TFhirMedicationStatementDosage) then
    composeMedicationStatementDosage(json, name, TFhirMedicationStatementDosage(base), false)
  else if (base is TFhirMedicationStatement) then
    composeMedicationStatement(json, name, TFhirMedicationStatement(base), false)
{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MESSAGEHEADER}
  else if (base is TFhirMessageHeaderResponse) then
    composeMessageHeaderResponse(json, name, TFhirMessageHeaderResponse(base), false)
  else if (base is TFhirMessageHeaderSource) then
    composeMessageHeaderSource(json, name, TFhirMessageHeaderSource(base), false)
  else if (base is TFhirMessageHeaderDestination) then
    composeMessageHeaderDestination(json, name, TFhirMessageHeaderDestination(base), false)
  else if (base is TFhirMessageHeader) then
    composeMessageHeader(json, name, TFhirMessageHeader(base), false)
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_NAMINGSYSTEM}
  else if (base is TFhirNamingSystemContact) then
    composeNamingSystemContact(json, name, TFhirNamingSystemContact(base), false)
  else if (base is TFhirNamingSystemUniqueId) then
    composeNamingSystemUniqueId(json, name, TFhirNamingSystemUniqueId(base), false)
  else if (base is TFhirNamingSystem) then
    composeNamingSystem(json, name, TFhirNamingSystem(base), false)
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
  else if (base is TFhirNutritionOrderOralDiet) then
    composeNutritionOrderOralDiet(json, name, TFhirNutritionOrderOralDiet(base), false)
  else if (base is TFhirNutritionOrderOralDietNutrient) then
    composeNutritionOrderOralDietNutrient(json, name, TFhirNutritionOrderOralDietNutrient(base), false)
  else if (base is TFhirNutritionOrderOralDietTexture) then
    composeNutritionOrderOralDietTexture(json, name, TFhirNutritionOrderOralDietTexture(base), false)
  else if (base is TFhirNutritionOrderSupplement) then
    composeNutritionOrderSupplement(json, name, TFhirNutritionOrderSupplement(base), false)
  else if (base is TFhirNutritionOrderEnteralFormula) then
    composeNutritionOrderEnteralFormula(json, name, TFhirNutritionOrderEnteralFormula(base), false)
  else if (base is TFhirNutritionOrderEnteralFormulaAdministration) then
    composeNutritionOrderEnteralFormulaAdministration(json, name, TFhirNutritionOrderEnteralFormulaAdministration(base), false)
  else if (base is TFhirNutritionOrder) then
    composeNutritionOrder(json, name, TFhirNutritionOrder(base), false)
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
  else if (base is TFhirObservationReferenceRange) then
    composeObservationReferenceRange(json, name, TFhirObservationReferenceRange(base), false)
  else if (base is TFhirObservationRelated) then
    composeObservationRelated(json, name, TFhirObservationRelated(base), false)
  else if (base is TFhirObservationComponent) then
    composeObservationComponent(json, name, TFhirObservationComponent(base), false)
  else if (base is TFhirObservation) then
    composeObservation(json, name, TFhirObservation(base), false)
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OPERATIONDEFINITION}
  else if (base is TFhirOperationDefinitionContact) then
    composeOperationDefinitionContact(json, name, TFhirOperationDefinitionContact(base), false)
  else if (base is TFhirOperationDefinitionParameter) then
    composeOperationDefinitionParameter(json, name, TFhirOperationDefinitionParameter(base), false)
  else if (base is TFhirOperationDefinitionParameterBinding) then
    composeOperationDefinitionParameterBinding(json, name, TFhirOperationDefinitionParameterBinding(base), false)
  else if (base is TFhirOperationDefinition) then
    composeOperationDefinition(json, name, TFhirOperationDefinition(base), false)
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
  else if (base is TFhirOperationOutcomeIssue) then
    composeOperationOutcomeIssue(json, name, TFhirOperationOutcomeIssue(base), false)
  else if (base is TFhirOperationOutcome) then
    composeOperationOutcome(json, name, TFhirOperationOutcome(base), false)
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORDER}
  else if (base is TFhirOrderWhen) then
    composeOrderWhen(json, name, TFhirOrderWhen(base), false)
  else if (base is TFhirOrder) then
    composeOrder(json, name, TFhirOrder(base), false)
{$ENDIF FHIR_ORDER}
{$IFDEF FHIR_ORDERRESPONSE}
  else if (base is TFhirOrderResponse) then
    composeOrderResponse(json, name, TFhirOrderResponse(base), false)
{$ENDIF FHIR_ORDERRESPONSE}
{$IFDEF FHIR_ORGANIZATION}
  else if (base is TFhirOrganizationContact) then
    composeOrganizationContact(json, name, TFhirOrganizationContact(base), false)
  else if (base is TFhirOrganization) then
    composeOrganization(json, name, TFhirOrganization(base), false)
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_PATIENT}
  else if (base is TFhirPatientContact) then
    composePatientContact(json, name, TFhirPatientContact(base), false)
  else if (base is TFhirPatientAnimal) then
    composePatientAnimal(json, name, TFhirPatientAnimal(base), false)
  else if (base is TFhirPatientCommunication) then
    composePatientCommunication(json, name, TFhirPatientCommunication(base), false)
  else if (base is TFhirPatientLink) then
    composePatientLink(json, name, TFhirPatientLink(base), false)
  else if (base is TFhirPatient) then
    composePatient(json, name, TFhirPatient(base), false)
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
  else if (base is TFhirPaymentNotice) then
    composePaymentNotice(json, name, TFhirPaymentNotice(base), false)
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
  else if (base is TFhirPaymentReconciliationDetail) then
    composePaymentReconciliationDetail(json, name, TFhirPaymentReconciliationDetail(base), false)
  else if (base is TFhirPaymentReconciliationNote) then
    composePaymentReconciliationNote(json, name, TFhirPaymentReconciliationNote(base), false)
  else if (base is TFhirPaymentReconciliation) then
    composePaymentReconciliation(json, name, TFhirPaymentReconciliation(base), false)
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
  else if (base is TFhirPersonLink) then
    composePersonLink(json, name, TFhirPersonLink(base), false)
  else if (base is TFhirPerson) then
    composePerson(json, name, TFhirPerson(base), false)
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PRACTITIONER}
  else if (base is TFhirPractitionerPractitionerRole) then
    composePractitionerPractitionerRole(json, name, TFhirPractitionerPractitionerRole(base), false)
  else if (base is TFhirPractitionerQualification) then
    composePractitionerQualification(json, name, TFhirPractitionerQualification(base), false)
  else if (base is TFhirPractitioner) then
    composePractitioner(json, name, TFhirPractitioner(base), false)
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PROCEDURE}
  else if (base is TFhirProcedurePerformer) then
    composeProcedurePerformer(json, name, TFhirProcedurePerformer(base), false)
  else if (base is TFhirProcedureFocalDevice) then
    composeProcedureFocalDevice(json, name, TFhirProcedureFocalDevice(base), false)
  else if (base is TFhirProcedure) then
    composeProcedure(json, name, TFhirProcedure(base), false)
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROCEDUREREQUEST}
  else if (base is TFhirProcedureRequest) then
    composeProcedureRequest(json, name, TFhirProcedureRequest(base), false)
{$ENDIF FHIR_PROCEDUREREQUEST}
{$IFDEF FHIR_PROCESSREQUEST}
  else if (base is TFhirProcessRequestItem) then
    composeProcessRequestItem(json, name, TFhirProcessRequestItem(base), false)
  else if (base is TFhirProcessRequest) then
    composeProcessRequest(json, name, TFhirProcessRequest(base), false)
{$ENDIF FHIR_PROCESSREQUEST}
{$IFDEF FHIR_PROCESSRESPONSE}
  else if (base is TFhirProcessResponseNotes) then
    composeProcessResponseNotes(json, name, TFhirProcessResponseNotes(base), false)
  else if (base is TFhirProcessResponse) then
    composeProcessResponse(json, name, TFhirProcessResponse(base), false)
{$ENDIF FHIR_PROCESSRESPONSE}
{$IFDEF FHIR_PROVENANCE}
  else if (base is TFhirProvenanceAgent) then
    composeProvenanceAgent(json, name, TFhirProvenanceAgent(base), false)
  else if (base is TFhirProvenanceAgentRelatedAgent) then
    composeProvenanceAgentRelatedAgent(json, name, TFhirProvenanceAgentRelatedAgent(base), false)
  else if (base is TFhirProvenanceEntity) then
    composeProvenanceEntity(json, name, TFhirProvenanceEntity(base), false)
  else if (base is TFhirProvenance) then
    composeProvenance(json, name, TFhirProvenance(base), false)
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
  else if (base is TFhirQuestionnaireGroup) then
    composeQuestionnaireGroup(json, name, TFhirQuestionnaireGroup(base), false)
  else if (base is TFhirQuestionnaireGroupQuestion) then
    composeQuestionnaireGroupQuestion(json, name, TFhirQuestionnaireGroupQuestion(base), false)
  else if (base is TFhirQuestionnaire) then
    composeQuestionnaire(json, name, TFhirQuestionnaire(base), false)
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
  else if (base is TFhirQuestionnaireResponseGroup) then
    composeQuestionnaireResponseGroup(json, name, TFhirQuestionnaireResponseGroup(base), false)
  else if (base is TFhirQuestionnaireResponseGroupQuestion) then
    composeQuestionnaireResponseGroupQuestion(json, name, TFhirQuestionnaireResponseGroupQuestion(base), false)
  else if (base is TFhirQuestionnaireResponseGroupQuestionAnswer) then
    composeQuestionnaireResponseGroupQuestionAnswer(json, name, TFhirQuestionnaireResponseGroupQuestionAnswer(base), false)
  else if (base is TFhirQuestionnaireResponse) then
    composeQuestionnaireResponse(json, name, TFhirQuestionnaireResponse(base), false)
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REFERRALREQUEST}
  else if (base is TFhirReferralRequest) then
    composeReferralRequest(json, name, TFhirReferralRequest(base), false)
{$ENDIF FHIR_REFERRALREQUEST}
{$IFDEF FHIR_RELATEDPERSON}
  else if (base is TFhirRelatedPerson) then
    composeRelatedPerson(json, name, TFhirRelatedPerson(base), false)
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_RISKASSESSMENT}
  else if (base is TFhirRiskAssessmentPrediction) then
    composeRiskAssessmentPrediction(json, name, TFhirRiskAssessmentPrediction(base), false)
  else if (base is TFhirRiskAssessment) then
    composeRiskAssessment(json, name, TFhirRiskAssessment(base), false)
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
  else if (base is TFhirSchedule) then
    composeSchedule(json, name, TFhirSchedule(base), false)
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
  else if (base is TFhirSearchParameterContact) then
    composeSearchParameterContact(json, name, TFhirSearchParameterContact(base), false)
  else if (base is TFhirSearchParameter) then
    composeSearchParameter(json, name, TFhirSearchParameter(base), false)
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SLOT}
  else if (base is TFhirSlot) then
    composeSlot(json, name, TFhirSlot(base), false)
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
  else if (base is TFhirSpecimenCollection) then
    composeSpecimenCollection(json, name, TFhirSpecimenCollection(base), false)
  else if (base is TFhirSpecimenTreatment) then
    composeSpecimenTreatment(json, name, TFhirSpecimenTreatment(base), false)
  else if (base is TFhirSpecimenContainer) then
    composeSpecimenContainer(json, name, TFhirSpecimenContainer(base), false)
  else if (base is TFhirSpecimen) then
    composeSpecimen(json, name, TFhirSpecimen(base), false)
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_STRUCTUREDEFINITION}
  else if (base is TFhirStructureDefinitionContact) then
    composeStructureDefinitionContact(json, name, TFhirStructureDefinitionContact(base), false)
  else if (base is TFhirStructureDefinitionMapping) then
    composeStructureDefinitionMapping(json, name, TFhirStructureDefinitionMapping(base), false)
  else if (base is TFhirStructureDefinitionSnapshot) then
    composeStructureDefinitionSnapshot(json, name, TFhirStructureDefinitionSnapshot(base), false)
  else if (base is TFhirStructureDefinitionDifferential) then
    composeStructureDefinitionDifferential(json, name, TFhirStructureDefinitionDifferential(base), false)
  else if (base is TFhirStructureDefinition) then
    composeStructureDefinition(json, name, TFhirStructureDefinition(base), false)
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_SUBSCRIPTION}
  else if (base is TFhirSubscriptionChannel) then
    composeSubscriptionChannel(json, name, TFhirSubscriptionChannel(base), false)
  else if (base is TFhirSubscription) then
    composeSubscription(json, name, TFhirSubscription(base), false)
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
  else if (base is TFhirSubstanceInstance) then
    composeSubstanceInstance(json, name, TFhirSubstanceInstance(base), false)
  else if (base is TFhirSubstanceIngredient) then
    composeSubstanceIngredient(json, name, TFhirSubstanceIngredient(base), false)
  else if (base is TFhirSubstance) then
    composeSubstance(json, name, TFhirSubstance(base), false)
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUPPLYDELIVERY}
  else if (base is TFhirSupplyDelivery) then
    composeSupplyDelivery(json, name, TFhirSupplyDelivery(base), false)
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
  else if (base is TFhirSupplyRequestWhen) then
    composeSupplyRequestWhen(json, name, TFhirSupplyRequestWhen(base), false)
  else if (base is TFhirSupplyRequest) then
    composeSupplyRequest(json, name, TFhirSupplyRequest(base), false)
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TESTSCRIPT}
  else if (base is TFhirTestScriptContact) then
    composeTestScriptContact(json, name, TFhirTestScriptContact(base), false)
  else if (base is TFhirTestScriptMetadata) then
    composeTestScriptMetadata(json, name, TFhirTestScriptMetadata(base), false)
  else if (base is TFhirTestScriptMetadataLink) then
    composeTestScriptMetadataLink(json, name, TFhirTestScriptMetadataLink(base), false)
  else if (base is TFhirTestScriptMetadataCapability) then
    composeTestScriptMetadataCapability(json, name, TFhirTestScriptMetadataCapability(base), false)
  else if (base is TFhirTestScriptFixture) then
    composeTestScriptFixture(json, name, TFhirTestScriptFixture(base), false)
  else if (base is TFhirTestScriptVariable) then
    composeTestScriptVariable(json, name, TFhirTestScriptVariable(base), false)
  else if (base is TFhirTestScriptSetup) then
    composeTestScriptSetup(json, name, TFhirTestScriptSetup(base), false)
  else if (base is TFhirTestScriptSetupAction) then
    composeTestScriptSetupAction(json, name, TFhirTestScriptSetupAction(base), false)
  else if (base is TFhirTestScriptSetupActionOperation) then
    composeTestScriptSetupActionOperation(json, name, TFhirTestScriptSetupActionOperation(base), false)
  else if (base is TFhirTestScriptSetupActionOperationRequestHeader) then
    composeTestScriptSetupActionOperationRequestHeader(json, name, TFhirTestScriptSetupActionOperationRequestHeader(base), false)
  else if (base is TFhirTestScriptSetupActionAssert) then
    composeTestScriptSetupActionAssert(json, name, TFhirTestScriptSetupActionAssert(base), false)
  else if (base is TFhirTestScriptTest) then
    composeTestScriptTest(json, name, TFhirTestScriptTest(base), false)
  else if (base is TFhirTestScriptTestAction) then
    composeTestScriptTestAction(json, name, TFhirTestScriptTestAction(base), false)
  else if (base is TFhirTestScriptTeardown) then
    composeTestScriptTeardown(json, name, TFhirTestScriptTeardown(base), false)
  else if (base is TFhirTestScriptTeardownAction) then
    composeTestScriptTeardownAction(json, name, TFhirTestScriptTeardownAction(base), false)
  else if (base is TFhirTestScript) then
    composeTestScript(json, name, TFhirTestScript(base), false)
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
  else if (base is TFhirValueSetContact) then
    composeValueSetContact(json, name, TFhirValueSetContact(base), false)
  else if (base is TFhirValueSetCodeSystem) then
    composeValueSetCodeSystem(json, name, TFhirValueSetCodeSystem(base), false)
  else if (base is TFhirValueSetCodeSystemConcept) then
    composeValueSetCodeSystemConcept(json, name, TFhirValueSetCodeSystemConcept(base), false)
  else if (base is TFhirValueSetCodeSystemConceptDesignation) then
    composeValueSetCodeSystemConceptDesignation(json, name, TFhirValueSetCodeSystemConceptDesignation(base), false)
  else if (base is TFhirValueSetCompose) then
    composeValueSetCompose(json, name, TFhirValueSetCompose(base), false)
  else if (base is TFhirValueSetComposeInclude) then
    composeValueSetComposeInclude(json, name, TFhirValueSetComposeInclude(base), false)
  else if (base is TFhirValueSetComposeIncludeConcept) then
    composeValueSetComposeIncludeConcept(json, name, TFhirValueSetComposeIncludeConcept(base), false)
  else if (base is TFhirValueSetComposeIncludeFilter) then
    composeValueSetComposeIncludeFilter(json, name, TFhirValueSetComposeIncludeFilter(base), false)
  else if (base is TFhirValueSetExpansion) then
    composeValueSetExpansion(json, name, TFhirValueSetExpansion(base), false)
  else if (base is TFhirValueSetExpansionParameter) then
    composeValueSetExpansionParameter(json, name, TFhirValueSetExpansionParameter(base), false)
  else if (base is TFhirValueSetExpansionContains) then
    composeValueSetExpansionContains(json, name, TFhirValueSetExpansionContains(base), false)
  else if (base is TFhirValueSet) then
    composeValueSet(json, name, TFhirValueSet(base), false)
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VISIONPRESCRIPTION}
  else if (base is TFhirVisionPrescriptionDispense) then
    composeVisionPrescriptionDispense(json, name, TFhirVisionPrescriptionDispense(base), false)
  else if (base is TFhirVisionPrescription) then
    composeVisionPrescription(json, name, TFhirVisionPrescription(base), false)
{$ENDIF FHIR_VISIONPRESCRIPTION}
  else
    inherited ComposeBase(json, name, base);
end;

procedure TFHIRJsonComposer.ComposeResource(json : TJSONWriter; resource: TFhirResource);
begin
  if (resource = nil) Then
    Raise EJsonException.Create('error - resource is nil');
  json.value('resourceType', CODES_TFhirResourceType[resource.ResourceType]);
  Case resource.ResourceType of
{$IFDEF FHIR_PARAMETERS}
    frtParameters: ComposeParameters(json, 'Parameters', TFhirParameters(resource));
{$ENDIF FHIR_PARAMETERS}
{$IFDEF FHIR_ACCOUNT}
  {$IFDEF FHIR_ACCOUNT}
     frtAccount: ComposeAccount(json, 'Account', TFhirAccount(resource));
   {$ENDIF}
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
  {$IFDEF FHIR_ALLERGYINTOLERANCE}
     frtAllergyIntolerance: ComposeAllergyIntolerance(json, 'AllergyIntolerance', TFhirAllergyIntolerance(resource));
   {$ENDIF}
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
  {$IFDEF FHIR_APPOINTMENT}
     frtAppointment: ComposeAppointment(json, 'Appointment', TFhirAppointment(resource));
   {$ENDIF}
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
  {$IFDEF FHIR_APPOINTMENTRESPONSE}
     frtAppointmentResponse: ComposeAppointmentResponse(json, 'AppointmentResponse', TFhirAppointmentResponse(resource));
   {$ENDIF}
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
  {$IFDEF FHIR_AUDITEVENT}
     frtAuditEvent: ComposeAuditEvent(json, 'AuditEvent', TFhirAuditEvent(resource));
   {$ENDIF}
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
  {$IFDEF FHIR_BASIC}
     frtBasic: ComposeBasic(json, 'Basic', TFhirBasic(resource));
   {$ENDIF}
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
  {$IFDEF FHIR_BINARY}
     frtBinary: ComposeBinary(json, 'Binary', TFhirBinary(resource));
   {$ENDIF}
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BODYSITE}
  {$IFDEF FHIR_BODYSITE}
     frtBodySite: ComposeBodySite(json, 'BodySite', TFhirBodySite(resource));
   {$ENDIF}
{$ENDIF FHIR_BODYSITE}
{$IFDEF FHIR_BUNDLE}
  {$IFDEF FHIR_BUNDLE}
     frtBundle: ComposeBundle(json, 'Bundle', TFhirBundle(resource));
   {$ENDIF}
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAREPLAN}
  {$IFDEF FHIR_CAREPLAN}
     frtCarePlan: ComposeCarePlan(json, 'CarePlan', TFhirCarePlan(resource));
   {$ENDIF}
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CLAIM}
  {$IFDEF FHIR_CLAIM}
     frtClaim: ComposeClaim(json, 'Claim', TFhirClaim(resource));
   {$ENDIF}
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
  {$IFDEF FHIR_CLAIMRESPONSE}
     frtClaimResponse: ComposeClaimResponse(json, 'ClaimResponse', TFhirClaimResponse(resource));
   {$ENDIF}
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
  {$IFDEF FHIR_CLINICALIMPRESSION}
     frtClinicalImpression: ComposeClinicalImpression(json, 'ClinicalImpression', TFhirClinicalImpression(resource));
   {$ENDIF}
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_COMMUNICATION}
  {$IFDEF FHIR_COMMUNICATION}
     frtCommunication: ComposeCommunication(json, 'Communication', TFhirCommunication(resource));
   {$ENDIF}
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
  {$IFDEF FHIR_COMMUNICATIONREQUEST}
     frtCommunicationRequest: ComposeCommunicationRequest(json, 'CommunicationRequest', TFhirCommunicationRequest(resource));
   {$ENDIF}
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPOSITION}
  {$IFDEF FHIR_COMPOSITION}
     frtComposition: ComposeComposition(json, 'Composition', TFhirComposition(resource));
   {$ENDIF}
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
  {$IFDEF FHIR_CONCEPTMAP}
     frtConceptMap: ComposeConceptMap(json, 'ConceptMap', TFhirConceptMap(resource));
   {$ENDIF}
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
  {$IFDEF FHIR_CONDITION}
     frtCondition: ComposeCondition(json, 'Condition', TFhirCondition(resource));
   {$ENDIF}
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONFORMANCE}
  {$IFDEF FHIR_CONFORMANCE}
     frtConformance: ComposeConformance(json, 'Conformance', TFhirConformance(resource));
   {$ENDIF}
{$ENDIF FHIR_CONFORMANCE}
{$IFDEF FHIR_CONTRACT}
  {$IFDEF FHIR_CONTRACT}
     frtContract: ComposeContract(json, 'Contract', TFhirContract(resource));
   {$ENDIF}
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
  {$IFDEF FHIR_COVERAGE}
     frtCoverage: ComposeCoverage(json, 'Coverage', TFhirCoverage(resource));
   {$ENDIF}
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_DATAELEMENT}
  {$IFDEF FHIR_DATAELEMENT}
     frtDataElement: ComposeDataElement(json, 'DataElement', TFhirDataElement(resource));
   {$ENDIF}
{$ENDIF FHIR_DATAELEMENT}
{$IFDEF FHIR_DETECTEDISSUE}
  {$IFDEF FHIR_DETECTEDISSUE}
     frtDetectedIssue: ComposeDetectedIssue(json, 'DetectedIssue', TFhirDetectedIssue(resource));
   {$ENDIF}
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
  {$IFDEF FHIR_DEVICE}
     frtDevice: ComposeDevice(json, 'Device', TFhirDevice(resource));
   {$ENDIF}
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICECOMPONENT}
  {$IFDEF FHIR_DEVICECOMPONENT}
     frtDeviceComponent: ComposeDeviceComponent(json, 'DeviceComponent', TFhirDeviceComponent(resource));
   {$ENDIF}
{$ENDIF FHIR_DEVICECOMPONENT}
{$IFDEF FHIR_DEVICEMETRIC}
  {$IFDEF FHIR_DEVICEMETRIC}
     frtDeviceMetric: ComposeDeviceMetric(json, 'DeviceMetric', TFhirDeviceMetric(resource));
   {$ENDIF}
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEUSEREQUEST}
  {$IFDEF FHIR_DEVICEUSEREQUEST}
     frtDeviceUseRequest: ComposeDeviceUseRequest(json, 'DeviceUseRequest', TFhirDeviceUseRequest(resource));
   {$ENDIF}
{$ENDIF FHIR_DEVICEUSEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
  {$IFDEF FHIR_DEVICEUSESTATEMENT}
     frtDeviceUseStatement: ComposeDeviceUseStatement(json, 'DeviceUseStatement', TFhirDeviceUseStatement(resource));
   {$ENDIF}
{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICORDER}
  {$IFDEF FHIR_DIAGNOSTICORDER}
     frtDiagnosticOrder: ComposeDiagnosticOrder(json, 'DiagnosticOrder', TFhirDiagnosticOrder(resource));
   {$ENDIF}
{$ENDIF FHIR_DIAGNOSTICORDER}
{$IFDEF FHIR_DIAGNOSTICREPORT}
  {$IFDEF FHIR_DIAGNOSTICREPORT}
     frtDiagnosticReport: ComposeDiagnosticReport(json, 'DiagnosticReport', TFhirDiagnosticReport(resource));
   {$ENDIF}
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
  {$IFDEF FHIR_DOCUMENTMANIFEST}
     frtDocumentManifest: ComposeDocumentManifest(json, 'DocumentManifest', TFhirDocumentManifest(resource));
   {$ENDIF}
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
  {$IFDEF FHIR_DOCUMENTREFERENCE}
     frtDocumentReference: ComposeDocumentReference(json, 'DocumentReference', TFhirDocumentReference(resource));
   {$ENDIF}
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ELIGIBILITYREQUEST}
  {$IFDEF FHIR_ELIGIBILITYREQUEST}
     frtEligibilityRequest: ComposeEligibilityRequest(json, 'EligibilityRequest', TFhirEligibilityRequest(resource));
   {$ENDIF}
{$ENDIF FHIR_ELIGIBILITYREQUEST}
{$IFDEF FHIR_ELIGIBILITYRESPONSE}
  {$IFDEF FHIR_ELIGIBILITYRESPONSE}
     frtEligibilityResponse: ComposeEligibilityResponse(json, 'EligibilityResponse', TFhirEligibilityResponse(resource));
   {$ENDIF}
{$ENDIF FHIR_ELIGIBILITYRESPONSE}
{$IFDEF FHIR_ENCOUNTER}
  {$IFDEF FHIR_ENCOUNTER}
     frtEncounter: ComposeEncounter(json, 'Encounter', TFhirEncounter(resource));
   {$ENDIF}
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENROLLMENTREQUEST}
  {$IFDEF FHIR_ENROLLMENTREQUEST}
     frtEnrollmentRequest: ComposeEnrollmentRequest(json, 'EnrollmentRequest', TFhirEnrollmentRequest(resource));
   {$ENDIF}
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
  {$IFDEF FHIR_ENROLLMENTRESPONSE}
     frtEnrollmentResponse: ComposeEnrollmentResponse(json, 'EnrollmentResponse', TFhirEnrollmentResponse(resource));
   {$ENDIF}
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
  {$IFDEF FHIR_EPISODEOFCARE}
     frtEpisodeOfCare: ComposeEpisodeOfCare(json, 'EpisodeOfCare', TFhirEpisodeOfCare(resource));
   {$ENDIF}
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
  {$IFDEF FHIR_EXPLANATIONOFBENEFIT}
     frtExplanationOfBenefit: ComposeExplanationOfBenefit(json, 'ExplanationOfBenefit', TFhirExplanationOfBenefit(resource));
   {$ENDIF}
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
  {$IFDEF FHIR_FAMILYMEMBERHISTORY}
     frtFamilyMemberHistory: ComposeFamilyMemberHistory(json, 'FamilyMemberHistory', TFhirFamilyMemberHistory(resource));
   {$ENDIF}
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
  {$IFDEF FHIR_FLAG}
     frtFlag: ComposeFlag(json, 'Flag', TFhirFlag(resource));
   {$ENDIF}
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
  {$IFDEF FHIR_GOAL}
     frtGoal: ComposeGoal(json, 'Goal', TFhirGoal(resource));
   {$ENDIF}
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GROUP}
  {$IFDEF FHIR_GROUP}
     frtGroup: ComposeGroup(json, 'Group', TFhirGroup(resource));
   {$ENDIF}
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_HEALTHCARESERVICE}
  {$IFDEF FHIR_HEALTHCARESERVICE}
     frtHealthcareService: ComposeHealthcareService(json, 'HealthcareService', TFhirHealthcareService(resource));
   {$ENDIF}
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGOBJECTSELECTION}
  {$IFDEF FHIR_IMAGINGOBJECTSELECTION}
     frtImagingObjectSelection: ComposeImagingObjectSelection(json, 'ImagingObjectSelection', TFhirImagingObjectSelection(resource));
   {$ENDIF}
{$ENDIF FHIR_IMAGINGOBJECTSELECTION}
{$IFDEF FHIR_IMAGINGSTUDY}
  {$IFDEF FHIR_IMAGINGSTUDY}
     frtImagingStudy: ComposeImagingStudy(json, 'ImagingStudy', TFhirImagingStudy(resource));
   {$ENDIF}
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
  {$IFDEF FHIR_IMMUNIZATION}
     frtImmunization: ComposeImmunization(json, 'Immunization', TFhirImmunization(resource));
   {$ENDIF}
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
  {$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
     frtImmunizationRecommendation: ComposeImmunizationRecommendation(json, 'ImmunizationRecommendation', TFhirImmunizationRecommendation(resource));
   {$ENDIF}
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
  {$IFDEF FHIR_IMPLEMENTATIONGUIDE}
     frtImplementationGuide: ComposeImplementationGuide(json, 'ImplementationGuide', TFhirImplementationGuide(resource));
   {$ENDIF}
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_LIST}
  {$IFDEF FHIR_LIST}
     frtList: ComposeList(json, 'List', TFhirList(resource));
   {$ENDIF}
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
  {$IFDEF FHIR_LOCATION}
     frtLocation: ComposeLocation(json, 'Location', TFhirLocation(resource));
   {$ENDIF}
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEDIA}
  {$IFDEF FHIR_MEDIA}
     frtMedia: ComposeMedia(json, 'Media', TFhirMedia(resource));
   {$ENDIF}
{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
  {$IFDEF FHIR_MEDICATION}
     frtMedication: ComposeMedication(json, 'Medication', TFhirMedication(resource));
   {$ENDIF}
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
  {$IFDEF FHIR_MEDICATIONADMINISTRATION}
     frtMedicationAdministration: ComposeMedicationAdministration(json, 'MedicationAdministration', TFhirMedicationAdministration(resource));
   {$ENDIF}
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
  {$IFDEF FHIR_MEDICATIONDISPENSE}
     frtMedicationDispense: ComposeMedicationDispense(json, 'MedicationDispense', TFhirMedicationDispense(resource));
   {$ENDIF}
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONORDER}
  {$IFDEF FHIR_MEDICATIONORDER}
     frtMedicationOrder: ComposeMedicationOrder(json, 'MedicationOrder', TFhirMedicationOrder(resource));
   {$ENDIF}
{$ENDIF FHIR_MEDICATIONORDER}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
  {$IFDEF FHIR_MEDICATIONSTATEMENT}
     frtMedicationStatement: ComposeMedicationStatement(json, 'MedicationStatement', TFhirMedicationStatement(resource));
   {$ENDIF}
{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MESSAGEHEADER}
  {$IFDEF FHIR_MESSAGEHEADER}
     frtMessageHeader: ComposeMessageHeader(json, 'MessageHeader', TFhirMessageHeader(resource));
   {$ENDIF}
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_NAMINGSYSTEM}
  {$IFDEF FHIR_NAMINGSYSTEM}
     frtNamingSystem: ComposeNamingSystem(json, 'NamingSystem', TFhirNamingSystem(resource));
   {$ENDIF}
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
  {$IFDEF FHIR_NUTRITIONORDER}
     frtNutritionOrder: ComposeNutritionOrder(json, 'NutritionOrder', TFhirNutritionOrder(resource));
   {$ENDIF}
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
  {$IFDEF FHIR_OBSERVATION}
     frtObservation: ComposeObservation(json, 'Observation', TFhirObservation(resource));
   {$ENDIF}
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OPERATIONDEFINITION}
  {$IFDEF FHIR_OPERATIONDEFINITION}
     frtOperationDefinition: ComposeOperationDefinition(json, 'OperationDefinition', TFhirOperationDefinition(resource));
   {$ENDIF}
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
  {$IFDEF FHIR_OPERATIONOUTCOME}
     frtOperationOutcome: ComposeOperationOutcome(json, 'OperationOutcome', TFhirOperationOutcome(resource));
   {$ENDIF}
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORDER}
  {$IFDEF FHIR_ORDER}
     frtOrder: ComposeOrder(json, 'Order', TFhirOrder(resource));
   {$ENDIF}
{$ENDIF FHIR_ORDER}
{$IFDEF FHIR_ORDERRESPONSE}
  {$IFDEF FHIR_ORDERRESPONSE}
     frtOrderResponse: ComposeOrderResponse(json, 'OrderResponse', TFhirOrderResponse(resource));
   {$ENDIF}
{$ENDIF FHIR_ORDERRESPONSE}
{$IFDEF FHIR_ORGANIZATION}
  {$IFDEF FHIR_ORGANIZATION}
     frtOrganization: ComposeOrganization(json, 'Organization', TFhirOrganization(resource));
   {$ENDIF}
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_PATIENT}
  {$IFDEF FHIR_PATIENT}
     frtPatient: ComposePatient(json, 'Patient', TFhirPatient(resource));
   {$ENDIF}
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
  {$IFDEF FHIR_PAYMENTNOTICE}
     frtPaymentNotice: ComposePaymentNotice(json, 'PaymentNotice', TFhirPaymentNotice(resource));
   {$ENDIF}
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
  {$IFDEF FHIR_PAYMENTRECONCILIATION}
     frtPaymentReconciliation: ComposePaymentReconciliation(json, 'PaymentReconciliation', TFhirPaymentReconciliation(resource));
   {$ENDIF}
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
  {$IFDEF FHIR_PERSON}
     frtPerson: ComposePerson(json, 'Person', TFhirPerson(resource));
   {$ENDIF}
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PRACTITIONER}
  {$IFDEF FHIR_PRACTITIONER}
     frtPractitioner: ComposePractitioner(json, 'Practitioner', TFhirPractitioner(resource));
   {$ENDIF}
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PROCEDURE}
  {$IFDEF FHIR_PROCEDURE}
     frtProcedure: ComposeProcedure(json, 'Procedure', TFhirProcedure(resource));
   {$ENDIF}
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROCEDUREREQUEST}
  {$IFDEF FHIR_PROCEDUREREQUEST}
     frtProcedureRequest: ComposeProcedureRequest(json, 'ProcedureRequest', TFhirProcedureRequest(resource));
   {$ENDIF}
{$ENDIF FHIR_PROCEDUREREQUEST}
{$IFDEF FHIR_PROCESSREQUEST}
  {$IFDEF FHIR_PROCESSREQUEST}
     frtProcessRequest: ComposeProcessRequest(json, 'ProcessRequest', TFhirProcessRequest(resource));
   {$ENDIF}
{$ENDIF FHIR_PROCESSREQUEST}
{$IFDEF FHIR_PROCESSRESPONSE}
  {$IFDEF FHIR_PROCESSRESPONSE}
     frtProcessResponse: ComposeProcessResponse(json, 'ProcessResponse', TFhirProcessResponse(resource));
   {$ENDIF}
{$ENDIF FHIR_PROCESSRESPONSE}
{$IFDEF FHIR_PROVENANCE}
  {$IFDEF FHIR_PROVENANCE}
     frtProvenance: ComposeProvenance(json, 'Provenance', TFhirProvenance(resource));
   {$ENDIF}
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
  {$IFDEF FHIR_QUESTIONNAIRE}
     frtQuestionnaire: ComposeQuestionnaire(json, 'Questionnaire', TFhirQuestionnaire(resource));
   {$ENDIF}
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
  {$IFDEF FHIR_QUESTIONNAIRERESPONSE}
     frtQuestionnaireResponse: ComposeQuestionnaireResponse(json, 'QuestionnaireResponse', TFhirQuestionnaireResponse(resource));
   {$ENDIF}
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REFERRALREQUEST}
  {$IFDEF FHIR_REFERRALREQUEST}
     frtReferralRequest: ComposeReferralRequest(json, 'ReferralRequest', TFhirReferralRequest(resource));
   {$ENDIF}
{$ENDIF FHIR_REFERRALREQUEST}
{$IFDEF FHIR_RELATEDPERSON}
  {$IFDEF FHIR_RELATEDPERSON}
     frtRelatedPerson: ComposeRelatedPerson(json, 'RelatedPerson', TFhirRelatedPerson(resource));
   {$ENDIF}
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_RISKASSESSMENT}
  {$IFDEF FHIR_RISKASSESSMENT}
     frtRiskAssessment: ComposeRiskAssessment(json, 'RiskAssessment', TFhirRiskAssessment(resource));
   {$ENDIF}
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
  {$IFDEF FHIR_SCHEDULE}
     frtSchedule: ComposeSchedule(json, 'Schedule', TFhirSchedule(resource));
   {$ENDIF}
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
  {$IFDEF FHIR_SEARCHPARAMETER}
     frtSearchParameter: ComposeSearchParameter(json, 'SearchParameter', TFhirSearchParameter(resource));
   {$ENDIF}
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SLOT}
  {$IFDEF FHIR_SLOT}
     frtSlot: ComposeSlot(json, 'Slot', TFhirSlot(resource));
   {$ENDIF}
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
  {$IFDEF FHIR_SPECIMEN}
     frtSpecimen: ComposeSpecimen(json, 'Specimen', TFhirSpecimen(resource));
   {$ENDIF}
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_STRUCTUREDEFINITION}
  {$IFDEF FHIR_STRUCTUREDEFINITION}
     frtStructureDefinition: composeStructureDefinition(json, 'StructureDefinition', TFhirStructureDefinition(resource));
   {$ENDIF}
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_SUBSCRIPTION}
  {$IFDEF FHIR_SUBSCRIPTION}
     frtSubscription: ComposeSubscription(json, 'Subscription', TFhirSubscription(resource));
   {$ENDIF}
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
  {$IFDEF FHIR_SUBSTANCE}
     frtSubstance: ComposeSubstance(json, 'Substance', TFhirSubstance(resource));
   {$ENDIF}
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUPPLYDELIVERY}
  {$IFDEF FHIR_SUPPLYDELIVERY}
     frtSupplyDelivery: ComposeSupplyDelivery(json, 'SupplyDelivery', TFhirSupplyDelivery(resource));
   {$ENDIF}
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
  {$IFDEF FHIR_SUPPLYREQUEST}
     frtSupplyRequest: ComposeSupplyRequest(json, 'SupplyRequest', TFhirSupplyRequest(resource));
   {$ENDIF}
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TESTSCRIPT}
  {$IFDEF FHIR_TESTSCRIPT}
     frtTestScript: ComposeTestScript(json, 'TestScript', TFhirTestScript(resource));
   {$ENDIF}
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
  {$IFDEF FHIR_VALUESET}
     frtValueSet: ComposeValueSet(json, 'ValueSet', TFhirValueSet(resource));
   {$ENDIF}
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VISIONPRESCRIPTION}
  {$IFDEF FHIR_VISIONPRESCRIPTION}
     frtVisionPrescription: ComposeVisionPrescription(json, 'VisionPrescription', TFhirVisionPrescription(resource));
   {$ENDIF}
{$ENDIF FHIR_VISIONPRESCRIPTION}
  else
    raise EJsonException.Create('Internal error: the resource type '+CODES_TFhirResourceType[resource.ResourceType]+' is not a valid resource type');
  end;
end;


end.

