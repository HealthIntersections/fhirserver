unit fhir2_xml;

{
  Copyright (c) 2011+, HL7 and Health Intersections Pty Ltd (http://www.healthintersections.com.au)
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
}

{$I fhir.inc}
{$I fhir2.inc}

interface

// FHIR v1.0.2 generated 2015-10-24T07:41:03+11:00

uses
  SysUtils, Classes,
  fsl_base, fsl_utilities, fsl_collections, fsl_xml,
  fhir_parser, fhir_objects,
  fhir2_parserBase, fhir2_resources, fhir2_constants, fhir2_types,
  fhir2_resources_base, fhir2_resources_admin, fhir2_resources_clinical, fhir2_resources_canonical, fhir2_resources_other;

Type

  TFHIRXmlParser = class (TFHIRXmlParserBase2)
  protected
    function ParseElement(element : TMXmlElement; path : string) : TFhirElement;

    Procedure ParseElementAttributes(value : TFhirElement; path : string; element : TMXmlElement);
    Function ParseBackboneElementChild(element : TFhirBackboneElement; path : string; child : TMXmlElement) : boolean;
    Function ParseElementChild(element : TFhirElement; path : string; child : TMXmlElement) : boolean;
    function ParseBackboneElement(element : TMXmlElement; path : string) : TFhirBackboneElement;

    function ParseEnum(Const aNames, aSystems : Array Of String; path : String; element : TMXmlElement) : TFhirEnum;
    function ParseDateTime(element : TMXmlElement; path : string) : TFhirDateTime;
    function ParseDate(element : TMXmlElement; path : string) : TFhirDate;
    function ParseString(element : TMXmlElement; path : string) : TFhirString;
    function ParseInteger(element : TMXmlElement; path : string) : TFhirInteger;
    function ParseUri(element : TMXmlElement; path : string) : TFhirUri;
    function ParseInstant(element : TMXmlElement; path : string) : TFhirInstant;
    function ParseBoolean(element : TMXmlElement; path : string) : TFhirBoolean;
    function ParseBase64Binary(element : TMXmlElement; path : string) : TFhirBase64Binary;
    function ParseTime(element : TMXmlElement; path : string) : TFhirTime;
    function ParseDecimal(element : TMXmlElement; path : string) : TFhirDecimal;
    function ParseCode(element : TMXmlElement; path : string) : TFhirCode;
    function ParseOid(element : TMXmlElement; path : string) : TFhirOid;
    function ParseUuid(element : TMXmlElement; path : string) : TFhirUuid;
    function ParseMarkdown(element : TMXmlElement; path : string) : TFhirMarkdown;
    function ParseUnsignedInt(element : TMXmlElement; path : string) : TFhirUnsignedInt;
    function ParseId(element : TMXmlElement; path : string) : TFhirId;
    function ParsePositiveInt(element : TMXmlElement; path : string) : TFhirPositiveInt;

    Procedure ParseResourceAttributes(resource : TFhirResource; path : string; element : TMXmlElement);
    Function ParseResourceChild(resource : TFhirResource; path : string; child : TMXmlElement) : boolean;
{$IFDEF FHIR_PARAMETERS}
    function ParseParametersParameter(element : TMXmlElement; path : string) : TFhirParametersParameter;
    function ParseParametersParameterChild(element : TFhirParametersParameter; path : string; child : TMXmlElement) : boolean;
    function ParseParameters(element : TMXmlElement; path : string) : TFhirParameters;
    function ParseParametersChild(element : TFhirParameters; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_PARAMETERS}
    Procedure ParseDomainResourceAttributes(resource : TFhirDomainResource; path : string; element : TMXmlElement);
    Function ParseDomainResourceChild(resource : TFhirDomainResource; path : string; child : TMXmlElement) : boolean;

    function ParseExtension(element : TMXmlElement; path : string) : TFhirExtension;
    function ParseExtensionChild(element : TFhirExtension; path : string; child : TMXmlElement) : boolean;
    function ParseNarrative(element : TMXmlElement; path : string) : TFhirNarrative;
    function ParseNarrativeChild(element : TFhirNarrative; path : string; child : TMXmlElement) : boolean;
    function ParseIdentifier(element : TMXmlElement; path : string) : TFhirIdentifier;
    function ParseIdentifierChild(element : TFhirIdentifier; path : string; child : TMXmlElement) : boolean;
    function ParseCoding(element : TMXmlElement; path : string) : TFhirCoding;
    function ParseCodingChild(element : TFhirCoding; path : string; child : TMXmlElement) : boolean;
    function ParseReference(element : TMXmlElement; path : string) : TFhirReference;
    function ParseReferenceChild(element : TFhirReference; path : string; child : TMXmlElement) : boolean;
    function ParseSignature(element : TMXmlElement; path : string) : TFhirSignature;
    function ParseSignatureChild(element : TFhirSignature; path : string; child : TMXmlElement) : boolean;
    function ParseSampledData(element : TMXmlElement; path : string) : TFhirSampledData;
    function ParseSampledDataChild(element : TFhirSampledData; path : string; child : TMXmlElement) : boolean;
    function ParsePeriod(element : TMXmlElement; path : string) : TFhirPeriod;
    function ParsePeriodChild(element : TFhirPeriod; path : string; child : TMXmlElement) : boolean;
    function ParseQuantity(element : TMXmlElement; path : string) : TFhirQuantity;
    function ParseQuantityChild(element : TFhirQuantity; path : string; child : TMXmlElement) : boolean;
    function ParseAttachment(element : TMXmlElement; path : string) : TFhirAttachment;
    function ParseAttachmentChild(element : TFhirAttachment; path : string; child : TMXmlElement) : boolean;
    function ParseRatio(element : TMXmlElement; path : string) : TFhirRatio;
    function ParseRatioChild(element : TFhirRatio; path : string; child : TMXmlElement) : boolean;
    function ParseRange(element : TMXmlElement; path : string) : TFhirRange;
    function ParseRangeChild(element : TFhirRange; path : string; child : TMXmlElement) : boolean;
    function ParseAnnotation(element : TMXmlElement; path : string) : TFhirAnnotation;
    function ParseAnnotationChild(element : TFhirAnnotation; path : string; child : TMXmlElement) : boolean;
    function ParseCodeableConcept(element : TMXmlElement; path : string) : TFhirCodeableConcept;
    function ParseCodeableConceptChild(element : TFhirCodeableConcept; path : string; child : TMXmlElement) : boolean;
    function ParseHumanName(element : TMXmlElement; path : string) : TFhirHumanName;
    function ParseHumanNameChild(element : TFhirHumanName; path : string; child : TMXmlElement) : boolean;
    function ParseMeta(element : TMXmlElement; path : string) : TFhirMeta;
    function ParseMetaChild(element : TFhirMeta; path : string; child : TMXmlElement) : boolean;
    function ParseContactPoint(element : TMXmlElement; path : string) : TFhirContactPoint;
    function ParseContactPointChild(element : TFhirContactPoint; path : string; child : TMXmlElement) : boolean;
    function ParseAddress(element : TMXmlElement; path : string) : TFhirAddress;
    function ParseAddressChild(element : TFhirAddress; path : string; child : TMXmlElement) : boolean;
    function ParseElementDefinitionSlicing(element : TMXmlElement; path : string) : TFhirElementDefinitionSlicing;
    function ParseElementDefinitionSlicingChild(element : TFhirElementDefinitionSlicing; path : string; child : TMXmlElement) : boolean;
    function ParseElementDefinitionBase(element : TMXmlElement; path : string) : TFhirElementDefinitionBase;
    function ParseElementDefinitionBaseChild(element : TFhirElementDefinitionBase; path : string; child : TMXmlElement) : boolean;
    function ParseElementDefinitionType(element : TMXmlElement; path : string) : TFhirElementDefinitionType;
    function ParseElementDefinitionTypeChild(element : TFhirElementDefinitionType; path : string; child : TMXmlElement) : boolean;
    function ParseElementDefinitionConstraint(element : TMXmlElement; path : string) : TFhirElementDefinitionConstraint;
    function ParseElementDefinitionConstraintChild(element : TFhirElementDefinitionConstraint; path : string; child : TMXmlElement) : boolean;
    function ParseElementDefinitionBinding(element : TMXmlElement; path : string) : TFhirElementDefinitionBinding;
    function ParseElementDefinitionBindingChild(element : TFhirElementDefinitionBinding; path : string; child : TMXmlElement) : boolean;
    function ParseElementDefinitionMapping(element : TMXmlElement; path : string) : TFhirElementDefinitionMapping;
    function ParseElementDefinitionMappingChild(element : TFhirElementDefinitionMapping; path : string; child : TMXmlElement) : boolean;
    function ParseElementDefinition(element : TMXmlElement; path : string) : TFhirElementDefinition;
    function ParseElementDefinitionChild(element : TFhirElementDefinition; path : string; child : TMXmlElement) : boolean;
    function ParseTimingRepeat(element : TMXmlElement; path : string) : TFhirTimingRepeat;
    function ParseTimingRepeatChild(element : TFhirTimingRepeat; path : string; child : TMXmlElement) : boolean;
    function ParseTiming(element : TMXmlElement; path : string) : TFhirTiming;
    function ParseTimingChild(element : TFhirTiming; path : string; child : TMXmlElement) : boolean;

{$IFDEF FHIR_ACCOUNT}
    function ParseAccount(element : TMXmlElement; path : string) : TFhirAccount;
    function ParseAccountChild(element : TFhirAccount; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
    function ParseAllergyIntoleranceReaction(element : TMXmlElement; path : string) : TFhirAllergyIntoleranceReaction;
    function ParseAllergyIntoleranceReactionChild(element : TFhirAllergyIntoleranceReaction; path : string; child : TMXmlElement) : boolean;
    function ParseAllergyIntolerance(element : TMXmlElement; path : string) : TFhirAllergyIntolerance;
    function ParseAllergyIntoleranceChild(element : TFhirAllergyIntolerance; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
    function ParseAppointmentParticipant(element : TMXmlElement; path : string) : TFhirAppointmentParticipant;
    function ParseAppointmentParticipantChild(element : TFhirAppointmentParticipant; path : string; child : TMXmlElement) : boolean;
    function ParseAppointment(element : TMXmlElement; path : string) : TFhirAppointment;
    function ParseAppointmentChild(element : TFhirAppointment; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
    function ParseAppointmentResponse(element : TMXmlElement; path : string) : TFhirAppointmentResponse;
    function ParseAppointmentResponseChild(element : TFhirAppointmentResponse; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
    function ParseAuditEventEvent(element : TMXmlElement; path : string) : TFhirAuditEventEvent;
    function ParseAuditEventEventChild(element : TFhirAuditEventEvent; path : string; child : TMXmlElement) : boolean;
    function ParseAuditEventParticipant(element : TMXmlElement; path : string) : TFhirAuditEventParticipant;
    function ParseAuditEventParticipantChild(element : TFhirAuditEventParticipant; path : string; child : TMXmlElement) : boolean;
    function ParseAuditEventParticipantNetwork(element : TMXmlElement; path : string) : TFhirAuditEventParticipantNetwork;
    function ParseAuditEventParticipantNetworkChild(element : TFhirAuditEventParticipantNetwork; path : string; child : TMXmlElement) : boolean;
    function ParseAuditEventSource(element : TMXmlElement; path : string) : TFhirAuditEventSource;
    function ParseAuditEventSourceChild(element : TFhirAuditEventSource; path : string; child : TMXmlElement) : boolean;
    function ParseAuditEventObject(element : TMXmlElement; path : string) : TFhirAuditEventObject;
    function ParseAuditEventObjectChild(element : TFhirAuditEventObject; path : string; child : TMXmlElement) : boolean;
    function ParseAuditEventObjectDetail(element : TMXmlElement; path : string) : TFhirAuditEventObjectDetail;
    function ParseAuditEventObjectDetailChild(element : TFhirAuditEventObjectDetail; path : string; child : TMXmlElement) : boolean;
    function ParseAuditEvent(element : TMXmlElement; path : string) : TFhirAuditEvent;
    function ParseAuditEventChild(element : TFhirAuditEvent; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
    function ParseBasic(element : TMXmlElement; path : string) : TFhirBasic;
    function ParseBasicChild(element : TFhirBasic; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
    function ParseBinary(element : TMXmlElement; path : string) : TFhirBinary;
    function ParseBinaryChild(element : TFhirBinary; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BODYSITE}
    function ParseBodySite(element : TMXmlElement; path : string) : TFhirBodySite;
    function ParseBodySiteChild(element : TFhirBodySite; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_BODYSITE}
{$IFDEF FHIR_BUNDLE}
    function ParseBundleLink(element : TMXmlElement; path : string) : TFhirBundleLink;
    function ParseBundleLinkChild(element : TFhirBundleLink; path : string; child : TMXmlElement) : boolean;
    function ParseBundleEntry(element : TMXmlElement; path : string) : TFhirBundleEntry;
    function ParseBundleEntryChild(element : TFhirBundleEntry; path : string; child : TMXmlElement) : boolean;
    function ParseBundleEntrySearch(element : TMXmlElement; path : string) : TFhirBundleEntrySearch;
    function ParseBundleEntrySearchChild(element : TFhirBundleEntrySearch; path : string; child : TMXmlElement) : boolean;
    function ParseBundleEntryRequest(element : TMXmlElement; path : string) : TFhirBundleEntryRequest;
    function ParseBundleEntryRequestChild(element : TFhirBundleEntryRequest; path : string; child : TMXmlElement) : boolean;
    function ParseBundleEntryResponse(element : TMXmlElement; path : string) : TFhirBundleEntryResponse;
    function ParseBundleEntryResponseChild(element : TFhirBundleEntryResponse; path : string; child : TMXmlElement) : boolean;
    function ParseBundle(element : TMXmlElement; path : string) : TFhirBundle;
    function ParseBundleChild(element : TFhirBundle; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAREPLAN}
    function ParseCarePlanRelatedPlan(element : TMXmlElement; path : string) : TFhirCarePlanRelatedPlan;
    function ParseCarePlanRelatedPlanChild(element : TFhirCarePlanRelatedPlan; path : string; child : TMXmlElement) : boolean;
    function ParseCarePlanParticipant(element : TMXmlElement; path : string) : TFhirCarePlanParticipant;
    function ParseCarePlanParticipantChild(element : TFhirCarePlanParticipant; path : string; child : TMXmlElement) : boolean;
    function ParseCarePlanActivity(element : TMXmlElement; path : string) : TFhirCarePlanActivity;
    function ParseCarePlanActivityChild(element : TFhirCarePlanActivity; path : string; child : TMXmlElement) : boolean;
    function ParseCarePlanActivityDetail(element : TMXmlElement; path : string) : TFhirCarePlanActivityDetail;
    function ParseCarePlanActivityDetailChild(element : TFhirCarePlanActivityDetail; path : string; child : TMXmlElement) : boolean;
    function ParseCarePlan(element : TMXmlElement; path : string) : TFhirCarePlan;
    function ParseCarePlanChild(element : TFhirCarePlan; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CLAIM}
    function ParseClaimPayee(element : TMXmlElement; path : string) : TFhirClaimPayee;
    function ParseClaimPayeeChild(element : TFhirClaimPayee; path : string; child : TMXmlElement) : boolean;
    function ParseClaimDiagnosis(element : TMXmlElement; path : string) : TFhirClaimDiagnosis;
    function ParseClaimDiagnosisChild(element : TFhirClaimDiagnosis; path : string; child : TMXmlElement) : boolean;
    function ParseClaimCoverage(element : TMXmlElement; path : string) : TFhirClaimCoverage;
    function ParseClaimCoverageChild(element : TFhirClaimCoverage; path : string; child : TMXmlElement) : boolean;
    function ParseClaimItem(element : TMXmlElement; path : string) : TFhirClaimItem;
    function ParseClaimItemChild(element : TFhirClaimItem; path : string; child : TMXmlElement) : boolean;
    function ParseClaimItemDetail(element : TMXmlElement; path : string) : TFhirClaimItemDetail;
    function ParseClaimItemDetailChild(element : TFhirClaimItemDetail; path : string; child : TMXmlElement) : boolean;
    function ParseClaimItemDetailSubDetail(element : TMXmlElement; path : string) : TFhirClaimItemDetailSubDetail;
    function ParseClaimItemDetailSubDetailChild(element : TFhirClaimItemDetailSubDetail; path : string; child : TMXmlElement) : boolean;
    function ParseClaimItemProsthesis(element : TMXmlElement; path : string) : TFhirClaimItemProsthesis;
    function ParseClaimItemProsthesisChild(element : TFhirClaimItemProsthesis; path : string; child : TMXmlElement) : boolean;
    function ParseClaimMissingTeeth(element : TMXmlElement; path : string) : TFhirClaimMissingTeeth;
    function ParseClaimMissingTeethChild(element : TFhirClaimMissingTeeth; path : string; child : TMXmlElement) : boolean;
    function ParseClaim(element : TMXmlElement; path : string) : TFhirClaim;
    function ParseClaimChild(element : TFhirClaim; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
    function ParseClaimResponseItem(element : TMXmlElement; path : string) : TFhirClaimResponseItem;
    function ParseClaimResponseItemChild(element : TFhirClaimResponseItem; path : string; child : TMXmlElement) : boolean;
    function ParseClaimResponseItemAdjudication(element : TMXmlElement; path : string) : TFhirClaimResponseItemAdjudication;
    function ParseClaimResponseItemAdjudicationChild(element : TFhirClaimResponseItemAdjudication; path : string; child : TMXmlElement) : boolean;
    function ParseClaimResponseItemDetail(element : TMXmlElement; path : string) : TFhirClaimResponseItemDetail;
    function ParseClaimResponseItemDetailChild(element : TFhirClaimResponseItemDetail; path : string; child : TMXmlElement) : boolean;
    function ParseClaimResponseItemDetailAdjudication(element : TMXmlElement; path : string) : TFhirClaimResponseItemDetailAdjudication;
    function ParseClaimResponseItemDetailAdjudicationChild(element : TFhirClaimResponseItemDetailAdjudication; path : string; child : TMXmlElement) : boolean;
    function ParseClaimResponseItemDetailSubDetail(element : TMXmlElement; path : string) : TFhirClaimResponseItemDetailSubDetail;
    function ParseClaimResponseItemDetailSubDetailChild(element : TFhirClaimResponseItemDetailSubDetail; path : string; child : TMXmlElement) : boolean;
    function ParseClaimResponseItemDetailSubDetailAdjudication(element : TMXmlElement; path : string) : TFhirClaimResponseItemDetailSubDetailAdjudication;
    function ParseClaimResponseItemDetailSubDetailAdjudicationChild(element : TFhirClaimResponseItemDetailSubDetailAdjudication; path : string; child : TMXmlElement) : boolean;
    function ParseClaimResponseAddItem(element : TMXmlElement; path : string) : TFhirClaimResponseAddItem;
    function ParseClaimResponseAddItemChild(element : TFhirClaimResponseAddItem; path : string; child : TMXmlElement) : boolean;
    function ParseClaimResponseAddItemAdjudication(element : TMXmlElement; path : string) : TFhirClaimResponseAddItemAdjudication;
    function ParseClaimResponseAddItemAdjudicationChild(element : TFhirClaimResponseAddItemAdjudication; path : string; child : TMXmlElement) : boolean;
    function ParseClaimResponseAddItemDetail(element : TMXmlElement; path : string) : TFhirClaimResponseAddItemDetail;
    function ParseClaimResponseAddItemDetailChild(element : TFhirClaimResponseAddItemDetail; path : string; child : TMXmlElement) : boolean;
    function ParseClaimResponseAddItemDetailAdjudication(element : TMXmlElement; path : string) : TFhirClaimResponseAddItemDetailAdjudication;
    function ParseClaimResponseAddItemDetailAdjudicationChild(element : TFhirClaimResponseAddItemDetailAdjudication; path : string; child : TMXmlElement) : boolean;
    function ParseClaimResponseError(element : TMXmlElement; path : string) : TFhirClaimResponseError;
    function ParseClaimResponseErrorChild(element : TFhirClaimResponseError; path : string; child : TMXmlElement) : boolean;
    function ParseClaimResponseNote(element : TMXmlElement; path : string) : TFhirClaimResponseNote;
    function ParseClaimResponseNoteChild(element : TFhirClaimResponseNote; path : string; child : TMXmlElement) : boolean;
    function ParseClaimResponseCoverage(element : TMXmlElement; path : string) : TFhirClaimResponseCoverage;
    function ParseClaimResponseCoverageChild(element : TFhirClaimResponseCoverage; path : string; child : TMXmlElement) : boolean;
    function ParseClaimResponse(element : TMXmlElement; path : string) : TFhirClaimResponse;
    function ParseClaimResponseChild(element : TFhirClaimResponse; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
    function ParseClinicalImpressionInvestigations(element : TMXmlElement; path : string) : TFhirClinicalImpressionInvestigations;
    function ParseClinicalImpressionInvestigationsChild(element : TFhirClinicalImpressionInvestigations; path : string; child : TMXmlElement) : boolean;
    function ParseClinicalImpressionFinding(element : TMXmlElement; path : string) : TFhirClinicalImpressionFinding;
    function ParseClinicalImpressionFindingChild(element : TFhirClinicalImpressionFinding; path : string; child : TMXmlElement) : boolean;
    function ParseClinicalImpressionRuledOut(element : TMXmlElement; path : string) : TFhirClinicalImpressionRuledOut;
    function ParseClinicalImpressionRuledOutChild(element : TFhirClinicalImpressionRuledOut; path : string; child : TMXmlElement) : boolean;
    function ParseClinicalImpression(element : TMXmlElement; path : string) : TFhirClinicalImpression;
    function ParseClinicalImpressionChild(element : TFhirClinicalImpression; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_COMMUNICATION}
    function ParseCommunicationPayload(element : TMXmlElement; path : string) : TFhirCommunicationPayload;
    function ParseCommunicationPayloadChild(element : TFhirCommunicationPayload; path : string; child : TMXmlElement) : boolean;
    function ParseCommunication(element : TMXmlElement; path : string) : TFhirCommunication;
    function ParseCommunicationChild(element : TFhirCommunication; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
    function ParseCommunicationRequestPayload(element : TMXmlElement; path : string) : TFhirCommunicationRequestPayload;
    function ParseCommunicationRequestPayloadChild(element : TFhirCommunicationRequestPayload; path : string; child : TMXmlElement) : boolean;
    function ParseCommunicationRequest(element : TMXmlElement; path : string) : TFhirCommunicationRequest;
    function ParseCommunicationRequestChild(element : TFhirCommunicationRequest; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPOSITION}
    function ParseCompositionAttester(element : TMXmlElement; path : string) : TFhirCompositionAttester;
    function ParseCompositionAttesterChild(element : TFhirCompositionAttester; path : string; child : TMXmlElement) : boolean;
    function ParseCompositionEvent(element : TMXmlElement; path : string) : TFhirCompositionEvent;
    function ParseCompositionEventChild(element : TFhirCompositionEvent; path : string; child : TMXmlElement) : boolean;
    function ParseCompositionSection(element : TMXmlElement; path : string) : TFhirCompositionSection;
    function ParseCompositionSectionChild(element : TFhirCompositionSection; path : string; child : TMXmlElement) : boolean;
    function ParseComposition(element : TMXmlElement; path : string) : TFhirComposition;
    function ParseCompositionChild(element : TFhirComposition; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
    function ParseConceptMapContact(element : TMXmlElement; path : string) : TFhirConceptMapContact;
    function ParseConceptMapContactChild(element : TFhirConceptMapContact; path : string; child : TMXmlElement) : boolean;
    function ParseConceptMapElement(element : TMXmlElement; path : string) : TFhirConceptMapElement;
    function ParseConceptMapElementChild(element : TFhirConceptMapElement; path : string; child : TMXmlElement) : boolean;
    function ParseConceptMapElementTarget(element : TMXmlElement; path : string) : TFhirConceptMapElementTarget;
    function ParseConceptMapElementTargetChild(element : TFhirConceptMapElementTarget; path : string; child : TMXmlElement) : boolean;
    function ParseConceptMapElementTargetDependsOn(element : TMXmlElement; path : string) : TFhirConceptMapElementTargetDependsOn;
    function ParseConceptMapElementTargetDependsOnChild(element : TFhirConceptMapElementTargetDependsOn; path : string; child : TMXmlElement) : boolean;
    function ParseConceptMap(element : TMXmlElement; path : string) : TFhirConceptMap;
    function ParseConceptMapChild(element : TFhirConceptMap; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
    function ParseConditionStage(element : TMXmlElement; path : string) : TFhirConditionStage;
    function ParseConditionStageChild(element : TFhirConditionStage; path : string; child : TMXmlElement) : boolean;
    function ParseConditionEvidence(element : TMXmlElement; path : string) : TFhirConditionEvidence;
    function ParseConditionEvidenceChild(element : TFhirConditionEvidence; path : string; child : TMXmlElement) : boolean;
    function ParseCondition(element : TMXmlElement; path : string) : TFhirCondition;
    function ParseConditionChild(element : TFhirCondition; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONFORMANCE}
    function ParseConformanceContact(element : TMXmlElement; path : string) : TFhirConformanceContact;
    function ParseConformanceContactChild(element : TFhirConformanceContact; path : string; child : TMXmlElement) : boolean;
    function ParseConformanceSoftware(element : TMXmlElement; path : string) : TFhirConformanceSoftware;
    function ParseConformanceSoftwareChild(element : TFhirConformanceSoftware; path : string; child : TMXmlElement) : boolean;
    function ParseConformanceImplementation(element : TMXmlElement; path : string) : TFhirConformanceImplementation;
    function ParseConformanceImplementationChild(element : TFhirConformanceImplementation; path : string; child : TMXmlElement) : boolean;
    function ParseConformanceRest(element : TMXmlElement; path : string) : TFhirConformanceRest;
    function ParseConformanceRestChild(element : TFhirConformanceRest; path : string; child : TMXmlElement) : boolean;
    function ParseConformanceRestSecurity(element : TMXmlElement; path : string) : TFhirConformanceRestSecurity;
    function ParseConformanceRestSecurityChild(element : TFhirConformanceRestSecurity; path : string; child : TMXmlElement) : boolean;
    function ParseConformanceRestSecurityCertificate(element : TMXmlElement; path : string) : TFhirConformanceRestSecurityCertificate;
    function ParseConformanceRestSecurityCertificateChild(element : TFhirConformanceRestSecurityCertificate; path : string; child : TMXmlElement) : boolean;
    function ParseConformanceRestResource(element : TMXmlElement; path : string) : TFhirConformanceRestResource;
    function ParseConformanceRestResourceChild(element : TFhirConformanceRestResource; path : string; child : TMXmlElement) : boolean;
    function ParseConformanceRestResourceInteraction(element : TMXmlElement; path : string) : TFhirConformanceRestResourceInteraction;
    function ParseConformanceRestResourceInteractionChild(element : TFhirConformanceRestResourceInteraction; path : string; child : TMXmlElement) : boolean;
    function ParseConformanceRestResourceSearchParam(element : TMXmlElement; path : string) : TFhirConformanceRestResourceSearchParam;
    function ParseConformanceRestResourceSearchParamChild(element : TFhirConformanceRestResourceSearchParam; path : string; child : TMXmlElement) : boolean;
    function ParseConformanceRestInteraction(element : TMXmlElement; path : string) : TFhirConformanceRestInteraction;
    function ParseConformanceRestInteractionChild(element : TFhirConformanceRestInteraction; path : string; child : TMXmlElement) : boolean;
    function ParseConformanceRestOperation(element : TMXmlElement; path : string) : TFhirConformanceRestOperation;
    function ParseConformanceRestOperationChild(element : TFhirConformanceRestOperation; path : string; child : TMXmlElement) : boolean;
    function ParseConformanceMessaging(element : TMXmlElement; path : string) : TFhirConformanceMessaging;
    function ParseConformanceMessagingChild(element : TFhirConformanceMessaging; path : string; child : TMXmlElement) : boolean;
    function ParseConformanceMessagingEndpoint(element : TMXmlElement; path : string) : TFhirConformanceMessagingEndpoint;
    function ParseConformanceMessagingEndpointChild(element : TFhirConformanceMessagingEndpoint; path : string; child : TMXmlElement) : boolean;
    function ParseConformanceMessagingEvent(element : TMXmlElement; path : string) : TFhirConformanceMessagingEvent;
    function ParseConformanceMessagingEventChild(element : TFhirConformanceMessagingEvent; path : string; child : TMXmlElement) : boolean;
    function ParseConformanceDocument(element : TMXmlElement; path : string) : TFhirConformanceDocument;
    function ParseConformanceDocumentChild(element : TFhirConformanceDocument; path : string; child : TMXmlElement) : boolean;
    function ParseConformance(element : TMXmlElement; path : string) : TFhirConformance;
    function ParseConformanceChild(element : TFhirConformance; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_CONFORMANCE}
{$IFDEF FHIR_CONTRACT}
    function ParseContractActor(element : TMXmlElement; path : string) : TFhirContractActor;
    function ParseContractActorChild(element : TFhirContractActor; path : string; child : TMXmlElement) : boolean;
    function ParseContractValuedItem(element : TMXmlElement; path : string) : TFhirContractValuedItem;
    function ParseContractValuedItemChild(element : TFhirContractValuedItem; path : string; child : TMXmlElement) : boolean;
    function ParseContractSigner(element : TMXmlElement; path : string) : TFhirContractSigner;
    function ParseContractSignerChild(element : TFhirContractSigner; path : string; child : TMXmlElement) : boolean;
    function ParseContractTerm(element : TMXmlElement; path : string) : TFhirContractTerm;
    function ParseContractTermChild(element : TFhirContractTerm; path : string; child : TMXmlElement) : boolean;
    function ParseContractTermActor(element : TMXmlElement; path : string) : TFhirContractTermActor;
    function ParseContractTermActorChild(element : TFhirContractTermActor; path : string; child : TMXmlElement) : boolean;
    function ParseContractTermValuedItem(element : TMXmlElement; path : string) : TFhirContractTermValuedItem;
    function ParseContractTermValuedItemChild(element : TFhirContractTermValuedItem; path : string; child : TMXmlElement) : boolean;
    function ParseContractFriendly(element : TMXmlElement; path : string) : TFhirContractFriendly;
    function ParseContractFriendlyChild(element : TFhirContractFriendly; path : string; child : TMXmlElement) : boolean;
    function ParseContractLegal(element : TMXmlElement; path : string) : TFhirContractLegal;
    function ParseContractLegalChild(element : TFhirContractLegal; path : string; child : TMXmlElement) : boolean;
    function ParseContractRule(element : TMXmlElement; path : string) : TFhirContractRule;
    function ParseContractRuleChild(element : TFhirContractRule; path : string; child : TMXmlElement) : boolean;
    function ParseContract(element : TMXmlElement; path : string) : TFhirContract;
    function ParseContractChild(element : TFhirContract; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
    function ParseCoverage(element : TMXmlElement; path : string) : TFhirCoverage;
    function ParseCoverageChild(element : TFhirCoverage; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_DATAELEMENT}
    function ParseDataElementContact(element : TMXmlElement; path : string) : TFhirDataElementContact;
    function ParseDataElementContactChild(element : TFhirDataElementContact; path : string; child : TMXmlElement) : boolean;
    function ParseDataElementMapping(element : TMXmlElement; path : string) : TFhirDataElementMapping;
    function ParseDataElementMappingChild(element : TFhirDataElementMapping; path : string; child : TMXmlElement) : boolean;
    function ParseDataElement(element : TMXmlElement; path : string) : TFhirDataElement;
    function ParseDataElementChild(element : TFhirDataElement; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_DATAELEMENT}
{$IFDEF FHIR_DETECTEDISSUE}
    function ParseDetectedIssueMitigation(element : TMXmlElement; path : string) : TFhirDetectedIssueMitigation;
    function ParseDetectedIssueMitigationChild(element : TFhirDetectedIssueMitigation; path : string; child : TMXmlElement) : boolean;
    function ParseDetectedIssue(element : TMXmlElement; path : string) : TFhirDetectedIssue;
    function ParseDetectedIssueChild(element : TFhirDetectedIssue; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
    function ParseDevice(element : TMXmlElement; path : string) : TFhirDevice;
    function ParseDeviceChild(element : TFhirDevice; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICECOMPONENT}
    function ParseDeviceComponentProductionSpecification(element : TMXmlElement; path : string) : TFhirDeviceComponentProductionSpecification;
    function ParseDeviceComponentProductionSpecificationChild(element : TFhirDeviceComponentProductionSpecification; path : string; child : TMXmlElement) : boolean;
    function ParseDeviceComponent(element : TMXmlElement; path : string) : TFhirDeviceComponent;
    function ParseDeviceComponentChild(element : TFhirDeviceComponent; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_DEVICECOMPONENT}
{$IFDEF FHIR_DEVICEMETRIC}
    function ParseDeviceMetricCalibration(element : TMXmlElement; path : string) : TFhirDeviceMetricCalibration;
    function ParseDeviceMetricCalibrationChild(element : TFhirDeviceMetricCalibration; path : string; child : TMXmlElement) : boolean;
    function ParseDeviceMetric(element : TMXmlElement; path : string) : TFhirDeviceMetric;
    function ParseDeviceMetricChild(element : TFhirDeviceMetric; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEUSEREQUEST}
    function ParseDeviceUseRequest(element : TMXmlElement; path : string) : TFhirDeviceUseRequest;
    function ParseDeviceUseRequestChild(element : TFhirDeviceUseRequest; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_DEVICEUSEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
    function ParseDeviceUseStatement(element : TMXmlElement; path : string) : TFhirDeviceUseStatement;
    function ParseDeviceUseStatementChild(element : TFhirDeviceUseStatement; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICORDER}
    function ParseDiagnosticOrderEvent(element : TMXmlElement; path : string) : TFhirDiagnosticOrderEvent;
    function ParseDiagnosticOrderEventChild(element : TFhirDiagnosticOrderEvent; path : string; child : TMXmlElement) : boolean;
    function ParseDiagnosticOrderItem(element : TMXmlElement; path : string) : TFhirDiagnosticOrderItem;
    function ParseDiagnosticOrderItemChild(element : TFhirDiagnosticOrderItem; path : string; child : TMXmlElement) : boolean;
    function ParseDiagnosticOrder(element : TMXmlElement; path : string) : TFhirDiagnosticOrder;
    function ParseDiagnosticOrderChild(element : TFhirDiagnosticOrder; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_DIAGNOSTICORDER}
{$IFDEF FHIR_DIAGNOSTICREPORT}
    function ParseDiagnosticReportImage(element : TMXmlElement; path : string) : TFhirDiagnosticReportImage;
    function ParseDiagnosticReportImageChild(element : TFhirDiagnosticReportImage; path : string; child : TMXmlElement) : boolean;
    function ParseDiagnosticReport(element : TMXmlElement; path : string) : TFhirDiagnosticReport;
    function ParseDiagnosticReportChild(element : TFhirDiagnosticReport; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
    function ParseDocumentManifestContent(element : TMXmlElement; path : string) : TFhirDocumentManifestContent;
    function ParseDocumentManifestContentChild(element : TFhirDocumentManifestContent; path : string; child : TMXmlElement) : boolean;
    function ParseDocumentManifestRelated(element : TMXmlElement; path : string) : TFhirDocumentManifestRelated;
    function ParseDocumentManifestRelatedChild(element : TFhirDocumentManifestRelated; path : string; child : TMXmlElement) : boolean;
    function ParseDocumentManifest(element : TMXmlElement; path : string) : TFhirDocumentManifest;
    function ParseDocumentManifestChild(element : TFhirDocumentManifest; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
    function ParseDocumentReferenceRelatesTo(element : TMXmlElement; path : string) : TFhirDocumentReferenceRelatesTo;
    function ParseDocumentReferenceRelatesToChild(element : TFhirDocumentReferenceRelatesTo; path : string; child : TMXmlElement) : boolean;
    function ParseDocumentReferenceContent(element : TMXmlElement; path : string) : TFhirDocumentReferenceContent;
    function ParseDocumentReferenceContentChild(element : TFhirDocumentReferenceContent; path : string; child : TMXmlElement) : boolean;
    function ParseDocumentReferenceContext(element : TMXmlElement; path : string) : TFhirDocumentReferenceContext;
    function ParseDocumentReferenceContextChild(element : TFhirDocumentReferenceContext; path : string; child : TMXmlElement) : boolean;
    function ParseDocumentReferenceContextRelated(element : TMXmlElement; path : string) : TFhirDocumentReferenceContextRelated;
    function ParseDocumentReferenceContextRelatedChild(element : TFhirDocumentReferenceContextRelated; path : string; child : TMXmlElement) : boolean;
    function ParseDocumentReference(element : TMXmlElement; path : string) : TFhirDocumentReference;
    function ParseDocumentReferenceChild(element : TFhirDocumentReference; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ELIGIBILITYREQUEST}
    function ParseEligibilityRequest(element : TMXmlElement; path : string) : TFhirEligibilityRequest;
    function ParseEligibilityRequestChild(element : TFhirEligibilityRequest; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_ELIGIBILITYREQUEST}
{$IFDEF FHIR_ELIGIBILITYRESPONSE}
    function ParseEligibilityResponse(element : TMXmlElement; path : string) : TFhirEligibilityResponse;
    function ParseEligibilityResponseChild(element : TFhirEligibilityResponse; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_ELIGIBILITYRESPONSE}
{$IFDEF FHIR_ENCOUNTER}
    function ParseEncounterStatusHistory(element : TMXmlElement; path : string) : TFhirEncounterStatusHistory;
    function ParseEncounterStatusHistoryChild(element : TFhirEncounterStatusHistory; path : string; child : TMXmlElement) : boolean;
    function ParseEncounterParticipant(element : TMXmlElement; path : string) : TFhirEncounterParticipant;
    function ParseEncounterParticipantChild(element : TFhirEncounterParticipant; path : string; child : TMXmlElement) : boolean;
    function ParseEncounterHospitalization(element : TMXmlElement; path : string) : TFhirEncounterHospitalization;
    function ParseEncounterHospitalizationChild(element : TFhirEncounterHospitalization; path : string; child : TMXmlElement) : boolean;
    function ParseEncounterLocation(element : TMXmlElement; path : string) : TFhirEncounterLocation;
    function ParseEncounterLocationChild(element : TFhirEncounterLocation; path : string; child : TMXmlElement) : boolean;
    function ParseEncounter(element : TMXmlElement; path : string) : TFhirEncounter;
    function ParseEncounterChild(element : TFhirEncounter; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENROLLMENTREQUEST}
    function ParseEnrollmentRequest(element : TMXmlElement; path : string) : TFhirEnrollmentRequest;
    function ParseEnrollmentRequestChild(element : TFhirEnrollmentRequest; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
    function ParseEnrollmentResponse(element : TMXmlElement; path : string) : TFhirEnrollmentResponse;
    function ParseEnrollmentResponseChild(element : TFhirEnrollmentResponse; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
    function ParseEpisodeOfCareStatusHistory(element : TMXmlElement; path : string) : TFhirEpisodeOfCareStatusHistory;
    function ParseEpisodeOfCareStatusHistoryChild(element : TFhirEpisodeOfCareStatusHistory; path : string; child : TMXmlElement) : boolean;
    function ParseEpisodeOfCareCareTeam(element : TMXmlElement; path : string) : TFhirEpisodeOfCareCareTeam;
    function ParseEpisodeOfCareCareTeamChild(element : TFhirEpisodeOfCareCareTeam; path : string; child : TMXmlElement) : boolean;
    function ParseEpisodeOfCare(element : TMXmlElement; path : string) : TFhirEpisodeOfCare;
    function ParseEpisodeOfCareChild(element : TFhirEpisodeOfCare; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
    function ParseExplanationOfBenefit(element : TMXmlElement; path : string) : TFhirExplanationOfBenefit;
    function ParseExplanationOfBenefitChild(element : TFhirExplanationOfBenefit; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
    function ParseFamilyMemberHistoryCondition(element : TMXmlElement; path : string) : TFhirFamilyMemberHistoryCondition;
    function ParseFamilyMemberHistoryConditionChild(element : TFhirFamilyMemberHistoryCondition; path : string; child : TMXmlElement) : boolean;
    function ParseFamilyMemberHistory(element : TMXmlElement; path : string) : TFhirFamilyMemberHistory;
    function ParseFamilyMemberHistoryChild(element : TFhirFamilyMemberHistory; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
    function ParseFlag(element : TMXmlElement; path : string) : TFhirFlag;
    function ParseFlagChild(element : TFhirFlag; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
    function ParseGoalOutcome(element : TMXmlElement; path : string) : TFhirGoalOutcome;
    function ParseGoalOutcomeChild(element : TFhirGoalOutcome; path : string; child : TMXmlElement) : boolean;
    function ParseGoal(element : TMXmlElement; path : string) : TFhirGoal;
    function ParseGoalChild(element : TFhirGoal; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GROUP}
    function ParseGroupCharacteristic(element : TMXmlElement; path : string) : TFhirGroupCharacteristic;
    function ParseGroupCharacteristicChild(element : TFhirGroupCharacteristic; path : string; child : TMXmlElement) : boolean;
    function ParseGroupMember(element : TMXmlElement; path : string) : TFhirGroupMember;
    function ParseGroupMemberChild(element : TFhirGroupMember; path : string; child : TMXmlElement) : boolean;
    function ParseGroup(element : TMXmlElement; path : string) : TFhirGroup;
    function ParseGroupChild(element : TFhirGroup; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_HEALTHCARESERVICE}
    function ParseHealthcareServiceServiceType(element : TMXmlElement; path : string) : TFhirHealthcareServiceServiceType;
    function ParseHealthcareServiceServiceTypeChild(element : TFhirHealthcareServiceServiceType; path : string; child : TMXmlElement) : boolean;
    function ParseHealthcareServiceAvailableTime(element : TMXmlElement; path : string) : TFhirHealthcareServiceAvailableTime;
    function ParseHealthcareServiceAvailableTimeChild(element : TFhirHealthcareServiceAvailableTime; path : string; child : TMXmlElement) : boolean;
    function ParseHealthcareServiceNotAvailable(element : TMXmlElement; path : string) : TFhirHealthcareServiceNotAvailable;
    function ParseHealthcareServiceNotAvailableChild(element : TFhirHealthcareServiceNotAvailable; path : string; child : TMXmlElement) : boolean;
    function ParseHealthcareService(element : TMXmlElement; path : string) : TFhirHealthcareService;
    function ParseHealthcareServiceChild(element : TFhirHealthcareService; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGOBJECTSELECTION}
    function ParseImagingObjectSelectionStudy(element : TMXmlElement; path : string) : TFhirImagingObjectSelectionStudy;
    function ParseImagingObjectSelectionStudyChild(element : TFhirImagingObjectSelectionStudy; path : string; child : TMXmlElement) : boolean;
    function ParseImagingObjectSelectionStudySeries(element : TMXmlElement; path : string) : TFhirImagingObjectSelectionStudySeries;
    function ParseImagingObjectSelectionStudySeriesChild(element : TFhirImagingObjectSelectionStudySeries; path : string; child : TMXmlElement) : boolean;
    function ParseImagingObjectSelectionStudySeriesInstance(element : TMXmlElement; path : string) : TFhirImagingObjectSelectionStudySeriesInstance;
    function ParseImagingObjectSelectionStudySeriesInstanceChild(element : TFhirImagingObjectSelectionStudySeriesInstance; path : string; child : TMXmlElement) : boolean;
    function ParseImagingObjectSelectionStudySeriesInstanceFrames(element : TMXmlElement; path : string) : TFhirImagingObjectSelectionStudySeriesInstanceFrames;
    function ParseImagingObjectSelectionStudySeriesInstanceFramesChild(element : TFhirImagingObjectSelectionStudySeriesInstanceFrames; path : string; child : TMXmlElement) : boolean;
    function ParseImagingObjectSelection(element : TMXmlElement; path : string) : TFhirImagingObjectSelection;
    function ParseImagingObjectSelectionChild(element : TFhirImagingObjectSelection; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_IMAGINGOBJECTSELECTION}
{$IFDEF FHIR_IMAGINGSTUDY}
    function ParseImagingStudySeries(element : TMXmlElement; path : string) : TFhirImagingStudySeries;
    function ParseImagingStudySeriesChild(element : TFhirImagingStudySeries; path : string; child : TMXmlElement) : boolean;
    function ParseImagingStudySeriesInstance(element : TMXmlElement; path : string) : TFhirImagingStudySeriesInstance;
    function ParseImagingStudySeriesInstanceChild(element : TFhirImagingStudySeriesInstance; path : string; child : TMXmlElement) : boolean;
    function ParseImagingStudy(element : TMXmlElement; path : string) : TFhirImagingStudy;
    function ParseImagingStudyChild(element : TFhirImagingStudy; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
    function ParseImmunizationExplanation(element : TMXmlElement; path : string) : TFhirImmunizationExplanation;
    function ParseImmunizationExplanationChild(element : TFhirImmunizationExplanation; path : string; child : TMXmlElement) : boolean;
    function ParseImmunizationReaction(element : TMXmlElement; path : string) : TFhirImmunizationReaction;
    function ParseImmunizationReactionChild(element : TFhirImmunizationReaction; path : string; child : TMXmlElement) : boolean;
    function ParseImmunizationVaccinationProtocol(element : TMXmlElement; path : string) : TFhirImmunizationVaccinationProtocol;
    function ParseImmunizationVaccinationProtocolChild(element : TFhirImmunizationVaccinationProtocol; path : string; child : TMXmlElement) : boolean;
    function ParseImmunization(element : TMXmlElement; path : string) : TFhirImmunization;
    function ParseImmunizationChild(element : TFhirImmunization; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
    function ParseImmunizationRecommendationRecommendation(element : TMXmlElement; path : string) : TFhirImmunizationRecommendationRecommendation;
    function ParseImmunizationRecommendationRecommendationChild(element : TFhirImmunizationRecommendationRecommendation; path : string; child : TMXmlElement) : boolean;
    function ParseImmunizationRecommendationRecommendationDateCriterion(element : TMXmlElement; path : string) : TFhirImmunizationRecommendationRecommendationDateCriterion;
    function ParseImmunizationRecommendationRecommendationDateCriterionChild(element : TFhirImmunizationRecommendationRecommendationDateCriterion; path : string; child : TMXmlElement) : boolean;
    function ParseImmunizationRecommendationRecommendationProtocol(element : TMXmlElement; path : string) : TFhirImmunizationRecommendationRecommendationProtocol;
    function ParseImmunizationRecommendationRecommendationProtocolChild(element : TFhirImmunizationRecommendationRecommendationProtocol; path : string; child : TMXmlElement) : boolean;
    function ParseImmunizationRecommendation(element : TMXmlElement; path : string) : TFhirImmunizationRecommendation;
    function ParseImmunizationRecommendationChild(element : TFhirImmunizationRecommendation; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
    function ParseImplementationGuideContact(element : TMXmlElement; path : string) : TFhirImplementationGuideContact;
    function ParseImplementationGuideContactChild(element : TFhirImplementationGuideContact; path : string; child : TMXmlElement) : boolean;
    function ParseImplementationGuideDependency(element : TMXmlElement; path : string) : TFhirImplementationGuideDependency;
    function ParseImplementationGuideDependencyChild(element : TFhirImplementationGuideDependency; path : string; child : TMXmlElement) : boolean;
    function ParseImplementationGuidePackage(element : TMXmlElement; path : string) : TFhirImplementationGuidePackage;
    function ParseImplementationGuidePackageChild(element : TFhirImplementationGuidePackage; path : string; child : TMXmlElement) : boolean;
    function ParseImplementationGuidePackageResource(element : TMXmlElement; path : string) : TFhirImplementationGuidePackageResource;
    function ParseImplementationGuidePackageResourceChild(element : TFhirImplementationGuidePackageResource; path : string; child : TMXmlElement) : boolean;
    function ParseImplementationGuideGlobal(element : TMXmlElement; path : string) : TFhirImplementationGuideGlobal;
    function ParseImplementationGuideGlobalChild(element : TFhirImplementationGuideGlobal; path : string; child : TMXmlElement) : boolean;
    function ParseImplementationGuidePage(element : TMXmlElement; path : string) : TFhirImplementationGuidePage;
    function ParseImplementationGuidePageChild(element : TFhirImplementationGuidePage; path : string; child : TMXmlElement) : boolean;
    function ParseImplementationGuide(element : TMXmlElement; path : string) : TFhirImplementationGuide;
    function ParseImplementationGuideChild(element : TFhirImplementationGuide; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_LIST}
    function ParseListEntry(element : TMXmlElement; path : string) : TFhirListEntry;
    function ParseListEntryChild(element : TFhirListEntry; path : string; child : TMXmlElement) : boolean;
    function ParseList(element : TMXmlElement; path : string) : TFhirList;
    function ParseListChild(element : TFhirList; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
    function ParseLocationPosition(element : TMXmlElement; path : string) : TFhirLocationPosition;
    function ParseLocationPositionChild(element : TFhirLocationPosition; path : string; child : TMXmlElement) : boolean;
    function ParseLocation(element : TMXmlElement; path : string) : TFhirLocation;
    function ParseLocationChild(element : TFhirLocation; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEDIA}
    function ParseMedia(element : TMXmlElement; path : string) : TFhirMedia;
    function ParseMediaChild(element : TFhirMedia; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
    function ParseMedicationProduct(element : TMXmlElement; path : string) : TFhirMedicationProduct;
    function ParseMedicationProductChild(element : TFhirMedicationProduct; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationProductIngredient(element : TMXmlElement; path : string) : TFhirMedicationProductIngredient;
    function ParseMedicationProductIngredientChild(element : TFhirMedicationProductIngredient; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationProductBatch(element : TMXmlElement; path : string) : TFhirMedicationProductBatch;
    function ParseMedicationProductBatchChild(element : TFhirMedicationProductBatch; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationPackage(element : TMXmlElement; path : string) : TFhirMedicationPackage;
    function ParseMedicationPackageChild(element : TFhirMedicationPackage; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationPackageContent(element : TMXmlElement; path : string) : TFhirMedicationPackageContent;
    function ParseMedicationPackageContentChild(element : TFhirMedicationPackageContent; path : string; child : TMXmlElement) : boolean;
    function ParseMedication(element : TMXmlElement; path : string) : TFhirMedication;
    function ParseMedicationChild(element : TFhirMedication; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
    function ParseMedicationAdministrationDosage(element : TMXmlElement; path : string) : TFhirMedicationAdministrationDosage;
    function ParseMedicationAdministrationDosageChild(element : TFhirMedicationAdministrationDosage; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationAdministration(element : TMXmlElement; path : string) : TFhirMedicationAdministration;
    function ParseMedicationAdministrationChild(element : TFhirMedicationAdministration; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
    function ParseMedicationDispenseDosageInstruction(element : TMXmlElement; path : string) : TFhirMedicationDispenseDosageInstruction;
    function ParseMedicationDispenseDosageInstructionChild(element : TFhirMedicationDispenseDosageInstruction; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationDispenseSubstitution(element : TMXmlElement; path : string) : TFhirMedicationDispenseSubstitution;
    function ParseMedicationDispenseSubstitutionChild(element : TFhirMedicationDispenseSubstitution; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationDispense(element : TMXmlElement; path : string) : TFhirMedicationDispense;
    function ParseMedicationDispenseChild(element : TFhirMedicationDispense; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONORDER}
    function ParseMedicationOrderDosageInstruction(element : TMXmlElement; path : string) : TFhirMedicationOrderDosageInstruction;
    function ParseMedicationOrderDosageInstructionChild(element : TFhirMedicationOrderDosageInstruction; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationOrderDispenseRequest(element : TMXmlElement; path : string) : TFhirMedicationOrderDispenseRequest;
    function ParseMedicationOrderDispenseRequestChild(element : TFhirMedicationOrderDispenseRequest; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationOrderSubstitution(element : TMXmlElement; path : string) : TFhirMedicationOrderSubstitution;
    function ParseMedicationOrderSubstitutionChild(element : TFhirMedicationOrderSubstitution; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationOrder(element : TMXmlElement; path : string) : TFhirMedicationOrder;
    function ParseMedicationOrderChild(element : TFhirMedicationOrder; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_MEDICATIONORDER}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
    function ParseMedicationStatementDosage(element : TMXmlElement; path : string) : TFhirMedicationStatementDosage;
    function ParseMedicationStatementDosageChild(element : TFhirMedicationStatementDosage; path : string; child : TMXmlElement) : boolean;
    function ParseMedicationStatement(element : TMXmlElement; path : string) : TFhirMedicationStatement;
    function ParseMedicationStatementChild(element : TFhirMedicationStatement; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MESSAGEHEADER}
    function ParseMessageHeaderResponse(element : TMXmlElement; path : string) : TFhirMessageHeaderResponse;
    function ParseMessageHeaderResponseChild(element : TFhirMessageHeaderResponse; path : string; child : TMXmlElement) : boolean;
    function ParseMessageHeaderSource(element : TMXmlElement; path : string) : TFhirMessageHeaderSource;
    function ParseMessageHeaderSourceChild(element : TFhirMessageHeaderSource; path : string; child : TMXmlElement) : boolean;
    function ParseMessageHeaderDestination(element : TMXmlElement; path : string) : TFhirMessageHeaderDestination;
    function ParseMessageHeaderDestinationChild(element : TFhirMessageHeaderDestination; path : string; child : TMXmlElement) : boolean;
    function ParseMessageHeader(element : TMXmlElement; path : string) : TFhirMessageHeader;
    function ParseMessageHeaderChild(element : TFhirMessageHeader; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_NAMINGSYSTEM}
    function ParseNamingSystemContact(element : TMXmlElement; path : string) : TFhirNamingSystemContact;
    function ParseNamingSystemContactChild(element : TFhirNamingSystemContact; path : string; child : TMXmlElement) : boolean;
    function ParseNamingSystemUniqueId(element : TMXmlElement; path : string) : TFhirNamingSystemUniqueId;
    function ParseNamingSystemUniqueIdChild(element : TFhirNamingSystemUniqueId; path : string; child : TMXmlElement) : boolean;
    function ParseNamingSystem(element : TMXmlElement; path : string) : TFhirNamingSystem;
    function ParseNamingSystemChild(element : TFhirNamingSystem; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
    function ParseNutritionOrderOralDiet(element : TMXmlElement; path : string) : TFhirNutritionOrderOralDiet;
    function ParseNutritionOrderOralDietChild(element : TFhirNutritionOrderOralDiet; path : string; child : TMXmlElement) : boolean;
    function ParseNutritionOrderOralDietNutrient(element : TMXmlElement; path : string) : TFhirNutritionOrderOralDietNutrient;
    function ParseNutritionOrderOralDietNutrientChild(element : TFhirNutritionOrderOralDietNutrient; path : string; child : TMXmlElement) : boolean;
    function ParseNutritionOrderOralDietTexture(element : TMXmlElement; path : string) : TFhirNutritionOrderOralDietTexture;
    function ParseNutritionOrderOralDietTextureChild(element : TFhirNutritionOrderOralDietTexture; path : string; child : TMXmlElement) : boolean;
    function ParseNutritionOrderSupplement(element : TMXmlElement; path : string) : TFhirNutritionOrderSupplement;
    function ParseNutritionOrderSupplementChild(element : TFhirNutritionOrderSupplement; path : string; child : TMXmlElement) : boolean;
    function ParseNutritionOrderEnteralFormula(element : TMXmlElement; path : string) : TFhirNutritionOrderEnteralFormula;
    function ParseNutritionOrderEnteralFormulaChild(element : TFhirNutritionOrderEnteralFormula; path : string; child : TMXmlElement) : boolean;
    function ParseNutritionOrderEnteralFormulaAdministration(element : TMXmlElement; path : string) : TFhirNutritionOrderEnteralFormulaAdministration;
    function ParseNutritionOrderEnteralFormulaAdministrationChild(element : TFhirNutritionOrderEnteralFormulaAdministration; path : string; child : TMXmlElement) : boolean;
    function ParseNutritionOrder(element : TMXmlElement; path : string) : TFhirNutritionOrder;
    function ParseNutritionOrderChild(element : TFhirNutritionOrder; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
    function ParseObservationReferenceRange(element : TMXmlElement; path : string) : TFhirObservationReferenceRange;
    function ParseObservationReferenceRangeChild(element : TFhirObservationReferenceRange; path : string; child : TMXmlElement) : boolean;
    function ParseObservationRelated(element : TMXmlElement; path : string) : TFhirObservationRelated;
    function ParseObservationRelatedChild(element : TFhirObservationRelated; path : string; child : TMXmlElement) : boolean;
    function ParseObservationComponent(element : TMXmlElement; path : string) : TFhirObservationComponent;
    function ParseObservationComponentChild(element : TFhirObservationComponent; path : string; child : TMXmlElement) : boolean;
    function ParseObservation(element : TMXmlElement; path : string) : TFhirObservation;
    function ParseObservationChild(element : TFhirObservation; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OPERATIONDEFINITION}
    function ParseOperationDefinitionContact(element : TMXmlElement; path : string) : TFhirOperationDefinitionContact;
    function ParseOperationDefinitionContactChild(element : TFhirOperationDefinitionContact; path : string; child : TMXmlElement) : boolean;
    function ParseOperationDefinitionParameter(element : TMXmlElement; path : string) : TFhirOperationDefinitionParameter;
    function ParseOperationDefinitionParameterChild(element : TFhirOperationDefinitionParameter; path : string; child : TMXmlElement) : boolean;
    function ParseOperationDefinitionParameterBinding(element : TMXmlElement; path : string) : TFhirOperationDefinitionParameterBinding;
    function ParseOperationDefinitionParameterBindingChild(element : TFhirOperationDefinitionParameterBinding; path : string; child : TMXmlElement) : boolean;
    function ParseOperationDefinition(element : TMXmlElement; path : string) : TFhirOperationDefinition;
    function ParseOperationDefinitionChild(element : TFhirOperationDefinition; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
    function ParseOperationOutcomeIssue(element : TMXmlElement; path : string) : TFhirOperationOutcomeIssue;
    function ParseOperationOutcomeIssueChild(element : TFhirOperationOutcomeIssue; path : string; child : TMXmlElement) : boolean;
    function ParseOperationOutcome(element : TMXmlElement; path : string) : TFhirOperationOutcome;
    function ParseOperationOutcomeChild(element : TFhirOperationOutcome; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORDER}
    function ParseOrderWhen(element : TMXmlElement; path : string) : TFhirOrderWhen;
    function ParseOrderWhenChild(element : TFhirOrderWhen; path : string; child : TMXmlElement) : boolean;
    function ParseOrder(element : TMXmlElement; path : string) : TFhirOrder;
    function ParseOrderChild(element : TFhirOrder; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_ORDER}
{$IFDEF FHIR_ORDERRESPONSE}
    function ParseOrderResponse(element : TMXmlElement; path : string) : TFhirOrderResponse;
    function ParseOrderResponseChild(element : TFhirOrderResponse; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_ORDERRESPONSE}
{$IFDEF FHIR_ORGANIZATION}
    function ParseOrganizationContact(element : TMXmlElement; path : string) : TFhirOrganizationContact;
    function ParseOrganizationContactChild(element : TFhirOrganizationContact; path : string; child : TMXmlElement) : boolean;
    function ParseOrganization(element : TMXmlElement; path : string) : TFhirOrganization;
    function ParseOrganizationChild(element : TFhirOrganization; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_PATIENT}
    function ParsePatientContact(element : TMXmlElement; path : string) : TFhirPatientContact;
    function ParsePatientContactChild(element : TFhirPatientContact; path : string; child : TMXmlElement) : boolean;
    function ParsePatientAnimal(element : TMXmlElement; path : string) : TFhirPatientAnimal;
    function ParsePatientAnimalChild(element : TFhirPatientAnimal; path : string; child : TMXmlElement) : boolean;
    function ParsePatientCommunication(element : TMXmlElement; path : string) : TFhirPatientCommunication;
    function ParsePatientCommunicationChild(element : TFhirPatientCommunication; path : string; child : TMXmlElement) : boolean;
    function ParsePatientLink(element : TMXmlElement; path : string) : TFhirPatientLink;
    function ParsePatientLinkChild(element : TFhirPatientLink; path : string; child : TMXmlElement) : boolean;
    function ParsePatient(element : TMXmlElement; path : string) : TFhirPatient;
    function ParsePatientChild(element : TFhirPatient; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
    function ParsePaymentNotice(element : TMXmlElement; path : string) : TFhirPaymentNotice;
    function ParsePaymentNoticeChild(element : TFhirPaymentNotice; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
    function ParsePaymentReconciliationDetail(element : TMXmlElement; path : string) : TFhirPaymentReconciliationDetail;
    function ParsePaymentReconciliationDetailChild(element : TFhirPaymentReconciliationDetail; path : string; child : TMXmlElement) : boolean;
    function ParsePaymentReconciliationNote(element : TMXmlElement; path : string) : TFhirPaymentReconciliationNote;
    function ParsePaymentReconciliationNoteChild(element : TFhirPaymentReconciliationNote; path : string; child : TMXmlElement) : boolean;
    function ParsePaymentReconciliation(element : TMXmlElement; path : string) : TFhirPaymentReconciliation;
    function ParsePaymentReconciliationChild(element : TFhirPaymentReconciliation; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
    function ParsePersonLink(element : TMXmlElement; path : string) : TFhirPersonLink;
    function ParsePersonLinkChild(element : TFhirPersonLink; path : string; child : TMXmlElement) : boolean;
    function ParsePerson(element : TMXmlElement; path : string) : TFhirPerson;
    function ParsePersonChild(element : TFhirPerson; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PRACTITIONER}
    function ParsePractitionerPractitionerRole(element : TMXmlElement; path : string) : TFhirPractitionerPractitionerRole;
    function ParsePractitionerPractitionerRoleChild(element : TFhirPractitionerPractitionerRole; path : string; child : TMXmlElement) : boolean;
    function ParsePractitionerQualification(element : TMXmlElement; path : string) : TFhirPractitionerQualification;
    function ParsePractitionerQualificationChild(element : TFhirPractitionerQualification; path : string; child : TMXmlElement) : boolean;
    function ParsePractitioner(element : TMXmlElement; path : string) : TFhirPractitioner;
    function ParsePractitionerChild(element : TFhirPractitioner; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PROCEDURE}
    function ParseProcedurePerformer(element : TMXmlElement; path : string) : TFhirProcedurePerformer;
    function ParseProcedurePerformerChild(element : TFhirProcedurePerformer; path : string; child : TMXmlElement) : boolean;
    function ParseProcedureFocalDevice(element : TMXmlElement; path : string) : TFhirProcedureFocalDevice;
    function ParseProcedureFocalDeviceChild(element : TFhirProcedureFocalDevice; path : string; child : TMXmlElement) : boolean;
    function ParseProcedure(element : TMXmlElement; path : string) : TFhirProcedure;
    function ParseProcedureChild(element : TFhirProcedure; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROCEDUREREQUEST}
    function ParseProcedureRequest(element : TMXmlElement; path : string) : TFhirProcedureRequest;
    function ParseProcedureRequestChild(element : TFhirProcedureRequest; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_PROCEDUREREQUEST}
{$IFDEF FHIR_PROCESSREQUEST}
    function ParseProcessRequestItem(element : TMXmlElement; path : string) : TFhirProcessRequestItem;
    function ParseProcessRequestItemChild(element : TFhirProcessRequestItem; path : string; child : TMXmlElement) : boolean;
    function ParseProcessRequest(element : TMXmlElement; path : string) : TFhirProcessRequest;
    function ParseProcessRequestChild(element : TFhirProcessRequest; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_PROCESSREQUEST}
{$IFDEF FHIR_PROCESSRESPONSE}
    function ParseProcessResponseNotes(element : TMXmlElement; path : string) : TFhirProcessResponseNotes;
    function ParseProcessResponseNotesChild(element : TFhirProcessResponseNotes; path : string; child : TMXmlElement) : boolean;
    function ParseProcessResponse(element : TMXmlElement; path : string) : TFhirProcessResponse;
    function ParseProcessResponseChild(element : TFhirProcessResponse; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_PROCESSRESPONSE}
{$IFDEF FHIR_PROVENANCE}
    function ParseProvenanceAgent(element : TMXmlElement; path : string) : TFhirProvenanceAgent;
    function ParseProvenanceAgentChild(element : TFhirProvenanceAgent; path : string; child : TMXmlElement) : boolean;
    function ParseProvenanceAgentRelatedAgent(element : TMXmlElement; path : string) : TFhirProvenanceAgentRelatedAgent;
    function ParseProvenanceAgentRelatedAgentChild(element : TFhirProvenanceAgentRelatedAgent; path : string; child : TMXmlElement) : boolean;
    function ParseProvenanceEntity(element : TMXmlElement; path : string) : TFhirProvenanceEntity;
    function ParseProvenanceEntityChild(element : TFhirProvenanceEntity; path : string; child : TMXmlElement) : boolean;
    function ParseProvenance(element : TMXmlElement; path : string) : TFhirProvenance;
    function ParseProvenanceChild(element : TFhirProvenance; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
    function ParseQuestionnaireGroup(element : TMXmlElement; path : string) : TFhirQuestionnaireGroup;
    function ParseQuestionnaireGroupChild(element : TFhirQuestionnaireGroup; path : string; child : TMXmlElement) : boolean;
    function ParseQuestionnaireGroupQuestion(element : TMXmlElement; path : string) : TFhirQuestionnaireGroupQuestion;
    function ParseQuestionnaireGroupQuestionChild(element : TFhirQuestionnaireGroupQuestion; path : string; child : TMXmlElement) : boolean;
    function ParseQuestionnaire(element : TMXmlElement; path : string) : TFhirQuestionnaire;
    function ParseQuestionnaireChild(element : TFhirQuestionnaire; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
    function ParseQuestionnaireResponseGroup(element : TMXmlElement; path : string) : TFhirQuestionnaireResponseGroup;
    function ParseQuestionnaireResponseGroupChild(element : TFhirQuestionnaireResponseGroup; path : string; child : TMXmlElement) : boolean;
    function ParseQuestionnaireResponseGroupQuestion(element : TMXmlElement; path : string) : TFhirQuestionnaireResponseGroupQuestion;
    function ParseQuestionnaireResponseGroupQuestionChild(element : TFhirQuestionnaireResponseGroupQuestion; path : string; child : TMXmlElement) : boolean;
    function ParseQuestionnaireResponseGroupQuestionAnswer(element : TMXmlElement; path : string) : TFhirQuestionnaireResponseGroupQuestionAnswer;
    function ParseQuestionnaireResponseGroupQuestionAnswerChild(element : TFhirQuestionnaireResponseGroupQuestionAnswer; path : string; child : TMXmlElement) : boolean;
    function ParseQuestionnaireResponse(element : TMXmlElement; path : string) : TFhirQuestionnaireResponse;
    function ParseQuestionnaireResponseChild(element : TFhirQuestionnaireResponse; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REFERRALREQUEST}
    function ParseReferralRequest(element : TMXmlElement; path : string) : TFhirReferralRequest;
    function ParseReferralRequestChild(element : TFhirReferralRequest; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_REFERRALREQUEST}
{$IFDEF FHIR_RELATEDPERSON}
    function ParseRelatedPerson(element : TMXmlElement; path : string) : TFhirRelatedPerson;
    function ParseRelatedPersonChild(element : TFhirRelatedPerson; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_RISKASSESSMENT}
    function ParseRiskAssessmentPrediction(element : TMXmlElement; path : string) : TFhirRiskAssessmentPrediction;
    function ParseRiskAssessmentPredictionChild(element : TFhirRiskAssessmentPrediction; path : string; child : TMXmlElement) : boolean;
    function ParseRiskAssessment(element : TMXmlElement; path : string) : TFhirRiskAssessment;
    function ParseRiskAssessmentChild(element : TFhirRiskAssessment; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
    function ParseSchedule(element : TMXmlElement; path : string) : TFhirSchedule;
    function ParseScheduleChild(element : TFhirSchedule; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
    function ParseSearchParameterContact(element : TMXmlElement; path : string) : TFhirSearchParameterContact;
    function ParseSearchParameterContactChild(element : TFhirSearchParameterContact; path : string; child : TMXmlElement) : boolean;
    function ParseSearchParameter(element : TMXmlElement; path : string) : TFhirSearchParameter;
    function ParseSearchParameterChild(element : TFhirSearchParameter; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SLOT}
    function ParseSlot(element : TMXmlElement; path : string) : TFhirSlot;
    function ParseSlotChild(element : TFhirSlot; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
    function ParseSpecimenCollection(element : TMXmlElement; path : string) : TFhirSpecimenCollection;
    function ParseSpecimenCollectionChild(element : TFhirSpecimenCollection; path : string; child : TMXmlElement) : boolean;
    function ParseSpecimenTreatment(element : TMXmlElement; path : string) : TFhirSpecimenTreatment;
    function ParseSpecimenTreatmentChild(element : TFhirSpecimenTreatment; path : string; child : TMXmlElement) : boolean;
    function ParseSpecimenContainer(element : TMXmlElement; path : string) : TFhirSpecimenContainer;
    function ParseSpecimenContainerChild(element : TFhirSpecimenContainer; path : string; child : TMXmlElement) : boolean;
    function ParseSpecimen(element : TMXmlElement; path : string) : TFhirSpecimen;
    function ParseSpecimenChild(element : TFhirSpecimen; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_STRUCTUREDEFINITION}
    function ParseStructureDefinitionContact(element : TMXmlElement; path : string) : TFhirStructureDefinitionContact;
    function ParseStructureDefinitionContactChild(element : TFhirStructureDefinitionContact; path : string; child : TMXmlElement) : boolean;
    function ParseStructureDefinitionMapping(element : TMXmlElement; path : string) : TFhirStructureDefinitionMapping;
    function ParseStructureDefinitionMappingChild(element : TFhirStructureDefinitionMapping; path : string; child : TMXmlElement) : boolean;
    function ParseStructureDefinitionSnapshot(element : TMXmlElement; path : string) : TFhirStructureDefinitionSnapshot;
    function ParseStructureDefinitionSnapshotChild(element : TFhirStructureDefinitionSnapshot; path : string; child : TMXmlElement) : boolean;
    function ParseStructureDefinitionDifferential(element : TMXmlElement; path : string) : TFhirStructureDefinitionDifferential;
    function ParseStructureDefinitionDifferentialChild(element : TFhirStructureDefinitionDifferential; path : string; child : TMXmlElement) : boolean;
    function ParseStructureDefinition(element : TMXmlElement; path : string) : TFhirStructureDefinition;
    function ParseStructureDefinitionChild(element : TFhirStructureDefinition; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_SUBSCRIPTION}
    function ParseSubscriptionChannel(element : TMXmlElement; path : string) : TFhirSubscriptionChannel;
    function ParseSubscriptionChannelChild(element : TFhirSubscriptionChannel; path : string; child : TMXmlElement) : boolean;
    function ParseSubscription(element : TMXmlElement; path : string) : TFhirSubscription;
    function ParseSubscriptionChild(element : TFhirSubscription; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
    function ParseSubstanceInstance(element : TMXmlElement; path : string) : TFhirSubstanceInstance;
    function ParseSubstanceInstanceChild(element : TFhirSubstanceInstance; path : string; child : TMXmlElement) : boolean;
    function ParseSubstanceIngredient(element : TMXmlElement; path : string) : TFhirSubstanceIngredient;
    function ParseSubstanceIngredientChild(element : TFhirSubstanceIngredient; path : string; child : TMXmlElement) : boolean;
    function ParseSubstance(element : TMXmlElement; path : string) : TFhirSubstance;
    function ParseSubstanceChild(element : TFhirSubstance; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUPPLYDELIVERY}
    function ParseSupplyDelivery(element : TMXmlElement; path : string) : TFhirSupplyDelivery;
    function ParseSupplyDeliveryChild(element : TFhirSupplyDelivery; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
    function ParseSupplyRequestWhen(element : TMXmlElement; path : string) : TFhirSupplyRequestWhen;
    function ParseSupplyRequestWhenChild(element : TFhirSupplyRequestWhen; path : string; child : TMXmlElement) : boolean;
    function ParseSupplyRequest(element : TMXmlElement; path : string) : TFhirSupplyRequest;
    function ParseSupplyRequestChild(element : TFhirSupplyRequest; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TESTSCRIPT}
    function ParseTestScriptContact(element : TMXmlElement; path : string) : TFhirTestScriptContact;
    function ParseTestScriptContactChild(element : TFhirTestScriptContact; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptMetadata(element : TMXmlElement; path : string) : TFhirTestScriptMetadata;
    function ParseTestScriptMetadataChild(element : TFhirTestScriptMetadata; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptMetadataLink(element : TMXmlElement; path : string) : TFhirTestScriptMetadataLink;
    function ParseTestScriptMetadataLinkChild(element : TFhirTestScriptMetadataLink; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptMetadataCapability(element : TMXmlElement; path : string) : TFhirTestScriptMetadataCapability;
    function ParseTestScriptMetadataCapabilityChild(element : TFhirTestScriptMetadataCapability; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptFixture(element : TMXmlElement; path : string) : TFhirTestScriptFixture;
    function ParseTestScriptFixtureChild(element : TFhirTestScriptFixture; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptVariable(element : TMXmlElement; path : string) : TFhirTestScriptVariable;
    function ParseTestScriptVariableChild(element : TFhirTestScriptVariable; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptSetup(element : TMXmlElement; path : string) : TFhirTestScriptSetup;
    function ParseTestScriptSetupChild(element : TFhirTestScriptSetup; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptSetupAction(element : TMXmlElement; path : string) : TFhirTestScriptSetupAction;
    function ParseTestScriptSetupActionChild(element : TFhirTestScriptSetupAction; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptSetupActionOperation(element : TMXmlElement; path : string) : TFhirTestScriptSetupActionOperation;
    function ParseTestScriptSetupActionOperationChild(element : TFhirTestScriptSetupActionOperation; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptSetupActionOperationRequestHeader(element : TMXmlElement; path : string) : TFhirTestScriptSetupActionOperationRequestHeader;
    function ParseTestScriptSetupActionOperationRequestHeaderChild(element : TFhirTestScriptSetupActionOperationRequestHeader; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptSetupActionAssert(element : TMXmlElement; path : string) : TFhirTestScriptSetupActionAssert;
    function ParseTestScriptSetupActionAssertChild(element : TFhirTestScriptSetupActionAssert; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptTest(element : TMXmlElement; path : string) : TFhirTestScriptTest;
    function ParseTestScriptTestChild(element : TFhirTestScriptTest; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptTestAction(element : TMXmlElement; path : string) : TFhirTestScriptTestAction;
    function ParseTestScriptTestActionChild(element : TFhirTestScriptTestAction; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptTeardown(element : TMXmlElement; path : string) : TFhirTestScriptTeardown;
    function ParseTestScriptTeardownChild(element : TFhirTestScriptTeardown; path : string; child : TMXmlElement) : boolean;
    function ParseTestScriptTeardownAction(element : TMXmlElement; path : string) : TFhirTestScriptTeardownAction;
    function ParseTestScriptTeardownActionChild(element : TFhirTestScriptTeardownAction; path : string; child : TMXmlElement) : boolean;
    function ParseTestScript(element : TMXmlElement; path : string) : TFhirTestScript;
    function ParseTestScriptChild(element : TFhirTestScript; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
    function ParseValueSetContact(element : TMXmlElement; path : string) : TFhirValueSetContact;
    function ParseValueSetContactChild(element : TFhirValueSetContact; path : string; child : TMXmlElement) : boolean;
    function ParseValueSetCodeSystem(element : TMXmlElement; path : string) : TFhirValueSetCodeSystem;
    function ParseValueSetCodeSystemChild(element : TFhirValueSetCodeSystem; path : string; child : TMXmlElement) : boolean;
    function ParseValueSetCodeSystemConcept(element : TMXmlElement; path : string) : TFhirValueSetCodeSystemConcept;
    function ParseValueSetCodeSystemConceptChild(element : TFhirValueSetCodeSystemConcept; path : string; child : TMXmlElement) : boolean;
    function ParseValueSetCodeSystemConceptDesignation(element : TMXmlElement; path : string) : TFhirValueSetCodeSystemConceptDesignation;
    function ParseValueSetCodeSystemConceptDesignationChild(element : TFhirValueSetCodeSystemConceptDesignation; path : string; child : TMXmlElement) : boolean;
    function ParseValueSetCompose(element : TMXmlElement; path : string) : TFhirValueSetCompose;
    function ParseValueSetComposeChild(element : TFhirValueSetCompose; path : string; child : TMXmlElement) : boolean;
    function ParseValueSetComposeInclude(element : TMXmlElement; path : string) : TFhirValueSetComposeInclude;
    function ParseValueSetComposeIncludeChild(element : TFhirValueSetComposeInclude; path : string; child : TMXmlElement) : boolean;
    function ParseValueSetComposeIncludeConcept(element : TMXmlElement; path : string) : TFhirValueSetComposeIncludeConcept;
    function ParseValueSetComposeIncludeConceptChild(element : TFhirValueSetComposeIncludeConcept; path : string; child : TMXmlElement) : boolean;
    function ParseValueSetComposeIncludeFilter(element : TMXmlElement; path : string) : TFhirValueSetComposeIncludeFilter;
    function ParseValueSetComposeIncludeFilterChild(element : TFhirValueSetComposeIncludeFilter; path : string; child : TMXmlElement) : boolean;
    function ParseValueSetExpansion(element : TMXmlElement; path : string) : TFhirValueSetExpansion;
    function ParseValueSetExpansionChild(element : TFhirValueSetExpansion; path : string; child : TMXmlElement) : boolean;
    function ParseValueSetExpansionParameter(element : TMXmlElement; path : string) : TFhirValueSetExpansionParameter;
    function ParseValueSetExpansionParameterChild(element : TFhirValueSetExpansionParameter; path : string; child : TMXmlElement) : boolean;
    function ParseValueSetExpansionContains(element : TMXmlElement; path : string) : TFhirValueSetExpansionContains;
    function ParseValueSetExpansionContainsChild(element : TFhirValueSetExpansionContains; path : string; child : TMXmlElement) : boolean;
    function ParseValueSet(element : TMXmlElement; path : string) : TFhirValueSet;
    function ParseValueSetChild(element : TFhirValueSet; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VISIONPRESCRIPTION}
    function ParseVisionPrescriptionDispense(element : TMXmlElement; path : string) : TFhirVisionPrescriptionDispense;
    function ParseVisionPrescriptionDispenseChild(element : TFhirVisionPrescriptionDispense; path : string; child : TMXmlElement) : boolean;
    function ParseVisionPrescription(element : TMXmlElement; path : string) : TFhirVisionPrescription;
    function ParseVisionPrescriptionChild(element : TFhirVisionPrescription; path : string; child : TMXmlElement) : boolean;
{$ENDIF FHIR_VISIONPRESCRIPTION}
    function ParseResource(element : TMXmlElement; path : String) : TFhirResource; override;
    function ParseDataType(element : TMXmlElement; name : String; type_ : TFHIRTypeClass) : TFHIRType; override;
  public
    function ParseFragment(element : TMXmlElement) : TFHIRObject; overload;
  end;

  TFHIRXmlComposer = class (TFHIRXmlComposerBase2)
  protected
    procedure ComposeElement(xml : TXmlBuilder; name : string; elem : TFhirElement);

    Procedure ComposeElementAttributes(xml : TXmlBuilder; element : TFhirElement);
    Procedure ComposeElementChildren(xml : TXmlBuilder; element : TFhirElement);
    Procedure ComposeBackboneElementChildren(xml : TXmlBuilder; element : TFhirBackboneElement); overload;
    procedure ComposeBackboneElement(xml : TXmlBuilder; name : string; elem : TFhirBackboneElement);

    Procedure ComposeEnum(xml : TXmlBuilder; name : String; value : TFhirEnum; Const aNames : Array Of String);
    Procedure ComposeDateTime(xml : TXmlBuilder; name : String; value : TFhirDateTime);
    Procedure ComposeDate(xml : TXmlBuilder; name : String; value : TFhirDate);
    Procedure ComposeString(xml : TXmlBuilder; name : String; value : TFhirString);
    Procedure ComposeInteger(xml : TXmlBuilder; name : String; value : TFhirInteger);
    Procedure ComposeUri(xml : TXmlBuilder; name : String; value : TFhirUri);
    Procedure ComposeInstant(xml : TXmlBuilder; name : String; value : TFhirInstant);
    Procedure ComposeBoolean(xml : TXmlBuilder; name : String; value : TFhirBoolean);
    Procedure ComposeBase64Binary(xml : TXmlBuilder; name : String; value : TFhirBase64Binary);
    Procedure ComposeTime(xml : TXmlBuilder; name : String; value : TFhirTime);
    Procedure ComposeDecimal(xml : TXmlBuilder; name : String; value : TFhirDecimal);
    Procedure ComposeCode(xml : TXmlBuilder; name : String; value : TFhirCode);
    Procedure ComposeOid(xml : TXmlBuilder; name : String; value : TFhirOid);
    Procedure ComposeUuid(xml : TXmlBuilder; name : String; value : TFhirUuid);
    Procedure ComposeMarkdown(xml : TXmlBuilder; name : String; value : TFhirMarkdown);
    Procedure ComposeUnsignedInt(xml : TXmlBuilder; name : String; value : TFhirUnsignedInt);
    Procedure ComposeId(xml : TXmlBuilder; name : String; value : TFhirId);
    Procedure ComposePositiveInt(xml : TXmlBuilder; name : String; value : TFhirPositiveInt);

    Procedure ComposeResourceAttributes(xml : TXmlBuilder; resource : TFhirResource);
    Procedure ComposeResourceChildren(xml : TXmlBuilder; elem : TFhirResource);
{$IFDEF FHIR_PARAMETERS}
    procedure ComposeParametersParameter(xml : TXmlBuilder; name : string; elem : TFhirParametersParameter);
    procedure ComposeParametersParameterChildren(xml : TXmlBuilder; elem : TFhirParametersParameter);
    procedure ComposeParameters(xml : TXmlBuilder; name : string; elem : TFhirParameters);
    procedure ComposeParametersChildren(xml : TXmlBuilder; elem : TFhirParameters);
{$ENDIF FHIR_PARAMETERS}
    Procedure ComposeDomainResourceAttributes(xml : TXmlBuilder; resource : TFhirDomainResource);
    Procedure ComposeDomainResourceChildren(xml : TXmlBuilder; elem : TFhirDomainResource);

    procedure ComposeExtension(xml : TXmlBuilder; name : string; elem : TFhirExtension);
    procedure ComposeExtensionChildren(xml : TXmlBuilder; elem : TFhirExtension);
    procedure ComposeNarrative(xml : TXmlBuilder; name : string; elem : TFhirNarrative);
    procedure ComposeNarrativeChildren(xml : TXmlBuilder; elem : TFhirNarrative);
    procedure ComposeIdentifier(xml : TXmlBuilder; name : string; elem : TFhirIdentifier);
    procedure ComposeIdentifierChildren(xml : TXmlBuilder; elem : TFhirIdentifier);
    procedure ComposeCoding(xml : TXmlBuilder; name : string; elem : TFhirCoding);
    procedure ComposeCodingChildren(xml : TXmlBuilder; elem : TFhirCoding);
    procedure ComposeReference(xml : TXmlBuilder; name : string; elem : TFhirReference);
    procedure ComposeReferenceChildren(xml : TXmlBuilder; elem : TFhirReference);
    procedure ComposeSignature(xml : TXmlBuilder; name : string; elem : TFhirSignature);
    procedure ComposeSignatureChildren(xml : TXmlBuilder; elem : TFhirSignature);
    procedure ComposeSampledData(xml : TXmlBuilder; name : string; elem : TFhirSampledData);
    procedure ComposeSampledDataChildren(xml : TXmlBuilder; elem : TFhirSampledData);
    procedure ComposePeriod(xml : TXmlBuilder; name : string; elem : TFhirPeriod);
    procedure ComposePeriodChildren(xml : TXmlBuilder; elem : TFhirPeriod);
    procedure ComposeQuantity(xml : TXmlBuilder; name : string; elem : TFhirQuantity);
    procedure ComposeQuantityChildren(xml : TXmlBuilder; elem : TFhirQuantity);
    procedure ComposeAttachment(xml : TXmlBuilder; name : string; elem : TFhirAttachment);
    procedure ComposeAttachmentChildren(xml : TXmlBuilder; elem : TFhirAttachment);
    procedure ComposeRatio(xml : TXmlBuilder; name : string; elem : TFhirRatio);
    procedure ComposeRatioChildren(xml : TXmlBuilder; elem : TFhirRatio);
    procedure ComposeRange(xml : TXmlBuilder; name : string; elem : TFhirRange);
    procedure ComposeRangeChildren(xml : TXmlBuilder; elem : TFhirRange);
    procedure ComposeAnnotation(xml : TXmlBuilder; name : string; elem : TFhirAnnotation);
    procedure ComposeAnnotationChildren(xml : TXmlBuilder; elem : TFhirAnnotation);
    procedure ComposeCodeableConcept(xml : TXmlBuilder; name : string; elem : TFhirCodeableConcept);
    procedure ComposeCodeableConceptChildren(xml : TXmlBuilder; elem : TFhirCodeableConcept);
    procedure ComposeHumanName(xml : TXmlBuilder; name : string; elem : TFhirHumanName);
    procedure ComposeHumanNameChildren(xml : TXmlBuilder; elem : TFhirHumanName);
    procedure ComposeMeta(xml : TXmlBuilder; name : string; elem : TFhirMeta);
    procedure ComposeMetaChildren(xml : TXmlBuilder; elem : TFhirMeta);
    procedure ComposeContactPoint(xml : TXmlBuilder; name : string; elem : TFhirContactPoint);
    procedure ComposeContactPointChildren(xml : TXmlBuilder; elem : TFhirContactPoint);
    procedure ComposeAddress(xml : TXmlBuilder; name : string; elem : TFhirAddress);
    procedure ComposeAddressChildren(xml : TXmlBuilder; elem : TFhirAddress);
    procedure ComposeElementDefinitionSlicing(xml : TXmlBuilder; name : string; elem : TFhirElementDefinitionSlicing);
    procedure ComposeElementDefinitionSlicingChildren(xml : TXmlBuilder; elem : TFhirElementDefinitionSlicing);
    procedure ComposeElementDefinitionBase(xml : TXmlBuilder; name : string; elem : TFhirElementDefinitionBase);
    procedure ComposeElementDefinitionBaseChildren(xml : TXmlBuilder; elem : TFhirElementDefinitionBase);
    procedure ComposeElementDefinitionType(xml : TXmlBuilder; name : string; elem : TFhirElementDefinitionType);
    procedure ComposeElementDefinitionTypeChildren(xml : TXmlBuilder; elem : TFhirElementDefinitionType);
    procedure ComposeElementDefinitionConstraint(xml : TXmlBuilder; name : string; elem : TFhirElementDefinitionConstraint);
    procedure ComposeElementDefinitionConstraintChildren(xml : TXmlBuilder; elem : TFhirElementDefinitionConstraint);
    procedure ComposeElementDefinitionBinding(xml : TXmlBuilder; name : string; elem : TFhirElementDefinitionBinding);
    procedure ComposeElementDefinitionBindingChildren(xml : TXmlBuilder; elem : TFhirElementDefinitionBinding);
    procedure ComposeElementDefinitionMapping(xml : TXmlBuilder; name : string; elem : TFhirElementDefinitionMapping);
    procedure ComposeElementDefinitionMappingChildren(xml : TXmlBuilder; elem : TFhirElementDefinitionMapping);
    procedure ComposeElementDefinition(xml : TXmlBuilder; name : string; elem : TFhirElementDefinition);
    procedure ComposeElementDefinitionChildren(xml : TXmlBuilder; elem : TFhirElementDefinition);
    procedure ComposeTimingRepeat(xml : TXmlBuilder; name : string; elem : TFhirTimingRepeat);
    procedure ComposeTimingRepeatChildren(xml : TXmlBuilder; elem : TFhirTimingRepeat);
    procedure ComposeTiming(xml : TXmlBuilder; name : string; elem : TFhirTiming);
    procedure ComposeTimingChildren(xml : TXmlBuilder; elem : TFhirTiming);

{$IFDEF FHIR_ACCOUNT}
    procedure ComposeAccount(xml : TXmlBuilder; name : string; elem : TFhirAccount);
    procedure ComposeAccountChildren(xml : TXmlBuilder; elem : TFhirAccount);
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
    procedure ComposeAllergyIntoleranceReaction(xml : TXmlBuilder; name : string; elem : TFhirAllergyIntoleranceReaction);
    procedure ComposeAllergyIntoleranceReactionChildren(xml : TXmlBuilder; elem : TFhirAllergyIntoleranceReaction);
    procedure ComposeAllergyIntolerance(xml : TXmlBuilder; name : string; elem : TFhirAllergyIntolerance);
    procedure ComposeAllergyIntoleranceChildren(xml : TXmlBuilder; elem : TFhirAllergyIntolerance);
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
    procedure ComposeAppointmentParticipant(xml : TXmlBuilder; name : string; elem : TFhirAppointmentParticipant);
    procedure ComposeAppointmentParticipantChildren(xml : TXmlBuilder; elem : TFhirAppointmentParticipant);
    procedure ComposeAppointment(xml : TXmlBuilder; name : string; elem : TFhirAppointment);
    procedure ComposeAppointmentChildren(xml : TXmlBuilder; elem : TFhirAppointment);
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
    procedure ComposeAppointmentResponse(xml : TXmlBuilder; name : string; elem : TFhirAppointmentResponse);
    procedure ComposeAppointmentResponseChildren(xml : TXmlBuilder; elem : TFhirAppointmentResponse);
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
    procedure ComposeAuditEventEvent(xml : TXmlBuilder; name : string; elem : TFhirAuditEventEvent);
    procedure ComposeAuditEventEventChildren(xml : TXmlBuilder; elem : TFhirAuditEventEvent);
    procedure ComposeAuditEventParticipant(xml : TXmlBuilder; name : string; elem : TFhirAuditEventParticipant);
    procedure ComposeAuditEventParticipantChildren(xml : TXmlBuilder; elem : TFhirAuditEventParticipant);
    procedure ComposeAuditEventParticipantNetwork(xml : TXmlBuilder; name : string; elem : TFhirAuditEventParticipantNetwork);
    procedure ComposeAuditEventParticipantNetworkChildren(xml : TXmlBuilder; elem : TFhirAuditEventParticipantNetwork);
    procedure ComposeAuditEventSource(xml : TXmlBuilder; name : string; elem : TFhirAuditEventSource);
    procedure ComposeAuditEventSourceChildren(xml : TXmlBuilder; elem : TFhirAuditEventSource);
    procedure ComposeAuditEventObject(xml : TXmlBuilder; name : string; elem : TFhirAuditEventObject);
    procedure ComposeAuditEventObjectChildren(xml : TXmlBuilder; elem : TFhirAuditEventObject);
    procedure ComposeAuditEventObjectDetail(xml : TXmlBuilder; name : string; elem : TFhirAuditEventObjectDetail);
    procedure ComposeAuditEventObjectDetailChildren(xml : TXmlBuilder; elem : TFhirAuditEventObjectDetail);
    procedure ComposeAuditEvent(xml : TXmlBuilder; name : string; elem : TFhirAuditEvent);
    procedure ComposeAuditEventChildren(xml : TXmlBuilder; elem : TFhirAuditEvent);
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
    procedure ComposeBasic(xml : TXmlBuilder; name : string; elem : TFhirBasic);
    procedure ComposeBasicChildren(xml : TXmlBuilder; elem : TFhirBasic);
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
    procedure ComposeBinary(xml : TXmlBuilder; name : string; elem : TFhirBinary);
    procedure ComposeBinaryChildren(xml : TXmlBuilder; elem : TFhirBinary);
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BODYSITE}
    procedure ComposeBodySite(xml : TXmlBuilder; name : string; elem : TFhirBodySite);
    procedure ComposeBodySiteChildren(xml : TXmlBuilder; elem : TFhirBodySite);
{$ENDIF FHIR_BODYSITE}
{$IFDEF FHIR_BUNDLE}
    procedure ComposeBundleLink(xml : TXmlBuilder; name : string; elem : TFhirBundleLink);
    procedure ComposeBundleLinkChildren(xml : TXmlBuilder; elem : TFhirBundleLink);
    procedure ComposeBundleEntry(xml : TXmlBuilder; name : string; elem : TFhirBundleEntry);
    procedure ComposeBundleEntryChildren(xml : TXmlBuilder; elem : TFhirBundleEntry);
    procedure ComposeBundleEntrySearch(xml : TXmlBuilder; name : string; elem : TFhirBundleEntrySearch);
    procedure ComposeBundleEntrySearchChildren(xml : TXmlBuilder; elem : TFhirBundleEntrySearch);
    procedure ComposeBundleEntryRequest(xml : TXmlBuilder; name : string; elem : TFhirBundleEntryRequest);
    procedure ComposeBundleEntryRequestChildren(xml : TXmlBuilder; elem : TFhirBundleEntryRequest);
    procedure ComposeBundleEntryResponse(xml : TXmlBuilder; name : string; elem : TFhirBundleEntryResponse);
    procedure ComposeBundleEntryResponseChildren(xml : TXmlBuilder; elem : TFhirBundleEntryResponse);
    procedure ComposeBundle(xml : TXmlBuilder; name : string; elem : TFhirBundle);
    procedure ComposeBundleChildren(xml : TXmlBuilder; elem : TFhirBundle);
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAREPLAN}
    procedure ComposeCarePlanRelatedPlan(xml : TXmlBuilder; name : string; elem : TFhirCarePlanRelatedPlan);
    procedure ComposeCarePlanRelatedPlanChildren(xml : TXmlBuilder; elem : TFhirCarePlanRelatedPlan);
    procedure ComposeCarePlanParticipant(xml : TXmlBuilder; name : string; elem : TFhirCarePlanParticipant);
    procedure ComposeCarePlanParticipantChildren(xml : TXmlBuilder; elem : TFhirCarePlanParticipant);
    procedure ComposeCarePlanActivity(xml : TXmlBuilder; name : string; elem : TFhirCarePlanActivity);
    procedure ComposeCarePlanActivityChildren(xml : TXmlBuilder; elem : TFhirCarePlanActivity);
    procedure ComposeCarePlanActivityDetail(xml : TXmlBuilder; name : string; elem : TFhirCarePlanActivityDetail);
    procedure ComposeCarePlanActivityDetailChildren(xml : TXmlBuilder; elem : TFhirCarePlanActivityDetail);
    procedure ComposeCarePlan(xml : TXmlBuilder; name : string; elem : TFhirCarePlan);
    procedure ComposeCarePlanChildren(xml : TXmlBuilder; elem : TFhirCarePlan);
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CLAIM}
    procedure ComposeClaimPayee(xml : TXmlBuilder; name : string; elem : TFhirClaimPayee);
    procedure ComposeClaimPayeeChildren(xml : TXmlBuilder; elem : TFhirClaimPayee);
    procedure ComposeClaimDiagnosis(xml : TXmlBuilder; name : string; elem : TFhirClaimDiagnosis);
    procedure ComposeClaimDiagnosisChildren(xml : TXmlBuilder; elem : TFhirClaimDiagnosis);
    procedure ComposeClaimCoverage(xml : TXmlBuilder; name : string; elem : TFhirClaimCoverage);
    procedure ComposeClaimCoverageChildren(xml : TXmlBuilder; elem : TFhirClaimCoverage);
    procedure ComposeClaimItem(xml : TXmlBuilder; name : string; elem : TFhirClaimItem);
    procedure ComposeClaimItemChildren(xml : TXmlBuilder; elem : TFhirClaimItem);
    procedure ComposeClaimItemDetail(xml : TXmlBuilder; name : string; elem : TFhirClaimItemDetail);
    procedure ComposeClaimItemDetailChildren(xml : TXmlBuilder; elem : TFhirClaimItemDetail);
    procedure ComposeClaimItemDetailSubDetail(xml : TXmlBuilder; name : string; elem : TFhirClaimItemDetailSubDetail);
    procedure ComposeClaimItemDetailSubDetailChildren(xml : TXmlBuilder; elem : TFhirClaimItemDetailSubDetail);
    procedure ComposeClaimItemProsthesis(xml : TXmlBuilder; name : string; elem : TFhirClaimItemProsthesis);
    procedure ComposeClaimItemProsthesisChildren(xml : TXmlBuilder; elem : TFhirClaimItemProsthesis);
    procedure ComposeClaimMissingTeeth(xml : TXmlBuilder; name : string; elem : TFhirClaimMissingTeeth);
    procedure ComposeClaimMissingTeethChildren(xml : TXmlBuilder; elem : TFhirClaimMissingTeeth);
    procedure ComposeClaim(xml : TXmlBuilder; name : string; elem : TFhirClaim);
    procedure ComposeClaimChildren(xml : TXmlBuilder; elem : TFhirClaim);
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
    procedure ComposeClaimResponseItem(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseItem);
    procedure ComposeClaimResponseItemChildren(xml : TXmlBuilder; elem : TFhirClaimResponseItem);
    procedure ComposeClaimResponseItemAdjudication(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseItemAdjudication);
    procedure ComposeClaimResponseItemAdjudicationChildren(xml : TXmlBuilder; elem : TFhirClaimResponseItemAdjudication);
    procedure ComposeClaimResponseItemDetail(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseItemDetail);
    procedure ComposeClaimResponseItemDetailChildren(xml : TXmlBuilder; elem : TFhirClaimResponseItemDetail);
    procedure ComposeClaimResponseItemDetailAdjudication(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseItemDetailAdjudication);
    procedure ComposeClaimResponseItemDetailAdjudicationChildren(xml : TXmlBuilder; elem : TFhirClaimResponseItemDetailAdjudication);
    procedure ComposeClaimResponseItemDetailSubDetail(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseItemDetailSubDetail);
    procedure ComposeClaimResponseItemDetailSubDetailChildren(xml : TXmlBuilder; elem : TFhirClaimResponseItemDetailSubDetail);
    procedure ComposeClaimResponseItemDetailSubDetailAdjudication(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseItemDetailSubDetailAdjudication);
    procedure ComposeClaimResponseItemDetailSubDetailAdjudicationChildren(xml : TXmlBuilder; elem : TFhirClaimResponseItemDetailSubDetailAdjudication);
    procedure ComposeClaimResponseAddItem(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseAddItem);
    procedure ComposeClaimResponseAddItemChildren(xml : TXmlBuilder; elem : TFhirClaimResponseAddItem);
    procedure ComposeClaimResponseAddItemAdjudication(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseAddItemAdjudication);
    procedure ComposeClaimResponseAddItemAdjudicationChildren(xml : TXmlBuilder; elem : TFhirClaimResponseAddItemAdjudication);
    procedure ComposeClaimResponseAddItemDetail(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseAddItemDetail);
    procedure ComposeClaimResponseAddItemDetailChildren(xml : TXmlBuilder; elem : TFhirClaimResponseAddItemDetail);
    procedure ComposeClaimResponseAddItemDetailAdjudication(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseAddItemDetailAdjudication);
    procedure ComposeClaimResponseAddItemDetailAdjudicationChildren(xml : TXmlBuilder; elem : TFhirClaimResponseAddItemDetailAdjudication);
    procedure ComposeClaimResponseError(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseError);
    procedure ComposeClaimResponseErrorChildren(xml : TXmlBuilder; elem : TFhirClaimResponseError);
    procedure ComposeClaimResponseNote(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseNote);
    procedure ComposeClaimResponseNoteChildren(xml : TXmlBuilder; elem : TFhirClaimResponseNote);
    procedure ComposeClaimResponseCoverage(xml : TXmlBuilder; name : string; elem : TFhirClaimResponseCoverage);
    procedure ComposeClaimResponseCoverageChildren(xml : TXmlBuilder; elem : TFhirClaimResponseCoverage);
    procedure ComposeClaimResponse(xml : TXmlBuilder; name : string; elem : TFhirClaimResponse);
    procedure ComposeClaimResponseChildren(xml : TXmlBuilder; elem : TFhirClaimResponse);
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
    procedure ComposeClinicalImpressionInvestigations(xml : TXmlBuilder; name : string; elem : TFhirClinicalImpressionInvestigations);
    procedure ComposeClinicalImpressionInvestigationsChildren(xml : TXmlBuilder; elem : TFhirClinicalImpressionInvestigations);
    procedure ComposeClinicalImpressionFinding(xml : TXmlBuilder; name : string; elem : TFhirClinicalImpressionFinding);
    procedure ComposeClinicalImpressionFindingChildren(xml : TXmlBuilder; elem : TFhirClinicalImpressionFinding);
    procedure ComposeClinicalImpressionRuledOut(xml : TXmlBuilder; name : string; elem : TFhirClinicalImpressionRuledOut);
    procedure ComposeClinicalImpressionRuledOutChildren(xml : TXmlBuilder; elem : TFhirClinicalImpressionRuledOut);
    procedure ComposeClinicalImpression(xml : TXmlBuilder; name : string; elem : TFhirClinicalImpression);
    procedure ComposeClinicalImpressionChildren(xml : TXmlBuilder; elem : TFhirClinicalImpression);
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_COMMUNICATION}
    procedure ComposeCommunicationPayload(xml : TXmlBuilder; name : string; elem : TFhirCommunicationPayload);
    procedure ComposeCommunicationPayloadChildren(xml : TXmlBuilder; elem : TFhirCommunicationPayload);
    procedure ComposeCommunication(xml : TXmlBuilder; name : string; elem : TFhirCommunication);
    procedure ComposeCommunicationChildren(xml : TXmlBuilder; elem : TFhirCommunication);
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
    procedure ComposeCommunicationRequestPayload(xml : TXmlBuilder; name : string; elem : TFhirCommunicationRequestPayload);
    procedure ComposeCommunicationRequestPayloadChildren(xml : TXmlBuilder; elem : TFhirCommunicationRequestPayload);
    procedure ComposeCommunicationRequest(xml : TXmlBuilder; name : string; elem : TFhirCommunicationRequest);
    procedure ComposeCommunicationRequestChildren(xml : TXmlBuilder; elem : TFhirCommunicationRequest);
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPOSITION}
    procedure ComposeCompositionAttester(xml : TXmlBuilder; name : string; elem : TFhirCompositionAttester);
    procedure ComposeCompositionAttesterChildren(xml : TXmlBuilder; elem : TFhirCompositionAttester);
    procedure ComposeCompositionEvent(xml : TXmlBuilder; name : string; elem : TFhirCompositionEvent);
    procedure ComposeCompositionEventChildren(xml : TXmlBuilder; elem : TFhirCompositionEvent);
    procedure ComposeCompositionSection(xml : TXmlBuilder; name : string; elem : TFhirCompositionSection);
    procedure ComposeCompositionSectionChildren(xml : TXmlBuilder; elem : TFhirCompositionSection);
    procedure ComposeComposition(xml : TXmlBuilder; name : string; elem : TFhirComposition);
    procedure ComposeCompositionChildren(xml : TXmlBuilder; elem : TFhirComposition);
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
    procedure ComposeConceptMapContact(xml : TXmlBuilder; name : string; elem : TFhirConceptMapContact);
    procedure ComposeConceptMapContactChildren(xml : TXmlBuilder; elem : TFhirConceptMapContact);
    procedure ComposeConceptMapElement(xml : TXmlBuilder; name : string; elem : TFhirConceptMapElement);
    procedure ComposeConceptMapElementChildren(xml : TXmlBuilder; elem : TFhirConceptMapElement);
    procedure ComposeConceptMapElementTarget(xml : TXmlBuilder; name : string; elem : TFhirConceptMapElementTarget);
    procedure ComposeConceptMapElementTargetChildren(xml : TXmlBuilder; elem : TFhirConceptMapElementTarget);
    procedure ComposeConceptMapElementTargetDependsOn(xml : TXmlBuilder; name : string; elem : TFhirConceptMapElementTargetDependsOn);
    procedure ComposeConceptMapElementTargetDependsOnChildren(xml : TXmlBuilder; elem : TFhirConceptMapElementTargetDependsOn);
    procedure ComposeConceptMap(xml : TXmlBuilder; name : string; elem : TFhirConceptMap);
    procedure ComposeConceptMapChildren(xml : TXmlBuilder; elem : TFhirConceptMap);
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
    procedure ComposeConditionStage(xml : TXmlBuilder; name : string; elem : TFhirConditionStage);
    procedure ComposeConditionStageChildren(xml : TXmlBuilder; elem : TFhirConditionStage);
    procedure ComposeConditionEvidence(xml : TXmlBuilder; name : string; elem : TFhirConditionEvidence);
    procedure ComposeConditionEvidenceChildren(xml : TXmlBuilder; elem : TFhirConditionEvidence);
    procedure ComposeCondition(xml : TXmlBuilder; name : string; elem : TFhirCondition);
    procedure ComposeConditionChildren(xml : TXmlBuilder; elem : TFhirCondition);
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONFORMANCE}
    procedure ComposeConformanceContact(xml : TXmlBuilder; name : string; elem : TFhirConformanceContact);
    procedure ComposeConformanceContactChildren(xml : TXmlBuilder; elem : TFhirConformanceContact);
    procedure ComposeConformanceSoftware(xml : TXmlBuilder; name : string; elem : TFhirConformanceSoftware);
    procedure ComposeConformanceSoftwareChildren(xml : TXmlBuilder; elem : TFhirConformanceSoftware);
    procedure ComposeConformanceImplementation(xml : TXmlBuilder; name : string; elem : TFhirConformanceImplementation);
    procedure ComposeConformanceImplementationChildren(xml : TXmlBuilder; elem : TFhirConformanceImplementation);
    procedure ComposeConformanceRest(xml : TXmlBuilder; name : string; elem : TFhirConformanceRest);
    procedure ComposeConformanceRestChildren(xml : TXmlBuilder; elem : TFhirConformanceRest);
    procedure ComposeConformanceRestSecurity(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestSecurity);
    procedure ComposeConformanceRestSecurityChildren(xml : TXmlBuilder; elem : TFhirConformanceRestSecurity);
    procedure ComposeConformanceRestSecurityCertificate(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestSecurityCertificate);
    procedure ComposeConformanceRestSecurityCertificateChildren(xml : TXmlBuilder; elem : TFhirConformanceRestSecurityCertificate);
    procedure ComposeConformanceRestResource(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestResource);
    procedure ComposeConformanceRestResourceChildren(xml : TXmlBuilder; elem : TFhirConformanceRestResource);
    procedure ComposeConformanceRestResourceInteraction(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestResourceInteraction);
    procedure ComposeConformanceRestResourceInteractionChildren(xml : TXmlBuilder; elem : TFhirConformanceRestResourceInteraction);
    procedure ComposeConformanceRestResourceSearchParam(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestResourceSearchParam);
    procedure ComposeConformanceRestResourceSearchParamChildren(xml : TXmlBuilder; elem : TFhirConformanceRestResourceSearchParam);
    procedure ComposeConformanceRestInteraction(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestInteraction);
    procedure ComposeConformanceRestInteractionChildren(xml : TXmlBuilder; elem : TFhirConformanceRestInteraction);
    procedure ComposeConformanceRestOperation(xml : TXmlBuilder; name : string; elem : TFhirConformanceRestOperation);
    procedure ComposeConformanceRestOperationChildren(xml : TXmlBuilder; elem : TFhirConformanceRestOperation);
    procedure ComposeConformanceMessaging(xml : TXmlBuilder; name : string; elem : TFhirConformanceMessaging);
    procedure ComposeConformanceMessagingChildren(xml : TXmlBuilder; elem : TFhirConformanceMessaging);
    procedure ComposeConformanceMessagingEndpoint(xml : TXmlBuilder; name : string; elem : TFhirConformanceMessagingEndpoint);
    procedure ComposeConformanceMessagingEndpointChildren(xml : TXmlBuilder; elem : TFhirConformanceMessagingEndpoint);
    procedure ComposeConformanceMessagingEvent(xml : TXmlBuilder; name : string; elem : TFhirConformanceMessagingEvent);
    procedure ComposeConformanceMessagingEventChildren(xml : TXmlBuilder; elem : TFhirConformanceMessagingEvent);
    procedure ComposeConformanceDocument(xml : TXmlBuilder; name : string; elem : TFhirConformanceDocument);
    procedure ComposeConformanceDocumentChildren(xml : TXmlBuilder; elem : TFhirConformanceDocument);
    procedure ComposeConformance(xml : TXmlBuilder; name : string; elem : TFhirConformance);
    procedure ComposeConformanceChildren(xml : TXmlBuilder; elem : TFhirConformance);
{$ENDIF FHIR_CONFORMANCE}
{$IFDEF FHIR_CONTRACT}
    procedure ComposeContractActor(xml : TXmlBuilder; name : string; elem : TFhirContractActor);
    procedure ComposeContractActorChildren(xml : TXmlBuilder; elem : TFhirContractActor);
    procedure ComposeContractValuedItem(xml : TXmlBuilder; name : string; elem : TFhirContractValuedItem);
    procedure ComposeContractValuedItemChildren(xml : TXmlBuilder; elem : TFhirContractValuedItem);
    procedure ComposeContractSigner(xml : TXmlBuilder; name : string; elem : TFhirContractSigner);
    procedure ComposeContractSignerChildren(xml : TXmlBuilder; elem : TFhirContractSigner);
    procedure ComposeContractTerm(xml : TXmlBuilder; name : string; elem : TFhirContractTerm);
    procedure ComposeContractTermChildren(xml : TXmlBuilder; elem : TFhirContractTerm);
    procedure ComposeContractTermActor(xml : TXmlBuilder; name : string; elem : TFhirContractTermActor);
    procedure ComposeContractTermActorChildren(xml : TXmlBuilder; elem : TFhirContractTermActor);
    procedure ComposeContractTermValuedItem(xml : TXmlBuilder; name : string; elem : TFhirContractTermValuedItem);
    procedure ComposeContractTermValuedItemChildren(xml : TXmlBuilder; elem : TFhirContractTermValuedItem);
    procedure ComposeContractFriendly(xml : TXmlBuilder; name : string; elem : TFhirContractFriendly);
    procedure ComposeContractFriendlyChildren(xml : TXmlBuilder; elem : TFhirContractFriendly);
    procedure ComposeContractLegal(xml : TXmlBuilder; name : string; elem : TFhirContractLegal);
    procedure ComposeContractLegalChildren(xml : TXmlBuilder; elem : TFhirContractLegal);
    procedure ComposeContractRule(xml : TXmlBuilder; name : string; elem : TFhirContractRule);
    procedure ComposeContractRuleChildren(xml : TXmlBuilder; elem : TFhirContractRule);
    procedure ComposeContract(xml : TXmlBuilder; name : string; elem : TFhirContract);
    procedure ComposeContractChildren(xml : TXmlBuilder; elem : TFhirContract);
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
    procedure ComposeCoverage(xml : TXmlBuilder; name : string; elem : TFhirCoverage);
    procedure ComposeCoverageChildren(xml : TXmlBuilder; elem : TFhirCoverage);
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_DATAELEMENT}
    procedure ComposeDataElementContact(xml : TXmlBuilder; name : string; elem : TFhirDataElementContact);
    procedure ComposeDataElementContactChildren(xml : TXmlBuilder; elem : TFhirDataElementContact);
    procedure ComposeDataElementMapping(xml : TXmlBuilder; name : string; elem : TFhirDataElementMapping);
    procedure ComposeDataElementMappingChildren(xml : TXmlBuilder; elem : TFhirDataElementMapping);
    procedure ComposeDataElement(xml : TXmlBuilder; name : string; elem : TFhirDataElement);
    procedure ComposeDataElementChildren(xml : TXmlBuilder; elem : TFhirDataElement);
{$ENDIF FHIR_DATAELEMENT}
{$IFDEF FHIR_DETECTEDISSUE}
    procedure ComposeDetectedIssueMitigation(xml : TXmlBuilder; name : string; elem : TFhirDetectedIssueMitigation);
    procedure ComposeDetectedIssueMitigationChildren(xml : TXmlBuilder; elem : TFhirDetectedIssueMitigation);
    procedure ComposeDetectedIssue(xml : TXmlBuilder; name : string; elem : TFhirDetectedIssue);
    procedure ComposeDetectedIssueChildren(xml : TXmlBuilder; elem : TFhirDetectedIssue);
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
    procedure ComposeDevice(xml : TXmlBuilder; name : string; elem : TFhirDevice);
    procedure ComposeDeviceChildren(xml : TXmlBuilder; elem : TFhirDevice);
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICECOMPONENT}
    procedure ComposeDeviceComponentProductionSpecification(xml : TXmlBuilder; name : string; elem : TFhirDeviceComponentProductionSpecification);
    procedure ComposeDeviceComponentProductionSpecificationChildren(xml : TXmlBuilder; elem : TFhirDeviceComponentProductionSpecification);
    procedure ComposeDeviceComponent(xml : TXmlBuilder; name : string; elem : TFhirDeviceComponent);
    procedure ComposeDeviceComponentChildren(xml : TXmlBuilder; elem : TFhirDeviceComponent);
{$ENDIF FHIR_DEVICECOMPONENT}
{$IFDEF FHIR_DEVICEMETRIC}
    procedure ComposeDeviceMetricCalibration(xml : TXmlBuilder; name : string; elem : TFhirDeviceMetricCalibration);
    procedure ComposeDeviceMetricCalibrationChildren(xml : TXmlBuilder; elem : TFhirDeviceMetricCalibration);
    procedure ComposeDeviceMetric(xml : TXmlBuilder; name : string; elem : TFhirDeviceMetric);
    procedure ComposeDeviceMetricChildren(xml : TXmlBuilder; elem : TFhirDeviceMetric);
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEUSEREQUEST}
    procedure ComposeDeviceUseRequest(xml : TXmlBuilder; name : string; elem : TFhirDeviceUseRequest);
    procedure ComposeDeviceUseRequestChildren(xml : TXmlBuilder; elem : TFhirDeviceUseRequest);
{$ENDIF FHIR_DEVICEUSEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
    procedure ComposeDeviceUseStatement(xml : TXmlBuilder; name : string; elem : TFhirDeviceUseStatement);
    procedure ComposeDeviceUseStatementChildren(xml : TXmlBuilder; elem : TFhirDeviceUseStatement);
{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICORDER}
    procedure ComposeDiagnosticOrderEvent(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticOrderEvent);
    procedure ComposeDiagnosticOrderEventChildren(xml : TXmlBuilder; elem : TFhirDiagnosticOrderEvent);
    procedure ComposeDiagnosticOrderItem(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticOrderItem);
    procedure ComposeDiagnosticOrderItemChildren(xml : TXmlBuilder; elem : TFhirDiagnosticOrderItem);
    procedure ComposeDiagnosticOrder(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticOrder);
    procedure ComposeDiagnosticOrderChildren(xml : TXmlBuilder; elem : TFhirDiagnosticOrder);
{$ENDIF FHIR_DIAGNOSTICORDER}
{$IFDEF FHIR_DIAGNOSTICREPORT}
    procedure ComposeDiagnosticReportImage(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticReportImage);
    procedure ComposeDiagnosticReportImageChildren(xml : TXmlBuilder; elem : TFhirDiagnosticReportImage);
    procedure ComposeDiagnosticReport(xml : TXmlBuilder; name : string; elem : TFhirDiagnosticReport);
    procedure ComposeDiagnosticReportChildren(xml : TXmlBuilder; elem : TFhirDiagnosticReport);
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
    procedure ComposeDocumentManifestContent(xml : TXmlBuilder; name : string; elem : TFhirDocumentManifestContent);
    procedure ComposeDocumentManifestContentChildren(xml : TXmlBuilder; elem : TFhirDocumentManifestContent);
    procedure ComposeDocumentManifestRelated(xml : TXmlBuilder; name : string; elem : TFhirDocumentManifestRelated);
    procedure ComposeDocumentManifestRelatedChildren(xml : TXmlBuilder; elem : TFhirDocumentManifestRelated);
    procedure ComposeDocumentManifest(xml : TXmlBuilder; name : string; elem : TFhirDocumentManifest);
    procedure ComposeDocumentManifestChildren(xml : TXmlBuilder; elem : TFhirDocumentManifest);
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
    procedure ComposeDocumentReferenceRelatesTo(xml : TXmlBuilder; name : string; elem : TFhirDocumentReferenceRelatesTo);
    procedure ComposeDocumentReferenceRelatesToChildren(xml : TXmlBuilder; elem : TFhirDocumentReferenceRelatesTo);
    procedure ComposeDocumentReferenceContent(xml : TXmlBuilder; name : string; elem : TFhirDocumentReferenceContent);
    procedure ComposeDocumentReferenceContentChildren(xml : TXmlBuilder; elem : TFhirDocumentReferenceContent);
    procedure ComposeDocumentReferenceContext(xml : TXmlBuilder; name : string; elem : TFhirDocumentReferenceContext);
    procedure ComposeDocumentReferenceContextChildren(xml : TXmlBuilder; elem : TFhirDocumentReferenceContext);
    procedure ComposeDocumentReferenceContextRelated(xml : TXmlBuilder; name : string; elem : TFhirDocumentReferenceContextRelated);
    procedure ComposeDocumentReferenceContextRelatedChildren(xml : TXmlBuilder; elem : TFhirDocumentReferenceContextRelated);
    procedure ComposeDocumentReference(xml : TXmlBuilder; name : string; elem : TFhirDocumentReference);
    procedure ComposeDocumentReferenceChildren(xml : TXmlBuilder; elem : TFhirDocumentReference);
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ELIGIBILITYREQUEST}
    procedure ComposeEligibilityRequest(xml : TXmlBuilder; name : string; elem : TFhirEligibilityRequest);
    procedure ComposeEligibilityRequestChildren(xml : TXmlBuilder; elem : TFhirEligibilityRequest);
{$ENDIF FHIR_ELIGIBILITYREQUEST}
{$IFDEF FHIR_ELIGIBILITYRESPONSE}
    procedure ComposeEligibilityResponse(xml : TXmlBuilder; name : string; elem : TFhirEligibilityResponse);
    procedure ComposeEligibilityResponseChildren(xml : TXmlBuilder; elem : TFhirEligibilityResponse);
{$ENDIF FHIR_ELIGIBILITYRESPONSE}
{$IFDEF FHIR_ENCOUNTER}
    procedure ComposeEncounterStatusHistory(xml : TXmlBuilder; name : string; elem : TFhirEncounterStatusHistory);
    procedure ComposeEncounterStatusHistoryChildren(xml : TXmlBuilder; elem : TFhirEncounterStatusHistory);
    procedure ComposeEncounterParticipant(xml : TXmlBuilder; name : string; elem : TFhirEncounterParticipant);
    procedure ComposeEncounterParticipantChildren(xml : TXmlBuilder; elem : TFhirEncounterParticipant);
    procedure ComposeEncounterHospitalization(xml : TXmlBuilder; name : string; elem : TFhirEncounterHospitalization);
    procedure ComposeEncounterHospitalizationChildren(xml : TXmlBuilder; elem : TFhirEncounterHospitalization);
    procedure ComposeEncounterLocation(xml : TXmlBuilder; name : string; elem : TFhirEncounterLocation);
    procedure ComposeEncounterLocationChildren(xml : TXmlBuilder; elem : TFhirEncounterLocation);
    procedure ComposeEncounter(xml : TXmlBuilder; name : string; elem : TFhirEncounter);
    procedure ComposeEncounterChildren(xml : TXmlBuilder; elem : TFhirEncounter);
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENROLLMENTREQUEST}
    procedure ComposeEnrollmentRequest(xml : TXmlBuilder; name : string; elem : TFhirEnrollmentRequest);
    procedure ComposeEnrollmentRequestChildren(xml : TXmlBuilder; elem : TFhirEnrollmentRequest);
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
    procedure ComposeEnrollmentResponse(xml : TXmlBuilder; name : string; elem : TFhirEnrollmentResponse);
    procedure ComposeEnrollmentResponseChildren(xml : TXmlBuilder; elem : TFhirEnrollmentResponse);
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
    procedure ComposeEpisodeOfCareStatusHistory(xml : TXmlBuilder; name : string; elem : TFhirEpisodeOfCareStatusHistory);
    procedure ComposeEpisodeOfCareStatusHistoryChildren(xml : TXmlBuilder; elem : TFhirEpisodeOfCareStatusHistory);
    procedure ComposeEpisodeOfCareCareTeam(xml : TXmlBuilder; name : string; elem : TFhirEpisodeOfCareCareTeam);
    procedure ComposeEpisodeOfCareCareTeamChildren(xml : TXmlBuilder; elem : TFhirEpisodeOfCareCareTeam);
    procedure ComposeEpisodeOfCare(xml : TXmlBuilder; name : string; elem : TFhirEpisodeOfCare);
    procedure ComposeEpisodeOfCareChildren(xml : TXmlBuilder; elem : TFhirEpisodeOfCare);
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
    procedure ComposeExplanationOfBenefit(xml : TXmlBuilder; name : string; elem : TFhirExplanationOfBenefit);
    procedure ComposeExplanationOfBenefitChildren(xml : TXmlBuilder; elem : TFhirExplanationOfBenefit);
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
    procedure ComposeFamilyMemberHistoryCondition(xml : TXmlBuilder; name : string; elem : TFhirFamilyMemberHistoryCondition);
    procedure ComposeFamilyMemberHistoryConditionChildren(xml : TXmlBuilder; elem : TFhirFamilyMemberHistoryCondition);
    procedure ComposeFamilyMemberHistory(xml : TXmlBuilder; name : string; elem : TFhirFamilyMemberHistory);
    procedure ComposeFamilyMemberHistoryChildren(xml : TXmlBuilder; elem : TFhirFamilyMemberHistory);
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
    procedure ComposeFlag(xml : TXmlBuilder; name : string; elem : TFhirFlag);
    procedure ComposeFlagChildren(xml : TXmlBuilder; elem : TFhirFlag);
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
    procedure ComposeGoalOutcome(xml : TXmlBuilder; name : string; elem : TFhirGoalOutcome);
    procedure ComposeGoalOutcomeChildren(xml : TXmlBuilder; elem : TFhirGoalOutcome);
    procedure ComposeGoal(xml : TXmlBuilder; name : string; elem : TFhirGoal);
    procedure ComposeGoalChildren(xml : TXmlBuilder; elem : TFhirGoal);
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GROUP}
    procedure ComposeGroupCharacteristic(xml : TXmlBuilder; name : string; elem : TFhirGroupCharacteristic);
    procedure ComposeGroupCharacteristicChildren(xml : TXmlBuilder; elem : TFhirGroupCharacteristic);
    procedure ComposeGroupMember(xml : TXmlBuilder; name : string; elem : TFhirGroupMember);
    procedure ComposeGroupMemberChildren(xml : TXmlBuilder; elem : TFhirGroupMember);
    procedure ComposeGroup(xml : TXmlBuilder; name : string; elem : TFhirGroup);
    procedure ComposeGroupChildren(xml : TXmlBuilder; elem : TFhirGroup);
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_HEALTHCARESERVICE}
    procedure ComposeHealthcareServiceServiceType(xml : TXmlBuilder; name : string; elem : TFhirHealthcareServiceServiceType);
    procedure ComposeHealthcareServiceServiceTypeChildren(xml : TXmlBuilder; elem : TFhirHealthcareServiceServiceType);
    procedure ComposeHealthcareServiceAvailableTime(xml : TXmlBuilder; name : string; elem : TFhirHealthcareServiceAvailableTime);
    procedure ComposeHealthcareServiceAvailableTimeChildren(xml : TXmlBuilder; elem : TFhirHealthcareServiceAvailableTime);
    procedure ComposeHealthcareServiceNotAvailable(xml : TXmlBuilder; name : string; elem : TFhirHealthcareServiceNotAvailable);
    procedure ComposeHealthcareServiceNotAvailableChildren(xml : TXmlBuilder; elem : TFhirHealthcareServiceNotAvailable);
    procedure ComposeHealthcareService(xml : TXmlBuilder; name : string; elem : TFhirHealthcareService);
    procedure ComposeHealthcareServiceChildren(xml : TXmlBuilder; elem : TFhirHealthcareService);
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGOBJECTSELECTION}
    procedure ComposeImagingObjectSelectionStudy(xml : TXmlBuilder; name : string; elem : TFhirImagingObjectSelectionStudy);
    procedure ComposeImagingObjectSelectionStudyChildren(xml : TXmlBuilder; elem : TFhirImagingObjectSelectionStudy);
    procedure ComposeImagingObjectSelectionStudySeries(xml : TXmlBuilder; name : string; elem : TFhirImagingObjectSelectionStudySeries);
    procedure ComposeImagingObjectSelectionStudySeriesChildren(xml : TXmlBuilder; elem : TFhirImagingObjectSelectionStudySeries);
    procedure ComposeImagingObjectSelectionStudySeriesInstance(xml : TXmlBuilder; name : string; elem : TFhirImagingObjectSelectionStudySeriesInstance);
    procedure ComposeImagingObjectSelectionStudySeriesInstanceChildren(xml : TXmlBuilder; elem : TFhirImagingObjectSelectionStudySeriesInstance);
    procedure ComposeImagingObjectSelectionStudySeriesInstanceFrames(xml : TXmlBuilder; name : string; elem : TFhirImagingObjectSelectionStudySeriesInstanceFrames);
    procedure ComposeImagingObjectSelectionStudySeriesInstanceFramesChildren(xml : TXmlBuilder; elem : TFhirImagingObjectSelectionStudySeriesInstanceFrames);
    procedure ComposeImagingObjectSelection(xml : TXmlBuilder; name : string; elem : TFhirImagingObjectSelection);
    procedure ComposeImagingObjectSelectionChildren(xml : TXmlBuilder; elem : TFhirImagingObjectSelection);
{$ENDIF FHIR_IMAGINGOBJECTSELECTION}
{$IFDEF FHIR_IMAGINGSTUDY}
    procedure ComposeImagingStudySeries(xml : TXmlBuilder; name : string; elem : TFhirImagingStudySeries);
    procedure ComposeImagingStudySeriesChildren(xml : TXmlBuilder; elem : TFhirImagingStudySeries);
    procedure ComposeImagingStudySeriesInstance(xml : TXmlBuilder; name : string; elem : TFhirImagingStudySeriesInstance);
    procedure ComposeImagingStudySeriesInstanceChildren(xml : TXmlBuilder; elem : TFhirImagingStudySeriesInstance);
    procedure ComposeImagingStudy(xml : TXmlBuilder; name : string; elem : TFhirImagingStudy);
    procedure ComposeImagingStudyChildren(xml : TXmlBuilder; elem : TFhirImagingStudy);
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
    procedure ComposeImmunizationExplanation(xml : TXmlBuilder; name : string; elem : TFhirImmunizationExplanation);
    procedure ComposeImmunizationExplanationChildren(xml : TXmlBuilder; elem : TFhirImmunizationExplanation);
    procedure ComposeImmunizationReaction(xml : TXmlBuilder; name : string; elem : TFhirImmunizationReaction);
    procedure ComposeImmunizationReactionChildren(xml : TXmlBuilder; elem : TFhirImmunizationReaction);
    procedure ComposeImmunizationVaccinationProtocol(xml : TXmlBuilder; name : string; elem : TFhirImmunizationVaccinationProtocol);
    procedure ComposeImmunizationVaccinationProtocolChildren(xml : TXmlBuilder; elem : TFhirImmunizationVaccinationProtocol);
    procedure ComposeImmunization(xml : TXmlBuilder; name : string; elem : TFhirImmunization);
    procedure ComposeImmunizationChildren(xml : TXmlBuilder; elem : TFhirImmunization);
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
    procedure ComposeImmunizationRecommendationRecommendation(xml : TXmlBuilder; name : string; elem : TFhirImmunizationRecommendationRecommendation);
    procedure ComposeImmunizationRecommendationRecommendationChildren(xml : TXmlBuilder; elem : TFhirImmunizationRecommendationRecommendation);
    procedure ComposeImmunizationRecommendationRecommendationDateCriterion(xml : TXmlBuilder; name : string; elem : TFhirImmunizationRecommendationRecommendationDateCriterion);
    procedure ComposeImmunizationRecommendationRecommendationDateCriterionChildren(xml : TXmlBuilder; elem : TFhirImmunizationRecommendationRecommendationDateCriterion);
    procedure ComposeImmunizationRecommendationRecommendationProtocol(xml : TXmlBuilder; name : string; elem : TFhirImmunizationRecommendationRecommendationProtocol);
    procedure ComposeImmunizationRecommendationRecommendationProtocolChildren(xml : TXmlBuilder; elem : TFhirImmunizationRecommendationRecommendationProtocol);
    procedure ComposeImmunizationRecommendation(xml : TXmlBuilder; name : string; elem : TFhirImmunizationRecommendation);
    procedure ComposeImmunizationRecommendationChildren(xml : TXmlBuilder; elem : TFhirImmunizationRecommendation);
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
    procedure ComposeImplementationGuideContact(xml : TXmlBuilder; name : string; elem : TFhirImplementationGuideContact);
    procedure ComposeImplementationGuideContactChildren(xml : TXmlBuilder; elem : TFhirImplementationGuideContact);
    procedure ComposeImplementationGuideDependency(xml : TXmlBuilder; name : string; elem : TFhirImplementationGuideDependency);
    procedure ComposeImplementationGuideDependencyChildren(xml : TXmlBuilder; elem : TFhirImplementationGuideDependency);
    procedure ComposeImplementationGuidePackage(xml : TXmlBuilder; name : string; elem : TFhirImplementationGuidePackage);
    procedure ComposeImplementationGuidePackageChildren(xml : TXmlBuilder; elem : TFhirImplementationGuidePackage);
    procedure ComposeImplementationGuidePackageResource(xml : TXmlBuilder; name : string; elem : TFhirImplementationGuidePackageResource);
    procedure ComposeImplementationGuidePackageResourceChildren(xml : TXmlBuilder; elem : TFhirImplementationGuidePackageResource);
    procedure ComposeImplementationGuideGlobal(xml : TXmlBuilder; name : string; elem : TFhirImplementationGuideGlobal);
    procedure ComposeImplementationGuideGlobalChildren(xml : TXmlBuilder; elem : TFhirImplementationGuideGlobal);
    procedure ComposeImplementationGuidePage(xml : TXmlBuilder; name : string; elem : TFhirImplementationGuidePage);
    procedure ComposeImplementationGuidePageChildren(xml : TXmlBuilder; elem : TFhirImplementationGuidePage);
    procedure ComposeImplementationGuide(xml : TXmlBuilder; name : string; elem : TFhirImplementationGuide);
    procedure ComposeImplementationGuideChildren(xml : TXmlBuilder; elem : TFhirImplementationGuide);
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_LIST}
    procedure ComposeListEntry(xml : TXmlBuilder; name : string; elem : TFhirListEntry);
    procedure ComposeListEntryChildren(xml : TXmlBuilder; elem : TFhirListEntry);
    procedure ComposeList(xml : TXmlBuilder; name : string; elem : TFhirList);
    procedure ComposeListChildren(xml : TXmlBuilder; elem : TFhirList);
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
    procedure ComposeLocationPosition(xml : TXmlBuilder; name : string; elem : TFhirLocationPosition);
    procedure ComposeLocationPositionChildren(xml : TXmlBuilder; elem : TFhirLocationPosition);
    procedure ComposeLocation(xml : TXmlBuilder; name : string; elem : TFhirLocation);
    procedure ComposeLocationChildren(xml : TXmlBuilder; elem : TFhirLocation);
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEDIA}
    procedure ComposeMedia(xml : TXmlBuilder; name : string; elem : TFhirMedia);
    procedure ComposeMediaChildren(xml : TXmlBuilder; elem : TFhirMedia);
{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
    procedure ComposeMedicationProduct(xml : TXmlBuilder; name : string; elem : TFhirMedicationProduct);
    procedure ComposeMedicationProductChildren(xml : TXmlBuilder; elem : TFhirMedicationProduct);
    procedure ComposeMedicationProductIngredient(xml : TXmlBuilder; name : string; elem : TFhirMedicationProductIngredient);
    procedure ComposeMedicationProductIngredientChildren(xml : TXmlBuilder; elem : TFhirMedicationProductIngredient);
    procedure ComposeMedicationProductBatch(xml : TXmlBuilder; name : string; elem : TFhirMedicationProductBatch);
    procedure ComposeMedicationProductBatchChildren(xml : TXmlBuilder; elem : TFhirMedicationProductBatch);
    procedure ComposeMedicationPackage(xml : TXmlBuilder; name : string; elem : TFhirMedicationPackage);
    procedure ComposeMedicationPackageChildren(xml : TXmlBuilder; elem : TFhirMedicationPackage);
    procedure ComposeMedicationPackageContent(xml : TXmlBuilder; name : string; elem : TFhirMedicationPackageContent);
    procedure ComposeMedicationPackageContentChildren(xml : TXmlBuilder; elem : TFhirMedicationPackageContent);
    procedure ComposeMedication(xml : TXmlBuilder; name : string; elem : TFhirMedication);
    procedure ComposeMedicationChildren(xml : TXmlBuilder; elem : TFhirMedication);
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
    procedure ComposeMedicationAdministrationDosage(xml : TXmlBuilder; name : string; elem : TFhirMedicationAdministrationDosage);
    procedure ComposeMedicationAdministrationDosageChildren(xml : TXmlBuilder; elem : TFhirMedicationAdministrationDosage);
    procedure ComposeMedicationAdministration(xml : TXmlBuilder; name : string; elem : TFhirMedicationAdministration);
    procedure ComposeMedicationAdministrationChildren(xml : TXmlBuilder; elem : TFhirMedicationAdministration);
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
    procedure ComposeMedicationDispenseDosageInstruction(xml : TXmlBuilder; name : string; elem : TFhirMedicationDispenseDosageInstruction);
    procedure ComposeMedicationDispenseDosageInstructionChildren(xml : TXmlBuilder; elem : TFhirMedicationDispenseDosageInstruction);
    procedure ComposeMedicationDispenseSubstitution(xml : TXmlBuilder; name : string; elem : TFhirMedicationDispenseSubstitution);
    procedure ComposeMedicationDispenseSubstitutionChildren(xml : TXmlBuilder; elem : TFhirMedicationDispenseSubstitution);
    procedure ComposeMedicationDispense(xml : TXmlBuilder; name : string; elem : TFhirMedicationDispense);
    procedure ComposeMedicationDispenseChildren(xml : TXmlBuilder; elem : TFhirMedicationDispense);
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONORDER}
    procedure ComposeMedicationOrderDosageInstruction(xml : TXmlBuilder; name : string; elem : TFhirMedicationOrderDosageInstruction);
    procedure ComposeMedicationOrderDosageInstructionChildren(xml : TXmlBuilder; elem : TFhirMedicationOrderDosageInstruction);
    procedure ComposeMedicationOrderDispenseRequest(xml : TXmlBuilder; name : string; elem : TFhirMedicationOrderDispenseRequest);
    procedure ComposeMedicationOrderDispenseRequestChildren(xml : TXmlBuilder; elem : TFhirMedicationOrderDispenseRequest);
    procedure ComposeMedicationOrderSubstitution(xml : TXmlBuilder; name : string; elem : TFhirMedicationOrderSubstitution);
    procedure ComposeMedicationOrderSubstitutionChildren(xml : TXmlBuilder; elem : TFhirMedicationOrderSubstitution);
    procedure ComposeMedicationOrder(xml : TXmlBuilder; name : string; elem : TFhirMedicationOrder);
    procedure ComposeMedicationOrderChildren(xml : TXmlBuilder; elem : TFhirMedicationOrder);
{$ENDIF FHIR_MEDICATIONORDER}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
    procedure ComposeMedicationStatementDosage(xml : TXmlBuilder; name : string; elem : TFhirMedicationStatementDosage);
    procedure ComposeMedicationStatementDosageChildren(xml : TXmlBuilder; elem : TFhirMedicationStatementDosage);
    procedure ComposeMedicationStatement(xml : TXmlBuilder; name : string; elem : TFhirMedicationStatement);
    procedure ComposeMedicationStatementChildren(xml : TXmlBuilder; elem : TFhirMedicationStatement);
{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MESSAGEHEADER}
    procedure ComposeMessageHeaderResponse(xml : TXmlBuilder; name : string; elem : TFhirMessageHeaderResponse);
    procedure ComposeMessageHeaderResponseChildren(xml : TXmlBuilder; elem : TFhirMessageHeaderResponse);
    procedure ComposeMessageHeaderSource(xml : TXmlBuilder; name : string; elem : TFhirMessageHeaderSource);
    procedure ComposeMessageHeaderSourceChildren(xml : TXmlBuilder; elem : TFhirMessageHeaderSource);
    procedure ComposeMessageHeaderDestination(xml : TXmlBuilder; name : string; elem : TFhirMessageHeaderDestination);
    procedure ComposeMessageHeaderDestinationChildren(xml : TXmlBuilder; elem : TFhirMessageHeaderDestination);
    procedure ComposeMessageHeader(xml : TXmlBuilder; name : string; elem : TFhirMessageHeader);
    procedure ComposeMessageHeaderChildren(xml : TXmlBuilder; elem : TFhirMessageHeader);
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_NAMINGSYSTEM}
    procedure ComposeNamingSystemContact(xml : TXmlBuilder; name : string; elem : TFhirNamingSystemContact);
    procedure ComposeNamingSystemContactChildren(xml : TXmlBuilder; elem : TFhirNamingSystemContact);
    procedure ComposeNamingSystemUniqueId(xml : TXmlBuilder; name : string; elem : TFhirNamingSystemUniqueId);
    procedure ComposeNamingSystemUniqueIdChildren(xml : TXmlBuilder; elem : TFhirNamingSystemUniqueId);
    procedure ComposeNamingSystem(xml : TXmlBuilder; name : string; elem : TFhirNamingSystem);
    procedure ComposeNamingSystemChildren(xml : TXmlBuilder; elem : TFhirNamingSystem);
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
    procedure ComposeNutritionOrderOralDiet(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrderOralDiet);
    procedure ComposeNutritionOrderOralDietChildren(xml : TXmlBuilder; elem : TFhirNutritionOrderOralDiet);
    procedure ComposeNutritionOrderOralDietNutrient(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrderOralDietNutrient);
    procedure ComposeNutritionOrderOralDietNutrientChildren(xml : TXmlBuilder; elem : TFhirNutritionOrderOralDietNutrient);
    procedure ComposeNutritionOrderOralDietTexture(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrderOralDietTexture);
    procedure ComposeNutritionOrderOralDietTextureChildren(xml : TXmlBuilder; elem : TFhirNutritionOrderOralDietTexture);
    procedure ComposeNutritionOrderSupplement(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrderSupplement);
    procedure ComposeNutritionOrderSupplementChildren(xml : TXmlBuilder; elem : TFhirNutritionOrderSupplement);
    procedure ComposeNutritionOrderEnteralFormula(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrderEnteralFormula);
    procedure ComposeNutritionOrderEnteralFormulaChildren(xml : TXmlBuilder; elem : TFhirNutritionOrderEnteralFormula);
    procedure ComposeNutritionOrderEnteralFormulaAdministration(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrderEnteralFormulaAdministration);
    procedure ComposeNutritionOrderEnteralFormulaAdministrationChildren(xml : TXmlBuilder; elem : TFhirNutritionOrderEnteralFormulaAdministration);
    procedure ComposeNutritionOrder(xml : TXmlBuilder; name : string; elem : TFhirNutritionOrder);
    procedure ComposeNutritionOrderChildren(xml : TXmlBuilder; elem : TFhirNutritionOrder);
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
    procedure ComposeObservationReferenceRange(xml : TXmlBuilder; name : string; elem : TFhirObservationReferenceRange);
    procedure ComposeObservationReferenceRangeChildren(xml : TXmlBuilder; elem : TFhirObservationReferenceRange);
    procedure ComposeObservationRelated(xml : TXmlBuilder; name : string; elem : TFhirObservationRelated);
    procedure ComposeObservationRelatedChildren(xml : TXmlBuilder; elem : TFhirObservationRelated);
    procedure ComposeObservationComponent(xml : TXmlBuilder; name : string; elem : TFhirObservationComponent);
    procedure ComposeObservationComponentChildren(xml : TXmlBuilder; elem : TFhirObservationComponent);
    procedure ComposeObservation(xml : TXmlBuilder; name : string; elem : TFhirObservation);
    procedure ComposeObservationChildren(xml : TXmlBuilder; elem : TFhirObservation);
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OPERATIONDEFINITION}
    procedure ComposeOperationDefinitionContact(xml : TXmlBuilder; name : string; elem : TFhirOperationDefinitionContact);
    procedure ComposeOperationDefinitionContactChildren(xml : TXmlBuilder; elem : TFhirOperationDefinitionContact);
    procedure ComposeOperationDefinitionParameter(xml : TXmlBuilder; name : string; elem : TFhirOperationDefinitionParameter);
    procedure ComposeOperationDefinitionParameterChildren(xml : TXmlBuilder; elem : TFhirOperationDefinitionParameter);
    procedure ComposeOperationDefinitionParameterBinding(xml : TXmlBuilder; name : string; elem : TFhirOperationDefinitionParameterBinding);
    procedure ComposeOperationDefinitionParameterBindingChildren(xml : TXmlBuilder; elem : TFhirOperationDefinitionParameterBinding);
    procedure ComposeOperationDefinition(xml : TXmlBuilder; name : string; elem : TFhirOperationDefinition);
    procedure ComposeOperationDefinitionChildren(xml : TXmlBuilder; elem : TFhirOperationDefinition);
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
    procedure ComposeOperationOutcomeIssue(xml : TXmlBuilder; name : string; elem : TFhirOperationOutcomeIssue);
    procedure ComposeOperationOutcomeIssueChildren(xml : TXmlBuilder; elem : TFhirOperationOutcomeIssue);
    procedure ComposeOperationOutcome(xml : TXmlBuilder; name : string; elem : TFhirOperationOutcome);
    procedure ComposeOperationOutcomeChildren(xml : TXmlBuilder; elem : TFhirOperationOutcome);
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORDER}
    procedure ComposeOrderWhen(xml : TXmlBuilder; name : string; elem : TFhirOrderWhen);
    procedure ComposeOrderWhenChildren(xml : TXmlBuilder; elem : TFhirOrderWhen);
    procedure ComposeOrder(xml : TXmlBuilder; name : string; elem : TFhirOrder);
    procedure ComposeOrderChildren(xml : TXmlBuilder; elem : TFhirOrder);
{$ENDIF FHIR_ORDER}
{$IFDEF FHIR_ORDERRESPONSE}
    procedure ComposeOrderResponse(xml : TXmlBuilder; name : string; elem : TFhirOrderResponse);
    procedure ComposeOrderResponseChildren(xml : TXmlBuilder; elem : TFhirOrderResponse);
{$ENDIF FHIR_ORDERRESPONSE}
{$IFDEF FHIR_ORGANIZATION}
    procedure ComposeOrganizationContact(xml : TXmlBuilder; name : string; elem : TFhirOrganizationContact);
    procedure ComposeOrganizationContactChildren(xml : TXmlBuilder; elem : TFhirOrganizationContact);
    procedure ComposeOrganization(xml : TXmlBuilder; name : string; elem : TFhirOrganization);
    procedure ComposeOrganizationChildren(xml : TXmlBuilder; elem : TFhirOrganization);
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_PATIENT}
    procedure ComposePatientContact(xml : TXmlBuilder; name : string; elem : TFhirPatientContact);
    procedure ComposePatientContactChildren(xml : TXmlBuilder; elem : TFhirPatientContact);
    procedure ComposePatientAnimal(xml : TXmlBuilder; name : string; elem : TFhirPatientAnimal);
    procedure ComposePatientAnimalChildren(xml : TXmlBuilder; elem : TFhirPatientAnimal);
    procedure ComposePatientCommunication(xml : TXmlBuilder; name : string; elem : TFhirPatientCommunication);
    procedure ComposePatientCommunicationChildren(xml : TXmlBuilder; elem : TFhirPatientCommunication);
    procedure ComposePatientLink(xml : TXmlBuilder; name : string; elem : TFhirPatientLink);
    procedure ComposePatientLinkChildren(xml : TXmlBuilder; elem : TFhirPatientLink);
    procedure ComposePatient(xml : TXmlBuilder; name : string; elem : TFhirPatient);
    procedure ComposePatientChildren(xml : TXmlBuilder; elem : TFhirPatient);
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
    procedure ComposePaymentNotice(xml : TXmlBuilder; name : string; elem : TFhirPaymentNotice);
    procedure ComposePaymentNoticeChildren(xml : TXmlBuilder; elem : TFhirPaymentNotice);
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
    procedure ComposePaymentReconciliationDetail(xml : TXmlBuilder; name : string; elem : TFhirPaymentReconciliationDetail);
    procedure ComposePaymentReconciliationDetailChildren(xml : TXmlBuilder; elem : TFhirPaymentReconciliationDetail);
    procedure ComposePaymentReconciliationNote(xml : TXmlBuilder; name : string; elem : TFhirPaymentReconciliationNote);
    procedure ComposePaymentReconciliationNoteChildren(xml : TXmlBuilder; elem : TFhirPaymentReconciliationNote);
    procedure ComposePaymentReconciliation(xml : TXmlBuilder; name : string; elem : TFhirPaymentReconciliation);
    procedure ComposePaymentReconciliationChildren(xml : TXmlBuilder; elem : TFhirPaymentReconciliation);
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
    procedure ComposePersonLink(xml : TXmlBuilder; name : string; elem : TFhirPersonLink);
    procedure ComposePersonLinkChildren(xml : TXmlBuilder; elem : TFhirPersonLink);
    procedure ComposePerson(xml : TXmlBuilder; name : string; elem : TFhirPerson);
    procedure ComposePersonChildren(xml : TXmlBuilder; elem : TFhirPerson);
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PRACTITIONER}
    procedure ComposePractitionerPractitionerRole(xml : TXmlBuilder; name : string; elem : TFhirPractitionerPractitionerRole);
    procedure ComposePractitionerPractitionerRoleChildren(xml : TXmlBuilder; elem : TFhirPractitionerPractitionerRole);
    procedure ComposePractitionerQualification(xml : TXmlBuilder; name : string; elem : TFhirPractitionerQualification);
    procedure ComposePractitionerQualificationChildren(xml : TXmlBuilder; elem : TFhirPractitionerQualification);
    procedure ComposePractitioner(xml : TXmlBuilder; name : string; elem : TFhirPractitioner);
    procedure ComposePractitionerChildren(xml : TXmlBuilder; elem : TFhirPractitioner);
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PROCEDURE}
    procedure ComposeProcedurePerformer(xml : TXmlBuilder; name : string; elem : TFhirProcedurePerformer);
    procedure ComposeProcedurePerformerChildren(xml : TXmlBuilder; elem : TFhirProcedurePerformer);
    procedure ComposeProcedureFocalDevice(xml : TXmlBuilder; name : string; elem : TFhirProcedureFocalDevice);
    procedure ComposeProcedureFocalDeviceChildren(xml : TXmlBuilder; elem : TFhirProcedureFocalDevice);
    procedure ComposeProcedure(xml : TXmlBuilder; name : string; elem : TFhirProcedure);
    procedure ComposeProcedureChildren(xml : TXmlBuilder; elem : TFhirProcedure);
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROCEDUREREQUEST}
    procedure ComposeProcedureRequest(xml : TXmlBuilder; name : string; elem : TFhirProcedureRequest);
    procedure ComposeProcedureRequestChildren(xml : TXmlBuilder; elem : TFhirProcedureRequest);
{$ENDIF FHIR_PROCEDUREREQUEST}
{$IFDEF FHIR_PROCESSREQUEST}
    procedure ComposeProcessRequestItem(xml : TXmlBuilder; name : string; elem : TFhirProcessRequestItem);
    procedure ComposeProcessRequestItemChildren(xml : TXmlBuilder; elem : TFhirProcessRequestItem);
    procedure ComposeProcessRequest(xml : TXmlBuilder; name : string; elem : TFhirProcessRequest);
    procedure ComposeProcessRequestChildren(xml : TXmlBuilder; elem : TFhirProcessRequest);
{$ENDIF FHIR_PROCESSREQUEST}
{$IFDEF FHIR_PROCESSRESPONSE}
    procedure ComposeProcessResponseNotes(xml : TXmlBuilder; name : string; elem : TFhirProcessResponseNotes);
    procedure ComposeProcessResponseNotesChildren(xml : TXmlBuilder; elem : TFhirProcessResponseNotes);
    procedure ComposeProcessResponse(xml : TXmlBuilder; name : string; elem : TFhirProcessResponse);
    procedure ComposeProcessResponseChildren(xml : TXmlBuilder; elem : TFhirProcessResponse);
{$ENDIF FHIR_PROCESSRESPONSE}
{$IFDEF FHIR_PROVENANCE}
    procedure ComposeProvenanceAgent(xml : TXmlBuilder; name : string; elem : TFhirProvenanceAgent);
    procedure ComposeProvenanceAgentChildren(xml : TXmlBuilder; elem : TFhirProvenanceAgent);
    procedure ComposeProvenanceAgentRelatedAgent(xml : TXmlBuilder; name : string; elem : TFhirProvenanceAgentRelatedAgent);
    procedure ComposeProvenanceAgentRelatedAgentChildren(xml : TXmlBuilder; elem : TFhirProvenanceAgentRelatedAgent);
    procedure ComposeProvenanceEntity(xml : TXmlBuilder; name : string; elem : TFhirProvenanceEntity);
    procedure ComposeProvenanceEntityChildren(xml : TXmlBuilder; elem : TFhirProvenanceEntity);
    procedure ComposeProvenance(xml : TXmlBuilder; name : string; elem : TFhirProvenance);
    procedure ComposeProvenanceChildren(xml : TXmlBuilder; elem : TFhirProvenance);
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
    procedure ComposeQuestionnaireGroup(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireGroup);
    procedure ComposeQuestionnaireGroupChildren(xml : TXmlBuilder; elem : TFhirQuestionnaireGroup);
    procedure ComposeQuestionnaireGroupQuestion(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireGroupQuestion);
    procedure ComposeQuestionnaireGroupQuestionChildren(xml : TXmlBuilder; elem : TFhirQuestionnaireGroupQuestion);
    procedure ComposeQuestionnaire(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaire);
    procedure ComposeQuestionnaireChildren(xml : TXmlBuilder; elem : TFhirQuestionnaire);
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
    procedure ComposeQuestionnaireResponseGroup(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireResponseGroup);
    procedure ComposeQuestionnaireResponseGroupChildren(xml : TXmlBuilder; elem : TFhirQuestionnaireResponseGroup);
    procedure ComposeQuestionnaireResponseGroupQuestion(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireResponseGroupQuestion);
    procedure ComposeQuestionnaireResponseGroupQuestionChildren(xml : TXmlBuilder; elem : TFhirQuestionnaireResponseGroupQuestion);
    procedure ComposeQuestionnaireResponseGroupQuestionAnswer(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireResponseGroupQuestionAnswer);
    procedure ComposeQuestionnaireResponseGroupQuestionAnswerChildren(xml : TXmlBuilder; elem : TFhirQuestionnaireResponseGroupQuestionAnswer);
    procedure ComposeQuestionnaireResponse(xml : TXmlBuilder; name : string; elem : TFhirQuestionnaireResponse);
    procedure ComposeQuestionnaireResponseChildren(xml : TXmlBuilder; elem : TFhirQuestionnaireResponse);
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REFERRALREQUEST}
    procedure ComposeReferralRequest(xml : TXmlBuilder; name : string; elem : TFhirReferralRequest);
    procedure ComposeReferralRequestChildren(xml : TXmlBuilder; elem : TFhirReferralRequest);
{$ENDIF FHIR_REFERRALREQUEST}
{$IFDEF FHIR_RELATEDPERSON}
    procedure ComposeRelatedPerson(xml : TXmlBuilder; name : string; elem : TFhirRelatedPerson);
    procedure ComposeRelatedPersonChildren(xml : TXmlBuilder; elem : TFhirRelatedPerson);
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_RISKASSESSMENT}
    procedure ComposeRiskAssessmentPrediction(xml : TXmlBuilder; name : string; elem : TFhirRiskAssessmentPrediction);
    procedure ComposeRiskAssessmentPredictionChildren(xml : TXmlBuilder; elem : TFhirRiskAssessmentPrediction);
    procedure ComposeRiskAssessment(xml : TXmlBuilder; name : string; elem : TFhirRiskAssessment);
    procedure ComposeRiskAssessmentChildren(xml : TXmlBuilder; elem : TFhirRiskAssessment);
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
    procedure ComposeSchedule(xml : TXmlBuilder; name : string; elem : TFhirSchedule);
    procedure ComposeScheduleChildren(xml : TXmlBuilder; elem : TFhirSchedule);
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
    procedure ComposeSearchParameterContact(xml : TXmlBuilder; name : string; elem : TFhirSearchParameterContact);
    procedure ComposeSearchParameterContactChildren(xml : TXmlBuilder; elem : TFhirSearchParameterContact);
    procedure ComposeSearchParameter(xml : TXmlBuilder; name : string; elem : TFhirSearchParameter);
    procedure ComposeSearchParameterChildren(xml : TXmlBuilder; elem : TFhirSearchParameter);
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SLOT}
    procedure ComposeSlot(xml : TXmlBuilder; name : string; elem : TFhirSlot);
    procedure ComposeSlotChildren(xml : TXmlBuilder; elem : TFhirSlot);
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
    procedure ComposeSpecimenCollection(xml : TXmlBuilder; name : string; elem : TFhirSpecimenCollection);
    procedure ComposeSpecimenCollectionChildren(xml : TXmlBuilder; elem : TFhirSpecimenCollection);
    procedure ComposeSpecimenTreatment(xml : TXmlBuilder; name : string; elem : TFhirSpecimenTreatment);
    procedure ComposeSpecimenTreatmentChildren(xml : TXmlBuilder; elem : TFhirSpecimenTreatment);
    procedure ComposeSpecimenContainer(xml : TXmlBuilder; name : string; elem : TFhirSpecimenContainer);
    procedure ComposeSpecimenContainerChildren(xml : TXmlBuilder; elem : TFhirSpecimenContainer);
    procedure ComposeSpecimen(xml : TXmlBuilder; name : string; elem : TFhirSpecimen);
    procedure ComposeSpecimenChildren(xml : TXmlBuilder; elem : TFhirSpecimen);
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_STRUCTUREDEFINITION}
    procedure ComposeStructureDefinitionContact(xml : TXmlBuilder; name : string; elem : TFhirStructureDefinitionContact);
    procedure ComposeStructureDefinitionContactChildren(xml : TXmlBuilder; elem : TFhirStructureDefinitionContact);
    procedure ComposeStructureDefinitionMapping(xml : TXmlBuilder; name : string; elem : TFhirStructureDefinitionMapping);
    procedure ComposeStructureDefinitionMappingChildren(xml : TXmlBuilder; elem : TFhirStructureDefinitionMapping);
    procedure ComposeStructureDefinitionSnapshot(xml : TXmlBuilder; name : string; elem : TFhirStructureDefinitionSnapshot);
    procedure ComposeStructureDefinitionSnapshotChildren(xml : TXmlBuilder; elem : TFhirStructureDefinitionSnapshot);
    procedure ComposeStructureDefinitionDifferential(xml : TXmlBuilder; name : string; elem : TFhirStructureDefinitionDifferential);
    procedure ComposeStructureDefinitionDifferentialChildren(xml : TXmlBuilder; elem : TFhirStructureDefinitionDifferential);
    procedure ComposeStructureDefinition(xml : TXmlBuilder; name : string; elem : TFhirStructureDefinition);
    procedure ComposeStructureDefinitionChildren(xml : TXmlBuilder; elem : TFhirStructureDefinition);
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_SUBSCRIPTION}
    procedure ComposeSubscriptionChannel(xml : TXmlBuilder; name : string; elem : TFhirSubscriptionChannel);
    procedure ComposeSubscriptionChannelChildren(xml : TXmlBuilder; elem : TFhirSubscriptionChannel);
    procedure ComposeSubscription(xml : TXmlBuilder; name : string; elem : TFhirSubscription);
    procedure ComposeSubscriptionChildren(xml : TXmlBuilder; elem : TFhirSubscription);
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
    procedure ComposeSubstanceInstance(xml : TXmlBuilder; name : string; elem : TFhirSubstanceInstance);
    procedure ComposeSubstanceInstanceChildren(xml : TXmlBuilder; elem : TFhirSubstanceInstance);
    procedure ComposeSubstanceIngredient(xml : TXmlBuilder; name : string; elem : TFhirSubstanceIngredient);
    procedure ComposeSubstanceIngredientChildren(xml : TXmlBuilder; elem : TFhirSubstanceIngredient);
    procedure ComposeSubstance(xml : TXmlBuilder; name : string; elem : TFhirSubstance);
    procedure ComposeSubstanceChildren(xml : TXmlBuilder; elem : TFhirSubstance);
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUPPLYDELIVERY}
    procedure ComposeSupplyDelivery(xml : TXmlBuilder; name : string; elem : TFhirSupplyDelivery);
    procedure ComposeSupplyDeliveryChildren(xml : TXmlBuilder; elem : TFhirSupplyDelivery);
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
    procedure ComposeSupplyRequestWhen(xml : TXmlBuilder; name : string; elem : TFhirSupplyRequestWhen);
    procedure ComposeSupplyRequestWhenChildren(xml : TXmlBuilder; elem : TFhirSupplyRequestWhen);
    procedure ComposeSupplyRequest(xml : TXmlBuilder; name : string; elem : TFhirSupplyRequest);
    procedure ComposeSupplyRequestChildren(xml : TXmlBuilder; elem : TFhirSupplyRequest);
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TESTSCRIPT}
    procedure ComposeTestScriptContact(xml : TXmlBuilder; name : string; elem : TFhirTestScriptContact);
    procedure ComposeTestScriptContactChildren(xml : TXmlBuilder; elem : TFhirTestScriptContact);
    procedure ComposeTestScriptMetadata(xml : TXmlBuilder; name : string; elem : TFhirTestScriptMetadata);
    procedure ComposeTestScriptMetadataChildren(xml : TXmlBuilder; elem : TFhirTestScriptMetadata);
    procedure ComposeTestScriptMetadataLink(xml : TXmlBuilder; name : string; elem : TFhirTestScriptMetadataLink);
    procedure ComposeTestScriptMetadataLinkChildren(xml : TXmlBuilder; elem : TFhirTestScriptMetadataLink);
    procedure ComposeTestScriptMetadataCapability(xml : TXmlBuilder; name : string; elem : TFhirTestScriptMetadataCapability);
    procedure ComposeTestScriptMetadataCapabilityChildren(xml : TXmlBuilder; elem : TFhirTestScriptMetadataCapability);
    procedure ComposeTestScriptFixture(xml : TXmlBuilder; name : string; elem : TFhirTestScriptFixture);
    procedure ComposeTestScriptFixtureChildren(xml : TXmlBuilder; elem : TFhirTestScriptFixture);
    procedure ComposeTestScriptVariable(xml : TXmlBuilder; name : string; elem : TFhirTestScriptVariable);
    procedure ComposeTestScriptVariableChildren(xml : TXmlBuilder; elem : TFhirTestScriptVariable);
    procedure ComposeTestScriptSetup(xml : TXmlBuilder; name : string; elem : TFhirTestScriptSetup);
    procedure ComposeTestScriptSetupChildren(xml : TXmlBuilder; elem : TFhirTestScriptSetup);
    procedure ComposeTestScriptSetupAction(xml : TXmlBuilder; name : string; elem : TFhirTestScriptSetupAction);
    procedure ComposeTestScriptSetupActionChildren(xml : TXmlBuilder; elem : TFhirTestScriptSetupAction);
    procedure ComposeTestScriptSetupActionOperation(xml : TXmlBuilder; name : string; elem : TFhirTestScriptSetupActionOperation);
    procedure ComposeTestScriptSetupActionOperationChildren(xml : TXmlBuilder; elem : TFhirTestScriptSetupActionOperation);
    procedure ComposeTestScriptSetupActionOperationRequestHeader(xml : TXmlBuilder; name : string; elem : TFhirTestScriptSetupActionOperationRequestHeader);
    procedure ComposeTestScriptSetupActionOperationRequestHeaderChildren(xml : TXmlBuilder; elem : TFhirTestScriptSetupActionOperationRequestHeader);
    procedure ComposeTestScriptSetupActionAssert(xml : TXmlBuilder; name : string; elem : TFhirTestScriptSetupActionAssert);
    procedure ComposeTestScriptSetupActionAssertChildren(xml : TXmlBuilder; elem : TFhirTestScriptSetupActionAssert);
    procedure ComposeTestScriptTest(xml : TXmlBuilder; name : string; elem : TFhirTestScriptTest);
    procedure ComposeTestScriptTestChildren(xml : TXmlBuilder; elem : TFhirTestScriptTest);
    procedure ComposeTestScriptTestAction(xml : TXmlBuilder; name : string; elem : TFhirTestScriptTestAction);
    procedure ComposeTestScriptTestActionChildren(xml : TXmlBuilder; elem : TFhirTestScriptTestAction);
    procedure ComposeTestScriptTeardown(xml : TXmlBuilder; name : string; elem : TFhirTestScriptTeardown);
    procedure ComposeTestScriptTeardownChildren(xml : TXmlBuilder; elem : TFhirTestScriptTeardown);
    procedure ComposeTestScriptTeardownAction(xml : TXmlBuilder; name : string; elem : TFhirTestScriptTeardownAction);
    procedure ComposeTestScriptTeardownActionChildren(xml : TXmlBuilder; elem : TFhirTestScriptTeardownAction);
    procedure ComposeTestScript(xml : TXmlBuilder; name : string; elem : TFhirTestScript);
    procedure ComposeTestScriptChildren(xml : TXmlBuilder; elem : TFhirTestScript);
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
    procedure ComposeValueSetContact(xml : TXmlBuilder; name : string; elem : TFhirValueSetContact);
    procedure ComposeValueSetContactChildren(xml : TXmlBuilder; elem : TFhirValueSetContact);
    procedure ComposeValueSetCodeSystem(xml : TXmlBuilder; name : string; elem : TFhirValueSetCodeSystem);
    procedure ComposeValueSetCodeSystemChildren(xml : TXmlBuilder; elem : TFhirValueSetCodeSystem);
    procedure ComposeValueSetCodeSystemConcept(xml : TXmlBuilder; name : string; elem : TFhirValueSetCodeSystemConcept);
    procedure ComposeValueSetCodeSystemConceptChildren(xml : TXmlBuilder; elem : TFhirValueSetCodeSystemConcept);
    procedure ComposeValueSetCodeSystemConceptDesignation(xml : TXmlBuilder; name : string; elem : TFhirValueSetCodeSystemConceptDesignation);
    procedure ComposeValueSetCodeSystemConceptDesignationChildren(xml : TXmlBuilder; elem : TFhirValueSetCodeSystemConceptDesignation);
    procedure ComposeValueSetCompose(xml : TXmlBuilder; name : string; elem : TFhirValueSetCompose);
    procedure ComposeValueSetComposeChildren(xml : TXmlBuilder; elem : TFhirValueSetCompose);
    procedure ComposeValueSetComposeInclude(xml : TXmlBuilder; name : string; elem : TFhirValueSetComposeInclude);
    procedure ComposeValueSetComposeIncludeChildren(xml : TXmlBuilder; elem : TFhirValueSetComposeInclude);
    procedure ComposeValueSetComposeIncludeConcept(xml : TXmlBuilder; name : string; elem : TFhirValueSetComposeIncludeConcept);
    procedure ComposeValueSetComposeIncludeConceptChildren(xml : TXmlBuilder; elem : TFhirValueSetComposeIncludeConcept);
    procedure ComposeValueSetComposeIncludeFilter(xml : TXmlBuilder; name : string; elem : TFhirValueSetComposeIncludeFilter);
    procedure ComposeValueSetComposeIncludeFilterChildren(xml : TXmlBuilder; elem : TFhirValueSetComposeIncludeFilter);
    procedure ComposeValueSetExpansion(xml : TXmlBuilder; name : string; elem : TFhirValueSetExpansion);
    procedure ComposeValueSetExpansionChildren(xml : TXmlBuilder; elem : TFhirValueSetExpansion);
    procedure ComposeValueSetExpansionParameter(xml : TXmlBuilder; name : string; elem : TFhirValueSetExpansionParameter);
    procedure ComposeValueSetExpansionParameterChildren(xml : TXmlBuilder; elem : TFhirValueSetExpansionParameter);
    procedure ComposeValueSetExpansionContains(xml : TXmlBuilder; name : string; elem : TFhirValueSetExpansionContains);
    procedure ComposeValueSetExpansionContainsChildren(xml : TXmlBuilder; elem : TFhirValueSetExpansionContains);
    procedure ComposeValueSet(xml : TXmlBuilder; name : string; elem : TFhirValueSet);
    procedure ComposeValueSetChildren(xml : TXmlBuilder; elem : TFhirValueSet);
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VISIONPRESCRIPTION}
    procedure ComposeVisionPrescriptionDispense(xml : TXmlBuilder; name : string; elem : TFhirVisionPrescriptionDispense);
    procedure ComposeVisionPrescriptionDispenseChildren(xml : TXmlBuilder; elem : TFhirVisionPrescriptionDispense);
    procedure ComposeVisionPrescription(xml : TXmlBuilder; name : string; elem : TFhirVisionPrescription);
    procedure ComposeVisionPrescriptionChildren(xml : TXmlBuilder; elem : TFhirVisionPrescription);
{$ENDIF FHIR_VISIONPRESCRIPTION}
    procedure ComposeResource(xml : TXmlBuilder; resource : TFhirResource); override;
  public
    procedure ComposeBase(xml : TXmlBuilder; name : String; base : TFHIRObject); override;
  end;


implementation

{ TFHIRXmlParser }

function TFHIRXmlParser.ParseElement(element : TMXmlElement; path : string) : TFhirElement;
var
  child : TMXmlElement;
begin
  result := TFhirElement.create;
  try
    parseElementAttributes(result, path, element);
    result.id := GetAttribute(element, 'id');{x.4}
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseElementChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeElement(xml : TXmlBuilder; name : String; elem : TFhirElement);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  Attribute(xml, 'id', elem.id  );
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

Procedure TFHIRXmlParser.ParseElementAttributes(value : TFhirElement; path : string; element : TMXmlElement);
begin
  TakeCommentsStart(value);
  GetObjectLocation(value, element);
  value.Id := GetAttribute(element, 'id');
end;

Function TFHIRXmlParser.ParseBackboneElementChild(element : TFhirBackboneElement; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
  if (child.localName = 'modifierExtension') then
    element.ModifierExtensionList.add(ParseExtension(child, path+'/modifierExtension'))
  else
    result := ParseElementChild(element, path, child);
end;

Function TFHIRXmlParser.ParseElementChild(element : TFhirElement; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
  if (child.localName = 'extension') then
    element.ExtensionList.add(ParseExtension(child, path+'/extension'))
  else
    result := false;
end;

Procedure TFHIRXmlComposer.ComposeElementAttributes(xml : TXmlBuilder; element : TFhirElement);
begin
  CommentsStart(xml, element);
  Attribute(xml, 'id', element.Id);
end;

Procedure TFHIRXmlComposer.ComposeElementChildren(xml : TXmlBuilder; element : TFhirElement);
var
  i : integer;
begin
  if element.hasExtensionList then
    for i := 0 to element.extensionList.count - 1 do
      ComposeExtension(xml, 'extension', element.extensionList[i]);
end;

Procedure TFHIRXmlComposer.ComposeBackboneElementChildren(xml : TXmlBuilder; element : TFhirBackboneElement);
var
  i : integer;
begin
  ComposeElementChildren(xml, element);
  if element.hasModifierExtensionList then
    for i := 0 to element.modifierExtensionList.count - 1 do
      ComposeExtension(xml, 'modifierExtension', element.modifierExtensionList[i]);
end;

function TFHIRXmlParser.ParseBackboneElement(element : TMXmlElement; path : string) : TFhirBackboneElement;
var
  child : TMXmlElement;
begin
  result := TFhirBackboneElement.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseBackboneElementChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

procedure TFHIRXmlComposer.ComposeBackboneElement(xml : TXmlBuilder; name : String; elem : TFhirBackboneElement);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeBackboneElementChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseEnum(Const aNames, aSystems : Array Of String; path : String; element : TMXmlElement) : TFhirEnum;
var
  child : TMXmlElement;
  i : integer;
begin
  result := TFhirEnum.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    i := StringArrayIndexOfSensitive(aNames, result.value);
    if i < 0 then
      raise EXmlException.Create('unknown code: '+result.value+' from a set of choices of '+StringArrayToCommaString(aNames)+' for "'+path+'"');
    result.system := aSystems[i];
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeEnum(xml : TXmlBuilder; name : String; value : TFhirEnum; Const aNames : Array Of String);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseDateTime(element : TMXmlElement; path : string) : TFhirDateTime;
var
  child : TMXmlElement;
begin
  result := TFhirDateTime.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := toTFslDateTime(GetAttribute(element, 'value'));
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeDateTime(xml : TXmlBuilder; name : String; value : TFhirDateTime);
begin
  if (value = nil) or ((value.value.null) and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  if (value.value.notNull) then
    attribute(xml, 'value', asString(value.value));
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseDate(element : TMXmlElement; path : string) : TFhirDate;
var
  child : TMXmlElement;
begin
  result := TFhirDate.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := toTFslDateTime(GetAttribute(element, 'value'));
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeDate(xml : TXmlBuilder; name : String; value : TFhirDate);
begin
  if (value = nil) or ((value.value.null) and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  if (value.value.notNull) then
    attribute(xml, 'value', asString(value.value));
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseString(element : TMXmlElement; path : string) : TFhirString;
var
  child : TMXmlElement;
begin
  result := TFhirString.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeString(xml : TXmlBuilder; name : String; value : TFhirString);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseInteger(element : TMXmlElement; path : string) : TFhirInteger;
var
  child : TMXmlElement;
begin
  result := TFhirInteger.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeInteger(xml : TXmlBuilder; name : String; value : TFhirInteger);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseUri(element : TMXmlElement; path : string) : TFhirUri;
var
  child : TMXmlElement;
begin
  result := TFhirUri.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeUri(xml : TXmlBuilder; name : String; value : TFhirUri);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseInstant(element : TMXmlElement; path : string) : TFhirInstant;
var
  child : TMXmlElement;
begin
  result := TFhirInstant.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := toTFslDateTime(GetAttribute(element, 'value'));
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeInstant(xml : TXmlBuilder; name : String; value : TFhirInstant);
begin
  if (value = nil) or ((value.value.null) and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  if (value.value.notNull) then
    attribute(xml, 'value', asString(value.value));
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseBoolean(element : TMXmlElement; path : string) : TFhirBoolean;
var
  child : TMXmlElement;
begin
  result := TFhirBoolean.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := StringToBoolean(GetAttribute(element, 'value'));
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeBoolean(xml : TXmlBuilder; name : String; value : TFhirBoolean);
begin
  if (value = nil) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', LCBooleanToString(value.value));
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseBase64Binary(element : TMXmlElement; path : string) : TFhirBase64Binary;
var
  child : TMXmlElement;
begin
  result := TFhirBase64Binary.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := toTBytes(GetAttribute(element, 'value'));
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeBase64Binary(xml : TXmlBuilder; name : String; value : TFhirBase64Binary);
begin
  if (value = nil) or ((value.value = nil) and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  if (value.value <> nil) then
    attribute(xml, 'value', asString(value.value));
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseTime(element : TMXmlElement; path : string) : TFhirTime;
var
  child : TMXmlElement;
begin
  result := TFhirTime.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeTime(xml : TXmlBuilder; name : String; value : TFhirTime);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseDecimal(element : TMXmlElement; path : string) : TFhirDecimal;
var
  child : TMXmlElement;
begin
  result := TFhirDecimal.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeDecimal(xml : TXmlBuilder; name : String; value : TFhirDecimal);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseCode(element : TMXmlElement; path : string) : TFhirCode;
var
  child : TMXmlElement;
begin
  result := TFhirCode.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeCode(xml : TXmlBuilder; name : String; value : TFhirCode);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseOid(element : TMXmlElement; path : string) : TFhirOid;
var
  child : TMXmlElement;
begin
  result := TFhirOid.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeOid(xml : TXmlBuilder; name : String; value : TFhirOid);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseUuid(element : TMXmlElement; path : string) : TFhirUuid;
var
  child : TMXmlElement;
begin
  result := TFhirUuid.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeUuid(xml : TXmlBuilder; name : String; value : TFhirUuid);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseMarkdown(element : TMXmlElement; path : string) : TFhirMarkdown;
var
  child : TMXmlElement;
begin
  result := TFhirMarkdown.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeMarkdown(xml : TXmlBuilder; name : String; value : TFhirMarkdown);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseUnsignedInt(element : TMXmlElement; path : string) : TFhirUnsignedInt;
var
  child : TMXmlElement;
begin
  result := TFhirUnsignedInt.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeUnsignedInt(xml : TXmlBuilder; name : String; value : TFhirUnsignedInt);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParseId(element : TMXmlElement; path : string) : TFhirId;
var
  child : TMXmlElement;
begin
  result := TFhirId.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposeId(xml : TXmlBuilder; name : String; value : TFhirId);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

function TFHIRXmlParser.ParsePositiveInt(element : TMXmlElement; path : string) : TFhirPositiveInt;
var
  child : TMXmlElement;
begin
  result := TFhirPositiveInt.create;
  try
    ParseElementAttributes(result, path, element);
    result.value := GetAttribute(element, 'value');
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if Not ParseElementChild(result, path, child) then
         UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

Procedure TFHIRXmlComposer.ComposePositiveInt(xml : TXmlBuilder; name : String; value : TFhirPositiveInt);
begin
  if (value = nil) or ((value.value = '') and (value.extensionList.count = 0)) then
    exit;
  composeElementAttributes(xml, value);
  attribute(xml, 'value', value.value);
  if KeepLocationData then value.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementChildren(xml, value);
  closeOutElement(xml, value);
  xml.close(name);
  if KeepLocationData then value.LocationData.ComposeFinish := xml.SourceLocation;
end;

Procedure TFHIRXmlParser.ParseResourceAttributes(resource : TFhirResource; path : string; element : TMXmlElement);
begin
  GetObjectLocation(resource, element);
end;

Function TFHIRXmlParser.ParseResourceChild(resource : TFhirResource; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
  if (child.localName = 'id') then
    resource.idElement := ParseId(child, path+'/id') {b}
  else if (child.localName = 'meta') then
    resource.meta := ParseMeta(child, path+'/meta') {b}
  else if (child.localName = 'implicitRules') then
    resource.implicitRulesElement := ParseUri(child, path+'/implicitRules') {b}
  else if (child.localName = 'language') then
    resource.languageElement := ParseCode(child, path+'/language') {b}
  else
    result := false;
end;

Procedure TFHIRXmlComposer.ComposeResourceAttributes(xml : TXmlBuilder; resource : TFhirResource);
begin
end;

Procedure TFHIRXmlComposer.ComposeResourceChildren(xml : TXmlBuilder; elem : TFhirResource);
begin
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeId(xml, 'id', elem.idElement);{x.2b}
  if (true) {SummaryOption in [soFull, soSummary, soData]) and doCompose('meta')} then
    ComposeMeta(xml, 'meta', elem.meta);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('implicitRules') then
    ComposeUri(xml, 'implicitRules', elem.implicitRulesElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('language') then
    ComposeCode(xml, 'language', elem.languageElement);{x.2b}
end;

{$IFDEF FHIR_PARAMETERS}
function TFHIRXmlParser.ParseParametersParameter(element : TMXmlElement; path : string) : TFhirParametersParameter;
var
  child : TMXmlElement;
begin
  result := TFhirParametersParameter.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseParametersParameterChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseParametersParameterChild(element : TFhirParametersParameter; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'valueCode') then
        element.value := ParseCode(child, path+'.valueCode') {c}
      else if (child.localName = 'valueOid') then
        element.value := ParseOid(child, path+'.valueOid') {c}
      else if (child.localName = 'valueUuid') then
        element.value := ParseUuid(child, path+'.valueUuid') {c}
      else if (child.localName = 'valueMarkdown') then
        element.value := ParseMarkdown(child, path+'.valueMarkdown') {c}
      else if (child.localName = 'valueUnsignedInt') then
        element.value := ParseUnsignedInt(child, path+'.valueUnsignedInt') {c}
      else if (child.localName = 'valueId') then
        element.value := ParseId(child, path+'.valueId') {c}
      else if (child.localName = 'valuePositiveInt') then
        element.value := ParsePositiveInt(child, path+'.valuePositiveInt') {c}
      else if (child.localName = 'valueDateTime') then
        element.value := ParseDateTime(child, path+'.valueDateTime') {c}
      else if (child.localName = 'valueDate') then
        element.value := ParseDate(child, path+'.valueDate') {c}
      else if (child.localName = 'valueString') then
        element.value := ParseString(child, path+'.valueString') {c}
      else if (child.localName = 'valueInteger') then
        element.value := ParseInteger(child, path+'.valueInteger') {c}
      else if (child.localName = 'valueUri') then
        element.value := ParseUri(child, path+'.valueUri') {c}
      else if (child.localName = 'valueInstant') then
        element.value := ParseInstant(child, path+'.valueInstant') {c}
      else if (child.localName = 'valueBoolean') then
        element.value := ParseBoolean(child, path+'.valueBoolean') {c}
      else if (child.localName = 'valueBase64Binary') then
        element.value := ParseBase64Binary(child, path+'.valueBase64Binary') {c}
      else if (child.localName = 'valueTime') then
        element.value := ParseTime(child, path+'.valueTime') {c}
      else if (child.localName = 'valueDecimal') then
        element.value := ParseDecimal(child, path+'.valueDecimal') {c}
      else if (child.localName = 'valueIdentifier') then
        element.value := ParseIdentifier(child, path+'.valueIdentifier') {eIdentifier}
      else if (child.localName = 'valueCoding') then
        element.value := ParseCoding(child, path+'.valueCoding') {eCoding}
      else if (child.localName = 'valueReference') then
        element.value := ParseReference(child, path+'.valueReference') {eReference}
      else if (child.localName = 'valueSignature') then
        element.value := ParseSignature(child, path+'.valueSignature') {eSignature}
      else if (child.localName = 'valueSampledData') then
        element.value := ParseSampledData(child, path+'.valueSampledData') {eSampledData}
      else if (child.localName = 'valuePeriod') then
        element.value := ParsePeriod(child, path+'.valuePeriod') {ePeriod}
      else if (child.localName = 'valueQuantity') then
        element.value := ParseQuantity(child, path+'.valueQuantity') {eQuantity}
      else if (child.localName = 'valueAttachment') then
        element.value := ParseAttachment(child, path+'.valueAttachment') {eAttachment}
      else if (child.localName = 'valueRatio') then
        element.value := ParseRatio(child, path+'.valueRatio') {eRatio}
      else if (child.localName = 'valueRange') then
        element.value := ParseRange(child, path+'.valueRange') {eRange}
      else if (child.localName = 'valueAnnotation') then
        element.value := ParseAnnotation(child, path+'.valueAnnotation') {eAnnotation}
      else if (child.localName = 'valueCodeableConcept') then
        element.value := ParseCodeableConcept(child, path+'.valueCodeableConcept') {eCodeableConcept}
      else if (child.localName = 'valueHumanName') then
        element.value := ParseHumanName(child, path+'/valueHumanName') {f}
      else if (child.localName = 'valueMeta') then
        element.value := ParseMeta(child, path+'/valueMeta') {f}
      else if (child.localName = 'valueContactPoint') then
        element.value := ParseContactPoint(child, path+'/valueContactPoint') {f}
      else if (child.localName = 'valueAddress') then
        element.value := ParseAddress(child, path+'/valueAddress') {f}
      else if (child.localName = 'valueElementDefinition') then
        element.value := ParseElementDefinition(child, path+'/valueElementDefinition') {f}
      else if (child.localName = 'valueTiming') then
        element.value := ParseTiming(child, path+'/valueTiming') {f}
      else if (child.localName = 'resource') then
        element.resource := ParseInnerResource(child, path+'/resource') {b}
      else if (child.localName = 'part') then
        element.partList.Add(ParseParametersParameter(child, path+'/part')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeParametersParameter(xml : TXmlBuilder; name : String; elem : TFhirParametersParameter);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeParametersParameterChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeParametersParameterChildren(xml : TXmlBuilder; elem : TFhirParametersParameter);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCode) {1} then
    ComposeCode(xml, 'valueCode', TFhirCode(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirOid) {1} then
    ComposeOid(xml, 'valueOid', TFhirOid(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUuid) {1} then
    ComposeUuid(xml, 'valueUuid', TFhirUuid(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirMarkdown) {1} then
    ComposeMarkdown(xml, 'valueMarkdown', TFhirMarkdown(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUnsignedInt) {1} then
    ComposeUnsignedInt(xml, 'valueUnsignedInt', TFhirUnsignedInt(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirId) {1} then
    ComposeId(xml, 'valueId', TFhirId(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirPositiveInt) {1} then
    ComposePositiveInt(xml, 'valuePositiveInt', TFhirPositiveInt(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDateTime) {1} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDate) {1} then
    ComposeDate(xml, 'valueDate', TFhirDate(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirString) {1} then
    ComposeString(xml, 'valueString', TFhirString(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirInteger) {1} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUri) {1} then
    ComposeUri(xml, 'valueUri', TFhirUri(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirInstant) {1} then
    ComposeInstant(xml, 'valueInstant', TFhirInstant(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirBoolean) {1} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirBase64Binary) {1} then
    ComposeBase64Binary(xml, 'valueBase64Binary', TFhirBase64Binary(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirTime) {1} then
    ComposeTime(xml, 'valueTime', TFhirTime(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDecimal) {1} then
    ComposeDecimal(xml, 'valueDecimal', TFhirDecimal(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirIdentifier) {8} then
    ComposeIdentifier(xml, 'valueIdentifier', TFhirIdentifier(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirCoding) {8} then
    ComposeCoding(xml, 'valueCoding', TFhirCoding(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirReference) {8} then
    ComposeReference(xml, 'valueReference', TFhirReference(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirSignature) {8} then
    ComposeSignature(xml, 'valueSignature', TFhirSignature(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirSampledData) {8} then
    ComposeSampledData(xml, 'valueSampledData', TFhirSampledData(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirPeriod) {8} then
    ComposePeriod(xml, 'valuePeriod', TFhirPeriod(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirQuantity) {8} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirAttachment) {8} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirRatio) {8} then
    ComposeRatio(xml, 'valueRatio', TFhirRatio(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirRange) {8} then
    ComposeRange(xml, 'valueRange', TFhirRange(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirAnnotation) {8} then
    ComposeAnnotation(xml, 'valueAnnotation', TFhirAnnotation(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirHumanName) {9} then
    ComposeHumanName(xml, 'valueHumanName', TFhirHumanName(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirMeta) {9} then
    ComposeMeta(xml, 'valueMeta', TFhirMeta(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirContactPoint) {9} then
    ComposeContactPoint(xml, 'valueContactPoint', TFhirContactPoint(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirAddress) {9} then
    ComposeAddress(xml, 'valueAddress', TFhirAddress(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirElementDefinition) {9} then
    ComposeElementDefinition(xml, 'valueElementDefinition', TFhirElementDefinition(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirTiming) {9} then
    ComposeTiming(xml, 'valueTiming', TFhirTiming(elem.value));
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInnerResource(xml, 'resource', elem, elem.resource);{x.2a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.partList.Count - 1 do
      ComposeParametersParameter(xml, 'part', elem.partList[i]);
end;

function TFHIRXmlParser.ParseParameters(element : TMXmlElement; path : string) : TFhirParameters;
var
  child : TMXmlElement;
begin
  result := TFhirParameters.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseParametersChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseParametersChild(element : TFhirParameters; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'parameter') then
        element.parameterList.Add(ParseParametersParameter(child, path+'/parameter')){y.2}
      else if Not ParseResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeParameters(xml : TXmlBuilder; name : String; elem : TFhirParameters);
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeParametersChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeParametersChildren(xml : TXmlBuilder; elem : TFhirParameters);
var
  i : integer;
begin
  composeResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and doCompose('parameter') then
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeParametersParameter(xml, 'parameter', elem.parameterList[i]);
end;

{$ENDIF FHIR_PARAMETERS}
Procedure TFHIRXmlParser.ParseDomainResourceAttributes(resource : TFhirDomainResource; path : string; element : TMXmlElement);
begin
  ParseResourceAttributes(resource, path, element);
end;

Function TFHIRXmlParser.ParseDomainResourceChild(resource : TFhirDomainResource; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
  if (child.localName = 'text') then
    resource.text := ParseNarrative(child, path+'/text') {b}
  else if (child.localName = 'contained') then
    resource.containedList.Add(ParseInnerResource(child, path+'/contained')){y.2}
  else if (child.localName = 'extension') then
    resource.extensionList.Add(ParseExtension(child, path+'/extension')){y.2}
  else if (child.localName = 'modifierExtension') then
    resource.modifierExtensionList.Add(ParseExtension(child, path+'/modifierExtension')){y.2}
  else if not parseResourceChild(resource, path, child) then
    result := false;
end;

Procedure TFHIRXmlComposer.ComposeDomainResourceAttributes(xml : TXmlBuilder; resource : TFhirDomainResource);
begin
  ComposeResourceAttributes(xml, resource);
end;

Procedure TFHIRXmlComposer.ComposeDomainResourceChildren(xml : TXmlBuilder; elem : TFhirDomainResource);
var
  i : integer;{z.a}
begin
  composeResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soText]) and doCompose('text') then
    ComposeNarrative(xml, 'text', elem.text);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('contained') then
    for i := 0 to elem.containedList.Count - 1 do
      ComposeInnerResource(xml, 'contained', elem, elem.containedList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('extension') then
    for i := 0 to elem.extensionList.Count - 1 do
      ComposeExtension(xml, 'extension', elem.extensionList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('modifierExtension') then
    for i := 0 to elem.modifierExtensionList.Count - 1 do
      ComposeExtension(xml, 'modifierExtension', elem.modifierExtensionList[i]);
end;

function TFHIRXmlParser.ParseExtension(element : TMXmlElement; path : string) : TFhirExtension;
var
  child : TMXmlElement;
begin
  result := TFhirExtension.create;
  try
    parseElementAttributes(result, path, element);
    result.url := GetAttribute(element, 'url');{x.4}
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExtensionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExtensionChild(element : TFhirExtension; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'valueCode') then
        element.value := ParseCode(child, path+'.valueCode') {c}
      else if (child.localName = 'valueOid') then
        element.value := ParseOid(child, path+'.valueOid') {c}
      else if (child.localName = 'valueUuid') then
        element.value := ParseUuid(child, path+'.valueUuid') {c}
      else if (child.localName = 'valueMarkdown') then
        element.value := ParseMarkdown(child, path+'.valueMarkdown') {c}
      else if (child.localName = 'valueUnsignedInt') then
        element.value := ParseUnsignedInt(child, path+'.valueUnsignedInt') {c}
      else if (child.localName = 'valueId') then
        element.value := ParseId(child, path+'.valueId') {c}
      else if (child.localName = 'valuePositiveInt') then
        element.value := ParsePositiveInt(child, path+'.valuePositiveInt') {c}
      else if (child.localName = 'valueDateTime') then
        element.value := ParseDateTime(child, path+'.valueDateTime') {c}
      else if (child.localName = 'valueDate') then
        element.value := ParseDate(child, path+'.valueDate') {c}
      else if (child.localName = 'valueString') then
        element.value := ParseString(child, path+'.valueString') {c}
      else if (child.localName = 'valueInteger') then
        element.value := ParseInteger(child, path+'.valueInteger') {c}
      else if (child.localName = 'valueUri') then
        element.value := ParseUri(child, path+'.valueUri') {c}
      else if (child.localName = 'valueInstant') then
        element.value := ParseInstant(child, path+'.valueInstant') {c}
      else if (child.localName = 'valueBoolean') then
        element.value := ParseBoolean(child, path+'.valueBoolean') {c}
      else if (child.localName = 'valueBase64Binary') then
        element.value := ParseBase64Binary(child, path+'.valueBase64Binary') {c}
      else if (child.localName = 'valueTime') then
        element.value := ParseTime(child, path+'.valueTime') {c}
      else if (child.localName = 'valueDecimal') then
        element.value := ParseDecimal(child, path+'.valueDecimal') {c}
      else if (child.localName = 'valueIdentifier') then
        element.value := ParseIdentifier(child, path+'.valueIdentifier') {eIdentifier}
      else if (child.localName = 'valueCoding') then
        element.value := ParseCoding(child, path+'.valueCoding') {eCoding}
      else if (child.localName = 'valueReference') then
        element.value := ParseReference(child, path+'.valueReference') {eReference}
      else if (child.localName = 'valueSignature') then
        element.value := ParseSignature(child, path+'.valueSignature') {eSignature}
      else if (child.localName = 'valueSampledData') then
        element.value := ParseSampledData(child, path+'.valueSampledData') {eSampledData}
      else if (child.localName = 'valuePeriod') then
        element.value := ParsePeriod(child, path+'.valuePeriod') {ePeriod}
      else if (child.localName = 'valueQuantity') then
        element.value := ParseQuantity(child, path+'.valueQuantity') {eQuantity}
      else if (child.localName = 'valueAttachment') then
        element.value := ParseAttachment(child, path+'.valueAttachment') {eAttachment}
      else if (child.localName = 'valueRatio') then
        element.value := ParseRatio(child, path+'.valueRatio') {eRatio}
      else if (child.localName = 'valueRange') then
        element.value := ParseRange(child, path+'.valueRange') {eRange}
      else if (child.localName = 'valueAnnotation') then
        element.value := ParseAnnotation(child, path+'.valueAnnotation') {eAnnotation}
      else if (child.localName = 'valueCodeableConcept') then
        element.value := ParseCodeableConcept(child, path+'.valueCodeableConcept') {eCodeableConcept}
      else if (child.localName = 'valueHumanName') then
        element.value := ParseHumanName(child, path+'/valueHumanName') {f}
      else if (child.localName = 'valueMeta') then
        element.value := ParseMeta(child, path+'/valueMeta') {f}
      else if (child.localName = 'valueContactPoint') then
        element.value := ParseContactPoint(child, path+'/valueContactPoint') {f}
      else if (child.localName = 'valueAddress') then
        element.value := ParseAddress(child, path+'/valueAddress') {f}
      else if (child.localName = 'valueElementDefinition') then
        element.value := ParseElementDefinition(child, path+'/valueElementDefinition') {f}
      else if (child.localName = 'valueTiming') then
        element.value := ParseTiming(child, path+'/valueTiming') {f}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExtension(xml : TXmlBuilder; name : String; elem : TFhirExtension);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  Attribute(xml, 'url', elem.url  );
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExtensionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExtensionChildren(xml : TXmlBuilder; elem : TFhirExtension);
begin
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirCode) {1} then
    ComposeCode(xml, 'valueCode', TFhirCode(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirOid) {1} then
    ComposeOid(xml, 'valueOid', TFhirOid(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUuid) {1} then
    ComposeUuid(xml, 'valueUuid', TFhirUuid(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirMarkdown) {1} then
    ComposeMarkdown(xml, 'valueMarkdown', TFhirMarkdown(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUnsignedInt) {1} then
    ComposeUnsignedInt(xml, 'valueUnsignedInt', TFhirUnsignedInt(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirId) {1} then
    ComposeId(xml, 'valueId', TFhirId(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirPositiveInt) {1} then
    ComposePositiveInt(xml, 'valuePositiveInt', TFhirPositiveInt(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDateTime) {1} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDate) {1} then
    ComposeDate(xml, 'valueDate', TFhirDate(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirString) {1} then
    ComposeString(xml, 'valueString', TFhirString(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirInteger) {1} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirUri) {1} then
    ComposeUri(xml, 'valueUri', TFhirUri(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirInstant) {1} then
    ComposeInstant(xml, 'valueInstant', TFhirInstant(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirBoolean) {1} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirBase64Binary) {1} then
    ComposeBase64Binary(xml, 'valueBase64Binary', TFhirBase64Binary(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirTime) {1} then
    ComposeTime(xml, 'valueTime', TFhirTime(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.value is TFhirDecimal) {1} then
    ComposeDecimal(xml, 'valueDecimal', TFhirDecimal(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirIdentifier) {8} then
    ComposeIdentifier(xml, 'valueIdentifier', TFhirIdentifier(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirCoding) {8} then
    ComposeCoding(xml, 'valueCoding', TFhirCoding(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirReference) {8} then
    ComposeReference(xml, 'valueReference', TFhirReference(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirSignature) {8} then
    ComposeSignature(xml, 'valueSignature', TFhirSignature(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirSampledData) {8} then
    ComposeSampledData(xml, 'valueSampledData', TFhirSampledData(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirPeriod) {8} then
    ComposePeriod(xml, 'valuePeriod', TFhirPeriod(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirQuantity) {8} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirAttachment) {8} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirRatio) {8} then
    ComposeRatio(xml, 'valueRatio', TFhirRatio(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirRange) {8} then
    ComposeRange(xml, 'valueRange', TFhirRange(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirAnnotation) {8} then
    ComposeAnnotation(xml, 'valueAnnotation', TFhirAnnotation(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirHumanName) {9} then
    ComposeHumanName(xml, 'valueHumanName', TFhirHumanName(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirMeta) {9} then
    ComposeMeta(xml, 'valueMeta', TFhirMeta(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirContactPoint) {9} then
    ComposeContactPoint(xml, 'valueContactPoint', TFhirContactPoint(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirAddress) {9} then
    ComposeAddress(xml, 'valueAddress', TFhirAddress(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirElementDefinition) {9} then
    ComposeElementDefinition(xml, 'valueElementDefinition', TFhirElementDefinition(elem.value))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.value is TFhirTiming) {9} then
    ComposeTiming(xml, 'valueTiming', TFhirTiming(elem.value));
end;

function TFHIRXmlParser.ParseNarrative(element : TMXmlElement; path : string) : TFhirNarrative;
var
  child : TMXmlElement;
begin
  result := TFhirNarrative.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNarrativeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNarrativeChild(element : TFhirNarrative; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirNarrativeStatusEnum, SYSTEMS_TFhirNarrativeStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'div') then
        element.div_ := ParseXHtmlNode(child, path+'/div') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNarrative(xml : TXmlBuilder; name : String; elem : TFhirNarrative);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNarrativeChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNarrativeChildren(xml : TXmlBuilder; elem : TFhirNarrative);
begin
  composeElementChildren(xml, elem);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirNarrativeStatusEnum);
  ComposeXHtmlNode(xml, 'div', elem.div_);{x.2a}
end;

function TFHIRXmlParser.ParseIdentifier(element : TMXmlElement; path : string) : TFhirIdentifier;
var
  child : TMXmlElement;
begin
  result := TFhirIdentifier.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseIdentifierChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseIdentifierChild(element : TFhirIdentifier; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'use') then
        element.useElement := ParseEnum(CODES_TFhirIdentifierUseEnum, SYSTEMS_TFhirIdentifierUseEnum, path+'/use', child){1a}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'system') then
        element.systemElement := ParseUri(child, path+'/system') {b}
      else if (child.localName = 'value') then
        element.valueElement := ParseString(child, path+'/value') {b}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if (child.localName = 'assigner') then
        element.assigner := ParseReference{TFhirOrganization}(child, path+'/assigner') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeIdentifier(xml : TXmlBuilder; name : String; elem : TFhirIdentifier);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeIdentifierChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeIdentifierChildren(xml : TXmlBuilder; elem : TFhirIdentifier);
begin
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnum(xml, 'use', elem.UseElement, CODES_TFhirIdentifierUseEnum);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(xml, 'system', elem.systemElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'value', elem.valueElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'assigner', elem.assigner);{x.2a}
end;

function TFHIRXmlParser.ParseCoding(element : TMXmlElement; path : string) : TFhirCoding;
var
  child : TMXmlElement;
begin
  result := TFhirCoding.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCodingChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCodingChild(element : TFhirCoding; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'system') then
        element.systemElement := ParseUri(child, path+'/system') {b}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if (child.localName = 'code') then
        element.codeElement := ParseCode(child, path+'/code') {b}
      else if (child.localName = 'display') then
        element.displayElement := ParseString(child, path+'/display') {b}
      else if (child.localName = 'userSelected') then
        element.userSelectedElement := ParseBoolean(child, path+'/userSelected') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCoding(xml : TXmlBuilder; name : String; elem : TFhirCoding);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCodingChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCodingChildren(xml : TXmlBuilder; elem : TFhirCoding);
begin
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(xml, 'system', elem.systemElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'version', elem.versionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCode(xml, 'code', elem.codeElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'display', elem.displayElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBoolean(xml, 'userSelected', elem.userSelectedElement);{x.2b}
end;

function TFHIRXmlParser.ParseReference(element : TMXmlElement; path : string) : TFhirReference;
var
  child : TMXmlElement;
begin
  result := TFhirReference.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseReferenceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseReferenceChild(element : TFhirReference; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'reference') then
        element.referenceElement := ParseString(child, path+'/reference') {b}
      else if (child.localName = 'display') then
        element.displayElement := ParseString(child, path+'/display') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeReference(xml : TXmlBuilder; name : String; elem : TFhirReference);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeReferenceChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeReferenceChildren(xml : TXmlBuilder; elem : TFhirReference);
begin
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'reference', elem.referenceElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'display', elem.displayElement);{x.2b}
end;

function TFHIRXmlParser.ParseSignature(element : TMXmlElement; path : string) : TFhirSignature;
var
  child : TMXmlElement;
begin
  result := TFhirSignature.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSignatureChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSignatureChild(element : TFhirSignature; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_List.Add(ParseCoding(child, path+'/type')){y.2}
      else if (child.localName = 'when') then
        element.whenElement := ParseInstant(child, path+'/when') {b}
      else if (child.localName = 'whoReference') then
        element.who := ParseReference(child, path+'/whoReference') {a}
      else if (child.localName = 'whoUri') then
        element.who := ParseUri(child, path+'/whoUri'){x.3}
      else if (child.localName = 'contentType') then
        element.contentTypeElement := ParseCode(child, path+'/contentType') {b}
      else if (child.localName = 'blob') then
        element.blobElement := ParseBase64Binary(child, path+'/blob') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSignature(xml : TXmlBuilder; name : String; elem : TFhirSignature);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSignatureChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSignatureChildren(xml : TXmlBuilder; elem : TFhirSignature);
var
  i : integer;
begin
  composeElementChildren(xml, elem);
  for i := 0 to elem.type_List.Count - 1 do
      ComposeCoding(xml, 'type', elem.type_List[i]);
  ComposeInstant(xml, 'when', elem.whenElement);{x.2b}
  if (elem.who is TFhirReference) {2} then
    ComposeReference(xml, 'whoReference', TFhirReference(elem.who))
  else if (elem.who is TFhirUri) {6} then
    ComposeUri(xml, 'whoUri', TFhirUri(elem.who));
  ComposeCode(xml, 'contentType', elem.contentTypeElement);{x.2b}
  ComposeBase64Binary(xml, 'blob', elem.blobElement);{x.2b}
end;

function TFHIRXmlParser.ParseSampledData(element : TMXmlElement; path : string) : TFhirSampledData;
var
  child : TMXmlElement;
begin
  result := TFhirSampledData.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSampledDataChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSampledDataChild(element : TFhirSampledData; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'origin') then
        element.origin := ParseQuantity(child, path+'/origin') {b}
      else if (child.localName = 'period') then
        element.periodElement := ParseDecimal(child, path+'/period') {b}
      else if (child.localName = 'factor') then
        element.factorElement := ParseDecimal(child, path+'/factor') {b}
      else if (child.localName = 'lowerLimit') then
        element.lowerLimitElement := ParseDecimal(child, path+'/lowerLimit') {b}
      else if (child.localName = 'upperLimit') then
        element.upperLimitElement := ParseDecimal(child, path+'/upperLimit') {b}
      else if (child.localName = 'dimensions') then
        element.dimensionsElement := ParsePositiveInt(child, path+'/dimensions') {b}
      else if (child.localName = 'data') then
        element.dataElement := ParseString(child, path+'/data') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSampledData(xml : TXmlBuilder; name : String; elem : TFhirSampledData);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSampledDataChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSampledDataChildren(xml : TXmlBuilder; elem : TFhirSampledData);
begin
  composeElementChildren(xml, elem);
  ComposeQuantity(xml, 'origin', elem.origin);{x.2a}
  ComposeDecimal(xml, 'period', elem.periodElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (not isCanonical or (elem.factor <> '1')) then
    ComposeDecimal(xml, 'factor', elem.factorElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimal(xml, 'lowerLimit', elem.lowerLimitElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimal(xml, 'upperLimit', elem.upperLimitElement);{x.2b}
  ComposePositiveInt(xml, 'dimensions', elem.dimensionsElement);{x.2b}
  ComposeString(xml, 'data', elem.dataElement);{x.2b}
end;

function TFHIRXmlParser.ParsePeriod(element : TMXmlElement; path : string) : TFhirPeriod;
var
  child : TMXmlElement;
begin
  result := TFhirPeriod.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePeriodChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePeriodChild(element : TFhirPeriod; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'start') then
        element.startElement := ParseDateTime(child, path+'/start') {b}
      else if (child.localName = 'end') then
        element.end_Element := ParseDateTime(child, path+'/end') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePeriod(xml : TXmlBuilder; name : String; elem : TFhirPeriod);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePeriodChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePeriodChildren(xml : TXmlBuilder; elem : TFhirPeriod);
begin
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTime(xml, 'start', elem.startElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTime(xml, 'end', elem.end_Element);{x.2b}
end;

function TFHIRXmlParser.ParseQuantity(element : TMXmlElement; path : string) : TFhirQuantity;
var
  child : TMXmlElement;
begin
  result := TFhirQuantity.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseQuantityChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseQuantityChild(element : TFhirQuantity; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'value') then
        element.valueElement := ParseDecimal(child, path+'/value') {b}
      else if (child.localName = 'comparator') then
        element.comparatorElement := ParseEnum(CODES_TFhirQuantityComparatorEnum, SYSTEMS_TFhirQuantityComparatorEnum, path+'/comparator', child){1a}
      else if (child.localName = 'unit') then
        element.unit_Element := ParseString(child, path+'/unit') {b}
      else if (child.localName = 'system') then
        element.systemElement := ParseUri(child, path+'/system') {b}
      else if (child.localName = 'code') then
        element.codeElement := ParseCode(child, path+'/code') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeQuantity(xml : TXmlBuilder; name : String; elem : TFhirQuantity);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeQuantityChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeQuantityChildren(xml : TXmlBuilder; elem : TFhirQuantity);
begin
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimal(xml, 'value', elem.valueElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnum(xml, 'comparator', elem.ComparatorElement, CODES_TFhirQuantityComparatorEnum);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'unit', elem.unit_Element);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(xml, 'system', elem.systemElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCode(xml, 'code', elem.codeElement);{x.2b}
end;

function TFHIRXmlParser.ParseAttachment(element : TMXmlElement; path : string) : TFhirAttachment;
var
  child : TMXmlElement;
begin
  result := TFhirAttachment.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAttachmentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAttachmentChild(element : TFhirAttachment; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'contentType') then
        element.contentTypeElement := ParseCode(child, path+'/contentType') {b}
      else if (child.localName = 'language') then
        element.languageElement := ParseCode(child, path+'/language') {b}
      else if (child.localName = 'data') then
        element.dataElement := ParseBase64Binary(child, path+'/data') {b}
      else if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'size') then
        element.sizeElement := ParseUnsignedInt(child, path+'/size') {b}
      else if (child.localName = 'hash') then
        element.hashElement := ParseBase64Binary(child, path+'/hash') {b}
      else if (child.localName = 'title') then
        element.titleElement := ParseString(child, path+'/title') {b}
      else if (child.localName = 'creation') then
        element.creationElement := ParseDateTime(child, path+'/creation') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAttachment(xml : TXmlBuilder; name : String; elem : TFhirAttachment);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAttachmentChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAttachmentChildren(xml : TXmlBuilder; elem : TFhirAttachment);
begin
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCode(xml, 'contentType', elem.contentTypeElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCode(xml, 'language', elem.languageElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBase64Binary(xml, 'data', elem.dataElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUnsignedInt(xml, 'size', elem.sizeElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBase64Binary(xml, 'hash', elem.hashElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'title', elem.titleElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTime(xml, 'creation', elem.creationElement);{x.2b}
end;

function TFHIRXmlParser.ParseRatio(element : TMXmlElement; path : string) : TFhirRatio;
var
  child : TMXmlElement;
begin
  result := TFhirRatio.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseRatioChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseRatioChild(element : TFhirRatio; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'numerator') then
        element.numerator := ParseQuantity(child, path+'/numerator') {b}
      else if (child.localName = 'denominator') then
        element.denominator := ParseQuantity(child, path+'/denominator') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeRatio(xml : TXmlBuilder; name : String; elem : TFhirRatio);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeRatioChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeRatioChildren(xml : TXmlBuilder; elem : TFhirRatio);
begin
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(xml, 'numerator', elem.numerator);{x.2a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(xml, 'denominator', elem.denominator);{x.2a}
end;

function TFHIRXmlParser.ParseRange(element : TMXmlElement; path : string) : TFhirRange;
var
  child : TMXmlElement;
begin
  result := TFhirRange.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseRangeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseRangeChild(element : TFhirRange; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'low') then
        element.low := ParseQuantity(child, path+'/low') {b}
      else if (child.localName = 'high') then
        element.high := ParseQuantity(child, path+'/high') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeRange(xml : TXmlBuilder; name : String; elem : TFhirRange);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeRangeChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeRangeChildren(xml : TXmlBuilder; elem : TFhirRange);
begin
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(xml, 'low', elem.low);{x.2a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeQuantity(xml, 'high', elem.high);{x.2a}
end;

function TFHIRXmlParser.ParseAnnotation(element : TMXmlElement; path : string) : TFhirAnnotation;
var
  child : TMXmlElement;
begin
  result := TFhirAnnotation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAnnotationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAnnotationChild(element : TFhirAnnotation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'authorReference') then
        element.author := ParseReference(child, path+'/authorReference') {a}
      else if (child.localName = 'authorString') then
        element.author := ParseString(child, path+'/authorString'){x.3}
      else if (child.localName = 'time') then
        element.timeElement := ParseDateTime(child, path+'/time') {b}
      else if (child.localName = 'text') then
        element.textElement := ParseString(child, path+'/text') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAnnotation(xml : TXmlBuilder; name : String; elem : TFhirAnnotation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAnnotationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAnnotationChildren(xml : TXmlBuilder; elem : TFhirAnnotation);
begin
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.author is TFhirReference) {2} then
    ComposeReference(xml, 'authorReference', TFhirReference(elem.author))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.author is TFhirString) {6} then
    ComposeString(xml, 'authorString', TFhirString(elem.author));
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDateTime(xml, 'time', elem.timeElement);{x.2b}
  ComposeString(xml, 'text', elem.textElement);{x.2b}
end;

function TFHIRXmlParser.ParseCodeableConcept(element : TMXmlElement; path : string) : TFhirCodeableConcept;
var
  child : TMXmlElement;
begin
  result := TFhirCodeableConcept.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCodeableConceptChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCodeableConceptChild(element : TFhirCodeableConcept; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'coding') then
        element.codingList.Add(ParseCoding(child, path+'/coding')){y.2}
      else if (child.localName = 'text') then
        element.textElement := ParseString(child, path+'/text') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCodeableConcept(xml : TXmlBuilder; name : String; elem : TFhirCodeableConcept);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCodeableConceptChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCodeableConceptChildren(xml : TXmlBuilder; elem : TFhirCodeableConcept);
var
  i : integer;
begin
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.codingList.Count - 1 do
      ComposeCoding(xml, 'coding', elem.codingList[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2b}
end;

function TFHIRXmlParser.ParseHumanName(element : TMXmlElement; path : string) : TFhirHumanName;
var
  child : TMXmlElement;
begin
  result := TFhirHumanName.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseHumanNameChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseHumanNameChild(element : TFhirHumanName; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'use') then
        element.useElement := ParseEnum(CODES_TFhirNameUseEnum, SYSTEMS_TFhirNameUseEnum, path+'/use', child){1a}
      else if (child.localName = 'text') then
        element.textElement := ParseString(child, path+'/text') {b}
      else if (child.localName = 'family') then
        element.familyList.Add(ParseString(child, path+'/family')){y.2}
      else if (child.localName = 'given') then
        element.givenList.Add(ParseString(child, path+'/given')){y.2}
      else if (child.localName = 'prefix') then
        element.prefixList.Add(ParseString(child, path+'/prefix')){y.2}
      else if (child.localName = 'suffix') then
        element.suffixList.Add(ParseString(child, path+'/suffix')){y.2}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeHumanName(xml : TXmlBuilder; name : String; elem : TFhirHumanName);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeHumanNameChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeHumanNameChildren(xml : TXmlBuilder; elem : TFhirHumanName);
var
  i : integer;
begin
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnum(xml, 'use', elem.UseElement, CODES_TFhirNameUseEnum);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.familyList.Count - 1 do
      ComposeString(xml, 'family', elem.familyList[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.givenList.Count - 1 do
      ComposeString(xml, 'given', elem.givenList[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.prefixList.Count - 1 do
      ComposeString(xml, 'prefix', elem.prefixList[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.suffixList.Count - 1 do
      ComposeString(xml, 'suffix', elem.suffixList[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
end;

function TFHIRXmlParser.ParseMeta(element : TMXmlElement; path : string) : TFhirMeta;
var
  child : TMXmlElement;
begin
  result := TFhirMeta.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMetaChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMetaChild(element : TFhirMeta; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'versionId') then
        element.versionIdElement := ParseId(child, path+'/versionId') {b}
      else if (child.localName = 'lastUpdated') then
        element.lastUpdatedElement := ParseInstant(child, path+'/lastUpdated') {b}
      else if (child.localName = 'profile') then
        element.profileList.Add(ParseUri(child, path+'/profile')){y.2}
      else if (child.localName = 'security') then
        element.securityList.Add(ParseCoding(child, path+'/security')){y.2}
      else if (child.localName = 'tag') then
        element.tagList.Add(ParseCoding(child, path+'/tag')){y.2}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMeta(xml : TXmlBuilder; name : String; elem : TFhirMeta);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMetaChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMetaChildren(xml : TXmlBuilder; elem : TFhirMeta);
var
  i : integer;
begin
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeId(xml, 'versionId', elem.versionIdElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstant(xml, 'lastUpdated', elem.lastUpdatedElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.profileList.Count - 1 do
      ComposeUri(xml, 'profile', elem.profileList[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.securityList.Count - 1 do
      ComposeCoding(xml, 'security', elem.securityList[i]);
  for i := 0 to elem.tagList.Count - 1 do
    if (SummaryOption in [soFull, soSummary, soData]) or isSubsettedTag(elem.tagList[i]) then
      ComposeCoding(xml, 'tag', elem.tagList[i]);
end;

function TFHIRXmlParser.ParseContactPoint(element : TMXmlElement; path : string) : TFhirContactPoint;
var
  child : TMXmlElement;
begin
  result := TFhirContactPoint.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseContactPointChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContactPointChild(element : TFhirContactPoint; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'system') then
        element.systemElement := ParseEnum(CODES_TFhirContactPointSystemEnum, SYSTEMS_TFhirContactPointSystemEnum, path+'/system', child){1a}
      else if (child.localName = 'value') then
        element.valueElement := ParseString(child, path+'/value') {b}
      else if (child.localName = 'use') then
        element.useElement := ParseEnum(CODES_TFhirContactPointUseEnum, SYSTEMS_TFhirContactPointUseEnum, path+'/use', child){1a}
      else if (child.localName = 'rank') then
        element.rankElement := ParsePositiveInt(child, path+'/rank') {b}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeContactPoint(xml : TXmlBuilder; name : String; elem : TFhirContactPoint);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeContactPointChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeContactPointChildren(xml : TXmlBuilder; elem : TFhirContactPoint);
begin
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnum(xml, 'system', elem.SystemElement, CODES_TFhirContactPointSystemEnum);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'value', elem.valueElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnum(xml, 'use', elem.UseElement, CODES_TFhirContactPointUseEnum);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePositiveInt(xml, 'rank', elem.rankElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
end;

function TFHIRXmlParser.ParseAddress(element : TMXmlElement; path : string) : TFhirAddress;
var
  child : TMXmlElement;
begin
  result := TFhirAddress.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAddressChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAddressChild(element : TFhirAddress; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'use') then
        element.useElement := ParseEnum(CODES_TFhirAddressUseEnum, SYSTEMS_TFhirAddressUseEnum, path+'/use', child){1a}
      else if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirAddressTypeEnum, SYSTEMS_TFhirAddressTypeEnum, path+'/type', child){1a}
      else if (child.localName = 'text') then
        element.textElement := ParseString(child, path+'/text') {b}
      else if (child.localName = 'line') then
        element.lineList.Add(ParseString(child, path+'/line')){y.2}
      else if (child.localName = 'city') then
        element.cityElement := ParseString(child, path+'/city') {b}
      else if (child.localName = 'district') then
        element.districtElement := ParseString(child, path+'/district') {b}
      else if (child.localName = 'state') then
        element.stateElement := ParseString(child, path+'/state') {b}
      else if (child.localName = 'postalCode') then
        element.postalCodeElement := ParseString(child, path+'/postalCode') {b}
      else if (child.localName = 'country') then
        element.countryElement := ParseString(child, path+'/country') {b}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAddress(xml : TXmlBuilder; name : String; elem : TFhirAddress);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAddressChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAddressChildren(xml : TXmlBuilder; elem : TFhirAddress);
var
  i : integer;
begin
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnum(xml, 'use', elem.UseElement, CODES_TFhirAddressUseEnum);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirAddressTypeEnum);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.lineList.Count - 1 do
      ComposeString(xml, 'line', elem.lineList[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'city', elem.cityElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'district', elem.districtElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'state', elem.stateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'postalCode', elem.postalCodeElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'country', elem.countryElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
end;

function TFHIRXmlParser.ParseElementDefinitionSlicing(element : TMXmlElement; path : string) : TFhirElementDefinitionSlicing;
var
  child : TMXmlElement;
begin
  result := TFhirElementDefinitionSlicing.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseElementDefinitionSlicingChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseElementDefinitionSlicingChild(element : TFhirElementDefinitionSlicing; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'discriminator') then
        element.discriminatorList.Add(ParseString(child, path+'/discriminator')){y.2}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'ordered') then
        element.orderedElement := ParseBoolean(child, path+'/ordered') {b}
      else if (child.localName = 'rules') then
        element.rulesElement := ParseEnum(CODES_TFhirResourceSlicingRulesEnum, SYSTEMS_TFhirResourceSlicingRulesEnum, path+'/rules', child){1a}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionSlicing(xml : TXmlBuilder; name : String; elem : TFhirElementDefinitionSlicing);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementDefinitionSlicingChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionSlicingChildren(xml : TXmlBuilder; elem : TFhirElementDefinitionSlicing);
var
  i : integer;
begin
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.discriminatorList.Count - 1 do
      ComposeString(xml, 'discriminator', elem.discriminatorList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.ordered <> false)) then
    ComposeBoolean(xml, 'ordered', elem.orderedElement);{x.2b}
  ComposeEnum(xml, 'rules', elem.RulesElement, CODES_TFhirResourceSlicingRulesEnum);
end;

function TFHIRXmlParser.ParseElementDefinitionBase(element : TMXmlElement; path : string) : TFhirElementDefinitionBase;
var
  child : TMXmlElement;
begin
  result := TFhirElementDefinitionBase.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseElementDefinitionBaseChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseElementDefinitionBaseChild(element : TFhirElementDefinitionBase; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'path') then
        element.pathElement := ParseString(child, path+'/path') {b}
      else if (child.localName = 'min') then
        element.minElement := ParseInteger(child, path+'/min') {b}
      else if (child.localName = 'max') then
        element.maxElement := ParseString(child, path+'/max') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionBase(xml : TXmlBuilder; name : String; elem : TFhirElementDefinitionBase);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementDefinitionBaseChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionBaseChildren(xml : TXmlBuilder; elem : TFhirElementDefinitionBase);
begin
  composeElementChildren(xml, elem);
  ComposeString(xml, 'path', elem.pathElement);{x.2b}
  ComposeInteger(xml, 'min', elem.minElement);{x.2b}
  ComposeString(xml, 'max', elem.maxElement);{x.2b}
end;

function TFHIRXmlParser.ParseElementDefinitionType(element : TMXmlElement; path : string) : TFhirElementDefinitionType;
var
  child : TMXmlElement;
begin
  result := TFhirElementDefinitionType.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseElementDefinitionTypeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseElementDefinitionTypeChild(element : TFhirElementDefinitionType; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.codeElement := ParseCode(child, path+'/code') {b}
      else if (child.localName = 'profile') then
        element.profileList.Add(ParseUri(child, path+'/profile')){y.2}
      else if (child.localName = 'aggregation') then
        element.aggregationList.Add(ParseEnum(CODES_TFhirResourceAggregationModeEnum, SYSTEMS_TFhirResourceAggregationModeEnum, path+'/aggregation', child)){y.1}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionType(xml : TXmlBuilder; name : String; elem : TFhirElementDefinitionType);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementDefinitionTypeChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionTypeChildren(xml : TXmlBuilder; elem : TFhirElementDefinitionType);
var
  i : integer;
begin
  composeElementChildren(xml, elem);
  ComposeCode(xml, 'code', elem.codeElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.profileList.Count - 1 do
      ComposeUri(xml, 'profile', elem.profileList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.aggregationList.Count - 1 do
      ComposeEnum(xml, 'aggregation', elem.aggregationList[i], CODES_TFhirResourceAggregationModeEnum);
end;

function TFHIRXmlParser.ParseElementDefinitionConstraint(element : TMXmlElement; path : string) : TFhirElementDefinitionConstraint;
var
  child : TMXmlElement;
begin
  result := TFhirElementDefinitionConstraint.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseElementDefinitionConstraintChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseElementDefinitionConstraintChild(element : TFhirElementDefinitionConstraint; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'key') then
        element.keyElement := ParseId(child, path+'/key') {b}
      else if (child.localName = 'requirements') then
        element.requirementsElement := ParseString(child, path+'/requirements') {b}
      else if (child.localName = 'severity') then
        element.severityElement := ParseEnum(CODES_TFhirConstraintSeverityEnum, SYSTEMS_TFhirConstraintSeverityEnum, path+'/severity', child){1a}
      else if (child.localName = 'human') then
        element.humanElement := ParseString(child, path+'/human') {b}
      else if (child.localName = 'xpath') then
        element.xpathElement := ParseString(child, path+'/xpath') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionConstraint(xml : TXmlBuilder; name : String; elem : TFhirElementDefinitionConstraint);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementDefinitionConstraintChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionConstraintChildren(xml : TXmlBuilder; elem : TFhirElementDefinitionConstraint);
begin
  composeElementChildren(xml, elem);
  ComposeId(xml, 'key', elem.keyElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'requirements', elem.requirementsElement);{x.2b}
  ComposeEnum(xml, 'severity', elem.SeverityElement, CODES_TFhirConstraintSeverityEnum);
  ComposeString(xml, 'human', elem.humanElement);{x.2b}
  ComposeString(xml, 'xpath', elem.xpathElement);{x.2b}
end;

function TFHIRXmlParser.ParseElementDefinitionBinding(element : TMXmlElement; path : string) : TFhirElementDefinitionBinding;
var
  child : TMXmlElement;
begin
  result := TFhirElementDefinitionBinding.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseElementDefinitionBindingChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseElementDefinitionBindingChild(element : TFhirElementDefinitionBinding; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'strength') then
        element.strengthElement := ParseEnum(CODES_TFhirBindingStrengthEnum, SYSTEMS_TFhirBindingStrengthEnum, path+'/strength', child){1a}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'valueSetReference') then
        element.valueSet := ParseReference(child, path+'/valueSetReference') {a}
      else if (child.localName = 'valueSetUri') then
        element.valueSet := ParseUri(child, path+'/valueSetUri'){x.3}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionBinding(xml : TXmlBuilder; name : String; elem : TFhirElementDefinitionBinding);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementDefinitionBindingChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionBindingChildren(xml : TXmlBuilder; elem : TFhirElementDefinitionBinding);
begin
  composeElementChildren(xml, elem);
  ComposeEnum(xml, 'strength', elem.StrengthElement, CODES_TFhirBindingStrengthEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.valueSet is TFhirReference) {2} then
    ComposeReference(xml, 'valueSetReference', TFhirReference(elem.valueSet))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.valueSet is TFhirUri) {6} then
    ComposeUri(xml, 'valueSetUri', TFhirUri(elem.valueSet));
end;

function TFHIRXmlParser.ParseElementDefinitionMapping(element : TMXmlElement; path : string) : TFhirElementDefinitionMapping;
var
  child : TMXmlElement;
begin
  result := TFhirElementDefinitionMapping.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseElementDefinitionMappingChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseElementDefinitionMappingChild(element : TFhirElementDefinitionMapping; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identity') then
        element.identityElement := ParseId(child, path+'/identity') {b}
      else if (child.localName = 'language') then
        element.languageElement := ParseCode(child, path+'/language') {b}
      else if (child.localName = 'map') then
        element.mapElement := ParseString(child, path+'/map') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionMapping(xml : TXmlBuilder; name : String; elem : TFhirElementDefinitionMapping);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementDefinitionMappingChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionMappingChildren(xml : TXmlBuilder; elem : TFhirElementDefinitionMapping);
begin
  composeElementChildren(xml, elem);
  ComposeId(xml, 'identity', elem.identityElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCode(xml, 'language', elem.languageElement);{x.2b}
  ComposeString(xml, 'map', elem.mapElement);{x.2b}
end;

function TFHIRXmlParser.ParseElementDefinition(element : TMXmlElement; path : string) : TFhirElementDefinition;
var
  child : TMXmlElement;
begin
  result := TFhirElementDefinition.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseElementDefinitionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseElementDefinitionChild(element : TFhirElementDefinition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'path') then
        element.pathElement := ParseString(child, path+'/path') {b}
      else if (child.localName = 'representation') then
        element.representationList.Add(ParseEnum(CODES_TFhirPropertyRepresentationEnum, SYSTEMS_TFhirPropertyRepresentationEnum, path+'/representation', child)){y.1}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'label') then
        element.label_Element := ParseString(child, path+'/label') {b}
      else if (child.localName = 'code') then
        element.codeList.Add(ParseCoding(child, path+'/code')){y.2}
      else if (child.localName = 'slicing') then
        element.slicing := ParseElementDefinitionSlicing(child, path+'/slicing') {b}
      else if (child.localName = 'short') then
        element.shortElement := ParseString(child, path+'/short') {b}
      else if (child.localName = 'definition') then
        element.definitionElement := ParseMarkdown(child, path+'/definition') {b}
      else if (child.localName = 'comments') then
        element.commentsElement := ParseMarkdown(child, path+'/comments') {b}
      else if (child.localName = 'requirements') then
        element.requirementsElement := ParseMarkdown(child, path+'/requirements') {b}
      else if (child.localName = 'alias') then
        element.aliasList.Add(ParseString(child, path+'/alias')){y.2}
      else if (child.localName = 'min') then
        element.minElement := ParseInteger(child, path+'/min') {b}
      else if (child.localName = 'max') then
        element.maxElement := ParseString(child, path+'/max') {b}
      else if (child.localName = 'base') then
        element.base := ParseElementDefinitionBase(child, path+'/base') {b}
      else if (child.localName = 'type') then
        element.type_List.Add(ParseElementDefinitionType(child, path+'/type')){y.2}
      else if (child.localName = 'nameReference') then
        element.nameReferenceElement := ParseString(child, path+'/nameReference') {b}
      else if (child.localName = 'defaultValueCode') then
        element.defaultValue := ParseCode(child, path+'.defaultValueCode') {c}
      else if (child.localName = 'defaultValueOid') then
        element.defaultValue := ParseOid(child, path+'.defaultValueOid') {c}
      else if (child.localName = 'defaultValueUuid') then
        element.defaultValue := ParseUuid(child, path+'.defaultValueUuid') {c}
      else if (child.localName = 'defaultValueMarkdown') then
        element.defaultValue := ParseMarkdown(child, path+'.defaultValueMarkdown') {c}
      else if (child.localName = 'defaultValueUnsignedInt') then
        element.defaultValue := ParseUnsignedInt(child, path+'.defaultValueUnsignedInt') {c}
      else if (child.localName = 'defaultValueId') then
        element.defaultValue := ParseId(child, path+'.defaultValueId') {c}
      else if (child.localName = 'defaultValuePositiveInt') then
        element.defaultValue := ParsePositiveInt(child, path+'.defaultValuePositiveInt') {c}
      else if (child.localName = 'defaultValueDateTime') then
        element.defaultValue := ParseDateTime(child, path+'.defaultValueDateTime') {c}
      else if (child.localName = 'defaultValueDate') then
        element.defaultValue := ParseDate(child, path+'.defaultValueDate') {c}
      else if (child.localName = 'defaultValueString') then
        element.defaultValue := ParseString(child, path+'.defaultValueString') {c}
      else if (child.localName = 'defaultValueInteger') then
        element.defaultValue := ParseInteger(child, path+'.defaultValueInteger') {c}
      else if (child.localName = 'defaultValueUri') then
        element.defaultValue := ParseUri(child, path+'.defaultValueUri') {c}
      else if (child.localName = 'defaultValueInstant') then
        element.defaultValue := ParseInstant(child, path+'.defaultValueInstant') {c}
      else if (child.localName = 'defaultValueBoolean') then
        element.defaultValue := ParseBoolean(child, path+'.defaultValueBoolean') {c}
      else if (child.localName = 'defaultValueBase64Binary') then
        element.defaultValue := ParseBase64Binary(child, path+'.defaultValueBase64Binary') {c}
      else if (child.localName = 'defaultValueTime') then
        element.defaultValue := ParseTime(child, path+'.defaultValueTime') {c}
      else if (child.localName = 'defaultValueDecimal') then
        element.defaultValue := ParseDecimal(child, path+'.defaultValueDecimal') {c}
      else if (child.localName = 'defaultValueIdentifier') then
        element.defaultValue := ParseIdentifier(child, path+'.defaultValueIdentifier') {eIdentifier}
      else if (child.localName = 'defaultValueCoding') then
        element.defaultValue := ParseCoding(child, path+'.defaultValueCoding') {eCoding}
      else if (child.localName = 'defaultValueReference') then
        element.defaultValue := ParseReference(child, path+'.defaultValueReference') {eReference}
      else if (child.localName = 'defaultValueSignature') then
        element.defaultValue := ParseSignature(child, path+'.defaultValueSignature') {eSignature}
      else if (child.localName = 'defaultValueSampledData') then
        element.defaultValue := ParseSampledData(child, path+'.defaultValueSampledData') {eSampledData}
      else if (child.localName = 'defaultValuePeriod') then
        element.defaultValue := ParsePeriod(child, path+'.defaultValuePeriod') {ePeriod}
      else if (child.localName = 'defaultValueQuantity') then
        element.defaultValue := ParseQuantity(child, path+'.defaultValueQuantity') {eQuantity}
      else if (child.localName = 'defaultValueAttachment') then
        element.defaultValue := ParseAttachment(child, path+'.defaultValueAttachment') {eAttachment}
      else if (child.localName = 'defaultValueRatio') then
        element.defaultValue := ParseRatio(child, path+'.defaultValueRatio') {eRatio}
      else if (child.localName = 'defaultValueRange') then
        element.defaultValue := ParseRange(child, path+'.defaultValueRange') {eRange}
      else if (child.localName = 'defaultValueAnnotation') then
        element.defaultValue := ParseAnnotation(child, path+'.defaultValueAnnotation') {eAnnotation}
      else if (child.localName = 'defaultValueCodeableConcept') then
        element.defaultValue := ParseCodeableConcept(child, path+'.defaultValueCodeableConcept') {eCodeableConcept}
      else if (child.localName = 'defaultValueHumanName') then
        element.defaultValue := ParseHumanName(child, path+'/defaultValueHumanName') {f}
      else if (child.localName = 'defaultValueMeta') then
        element.defaultValue := ParseMeta(child, path+'/defaultValueMeta') {f}
      else if (child.localName = 'defaultValueContactPoint') then
        element.defaultValue := ParseContactPoint(child, path+'/defaultValueContactPoint') {f}
      else if (child.localName = 'defaultValueAddress') then
        element.defaultValue := ParseAddress(child, path+'/defaultValueAddress') {f}
      else if (child.localName = 'defaultValueElementDefinition') then
        element.defaultValue := ParseElementDefinition(child, path+'/defaultValueElementDefinition') {f}
      else if (child.localName = 'defaultValueTiming') then
        element.defaultValue := ParseTiming(child, path+'/defaultValueTiming') {f}
      else if (child.localName = 'meaningWhenMissing') then
        element.meaningWhenMissingElement := ParseMarkdown(child, path+'/meaningWhenMissing') {b}
      else if (child.localName = 'fixedCode') then
        element.fixed := ParseCode(child, path+'.fixedCode') {c}
      else if (child.localName = 'fixedOid') then
        element.fixed := ParseOid(child, path+'.fixedOid') {c}
      else if (child.localName = 'fixedUuid') then
        element.fixed := ParseUuid(child, path+'.fixedUuid') {c}
      else if (child.localName = 'fixedMarkdown') then
        element.fixed := ParseMarkdown(child, path+'.fixedMarkdown') {c}
      else if (child.localName = 'fixedUnsignedInt') then
        element.fixed := ParseUnsignedInt(child, path+'.fixedUnsignedInt') {c}
      else if (child.localName = 'fixedId') then
        element.fixed := ParseId(child, path+'.fixedId') {c}
      else if (child.localName = 'fixedPositiveInt') then
        element.fixed := ParsePositiveInt(child, path+'.fixedPositiveInt') {c}
      else if (child.localName = 'fixedDateTime') then
        element.fixed := ParseDateTime(child, path+'.fixedDateTime') {c}
      else if (child.localName = 'fixedDate') then
        element.fixed := ParseDate(child, path+'.fixedDate') {c}
      else if (child.localName = 'fixedString') then
        element.fixed := ParseString(child, path+'.fixedString') {c}
      else if (child.localName = 'fixedInteger') then
        element.fixed := ParseInteger(child, path+'.fixedInteger') {c}
      else if (child.localName = 'fixedUri') then
        element.fixed := ParseUri(child, path+'.fixedUri') {c}
      else if (child.localName = 'fixedInstant') then
        element.fixed := ParseInstant(child, path+'.fixedInstant') {c}
      else if (child.localName = 'fixedBoolean') then
        element.fixed := ParseBoolean(child, path+'.fixedBoolean') {c}
      else if (child.localName = 'fixedBase64Binary') then
        element.fixed := ParseBase64Binary(child, path+'.fixedBase64Binary') {c}
      else if (child.localName = 'fixedTime') then
        element.fixed := ParseTime(child, path+'.fixedTime') {c}
      else if (child.localName = 'fixedDecimal') then
        element.fixed := ParseDecimal(child, path+'.fixedDecimal') {c}
      else if (child.localName = 'fixedIdentifier') then
        element.fixed := ParseIdentifier(child, path+'.fixedIdentifier') {eIdentifier}
      else if (child.localName = 'fixedCoding') then
        element.fixed := ParseCoding(child, path+'.fixedCoding') {eCoding}
      else if (child.localName = 'fixedReference') then
        element.fixed := ParseReference(child, path+'.fixedReference') {eReference}
      else if (child.localName = 'fixedSignature') then
        element.fixed := ParseSignature(child, path+'.fixedSignature') {eSignature}
      else if (child.localName = 'fixedSampledData') then
        element.fixed := ParseSampledData(child, path+'.fixedSampledData') {eSampledData}
      else if (child.localName = 'fixedPeriod') then
        element.fixed := ParsePeriod(child, path+'.fixedPeriod') {ePeriod}
      else if (child.localName = 'fixedQuantity') then
        element.fixed := ParseQuantity(child, path+'.fixedQuantity') {eQuantity}
      else if (child.localName = 'fixedAttachment') then
        element.fixed := ParseAttachment(child, path+'.fixedAttachment') {eAttachment}
      else if (child.localName = 'fixedRatio') then
        element.fixed := ParseRatio(child, path+'.fixedRatio') {eRatio}
      else if (child.localName = 'fixedRange') then
        element.fixed := ParseRange(child, path+'.fixedRange') {eRange}
      else if (child.localName = 'fixedAnnotation') then
        element.fixed := ParseAnnotation(child, path+'.fixedAnnotation') {eAnnotation}
      else if (child.localName = 'fixedCodeableConcept') then
        element.fixed := ParseCodeableConcept(child, path+'.fixedCodeableConcept') {eCodeableConcept}
      else if (child.localName = 'fixedHumanName') then
        element.fixed := ParseHumanName(child, path+'/fixedHumanName') {f}
      else if (child.localName = 'fixedMeta') then
        element.fixed := ParseMeta(child, path+'/fixedMeta') {f}
      else if (child.localName = 'fixedContactPoint') then
        element.fixed := ParseContactPoint(child, path+'/fixedContactPoint') {f}
      else if (child.localName = 'fixedAddress') then
        element.fixed := ParseAddress(child, path+'/fixedAddress') {f}
      else if (child.localName = 'fixedElementDefinition') then
        element.fixed := ParseElementDefinition(child, path+'/fixedElementDefinition') {f}
      else if (child.localName = 'fixedTiming') then
        element.fixed := ParseTiming(child, path+'/fixedTiming') {f}
      else if (child.localName = 'patternCode') then
        element.pattern := ParseCode(child, path+'.patternCode') {c}
      else if (child.localName = 'patternOid') then
        element.pattern := ParseOid(child, path+'.patternOid') {c}
      else if (child.localName = 'patternUuid') then
        element.pattern := ParseUuid(child, path+'.patternUuid') {c}
      else if (child.localName = 'patternMarkdown') then
        element.pattern := ParseMarkdown(child, path+'.patternMarkdown') {c}
      else if (child.localName = 'patternUnsignedInt') then
        element.pattern := ParseUnsignedInt(child, path+'.patternUnsignedInt') {c}
      else if (child.localName = 'patternId') then
        element.pattern := ParseId(child, path+'.patternId') {c}
      else if (child.localName = 'patternPositiveInt') then
        element.pattern := ParsePositiveInt(child, path+'.patternPositiveInt') {c}
      else if (child.localName = 'patternDateTime') then
        element.pattern := ParseDateTime(child, path+'.patternDateTime') {c}
      else if (child.localName = 'patternDate') then
        element.pattern := ParseDate(child, path+'.patternDate') {c}
      else if (child.localName = 'patternString') then
        element.pattern := ParseString(child, path+'.patternString') {c}
      else if (child.localName = 'patternInteger') then
        element.pattern := ParseInteger(child, path+'.patternInteger') {c}
      else if (child.localName = 'patternUri') then
        element.pattern := ParseUri(child, path+'.patternUri') {c}
      else if (child.localName = 'patternInstant') then
        element.pattern := ParseInstant(child, path+'.patternInstant') {c}
      else if (child.localName = 'patternBoolean') then
        element.pattern := ParseBoolean(child, path+'.patternBoolean') {c}
      else if (child.localName = 'patternBase64Binary') then
        element.pattern := ParseBase64Binary(child, path+'.patternBase64Binary') {c}
      else if (child.localName = 'patternTime') then
        element.pattern := ParseTime(child, path+'.patternTime') {c}
      else if (child.localName = 'patternDecimal') then
        element.pattern := ParseDecimal(child, path+'.patternDecimal') {c}
      else if (child.localName = 'patternIdentifier') then
        element.pattern := ParseIdentifier(child, path+'.patternIdentifier') {eIdentifier}
      else if (child.localName = 'patternCoding') then
        element.pattern := ParseCoding(child, path+'.patternCoding') {eCoding}
      else if (child.localName = 'patternReference') then
        element.pattern := ParseReference(child, path+'.patternReference') {eReference}
      else if (child.localName = 'patternSignature') then
        element.pattern := ParseSignature(child, path+'.patternSignature') {eSignature}
      else if (child.localName = 'patternSampledData') then
        element.pattern := ParseSampledData(child, path+'.patternSampledData') {eSampledData}
      else if (child.localName = 'patternPeriod') then
        element.pattern := ParsePeriod(child, path+'.patternPeriod') {ePeriod}
      else if (child.localName = 'patternQuantity') then
        element.pattern := ParseQuantity(child, path+'.patternQuantity') {eQuantity}
      else if (child.localName = 'patternAttachment') then
        element.pattern := ParseAttachment(child, path+'.patternAttachment') {eAttachment}
      else if (child.localName = 'patternRatio') then
        element.pattern := ParseRatio(child, path+'.patternRatio') {eRatio}
      else if (child.localName = 'patternRange') then
        element.pattern := ParseRange(child, path+'.patternRange') {eRange}
      else if (child.localName = 'patternAnnotation') then
        element.pattern := ParseAnnotation(child, path+'.patternAnnotation') {eAnnotation}
      else if (child.localName = 'patternCodeableConcept') then
        element.pattern := ParseCodeableConcept(child, path+'.patternCodeableConcept') {eCodeableConcept}
      else if (child.localName = 'patternHumanName') then
        element.pattern := ParseHumanName(child, path+'/patternHumanName') {f}
      else if (child.localName = 'patternMeta') then
        element.pattern := ParseMeta(child, path+'/patternMeta') {f}
      else if (child.localName = 'patternContactPoint') then
        element.pattern := ParseContactPoint(child, path+'/patternContactPoint') {f}
      else if (child.localName = 'patternAddress') then
        element.pattern := ParseAddress(child, path+'/patternAddress') {f}
      else if (child.localName = 'patternElementDefinition') then
        element.pattern := ParseElementDefinition(child, path+'/patternElementDefinition') {f}
      else if (child.localName = 'patternTiming') then
        element.pattern := ParseTiming(child, path+'/patternTiming') {f}
      else if (child.localName = 'exampleCode') then
        element.example := ParseCode(child, path+'.exampleCode') {c}
      else if (child.localName = 'exampleOid') then
        element.example := ParseOid(child, path+'.exampleOid') {c}
      else if (child.localName = 'exampleUuid') then
        element.example := ParseUuid(child, path+'.exampleUuid') {c}
      else if (child.localName = 'exampleMarkdown') then
        element.example := ParseMarkdown(child, path+'.exampleMarkdown') {c}
      else if (child.localName = 'exampleUnsignedInt') then
        element.example := ParseUnsignedInt(child, path+'.exampleUnsignedInt') {c}
      else if (child.localName = 'exampleId') then
        element.example := ParseId(child, path+'.exampleId') {c}
      else if (child.localName = 'examplePositiveInt') then
        element.example := ParsePositiveInt(child, path+'.examplePositiveInt') {c}
      else if (child.localName = 'exampleDateTime') then
        element.example := ParseDateTime(child, path+'.exampleDateTime') {c}
      else if (child.localName = 'exampleDate') then
        element.example := ParseDate(child, path+'.exampleDate') {c}
      else if (child.localName = 'exampleString') then
        element.example := ParseString(child, path+'.exampleString') {c}
      else if (child.localName = 'exampleInteger') then
        element.example := ParseInteger(child, path+'.exampleInteger') {c}
      else if (child.localName = 'exampleUri') then
        element.example := ParseUri(child, path+'.exampleUri') {c}
      else if (child.localName = 'exampleInstant') then
        element.example := ParseInstant(child, path+'.exampleInstant') {c}
      else if (child.localName = 'exampleBoolean') then
        element.example := ParseBoolean(child, path+'.exampleBoolean') {c}
      else if (child.localName = 'exampleBase64Binary') then
        element.example := ParseBase64Binary(child, path+'.exampleBase64Binary') {c}
      else if (child.localName = 'exampleTime') then
        element.example := ParseTime(child, path+'.exampleTime') {c}
      else if (child.localName = 'exampleDecimal') then
        element.example := ParseDecimal(child, path+'.exampleDecimal') {c}
      else if (child.localName = 'exampleIdentifier') then
        element.example := ParseIdentifier(child, path+'.exampleIdentifier') {eIdentifier}
      else if (child.localName = 'exampleCoding') then
        element.example := ParseCoding(child, path+'.exampleCoding') {eCoding}
      else if (child.localName = 'exampleReference') then
        element.example := ParseReference(child, path+'.exampleReference') {eReference}
      else if (child.localName = 'exampleSignature') then
        element.example := ParseSignature(child, path+'.exampleSignature') {eSignature}
      else if (child.localName = 'exampleSampledData') then
        element.example := ParseSampledData(child, path+'.exampleSampledData') {eSampledData}
      else if (child.localName = 'examplePeriod') then
        element.example := ParsePeriod(child, path+'.examplePeriod') {ePeriod}
      else if (child.localName = 'exampleQuantity') then
        element.example := ParseQuantity(child, path+'.exampleQuantity') {eQuantity}
      else if (child.localName = 'exampleAttachment') then
        element.example := ParseAttachment(child, path+'.exampleAttachment') {eAttachment}
      else if (child.localName = 'exampleRatio') then
        element.example := ParseRatio(child, path+'.exampleRatio') {eRatio}
      else if (child.localName = 'exampleRange') then
        element.example := ParseRange(child, path+'.exampleRange') {eRange}
      else if (child.localName = 'exampleAnnotation') then
        element.example := ParseAnnotation(child, path+'.exampleAnnotation') {eAnnotation}
      else if (child.localName = 'exampleCodeableConcept') then
        element.example := ParseCodeableConcept(child, path+'.exampleCodeableConcept') {eCodeableConcept}
      else if (child.localName = 'exampleHumanName') then
        element.example := ParseHumanName(child, path+'/exampleHumanName') {f}
      else if (child.localName = 'exampleMeta') then
        element.example := ParseMeta(child, path+'/exampleMeta') {f}
      else if (child.localName = 'exampleContactPoint') then
        element.example := ParseContactPoint(child, path+'/exampleContactPoint') {f}
      else if (child.localName = 'exampleAddress') then
        element.example := ParseAddress(child, path+'/exampleAddress') {f}
      else if (child.localName = 'exampleElementDefinition') then
        element.example := ParseElementDefinition(child, path+'/exampleElementDefinition') {f}
      else if (child.localName = 'exampleTiming') then
        element.example := ParseTiming(child, path+'/exampleTiming') {f}
      else if (child.localName = 'minValueCode') then
        element.minValue := ParseCode(child, path+'.minValueCode') {c}
      else if (child.localName = 'minValueOid') then
        element.minValue := ParseOid(child, path+'.minValueOid') {c}
      else if (child.localName = 'minValueUuid') then
        element.minValue := ParseUuid(child, path+'.minValueUuid') {c}
      else if (child.localName = 'minValueMarkdown') then
        element.minValue := ParseMarkdown(child, path+'.minValueMarkdown') {c}
      else if (child.localName = 'minValueUnsignedInt') then
        element.minValue := ParseUnsignedInt(child, path+'.minValueUnsignedInt') {c}
      else if (child.localName = 'minValueId') then
        element.minValue := ParseId(child, path+'.minValueId') {c}
      else if (child.localName = 'minValuePositiveInt') then
        element.minValue := ParsePositiveInt(child, path+'.minValuePositiveInt') {c}
      else if (child.localName = 'minValueDateTime') then
        element.minValue := ParseDateTime(child, path+'.minValueDateTime') {c}
      else if (child.localName = 'minValueDate') then
        element.minValue := ParseDate(child, path+'.minValueDate') {c}
      else if (child.localName = 'minValueString') then
        element.minValue := ParseString(child, path+'.minValueString') {c}
      else if (child.localName = 'minValueInteger') then
        element.minValue := ParseInteger(child, path+'.minValueInteger') {c}
      else if (child.localName = 'minValueUri') then
        element.minValue := ParseUri(child, path+'.minValueUri') {c}
      else if (child.localName = 'minValueInstant') then
        element.minValue := ParseInstant(child, path+'.minValueInstant') {c}
      else if (child.localName = 'minValueBoolean') then
        element.minValue := ParseBoolean(child, path+'.minValueBoolean') {c}
      else if (child.localName = 'minValueBase64Binary') then
        element.minValue := ParseBase64Binary(child, path+'.minValueBase64Binary') {c}
      else if (child.localName = 'minValueTime') then
        element.minValue := ParseTime(child, path+'.minValueTime') {c}
      else if (child.localName = 'minValueDecimal') then
        element.minValue := ParseDecimal(child, path+'.minValueDecimal') {c}
      else if (child.localName = 'minValueIdentifier') then
        element.minValue := ParseIdentifier(child, path+'.minValueIdentifier') {eIdentifier}
      else if (child.localName = 'minValueCoding') then
        element.minValue := ParseCoding(child, path+'.minValueCoding') {eCoding}
      else if (child.localName = 'minValueReference') then
        element.minValue := ParseReference(child, path+'.minValueReference') {eReference}
      else if (child.localName = 'minValueSignature') then
        element.minValue := ParseSignature(child, path+'.minValueSignature') {eSignature}
      else if (child.localName = 'minValueSampledData') then
        element.minValue := ParseSampledData(child, path+'.minValueSampledData') {eSampledData}
      else if (child.localName = 'minValuePeriod') then
        element.minValue := ParsePeriod(child, path+'.minValuePeriod') {ePeriod}
      else if (child.localName = 'minValueQuantity') then
        element.minValue := ParseQuantity(child, path+'.minValueQuantity') {eQuantity}
      else if (child.localName = 'minValueAttachment') then
        element.minValue := ParseAttachment(child, path+'.minValueAttachment') {eAttachment}
      else if (child.localName = 'minValueRatio') then
        element.minValue := ParseRatio(child, path+'.minValueRatio') {eRatio}
      else if (child.localName = 'minValueRange') then
        element.minValue := ParseRange(child, path+'.minValueRange') {eRange}
      else if (child.localName = 'minValueAnnotation') then
        element.minValue := ParseAnnotation(child, path+'.minValueAnnotation') {eAnnotation}
      else if (child.localName = 'minValueCodeableConcept') then
        element.minValue := ParseCodeableConcept(child, path+'.minValueCodeableConcept') {eCodeableConcept}
      else if (child.localName = 'minValueHumanName') then
        element.minValue := ParseHumanName(child, path+'/minValueHumanName') {f}
      else if (child.localName = 'minValueMeta') then
        element.minValue := ParseMeta(child, path+'/minValueMeta') {f}
      else if (child.localName = 'minValueContactPoint') then
        element.minValue := ParseContactPoint(child, path+'/minValueContactPoint') {f}
      else if (child.localName = 'minValueAddress') then
        element.minValue := ParseAddress(child, path+'/minValueAddress') {f}
      else if (child.localName = 'minValueElementDefinition') then
        element.minValue := ParseElementDefinition(child, path+'/minValueElementDefinition') {f}
      else if (child.localName = 'minValueTiming') then
        element.minValue := ParseTiming(child, path+'/minValueTiming') {f}
      else if (child.localName = 'maxValueCode') then
        element.maxValue := ParseCode(child, path+'.maxValueCode') {c}
      else if (child.localName = 'maxValueOid') then
        element.maxValue := ParseOid(child, path+'.maxValueOid') {c}
      else if (child.localName = 'maxValueUuid') then
        element.maxValue := ParseUuid(child, path+'.maxValueUuid') {c}
      else if (child.localName = 'maxValueMarkdown') then
        element.maxValue := ParseMarkdown(child, path+'.maxValueMarkdown') {c}
      else if (child.localName = 'maxValueUnsignedInt') then
        element.maxValue := ParseUnsignedInt(child, path+'.maxValueUnsignedInt') {c}
      else if (child.localName = 'maxValueId') then
        element.maxValue := ParseId(child, path+'.maxValueId') {c}
      else if (child.localName = 'maxValuePositiveInt') then
        element.maxValue := ParsePositiveInt(child, path+'.maxValuePositiveInt') {c}
      else if (child.localName = 'maxValueDateTime') then
        element.maxValue := ParseDateTime(child, path+'.maxValueDateTime') {c}
      else if (child.localName = 'maxValueDate') then
        element.maxValue := ParseDate(child, path+'.maxValueDate') {c}
      else if (child.localName = 'maxValueString') then
        element.maxValue := ParseString(child, path+'.maxValueString') {c}
      else if (child.localName = 'maxValueInteger') then
        element.maxValue := ParseInteger(child, path+'.maxValueInteger') {c}
      else if (child.localName = 'maxValueUri') then
        element.maxValue := ParseUri(child, path+'.maxValueUri') {c}
      else if (child.localName = 'maxValueInstant') then
        element.maxValue := ParseInstant(child, path+'.maxValueInstant') {c}
      else if (child.localName = 'maxValueBoolean') then
        element.maxValue := ParseBoolean(child, path+'.maxValueBoolean') {c}
      else if (child.localName = 'maxValueBase64Binary') then
        element.maxValue := ParseBase64Binary(child, path+'.maxValueBase64Binary') {c}
      else if (child.localName = 'maxValueTime') then
        element.maxValue := ParseTime(child, path+'.maxValueTime') {c}
      else if (child.localName = 'maxValueDecimal') then
        element.maxValue := ParseDecimal(child, path+'.maxValueDecimal') {c}
      else if (child.localName = 'maxValueIdentifier') then
        element.maxValue := ParseIdentifier(child, path+'.maxValueIdentifier') {eIdentifier}
      else if (child.localName = 'maxValueCoding') then
        element.maxValue := ParseCoding(child, path+'.maxValueCoding') {eCoding}
      else if (child.localName = 'maxValueReference') then
        element.maxValue := ParseReference(child, path+'.maxValueReference') {eReference}
      else if (child.localName = 'maxValueSignature') then
        element.maxValue := ParseSignature(child, path+'.maxValueSignature') {eSignature}
      else if (child.localName = 'maxValueSampledData') then
        element.maxValue := ParseSampledData(child, path+'.maxValueSampledData') {eSampledData}
      else if (child.localName = 'maxValuePeriod') then
        element.maxValue := ParsePeriod(child, path+'.maxValuePeriod') {ePeriod}
      else if (child.localName = 'maxValueQuantity') then
        element.maxValue := ParseQuantity(child, path+'.maxValueQuantity') {eQuantity}
      else if (child.localName = 'maxValueAttachment') then
        element.maxValue := ParseAttachment(child, path+'.maxValueAttachment') {eAttachment}
      else if (child.localName = 'maxValueRatio') then
        element.maxValue := ParseRatio(child, path+'.maxValueRatio') {eRatio}
      else if (child.localName = 'maxValueRange') then
        element.maxValue := ParseRange(child, path+'.maxValueRange') {eRange}
      else if (child.localName = 'maxValueAnnotation') then
        element.maxValue := ParseAnnotation(child, path+'.maxValueAnnotation') {eAnnotation}
      else if (child.localName = 'maxValueCodeableConcept') then
        element.maxValue := ParseCodeableConcept(child, path+'.maxValueCodeableConcept') {eCodeableConcept}
      else if (child.localName = 'maxValueHumanName') then
        element.maxValue := ParseHumanName(child, path+'/maxValueHumanName') {f}
      else if (child.localName = 'maxValueMeta') then
        element.maxValue := ParseMeta(child, path+'/maxValueMeta') {f}
      else if (child.localName = 'maxValueContactPoint') then
        element.maxValue := ParseContactPoint(child, path+'/maxValueContactPoint') {f}
      else if (child.localName = 'maxValueAddress') then
        element.maxValue := ParseAddress(child, path+'/maxValueAddress') {f}
      else if (child.localName = 'maxValueElementDefinition') then
        element.maxValue := ParseElementDefinition(child, path+'/maxValueElementDefinition') {f}
      else if (child.localName = 'maxValueTiming') then
        element.maxValue := ParseTiming(child, path+'/maxValueTiming') {f}
      else if (child.localName = 'maxLength') then
        element.maxLengthElement := ParseInteger(child, path+'/maxLength') {b}
      else if (child.localName = 'condition') then
        element.conditionList.Add(ParseId(child, path+'/condition')){y.2}
      else if (child.localName = 'constraint') then
        element.constraintList.Add(ParseElementDefinitionConstraint(child, path+'/constraint')){y.2}
      else if (child.localName = 'mustSupport') then
        element.mustSupportElement := ParseBoolean(child, path+'/mustSupport') {b}
      else if (child.localName = 'isModifier') then
        element.isModifierElement := ParseBoolean(child, path+'/isModifier') {b}
      else if (child.localName = 'isSummary') then
        element.isSummaryElement := ParseBoolean(child, path+'/isSummary') {b}
      else if (child.localName = 'binding') then
        element.binding := ParseElementDefinitionBinding(child, path+'/binding') {b}
      else if (child.localName = 'mapping') then
        element.mappingList.Add(ParseElementDefinitionMapping(child, path+'/mapping')){y.2}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeElementDefinition(xml : TXmlBuilder; name : String; elem : TFhirElementDefinition);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeElementDefinitionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeElementDefinitionChildren(xml : TXmlBuilder; elem : TFhirElementDefinition);
var
  i : integer;
begin
  composeElementChildren(xml, elem);
  ComposeString(xml, 'path', elem.pathElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.representationList.Count - 1 do
      ComposeEnum(xml, 'representation', elem.representationList[i], CODES_TFhirPropertyRepresentationEnum);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'label', elem.label_Element);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCoding(xml, 'code', elem.codeList[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeElementDefinitionSlicing(xml, 'slicing', elem.slicing);{x.2a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'short', elem.shortElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeMarkdown(xml, 'definition', elem.definitionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeMarkdown(xml, 'comments', elem.commentsElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeMarkdown(xml, 'requirements', elem.requirementsElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.aliasList.Count - 1 do
      ComposeString(xml, 'alias', elem.aliasList[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInteger(xml, 'min', elem.minElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'max', elem.maxElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeElementDefinitionBase(xml, 'base', elem.base);{x.2a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeElementDefinitionType(xml, 'type', elem.type_List[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'nameReference', elem.nameReferenceElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirCode) {1} then
    ComposeCode(xml, 'defaultValueCode', TFhirCode(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirOid) {1} then
    ComposeOid(xml, 'defaultValueOid', TFhirOid(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirUuid) {1} then
    ComposeUuid(xml, 'defaultValueUuid', TFhirUuid(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirMarkdown) {1} then
    ComposeMarkdown(xml, 'defaultValueMarkdown', TFhirMarkdown(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirUnsignedInt) {1} then
    ComposeUnsignedInt(xml, 'defaultValueUnsignedInt', TFhirUnsignedInt(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirId) {1} then
    ComposeId(xml, 'defaultValueId', TFhirId(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirPositiveInt) {1} then
    ComposePositiveInt(xml, 'defaultValuePositiveInt', TFhirPositiveInt(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirDateTime) {1} then
    ComposeDateTime(xml, 'defaultValueDateTime', TFhirDateTime(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirDate) {1} then
    ComposeDate(xml, 'defaultValueDate', TFhirDate(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirString) {1} then
    ComposeString(xml, 'defaultValueString', TFhirString(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirInteger) {1} then
    ComposeInteger(xml, 'defaultValueInteger', TFhirInteger(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirUri) {1} then
    ComposeUri(xml, 'defaultValueUri', TFhirUri(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirInstant) {1} then
    ComposeInstant(xml, 'defaultValueInstant', TFhirInstant(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirBoolean) {1} then
    ComposeBoolean(xml, 'defaultValueBoolean', TFhirBoolean(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirBase64Binary) {1} then
    ComposeBase64Binary(xml, 'defaultValueBase64Binary', TFhirBase64Binary(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirTime) {1} then
    ComposeTime(xml, 'defaultValueTime', TFhirTime(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.defaultValue is TFhirDecimal) {1} then
    ComposeDecimal(xml, 'defaultValueDecimal', TFhirDecimal(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirIdentifier) {8} then
    ComposeIdentifier(xml, 'defaultValueIdentifier', TFhirIdentifier(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirCoding) {8} then
    ComposeCoding(xml, 'defaultValueCoding', TFhirCoding(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirReference) {8} then
    ComposeReference(xml, 'defaultValueReference', TFhirReference(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirSignature) {8} then
    ComposeSignature(xml, 'defaultValueSignature', TFhirSignature(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirSampledData) {8} then
    ComposeSampledData(xml, 'defaultValueSampledData', TFhirSampledData(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirPeriod) {8} then
    ComposePeriod(xml, 'defaultValuePeriod', TFhirPeriod(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirQuantity) {8} then
    ComposeQuantity(xml, 'defaultValueQuantity', TFhirQuantity(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirAttachment) {8} then
    ComposeAttachment(xml, 'defaultValueAttachment', TFhirAttachment(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirRatio) {8} then
    ComposeRatio(xml, 'defaultValueRatio', TFhirRatio(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirRange) {8} then
    ComposeRange(xml, 'defaultValueRange', TFhirRange(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirAnnotation) {8} then
    ComposeAnnotation(xml, 'defaultValueAnnotation', TFhirAnnotation(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(xml, 'defaultValueCodeableConcept', TFhirCodeableConcept(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirHumanName) {9} then
    ComposeHumanName(xml, 'defaultValueHumanName', TFhirHumanName(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirMeta) {9} then
    ComposeMeta(xml, 'defaultValueMeta', TFhirMeta(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirContactPoint) {9} then
    ComposeContactPoint(xml, 'defaultValueContactPoint', TFhirContactPoint(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirAddress) {9} then
    ComposeAddress(xml, 'defaultValueAddress', TFhirAddress(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirElementDefinition) {9} then
    ComposeElementDefinition(xml, 'defaultValueElementDefinition', TFhirElementDefinition(elem.defaultValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.defaultValue is TFhirTiming) {9} then
    ComposeTiming(xml, 'defaultValueTiming', TFhirTiming(elem.defaultValue));
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeMarkdown(xml, 'meaningWhenMissing', elem.meaningWhenMissingElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirCode) {1} then
    ComposeCode(xml, 'fixedCode', TFhirCode(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirOid) {1} then
    ComposeOid(xml, 'fixedOid', TFhirOid(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirUuid) {1} then
    ComposeUuid(xml, 'fixedUuid', TFhirUuid(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirMarkdown) {1} then
    ComposeMarkdown(xml, 'fixedMarkdown', TFhirMarkdown(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirUnsignedInt) {1} then
    ComposeUnsignedInt(xml, 'fixedUnsignedInt', TFhirUnsignedInt(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirId) {1} then
    ComposeId(xml, 'fixedId', TFhirId(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirPositiveInt) {1} then
    ComposePositiveInt(xml, 'fixedPositiveInt', TFhirPositiveInt(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirDateTime) {1} then
    ComposeDateTime(xml, 'fixedDateTime', TFhirDateTime(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirDate) {1} then
    ComposeDate(xml, 'fixedDate', TFhirDate(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirString) {1} then
    ComposeString(xml, 'fixedString', TFhirString(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirInteger) {1} then
    ComposeInteger(xml, 'fixedInteger', TFhirInteger(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirUri) {1} then
    ComposeUri(xml, 'fixedUri', TFhirUri(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirInstant) {1} then
    ComposeInstant(xml, 'fixedInstant', TFhirInstant(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirBoolean) {1} then
    ComposeBoolean(xml, 'fixedBoolean', TFhirBoolean(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirBase64Binary) {1} then
    ComposeBase64Binary(xml, 'fixedBase64Binary', TFhirBase64Binary(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirTime) {1} then
    ComposeTime(xml, 'fixedTime', TFhirTime(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.fixed is TFhirDecimal) {1} then
    ComposeDecimal(xml, 'fixedDecimal', TFhirDecimal(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirIdentifier) {8} then
    ComposeIdentifier(xml, 'fixedIdentifier', TFhirIdentifier(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirCoding) {8} then
    ComposeCoding(xml, 'fixedCoding', TFhirCoding(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirReference) {8} then
    ComposeReference(xml, 'fixedReference', TFhirReference(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirSignature) {8} then
    ComposeSignature(xml, 'fixedSignature', TFhirSignature(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirSampledData) {8} then
    ComposeSampledData(xml, 'fixedSampledData', TFhirSampledData(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirPeriod) {8} then
    ComposePeriod(xml, 'fixedPeriod', TFhirPeriod(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirQuantity) {8} then
    ComposeQuantity(xml, 'fixedQuantity', TFhirQuantity(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirAttachment) {8} then
    ComposeAttachment(xml, 'fixedAttachment', TFhirAttachment(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirRatio) {8} then
    ComposeRatio(xml, 'fixedRatio', TFhirRatio(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirRange) {8} then
    ComposeRange(xml, 'fixedRange', TFhirRange(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirAnnotation) {8} then
    ComposeAnnotation(xml, 'fixedAnnotation', TFhirAnnotation(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(xml, 'fixedCodeableConcept', TFhirCodeableConcept(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirHumanName) {9} then
    ComposeHumanName(xml, 'fixedHumanName', TFhirHumanName(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirMeta) {9} then
    ComposeMeta(xml, 'fixedMeta', TFhirMeta(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirContactPoint) {9} then
    ComposeContactPoint(xml, 'fixedContactPoint', TFhirContactPoint(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirAddress) {9} then
    ComposeAddress(xml, 'fixedAddress', TFhirAddress(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirElementDefinition) {9} then
    ComposeElementDefinition(xml, 'fixedElementDefinition', TFhirElementDefinition(elem.fixed))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.fixed is TFhirTiming) {9} then
    ComposeTiming(xml, 'fixedTiming', TFhirTiming(elem.fixed));
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirCode) {1} then
    ComposeCode(xml, 'patternCode', TFhirCode(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirOid) {1} then
    ComposeOid(xml, 'patternOid', TFhirOid(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirUuid) {1} then
    ComposeUuid(xml, 'patternUuid', TFhirUuid(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirMarkdown) {1} then
    ComposeMarkdown(xml, 'patternMarkdown', TFhirMarkdown(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirUnsignedInt) {1} then
    ComposeUnsignedInt(xml, 'patternUnsignedInt', TFhirUnsignedInt(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirId) {1} then
    ComposeId(xml, 'patternId', TFhirId(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirPositiveInt) {1} then
    ComposePositiveInt(xml, 'patternPositiveInt', TFhirPositiveInt(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirDateTime) {1} then
    ComposeDateTime(xml, 'patternDateTime', TFhirDateTime(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirDate) {1} then
    ComposeDate(xml, 'patternDate', TFhirDate(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirString) {1} then
    ComposeString(xml, 'patternString', TFhirString(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirInteger) {1} then
    ComposeInteger(xml, 'patternInteger', TFhirInteger(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirUri) {1} then
    ComposeUri(xml, 'patternUri', TFhirUri(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirInstant) {1} then
    ComposeInstant(xml, 'patternInstant', TFhirInstant(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirBoolean) {1} then
    ComposeBoolean(xml, 'patternBoolean', TFhirBoolean(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirBase64Binary) {1} then
    ComposeBase64Binary(xml, 'patternBase64Binary', TFhirBase64Binary(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirTime) {1} then
    ComposeTime(xml, 'patternTime', TFhirTime(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.pattern is TFhirDecimal) {1} then
    ComposeDecimal(xml, 'patternDecimal', TFhirDecimal(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirIdentifier) {8} then
    ComposeIdentifier(xml, 'patternIdentifier', TFhirIdentifier(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirCoding) {8} then
    ComposeCoding(xml, 'patternCoding', TFhirCoding(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirReference) {8} then
    ComposeReference(xml, 'patternReference', TFhirReference(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirSignature) {8} then
    ComposeSignature(xml, 'patternSignature', TFhirSignature(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirSampledData) {8} then
    ComposeSampledData(xml, 'patternSampledData', TFhirSampledData(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirPeriod) {8} then
    ComposePeriod(xml, 'patternPeriod', TFhirPeriod(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirQuantity) {8} then
    ComposeQuantity(xml, 'patternQuantity', TFhirQuantity(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirAttachment) {8} then
    ComposeAttachment(xml, 'patternAttachment', TFhirAttachment(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirRatio) {8} then
    ComposeRatio(xml, 'patternRatio', TFhirRatio(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirRange) {8} then
    ComposeRange(xml, 'patternRange', TFhirRange(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirAnnotation) {8} then
    ComposeAnnotation(xml, 'patternAnnotation', TFhirAnnotation(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(xml, 'patternCodeableConcept', TFhirCodeableConcept(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirHumanName) {9} then
    ComposeHumanName(xml, 'patternHumanName', TFhirHumanName(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirMeta) {9} then
    ComposeMeta(xml, 'patternMeta', TFhirMeta(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirContactPoint) {9} then
    ComposeContactPoint(xml, 'patternContactPoint', TFhirContactPoint(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirAddress) {9} then
    ComposeAddress(xml, 'patternAddress', TFhirAddress(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirElementDefinition) {9} then
    ComposeElementDefinition(xml, 'patternElementDefinition', TFhirElementDefinition(elem.pattern))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.pattern is TFhirTiming) {9} then
    ComposeTiming(xml, 'patternTiming', TFhirTiming(elem.pattern));
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirCode) {1} then
    ComposeCode(xml, 'exampleCode', TFhirCode(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirOid) {1} then
    ComposeOid(xml, 'exampleOid', TFhirOid(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirUuid) {1} then
    ComposeUuid(xml, 'exampleUuid', TFhirUuid(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirMarkdown) {1} then
    ComposeMarkdown(xml, 'exampleMarkdown', TFhirMarkdown(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirUnsignedInt) {1} then
    ComposeUnsignedInt(xml, 'exampleUnsignedInt', TFhirUnsignedInt(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirId) {1} then
    ComposeId(xml, 'exampleId', TFhirId(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirPositiveInt) {1} then
    ComposePositiveInt(xml, 'examplePositiveInt', TFhirPositiveInt(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirDateTime) {1} then
    ComposeDateTime(xml, 'exampleDateTime', TFhirDateTime(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirDate) {1} then
    ComposeDate(xml, 'exampleDate', TFhirDate(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirString) {1} then
    ComposeString(xml, 'exampleString', TFhirString(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirInteger) {1} then
    ComposeInteger(xml, 'exampleInteger', TFhirInteger(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirUri) {1} then
    ComposeUri(xml, 'exampleUri', TFhirUri(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirInstant) {1} then
    ComposeInstant(xml, 'exampleInstant', TFhirInstant(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirBoolean) {1} then
    ComposeBoolean(xml, 'exampleBoolean', TFhirBoolean(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirBase64Binary) {1} then
    ComposeBase64Binary(xml, 'exampleBase64Binary', TFhirBase64Binary(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirTime) {1} then
    ComposeTime(xml, 'exampleTime', TFhirTime(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.example is TFhirDecimal) {1} then
    ComposeDecimal(xml, 'exampleDecimal', TFhirDecimal(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirIdentifier) {8} then
    ComposeIdentifier(xml, 'exampleIdentifier', TFhirIdentifier(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirCoding) {8} then
    ComposeCoding(xml, 'exampleCoding', TFhirCoding(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirReference) {8} then
    ComposeReference(xml, 'exampleReference', TFhirReference(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirSignature) {8} then
    ComposeSignature(xml, 'exampleSignature', TFhirSignature(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirSampledData) {8} then
    ComposeSampledData(xml, 'exampleSampledData', TFhirSampledData(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirPeriod) {8} then
    ComposePeriod(xml, 'examplePeriod', TFhirPeriod(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirQuantity) {8} then
    ComposeQuantity(xml, 'exampleQuantity', TFhirQuantity(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirAttachment) {8} then
    ComposeAttachment(xml, 'exampleAttachment', TFhirAttachment(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirRatio) {8} then
    ComposeRatio(xml, 'exampleRatio', TFhirRatio(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirRange) {8} then
    ComposeRange(xml, 'exampleRange', TFhirRange(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirAnnotation) {8} then
    ComposeAnnotation(xml, 'exampleAnnotation', TFhirAnnotation(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(xml, 'exampleCodeableConcept', TFhirCodeableConcept(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirHumanName) {9} then
    ComposeHumanName(xml, 'exampleHumanName', TFhirHumanName(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirMeta) {9} then
    ComposeMeta(xml, 'exampleMeta', TFhirMeta(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirContactPoint) {9} then
    ComposeContactPoint(xml, 'exampleContactPoint', TFhirContactPoint(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirAddress) {9} then
    ComposeAddress(xml, 'exampleAddress', TFhirAddress(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirElementDefinition) {9} then
    ComposeElementDefinition(xml, 'exampleElementDefinition', TFhirElementDefinition(elem.example))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.example is TFhirTiming) {9} then
    ComposeTiming(xml, 'exampleTiming', TFhirTiming(elem.example));
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirCode) {1} then
    ComposeCode(xml, 'minValueCode', TFhirCode(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirOid) {1} then
    ComposeOid(xml, 'minValueOid', TFhirOid(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirUuid) {1} then
    ComposeUuid(xml, 'minValueUuid', TFhirUuid(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirMarkdown) {1} then
    ComposeMarkdown(xml, 'minValueMarkdown', TFhirMarkdown(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirUnsignedInt) {1} then
    ComposeUnsignedInt(xml, 'minValueUnsignedInt', TFhirUnsignedInt(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirId) {1} then
    ComposeId(xml, 'minValueId', TFhirId(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirPositiveInt) {1} then
    ComposePositiveInt(xml, 'minValuePositiveInt', TFhirPositiveInt(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirDateTime) {1} then
    ComposeDateTime(xml, 'minValueDateTime', TFhirDateTime(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirDate) {1} then
    ComposeDate(xml, 'minValueDate', TFhirDate(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirString) {1} then
    ComposeString(xml, 'minValueString', TFhirString(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirInteger) {1} then
    ComposeInteger(xml, 'minValueInteger', TFhirInteger(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirUri) {1} then
    ComposeUri(xml, 'minValueUri', TFhirUri(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirInstant) {1} then
    ComposeInstant(xml, 'minValueInstant', TFhirInstant(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirBoolean) {1} then
    ComposeBoolean(xml, 'minValueBoolean', TFhirBoolean(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirBase64Binary) {1} then
    ComposeBase64Binary(xml, 'minValueBase64Binary', TFhirBase64Binary(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirTime) {1} then
    ComposeTime(xml, 'minValueTime', TFhirTime(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.minValue is TFhirDecimal) {1} then
    ComposeDecimal(xml, 'minValueDecimal', TFhirDecimal(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirIdentifier) {8} then
    ComposeIdentifier(xml, 'minValueIdentifier', TFhirIdentifier(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirCoding) {8} then
    ComposeCoding(xml, 'minValueCoding', TFhirCoding(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirReference) {8} then
    ComposeReference(xml, 'minValueReference', TFhirReference(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirSignature) {8} then
    ComposeSignature(xml, 'minValueSignature', TFhirSignature(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirSampledData) {8} then
    ComposeSampledData(xml, 'minValueSampledData', TFhirSampledData(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirPeriod) {8} then
    ComposePeriod(xml, 'minValuePeriod', TFhirPeriod(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirQuantity) {8} then
    ComposeQuantity(xml, 'minValueQuantity', TFhirQuantity(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirAttachment) {8} then
    ComposeAttachment(xml, 'minValueAttachment', TFhirAttachment(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirRatio) {8} then
    ComposeRatio(xml, 'minValueRatio', TFhirRatio(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirRange) {8} then
    ComposeRange(xml, 'minValueRange', TFhirRange(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirAnnotation) {8} then
    ComposeAnnotation(xml, 'minValueAnnotation', TFhirAnnotation(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(xml, 'minValueCodeableConcept', TFhirCodeableConcept(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirHumanName) {9} then
    ComposeHumanName(xml, 'minValueHumanName', TFhirHumanName(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirMeta) {9} then
    ComposeMeta(xml, 'minValueMeta', TFhirMeta(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirContactPoint) {9} then
    ComposeContactPoint(xml, 'minValueContactPoint', TFhirContactPoint(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirAddress) {9} then
    ComposeAddress(xml, 'minValueAddress', TFhirAddress(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirElementDefinition) {9} then
    ComposeElementDefinition(xml, 'minValueElementDefinition', TFhirElementDefinition(elem.minValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.minValue is TFhirTiming) {9} then
    ComposeTiming(xml, 'minValueTiming', TFhirTiming(elem.minValue));
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirCode) {1} then
    ComposeCode(xml, 'maxValueCode', TFhirCode(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirOid) {1} then
    ComposeOid(xml, 'maxValueOid', TFhirOid(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirUuid) {1} then
    ComposeUuid(xml, 'maxValueUuid', TFhirUuid(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirMarkdown) {1} then
    ComposeMarkdown(xml, 'maxValueMarkdown', TFhirMarkdown(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirUnsignedInt) {1} then
    ComposeUnsignedInt(xml, 'maxValueUnsignedInt', TFhirUnsignedInt(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirId) {1} then
    ComposeId(xml, 'maxValueId', TFhirId(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirPositiveInt) {1} then
    ComposePositiveInt(xml, 'maxValuePositiveInt', TFhirPositiveInt(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirDateTime) {1} then
    ComposeDateTime(xml, 'maxValueDateTime', TFhirDateTime(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirDate) {1} then
    ComposeDate(xml, 'maxValueDate', TFhirDate(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirString) {1} then
    ComposeString(xml, 'maxValueString', TFhirString(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirInteger) {1} then
    ComposeInteger(xml, 'maxValueInteger', TFhirInteger(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirUri) {1} then
    ComposeUri(xml, 'maxValueUri', TFhirUri(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirInstant) {1} then
    ComposeInstant(xml, 'maxValueInstant', TFhirInstant(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirBoolean) {1} then
    ComposeBoolean(xml, 'maxValueBoolean', TFhirBoolean(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirBase64Binary) {1} then
    ComposeBase64Binary(xml, 'maxValueBase64Binary', TFhirBase64Binary(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirTime) {1} then
    ComposeTime(xml, 'maxValueTime', TFhirTime(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData]) and (elem.maxValue is TFhirDecimal) {1} then
    ComposeDecimal(xml, 'maxValueDecimal', TFhirDecimal(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirIdentifier) {8} then
    ComposeIdentifier(xml, 'maxValueIdentifier', TFhirIdentifier(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirCoding) {8} then
    ComposeCoding(xml, 'maxValueCoding', TFhirCoding(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirReference) {8} then
    ComposeReference(xml, 'maxValueReference', TFhirReference(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirSignature) {8} then
    ComposeSignature(xml, 'maxValueSignature', TFhirSignature(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirSampledData) {8} then
    ComposeSampledData(xml, 'maxValueSampledData', TFhirSampledData(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirPeriod) {8} then
    ComposePeriod(xml, 'maxValuePeriod', TFhirPeriod(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirQuantity) {8} then
    ComposeQuantity(xml, 'maxValueQuantity', TFhirQuantity(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirAttachment) {8} then
    ComposeAttachment(xml, 'maxValueAttachment', TFhirAttachment(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirRatio) {8} then
    ComposeRatio(xml, 'maxValueRatio', TFhirRatio(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirRange) {8} then
    ComposeRange(xml, 'maxValueRange', TFhirRange(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirAnnotation) {8} then
    ComposeAnnotation(xml, 'maxValueAnnotation', TFhirAnnotation(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirCodeableConcept) {8} then
    ComposeCodeableConcept(xml, 'maxValueCodeableConcept', TFhirCodeableConcept(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirHumanName) {9} then
    ComposeHumanName(xml, 'maxValueHumanName', TFhirHumanName(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirMeta) {9} then
    ComposeMeta(xml, 'maxValueMeta', TFhirMeta(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirContactPoint) {9} then
    ComposeContactPoint(xml, 'maxValueContactPoint', TFhirContactPoint(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirAddress) {9} then
    ComposeAddress(xml, 'maxValueAddress', TFhirAddress(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirElementDefinition) {9} then
    ComposeElementDefinition(xml, 'maxValueElementDefinition', TFhirElementDefinition(elem.maxValue))
  else if (SummaryOption in [soFull, soSummary, soText, soData])  and (elem.maxValue is TFhirTiming) {9} then
    ComposeTiming(xml, 'maxValueTiming', TFhirTiming(elem.maxValue));
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInteger(xml, 'maxLength', elem.maxLengthElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.conditionList.Count - 1 do
      ComposeId(xml, 'condition', elem.conditionList[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.constraintList.Count - 1 do
      ComposeElementDefinitionConstraint(xml, 'constraint', elem.constraintList[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (not isCanonical or (elem.mustSupport <> false)) then
    ComposeBoolean(xml, 'mustSupport', elem.mustSupportElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (not isCanonical or (elem.isModifier <> false)) then
    ComposeBoolean(xml, 'isModifier', elem.isModifierElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) and (not isCanonical or (elem.isSummary <> false)) then
    ComposeBoolean(xml, 'isSummary', elem.isSummaryElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeElementDefinitionBinding(xml, 'binding', elem.binding);{x.2a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.mappingList.Count - 1 do
      ComposeElementDefinitionMapping(xml, 'mapping', elem.mappingList[i]);
end;

function TFHIRXmlParser.ParseTimingRepeat(element : TMXmlElement; path : string) : TFhirTimingRepeat;
var
  child : TMXmlElement;
begin
  result := TFhirTimingRepeat.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTimingRepeatChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTimingRepeatChild(element : TFhirTimingRepeat; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'boundsQuantity') then
        element.bounds := ParseQuantity(child, path+'/boundsQuantity'){x.3}
      else if (child.localName = 'boundsRange') then
        element.bounds := ParseRange(child, path+'/boundsRange'){x.3}
      else if (child.localName = 'boundsPeriod') then
        element.bounds := ParsePeriod(child, path+'/boundsPeriod'){x.3}
      else if (child.localName = 'count') then
        element.countElement := ParseInteger(child, path+'/count') {b}
      else if (child.localName = 'duration') then
        element.durationElement := ParseDecimal(child, path+'/duration') {b}
      else if (child.localName = 'durationMax') then
        element.durationMaxElement := ParseDecimal(child, path+'/durationMax') {b}
      else if (child.localName = 'durationUnits') then
        element.durationUnitsElement := ParseEnum(CODES_TFhirUnitsOfTimeEnum, SYSTEMS_TFhirUnitsOfTimeEnum, path+'/durationUnits', child){1a}
      else if (child.localName = 'frequency') then
        element.frequencyElement := ParseInteger(child, path+'/frequency') {b}
      else if (child.localName = 'frequencyMax') then
        element.frequencyMaxElement := ParseInteger(child, path+'/frequencyMax') {b}
      else if (child.localName = 'period') then
        element.periodElement := ParseDecimal(child, path+'/period') {b}
      else if (child.localName = 'periodMax') then
        element.periodMaxElement := ParseDecimal(child, path+'/periodMax') {b}
      else if (child.localName = 'periodUnits') then
        element.periodUnitsElement := ParseEnum(CODES_TFhirUnitsOfTimeEnum, SYSTEMS_TFhirUnitsOfTimeEnum, path+'/periodUnits', child){1a}
      else if (child.localName = 'when') then
        element.whenElement := ParseEnum(CODES_TFhirEventTimingEnum, SYSTEMS_TFhirEventTimingEnum, path+'/when', child){1a}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTimingRepeat(xml : TXmlBuilder; name : String; elem : TFhirTimingRepeat);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTimingRepeatChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTimingRepeatChildren(xml : TXmlBuilder; elem : TFhirTimingRepeat);
begin
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.bounds is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'boundsQuantity', TFhirQuantity(elem.bounds))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.bounds is TFhirRange) {6} then
    ComposeRange(xml, 'boundsRange', TFhirRange(elem.bounds))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.bounds is TFhirPeriod) {6} then
    ComposePeriod(xml, 'boundsPeriod', TFhirPeriod(elem.bounds));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(xml, 'count', elem.countElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'duration', elem.durationElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'durationMax', elem.durationMaxElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'durationUnits', elem.DurationUnitsElement, CODES_TFhirUnitsOfTimeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.frequency <> '1')) then
    ComposeInteger(xml, 'frequency', elem.frequencyElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(xml, 'frequencyMax', elem.frequencyMaxElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'period', elem.periodElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'periodMax', elem.periodMaxElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'periodUnits', elem.PeriodUnitsElement, CODES_TFhirUnitsOfTimeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'when', elem.WhenElement, CODES_TFhirEventTimingEnum);
end;

function TFHIRXmlParser.ParseTiming(element : TMXmlElement; path : string) : TFhirTiming;
var
  child : TMXmlElement;
begin
  result := TFhirTiming.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTimingChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTimingChild(element : TFhirTiming; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'event') then
        element.eventList.Add(ParseDateTime(child, path+'/event')){y.2}
      else if (child.localName = 'repeat') then
        element.repeat_ := ParseTimingRepeat(child, path+'/repeat') {b}
      else if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if Not ParseElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTiming(xml : TXmlBuilder; name : String; elem : TFhirTiming);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTimingChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTimingChildren(xml : TXmlBuilder; elem : TFhirTiming);
var
  i : integer;
begin
  composeElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.eventList.Count - 1 do
      ComposeDateTime(xml, 'event', elem.eventList[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeTimingRepeat(xml, 'repeat', elem.repeat_);{x.2a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
end;

{$IFDEF FHIR_ACCOUNT}
function TFHIRXmlParser.ParseAccount(element : TMXmlElement; path : string) : TFhirAccount;
var
  child : TMXmlElement;
begin
  result := TFhirAccount.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAccountChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAccountChild(element : TFhirAccount; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseCode(child, path+'/status') {b}
      else if (child.localName = 'activePeriod') then
        element.activePeriod := ParsePeriod(child, path+'/activePeriod') {b}
      else if (child.localName = 'currency') then
        element.currency := ParseCoding(child, path+'/currency') {b}
      else if (child.localName = 'balance') then
        element.balance := ParseQuantity(child, path+'/balance') {b}
      else if (child.localName = 'coveragePeriod') then
        element.coveragePeriod := ParsePeriod(child, path+'/coveragePeriod') {b}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'owner') then
        element.owner := ParseReference{TFhirOrganization}(child, path+'/owner') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAccount(xml : TXmlBuilder; name : String; elem : TFhirAccount);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAccountChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAccountChildren(xml : TXmlBuilder; elem : TFhirAccount);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeCode(xml, 'status', elem.statusElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('activePeriod') then
    ComposePeriod(xml, 'activePeriod', elem.activePeriod);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('currency') then
    ComposeCoding(xml, 'currency', elem.currency);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('balance') then
    ComposeQuantity(xml, 'balance', elem.balance);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('coveragePeriod') then
    ComposePeriod(xml, 'coveragePeriod', elem.coveragePeriod);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('owner') then
    ComposeReference{TFhirOrganization}(xml, 'owner', elem.owner);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
end;

{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
function TFHIRXmlParser.ParseAllergyIntoleranceReaction(element : TMXmlElement; path : string) : TFhirAllergyIntoleranceReaction;
var
  child : TMXmlElement;
begin
  result := TFhirAllergyIntoleranceReaction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAllergyIntoleranceReactionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAllergyIntoleranceReactionChild(element : TFhirAllergyIntoleranceReaction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'substance') then
        element.substance := ParseCodeableConcept(child, path+'/substance') {b}
      else if (child.localName = 'certainty') then
        element.certaintyElement := ParseEnum(CODES_TFhirReactionEventCertaintyEnum, SYSTEMS_TFhirReactionEventCertaintyEnum, path+'/certainty', child){1a}
      else if (child.localName = 'manifestation') then
        element.manifestationList.Add(ParseCodeableConcept(child, path+'/manifestation')){y.2}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'onset') then
        element.onsetElement := ParseDateTime(child, path+'/onset') {b}
      else if (child.localName = 'severity') then
        element.severityElement := ParseEnum(CODES_TFhirReactionEventSeverityEnum, SYSTEMS_TFhirReactionEventSeverityEnum, path+'/severity', child){1a}
      else if (child.localName = 'exposureRoute') then
        element.exposureRoute := ParseCodeableConcept(child, path+'/exposureRoute') {b}
      else if (child.localName = 'note') then
        element.note := ParseAnnotation(child, path+'/note') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAllergyIntoleranceReaction(xml : TXmlBuilder; name : String; elem : TFhirAllergyIntoleranceReaction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAllergyIntoleranceReactionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAllergyIntoleranceReactionChildren(xml : TXmlBuilder; elem : TFhirAllergyIntoleranceReaction);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'substance', elem.substance);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'certainty', elem.CertaintyElement, CODES_TFhirReactionEventCertaintyEnum);
  for i := 0 to elem.manifestationList.Count - 1 do
      ComposeCodeableConcept(xml, 'manifestation', elem.manifestationList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'onset', elem.onsetElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'severity', elem.SeverityElement, CODES_TFhirReactionEventSeverityEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'exposureRoute', elem.exposureRoute);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeAnnotation(xml, 'note', elem.note);{x.2a}
end;

function TFHIRXmlParser.ParseAllergyIntolerance(element : TMXmlElement; path : string) : TFhirAllergyIntolerance;
var
  child : TMXmlElement;
begin
  result := TFhirAllergyIntolerance.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAllergyIntoleranceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAllergyIntoleranceChild(element : TFhirAllergyIntolerance; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'onset') then
        element.onsetElement := ParseDateTime(child, path+'/onset') {b}
      else if (child.localName = 'recordedDate') then
        element.recordedDateElement := ParseDateTime(child, path+'/recordedDate') {b}
      else if (child.localName = 'recorder') then
        element.recorder := ParseReference{Resource}(child, path+'/recorder') {b}
      else if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'reporter') then
        element.reporter := ParseReference{Resource}(child, path+'/reporter') {b}
      else if (child.localName = 'substance') then
        element.substance := ParseCodeableConcept(child, path+'/substance') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirAllergyIntoleranceStatusEnum, SYSTEMS_TFhirAllergyIntoleranceStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'criticality') then
        element.criticalityElement := ParseEnum(CODES_TFhirAllergyIntoleranceCriticalityEnum, SYSTEMS_TFhirAllergyIntoleranceCriticalityEnum, path+'/criticality', child){1a}
      else if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirAllergyIntoleranceTypeEnum, SYSTEMS_TFhirAllergyIntoleranceTypeEnum, path+'/type', child){1a}
      else if (child.localName = 'category') then
        element.categoryElement := ParseEnum(CODES_TFhirAllergyIntoleranceCategoryEnum, SYSTEMS_TFhirAllergyIntoleranceCategoryEnum, path+'/category', child){1a}
      else if (child.localName = 'lastOccurence') then
        element.lastOccurenceElement := ParseDateTime(child, path+'/lastOccurence') {b}
      else if (child.localName = 'note') then
        element.note := ParseAnnotation(child, path+'/note') {b}
      else if (child.localName = 'reaction') then
        element.reactionList.Add(ParseAllergyIntoleranceReaction(child, path+'/reaction')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAllergyIntolerance(xml : TXmlBuilder; name : String; elem : TFhirAllergyIntolerance);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAllergyIntoleranceChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAllergyIntoleranceChildren(xml : TXmlBuilder; elem : TFhirAllergyIntolerance);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('onset') then
    ComposeDateTime(xml, 'onset', elem.onsetElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recordedDate') then
    ComposeDateTime(xml, 'recordedDate', elem.recordedDateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recorder') then
    ComposeReference{Resource}(xml, 'recorder', elem.recorder);{x.2a}
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reporter') then
    ComposeReference{Resource}(xml, 'reporter', elem.reporter);{x.2a}
  ComposeCodeableConcept(xml, 'substance', elem.substance);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirAllergyIntoleranceStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('criticality') then
    ComposeEnum(xml, 'criticality', elem.CriticalityElement, CODES_TFhirAllergyIntoleranceCriticalityEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirAllergyIntoleranceTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeEnum(xml, 'category', elem.CategoryElement, CODES_TFhirAllergyIntoleranceCategoryEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('lastOccurence') then
    ComposeDateTime(xml, 'lastOccurence', elem.lastOccurenceElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    ComposeAnnotation(xml, 'note', elem.note);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('reaction') then
    for i := 0 to elem.reactionList.Count - 1 do
      ComposeAllergyIntoleranceReaction(xml, 'reaction', elem.reactionList[i]);
end;

{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
function TFHIRXmlParser.ParseAppointmentParticipant(element : TMXmlElement; path : string) : TFhirAppointmentParticipant;
var
  child : TMXmlElement;
begin
  result := TFhirAppointmentParticipant.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAppointmentParticipantChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAppointmentParticipantChild(element : TFhirAppointmentParticipant; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_List.Add(ParseCodeableConcept(child, path+'/type')){y.2}
      else if (child.localName = 'actor') then
        element.actor := ParseReference{Resource}(child, path+'/actor') {b}
      else if (child.localName = 'required') then
        element.requiredElement := ParseEnum(CODES_TFhirParticipantrequiredEnum, SYSTEMS_TFhirParticipantrequiredEnum, path+'/required', child){1a}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirParticipationstatusEnum, SYSTEMS_TFhirParticipationstatusEnum, path+'/status', child){1a}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAppointmentParticipant(xml : TXmlBuilder; name : String; elem : TFhirAppointmentParticipant);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAppointmentParticipantChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAppointmentParticipantChildren(xml : TXmlBuilder; elem : TFhirAppointmentParticipant);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', elem.type_List[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'actor', elem.actor);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'required', elem.RequiredElement, CODES_TFhirParticipantrequiredEnum);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirParticipationstatusEnum);
end;

function TFHIRXmlParser.ParseAppointment(element : TMXmlElement; path : string) : TFhirAppointment;
var
  child : TMXmlElement;
begin
  result := TFhirAppointment.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAppointmentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAppointmentChild(element : TFhirAppointment; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirAppointmentstatusEnum, SYSTEMS_TFhirAppointmentstatusEnum, path+'/status', child){1a}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'reason') then
        element.reason := ParseCodeableConcept(child, path+'/reason') {b}
      else if (child.localName = 'priority') then
        element.priorityElement := ParseUnsignedInt(child, path+'/priority') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'start') then
        element.startElement := ParseInstant(child, path+'/start') {b}
      else if (child.localName = 'end') then
        element.end_Element := ParseInstant(child, path+'/end') {b}
      else if (child.localName = 'minutesDuration') then
        element.minutesDurationElement := ParsePositiveInt(child, path+'/minutesDuration') {b}
      else if (child.localName = 'slot') then
        element.slotList.Add(ParseReference{TFhirSlot}(child, path+'/slot')){y.2}
      else if (child.localName = 'comment') then
        element.commentElement := ParseString(child, path+'/comment') {b}
      else if (child.localName = 'participant') then
        element.participantList.Add(ParseAppointmentParticipant(child, path+'/participant')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAppointment(xml : TXmlBuilder; name : String; elem : TFhirAppointment);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAppointmentChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAppointmentChildren(xml : TXmlBuilder; elem : TFhirAppointment);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirAppointmentstatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reason') then
    ComposeCodeableConcept(xml, 'reason', elem.reason);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('priority') then
    ComposeUnsignedInt(xml, 'priority', elem.priorityElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('start') then
    ComposeInstant(xml, 'start', elem.startElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('end_') then
    ComposeInstant(xml, 'end', elem.end_Element);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('minutesDuration') then
    ComposePositiveInt(xml, 'minutesDuration', elem.minutesDurationElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('slot') then
    for i := 0 to elem.slotList.Count - 1 do
      ComposeReference{TFhirSlot}(xml, 'slot', elem.slotList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeString(xml, 'comment', elem.commentElement);{x.2b}
  for i := 0 to elem.participantList.Count - 1 do
      ComposeAppointmentParticipant(xml, 'participant', elem.participantList[i]);
end;

{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
function TFHIRXmlParser.ParseAppointmentResponse(element : TMXmlElement; path : string) : TFhirAppointmentResponse;
var
  child : TMXmlElement;
begin
  result := TFhirAppointmentResponse.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAppointmentResponseChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAppointmentResponseChild(element : TFhirAppointmentResponse; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'appointment') then
        element.appointment := ParseReference{TFhirAppointment}(child, path+'/appointment') {b}
      else if (child.localName = 'start') then
        element.startElement := ParseInstant(child, path+'/start') {b}
      else if (child.localName = 'end') then
        element.end_Element := ParseInstant(child, path+'/end') {b}
      else if (child.localName = 'participantType') then
        element.participantTypeList.Add(ParseCodeableConcept(child, path+'/participantType')){y.2}
      else if (child.localName = 'actor') then
        element.actor := ParseReference{Resource}(child, path+'/actor') {b}
      else if (child.localName = 'participantStatus') then
        element.participantStatusElement := ParseEnum(CODES_TFhirParticipantstatusEnum, SYSTEMS_TFhirParticipantstatusEnum, path+'/participantStatus', child){1a}
      else if (child.localName = 'comment') then
        element.commentElement := ParseString(child, path+'/comment') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAppointmentResponse(xml : TXmlBuilder; name : String; elem : TFhirAppointmentResponse);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAppointmentResponseChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAppointmentResponseChildren(xml : TXmlBuilder; elem : TFhirAppointmentResponse);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{TFhirAppointment}(xml, 'appointment', elem.appointment);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('start') then
    ComposeInstant(xml, 'start', elem.startElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('end_') then
    ComposeInstant(xml, 'end', elem.end_Element);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('participantType') then
    for i := 0 to elem.participantTypeList.Count - 1 do
      ComposeCodeableConcept(xml, 'participantType', elem.participantTypeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('actor') then
    ComposeReference{Resource}(xml, 'actor', elem.actor);{x.2a}
  ComposeEnum(xml, 'participantStatus', elem.ParticipantStatusElement, CODES_TFhirParticipantstatusEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeString(xml, 'comment', elem.commentElement);{x.2b}
end;

{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
function TFHIRXmlParser.ParseAuditEventEvent(element : TMXmlElement; path : string) : TFhirAuditEventEvent;
var
  child : TMXmlElement;
begin
  result := TFhirAuditEventEvent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAuditEventEventChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAuditEventEventChild(element : TFhirAuditEventEvent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.localName = 'subtype') then
        element.subtypeList.Add(ParseCoding(child, path+'/subtype')){y.2}
      else if (child.localName = 'action') then
        element.actionElement := ParseEnum(CODES_TFhirAuditEventActionEnum, SYSTEMS_TFhirAuditEventActionEnum, path+'/action', child){1a}
      else if (child.localName = 'dateTime') then
        element.dateTimeElement := ParseInstant(child, path+'/dateTime') {b}
      else if (child.localName = 'outcome') then
        element.outcomeElement := ParseEnum(CODES_TFhirAuditEventOutcomeEnum, SYSTEMS_TFhirAuditEventOutcomeEnum, path+'/outcome', child){1a}
      else if (child.localName = 'outcomeDesc') then
        element.outcomeDescElement := ParseString(child, path+'/outcomeDesc') {b}
      else if (child.localName = 'purposeOfEvent') then
        element.purposeOfEventList.Add(ParseCoding(child, path+'/purposeOfEvent')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAuditEventEvent(xml : TXmlBuilder; name : String; elem : TFhirAuditEventEvent);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAuditEventEventChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAuditEventEventChildren(xml : TXmlBuilder; elem : TFhirAuditEventEvent);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCoding(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.subtypeList.Count - 1 do
      ComposeCoding(xml, 'subtype', elem.subtypeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'action', elem.ActionElement, CODES_TFhirAuditEventActionEnum);
  ComposeInstant(xml, 'dateTime', elem.dateTimeElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'outcome', elem.OutcomeElement, CODES_TFhirAuditEventOutcomeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'outcomeDesc', elem.outcomeDescElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.purposeOfEventList.Count - 1 do
      ComposeCoding(xml, 'purposeOfEvent', elem.purposeOfEventList[i]);
end;

function TFHIRXmlParser.ParseAuditEventParticipant(element : TMXmlElement; path : string) : TFhirAuditEventParticipant;
var
  child : TMXmlElement;
begin
  result := TFhirAuditEventParticipant.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAuditEventParticipantChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAuditEventParticipantChild(element : TFhirAuditEventParticipant; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'role') then
        element.roleList.Add(ParseCodeableConcept(child, path+'/role')){y.2}
      else if (child.localName = 'reference') then
        element.reference := ParseReference{Resource}(child, path+'/reference') {b}
      else if (child.localName = 'userId') then
        element.userId := ParseIdentifier(child, path+'/userId') {b}
      else if (child.localName = 'altId') then
        element.altIdElement := ParseString(child, path+'/altId') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'requestor') then
        element.requestorElement := ParseBoolean(child, path+'/requestor') {b}
      else if (child.localName = 'location') then
        element.location := ParseReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.localName = 'policy') then
        element.policyList.Add(ParseUri(child, path+'/policy')){y.2}
      else if (child.localName = 'media') then
        element.media := ParseCoding(child, path+'/media') {b}
      else if (child.localName = 'network') then
        element.network := ParseAuditEventParticipantNetwork(child, path+'/network') {b}
      else if (child.localName = 'purposeOfUse') then
        element.purposeOfUseList.Add(ParseCoding(child, path+'/purposeOfUse')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAuditEventParticipant(xml : TXmlBuilder; name : String; elem : TFhirAuditEventParticipant);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAuditEventParticipantChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAuditEventParticipantChildren(xml : TXmlBuilder; elem : TFhirAuditEventParticipant);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(xml, 'role', elem.roleList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'reference', elem.reference);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'userId', elem.userId);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'altId', elem.altIdElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  ComposeBoolean(xml, 'requestor', elem.requestorElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(xml, 'location', elem.location);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.policyList.Count - 1 do
      ComposeUri(xml, 'policy', elem.policyList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(xml, 'media', elem.media);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeAuditEventParticipantNetwork(xml, 'network', elem.network);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.purposeOfUseList.Count - 1 do
      ComposeCoding(xml, 'purposeOfUse', elem.purposeOfUseList[i]);
end;

function TFHIRXmlParser.ParseAuditEventParticipantNetwork(element : TMXmlElement; path : string) : TFhirAuditEventParticipantNetwork;
var
  child : TMXmlElement;
begin
  result := TFhirAuditEventParticipantNetwork.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAuditEventParticipantNetworkChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAuditEventParticipantNetworkChild(element : TFhirAuditEventParticipantNetwork; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'address') then
        element.addressElement := ParseString(child, path+'/address') {b}
      else if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirNetworkTypeEnum, SYSTEMS_TFhirNetworkTypeEnum, path+'/type', child){1a}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAuditEventParticipantNetwork(xml : TXmlBuilder; name : String; elem : TFhirAuditEventParticipantNetwork);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAuditEventParticipantNetworkChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAuditEventParticipantNetworkChildren(xml : TXmlBuilder; elem : TFhirAuditEventParticipantNetwork);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'address', elem.addressElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirNetworkTypeEnum);
end;

function TFHIRXmlParser.ParseAuditEventSource(element : TMXmlElement; path : string) : TFhirAuditEventSource;
var
  child : TMXmlElement;
begin
  result := TFhirAuditEventSource.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAuditEventSourceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAuditEventSourceChild(element : TFhirAuditEventSource; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'site') then
        element.siteElement := ParseString(child, path+'/site') {b}
      else if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'type') then
        element.type_List.Add(ParseCoding(child, path+'/type')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAuditEventSource(xml : TXmlBuilder; name : String; elem : TFhirAuditEventSource);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAuditEventSourceChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAuditEventSourceChildren(xml : TXmlBuilder; elem : TFhirAuditEventSource);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'site', elem.siteElement);{x.2b}
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCoding(xml, 'type', elem.type_List[i]);
end;

function TFHIRXmlParser.ParseAuditEventObject(element : TMXmlElement; path : string) : TFhirAuditEventObject;
var
  child : TMXmlElement;
begin
  result := TFhirAuditEventObject.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAuditEventObjectChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAuditEventObjectChild(element : TFhirAuditEventObject; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'reference') then
        element.reference := ParseReference{TFhirReference}(child, path+'/reference') {b}
      else if (child.localName = 'type') then
        element.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.localName = 'role') then
        element.role := ParseCoding(child, path+'/role') {b}
      else if (child.localName = 'lifecycle') then
        element.lifecycle := ParseCoding(child, path+'/lifecycle') {b}
      else if (child.localName = 'securityLabel') then
        element.securityLabelList.Add(ParseCoding(child, path+'/securityLabel')){y.2}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'query') then
        element.queryElement := ParseBase64Binary(child, path+'/query') {b}
      else if (child.localName = 'detail') then
        element.detailList.Add(ParseAuditEventObjectDetail(child, path+'/detail')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAuditEventObject(xml : TXmlBuilder; name : String; elem : TFhirAuditEventObject);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAuditEventObjectChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAuditEventObjectChildren(xml : TXmlBuilder; elem : TFhirAuditEventObject);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(xml, 'reference', elem.reference);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(xml, 'role', elem.role);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(xml, 'lifecycle', elem.lifecycle);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.securityLabelList.Count - 1 do
      ComposeCoding(xml, 'securityLabel', elem.securityLabelList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBase64Binary(xml, 'query', elem.queryElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeAuditEventObjectDetail(xml, 'detail', elem.detailList[i]);
end;

function TFHIRXmlParser.ParseAuditEventObjectDetail(element : TMXmlElement; path : string) : TFhirAuditEventObjectDetail;
var
  child : TMXmlElement;
begin
  result := TFhirAuditEventObjectDetail.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAuditEventObjectDetailChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAuditEventObjectDetailChild(element : TFhirAuditEventObjectDetail; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_Element := ParseString(child, path+'/type') {b}
      else if (child.localName = 'value') then
        element.valueElement := ParseBase64Binary(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAuditEventObjectDetail(xml : TXmlBuilder; name : String; elem : TFhirAuditEventObjectDetail);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAuditEventObjectDetailChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAuditEventObjectDetailChildren(xml : TXmlBuilder; elem : TFhirAuditEventObjectDetail);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'type', elem.type_Element);{x.2b}
  ComposeBase64Binary(xml, 'value', elem.valueElement);{x.2b}
end;

function TFHIRXmlParser.ParseAuditEvent(element : TMXmlElement; path : string) : TFhirAuditEvent;
var
  child : TMXmlElement;
begin
  result := TFhirAuditEvent.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseAuditEventChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAuditEventChild(element : TFhirAuditEvent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'event') then
        element.event := ParseAuditEventEvent(child, path+'/event') {b}
      else if (child.localName = 'participant') then
        element.participantList.Add(ParseAuditEventParticipant(child, path+'/participant')){y.2}
      else if (child.localName = 'source') then
        element.source := ParseAuditEventSource(child, path+'/source') {b}
      else if (child.localName = 'object') then
        element.object_List.Add(ParseAuditEventObject(child, path+'/object')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeAuditEvent(xml : TXmlBuilder; name : String; elem : TFhirAuditEvent);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeAuditEventChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeAuditEventChildren(xml : TXmlBuilder; elem : TFhirAuditEvent);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  ComposeAuditEventEvent(xml, 'event', elem.event);{x.2a}
  for i := 0 to elem.participantList.Count - 1 do
      ComposeAuditEventParticipant(xml, 'participant', elem.participantList[i]);
  ComposeAuditEventSource(xml, 'source', elem.source);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('object_') then
    for i := 0 to elem.object_List.Count - 1 do
      ComposeAuditEventObject(xml, 'object', elem.object_List[i]);
end;

{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
function TFHIRXmlParser.ParseBasic(element : TMXmlElement; path : string) : TFhirBasic;
var
  child : TMXmlElement;
begin
  result := TFhirBasic.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseBasicChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseBasicChild(element : TFhirBasic; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{TFhirReference}(child, path+'/subject') {b}
      else if (child.localName = 'author') then
        element.author := ParseReference{Resource}(child, path+'/author') {b}
      else if (child.localName = 'created') then
        element.createdElement := ParseDate(child, path+'/created') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeBasic(xml : TXmlBuilder; name : String; elem : TFhirBasic);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeBasicChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeBasicChildren(xml : TXmlBuilder; elem : TFhirBasic);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirReference}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{Resource}(xml, 'author', elem.author);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDate(xml, 'created', elem.createdElement);{x.2b}
end;

{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
function TFHIRXmlParser.ParseBinary(element : TMXmlElement; path : string) : TFhirBinary;
var
  child : TMXmlElement;
begin
  result := TFhirBinary.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseBinaryChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseBinaryChild(element : TFhirBinary; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'contentType') then
        element.contentTypeElement := ParseCode(child, path+'/contentType') {b}
      else if (child.localName = 'content') then
        element.contentElement := ParseBase64Binary(child, path+'/content') {b}
      else if Not ParseResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeBinary(xml : TXmlBuilder; name : String; elem : TFhirBinary);
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeBinaryChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeBinaryChildren(xml : TXmlBuilder; elem : TFhirBinary);
begin
  composeResourceChildren(xml, elem);
  ComposeCode(xml, 'contentType', elem.contentTypeElement);{x.2b}
  ComposeBase64Binary(xml, 'content', elem.contentElement);{x.2b}
end;

{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BODYSITE}
function TFHIRXmlParser.ParseBodySite(element : TMXmlElement; path : string) : TFhirBodySite;
var
  child : TMXmlElement;
begin
  result := TFhirBodySite.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseBodySiteChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseBodySiteChild(element : TFhirBodySite; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'modifier') then
        element.modifierList.Add(ParseCodeableConcept(child, path+'/modifier')){y.2}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'image') then
        element.imageList.Add(ParseAttachment(child, path+'/image')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeBodySite(xml : TXmlBuilder; name : String; elem : TFhirBodySite);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeBodySiteChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeBodySiteChildren(xml : TXmlBuilder; elem : TFhirBodySite);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('modifier') then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'modifier', elem.modifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('image') then
    for i := 0 to elem.imageList.Count - 1 do
      ComposeAttachment(xml, 'image', elem.imageList[i]);
end;

{$ENDIF FHIR_BODYSITE}
{$IFDEF FHIR_BUNDLE}
function TFHIRXmlParser.ParseBundleLink(element : TMXmlElement; path : string) : TFhirBundleLink;
var
  child : TMXmlElement;
begin
  result := TFhirBundleLink.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseBundleLinkChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseBundleLinkChild(element : TFhirBundleLink; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'relation') then
        element.relationElement := ParseString(child, path+'/relation') {b}
      else if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeBundleLink(xml : TXmlBuilder; name : String; elem : TFhirBundleLink);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeBundleLinkChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeBundleLinkChildren(xml : TXmlBuilder; elem : TFhirBundleLink);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'relation', elem.relationElement);{x.2b}
  ComposeUri(xml, 'url', elem.urlElement);{x.2b}
end;

function TFHIRXmlParser.ParseBundleEntry(element : TMXmlElement; path : string) : TFhirBundleEntry;
var
  child : TMXmlElement;
begin
  result := TFhirBundleEntry.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseBundleEntryChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseBundleEntryChild(element : TFhirBundleEntry; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'link') then
        element.link_List.Add(ParseBundleLink(child, path+'/link')){y.2}
      else if (child.localName = 'fullUrl') then
        element.fullUrlElement := ParseUri(child, path+'/fullUrl') {b}
      else if (child.localName = 'resource') then
        element.resource := ParseInnerResource(child, path+'/resource') {b}
      else if (child.localName = 'search') then
        element.search := ParseBundleEntrySearch(child, path+'/search') {b}
      else if (child.localName = 'request') then
        element.request := ParseBundleEntryRequest(child, path+'/request') {b}
      else if (child.localName = 'response') then
        element.response := ParseBundleEntryResponse(child, path+'/response') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeBundleEntry(xml : TXmlBuilder; name : String; elem : TFhirBundleEntry);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeBundleEntryChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeBundleEntryChildren(xml : TXmlBuilder; elem : TFhirBundleEntry);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.link_List.Count - 1 do
      ComposeBundleLink(xml, 'link', elem.link_List[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(xml, 'fullUrl', elem.fullUrlElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInnerResource(xml, 'resource', elem, elem.resource);{x.2a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBundleEntrySearch(xml, 'search', elem.search);{x.2a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBundleEntryRequest(xml, 'request', elem.request);{x.2a}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeBundleEntryResponse(xml, 'response', elem.response);{x.2a}
end;

function TFHIRXmlParser.ParseBundleEntrySearch(element : TMXmlElement; path : string) : TFhirBundleEntrySearch;
var
  child : TMXmlElement;
begin
  result := TFhirBundleEntrySearch.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseBundleEntrySearchChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseBundleEntrySearchChild(element : TFhirBundleEntrySearch; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'mode') then
        element.modeElement := ParseEnum(CODES_TFhirSearchEntryModeEnum, SYSTEMS_TFhirSearchEntryModeEnum, path+'/mode', child){1a}
      else if (child.localName = 'score') then
        element.scoreElement := ParseDecimal(child, path+'/score') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeBundleEntrySearch(xml : TXmlBuilder; name : String; elem : TFhirBundleEntrySearch);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeBundleEntrySearchChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeBundleEntrySearchChildren(xml : TXmlBuilder; elem : TFhirBundleEntrySearch);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeEnum(xml, 'mode', elem.ModeElement, CODES_TFhirSearchEntryModeEnum);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeDecimal(xml, 'score', elem.scoreElement);{x.2b}
end;

function TFHIRXmlParser.ParseBundleEntryRequest(element : TMXmlElement; path : string) : TFhirBundleEntryRequest;
var
  child : TMXmlElement;
begin
  result := TFhirBundleEntryRequest.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseBundleEntryRequestChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseBundleEntryRequestChild(element : TFhirBundleEntryRequest; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'method') then
        element.methodElement := ParseEnum(CODES_TFhirHttpVerbEnum, SYSTEMS_TFhirHttpVerbEnum, path+'/method', child){1a}
      else if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'ifNoneMatch') then
        element.ifNoneMatchElement := ParseString(child, path+'/ifNoneMatch') {b}
      else if (child.localName = 'ifModifiedSince') then
        element.ifModifiedSinceElement := ParseInstant(child, path+'/ifModifiedSince') {b}
      else if (child.localName = 'ifMatch') then
        element.ifMatchElement := ParseString(child, path+'/ifMatch') {b}
      else if (child.localName = 'ifNoneExist') then
        element.ifNoneExistElement := ParseString(child, path+'/ifNoneExist') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeBundleEntryRequest(xml : TXmlBuilder; name : String; elem : TFhirBundleEntryRequest);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeBundleEntryRequestChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeBundleEntryRequestChildren(xml : TXmlBuilder; elem : TFhirBundleEntryRequest);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'method', elem.MethodElement, CODES_TFhirHttpVerbEnum);
  ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'ifNoneMatch', elem.ifNoneMatchElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstant(xml, 'ifModifiedSince', elem.ifModifiedSinceElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'ifMatch', elem.ifMatchElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'ifNoneExist', elem.ifNoneExistElement);{x.2b}
end;

function TFHIRXmlParser.ParseBundleEntryResponse(element : TMXmlElement; path : string) : TFhirBundleEntryResponse;
var
  child : TMXmlElement;
begin
  result := TFhirBundleEntryResponse.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseBundleEntryResponseChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseBundleEntryResponseChild(element : TFhirBundleEntryResponse; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'status') then
        element.statusElement := ParseString(child, path+'/status') {b}
      else if (child.localName = 'location') then
        element.locationElement := ParseUri(child, path+'/location') {b}
      else if (child.localName = 'etag') then
        element.etagElement := ParseString(child, path+'/etag') {b}
      else if (child.localName = 'lastModified') then
        element.lastModifiedElement := ParseInstant(child, path+'/lastModified') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeBundleEntryResponse(xml : TXmlBuilder; name : String; elem : TFhirBundleEntryResponse);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeBundleEntryResponseChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeBundleEntryResponseChildren(xml : TXmlBuilder; elem : TFhirBundleEntryResponse);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'status', elem.statusElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeUri(xml, 'location', elem.locationElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeString(xml, 'etag', elem.etagElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeInstant(xml, 'lastModified', elem.lastModifiedElement);{x.2b}
end;

function TFHIRXmlParser.ParseBundle(element : TMXmlElement; path : string) : TFhirBundle;
var
  child : TMXmlElement;
begin
  result := TFhirBundle.create;
  try
    parseResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseBundleChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseBundleChild(element : TFhirBundle; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirBundleTypeEnum, SYSTEMS_TFhirBundleTypeEnum, path+'/type', child){1a}
      else if (child.localName = 'total') then
        element.totalElement := ParseUnsignedInt(child, path+'/total') {b}
      else if (child.localName = 'link') then
        element.link_List.Add(ParseBundleLink(child, path+'/link')){y.2}
      else if (child.localName = 'entry') then
        element.entryList.Add(ParseBundleEntry(child, path+'/entry')){y.2}
      else if (child.localName = 'signature') then
        element.signature := ParseSignature(child, path+'/signature') {b}
      else if Not ParseResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeBundle(xml : TXmlBuilder; name : String; elem : TFhirBundle);
begin
  if (elem = nil) then
    exit;
  composeResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeBundleChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeBundleChildren(xml : TXmlBuilder; elem : TFhirBundle);
var
  i : integer;
begin
  composeResourceChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirBundleTypeEnum);
  if (SummaryOption in [soFull, soSummary, soText, soData, soCount]) then
    ComposeUnsignedInt(xml, 'total', elem.totalElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.link_List.Count - 1 do
      ComposeBundleLink(xml, 'link', elem.link_List[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    for i := 0 to elem.entryList.Count - 1 do
      ComposeBundleEntry(xml, 'entry', elem.entryList[i]);
  if (SummaryOption in [soFull, soSummary, soText, soData]) then
    ComposeSignature(xml, 'signature', elem.signature);{x.2a}
end;

{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAREPLAN}
function TFHIRXmlParser.ParseCarePlanRelatedPlan(element : TMXmlElement; path : string) : TFhirCarePlanRelatedPlan;
var
  child : TMXmlElement;
begin
  result := TFhirCarePlanRelatedPlan.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCarePlanRelatedPlanChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCarePlanRelatedPlanChild(element : TFhirCarePlanRelatedPlan; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.codeElement := ParseEnum(CODES_TFhirCarePlanRelationshipEnum, SYSTEMS_TFhirCarePlanRelationshipEnum, path+'/code', child){1a}
      else if (child.localName = 'plan') then
        element.plan := ParseReference{TFhirCarePlan}(child, path+'/plan') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCarePlanRelatedPlan(xml : TXmlBuilder; name : String; elem : TFhirCarePlanRelatedPlan);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCarePlanRelatedPlanChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCarePlanRelatedPlanChildren(xml : TXmlBuilder; elem : TFhirCarePlanRelatedPlan);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'code', elem.CodeElement, CODES_TFhirCarePlanRelationshipEnum);
  ComposeReference{TFhirCarePlan}(xml, 'plan', elem.plan);{x.2a}
end;

function TFHIRXmlParser.ParseCarePlanParticipant(element : TMXmlElement; path : string) : TFhirCarePlanParticipant;
var
  child : TMXmlElement;
begin
  result := TFhirCarePlanParticipant.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCarePlanParticipantChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCarePlanParticipantChild(element : TFhirCarePlanParticipant; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'role') then
        element.role := ParseCodeableConcept(child, path+'/role') {b}
      else if (child.localName = 'member') then
        element.member := ParseReference{Resource}(child, path+'/member') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCarePlanParticipant(xml : TXmlBuilder; name : String; elem : TFhirCarePlanParticipant);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCarePlanParticipantChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCarePlanParticipantChildren(xml : TXmlBuilder; elem : TFhirCarePlanParticipant);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'role', elem.role);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(xml, 'member', elem.member);{x.2a}
end;

function TFHIRXmlParser.ParseCarePlanActivity(element : TMXmlElement; path : string) : TFhirCarePlanActivity;
var
  child : TMXmlElement;
begin
  result := TFhirCarePlanActivity.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCarePlanActivityChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCarePlanActivityChild(element : TFhirCarePlanActivity; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'actionResulting') then
        element.actionResultingList.Add(ParseReference{TFhirReference}(child, path+'/actionResulting')){y.2}
      else if (child.localName = 'progress') then
        element.progressList.Add(ParseAnnotation(child, path+'/progress')){y.2}
      else if (child.localName = 'reference') then
        element.reference := ParseReference{Resource}(child, path+'/reference') {b}
      else if (child.localName = 'detail') then
        element.detail := ParseCarePlanActivityDetail(child, path+'/detail') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCarePlanActivity(xml : TXmlBuilder; name : String; elem : TFhirCarePlanActivity);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCarePlanActivityChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCarePlanActivityChildren(xml : TXmlBuilder; elem : TFhirCarePlanActivity);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.actionResultingList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'actionResulting', elem.actionResultingList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.progressList.Count - 1 do
      ComposeAnnotation(xml, 'progress', elem.progressList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(xml, 'reference', elem.reference);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCarePlanActivityDetail(xml, 'detail', elem.detail);{x.2a}
end;

function TFHIRXmlParser.ParseCarePlanActivityDetail(element : TMXmlElement; path : string) : TFhirCarePlanActivityDetail;
var
  child : TMXmlElement;
begin
  result := TFhirCarePlanActivityDetail.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCarePlanActivityDetailChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCarePlanActivityDetailChild(element : TFhirCarePlanActivityDetail; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'category') then
        element.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'reasonCode') then
        element.reasonCodeList.Add(ParseCodeableConcept(child, path+'/reasonCode')){y.2}
      else if (child.localName = 'reasonReference') then
        element.reasonReferenceList.Add(ParseReference{TFhirCondition}(child, path+'/reasonReference')){y.2}
      else if (child.localName = 'goal') then
        element.goalList.Add(ParseReference{TFhirGoal}(child, path+'/goal')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirCarePlanActivityStatusEnum, SYSTEMS_TFhirCarePlanActivityStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'statusReason') then
        element.statusReason := ParseCodeableConcept(child, path+'/statusReason') {b}
      else if (child.localName = 'prohibited') then
        element.prohibitedElement := ParseBoolean(child, path+'/prohibited') {b}
      else if (child.localName = 'scheduledTiming') then
        element.scheduled := ParseTiming(child, path+'/scheduledTiming'){x.3}
      else if (child.localName = 'scheduledPeriod') then
        element.scheduled := ParsePeriod(child, path+'/scheduledPeriod'){x.3}
      else if (child.localName = 'scheduledString') then
        element.scheduled := ParseString(child, path+'/scheduledString'){x.3}
      else if (child.localName = 'location') then
        element.location := ParseReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.localName = 'performer') then
        element.performerList.Add(ParseReference{Resource}(child, path+'/performer')){y.2}
      else if (child.localName = 'productCodeableConcept') then
        element.product := ParseCodeableConcept(child, path+'/productCodeableConcept'){x.3}
      else if (child.localName = 'productReference') then
        element.product := ParseReference(child, path+'/productReference') {a}
      else if (child.localName = 'dailyAmount') then
        element.dailyAmount := ParseQuantity(child, path+'/dailyAmount') {b}
      else if (child.localName = 'quantity') then
        element.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCarePlanActivityDetail(xml : TXmlBuilder; name : String; elem : TFhirCarePlanActivityDetail);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCarePlanActivityDetailChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCarePlanActivityDetailChildren(xml : TXmlBuilder; elem : TFhirCarePlanActivityDetail);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'category', elem.category);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.reasonCodeList.Count - 1 do
      ComposeCodeableConcept(xml, 'reasonCode', elem.reasonCodeList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.reasonReferenceList.Count - 1 do
      ComposeReference{TFhirCondition}(xml, 'reasonReference', elem.reasonReferenceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.goalList.Count - 1 do
      ComposeReference{TFhirGoal}(xml, 'goal', elem.goalList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirCarePlanActivityStatusEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'statusReason', elem.statusReason);{x.2a}
  ComposeBoolean(xml, 'prohibited', elem.prohibitedElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and (elem.scheduled is TFhirTiming) {6} then
    ComposeTiming(xml, 'scheduledTiming', TFhirTiming(elem.scheduled))
  else if (SummaryOption in [soFull, soData]) and (elem.scheduled is TFhirPeriod) {6} then
    ComposePeriod(xml, 'scheduledPeriod', TFhirPeriod(elem.scheduled))
  else if (SummaryOption in [soFull, soData]) and (elem.scheduled is TFhirString) {6} then
    ComposeString(xml, 'scheduledString', TFhirString(elem.scheduled));
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(xml, 'location', elem.location);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.performerList.Count - 1 do
      ComposeReference{Resource}(xml, 'performer', elem.performerList[i]);
  if (SummaryOption in [soFull, soData]) and (elem.product is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'productCodeableConcept', TFhirCodeableConcept(elem.product))
  else if (SummaryOption in [soFull, soData]) and (elem.product is TFhirReference) {2} then
    ComposeReference(xml, 'productReference', TFhirReference(elem.product));
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'dailyAmount', elem.dailyAmount);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
end;

function TFHIRXmlParser.ParseCarePlan(element : TMXmlElement; path : string) : TFhirCarePlan;
var
  child : TMXmlElement;
begin
  result := TFhirCarePlan.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCarePlanChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCarePlanChild(element : TFhirCarePlan; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirCarePlanStatusEnum, SYSTEMS_TFhirCarePlanStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'context') then
        element.context := ParseReference{Resource}(child, path+'/context') {b}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if (child.localName = 'author') then
        element.authorList.Add(ParseReference{Resource}(child, path+'/author')){y.2}
      else if (child.localName = 'modified') then
        element.modifiedElement := ParseDateTime(child, path+'/modified') {b}
      else if (child.localName = 'category') then
        element.categoryList.Add(ParseCodeableConcept(child, path+'/category')){y.2}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'addresses') then
        element.addressesList.Add(ParseReference{TFhirCondition}(child, path+'/addresses')){y.2}
      else if (child.localName = 'support') then
        element.supportList.Add(ParseReference{TFhirReference}(child, path+'/support')){y.2}
      else if (child.localName = 'relatedPlan') then
        element.relatedPlanList.Add(ParseCarePlanRelatedPlan(child, path+'/relatedPlan')){y.2}
      else if (child.localName = 'participant') then
        element.participantList.Add(ParseCarePlanParticipant(child, path+'/participant')){y.2}
      else if (child.localName = 'goal') then
        element.goalList.Add(ParseReference{TFhirGoal}(child, path+'/goal')){y.2}
      else if (child.localName = 'activity') then
        element.activityList.Add(ParseCarePlanActivity(child, path+'/activity')){y.2}
      else if (child.localName = 'note') then
        element.note := ParseAnnotation(child, path+'/note') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCarePlan(xml : TXmlBuilder; name : String; elem : TFhirCarePlan);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCarePlanChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCarePlanChildren(xml : TXmlBuilder; elem : TFhirCarePlan);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirCarePlanStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeReference{Resource}(xml, 'context', elem.context);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{Resource}(xml, 'author', elem.authorList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('modified') then
    ComposeDateTime(xml, 'modified', elem.modifiedElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', elem.categoryList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('addresses') then
    for i := 0 to elem.addressesList.Count - 1 do
      ComposeReference{TFhirCondition}(xml, 'addresses', elem.addressesList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('support') then
    for i := 0 to elem.supportList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'support', elem.supportList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('relatedPlan') then
    for i := 0 to elem.relatedPlanList.Count - 1 do
      ComposeCarePlanRelatedPlan(xml, 'relatedPlan', elem.relatedPlanList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('participant') then
    for i := 0 to elem.participantList.Count - 1 do
      ComposeCarePlanParticipant(xml, 'participant', elem.participantList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('goal') then
    for i := 0 to elem.goalList.Count - 1 do
      ComposeReference{TFhirGoal}(xml, 'goal', elem.goalList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('activity') then
    for i := 0 to elem.activityList.Count - 1 do
      ComposeCarePlanActivity(xml, 'activity', elem.activityList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    ComposeAnnotation(xml, 'note', elem.note);{x.2a}
end;

{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CLAIM}
function TFHIRXmlParser.ParseClaimPayee(element : TMXmlElement; path : string) : TFhirClaimPayee;
var
  child : TMXmlElement;
begin
  result := TFhirClaimPayee.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimPayeeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimPayeeChild(element : TFhirClaimPayee; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.localName = 'provider') then
        element.provider := ParseReference{TFhirPractitioner}(child, path+'/provider') {b}
      else if (child.localName = 'organization') then
        element.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.localName = 'person') then
        element.person := ParseReference{TFhirPatient}(child, path+'/person') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimPayee(xml : TXmlBuilder; name : String; elem : TFhirClaimPayee);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimPayeeChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimPayeeChildren(xml : TXmlBuilder; elem : TFhirClaimPayee);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(xml, 'provider', elem.provider);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(xml, 'person', elem.person);{x.2a}
end;

function TFHIRXmlParser.ParseClaimDiagnosis(element : TMXmlElement; path : string) : TFhirClaimDiagnosis;
var
  child : TMXmlElement;
begin
  result := TFhirClaimDiagnosis.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimDiagnosisChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimDiagnosisChild(element : TFhirClaimDiagnosis; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequence') then
        element.sequenceElement := ParsePositiveInt(child, path+'/sequence') {b}
      else if (child.localName = 'diagnosis') then
        element.diagnosis := ParseCoding(child, path+'/diagnosis') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimDiagnosis(xml : TXmlBuilder; name : String; elem : TFhirClaimDiagnosis);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimDiagnosisChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimDiagnosisChildren(xml : TXmlBuilder; elem : TFhirClaimDiagnosis);
begin
  composeBackboneElementChildren(xml, elem);
  ComposePositiveInt(xml, 'sequence', elem.sequenceElement);{x.2b}
  ComposeCoding(xml, 'diagnosis', elem.diagnosis);{x.2a}
end;

function TFHIRXmlParser.ParseClaimCoverage(element : TMXmlElement; path : string) : TFhirClaimCoverage;
var
  child : TMXmlElement;
begin
  result := TFhirClaimCoverage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimCoverageChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimCoverageChild(element : TFhirClaimCoverage; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequence') then
        element.sequenceElement := ParsePositiveInt(child, path+'/sequence') {b}
      else if (child.localName = 'focal') then
        element.focalElement := ParseBoolean(child, path+'/focal') {b}
      else if (child.localName = 'coverage') then
        element.coverage := ParseReference{TFhirCoverage}(child, path+'/coverage') {b}
      else if (child.localName = 'businessArrangement') then
        element.businessArrangementElement := ParseString(child, path+'/businessArrangement') {b}
      else if (child.localName = 'relationship') then
        element.relationship := ParseCoding(child, path+'/relationship') {b}
      else if (child.localName = 'preAuthRef') then
        element.preAuthRefList.Add(ParseString(child, path+'/preAuthRef')){y.2}
      else if (child.localName = 'claimResponse') then
        element.claimResponse := ParseReference{TFhirClaimResponse}(child, path+'/claimResponse') {b}
      else if (child.localName = 'originalRuleset') then
        element.originalRuleset := ParseCoding(child, path+'/originalRuleset') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimCoverage(xml : TXmlBuilder; name : String; elem : TFhirClaimCoverage);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimCoverageChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimCoverageChildren(xml : TXmlBuilder; elem : TFhirClaimCoverage);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposePositiveInt(xml, 'sequence', elem.sequenceElement);{x.2b}
  ComposeBoolean(xml, 'focal', elem.focalElement);{x.2b}
  ComposeReference{TFhirCoverage}(xml, 'coverage', elem.coverage);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'businessArrangement', elem.businessArrangementElement);{x.2b}
  ComposeCoding(xml, 'relationship', elem.relationship);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.preAuthRefList.Count - 1 do
      ComposeString(xml, 'preAuthRef', elem.preAuthRefList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirClaimResponse}(xml, 'claimResponse', elem.claimResponse);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'originalRuleset', elem.originalRuleset);{x.2a}
end;

function TFHIRXmlParser.ParseClaimItem(element : TMXmlElement; path : string) : TFhirClaimItem;
var
  child : TMXmlElement;
begin
  result := TFhirClaimItem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimItemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimItemChild(element : TFhirClaimItem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequence') then
        element.sequenceElement := ParsePositiveInt(child, path+'/sequence') {b}
      else if (child.localName = 'type') then
        element.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.localName = 'provider') then
        element.provider := ParseReference{TFhirPractitioner}(child, path+'/provider') {b}
      else if (child.localName = 'diagnosisLinkId') then
        element.diagnosisLinkIdList.Add(ParsePositiveInt(child, path+'/diagnosisLinkId')){y.2}
      else if (child.localName = 'service') then
        element.service := ParseCoding(child, path+'/service') {b}
      else if (child.localName = 'serviceDate') then
        element.serviceDateElement := ParseDate(child, path+'/serviceDate') {b}
      else if (child.localName = 'quantity') then
        element.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.localName = 'unitPrice') then
        element.unitPrice := ParseQuantity(child, path+'/unitPrice') {b}
      else if (child.localName = 'factor') then
        element.factorElement := ParseDecimal(child, path+'/factor') {b}
      else if (child.localName = 'points') then
        element.pointsElement := ParseDecimal(child, path+'/points') {b}
      else if (child.localName = 'net') then
        element.net := ParseQuantity(child, path+'/net') {b}
      else if (child.localName = 'udi') then
        element.udi := ParseCoding(child, path+'/udi') {b}
      else if (child.localName = 'bodySite') then
        element.bodySite := ParseCoding(child, path+'/bodySite') {b}
      else if (child.localName = 'subSite') then
        element.subSiteList.Add(ParseCoding(child, path+'/subSite')){y.2}
      else if (child.localName = 'modifier') then
        element.modifierList.Add(ParseCoding(child, path+'/modifier')){y.2}
      else if (child.localName = 'detail') then
        element.detailList.Add(ParseClaimItemDetail(child, path+'/detail')){y.2}
      else if (child.localName = 'prosthesis') then
        element.prosthesis := ParseClaimItemProsthesis(child, path+'/prosthesis') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimItem(xml : TXmlBuilder; name : String; elem : TFhirClaimItem);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimItemChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimItemChildren(xml : TXmlBuilder; elem : TFhirClaimItem);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposePositiveInt(xml, 'sequence', elem.sequenceElement);{x.2b}
  ComposeCoding(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(xml, 'provider', elem.provider);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.diagnosisLinkIdList.Count - 1 do
      ComposePositiveInt(xml, 'diagnosisLinkId', elem.diagnosisLinkIdList[i]);
  ComposeCoding(xml, 'service', elem.service);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(xml, 'serviceDate', elem.serviceDateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'unitPrice', elem.unitPrice);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'factor', elem.factorElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'points', elem.pointsElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'net', elem.net);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'udi', elem.udi);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'bodySite', elem.bodySite);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.subSiteList.Count - 1 do
      ComposeCoding(xml, 'subSite', elem.subSiteList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeCoding(xml, 'modifier', elem.modifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeClaimItemDetail(xml, 'detail', elem.detailList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeClaimItemProsthesis(xml, 'prosthesis', elem.prosthesis);{x.2a}
end;

function TFHIRXmlParser.ParseClaimItemDetail(element : TMXmlElement; path : string) : TFhirClaimItemDetail;
var
  child : TMXmlElement;
begin
  result := TFhirClaimItemDetail.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimItemDetailChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimItemDetailChild(element : TFhirClaimItemDetail; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequence') then
        element.sequenceElement := ParsePositiveInt(child, path+'/sequence') {b}
      else if (child.localName = 'type') then
        element.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.localName = 'service') then
        element.service := ParseCoding(child, path+'/service') {b}
      else if (child.localName = 'quantity') then
        element.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.localName = 'unitPrice') then
        element.unitPrice := ParseQuantity(child, path+'/unitPrice') {b}
      else if (child.localName = 'factor') then
        element.factorElement := ParseDecimal(child, path+'/factor') {b}
      else if (child.localName = 'points') then
        element.pointsElement := ParseDecimal(child, path+'/points') {b}
      else if (child.localName = 'net') then
        element.net := ParseQuantity(child, path+'/net') {b}
      else if (child.localName = 'udi') then
        element.udi := ParseCoding(child, path+'/udi') {b}
      else if (child.localName = 'subDetail') then
        element.subDetailList.Add(ParseClaimItemDetailSubDetail(child, path+'/subDetail')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimItemDetail(xml : TXmlBuilder; name : String; elem : TFhirClaimItemDetail);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimItemDetailChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimItemDetailChildren(xml : TXmlBuilder; elem : TFhirClaimItemDetail);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposePositiveInt(xml, 'sequence', elem.sequenceElement);{x.2b}
  ComposeCoding(xml, 'type', elem.type_);{x.2a}
  ComposeCoding(xml, 'service', elem.service);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'unitPrice', elem.unitPrice);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'factor', elem.factorElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'points', elem.pointsElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'net', elem.net);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'udi', elem.udi);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.subDetailList.Count - 1 do
      ComposeClaimItemDetailSubDetail(xml, 'subDetail', elem.subDetailList[i]);
end;

function TFHIRXmlParser.ParseClaimItemDetailSubDetail(element : TMXmlElement; path : string) : TFhirClaimItemDetailSubDetail;
var
  child : TMXmlElement;
begin
  result := TFhirClaimItemDetailSubDetail.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimItemDetailSubDetailChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimItemDetailSubDetailChild(element : TFhirClaimItemDetailSubDetail; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequence') then
        element.sequenceElement := ParsePositiveInt(child, path+'/sequence') {b}
      else if (child.localName = 'type') then
        element.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.localName = 'service') then
        element.service := ParseCoding(child, path+'/service') {b}
      else if (child.localName = 'quantity') then
        element.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.localName = 'unitPrice') then
        element.unitPrice := ParseQuantity(child, path+'/unitPrice') {b}
      else if (child.localName = 'factor') then
        element.factorElement := ParseDecimal(child, path+'/factor') {b}
      else if (child.localName = 'points') then
        element.pointsElement := ParseDecimal(child, path+'/points') {b}
      else if (child.localName = 'net') then
        element.net := ParseQuantity(child, path+'/net') {b}
      else if (child.localName = 'udi') then
        element.udi := ParseCoding(child, path+'/udi') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimItemDetailSubDetail(xml : TXmlBuilder; name : String; elem : TFhirClaimItemDetailSubDetail);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimItemDetailSubDetailChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimItemDetailSubDetailChildren(xml : TXmlBuilder; elem : TFhirClaimItemDetailSubDetail);
begin
  composeBackboneElementChildren(xml, elem);
  ComposePositiveInt(xml, 'sequence', elem.sequenceElement);{x.2b}
  ComposeCoding(xml, 'type', elem.type_);{x.2a}
  ComposeCoding(xml, 'service', elem.service);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'unitPrice', elem.unitPrice);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'factor', elem.factorElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'points', elem.pointsElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'net', elem.net);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'udi', elem.udi);{x.2a}
end;

function TFHIRXmlParser.ParseClaimItemProsthesis(element : TMXmlElement; path : string) : TFhirClaimItemProsthesis;
var
  child : TMXmlElement;
begin
  result := TFhirClaimItemProsthesis.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimItemProsthesisChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimItemProsthesisChild(element : TFhirClaimItemProsthesis; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'initial') then
        element.initialElement := ParseBoolean(child, path+'/initial') {b}
      else if (child.localName = 'priorDate') then
        element.priorDateElement := ParseDate(child, path+'/priorDate') {b}
      else if (child.localName = 'priorMaterial') then
        element.priorMaterial := ParseCoding(child, path+'/priorMaterial') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimItemProsthesis(xml : TXmlBuilder; name : String; elem : TFhirClaimItemProsthesis);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimItemProsthesisChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimItemProsthesisChildren(xml : TXmlBuilder; elem : TFhirClaimItemProsthesis);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'initial', elem.initialElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(xml, 'priorDate', elem.priorDateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'priorMaterial', elem.priorMaterial);{x.2a}
end;

function TFHIRXmlParser.ParseClaimMissingTeeth(element : TMXmlElement; path : string) : TFhirClaimMissingTeeth;
var
  child : TMXmlElement;
begin
  result := TFhirClaimMissingTeeth.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimMissingTeethChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimMissingTeethChild(element : TFhirClaimMissingTeeth; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'tooth') then
        element.tooth := ParseCoding(child, path+'/tooth') {b}
      else if (child.localName = 'reason') then
        element.reason := ParseCoding(child, path+'/reason') {b}
      else if (child.localName = 'extractionDate') then
        element.extractionDateElement := ParseDate(child, path+'/extractionDate') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimMissingTeeth(xml : TXmlBuilder; name : String; elem : TFhirClaimMissingTeeth);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimMissingTeethChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimMissingTeethChildren(xml : TXmlBuilder; elem : TFhirClaimMissingTeeth);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCoding(xml, 'tooth', elem.tooth);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'reason', elem.reason);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(xml, 'extractionDate', elem.extractionDateElement);{x.2b}
end;

function TFHIRXmlParser.ParseClaim(element : TMXmlElement; path : string) : TFhirClaim;
var
  child : TMXmlElement;
begin
  result := TFhirClaim.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimChild(element : TFhirClaim; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirClaimTypeLinkEnum, SYSTEMS_TFhirClaimTypeLinkEnum, path+'/type', child){1a}
      else if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'ruleset') then
        element.ruleset := ParseCoding(child, path+'/ruleset') {b}
      else if (child.localName = 'originalRuleset') then
        element.originalRuleset := ParseCoding(child, path+'/originalRuleset') {b}
      else if (child.localName = 'created') then
        element.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.localName = 'target') then
        element.target := ParseReference{TFhirOrganization}(child, path+'/target') {b}
      else if (child.localName = 'provider') then
        element.provider := ParseReference{TFhirPractitioner}(child, path+'/provider') {b}
      else if (child.localName = 'organization') then
        element.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.localName = 'use') then
        element.useElement := ParseEnum(CODES_TFhirClaimUseLinkEnum, SYSTEMS_TFhirClaimUseLinkEnum, path+'/use', child){1a}
      else if (child.localName = 'priority') then
        element.priority := ParseCoding(child, path+'/priority') {b}
      else if (child.localName = 'fundsReserve') then
        element.fundsReserve := ParseCoding(child, path+'/fundsReserve') {b}
      else if (child.localName = 'enterer') then
        element.enterer := ParseReference{TFhirPractitioner}(child, path+'/enterer') {b}
      else if (child.localName = 'facility') then
        element.facility := ParseReference{TFhirLocation}(child, path+'/facility') {b}
      else if (child.localName = 'prescription') then
        element.prescription := ParseReference{Resource}(child, path+'/prescription') {b}
      else if (child.localName = 'originalPrescription') then
        element.originalPrescription := ParseReference{TFhirMedicationOrder}(child, path+'/originalPrescription') {b}
      else if (child.localName = 'payee') then
        element.payee := ParseClaimPayee(child, path+'/payee') {b}
      else if (child.localName = 'referral') then
        element.referral := ParseReference{TFhirReferralRequest}(child, path+'/referral') {b}
      else if (child.localName = 'diagnosis') then
        element.diagnosisList.Add(ParseClaimDiagnosis(child, path+'/diagnosis')){y.2}
      else if (child.localName = 'condition') then
        element.conditionList.Add(ParseCoding(child, path+'/condition')){y.2}
      else if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'coverage') then
        element.coverageList.Add(ParseClaimCoverage(child, path+'/coverage')){y.2}
      else if (child.localName = 'exception') then
        element.exceptionList.Add(ParseCoding(child, path+'/exception')){y.2}
      else if (child.localName = 'school') then
        element.schoolElement := ParseString(child, path+'/school') {b}
      else if (child.localName = 'accident') then
        element.accidentElement := ParseDate(child, path+'/accident') {b}
      else if (child.localName = 'accidentType') then
        element.accidentType := ParseCoding(child, path+'/accidentType') {b}
      else if (child.localName = 'interventionException') then
        element.interventionExceptionList.Add(ParseCoding(child, path+'/interventionException')){y.2}
      else if (child.localName = 'item') then
        element.itemList.Add(ParseClaimItem(child, path+'/item')){y.2}
      else if (child.localName = 'additionalMaterials') then
        element.additionalMaterialsList.Add(ParseCoding(child, path+'/additionalMaterials')){y.2}
      else if (child.localName = 'missingTeeth') then
        element.missingTeethList.Add(ParseClaimMissingTeeth(child, path+'/missingTeeth')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaim(xml : TXmlBuilder; name : String; elem : TFhirClaim);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimChildren(xml : TXmlBuilder; elem : TFhirClaim);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirClaimTypeLinkEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ruleset') then
    ComposeCoding(xml, 'ruleset', elem.ruleset);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('originalRuleset') then
    ComposeCoding(xml, 'originalRuleset', elem.originalRuleset);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTime(xml, 'created', elem.createdElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('target') then
    ComposeReference{TFhirOrganization}(xml, 'target', elem.target);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('provider') then
    ComposeReference{TFhirPractitioner}(xml, 'provider', elem.provider);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('use') then
    ComposeEnum(xml, 'use', elem.UseElement, CODES_TFhirClaimUseLinkEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeCoding(xml, 'priority', elem.priority);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('fundsReserve') then
    ComposeCoding(xml, 'fundsReserve', elem.fundsReserve);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('enterer') then
    ComposeReference{TFhirPractitioner}(xml, 'enterer', elem.enterer);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('facility') then
    ComposeReference{TFhirLocation}(xml, 'facility', elem.facility);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('prescription') then
    ComposeReference{Resource}(xml, 'prescription', elem.prescription);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('originalPrescription') then
    ComposeReference{TFhirMedicationOrder}(xml, 'originalPrescription', elem.originalPrescription);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('payee') then
    ComposeClaimPayee(xml, 'payee', elem.payee);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('referral') then
    ComposeReference{TFhirReferralRequest}(xml, 'referral', elem.referral);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('diagnosis') then
    for i := 0 to elem.diagnosisList.Count - 1 do
      ComposeClaimDiagnosis(xml, 'diagnosis', elem.diagnosisList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('condition') then
    for i := 0 to elem.conditionList.Count - 1 do
      ComposeCoding(xml, 'condition', elem.conditionList[i]);
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('coverage') then
    for i := 0 to elem.coverageList.Count - 1 do
      ComposeClaimCoverage(xml, 'coverage', elem.coverageList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('exception') then
    for i := 0 to elem.exceptionList.Count - 1 do
      ComposeCoding(xml, 'exception', elem.exceptionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('school') then
    ComposeString(xml, 'school', elem.schoolElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('accident') then
    ComposeDate(xml, 'accident', elem.accidentElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('accidentType') then
    ComposeCoding(xml, 'accidentType', elem.accidentType);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('interventionException') then
    for i := 0 to elem.interventionExceptionList.Count - 1 do
      ComposeCoding(xml, 'interventionException', elem.interventionExceptionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('item') then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeClaimItem(xml, 'item', elem.itemList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('additionalMaterials') then
    for i := 0 to elem.additionalMaterialsList.Count - 1 do
      ComposeCoding(xml, 'additionalMaterials', elem.additionalMaterialsList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('missingTeeth') then
    for i := 0 to elem.missingTeethList.Count - 1 do
      ComposeClaimMissingTeeth(xml, 'missingTeeth', elem.missingTeethList[i]);
end;

{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
function TFHIRXmlParser.ParseClaimResponseItem(element : TMXmlElement; path : string) : TFhirClaimResponseItem;
var
  child : TMXmlElement;
begin
  result := TFhirClaimResponseItem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimResponseItemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimResponseItemChild(element : TFhirClaimResponseItem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequenceLinkId') then
        element.sequenceLinkIdElement := ParsePositiveInt(child, path+'/sequenceLinkId') {b}
      else if (child.localName = 'noteNumber') then
        element.noteNumberList.Add(ParsePositiveInt(child, path+'/noteNumber')){y.2}
      else if (child.localName = 'adjudication') then
        element.adjudicationList.Add(ParseClaimResponseItemAdjudication(child, path+'/adjudication')){y.2}
      else if (child.localName = 'detail') then
        element.detailList.Add(ParseClaimResponseItemDetail(child, path+'/detail')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseItem(xml : TXmlBuilder; name : String; elem : TFhirClaimResponseItem);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimResponseItemChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseItemChildren(xml : TXmlBuilder; elem : TFhirClaimResponseItem);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposePositiveInt(xml, 'sequenceLinkId', elem.sequenceLinkIdElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.noteNumberList.Count - 1 do
      ComposePositiveInt(xml, 'noteNumber', elem.noteNumberList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemAdjudication(xml, 'adjudication', elem.adjudicationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeClaimResponseItemDetail(xml, 'detail', elem.detailList[i]);
end;

function TFHIRXmlParser.ParseClaimResponseItemAdjudication(element : TMXmlElement; path : string) : TFhirClaimResponseItemAdjudication;
var
  child : TMXmlElement;
begin
  result := TFhirClaimResponseItemAdjudication.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimResponseItemAdjudicationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimResponseItemAdjudicationChild(element : TFhirClaimResponseItemAdjudication; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.code := ParseCoding(child, path+'/code') {b}
      else if (child.localName = 'amount') then
        element.amount := ParseQuantity(child, path+'/amount') {b}
      else if (child.localName = 'value') then
        element.valueElement := ParseDecimal(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseItemAdjudication(xml : TXmlBuilder; name : String; elem : TFhirClaimResponseItemAdjudication);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimResponseItemAdjudicationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseItemAdjudicationChildren(xml : TXmlBuilder; elem : TFhirClaimResponseItemAdjudication);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCoding(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'amount', elem.amount);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'value', elem.valueElement);{x.2b}
end;

function TFHIRXmlParser.ParseClaimResponseItemDetail(element : TMXmlElement; path : string) : TFhirClaimResponseItemDetail;
var
  child : TMXmlElement;
begin
  result := TFhirClaimResponseItemDetail.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimResponseItemDetailChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimResponseItemDetailChild(element : TFhirClaimResponseItemDetail; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequenceLinkId') then
        element.sequenceLinkIdElement := ParsePositiveInt(child, path+'/sequenceLinkId') {b}
      else if (child.localName = 'adjudication') then
        element.adjudicationList.Add(ParseClaimResponseItemDetailAdjudication(child, path+'/adjudication')){y.2}
      else if (child.localName = 'subDetail') then
        element.subDetailList.Add(ParseClaimResponseItemDetailSubDetail(child, path+'/subDetail')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseItemDetail(xml : TXmlBuilder; name : String; elem : TFhirClaimResponseItemDetail);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimResponseItemDetailChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseItemDetailChildren(xml : TXmlBuilder; elem : TFhirClaimResponseItemDetail);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposePositiveInt(xml, 'sequenceLinkId', elem.sequenceLinkIdElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemDetailAdjudication(xml, 'adjudication', elem.adjudicationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.subDetailList.Count - 1 do
      ComposeClaimResponseItemDetailSubDetail(xml, 'subDetail', elem.subDetailList[i]);
end;

function TFHIRXmlParser.ParseClaimResponseItemDetailAdjudication(element : TMXmlElement; path : string) : TFhirClaimResponseItemDetailAdjudication;
var
  child : TMXmlElement;
begin
  result := TFhirClaimResponseItemDetailAdjudication.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimResponseItemDetailAdjudicationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimResponseItemDetailAdjudicationChild(element : TFhirClaimResponseItemDetailAdjudication; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.code := ParseCoding(child, path+'/code') {b}
      else if (child.localName = 'amount') then
        element.amount := ParseQuantity(child, path+'/amount') {b}
      else if (child.localName = 'value') then
        element.valueElement := ParseDecimal(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseItemDetailAdjudication(xml : TXmlBuilder; name : String; elem : TFhirClaimResponseItemDetailAdjudication);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimResponseItemDetailAdjudicationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseItemDetailAdjudicationChildren(xml : TXmlBuilder; elem : TFhirClaimResponseItemDetailAdjudication);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCoding(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'amount', elem.amount);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'value', elem.valueElement);{x.2b}
end;

function TFHIRXmlParser.ParseClaimResponseItemDetailSubDetail(element : TMXmlElement; path : string) : TFhirClaimResponseItemDetailSubDetail;
var
  child : TMXmlElement;
begin
  result := TFhirClaimResponseItemDetailSubDetail.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimResponseItemDetailSubDetailChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimResponseItemDetailSubDetailChild(element : TFhirClaimResponseItemDetailSubDetail; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequenceLinkId') then
        element.sequenceLinkIdElement := ParsePositiveInt(child, path+'/sequenceLinkId') {b}
      else if (child.localName = 'adjudication') then
        element.adjudicationList.Add(ParseClaimResponseItemDetailSubDetailAdjudication(child, path+'/adjudication')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseItemDetailSubDetail(xml : TXmlBuilder; name : String; elem : TFhirClaimResponseItemDetailSubDetail);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimResponseItemDetailSubDetailChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseItemDetailSubDetailChildren(xml : TXmlBuilder; elem : TFhirClaimResponseItemDetailSubDetail);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposePositiveInt(xml, 'sequenceLinkId', elem.sequenceLinkIdElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseItemDetailSubDetailAdjudication(xml, 'adjudication', elem.adjudicationList[i]);
end;

function TFHIRXmlParser.ParseClaimResponseItemDetailSubDetailAdjudication(element : TMXmlElement; path : string) : TFhirClaimResponseItemDetailSubDetailAdjudication;
var
  child : TMXmlElement;
begin
  result := TFhirClaimResponseItemDetailSubDetailAdjudication.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimResponseItemDetailSubDetailAdjudicationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimResponseItemDetailSubDetailAdjudicationChild(element : TFhirClaimResponseItemDetailSubDetailAdjudication; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.code := ParseCoding(child, path+'/code') {b}
      else if (child.localName = 'amount') then
        element.amount := ParseQuantity(child, path+'/amount') {b}
      else if (child.localName = 'value') then
        element.valueElement := ParseDecimal(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseItemDetailSubDetailAdjudication(xml : TXmlBuilder; name : String; elem : TFhirClaimResponseItemDetailSubDetailAdjudication);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimResponseItemDetailSubDetailAdjudicationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseItemDetailSubDetailAdjudicationChildren(xml : TXmlBuilder; elem : TFhirClaimResponseItemDetailSubDetailAdjudication);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCoding(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'amount', elem.amount);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'value', elem.valueElement);{x.2b}
end;

function TFHIRXmlParser.ParseClaimResponseAddItem(element : TMXmlElement; path : string) : TFhirClaimResponseAddItem;
var
  child : TMXmlElement;
begin
  result := TFhirClaimResponseAddItem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimResponseAddItemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimResponseAddItemChild(element : TFhirClaimResponseAddItem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequenceLinkId') then
        element.sequenceLinkIdList.Add(ParsePositiveInt(child, path+'/sequenceLinkId')){y.2}
      else if (child.localName = 'service') then
        element.service := ParseCoding(child, path+'/service') {b}
      else if (child.localName = 'fee') then
        element.fee := ParseQuantity(child, path+'/fee') {b}
      else if (child.localName = 'noteNumberLinkId') then
        element.noteNumberLinkIdList.Add(ParsePositiveInt(child, path+'/noteNumberLinkId')){y.2}
      else if (child.localName = 'adjudication') then
        element.adjudicationList.Add(ParseClaimResponseAddItemAdjudication(child, path+'/adjudication')){y.2}
      else if (child.localName = 'detail') then
        element.detailList.Add(ParseClaimResponseAddItemDetail(child, path+'/detail')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseAddItem(xml : TXmlBuilder; name : String; elem : TFhirClaimResponseAddItem);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimResponseAddItemChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseAddItemChildren(xml : TXmlBuilder; elem : TFhirClaimResponseAddItem);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.sequenceLinkIdList.Count - 1 do
      ComposePositiveInt(xml, 'sequenceLinkId', elem.sequenceLinkIdList[i]);
  ComposeCoding(xml, 'service', elem.service);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'fee', elem.fee);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.noteNumberLinkIdList.Count - 1 do
      ComposePositiveInt(xml, 'noteNumberLinkId', elem.noteNumberLinkIdList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseAddItemAdjudication(xml, 'adjudication', elem.adjudicationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeClaimResponseAddItemDetail(xml, 'detail', elem.detailList[i]);
end;

function TFHIRXmlParser.ParseClaimResponseAddItemAdjudication(element : TMXmlElement; path : string) : TFhirClaimResponseAddItemAdjudication;
var
  child : TMXmlElement;
begin
  result := TFhirClaimResponseAddItemAdjudication.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimResponseAddItemAdjudicationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimResponseAddItemAdjudicationChild(element : TFhirClaimResponseAddItemAdjudication; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.code := ParseCoding(child, path+'/code') {b}
      else if (child.localName = 'amount') then
        element.amount := ParseQuantity(child, path+'/amount') {b}
      else if (child.localName = 'value') then
        element.valueElement := ParseDecimal(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseAddItemAdjudication(xml : TXmlBuilder; name : String; elem : TFhirClaimResponseAddItemAdjudication);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimResponseAddItemAdjudicationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseAddItemAdjudicationChildren(xml : TXmlBuilder; elem : TFhirClaimResponseAddItemAdjudication);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCoding(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'amount', elem.amount);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'value', elem.valueElement);{x.2b}
end;

function TFHIRXmlParser.ParseClaimResponseAddItemDetail(element : TMXmlElement; path : string) : TFhirClaimResponseAddItemDetail;
var
  child : TMXmlElement;
begin
  result := TFhirClaimResponseAddItemDetail.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimResponseAddItemDetailChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimResponseAddItemDetailChild(element : TFhirClaimResponseAddItemDetail; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'service') then
        element.service := ParseCoding(child, path+'/service') {b}
      else if (child.localName = 'fee') then
        element.fee := ParseQuantity(child, path+'/fee') {b}
      else if (child.localName = 'adjudication') then
        element.adjudicationList.Add(ParseClaimResponseAddItemDetailAdjudication(child, path+'/adjudication')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseAddItemDetail(xml : TXmlBuilder; name : String; elem : TFhirClaimResponseAddItemDetail);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimResponseAddItemDetailChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseAddItemDetailChildren(xml : TXmlBuilder; elem : TFhirClaimResponseAddItemDetail);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCoding(xml, 'service', elem.service);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'fee', elem.fee);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.adjudicationList.Count - 1 do
      ComposeClaimResponseAddItemDetailAdjudication(xml, 'adjudication', elem.adjudicationList[i]);
end;

function TFHIRXmlParser.ParseClaimResponseAddItemDetailAdjudication(element : TMXmlElement; path : string) : TFhirClaimResponseAddItemDetailAdjudication;
var
  child : TMXmlElement;
begin
  result := TFhirClaimResponseAddItemDetailAdjudication.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimResponseAddItemDetailAdjudicationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimResponseAddItemDetailAdjudicationChild(element : TFhirClaimResponseAddItemDetailAdjudication; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.code := ParseCoding(child, path+'/code') {b}
      else if (child.localName = 'amount') then
        element.amount := ParseQuantity(child, path+'/amount') {b}
      else if (child.localName = 'value') then
        element.valueElement := ParseDecimal(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseAddItemDetailAdjudication(xml : TXmlBuilder; name : String; elem : TFhirClaimResponseAddItemDetailAdjudication);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimResponseAddItemDetailAdjudicationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseAddItemDetailAdjudicationChildren(xml : TXmlBuilder; elem : TFhirClaimResponseAddItemDetailAdjudication);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCoding(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'amount', elem.amount);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'value', elem.valueElement);{x.2b}
end;

function TFHIRXmlParser.ParseClaimResponseError(element : TMXmlElement; path : string) : TFhirClaimResponseError;
var
  child : TMXmlElement;
begin
  result := TFhirClaimResponseError.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimResponseErrorChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimResponseErrorChild(element : TFhirClaimResponseError; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequenceLinkId') then
        element.sequenceLinkIdElement := ParsePositiveInt(child, path+'/sequenceLinkId') {b}
      else if (child.localName = 'detailSequenceLinkId') then
        element.detailSequenceLinkIdElement := ParsePositiveInt(child, path+'/detailSequenceLinkId') {b}
      else if (child.localName = 'subdetailSequenceLinkId') then
        element.subdetailSequenceLinkIdElement := ParsePositiveInt(child, path+'/subdetailSequenceLinkId') {b}
      else if (child.localName = 'code') then
        element.code := ParseCoding(child, path+'/code') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseError(xml : TXmlBuilder; name : String; elem : TFhirClaimResponseError);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimResponseErrorChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseErrorChildren(xml : TXmlBuilder; elem : TFhirClaimResponseError);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(xml, 'sequenceLinkId', elem.sequenceLinkIdElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(xml, 'detailSequenceLinkId', elem.detailSequenceLinkIdElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(xml, 'subdetailSequenceLinkId', elem.subdetailSequenceLinkIdElement);{x.2b}
  ComposeCoding(xml, 'code', elem.code);{x.2a}
end;

function TFHIRXmlParser.ParseClaimResponseNote(element : TMXmlElement; path : string) : TFhirClaimResponseNote;
var
  child : TMXmlElement;
begin
  result := TFhirClaimResponseNote.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimResponseNoteChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimResponseNoteChild(element : TFhirClaimResponseNote; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'number') then
        element.numberElement := ParsePositiveInt(child, path+'/number') {b}
      else if (child.localName = 'type') then
        element.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.localName = 'text') then
        element.textElement := ParseString(child, path+'/text') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseNote(xml : TXmlBuilder; name : String; elem : TFhirClaimResponseNote);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimResponseNoteChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseNoteChildren(xml : TXmlBuilder; elem : TFhirClaimResponseNote);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(xml, 'number', elem.numberElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2b}
end;

function TFHIRXmlParser.ParseClaimResponseCoverage(element : TMXmlElement; path : string) : TFhirClaimResponseCoverage;
var
  child : TMXmlElement;
begin
  result := TFhirClaimResponseCoverage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimResponseCoverageChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimResponseCoverageChild(element : TFhirClaimResponseCoverage; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequence') then
        element.sequenceElement := ParsePositiveInt(child, path+'/sequence') {b}
      else if (child.localName = 'focal') then
        element.focalElement := ParseBoolean(child, path+'/focal') {b}
      else if (child.localName = 'coverage') then
        element.coverage := ParseReference{TFhirCoverage}(child, path+'/coverage') {b}
      else if (child.localName = 'businessArrangement') then
        element.businessArrangementElement := ParseString(child, path+'/businessArrangement') {b}
      else if (child.localName = 'relationship') then
        element.relationship := ParseCoding(child, path+'/relationship') {b}
      else if (child.localName = 'preAuthRef') then
        element.preAuthRefList.Add(ParseString(child, path+'/preAuthRef')){y.2}
      else if (child.localName = 'claimResponse') then
        element.claimResponse := ParseReference{TFhirClaimResponse}(child, path+'/claimResponse') {b}
      else if (child.localName = 'originalRuleset') then
        element.originalRuleset := ParseCoding(child, path+'/originalRuleset') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseCoverage(xml : TXmlBuilder; name : String; elem : TFhirClaimResponseCoverage);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimResponseCoverageChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseCoverageChildren(xml : TXmlBuilder; elem : TFhirClaimResponseCoverage);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposePositiveInt(xml, 'sequence', elem.sequenceElement);{x.2b}
  ComposeBoolean(xml, 'focal', elem.focalElement);{x.2b}
  ComposeReference{TFhirCoverage}(xml, 'coverage', elem.coverage);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'businessArrangement', elem.businessArrangementElement);{x.2b}
  ComposeCoding(xml, 'relationship', elem.relationship);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.preAuthRefList.Count - 1 do
      ComposeString(xml, 'preAuthRef', elem.preAuthRefList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirClaimResponse}(xml, 'claimResponse', elem.claimResponse);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'originalRuleset', elem.originalRuleset);{x.2a}
end;

function TFHIRXmlParser.ParseClaimResponse(element : TMXmlElement; path : string) : TFhirClaimResponse;
var
  child : TMXmlElement;
begin
  result := TFhirClaimResponse.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClaimResponseChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClaimResponseChild(element : TFhirClaimResponse; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'request') then
        element.request := ParseReference{TFhirClaim}(child, path+'/request') {b}
      else if (child.localName = 'ruleset') then
        element.ruleset := ParseCoding(child, path+'/ruleset') {b}
      else if (child.localName = 'originalRuleset') then
        element.originalRuleset := ParseCoding(child, path+'/originalRuleset') {b}
      else if (child.localName = 'created') then
        element.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.localName = 'organization') then
        element.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.localName = 'requestProvider') then
        element.requestProvider := ParseReference{TFhirPractitioner}(child, path+'/requestProvider') {b}
      else if (child.localName = 'requestOrganization') then
        element.requestOrganization := ParseReference{TFhirOrganization}(child, path+'/requestOrganization') {b}
      else if (child.localName = 'outcome') then
        element.outcomeElement := ParseEnum(CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum, path+'/outcome', child){1a}
      else if (child.localName = 'disposition') then
        element.dispositionElement := ParseString(child, path+'/disposition') {b}
      else if (child.localName = 'payeeType') then
        element.payeeType := ParseCoding(child, path+'/payeeType') {b}
      else if (child.localName = 'item') then
        element.itemList.Add(ParseClaimResponseItem(child, path+'/item')){y.2}
      else if (child.localName = 'addItem') then
        element.addItemList.Add(ParseClaimResponseAddItem(child, path+'/addItem')){y.2}
      else if (child.localName = 'error') then
        element.errorList.Add(ParseClaimResponseError(child, path+'/error')){y.2}
      else if (child.localName = 'totalCost') then
        element.totalCost := ParseQuantity(child, path+'/totalCost') {b}
      else if (child.localName = 'unallocDeductable') then
        element.unallocDeductable := ParseQuantity(child, path+'/unallocDeductable') {b}
      else if (child.localName = 'totalBenefit') then
        element.totalBenefit := ParseQuantity(child, path+'/totalBenefit') {b}
      else if (child.localName = 'paymentAdjustment') then
        element.paymentAdjustment := ParseQuantity(child, path+'/paymentAdjustment') {b}
      else if (child.localName = 'paymentAdjustmentReason') then
        element.paymentAdjustmentReason := ParseCoding(child, path+'/paymentAdjustmentReason') {b}
      else if (child.localName = 'paymentDate') then
        element.paymentDateElement := ParseDate(child, path+'/paymentDate') {b}
      else if (child.localName = 'paymentAmount') then
        element.paymentAmount := ParseQuantity(child, path+'/paymentAmount') {b}
      else if (child.localName = 'paymentRef') then
        element.paymentRef := ParseIdentifier(child, path+'/paymentRef') {b}
      else if (child.localName = 'reserved') then
        element.reserved := ParseCoding(child, path+'/reserved') {b}
      else if (child.localName = 'form') then
        element.form := ParseCoding(child, path+'/form') {b}
      else if (child.localName = 'note') then
        element.noteList.Add(ParseClaimResponseNote(child, path+'/note')){y.2}
      else if (child.localName = 'coverage') then
        element.coverageList.Add(ParseClaimResponseCoverage(child, path+'/coverage')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClaimResponse(xml : TXmlBuilder; name : String; elem : TFhirClaimResponse);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClaimResponseChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClaimResponseChildren(xml : TXmlBuilder; elem : TFhirClaimResponse);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('request') then
    ComposeReference{TFhirClaim}(xml, 'request', elem.request);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ruleset') then
    ComposeCoding(xml, 'ruleset', elem.ruleset);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('originalRuleset') then
    ComposeCoding(xml, 'originalRuleset', elem.originalRuleset);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTime(xml, 'created', elem.createdElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestProvider') then
    ComposeReference{TFhirPractitioner}(xml, 'requestProvider', elem.requestProvider);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestOrganization') then
    ComposeReference{TFhirOrganization}(xml, 'requestOrganization', elem.requestOrganization);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcome') then
    ComposeEnum(xml, 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('disposition') then
    ComposeString(xml, 'disposition', elem.dispositionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('payeeType') then
    ComposeCoding(xml, 'payeeType', elem.payeeType);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('item') then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeClaimResponseItem(xml, 'item', elem.itemList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('addItem') then
    for i := 0 to elem.addItemList.Count - 1 do
      ComposeClaimResponseAddItem(xml, 'addItem', elem.addItemList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('error') then
    for i := 0 to elem.errorList.Count - 1 do
      ComposeClaimResponseError(xml, 'error', elem.errorList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('totalCost') then
    ComposeQuantity(xml, 'totalCost', elem.totalCost);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('unallocDeductable') then
    ComposeQuantity(xml, 'unallocDeductable', elem.unallocDeductable);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('totalBenefit') then
    ComposeQuantity(xml, 'totalBenefit', elem.totalBenefit);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('paymentAdjustment') then
    ComposeQuantity(xml, 'paymentAdjustment', elem.paymentAdjustment);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('paymentAdjustmentReason') then
    ComposeCoding(xml, 'paymentAdjustmentReason', elem.paymentAdjustmentReason);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('paymentDate') then
    ComposeDate(xml, 'paymentDate', elem.paymentDateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('paymentAmount') then
    ComposeQuantity(xml, 'paymentAmount', elem.paymentAmount);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('paymentRef') then
    ComposeIdentifier(xml, 'paymentRef', elem.paymentRef);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reserved') then
    ComposeCoding(xml, 'reserved', elem.reserved);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('form') then
    ComposeCoding(xml, 'form', elem.form);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeClaimResponseNote(xml, 'note', elem.noteList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('coverage') then
    for i := 0 to elem.coverageList.Count - 1 do
      ComposeClaimResponseCoverage(xml, 'coverage', elem.coverageList[i]);
end;

{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
function TFHIRXmlParser.ParseClinicalImpressionInvestigations(element : TMXmlElement; path : string) : TFhirClinicalImpressionInvestigations;
var
  child : TMXmlElement;
begin
  result := TFhirClinicalImpressionInvestigations.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClinicalImpressionInvestigationsChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClinicalImpressionInvestigationsChild(element : TFhirClinicalImpressionInvestigations; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'item') then
        element.itemList.Add(ParseReference{Resource}(child, path+'/item')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClinicalImpressionInvestigations(xml : TXmlBuilder; name : String; elem : TFhirClinicalImpressionInvestigations);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClinicalImpressionInvestigationsChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClinicalImpressionInvestigationsChildren(xml : TXmlBuilder; elem : TFhirClinicalImpressionInvestigations);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeReference{Resource}(xml, 'item', elem.itemList[i]);
end;

function TFHIRXmlParser.ParseClinicalImpressionFinding(element : TMXmlElement; path : string) : TFhirClinicalImpressionFinding;
var
  child : TMXmlElement;
begin
  result := TFhirClinicalImpressionFinding.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClinicalImpressionFindingChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClinicalImpressionFindingChild(element : TFhirClinicalImpressionFinding; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'item') then
        element.item := ParseCodeableConcept(child, path+'/item') {b}
      else if (child.localName = 'cause') then
        element.causeElement := ParseString(child, path+'/cause') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClinicalImpressionFinding(xml : TXmlBuilder; name : String; elem : TFhirClinicalImpressionFinding);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClinicalImpressionFindingChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClinicalImpressionFindingChildren(xml : TXmlBuilder; elem : TFhirClinicalImpressionFinding);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'item', elem.item);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'cause', elem.causeElement);{x.2b}
end;

function TFHIRXmlParser.ParseClinicalImpressionRuledOut(element : TMXmlElement; path : string) : TFhirClinicalImpressionRuledOut;
var
  child : TMXmlElement;
begin
  result := TFhirClinicalImpressionRuledOut.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClinicalImpressionRuledOutChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClinicalImpressionRuledOutChild(element : TFhirClinicalImpressionRuledOut; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'item') then
        element.item := ParseCodeableConcept(child, path+'/item') {b}
      else if (child.localName = 'reason') then
        element.reasonElement := ParseString(child, path+'/reason') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClinicalImpressionRuledOut(xml : TXmlBuilder; name : String; elem : TFhirClinicalImpressionRuledOut);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClinicalImpressionRuledOutChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClinicalImpressionRuledOutChildren(xml : TXmlBuilder; elem : TFhirClinicalImpressionRuledOut);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'item', elem.item);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'reason', elem.reasonElement);{x.2b}
end;

function TFHIRXmlParser.ParseClinicalImpression(element : TMXmlElement; path : string) : TFhirClinicalImpression;
var
  child : TMXmlElement;
begin
  result := TFhirClinicalImpression.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseClinicalImpressionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseClinicalImpressionChild(element : TFhirClinicalImpression; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'assessor') then
        element.assessor := ParseReference{TFhirPractitioner}(child, path+'/assessor') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirClinicalImpressionStatusEnum, SYSTEMS_TFhirClinicalImpressionStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'previous') then
        element.previous := ParseReference{TFhirClinicalImpression}(child, path+'/previous') {b}
      else if (child.localName = 'problem') then
        element.problemList.Add(ParseReference{Resource}(child, path+'/problem')){y.2}
      else if (child.localName = 'triggerCodeableConcept') then
        element.trigger := ParseCodeableConcept(child, path+'/triggerCodeableConcept'){x.3}
      else if (child.localName = 'triggerReference') then
        element.trigger := ParseReference(child, path+'/triggerReference') {a}
      else if (child.localName = 'investigations') then
        element.investigationsList.Add(ParseClinicalImpressionInvestigations(child, path+'/investigations')){y.2}
      else if (child.localName = 'protocol') then
        element.protocolElement := ParseUri(child, path+'/protocol') {b}
      else if (child.localName = 'summary') then
        element.summaryElement := ParseString(child, path+'/summary') {b}
      else if (child.localName = 'finding') then
        element.findingList.Add(ParseClinicalImpressionFinding(child, path+'/finding')){y.2}
      else if (child.localName = 'resolved') then
        element.resolvedList.Add(ParseCodeableConcept(child, path+'/resolved')){y.2}
      else if (child.localName = 'ruledOut') then
        element.ruledOutList.Add(ParseClinicalImpressionRuledOut(child, path+'/ruledOut')){y.2}
      else if (child.localName = 'prognosis') then
        element.prognosisElement := ParseString(child, path+'/prognosis') {b}
      else if (child.localName = 'plan') then
        element.planList.Add(ParseReference{Resource}(child, path+'/plan')){y.2}
      else if (child.localName = 'action') then
        element.actionList.Add(ParseReference{Resource}(child, path+'/action')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeClinicalImpression(xml : TXmlBuilder; name : String; elem : TFhirClinicalImpression);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeClinicalImpressionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeClinicalImpressionChildren(xml : TXmlBuilder; elem : TFhirClinicalImpression);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('assessor') then
    ComposeReference{TFhirPractitioner}(xml, 'assessor', elem.assessor);{x.2a}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirClinicalImpressionStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('previous') then
    ComposeReference{TFhirClinicalImpression}(xml, 'previous', elem.previous);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('problem') then
    for i := 0 to elem.problemList.Count - 1 do
      ComposeReference{Resource}(xml, 'problem', elem.problemList[i]);
  if (SummaryOption in [soFull, soData]) and (elem.trigger is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'triggerCodeableConcept', TFhirCodeableConcept(elem.trigger))
  else if (SummaryOption in [soFull, soData]) and (elem.trigger is TFhirReference) {2} then
    ComposeReference(xml, 'triggerReference', TFhirReference(elem.trigger));
  if (SummaryOption in [soFull, soData]) and doCompose('investigations') then
    for i := 0 to elem.investigationsList.Count - 1 do
      ComposeClinicalImpressionInvestigations(xml, 'investigations', elem.investigationsList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('protocol') then
    ComposeUri(xml, 'protocol', elem.protocolElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('summary') then
    ComposeString(xml, 'summary', elem.summaryElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('finding') then
    for i := 0 to elem.findingList.Count - 1 do
      ComposeClinicalImpressionFinding(xml, 'finding', elem.findingList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('resolved') then
    for i := 0 to elem.resolvedList.Count - 1 do
      ComposeCodeableConcept(xml, 'resolved', elem.resolvedList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('ruledOut') then
    for i := 0 to elem.ruledOutList.Count - 1 do
      ComposeClinicalImpressionRuledOut(xml, 'ruledOut', elem.ruledOutList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('prognosis') then
    ComposeString(xml, 'prognosis', elem.prognosisElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('plan') then
    for i := 0 to elem.planList.Count - 1 do
      ComposeReference{Resource}(xml, 'plan', elem.planList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('action') then
    for i := 0 to elem.actionList.Count - 1 do
      ComposeReference{Resource}(xml, 'action', elem.actionList[i]);
end;

{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_COMMUNICATION}
function TFHIRXmlParser.ParseCommunicationPayload(element : TMXmlElement; path : string) : TFhirCommunicationPayload;
var
  child : TMXmlElement;
begin
  result := TFhirCommunicationPayload.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCommunicationPayloadChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCommunicationPayloadChild(element : TFhirCommunicationPayload; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'contentAttachment') then
        element.content := ParseAttachment(child, path+'/contentAttachment'){x.3}
      else if (child.localName = 'contentReference') then
        element.content := ParseReference(child, path+'/contentReference') {a}
      else if (child.localName = 'contentString') then
        element.content := ParseString(child, path+'/contentString'){x.3}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCommunicationPayload(xml : TXmlBuilder; name : String; elem : TFhirCommunicationPayload);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCommunicationPayloadChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCommunicationPayloadChildren(xml : TXmlBuilder; elem : TFhirCommunicationPayload);
begin
  composeBackboneElementChildren(xml, elem);
  if (elem.content is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'contentAttachment', TFhirAttachment(elem.content))
  else if (elem.content is TFhirReference) {2} then
    ComposeReference(xml, 'contentReference', TFhirReference(elem.content))
  else if (elem.content is TFhirString) {6} then
    ComposeString(xml, 'contentString', TFhirString(elem.content));
end;

function TFHIRXmlParser.ParseCommunication(element : TMXmlElement; path : string) : TFhirCommunication;
var
  child : TMXmlElement;
begin
  result := TFhirCommunication.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCommunicationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCommunicationChild(element : TFhirCommunication; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'category') then
        element.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.localName = 'sender') then
        element.sender := ParseReference{Resource}(child, path+'/sender') {b}
      else if (child.localName = 'recipient') then
        element.recipientList.Add(ParseReference{Resource}(child, path+'/recipient')){y.2}
      else if (child.localName = 'payload') then
        element.payloadList.Add(ParseCommunicationPayload(child, path+'/payload')){y.2}
      else if (child.localName = 'medium') then
        element.mediumList.Add(ParseCodeableConcept(child, path+'/medium')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirCommunicationStatusEnum, SYSTEMS_TFhirCommunicationStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'encounter') then
        element.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.localName = 'sent') then
        element.sentElement := ParseDateTime(child, path+'/sent') {b}
      else if (child.localName = 'received') then
        element.receivedElement := ParseDateTime(child, path+'/received') {b}
      else if (child.localName = 'reason') then
        element.reasonList.Add(ParseCodeableConcept(child, path+'/reason')){y.2}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{TFhirPatient}(child, path+'/subject') {b}
      else if (child.localName = 'requestDetail') then
        element.requestDetail := ParseReference{TFhirCommunicationRequest}(child, path+'/requestDetail') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCommunication(xml : TXmlBuilder; name : String; elem : TFhirCommunication);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCommunicationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCommunicationChildren(xml : TXmlBuilder; elem : TFhirCommunication);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeCodeableConcept(xml, 'category', elem.category);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('sender') then
    ComposeReference{Resource}(xml, 'sender', elem.sender);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recipient') then
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{Resource}(xml, 'recipient', elem.recipientList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('payload') then
    for i := 0 to elem.payloadList.Count - 1 do
      ComposeCommunicationPayload(xml, 'payload', elem.payloadList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('medium') then
    for i := 0 to elem.mediumList.Count - 1 do
      ComposeCodeableConcept(xml, 'medium', elem.mediumList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirCommunicationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('sent') then
    ComposeDateTime(xml, 'sent', elem.sentElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('received') then
    ComposeDateTime(xml, 'received', elem.receivedElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reason') then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(xml, 'reason', elem.reasonList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirPatient}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestDetail') then
    ComposeReference{TFhirCommunicationRequest}(xml, 'requestDetail', elem.requestDetail);{x.2a}
end;

{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
function TFHIRXmlParser.ParseCommunicationRequestPayload(element : TMXmlElement; path : string) : TFhirCommunicationRequestPayload;
var
  child : TMXmlElement;
begin
  result := TFhirCommunicationRequestPayload.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCommunicationRequestPayloadChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCommunicationRequestPayloadChild(element : TFhirCommunicationRequestPayload; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'contentAttachment') then
        element.content := ParseAttachment(child, path+'/contentAttachment'){x.3}
      else if (child.localName = 'contentReference') then
        element.content := ParseReference(child, path+'/contentReference') {a}
      else if (child.localName = 'contentString') then
        element.content := ParseString(child, path+'/contentString'){x.3}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCommunicationRequestPayload(xml : TXmlBuilder; name : String; elem : TFhirCommunicationRequestPayload);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCommunicationRequestPayloadChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCommunicationRequestPayloadChildren(xml : TXmlBuilder; elem : TFhirCommunicationRequestPayload);
begin
  composeBackboneElementChildren(xml, elem);
  if (elem.content is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'contentAttachment', TFhirAttachment(elem.content))
  else if (elem.content is TFhirReference) {2} then
    ComposeReference(xml, 'contentReference', TFhirReference(elem.content))
  else if (elem.content is TFhirString) {6} then
    ComposeString(xml, 'contentString', TFhirString(elem.content));
end;

function TFHIRXmlParser.ParseCommunicationRequest(element : TMXmlElement; path : string) : TFhirCommunicationRequest;
var
  child : TMXmlElement;
begin
  result := TFhirCommunicationRequest.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCommunicationRequestChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCommunicationRequestChild(element : TFhirCommunicationRequest; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'category') then
        element.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.localName = 'sender') then
        element.sender := ParseReference{Resource}(child, path+'/sender') {b}
      else if (child.localName = 'recipient') then
        element.recipientList.Add(ParseReference{Resource}(child, path+'/recipient')){y.2}
      else if (child.localName = 'payload') then
        element.payloadList.Add(ParseCommunicationRequestPayload(child, path+'/payload')){y.2}
      else if (child.localName = 'medium') then
        element.mediumList.Add(ParseCodeableConcept(child, path+'/medium')){y.2}
      else if (child.localName = 'requester') then
        element.requester := ParseReference{Resource}(child, path+'/requester') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirCommunicationRequestStatusEnum, SYSTEMS_TFhirCommunicationRequestStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'encounter') then
        element.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.localName = 'scheduledPeriod') then
        element.scheduled := ParsePeriod(child, path+'/scheduledPeriod'){x.3}
      else if (child.localName = 'scheduledDateTime') then
        element.scheduled := ParseDateTime(child, path+'/scheduledDateTime'){x.3}
      else if (child.localName = 'reason') then
        element.reasonList.Add(ParseCodeableConcept(child, path+'/reason')){y.2}
      else if (child.localName = 'requestedOn') then
        element.requestedOnElement := ParseDateTime(child, path+'/requestedOn') {b}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{TFhirPatient}(child, path+'/subject') {b}
      else if (child.localName = 'priority') then
        element.priority := ParseCodeableConcept(child, path+'/priority') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCommunicationRequest(xml : TXmlBuilder; name : String; elem : TFhirCommunicationRequest);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCommunicationRequestChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCommunicationRequestChildren(xml : TXmlBuilder; elem : TFhirCommunicationRequest);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeCodeableConcept(xml, 'category', elem.category);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('sender') then
    ComposeReference{Resource}(xml, 'sender', elem.sender);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recipient') then
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{Resource}(xml, 'recipient', elem.recipientList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('payload') then
    for i := 0 to elem.payloadList.Count - 1 do
      ComposeCommunicationRequestPayload(xml, 'payload', elem.payloadList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('medium') then
    for i := 0 to elem.mediumList.Count - 1 do
      ComposeCodeableConcept(xml, 'medium', elem.mediumList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requester') then
    ComposeReference{Resource}(xml, 'requester', elem.requester);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirCommunicationRequestStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.scheduled is TFhirPeriod) {6} then
    ComposePeriod(xml, 'scheduledPeriod', TFhirPeriod(elem.scheduled))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.scheduled is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'scheduledDateTime', TFhirDateTime(elem.scheduled));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reason') then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(xml, 'reason', elem.reasonList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestedOn') then
    ComposeDateTime(xml, 'requestedOn', elem.requestedOnElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirPatient}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeCodeableConcept(xml, 'priority', elem.priority);{x.2a}
end;

{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPOSITION}
function TFHIRXmlParser.ParseCompositionAttester(element : TMXmlElement; path : string) : TFhirCompositionAttester;
var
  child : TMXmlElement;
begin
  result := TFhirCompositionAttester.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCompositionAttesterChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCompositionAttesterChild(element : TFhirCompositionAttester; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'mode') then
        element.modeList.Add(ParseEnum(CODES_TFhirCompositionAttestationModeEnum, SYSTEMS_TFhirCompositionAttestationModeEnum, path+'/mode', child)){y.1}
      else if (child.localName = 'time') then
        element.timeElement := ParseDateTime(child, path+'/time') {b}
      else if (child.localName = 'party') then
        element.party := ParseReference{Resource}(child, path+'/party') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCompositionAttester(xml : TXmlBuilder; name : String; elem : TFhirCompositionAttester);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCompositionAttesterChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCompositionAttesterChildren(xml : TXmlBuilder; elem : TFhirCompositionAttester);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.modeList.Count - 1 do
      ComposeEnum(xml, 'mode', elem.modeList[i], CODES_TFhirCompositionAttestationModeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'time', elem.timeElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'party', elem.party);{x.2a}
end;

function TFHIRXmlParser.ParseCompositionEvent(element : TMXmlElement; path : string) : TFhirCompositionEvent;
var
  child : TMXmlElement;
begin
  result := TFhirCompositionEvent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCompositionEventChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCompositionEventChild(element : TFhirCompositionEvent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.codeList.Add(ParseCodeableConcept(child, path+'/code')){y.2}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if (child.localName = 'detail') then
        element.detailList.Add(ParseReference{TFhirReference}(child, path+'/detail')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCompositionEvent(xml : TXmlBuilder; name : String; elem : TFhirCompositionEvent);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCompositionEventChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCompositionEventChildren(xml : TXmlBuilder; elem : TFhirCompositionEvent);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCodeableConcept(xml, 'code', elem.codeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'detail', elem.detailList[i]);
end;

function TFHIRXmlParser.ParseCompositionSection(element : TMXmlElement; path : string) : TFhirCompositionSection;
var
  child : TMXmlElement;
begin
  result := TFhirCompositionSection.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCompositionSectionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCompositionSectionChild(element : TFhirCompositionSection; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'title') then
        element.titleElement := ParseString(child, path+'/title') {b}
      else if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'text') then
        element.text := ParseNarrative(child, path+'/text') {b}
      else if (child.localName = 'mode') then
        element.modeElement := ParseEnum(CODES_TFhirListModeEnum, SYSTEMS_TFhirListModeEnum, path+'/mode', child){1a}
      else if (child.localName = 'orderedBy') then
        element.orderedBy := ParseCodeableConcept(child, path+'/orderedBy') {b}
      else if (child.localName = 'entry') then
        element.entryList.Add(ParseReference{TFhirReference}(child, path+'/entry')){y.2}
      else if (child.localName = 'emptyReason') then
        element.emptyReason := ParseCodeableConcept(child, path+'/emptyReason') {b}
      else if (child.localName = 'section') then
        element.sectionList.Add(ParseCompositionSection(child, path+'/section')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCompositionSection(xml : TXmlBuilder; name : String; elem : TFhirCompositionSection);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCompositionSectionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCompositionSectionChildren(xml : TXmlBuilder; elem : TFhirCompositionSection);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'title', elem.titleElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeNarrative(xml, 'text', elem.text);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'mode', elem.ModeElement, CODES_TFhirListModeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'orderedBy', elem.orderedBy);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.entryList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'entry', elem.entryList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'emptyReason', elem.emptyReason);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.sectionList.Count - 1 do
      ComposeCompositionSection(xml, 'section', elem.sectionList[i]);
end;

function TFHIRXmlParser.ParseComposition(element : TMXmlElement; path : string) : TFhirComposition;
var
  child : TMXmlElement;
begin
  result := TFhirComposition.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCompositionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCompositionChild(element : TFhirComposition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'class') then
        element.class_ := ParseCodeableConcept(child, path+'/class') {b}
      else if (child.localName = 'title') then
        element.titleElement := ParseString(child, path+'/title') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirCompositionStatusEnum, SYSTEMS_TFhirCompositionStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'confidentiality') then
        element.confidentialityElement := ParseEnum(CODES_TFhirV3ConfidentialityEnum, SYSTEMS_TFhirV3ConfidentialityEnum, path+'/confidentiality', child){1a}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{TFhirReference}(child, path+'/subject') {b}
      else if (child.localName = 'author') then
        element.authorList.Add(ParseReference{Resource}(child, path+'/author')){y.2}
      else if (child.localName = 'attester') then
        element.attesterList.Add(ParseCompositionAttester(child, path+'/attester')){y.2}
      else if (child.localName = 'custodian') then
        element.custodian := ParseReference{TFhirOrganization}(child, path+'/custodian') {b}
      else if (child.localName = 'event') then
        element.eventList.Add(ParseCompositionEvent(child, path+'/event')){y.2}
      else if (child.localName = 'encounter') then
        element.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.localName = 'section') then
        element.sectionList.Add(ParseCompositionSection(child, path+'/section')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeComposition(xml : TXmlBuilder; name : String; elem : TFhirComposition);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCompositionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCompositionChildren(xml : TXmlBuilder; elem : TFhirComposition);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('class_') then
    ComposeCodeableConcept(xml, 'class', elem.class_);{x.2a}
  ComposeString(xml, 'title', elem.titleElement);{x.2b}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirCompositionStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('confidentiality') then
    ComposeEnum(xml, 'confidentiality', elem.ConfidentialityElement, CODES_TFhirV3ConfidentialityEnum);
  ComposeReference{TFhirReference}(xml, 'subject', elem.subject);{x.2a}
  for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{Resource}(xml, 'author', elem.authorList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('attester') then
    for i := 0 to elem.attesterList.Count - 1 do
      ComposeCompositionAttester(xml, 'attester', elem.attesterList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('custodian') then
    ComposeReference{TFhirOrganization}(xml, 'custodian', elem.custodian);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('event') then
    for i := 0 to elem.eventList.Count - 1 do
      ComposeCompositionEvent(xml, 'event', elem.eventList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('section') then
    for i := 0 to elem.sectionList.Count - 1 do
      ComposeCompositionSection(xml, 'section', elem.sectionList[i]);
end;

{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
function TFHIRXmlParser.ParseConceptMapContact(element : TMXmlElement; path : string) : TFhirConceptMapContact;
var
  child : TMXmlElement;
begin
  result := TFhirConceptMapContact.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConceptMapContactChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConceptMapContactChild(element : TFhirConceptMapContact; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'telecom') then
        element.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConceptMapContact(xml : TXmlBuilder; name : String; elem : TFhirConceptMapContact);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConceptMapContactChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConceptMapContactChildren(xml : TXmlBuilder; elem : TFhirConceptMapContact);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
end;

function TFHIRXmlParser.ParseConceptMapElement(element : TMXmlElement; path : string) : TFhirConceptMapElement;
var
  child : TMXmlElement;
begin
  result := TFhirConceptMapElement.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConceptMapElementChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConceptMapElementChild(element : TFhirConceptMapElement; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'codeSystem') then
        element.codeSystemElement := ParseUri(child, path+'/codeSystem') {b}
      else if (child.localName = 'code') then
        element.codeElement := ParseCode(child, path+'/code') {b}
      else if (child.localName = 'target') then
        element.targetList.Add(ParseConceptMapElementTarget(child, path+'/target')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConceptMapElement(xml : TXmlBuilder; name : String; elem : TFhirConceptMapElement);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConceptMapElementChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConceptMapElementChildren(xml : TXmlBuilder; elem : TFhirConceptMapElement);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'codeSystem', elem.codeSystemElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'code', elem.codeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.targetList.Count - 1 do
      ComposeConceptMapElementTarget(xml, 'target', elem.targetList[i]);
end;

function TFHIRXmlParser.ParseConceptMapElementTarget(element : TMXmlElement; path : string) : TFhirConceptMapElementTarget;
var
  child : TMXmlElement;
begin
  result := TFhirConceptMapElementTarget.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConceptMapElementTargetChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConceptMapElementTargetChild(element : TFhirConceptMapElementTarget; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'codeSystem') then
        element.codeSystemElement := ParseUri(child, path+'/codeSystem') {b}
      else if (child.localName = 'code') then
        element.codeElement := ParseCode(child, path+'/code') {b}
      else if (child.localName = 'equivalence') then
        element.equivalenceElement := ParseEnum(CODES_TFhirConceptMapEquivalenceEnum, SYSTEMS_TFhirConceptMapEquivalenceEnum, path+'/equivalence', child){1a}
      else if (child.localName = 'comments') then
        element.commentsElement := ParseString(child, path+'/comments') {b}
      else if (child.localName = 'dependsOn') then
        element.dependsOnList.Add(ParseConceptMapElementTargetDependsOn(child, path+'/dependsOn')){y.2}
      else if (child.localName = 'product') then
        element.productList.Add(ParseConceptMapElementTargetDependsOn(child, path+'/product')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConceptMapElementTarget(xml : TXmlBuilder; name : String; elem : TFhirConceptMapElementTarget);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConceptMapElementTargetChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConceptMapElementTargetChildren(xml : TXmlBuilder; elem : TFhirConceptMapElementTarget);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'codeSystem', elem.codeSystemElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'code', elem.codeElement);{x.2b}
  ComposeEnum(xml, 'equivalence', elem.EquivalenceElement, CODES_TFhirConceptMapEquivalenceEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'comments', elem.commentsElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.dependsOnList.Count - 1 do
      ComposeConceptMapElementTargetDependsOn(xml, 'dependsOn', elem.dependsOnList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.productList.Count - 1 do
      ComposeConceptMapElementTargetDependsOn(xml, 'product', elem.productList[i]);
end;

function TFHIRXmlParser.ParseConceptMapElementTargetDependsOn(element : TMXmlElement; path : string) : TFhirConceptMapElementTargetDependsOn;
var
  child : TMXmlElement;
begin
  result := TFhirConceptMapElementTargetDependsOn.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConceptMapElementTargetDependsOnChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConceptMapElementTargetDependsOnChild(element : TFhirConceptMapElementTargetDependsOn; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'element') then
        element.elementElement := ParseUri(child, path+'/element') {b}
      else if (child.localName = 'codeSystem') then
        element.codeSystemElement := ParseUri(child, path+'/codeSystem') {b}
      else if (child.localName = 'code') then
        element.codeElement := ParseString(child, path+'/code') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConceptMapElementTargetDependsOn(xml : TXmlBuilder; name : String; elem : TFhirConceptMapElementTargetDependsOn);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConceptMapElementTargetDependsOnChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConceptMapElementTargetDependsOnChildren(xml : TXmlBuilder; elem : TFhirConceptMapElementTargetDependsOn);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeUri(xml, 'element', elem.elementElement);{x.2b}
  ComposeUri(xml, 'codeSystem', elem.codeSystemElement);{x.2b}
  ComposeString(xml, 'code', elem.codeElement);{x.2b}
end;

function TFHIRXmlParser.ParseConceptMap(element : TMXmlElement; path : string) : TFhirConceptMap;
var
  child : TMXmlElement;
begin
  result := TFhirConceptMap.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConceptMapChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConceptMapChild(element : TFhirConceptMap; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'experimental') then
        element.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.localName = 'publisher') then
        element.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.localName = 'contact') then
        element.contactList.Add(ParseConceptMapContact(child, path+'/contact')){y.2}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'useContext') then
        element.useContextList.Add(ParseCodeableConcept(child, path+'/useContext')){y.2}
      else if (child.localName = 'requirements') then
        element.requirementsElement := ParseString(child, path+'/requirements') {b}
      else if (child.localName = 'copyright') then
        element.copyrightElement := ParseString(child, path+'/copyright') {b}
      else if (child.localName = 'sourceReference') then
        element.source := ParseReference(child, path+'/sourceReference') {a}
      else if (child.localName = 'sourceUri') then
        element.source := ParseUri(child, path+'/sourceUri'){x.3}
      else if (child.localName = 'targetReference') then
        element.target := ParseReference(child, path+'/targetReference') {a}
      else if (child.localName = 'targetUri') then
        element.target := ParseUri(child, path+'/targetUri'){x.3}
      else if (child.localName = 'element') then
        element.elementList.Add(ParseConceptMapElement(child, path+'/element')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConceptMap(xml : TXmlBuilder; name : String; elem : TFhirConceptMap);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConceptMapChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConceptMapChildren(xml : TXmlBuilder; elem : TFhirConceptMap);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(xml, 'version', elem.versionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeConceptMapContact(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(xml, 'useContext', elem.useContextList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('requirements') then
    ComposeString(xml, 'requirements', elem.requirementsElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeString(xml, 'copyright', elem.copyrightElement);{x.2b}
  if (elem.source is TFhirReference) {2} then
    ComposeReference(xml, 'sourceReference', TFhirReference(elem.source))
  else if (elem.source is TFhirUri) {6} then
    ComposeUri(xml, 'sourceUri', TFhirUri(elem.source));
  if (elem.target is TFhirReference) {2} then
    ComposeReference(xml, 'targetReference', TFhirReference(elem.target))
  else if (elem.target is TFhirUri) {6} then
    ComposeUri(xml, 'targetUri', TFhirUri(elem.target));
  if (SummaryOption in [soFull, soData]) and doCompose('element') then
    for i := 0 to elem.elementList.Count - 1 do
      ComposeConceptMapElement(xml, 'element', elem.elementList[i]);
end;

{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
function TFHIRXmlParser.ParseConditionStage(element : TMXmlElement; path : string) : TFhirConditionStage;
var
  child : TMXmlElement;
begin
  result := TFhirConditionStage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConditionStageChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConditionStageChild(element : TFhirConditionStage; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'summary') then
        element.summary := ParseCodeableConcept(child, path+'/summary') {b}
      else if (child.localName = 'assessment') then
        element.assessmentList.Add(ParseReference{Resource}(child, path+'/assessment')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConditionStage(xml : TXmlBuilder; name : String; elem : TFhirConditionStage);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConditionStageChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConditionStageChildren(xml : TXmlBuilder; elem : TFhirConditionStage);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'summary', elem.summary);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.assessmentList.Count - 1 do
      ComposeReference{Resource}(xml, 'assessment', elem.assessmentList[i]);
end;

function TFHIRXmlParser.ParseConditionEvidence(element : TMXmlElement; path : string) : TFhirConditionEvidence;
var
  child : TMXmlElement;
begin
  result := TFhirConditionEvidence.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConditionEvidenceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConditionEvidenceChild(element : TFhirConditionEvidence; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'detail') then
        element.detailList.Add(ParseReference{TFhirReference}(child, path+'/detail')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConditionEvidence(xml : TXmlBuilder; name : String; elem : TFhirConditionEvidence);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConditionEvidenceChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConditionEvidenceChildren(xml : TXmlBuilder; elem : TFhirConditionEvidence);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.detailList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'detail', elem.detailList[i]);
end;

function TFHIRXmlParser.ParseCondition(element : TMXmlElement; path : string) : TFhirCondition;
var
  child : TMXmlElement;
begin
  result := TFhirCondition.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConditionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConditionChild(element : TFhirCondition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'encounter') then
        element.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.localName = 'asserter') then
        element.asserter := ParseReference{Resource}(child, path+'/asserter') {b}
      else if (child.localName = 'dateRecorded') then
        element.dateRecordedElement := ParseDate(child, path+'/dateRecorded') {b}
      else if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'category') then
        element.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.localName = 'clinicalStatus') then
        element.clinicalStatusElement := ParseCode(child, path+'/clinicalStatus') {b}
      else if (child.localName = 'verificationStatus') then
        element.verificationStatusElement := ParseEnum(CODES_TFhirConditionVerStatusEnum, SYSTEMS_TFhirConditionVerStatusEnum, path+'/verificationStatus', child){1a}
      else if (child.localName = 'severity') then
        element.severity := ParseCodeableConcept(child, path+'/severity') {b}
      else if (child.localName = 'onsetQuantity') then
        element.onset := ParseQuantity(child, path+'/onsetQuantity'){x.3}
      else if (child.localName = 'onsetPeriod') then
        element.onset := ParsePeriod(child, path+'/onsetPeriod'){x.3}
      else if (child.localName = 'onsetRange') then
        element.onset := ParseRange(child, path+'/onsetRange'){x.3}
      else if (child.localName = 'onsetDateTime') then
        element.onset := ParseDateTime(child, path+'/onsetDateTime'){x.3}
      else if (child.localName = 'onsetString') then
        element.onset := ParseString(child, path+'/onsetString'){x.3}
      else if (child.localName = 'abatementQuantity') then
        element.abatement := ParseQuantity(child, path+'/abatementQuantity'){x.3}
      else if (child.localName = 'abatementPeriod') then
        element.abatement := ParsePeriod(child, path+'/abatementPeriod'){x.3}
      else if (child.localName = 'abatementRange') then
        element.abatement := ParseRange(child, path+'/abatementRange'){x.3}
      else if (child.localName = 'abatementDateTime') then
        element.abatement := ParseDateTime(child, path+'/abatementDateTime'){x.3}
      else if (child.localName = 'abatementBoolean') then
        element.abatement := ParseBoolean(child, path+'/abatementBoolean'){x.3}
      else if (child.localName = 'abatementString') then
        element.abatement := ParseString(child, path+'/abatementString'){x.3}
      else if (child.localName = 'stage') then
        element.stage := ParseConditionStage(child, path+'/stage') {b}
      else if (child.localName = 'evidence') then
        element.evidenceList.Add(ParseConditionEvidence(child, path+'/evidence')){y.2}
      else if (child.localName = 'bodySite') then
        element.bodySiteList.Add(ParseCodeableConcept(child, path+'/bodySite')){y.2}
      else if (child.localName = 'notes') then
        element.notesElement := ParseString(child, path+'/notes') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCondition(xml : TXmlBuilder; name : String; elem : TFhirCondition);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConditionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConditionChildren(xml : TXmlBuilder; elem : TFhirCondition);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('asserter') then
    ComposeReference{Resource}(xml, 'asserter', elem.asserter);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dateRecorded') then
    ComposeDate(xml, 'dateRecorded', elem.dateRecordedElement);{x.2b}
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeCodeableConcept(xml, 'category', elem.category);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('clinicalStatus') then
    ComposeCode(xml, 'clinicalStatus', elem.clinicalStatusElement);{x.2b}
  ComposeEnum(xml, 'verificationStatus', elem.VerificationStatusElement, CODES_TFhirConditionVerStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('severity') then
    ComposeCodeableConcept(xml, 'severity', elem.severity);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'onsetQuantity', TFhirQuantity(elem.onset))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirPeriod) {6} then
    ComposePeriod(xml, 'onsetPeriod', TFhirPeriod(elem.onset))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirRange) {6} then
    ComposeRange(xml, 'onsetRange', TFhirRange(elem.onset))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'onsetDateTime', TFhirDateTime(elem.onset))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.onset is TFhirString) {6} then
    ComposeString(xml, 'onsetString', TFhirString(elem.onset));
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.abatement is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'abatementQuantity', TFhirQuantity(elem.abatement))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.abatement is TFhirPeriod) {6} then
    ComposePeriod(xml, 'abatementPeriod', TFhirPeriod(elem.abatement))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.abatement is TFhirRange) {6} then
    ComposeRange(xml, 'abatementRange', TFhirRange(elem.abatement))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.abatement is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'abatementDateTime', TFhirDateTime(elem.abatement))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.abatement is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'abatementBoolean', TFhirBoolean(elem.abatement))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.abatement is TFhirString) {6} then
    ComposeString(xml, 'abatementString', TFhirString(elem.abatement));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('stage') then
    ComposeConditionStage(xml, 'stage', elem.stage);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('evidence') then
    for i := 0 to elem.evidenceList.Count - 1 do
      ComposeConditionEvidence(xml, 'evidence', elem.evidenceList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('bodySite') then
    for i := 0 to elem.bodySiteList.Count - 1 do
      ComposeCodeableConcept(xml, 'bodySite', elem.bodySiteList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('notes') then
    ComposeString(xml, 'notes', elem.notesElement);{x.2b}
end;

{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONFORMANCE}
function TFHIRXmlParser.ParseConformanceContact(element : TMXmlElement; path : string) : TFhirConformanceContact;
var
  child : TMXmlElement;
begin
  result := TFhirConformanceContact.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConformanceContactChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConformanceContactChild(element : TFhirConformanceContact; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'telecom') then
        element.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConformanceContact(xml : TXmlBuilder; name : String; elem : TFhirConformanceContact);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConformanceContactChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConformanceContactChildren(xml : TXmlBuilder; elem : TFhirConformanceContact);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
end;

function TFHIRXmlParser.ParseConformanceSoftware(element : TMXmlElement; path : string) : TFhirConformanceSoftware;
var
  child : TMXmlElement;
begin
  result := TFhirConformanceSoftware.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConformanceSoftwareChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConformanceSoftwareChild(element : TFhirConformanceSoftware; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if (child.localName = 'releaseDate') then
        element.releaseDateElement := ParseDateTime(child, path+'/releaseDate') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConformanceSoftware(xml : TXmlBuilder; name : String; elem : TFhirConformanceSoftware);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConformanceSoftwareChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConformanceSoftwareChildren(xml : TXmlBuilder; elem : TFhirConformanceSoftware);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', elem.versionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'releaseDate', elem.releaseDateElement);{x.2b}
end;

function TFHIRXmlParser.ParseConformanceImplementation(element : TMXmlElement; path : string) : TFhirConformanceImplementation;
var
  child : TMXmlElement;
begin
  result := TFhirConformanceImplementation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConformanceImplementationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConformanceImplementationChild(element : TFhirConformanceImplementation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConformanceImplementation(xml : TXmlBuilder; name : String; elem : TFhirConformanceImplementation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConformanceImplementationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConformanceImplementationChildren(xml : TXmlBuilder; elem : TFhirConformanceImplementation);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', elem.urlElement);{x.2b}
end;

function TFHIRXmlParser.ParseConformanceRest(element : TMXmlElement; path : string) : TFhirConformanceRest;
var
  child : TMXmlElement;
begin
  result := TFhirConformanceRest.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConformanceRestChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConformanceRestChild(element : TFhirConformanceRest; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'mode') then
        element.modeElement := ParseEnum(CODES_TFhirRestfulConformanceModeEnum, SYSTEMS_TFhirRestfulConformanceModeEnum, path+'/mode', child){1a}
      else if (child.localName = 'documentation') then
        element.documentationElement := ParseString(child, path+'/documentation') {b}
      else if (child.localName = 'security') then
        element.security := ParseConformanceRestSecurity(child, path+'/security') {b}
      else if (child.localName = 'resource') then
        element.resourceList.Add(ParseConformanceRestResource(child, path+'/resource')){y.2}
      else if (child.localName = 'interaction') then
        element.interactionList.Add(ParseConformanceRestInteraction(child, path+'/interaction')){y.2}
      else if (child.localName = 'transactionMode') then
        element.transactionModeElement := ParseEnum(CODES_TFhirTransactionModeEnum, SYSTEMS_TFhirTransactionModeEnum, path+'/transactionMode', child){1a}
      else if (child.localName = 'searchParam') then
        element.searchParamList.Add(ParseConformanceRestResourceSearchParam(child, path+'/searchParam')){y.2}
      else if (child.localName = 'operation') then
        element.operationList.Add(ParseConformanceRestOperation(child, path+'/operation')){y.2}
      else if (child.localName = 'compartment') then
        element.compartmentList.Add(ParseUri(child, path+'/compartment')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConformanceRest(xml : TXmlBuilder; name : String; elem : TFhirConformanceRest);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConformanceRestChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConformanceRestChildren(xml : TXmlBuilder; elem : TFhirConformanceRest);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'mode', elem.ModeElement, CODES_TFhirRestfulConformanceModeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'documentation', elem.documentationElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeConformanceRestSecurity(xml, 'security', elem.security);{x.2a}
  for i := 0 to elem.resourceList.Count - 1 do
      ComposeConformanceRestResource(xml, 'resource', elem.resourceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.interactionList.Count - 1 do
      ComposeConformanceRestInteraction(xml, 'interaction', elem.interactionList[i]);
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.transactionModeElement <> nil) and (elem.transactionModeElement.primitiveValue <> 'not-supported')) then
    ComposeEnum(xml, 'transactionMode', elem.TransactionModeElement, CODES_TFhirTransactionModeEnum);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.searchParamList.Count - 1 do
      ComposeConformanceRestResourceSearchParam(xml, 'searchParam', elem.searchParamList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.operationList.Count - 1 do
      ComposeConformanceRestOperation(xml, 'operation', elem.operationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.compartmentList.Count - 1 do
      ComposeUri(xml, 'compartment', elem.compartmentList[i]);
end;

function TFHIRXmlParser.ParseConformanceRestSecurity(element : TMXmlElement; path : string) : TFhirConformanceRestSecurity;
var
  child : TMXmlElement;
begin
  result := TFhirConformanceRestSecurity.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConformanceRestSecurityChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConformanceRestSecurityChild(element : TFhirConformanceRestSecurity; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'cors') then
        element.corsElement := ParseBoolean(child, path+'/cors') {b}
      else if (child.localName = 'service') then
        element.serviceList.Add(ParseCodeableConcept(child, path+'/service')){y.2}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'certificate') then
        element.certificateList.Add(ParseConformanceRestSecurityCertificate(child, path+'/certificate')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConformanceRestSecurity(xml : TXmlBuilder; name : String; elem : TFhirConformanceRestSecurity);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConformanceRestSecurityChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConformanceRestSecurityChildren(xml : TXmlBuilder; elem : TFhirConformanceRestSecurity);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'cors', elem.corsElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.serviceList.Count - 1 do
      ComposeCodeableConcept(xml, 'service', elem.serviceList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.certificateList.Count - 1 do
      ComposeConformanceRestSecurityCertificate(xml, 'certificate', elem.certificateList[i]);
end;

function TFHIRXmlParser.ParseConformanceRestSecurityCertificate(element : TMXmlElement; path : string) : TFhirConformanceRestSecurityCertificate;
var
  child : TMXmlElement;
begin
  result := TFhirConformanceRestSecurityCertificate.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConformanceRestSecurityCertificateChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConformanceRestSecurityCertificateChild(element : TFhirConformanceRestSecurityCertificate; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_Element := ParseCode(child, path+'/type') {b}
      else if (child.localName = 'blob') then
        element.blobElement := ParseBase64Binary(child, path+'/blob') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConformanceRestSecurityCertificate(xml : TXmlBuilder; name : String; elem : TFhirConformanceRestSecurityCertificate);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConformanceRestSecurityCertificateChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConformanceRestSecurityCertificateChildren(xml : TXmlBuilder; elem : TFhirConformanceRestSecurityCertificate);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'type', elem.type_Element);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeBase64Binary(xml, 'blob', elem.blobElement);{x.2b}
end;

function TFHIRXmlParser.ParseConformanceRestResource(element : TMXmlElement; path : string) : TFhirConformanceRestResource;
var
  child : TMXmlElement;
begin
  result := TFhirConformanceRestResource.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConformanceRestResourceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConformanceRestResourceChild(element : TFhirConformanceRestResource; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, path+'/type', child){1a}
      else if (child.localName = 'profile') then
        element.profile := ParseReference{TFhirStructureDefinition}(child, path+'/profile') {b}
      else if (child.localName = 'interaction') then
        element.interactionList.Add(ParseConformanceRestResourceInteraction(child, path+'/interaction')){y.2}
      else if (child.localName = 'versioning') then
        element.versioningElement := ParseEnum(CODES_TFhirVersioningPolicyEnum, SYSTEMS_TFhirVersioningPolicyEnum, path+'/versioning', child){1a}
      else if (child.localName = 'readHistory') then
        element.readHistoryElement := ParseBoolean(child, path+'/readHistory') {b}
      else if (child.localName = 'updateCreate') then
        element.updateCreateElement := ParseBoolean(child, path+'/updateCreate') {b}
      else if (child.localName = 'conditionalCreate') then
        element.conditionalCreateElement := ParseBoolean(child, path+'/conditionalCreate') {b}
      else if (child.localName = 'conditionalUpdate') then
        element.conditionalUpdateElement := ParseBoolean(child, path+'/conditionalUpdate') {b}
      else if (child.localName = 'conditionalDelete') then
        element.conditionalDeleteElement := ParseEnum(CODES_TFhirConditionalDeleteStatusEnum, SYSTEMS_TFhirConditionalDeleteStatusEnum, path+'/conditionalDelete', child){1a}
      else if (child.localName = 'searchInclude') then
        element.searchIncludeList.Add(ParseString(child, path+'/searchInclude')){y.2}
      else if (child.localName = 'searchRevInclude') then
        element.searchRevIncludeList.Add(ParseString(child, path+'/searchRevInclude')){y.2}
      else if (child.localName = 'searchParam') then
        element.searchParamList.Add(ParseConformanceRestResourceSearchParam(child, path+'/searchParam')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConformanceRestResource(xml : TXmlBuilder; name : String; elem : TFhirConformanceRestResource);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConformanceRestResourceChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConformanceRestResourceChildren(xml : TXmlBuilder; elem : TFhirConformanceRestResource);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirResourceTypesEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirStructureDefinition}(xml, 'profile', elem.profile);{x.2a}
  for i := 0 to elem.interactionList.Count - 1 do
      ComposeConformanceRestResourceInteraction(xml, 'interaction', elem.interactionList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'versioning', elem.VersioningElement, CODES_TFhirVersioningPolicyEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'readHistory', elem.readHistoryElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'updateCreate', elem.updateCreateElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'conditionalCreate', elem.conditionalCreateElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'conditionalUpdate', elem.conditionalUpdateElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'conditionalDelete', elem.ConditionalDeleteElement, CODES_TFhirConditionalDeleteStatusEnum);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.searchIncludeList.Count - 1 do
      ComposeString(xml, 'searchInclude', elem.searchIncludeList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.searchRevIncludeList.Count - 1 do
      ComposeString(xml, 'searchRevInclude', elem.searchRevIncludeList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.searchParamList.Count - 1 do
      ComposeConformanceRestResourceSearchParam(xml, 'searchParam', elem.searchParamList[i]);
end;

function TFHIRXmlParser.ParseConformanceRestResourceInteraction(element : TMXmlElement; path : string) : TFhirConformanceRestResourceInteraction;
var
  child : TMXmlElement;
begin
  result := TFhirConformanceRestResourceInteraction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConformanceRestResourceInteractionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConformanceRestResourceInteractionChild(element : TFhirConformanceRestResourceInteraction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.codeElement := ParseEnum(CODES_TFhirTypeRestfulInteractionEnum, SYSTEMS_TFhirTypeRestfulInteractionEnum, path+'/code', child){1a}
      else if (child.localName = 'documentation') then
        element.documentationElement := ParseString(child, path+'/documentation') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConformanceRestResourceInteraction(xml : TXmlBuilder; name : String; elem : TFhirConformanceRestResourceInteraction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConformanceRestResourceInteractionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConformanceRestResourceInteractionChildren(xml : TXmlBuilder; elem : TFhirConformanceRestResourceInteraction);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'code', elem.CodeElement, CODES_TFhirTypeRestfulInteractionEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'documentation', elem.documentationElement);{x.2b}
end;

function TFHIRXmlParser.ParseConformanceRestResourceSearchParam(element : TMXmlElement; path : string) : TFhirConformanceRestResourceSearchParam;
var
  child : TMXmlElement;
begin
  result := TFhirConformanceRestResourceSearchParam.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConformanceRestResourceSearchParamChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConformanceRestResourceSearchParamChild(element : TFhirConformanceRestResourceSearchParam; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'definition') then
        element.definitionElement := ParseUri(child, path+'/definition') {b}
      else if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirSearchParamTypeEnum, SYSTEMS_TFhirSearchParamTypeEnum, path+'/type', child){1a}
      else if (child.localName = 'documentation') then
        element.documentationElement := ParseString(child, path+'/documentation') {b}
      else if (child.localName = 'target') then
        element.target.Add(ParseEnum(CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, path+'/target', child)){y.1}
      else if (child.localName = 'modifier') then
        element.modifierList.Add(ParseEnum(CODES_TFhirSearchModifierCodeEnum, SYSTEMS_TFhirSearchModifierCodeEnum, path+'/modifier', child)){y.1}
      else if (child.localName = 'chain') then
        element.chainList.Add(ParseString(child, path+'/chain')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConformanceRestResourceSearchParam(xml : TXmlBuilder; name : String; elem : TFhirConformanceRestResourceSearchParam);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConformanceRestResourceSearchParamChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConformanceRestResourceSearchParamChildren(xml : TXmlBuilder; elem : TFhirConformanceRestResourceSearchParam);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'definition', elem.definitionElement);{x.2b}
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirSearchParamTypeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'documentation', elem.documentationElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.target.Count - 1 do
      ComposeEnum(xml, 'target', elem.target[i], CODES_TFhirResourceTypesEnum);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.modifierList.Count - 1 do
      ComposeEnum(xml, 'modifier', elem.modifierList[i], CODES_TFhirSearchModifierCodeEnum);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.chainList.Count - 1 do
      ComposeString(xml, 'chain', elem.chainList[i]);
end;

function TFHIRXmlParser.ParseConformanceRestInteraction(element : TMXmlElement; path : string) : TFhirConformanceRestInteraction;
var
  child : TMXmlElement;
begin
  result := TFhirConformanceRestInteraction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConformanceRestInteractionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConformanceRestInteractionChild(element : TFhirConformanceRestInteraction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.codeElement := ParseEnum(CODES_TFhirSystemRestfulInteractionEnum, SYSTEMS_TFhirSystemRestfulInteractionEnum, path+'/code', child){1a}
      else if (child.localName = 'documentation') then
        element.documentationElement := ParseString(child, path+'/documentation') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConformanceRestInteraction(xml : TXmlBuilder; name : String; elem : TFhirConformanceRestInteraction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConformanceRestInteractionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConformanceRestInteractionChildren(xml : TXmlBuilder; elem : TFhirConformanceRestInteraction);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'code', elem.CodeElement, CODES_TFhirSystemRestfulInteractionEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'documentation', elem.documentationElement);{x.2b}
end;

function TFHIRXmlParser.ParseConformanceRestOperation(element : TMXmlElement; path : string) : TFhirConformanceRestOperation;
var
  child : TMXmlElement;
begin
  result := TFhirConformanceRestOperation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConformanceRestOperationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConformanceRestOperationChild(element : TFhirConformanceRestOperation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'definition') then
        element.definition := ParseReference{TFhirOperationDefinition}(child, path+'/definition') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConformanceRestOperation(xml : TXmlBuilder; name : String; elem : TFhirConformanceRestOperation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConformanceRestOperationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConformanceRestOperationChildren(xml : TXmlBuilder; elem : TFhirConformanceRestOperation);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameElement);{x.2b}
  ComposeReference{TFhirOperationDefinition}(xml, 'definition', elem.definition);{x.2a}
end;

function TFHIRXmlParser.ParseConformanceMessaging(element : TMXmlElement; path : string) : TFhirConformanceMessaging;
var
  child : TMXmlElement;
begin
  result := TFhirConformanceMessaging.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConformanceMessagingChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConformanceMessagingChild(element : TFhirConformanceMessaging; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'endpoint') then
        element.endpointList.Add(ParseConformanceMessagingEndpoint(child, path+'/endpoint')){y.2}
      else if (child.localName = 'reliableCache') then
        element.reliableCacheElement := ParseUnsignedInt(child, path+'/reliableCache') {b}
      else if (child.localName = 'documentation') then
        element.documentationElement := ParseString(child, path+'/documentation') {b}
      else if (child.localName = 'event') then
        element.eventList.Add(ParseConformanceMessagingEvent(child, path+'/event')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConformanceMessaging(xml : TXmlBuilder; name : String; elem : TFhirConformanceMessaging);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConformanceMessagingChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConformanceMessagingChildren(xml : TXmlBuilder; elem : TFhirConformanceMessaging);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.endpointList.Count - 1 do
      ComposeConformanceMessagingEndpoint(xml, 'endpoint', elem.endpointList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeUnsignedInt(xml, 'reliableCache', elem.reliableCacheElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'documentation', elem.documentationElement);{x.2b}
  for i := 0 to elem.eventList.Count - 1 do
      ComposeConformanceMessagingEvent(xml, 'event', elem.eventList[i]);
end;

function TFHIRXmlParser.ParseConformanceMessagingEndpoint(element : TMXmlElement; path : string) : TFhirConformanceMessagingEndpoint;
var
  child : TMXmlElement;
begin
  result := TFhirConformanceMessagingEndpoint.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConformanceMessagingEndpointChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConformanceMessagingEndpointChild(element : TFhirConformanceMessagingEndpoint; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'protocol') then
        element.protocol := ParseCoding(child, path+'/protocol') {b}
      else if (child.localName = 'address') then
        element.addressElement := ParseUri(child, path+'/address') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConformanceMessagingEndpoint(xml : TXmlBuilder; name : String; elem : TFhirConformanceMessagingEndpoint);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConformanceMessagingEndpointChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConformanceMessagingEndpointChildren(xml : TXmlBuilder; elem : TFhirConformanceMessagingEndpoint);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCoding(xml, 'protocol', elem.protocol);{x.2a}
  ComposeUri(xml, 'address', elem.addressElement);{x.2b}
end;

function TFHIRXmlParser.ParseConformanceMessagingEvent(element : TMXmlElement; path : string) : TFhirConformanceMessagingEvent;
var
  child : TMXmlElement;
begin
  result := TFhirConformanceMessagingEvent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConformanceMessagingEventChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConformanceMessagingEventChild(element : TFhirConformanceMessagingEvent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.code := ParseCoding(child, path+'/code') {b}
      else if (child.localName = 'category') then
        element.categoryElement := ParseEnum(CODES_TFhirMessageSignificanceCategoryEnum, SYSTEMS_TFhirMessageSignificanceCategoryEnum, path+'/category', child){1a}
      else if (child.localName = 'mode') then
        element.modeElement := ParseEnum(CODES_TFhirMessageConformanceEventModeEnum, SYSTEMS_TFhirMessageConformanceEventModeEnum, path+'/mode', child){1a}
      else if (child.localName = 'focus') then
        element.focusElement := ParseEnum(CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, path+'/focus', child){1a}
      else if (child.localName = 'request') then
        element.request := ParseReference{TFhirStructureDefinition}(child, path+'/request') {b}
      else if (child.localName = 'response') then
        element.response := ParseReference{TFhirStructureDefinition}(child, path+'/response') {b}
      else if (child.localName = 'documentation') then
        element.documentationElement := ParseString(child, path+'/documentation') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConformanceMessagingEvent(xml : TXmlBuilder; name : String; elem : TFhirConformanceMessagingEvent);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConformanceMessagingEventChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConformanceMessagingEventChildren(xml : TXmlBuilder; elem : TFhirConformanceMessagingEvent);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCoding(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'category', elem.CategoryElement, CODES_TFhirMessageSignificanceCategoryEnum);
  ComposeEnum(xml, 'mode', elem.ModeElement, CODES_TFhirMessageConformanceEventModeEnum);
  ComposeEnum(xml, 'focus', elem.FocusElement, CODES_TFhirResourceTypesEnum);
  ComposeReference{TFhirStructureDefinition}(xml, 'request', elem.request);{x.2a}
  ComposeReference{TFhirStructureDefinition}(xml, 'response', elem.response);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'documentation', elem.documentationElement);{x.2b}
end;

function TFHIRXmlParser.ParseConformanceDocument(element : TMXmlElement; path : string) : TFhirConformanceDocument;
var
  child : TMXmlElement;
begin
  result := TFhirConformanceDocument.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConformanceDocumentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConformanceDocumentChild(element : TFhirConformanceDocument; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'mode') then
        element.modeElement := ParseEnum(CODES_TFhirDocumentModeEnum, SYSTEMS_TFhirDocumentModeEnum, path+'/mode', child){1a}
      else if (child.localName = 'documentation') then
        element.documentationElement := ParseString(child, path+'/documentation') {b}
      else if (child.localName = 'profile') then
        element.profile := ParseReference{TFhirStructureDefinition}(child, path+'/profile') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConformanceDocument(xml : TXmlBuilder; name : String; elem : TFhirConformanceDocument);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConformanceDocumentChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConformanceDocumentChildren(xml : TXmlBuilder; elem : TFhirConformanceDocument);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'mode', elem.ModeElement, CODES_TFhirDocumentModeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'documentation', elem.documentationElement);{x.2b}
  ComposeReference{TFhirStructureDefinition}(xml, 'profile', elem.profile);{x.2a}
end;

function TFHIRXmlParser.ParseConformance(element : TMXmlElement; path : string) : TFhirConformance;
var
  child : TMXmlElement;
begin
  result := TFhirConformance.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseConformanceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConformanceChild(element : TFhirConformance; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'experimental') then
        element.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.localName = 'publisher') then
        element.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.localName = 'contact') then
        element.contactList.Add(ParseConformanceContact(child, path+'/contact')){y.2}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'requirements') then
        element.requirementsElement := ParseString(child, path+'/requirements') {b}
      else if (child.localName = 'copyright') then
        element.copyrightElement := ParseString(child, path+'/copyright') {b}
      else if (child.localName = 'kind') then
        element.kindElement := ParseEnum(CODES_TFhirConformanceStatementKindEnum, SYSTEMS_TFhirConformanceStatementKindEnum, path+'/kind', child){1a}
      else if (child.localName = 'software') then
        element.software := ParseConformanceSoftware(child, path+'/software') {b}
      else if (child.localName = 'implementation') then
        element.implementation_ := ParseConformanceImplementation(child, path+'/implementation') {b}
      else if (child.localName = 'fhirVersion') then
        element.fhirVersionElement := ParseId(child, path+'/fhirVersion') {b}
      else if (child.localName = 'acceptUnknown') then
        element.acceptUnknownElement := ParseEnum(CODES_TFhirUnknownContentCodeEnum, SYSTEMS_TFhirUnknownContentCodeEnum, path+'/acceptUnknown', child){1a}
      else if (child.localName = 'format') then
        element.formatList.Add(ParseCode(child, path+'/format')){y.2}
      else if (child.localName = 'profile') then
        element.profileList.Add(ParseReference{TFhirStructureDefinition}(child, path+'/profile')){y.2}
      else if (child.localName = 'rest') then
        element.restList.Add(ParseConformanceRest(child, path+'/rest')){y.2}
      else if (child.localName = 'messaging') then
        element.messagingList.Add(ParseConformanceMessaging(child, path+'/messaging')){y.2}
      else if (child.localName = 'document') then
        element.documentList.Add(ParseConformanceDocument(child, path+'/document')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeConformance(xml : TXmlBuilder; name : String; elem : TFhirConformance);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeConformanceChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeConformanceChildren(xml : TXmlBuilder; elem : TFhirConformance);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(xml, 'version', elem.versionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeConformanceContact(xml, 'contact', elem.contactList[i]);
  ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('requirements') then
    ComposeString(xml, 'requirements', elem.requirementsElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeString(xml, 'copyright', elem.copyrightElement);{x.2b}
  ComposeEnum(xml, 'kind', elem.KindElement, CODES_TFhirConformanceStatementKindEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('software') then
    ComposeConformanceSoftware(xml, 'software', elem.software);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('implementation_') then
    ComposeConformanceImplementation(xml, 'implementation', elem.implementation_);{x.2a}
  ComposeId(xml, 'fhirVersion', elem.fhirVersionElement);{x.2b}
  ComposeEnum(xml, 'acceptUnknown', elem.AcceptUnknownElement, CODES_TFhirUnknownContentCodeEnum);
  for i := 0 to elem.formatList.Count - 1 do
      ComposeCode(xml, 'format', elem.formatList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('profile') then
    for i := 0 to elem.profileList.Count - 1 do
      ComposeReference{TFhirStructureDefinition}(xml, 'profile', elem.profileList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('rest') then
    for i := 0 to elem.restList.Count - 1 do
      ComposeConformanceRest(xml, 'rest', elem.restList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('messaging') then
    for i := 0 to elem.messagingList.Count - 1 do
      ComposeConformanceMessaging(xml, 'messaging', elem.messagingList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('document') then
    for i := 0 to elem.documentList.Count - 1 do
      ComposeConformanceDocument(xml, 'document', elem.documentList[i]);
end;

{$ENDIF FHIR_CONFORMANCE}
{$IFDEF FHIR_CONTRACT}
function TFHIRXmlParser.ParseContractActor(element : TMXmlElement; path : string) : TFhirContractActor;
var
  child : TMXmlElement;
begin
  result := TFhirContractActor.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseContractActorChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContractActorChild(element : TFhirContractActor; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'entity') then
        element.entity := ParseReference{Resource}(child, path+'/entity') {b}
      else if (child.localName = 'role') then
        element.roleList.Add(ParseCodeableConcept(child, path+'/role')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeContractActor(xml : TXmlBuilder; name : String; elem : TFhirContractActor);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeContractActorChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeContractActorChildren(xml : TXmlBuilder; elem : TFhirContractActor);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeReference{Resource}(xml, 'entity', elem.entity);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(xml, 'role', elem.roleList[i]);
end;

function TFHIRXmlParser.ParseContractValuedItem(element : TMXmlElement; path : string) : TFhirContractValuedItem;
var
  child : TMXmlElement;
begin
  result := TFhirContractValuedItem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseContractValuedItemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContractValuedItemChild(element : TFhirContractValuedItem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'entityCodeableConcept') then
        element.entity := ParseCodeableConcept(child, path+'/entityCodeableConcept'){x.3}
      else if (child.localName = 'entityReference') then
        element.entity := ParseReference(child, path+'/entityReference') {a}
      else if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'effectiveTime') then
        element.effectiveTimeElement := ParseDateTime(child, path+'/effectiveTime') {b}
      else if (child.localName = 'quantity') then
        element.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.localName = 'unitPrice') then
        element.unitPrice := ParseQuantity(child, path+'/unitPrice') {b}
      else if (child.localName = 'factor') then
        element.factorElement := ParseDecimal(child, path+'/factor') {b}
      else if (child.localName = 'points') then
        element.pointsElement := ParseDecimal(child, path+'/points') {b}
      else if (child.localName = 'net') then
        element.net := ParseQuantity(child, path+'/net') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeContractValuedItem(xml : TXmlBuilder; name : String; elem : TFhirContractValuedItem);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeContractValuedItemChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeContractValuedItemChildren(xml : TXmlBuilder; elem : TFhirContractValuedItem);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and (elem.entity is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'entityCodeableConcept', TFhirCodeableConcept(elem.entity))
  else if (SummaryOption in [soFull, soData]) and (elem.entity is TFhirReference) {2} then
    ComposeReference(xml, 'entityReference', TFhirReference(elem.entity));
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'effectiveTime', elem.effectiveTimeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'unitPrice', elem.unitPrice);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'factor', elem.factorElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'points', elem.pointsElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'net', elem.net);{x.2a}
end;

function TFHIRXmlParser.ParseContractSigner(element : TMXmlElement; path : string) : TFhirContractSigner;
var
  child : TMXmlElement;
begin
  result := TFhirContractSigner.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseContractSignerChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContractSignerChild(element : TFhirContractSigner; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.localName = 'party') then
        element.party := ParseReference{Resource}(child, path+'/party') {b}
      else if (child.localName = 'signature') then
        element.signatureElement := ParseString(child, path+'/signature') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeContractSigner(xml : TXmlBuilder; name : String; elem : TFhirContractSigner);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeContractSignerChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeContractSignerChildren(xml : TXmlBuilder; elem : TFhirContractSigner);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCoding(xml, 'type', elem.type_);{x.2a}
  ComposeReference{Resource}(xml, 'party', elem.party);{x.2a}
  ComposeString(xml, 'signature', elem.signatureElement);{x.2b}
end;

function TFHIRXmlParser.ParseContractTerm(element : TMXmlElement; path : string) : TFhirContractTerm;
var
  child : TMXmlElement;
begin
  result := TFhirContractTerm.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseContractTermChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContractTermChild(element : TFhirContractTerm; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'issued') then
        element.issuedElement := ParseDateTime(child, path+'/issued') {b}
      else if (child.localName = 'applies') then
        element.applies := ParsePeriod(child, path+'/applies') {b}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'subType') then
        element.subType := ParseCodeableConcept(child, path+'/subType') {b}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{TFhirReference}(child, path+'/subject') {b}
      else if (child.localName = 'action') then
        element.actionList.Add(ParseCodeableConcept(child, path+'/action')){y.2}
      else if (child.localName = 'actionReason') then
        element.actionReasonList.Add(ParseCodeableConcept(child, path+'/actionReason')){y.2}
      else if (child.localName = 'actor') then
        element.actorList.Add(ParseContractTermActor(child, path+'/actor')){y.2}
      else if (child.localName = 'text') then
        element.textElement := ParseString(child, path+'/text') {b}
      else if (child.localName = 'valuedItem') then
        element.valuedItemList.Add(ParseContractTermValuedItem(child, path+'/valuedItem')){y.2}
      else if (child.localName = 'group') then
        element.groupList.Add(ParseContractTerm(child, path+'/group')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeContractTerm(xml : TXmlBuilder; name : String; elem : TFhirContractTerm);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeContractTermChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeContractTermChildren(xml : TXmlBuilder; elem : TFhirContractTerm);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'issued', elem.issuedElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'applies', elem.applies);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'subType', elem.subType);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.actionList.Count - 1 do
      ComposeCodeableConcept(xml, 'action', elem.actionList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.actionReasonList.Count - 1 do
      ComposeCodeableConcept(xml, 'actionReason', elem.actionReasonList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.actorList.Count - 1 do
      ComposeContractTermActor(xml, 'actor', elem.actorList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.valuedItemList.Count - 1 do
      ComposeContractTermValuedItem(xml, 'valuedItem', elem.valuedItemList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.groupList.Count - 1 do
      ComposeContractTerm(xml, 'group', elem.groupList[i]);
end;

function TFHIRXmlParser.ParseContractTermActor(element : TMXmlElement; path : string) : TFhirContractTermActor;
var
  child : TMXmlElement;
begin
  result := TFhirContractTermActor.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseContractTermActorChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContractTermActorChild(element : TFhirContractTermActor; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'entity') then
        element.entity := ParseReference{Resource}(child, path+'/entity') {b}
      else if (child.localName = 'role') then
        element.roleList.Add(ParseCodeableConcept(child, path+'/role')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeContractTermActor(xml : TXmlBuilder; name : String; elem : TFhirContractTermActor);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeContractTermActorChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeContractTermActorChildren(xml : TXmlBuilder; elem : TFhirContractTermActor);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeReference{Resource}(xml, 'entity', elem.entity);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(xml, 'role', elem.roleList[i]);
end;

function TFHIRXmlParser.ParseContractTermValuedItem(element : TMXmlElement; path : string) : TFhirContractTermValuedItem;
var
  child : TMXmlElement;
begin
  result := TFhirContractTermValuedItem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseContractTermValuedItemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContractTermValuedItemChild(element : TFhirContractTermValuedItem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'entityCodeableConcept') then
        element.entity := ParseCodeableConcept(child, path+'/entityCodeableConcept'){x.3}
      else if (child.localName = 'entityReference') then
        element.entity := ParseReference(child, path+'/entityReference') {a}
      else if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'effectiveTime') then
        element.effectiveTimeElement := ParseDateTime(child, path+'/effectiveTime') {b}
      else if (child.localName = 'quantity') then
        element.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.localName = 'unitPrice') then
        element.unitPrice := ParseQuantity(child, path+'/unitPrice') {b}
      else if (child.localName = 'factor') then
        element.factorElement := ParseDecimal(child, path+'/factor') {b}
      else if (child.localName = 'points') then
        element.pointsElement := ParseDecimal(child, path+'/points') {b}
      else if (child.localName = 'net') then
        element.net := ParseQuantity(child, path+'/net') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeContractTermValuedItem(xml : TXmlBuilder; name : String; elem : TFhirContractTermValuedItem);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeContractTermValuedItemChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeContractTermValuedItemChildren(xml : TXmlBuilder; elem : TFhirContractTermValuedItem);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and (elem.entity is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'entityCodeableConcept', TFhirCodeableConcept(elem.entity))
  else if (SummaryOption in [soFull, soData]) and (elem.entity is TFhirReference) {2} then
    ComposeReference(xml, 'entityReference', TFhirReference(elem.entity));
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'effectiveTime', elem.effectiveTimeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'unitPrice', elem.unitPrice);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'factor', elem.factorElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'points', elem.pointsElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'net', elem.net);{x.2a}
end;

function TFHIRXmlParser.ParseContractFriendly(element : TMXmlElement; path : string) : TFhirContractFriendly;
var
  child : TMXmlElement;
begin
  result := TFhirContractFriendly.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseContractFriendlyChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContractFriendlyChild(element : TFhirContractFriendly; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'contentAttachment') then
        element.content := ParseAttachment(child, path+'/contentAttachment'){x.3}
      else if (child.localName = 'contentReference') then
        element.content := ParseReference(child, path+'/contentReference') {a}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeContractFriendly(xml : TXmlBuilder; name : String; elem : TFhirContractFriendly);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeContractFriendlyChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeContractFriendlyChildren(xml : TXmlBuilder; elem : TFhirContractFriendly);
begin
  composeBackboneElementChildren(xml, elem);
  if (elem.content is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'contentAttachment', TFhirAttachment(elem.content))
  else if (elem.content is TFhirReference) {2} then
    ComposeReference(xml, 'contentReference', TFhirReference(elem.content));
end;

function TFHIRXmlParser.ParseContractLegal(element : TMXmlElement; path : string) : TFhirContractLegal;
var
  child : TMXmlElement;
begin
  result := TFhirContractLegal.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseContractLegalChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContractLegalChild(element : TFhirContractLegal; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'contentAttachment') then
        element.content := ParseAttachment(child, path+'/contentAttachment'){x.3}
      else if (child.localName = 'contentReference') then
        element.content := ParseReference(child, path+'/contentReference') {a}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeContractLegal(xml : TXmlBuilder; name : String; elem : TFhirContractLegal);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeContractLegalChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeContractLegalChildren(xml : TXmlBuilder; elem : TFhirContractLegal);
begin
  composeBackboneElementChildren(xml, elem);
  if (elem.content is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'contentAttachment', TFhirAttachment(elem.content))
  else if (elem.content is TFhirReference) {2} then
    ComposeReference(xml, 'contentReference', TFhirReference(elem.content));
end;

function TFHIRXmlParser.ParseContractRule(element : TMXmlElement; path : string) : TFhirContractRule;
var
  child : TMXmlElement;
begin
  result := TFhirContractRule.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseContractRuleChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContractRuleChild(element : TFhirContractRule; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'contentAttachment') then
        element.content := ParseAttachment(child, path+'/contentAttachment'){x.3}
      else if (child.localName = 'contentReference') then
        element.content := ParseReference(child, path+'/contentReference') {a}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeContractRule(xml : TXmlBuilder; name : String; elem : TFhirContractRule);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeContractRuleChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeContractRuleChildren(xml : TXmlBuilder; elem : TFhirContractRule);
begin
  composeBackboneElementChildren(xml, elem);
  if (elem.content is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'contentAttachment', TFhirAttachment(elem.content))
  else if (elem.content is TFhirReference) {2} then
    ComposeReference(xml, 'contentReference', TFhirReference(elem.content));
end;

function TFHIRXmlParser.ParseContract(element : TMXmlElement; path : string) : TFhirContract;
var
  child : TMXmlElement;
begin
  result := TFhirContract.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseContractChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContractChild(element : TFhirContract; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'issued') then
        element.issuedElement := ParseDateTime(child, path+'/issued') {b}
      else if (child.localName = 'applies') then
        element.applies := ParsePeriod(child, path+'/applies') {b}
      else if (child.localName = 'subject') then
        element.subjectList.Add(ParseReference{TFhirReference}(child, path+'/subject')){y.2}
      else if (child.localName = 'authority') then
        element.authorityList.Add(ParseReference{TFhirOrganization}(child, path+'/authority')){y.2}
      else if (child.localName = 'domain') then
        element.domainList.Add(ParseReference{TFhirLocation}(child, path+'/domain')){y.2}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'subType') then
        element.subTypeList.Add(ParseCodeableConcept(child, path+'/subType')){y.2}
      else if (child.localName = 'action') then
        element.actionList.Add(ParseCodeableConcept(child, path+'/action')){y.2}
      else if (child.localName = 'actionReason') then
        element.actionReasonList.Add(ParseCodeableConcept(child, path+'/actionReason')){y.2}
      else if (child.localName = 'actor') then
        element.actorList.Add(ParseContractActor(child, path+'/actor')){y.2}
      else if (child.localName = 'valuedItem') then
        element.valuedItemList.Add(ParseContractValuedItem(child, path+'/valuedItem')){y.2}
      else if (child.localName = 'signer') then
        element.signerList.Add(ParseContractSigner(child, path+'/signer')){y.2}
      else if (child.localName = 'term') then
        element.termList.Add(ParseContractTerm(child, path+'/term')){y.2}
      else if (child.localName = 'bindingAttachment') then
        element.binding := ParseAttachment(child, path+'/bindingAttachment'){x.3}
      else if (child.localName = 'bindingReference') then
        element.binding := ParseReference(child, path+'/bindingReference') {a}
      else if (child.localName = 'friendly') then
        element.friendlyList.Add(ParseContractFriendly(child, path+'/friendly')){y.2}
      else if (child.localName = 'legal') then
        element.legalList.Add(ParseContractLegal(child, path+'/legal')){y.2}
      else if (child.localName = 'rule') then
        element.ruleList.Add(ParseContractRule(child, path+'/rule')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeContract(xml : TXmlBuilder; name : String; elem : TFhirContract);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeContractChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeContractChildren(xml : TXmlBuilder; elem : TFhirContract);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('issued') then
    ComposeDateTime(xml, 'issued', elem.issuedElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('applies') then
    ComposePeriod(xml, 'applies', elem.applies);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    for i := 0 to elem.subjectList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'subject', elem.subjectList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('authority') then
    for i := 0 to elem.authorityList.Count - 1 do
      ComposeReference{TFhirOrganization}(xml, 'authority', elem.authorityList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('domain') then
    for i := 0 to elem.domainList.Count - 1 do
      ComposeReference{TFhirLocation}(xml, 'domain', elem.domainList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subType') then
    for i := 0 to elem.subTypeList.Count - 1 do
      ComposeCodeableConcept(xml, 'subType', elem.subTypeList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('action') then
    for i := 0 to elem.actionList.Count - 1 do
      ComposeCodeableConcept(xml, 'action', elem.actionList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('actionReason') then
    for i := 0 to elem.actionReasonList.Count - 1 do
      ComposeCodeableConcept(xml, 'actionReason', elem.actionReasonList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('actor') then
    for i := 0 to elem.actorList.Count - 1 do
      ComposeContractActor(xml, 'actor', elem.actorList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('valuedItem') then
    for i := 0 to elem.valuedItemList.Count - 1 do
      ComposeContractValuedItem(xml, 'valuedItem', elem.valuedItemList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('signer') then
    for i := 0 to elem.signerList.Count - 1 do
      ComposeContractSigner(xml, 'signer', elem.signerList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('term') then
    for i := 0 to elem.termList.Count - 1 do
      ComposeContractTerm(xml, 'term', elem.termList[i]);
  if (SummaryOption in [soFull, soData]) and (elem.binding is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'bindingAttachment', TFhirAttachment(elem.binding))
  else if (SummaryOption in [soFull, soData]) and (elem.binding is TFhirReference) {2} then
    ComposeReference(xml, 'bindingReference', TFhirReference(elem.binding));
  if (SummaryOption in [soFull, soData]) and doCompose('friendly') then
    for i := 0 to elem.friendlyList.Count - 1 do
      ComposeContractFriendly(xml, 'friendly', elem.friendlyList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('legal') then
    for i := 0 to elem.legalList.Count - 1 do
      ComposeContractLegal(xml, 'legal', elem.legalList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('rule') then
    for i := 0 to elem.ruleList.Count - 1 do
      ComposeContractRule(xml, 'rule', elem.ruleList[i]);
end;

{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
function TFHIRXmlParser.ParseCoverage(element : TMXmlElement; path : string) : TFhirCoverage;
var
  child : TMXmlElement;
begin
  result := TFhirCoverage.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseCoverageChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCoverageChild(element : TFhirCoverage; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'issuer') then
        element.issuer := ParseReference{TFhirOrganization}(child, path+'/issuer') {b}
      else if (child.localName = 'bin') then
        element.bin := ParseIdentifier(child, path+'/bin') {b}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if (child.localName = 'type') then
        element.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.localName = 'subscriberId') then
        element.subscriberId := ParseIdentifier(child, path+'/subscriberId') {b}
      else if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'group') then
        element.groupElement := ParseString(child, path+'/group') {b}
      else if (child.localName = 'plan') then
        element.planElement := ParseString(child, path+'/plan') {b}
      else if (child.localName = 'subPlan') then
        element.subPlanElement := ParseString(child, path+'/subPlan') {b}
      else if (child.localName = 'dependent') then
        element.dependentElement := ParsePositiveInt(child, path+'/dependent') {b}
      else if (child.localName = 'sequence') then
        element.sequenceElement := ParsePositiveInt(child, path+'/sequence') {b}
      else if (child.localName = 'subscriber') then
        element.subscriber := ParseReference{TFhirPatient}(child, path+'/subscriber') {b}
      else if (child.localName = 'network') then
        element.network := ParseIdentifier(child, path+'/network') {b}
      else if (child.localName = 'contract') then
        element.contractList.Add(ParseReference{TFhirContract}(child, path+'/contract')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeCoverage(xml : TXmlBuilder; name : String; elem : TFhirCoverage);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeCoverageChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeCoverageChildren(xml : TXmlBuilder; elem : TFhirCoverage);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('issuer') then
    ComposeReference{TFhirOrganization}(xml, 'issuer', elem.issuer);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('bin') then
    ComposeIdentifier(xml, 'bin', elem.bin);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCoding(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subscriberId') then
    ComposeIdentifier(xml, 'subscriberId', elem.subscriberId);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('group') then
    ComposeString(xml, 'group', elem.groupElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('plan') then
    ComposeString(xml, 'plan', elem.planElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subPlan') then
    ComposeString(xml, 'subPlan', elem.subPlanElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dependent') then
    ComposePositiveInt(xml, 'dependent', elem.dependentElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('sequence') then
    ComposePositiveInt(xml, 'sequence', elem.sequenceElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('subscriber') then
    ComposeReference{TFhirPatient}(xml, 'subscriber', elem.subscriber);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('network') then
    ComposeIdentifier(xml, 'network', elem.network);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('contract') then
    for i := 0 to elem.contractList.Count - 1 do
      ComposeReference{TFhirContract}(xml, 'contract', elem.contractList[i]);
end;

{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_DATAELEMENT}
function TFHIRXmlParser.ParseDataElementContact(element : TMXmlElement; path : string) : TFhirDataElementContact;
var
  child : TMXmlElement;
begin
  result := TFhirDataElementContact.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDataElementContactChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDataElementContactChild(element : TFhirDataElementContact; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'telecom') then
        element.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDataElementContact(xml : TXmlBuilder; name : String; elem : TFhirDataElementContact);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDataElementContactChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDataElementContactChildren(xml : TXmlBuilder; elem : TFhirDataElementContact);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
end;

function TFHIRXmlParser.ParseDataElementMapping(element : TMXmlElement; path : string) : TFhirDataElementMapping;
var
  child : TMXmlElement;
begin
  result := TFhirDataElementMapping.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDataElementMappingChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDataElementMappingChild(element : TFhirDataElementMapping; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identity') then
        element.identityElement := ParseId(child, path+'/identity') {b}
      else if (child.localName = 'uri') then
        element.uriElement := ParseUri(child, path+'/uri') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'comments') then
        element.commentsElement := ParseString(child, path+'/comments') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDataElementMapping(xml : TXmlBuilder; name : String; elem : TFhirDataElementMapping);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDataElementMappingChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDataElementMappingChildren(xml : TXmlBuilder; elem : TFhirDataElementMapping);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeId(xml, 'identity', elem.identityElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'uri', elem.uriElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'comments', elem.commentsElement);{x.2b}
end;

function TFHIRXmlParser.ParseDataElement(element : TMXmlElement; path : string) : TFhirDataElement;
var
  child : TMXmlElement;
begin
  result := TFhirDataElement.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDataElementChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDataElementChild(element : TFhirDataElement; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'experimental') then
        element.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.localName = 'publisher') then
        element.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.localName = 'contact') then
        element.contactList.Add(ParseDataElementContact(child, path+'/contact')){y.2}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'useContext') then
        element.useContextList.Add(ParseCodeableConcept(child, path+'/useContext')){y.2}
      else if (child.localName = 'copyright') then
        element.copyrightElement := ParseString(child, path+'/copyright') {b}
      else if (child.localName = 'stringency') then
        element.stringencyElement := ParseEnum(CODES_TFhirDataelementStringencyEnum, SYSTEMS_TFhirDataelementStringencyEnum, path+'/stringency', child){1a}
      else if (child.localName = 'mapping') then
        element.mappingList.Add(ParseDataElementMapping(child, path+'/mapping')){y.2}
      else if (child.localName = 'element') then
        element.elementList.Add(ParseElementDefinition(child, path+'/element')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDataElement(xml : TXmlBuilder; name : String; elem : TFhirDataElement);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDataElementChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDataElementChildren(xml : TXmlBuilder; elem : TFhirDataElement);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(xml, 'version', elem.versionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeDataElementContact(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(xml, 'useContext', elem.useContextList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeString(xml, 'copyright', elem.copyrightElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('stringency') then
    ComposeEnum(xml, 'stringency', elem.StringencyElement, CODES_TFhirDataelementStringencyEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('mapping') then
    for i := 0 to elem.mappingList.Count - 1 do
      ComposeDataElementMapping(xml, 'mapping', elem.mappingList[i]);
  for i := 0 to elem.elementList.Count - 1 do
      ComposeElementDefinition(xml, 'element', elem.elementList[i]);
end;

{$ENDIF FHIR_DATAELEMENT}
{$IFDEF FHIR_DETECTEDISSUE}
function TFHIRXmlParser.ParseDetectedIssueMitigation(element : TMXmlElement; path : string) : TFhirDetectedIssueMitigation;
var
  child : TMXmlElement;
begin
  result := TFhirDetectedIssueMitigation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDetectedIssueMitigationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDetectedIssueMitigationChild(element : TFhirDetectedIssueMitigation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'action') then
        element.action := ParseCodeableConcept(child, path+'/action') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'author') then
        element.author := ParseReference{TFhirPractitioner}(child, path+'/author') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDetectedIssueMitigation(xml : TXmlBuilder; name : String; elem : TFhirDetectedIssueMitigation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDetectedIssueMitigationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDetectedIssueMitigationChildren(xml : TXmlBuilder; elem : TFhirDetectedIssueMitigation);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'action', elem.action);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirPractitioner}(xml, 'author', elem.author);{x.2a}
end;

function TFHIRXmlParser.ParseDetectedIssue(element : TMXmlElement; path : string) : TFhirDetectedIssue;
var
  child : TMXmlElement;
begin
  result := TFhirDetectedIssue.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDetectedIssueChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDetectedIssueChild(element : TFhirDetectedIssue; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'category') then
        element.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.localName = 'severity') then
        element.severityElement := ParseEnum(CODES_TFhirDetectedissueSeverityEnum, SYSTEMS_TFhirDetectedissueSeverityEnum, path+'/severity', child){1a}
      else if (child.localName = 'implicated') then
        element.implicatedList.Add(ParseReference{TFhirReference}(child, path+'/implicated')){y.2}
      else if (child.localName = 'detail') then
        element.detailElement := ParseString(child, path+'/detail') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'author') then
        element.author := ParseReference{Resource}(child, path+'/author') {b}
      else if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'reference') then
        element.referenceElement := ParseUri(child, path+'/reference') {b}
      else if (child.localName = 'mitigation') then
        element.mitigationList.Add(ParseDetectedIssueMitigation(child, path+'/mitigation')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDetectedIssue(xml : TXmlBuilder; name : String; elem : TFhirDetectedIssue);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDetectedIssueChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDetectedIssueChildren(xml : TXmlBuilder; elem : TFhirDetectedIssue);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeCodeableConcept(xml, 'category', elem.category);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('severity') then
    ComposeEnum(xml, 'severity', elem.SeverityElement, CODES_TFhirDetectedissueSeverityEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('implicated') then
    for i := 0 to elem.implicatedList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'implicated', elem.implicatedList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('detail') then
    ComposeString(xml, 'detail', elem.detailElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{Resource}(xml, 'author', elem.author);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('reference') then
    ComposeUri(xml, 'reference', elem.referenceElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('mitigation') then
    for i := 0 to elem.mitigationList.Count - 1 do
      ComposeDetectedIssueMitigation(xml, 'mitigation', elem.mitigationList[i]);
end;

{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
function TFHIRXmlParser.ParseDevice(element : TMXmlElement; path : string) : TFhirDevice;
var
  child : TMXmlElement;
begin
  result := TFhirDevice.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceChild(element : TFhirDevice; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'note') then
        element.noteList.Add(ParseAnnotation(child, path+'/note')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirDevicestatusEnum, SYSTEMS_TFhirDevicestatusEnum, path+'/status', child){1a}
      else if (child.localName = 'manufacturer') then
        element.manufacturerElement := ParseString(child, path+'/manufacturer') {b}
      else if (child.localName = 'model') then
        element.modelElement := ParseString(child, path+'/model') {b}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if (child.localName = 'manufactureDate') then
        element.manufactureDateElement := ParseDateTime(child, path+'/manufactureDate') {b}
      else if (child.localName = 'expiry') then
        element.expiryElement := ParseDateTime(child, path+'/expiry') {b}
      else if (child.localName = 'udi') then
        element.udiElement := ParseString(child, path+'/udi') {b}
      else if (child.localName = 'lotNumber') then
        element.lotNumberElement := ParseString(child, path+'/lotNumber') {b}
      else if (child.localName = 'owner') then
        element.owner := ParseReference{TFhirOrganization}(child, path+'/owner') {b}
      else if (child.localName = 'location') then
        element.location := ParseReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'contact') then
        element.contactList.Add(ParseContactPoint(child, path+'/contact')){y.2}
      else if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDevice(xml : TXmlBuilder; name : String; elem : TFhirDevice);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceChildren(xml : TXmlBuilder; elem : TFhirDevice);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', elem.noteList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirDevicestatusEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('manufacturer') then
    ComposeString(xml, 'manufacturer', elem.manufacturerElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('model') then
    ComposeString(xml, 'model', elem.modelElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('version') then
    ComposeString(xml, 'version', elem.versionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('manufactureDate') then
    ComposeDateTime(xml, 'manufactureDate', elem.manufactureDateElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('expiry') then
    ComposeDateTime(xml, 'expiry', elem.expiryElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('udi') then
    ComposeString(xml, 'udi', elem.udiElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('lotNumber') then
    ComposeString(xml, 'lotNumber', elem.lotNumberElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('owner') then
    ComposeReference{TFhirOrganization}(xml, 'owner', elem.owner);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('location') then
    ComposeReference{TFhirLocation}(xml, 'location', elem.location);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactPoint(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('url') then
    ComposeUri(xml, 'url', elem.urlElement);{x.2b}
end;

{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICECOMPONENT}
function TFHIRXmlParser.ParseDeviceComponentProductionSpecification(element : TMXmlElement; path : string) : TFhirDeviceComponentProductionSpecification;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceComponentProductionSpecification.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceComponentProductionSpecificationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceComponentProductionSpecificationChild(element : TFhirDeviceComponentProductionSpecification; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'specType') then
        element.specType := ParseCodeableConcept(child, path+'/specType') {b}
      else if (child.localName = 'componentId') then
        element.componentId := ParseIdentifier(child, path+'/componentId') {b}
      else if (child.localName = 'productionSpec') then
        element.productionSpecElement := ParseString(child, path+'/productionSpec') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceComponentProductionSpecification(xml : TXmlBuilder; name : String; elem : TFhirDeviceComponentProductionSpecification);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceComponentProductionSpecificationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceComponentProductionSpecificationChildren(xml : TXmlBuilder; elem : TFhirDeviceComponentProductionSpecification);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'specType', elem.specType);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'componentId', elem.componentId);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'productionSpec', elem.productionSpecElement);{x.2b}
end;

function TFHIRXmlParser.ParseDeviceComponent(element : TMXmlElement; path : string) : TFhirDeviceComponent;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceComponent.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceComponentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceComponentChild(element : TFhirDeviceComponent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'lastSystemChange') then
        element.lastSystemChangeElement := ParseInstant(child, path+'/lastSystemChange') {b}
      else if (child.localName = 'source') then
        element.source := ParseReference{TFhirDevice}(child, path+'/source') {b}
      else if (child.localName = 'parent') then
        element.parent := ParseReference{TFhirDeviceComponent}(child, path+'/parent') {b}
      else if (child.localName = 'operationalStatus') then
        element.operationalStatusList.Add(ParseCodeableConcept(child, path+'/operationalStatus')){y.2}
      else if (child.localName = 'parameterGroup') then
        element.parameterGroup := ParseCodeableConcept(child, path+'/parameterGroup') {b}
      else if (child.localName = 'measurementPrinciple') then
        element.measurementPrincipleElement := ParseEnum(CODES_TFhirMeasurementPrincipleEnum, SYSTEMS_TFhirMeasurementPrincipleEnum, path+'/measurementPrinciple', child){1a}
      else if (child.localName = 'productionSpecification') then
        element.productionSpecificationList.Add(ParseDeviceComponentProductionSpecification(child, path+'/productionSpecification')){y.2}
      else if (child.localName = 'languageCode') then
        element.languageCode := ParseCodeableConcept(child, path+'/languageCode') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceComponent(xml : TXmlBuilder; name : String; elem : TFhirDeviceComponent);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceComponentChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceComponentChildren(xml : TXmlBuilder; elem : TFhirDeviceComponent);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  ComposeInstant(xml, 'lastSystemChange', elem.lastSystemChangeElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('source') then
    ComposeReference{TFhirDevice}(xml, 'source', elem.source);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('parent') then
    ComposeReference{TFhirDeviceComponent}(xml, 'parent', elem.parent);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('operationalStatus') then
    for i := 0 to elem.operationalStatusList.Count - 1 do
      ComposeCodeableConcept(xml, 'operationalStatus', elem.operationalStatusList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('parameterGroup') then
    ComposeCodeableConcept(xml, 'parameterGroup', elem.parameterGroup);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('measurementPrinciple') then
    ComposeEnum(xml, 'measurementPrinciple', elem.MeasurementPrincipleElement, CODES_TFhirMeasurementPrincipleEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('productionSpecification') then
    for i := 0 to elem.productionSpecificationList.Count - 1 do
      ComposeDeviceComponentProductionSpecification(xml, 'productionSpecification', elem.productionSpecificationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('languageCode') then
    ComposeCodeableConcept(xml, 'languageCode', elem.languageCode);{x.2a}
end;

{$ENDIF FHIR_DEVICECOMPONENT}
{$IFDEF FHIR_DEVICEMETRIC}
function TFHIRXmlParser.ParseDeviceMetricCalibration(element : TMXmlElement; path : string) : TFhirDeviceMetricCalibration;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceMetricCalibration.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceMetricCalibrationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceMetricCalibrationChild(element : TFhirDeviceMetricCalibration; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirMetricCalibrationTypeEnum, SYSTEMS_TFhirMetricCalibrationTypeEnum, path+'/type', child){1a}
      else if (child.localName = 'state') then
        element.stateElement := ParseEnum(CODES_TFhirMetricCalibrationStateEnum, SYSTEMS_TFhirMetricCalibrationStateEnum, path+'/state', child){1a}
      else if (child.localName = 'time') then
        element.timeElement := ParseInstant(child, path+'/time') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceMetricCalibration(xml : TXmlBuilder; name : String; elem : TFhirDeviceMetricCalibration);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceMetricCalibrationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceMetricCalibrationChildren(xml : TXmlBuilder; elem : TFhirDeviceMetricCalibration);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirMetricCalibrationTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'state', elem.StateElement, CODES_TFhirMetricCalibrationStateEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInstant(xml, 'time', elem.timeElement);{x.2b}
end;

function TFHIRXmlParser.ParseDeviceMetric(element : TMXmlElement; path : string) : TFhirDeviceMetric;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceMetric.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceMetricChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceMetricChild(element : TFhirDeviceMetric; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'unit') then
        element.unit_ := ParseCodeableConcept(child, path+'/unit') {b}
      else if (child.localName = 'source') then
        element.source := ParseReference{TFhirDevice}(child, path+'/source') {b}
      else if (child.localName = 'parent') then
        element.parent := ParseReference{TFhirDeviceComponent}(child, path+'/parent') {b}
      else if (child.localName = 'operationalStatus') then
        element.operationalStatusElement := ParseEnum(CODES_TFhirMetricOperationalStatusEnum, SYSTEMS_TFhirMetricOperationalStatusEnum, path+'/operationalStatus', child){1a}
      else if (child.localName = 'color') then
        element.colorElement := ParseEnum(CODES_TFhirMetricColorEnum, SYSTEMS_TFhirMetricColorEnum, path+'/color', child){1a}
      else if (child.localName = 'category') then
        element.categoryElement := ParseEnum(CODES_TFhirMetricCategoryEnum, SYSTEMS_TFhirMetricCategoryEnum, path+'/category', child){1a}
      else if (child.localName = 'measurementPeriod') then
        element.measurementPeriod := ParseTiming(child, path+'/measurementPeriod') {b}
      else if (child.localName = 'calibration') then
        element.calibrationList.Add(ParseDeviceMetricCalibration(child, path+'/calibration')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceMetric(xml : TXmlBuilder; name : String; elem : TFhirDeviceMetric);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceMetricChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceMetricChildren(xml : TXmlBuilder; elem : TFhirDeviceMetric);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('unit_') then
    ComposeCodeableConcept(xml, 'unit', elem.unit_);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('source') then
    ComposeReference{TFhirDevice}(xml, 'source', elem.source);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('parent') then
    ComposeReference{TFhirDeviceComponent}(xml, 'parent', elem.parent);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('operationalStatus') then
    ComposeEnum(xml, 'operationalStatus', elem.OperationalStatusElement, CODES_TFhirMetricOperationalStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('color') then
    ComposeEnum(xml, 'color', elem.ColorElement, CODES_TFhirMetricColorEnum);
  ComposeEnum(xml, 'category', elem.CategoryElement, CODES_TFhirMetricCategoryEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('measurementPeriod') then
    ComposeTiming(xml, 'measurementPeriod', elem.measurementPeriod);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('calibration') then
    for i := 0 to elem.calibrationList.Count - 1 do
      ComposeDeviceMetricCalibration(xml, 'calibration', elem.calibrationList[i]);
end;

{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEUSEREQUEST}
function TFHIRXmlParser.ParseDeviceUseRequest(element : TMXmlElement; path : string) : TFhirDeviceUseRequest;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceUseRequest.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceUseRequestChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceUseRequestChild(element : TFhirDeviceUseRequest; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'bodySiteCodeableConcept') then
        element.bodySite := ParseCodeableConcept(child, path+'/bodySiteCodeableConcept'){x.3}
      else if (child.localName = 'bodySiteReference') then
        element.bodySite := ParseReference(child, path+'/bodySiteReference') {a}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirDeviceUseRequestStatusEnum, SYSTEMS_TFhirDeviceUseRequestStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'device') then
        element.device := ParseReference{TFhirDevice}(child, path+'/device') {b}
      else if (child.localName = 'encounter') then
        element.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'indication') then
        element.indicationList.Add(ParseCodeableConcept(child, path+'/indication')){y.2}
      else if (child.localName = 'notes') then
        element.notesList.Add(ParseString(child, path+'/notes')){y.2}
      else if (child.localName = 'prnReason') then
        element.prnReasonList.Add(ParseCodeableConcept(child, path+'/prnReason')){y.2}
      else if (child.localName = 'orderedOn') then
        element.orderedOnElement := ParseDateTime(child, path+'/orderedOn') {b}
      else if (child.localName = 'recordedOn') then
        element.recordedOnElement := ParseDateTime(child, path+'/recordedOn') {b}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{TFhirPatient}(child, path+'/subject') {b}
      else if (child.localName = 'timingTiming') then
        element.timing := ParseTiming(child, path+'/timingTiming'){x.3}
      else if (child.localName = 'timingPeriod') then
        element.timing := ParsePeriod(child, path+'/timingPeriod'){x.3}
      else if (child.localName = 'timingDateTime') then
        element.timing := ParseDateTime(child, path+'/timingDateTime'){x.3}
      else if (child.localName = 'priority') then
        element.priorityElement := ParseEnum(CODES_TFhirDeviceUseRequestPriorityEnum, SYSTEMS_TFhirDeviceUseRequestPriorityEnum, path+'/priority', child){1a}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceUseRequest(xml : TXmlBuilder; name : String; elem : TFhirDeviceUseRequest);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceUseRequestChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceUseRequestChildren(xml : TXmlBuilder; elem : TFhirDeviceUseRequest);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.bodySite is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'bodySiteCodeableConcept', TFhirCodeableConcept(elem.bodySite))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.bodySite is TFhirReference) {2} then
    ComposeReference(xml, 'bodySiteReference', TFhirReference(elem.bodySite));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirDeviceUseRequestStatusEnum);
  ComposeReference{TFhirDevice}(xml, 'device', elem.device);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('indication') then
    for i := 0 to elem.indicationList.Count - 1 do
      ComposeCodeableConcept(xml, 'indication', elem.indicationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('notes') then
    for i := 0 to elem.notesList.Count - 1 do
      ComposeString(xml, 'notes', elem.notesList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('prnReason') then
    for i := 0 to elem.prnReasonList.Count - 1 do
      ComposeCodeableConcept(xml, 'prnReason', elem.prnReasonList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('orderedOn') then
    ComposeDateTime(xml, 'orderedOn', elem.orderedOnElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recordedOn') then
    ComposeDateTime(xml, 'recordedOn', elem.recordedOnElement);{x.2b}
  ComposeReference{TFhirPatient}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.timing is TFhirTiming) {6} then
    ComposeTiming(xml, 'timingTiming', TFhirTiming(elem.timing))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.timing is TFhirPeriod) {6} then
    ComposePeriod(xml, 'timingPeriod', TFhirPeriod(elem.timing))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.timing is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'timingDateTime', TFhirDateTime(elem.timing));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnum(xml, 'priority', elem.PriorityElement, CODES_TFhirDeviceUseRequestPriorityEnum);
end;

{$ENDIF FHIR_DEVICEUSEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
function TFHIRXmlParser.ParseDeviceUseStatement(element : TMXmlElement; path : string) : TFhirDeviceUseStatement;
var
  child : TMXmlElement;
begin
  result := TFhirDeviceUseStatement.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDeviceUseStatementChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDeviceUseStatementChild(element : TFhirDeviceUseStatement; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'bodySiteCodeableConcept') then
        element.bodySite := ParseCodeableConcept(child, path+'/bodySiteCodeableConcept'){x.3}
      else if (child.localName = 'bodySiteReference') then
        element.bodySite := ParseReference(child, path+'/bodySiteReference') {a}
      else if (child.localName = 'whenUsed') then
        element.whenUsed := ParsePeriod(child, path+'/whenUsed') {b}
      else if (child.localName = 'device') then
        element.device := ParseReference{TFhirDevice}(child, path+'/device') {b}
      else if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'indication') then
        element.indicationList.Add(ParseCodeableConcept(child, path+'/indication')){y.2}
      else if (child.localName = 'notes') then
        element.notesList.Add(ParseString(child, path+'/notes')){y.2}
      else if (child.localName = 'recordedOn') then
        element.recordedOnElement := ParseDateTime(child, path+'/recordedOn') {b}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{TFhirPatient}(child, path+'/subject') {b}
      else if (child.localName = 'timingTiming') then
        element.timing := ParseTiming(child, path+'/timingTiming'){x.3}
      else if (child.localName = 'timingPeriod') then
        element.timing := ParsePeriod(child, path+'/timingPeriod'){x.3}
      else if (child.localName = 'timingDateTime') then
        element.timing := ParseDateTime(child, path+'/timingDateTime'){x.3}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDeviceUseStatement(xml : TXmlBuilder; name : String; elem : TFhirDeviceUseStatement);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDeviceUseStatementChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDeviceUseStatementChildren(xml : TXmlBuilder; elem : TFhirDeviceUseStatement);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.bodySite is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'bodySiteCodeableConcept', TFhirCodeableConcept(elem.bodySite))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.bodySite is TFhirReference) {2} then
    ComposeReference(xml, 'bodySiteReference', TFhirReference(elem.bodySite));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('whenUsed') then
    ComposePeriod(xml, 'whenUsed', elem.whenUsed);{x.2a}
  ComposeReference{TFhirDevice}(xml, 'device', elem.device);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('indication') then
    for i := 0 to elem.indicationList.Count - 1 do
      ComposeCodeableConcept(xml, 'indication', elem.indicationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('notes') then
    for i := 0 to elem.notesList.Count - 1 do
      ComposeString(xml, 'notes', elem.notesList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recordedOn') then
    ComposeDateTime(xml, 'recordedOn', elem.recordedOnElement);{x.2b}
  ComposeReference{TFhirPatient}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.timing is TFhirTiming) {6} then
    ComposeTiming(xml, 'timingTiming', TFhirTiming(elem.timing))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.timing is TFhirPeriod) {6} then
    ComposePeriod(xml, 'timingPeriod', TFhirPeriod(elem.timing))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.timing is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'timingDateTime', TFhirDateTime(elem.timing));
end;

{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICORDER}
function TFHIRXmlParser.ParseDiagnosticOrderEvent(element : TMXmlElement; path : string) : TFhirDiagnosticOrderEvent;
var
  child : TMXmlElement;
begin
  result := TFhirDiagnosticOrderEvent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDiagnosticOrderEventChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDiagnosticOrderEventChild(element : TFhirDiagnosticOrderEvent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirDiagnosticOrderStatusEnum, SYSTEMS_TFhirDiagnosticOrderStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'description') then
        element.description := ParseCodeableConcept(child, path+'/description') {b}
      else if (child.localName = 'dateTime') then
        element.dateTimeElement := ParseDateTime(child, path+'/dateTime') {b}
      else if (child.localName = 'actor') then
        element.actor := ParseReference{Resource}(child, path+'/actor') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDiagnosticOrderEvent(xml : TXmlBuilder; name : String; elem : TFhirDiagnosticOrderEvent);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDiagnosticOrderEventChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDiagnosticOrderEventChildren(xml : TXmlBuilder; elem : TFhirDiagnosticOrderEvent);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirDiagnosticOrderStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'description', elem.description);{x.2a}
  ComposeDateTime(xml, 'dateTime', elem.dateTimeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(xml, 'actor', elem.actor);{x.2a}
end;

function TFHIRXmlParser.ParseDiagnosticOrderItem(element : TMXmlElement; path : string) : TFhirDiagnosticOrderItem;
var
  child : TMXmlElement;
begin
  result := TFhirDiagnosticOrderItem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDiagnosticOrderItemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDiagnosticOrderItemChild(element : TFhirDiagnosticOrderItem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'specimen') then
        element.specimenList.Add(ParseReference{TFhirSpecimen}(child, path+'/specimen')){y.2}
      else if (child.localName = 'bodySite') then
        element.bodySite := ParseCodeableConcept(child, path+'/bodySite') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirDiagnosticOrderStatusEnum, SYSTEMS_TFhirDiagnosticOrderStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'event') then
        element.eventList.Add(ParseDiagnosticOrderEvent(child, path+'/event')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDiagnosticOrderItem(xml : TXmlBuilder; name : String; elem : TFhirDiagnosticOrderItem);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDiagnosticOrderItemChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDiagnosticOrderItemChildren(xml : TXmlBuilder; elem : TFhirDiagnosticOrderItem);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.specimenList.Count - 1 do
      ComposeReference{TFhirSpecimen}(xml, 'specimen', elem.specimenList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'bodySite', elem.bodySite);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirDiagnosticOrderStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.eventList.Count - 1 do
      ComposeDiagnosticOrderEvent(xml, 'event', elem.eventList[i]);
end;

function TFHIRXmlParser.ParseDiagnosticOrder(element : TMXmlElement; path : string) : TFhirDiagnosticOrder;
var
  child : TMXmlElement;
begin
  result := TFhirDiagnosticOrder.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDiagnosticOrderChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDiagnosticOrderChild(element : TFhirDiagnosticOrder; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'orderer') then
        element.orderer := ParseReference{TFhirPractitioner}(child, path+'/orderer') {b}
      else if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'encounter') then
        element.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.localName = 'reason') then
        element.reasonList.Add(ParseCodeableConcept(child, path+'/reason')){y.2}
      else if (child.localName = 'supportingInformation') then
        element.supportingInformationList.Add(ParseReference{Resource}(child, path+'/supportingInformation')){y.2}
      else if (child.localName = 'specimen') then
        element.specimenList.Add(ParseReference{TFhirSpecimen}(child, path+'/specimen')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirDiagnosticOrderStatusEnum, SYSTEMS_TFhirDiagnosticOrderStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'priority') then
        element.priorityElement := ParseEnum(CODES_TFhirDiagnosticOrderPriorityEnum, SYSTEMS_TFhirDiagnosticOrderPriorityEnum, path+'/priority', child){1a}
      else if (child.localName = 'event') then
        element.eventList.Add(ParseDiagnosticOrderEvent(child, path+'/event')){y.2}
      else if (child.localName = 'item') then
        element.itemList.Add(ParseDiagnosticOrderItem(child, path+'/item')){y.2}
      else if (child.localName = 'note') then
        element.noteList.Add(ParseAnnotation(child, path+'/note')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDiagnosticOrder(xml : TXmlBuilder; name : String; elem : TFhirDiagnosticOrder);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDiagnosticOrderChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDiagnosticOrderChildren(xml : TXmlBuilder; elem : TFhirDiagnosticOrder);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('orderer') then
    ComposeReference{TFhirPractitioner}(xml, 'orderer', elem.orderer);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('reason') then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(xml, 'reason', elem.reasonList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('supportingInformation') then
    for i := 0 to elem.supportingInformationList.Count - 1 do
      ComposeReference{Resource}(xml, 'supportingInformation', elem.supportingInformationList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('specimen') then
    for i := 0 to elem.specimenList.Count - 1 do
      ComposeReference{TFhirSpecimen}(xml, 'specimen', elem.specimenList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirDiagnosticOrderStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnum(xml, 'priority', elem.PriorityElement, CODES_TFhirDiagnosticOrderPriorityEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('event') then
    for i := 0 to elem.eventList.Count - 1 do
      ComposeDiagnosticOrderEvent(xml, 'event', elem.eventList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('item') then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeDiagnosticOrderItem(xml, 'item', elem.itemList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', elem.noteList[i]);
end;

{$ENDIF FHIR_DIAGNOSTICORDER}
{$IFDEF FHIR_DIAGNOSTICREPORT}
function TFHIRXmlParser.ParseDiagnosticReportImage(element : TMXmlElement; path : string) : TFhirDiagnosticReportImage;
var
  child : TMXmlElement;
begin
  result := TFhirDiagnosticReportImage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDiagnosticReportImageChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDiagnosticReportImageChild(element : TFhirDiagnosticReportImage; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'comment') then
        element.commentElement := ParseString(child, path+'/comment') {b}
      else if (child.localName = 'link') then
        element.link_ := ParseReference{TFhirMedia}(child, path+'/link') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDiagnosticReportImage(xml : TXmlBuilder; name : String; elem : TFhirDiagnosticReportImage);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDiagnosticReportImageChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDiagnosticReportImageChildren(xml : TXmlBuilder; elem : TFhirDiagnosticReportImage);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'comment', elem.commentElement);{x.2b}
  ComposeReference{TFhirMedia}(xml, 'link', elem.link_);{x.2a}
end;

function TFHIRXmlParser.ParseDiagnosticReport(element : TMXmlElement; path : string) : TFhirDiagnosticReport;
var
  child : TMXmlElement;
begin
  result := TFhirDiagnosticReport.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDiagnosticReportChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDiagnosticReportChild(element : TFhirDiagnosticReport; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirDiagnosticReportStatusEnum, SYSTEMS_TFhirDiagnosticReportStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'category') then
        element.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'encounter') then
        element.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.localName = 'effectivePeriod') then
        element.effective := ParsePeriod(child, path+'/effectivePeriod'){x.3}
      else if (child.localName = 'effectiveDateTime') then
        element.effective := ParseDateTime(child, path+'/effectiveDateTime'){x.3}
      else if (child.localName = 'issued') then
        element.issuedElement := ParseInstant(child, path+'/issued') {b}
      else if (child.localName = 'performer') then
        element.performer := ParseReference{Resource}(child, path+'/performer') {b}
      else if (child.localName = 'request') then
        element.requestList.Add(ParseReference{Resource}(child, path+'/request')){y.2}
      else if (child.localName = 'specimen') then
        element.specimenList.Add(ParseReference{TFhirSpecimen}(child, path+'/specimen')){y.2}
      else if (child.localName = 'result') then
        element.resultList.Add(ParseReference{TFhirObservation}(child, path+'/result')){y.2}
      else if (child.localName = 'imagingStudy') then
        element.imagingStudyList.Add(ParseReference{Resource}(child, path+'/imagingStudy')){y.2}
      else if (child.localName = 'image') then
        element.imageList.Add(ParseDiagnosticReportImage(child, path+'/image')){y.2}
      else if (child.localName = 'conclusion') then
        element.conclusionElement := ParseString(child, path+'/conclusion') {b}
      else if (child.localName = 'codedDiagnosis') then
        element.codedDiagnosisList.Add(ParseCodeableConcept(child, path+'/codedDiagnosis')){y.2}
      else if (child.localName = 'presentedForm') then
        element.presentedFormList.Add(ParseAttachment(child, path+'/presentedForm')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDiagnosticReport(xml : TXmlBuilder; name : String; elem : TFhirDiagnosticReport);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDiagnosticReportChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDiagnosticReportChildren(xml : TXmlBuilder; elem : TFhirDiagnosticReport);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirDiagnosticReportStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeCodeableConcept(xml, 'category', elem.category);{x.2a}
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2a}
  if (elem.effective is TFhirPeriod) {6} then
    ComposePeriod(xml, 'effectivePeriod', TFhirPeriod(elem.effective))
  else if (elem.effective is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'effectiveDateTime', TFhirDateTime(elem.effective));
  ComposeInstant(xml, 'issued', elem.issuedElement);{x.2b}
  ComposeReference{Resource}(xml, 'performer', elem.performer);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('request') then
    for i := 0 to elem.requestList.Count - 1 do
      ComposeReference{Resource}(xml, 'request', elem.requestList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('specimen') then
    for i := 0 to elem.specimenList.Count - 1 do
      ComposeReference{TFhirSpecimen}(xml, 'specimen', elem.specimenList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('result') then
    for i := 0 to elem.resultList.Count - 1 do
      ComposeReference{TFhirObservation}(xml, 'result', elem.resultList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('imagingStudy') then
    for i := 0 to elem.imagingStudyList.Count - 1 do
      ComposeReference{Resource}(xml, 'imagingStudy', elem.imagingStudyList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('image') then
    for i := 0 to elem.imageList.Count - 1 do
      ComposeDiagnosticReportImage(xml, 'image', elem.imageList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('conclusion') then
    ComposeString(xml, 'conclusion', elem.conclusionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('codedDiagnosis') then
    for i := 0 to elem.codedDiagnosisList.Count - 1 do
      ComposeCodeableConcept(xml, 'codedDiagnosis', elem.codedDiagnosisList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('presentedForm') then
    for i := 0 to elem.presentedFormList.Count - 1 do
      ComposeAttachment(xml, 'presentedForm', elem.presentedFormList[i]);
end;

{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
function TFHIRXmlParser.ParseDocumentManifestContent(element : TMXmlElement; path : string) : TFhirDocumentManifestContent;
var
  child : TMXmlElement;
begin
  result := TFhirDocumentManifestContent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDocumentManifestContentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDocumentManifestContentChild(element : TFhirDocumentManifestContent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'pAttachment') then
        element.p := ParseAttachment(child, path+'/pAttachment'){x.3}
      else if (child.localName = 'pReference') then
        element.p := ParseReference(child, path+'/pReference') {a}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDocumentManifestContent(xml : TXmlBuilder; name : String; elem : TFhirDocumentManifestContent);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDocumentManifestContentChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDocumentManifestContentChildren(xml : TXmlBuilder; elem : TFhirDocumentManifestContent);
begin
  composeBackboneElementChildren(xml, elem);
  if (elem.p is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'pAttachment', TFhirAttachment(elem.p))
  else if (elem.p is TFhirReference) {2} then
    ComposeReference(xml, 'pReference', TFhirReference(elem.p));
end;

function TFHIRXmlParser.ParseDocumentManifestRelated(element : TMXmlElement; path : string) : TFhirDocumentManifestRelated;
var
  child : TMXmlElement;
begin
  result := TFhirDocumentManifestRelated.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDocumentManifestRelatedChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDocumentManifestRelatedChild(element : TFhirDocumentManifestRelated; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'ref') then
        element.ref := ParseReference{TFhirReference}(child, path+'/ref') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDocumentManifestRelated(xml : TXmlBuilder; name : String; elem : TFhirDocumentManifestRelated);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDocumentManifestRelatedChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDocumentManifestRelatedChildren(xml : TXmlBuilder; elem : TFhirDocumentManifestRelated);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(xml, 'ref', elem.ref);{x.2a}
end;

function TFHIRXmlParser.ParseDocumentManifest(element : TMXmlElement; path : string) : TFhirDocumentManifest;
var
  child : TMXmlElement;
begin
  result := TFhirDocumentManifest.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDocumentManifestChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDocumentManifestChild(element : TFhirDocumentManifest; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'masterIdentifier') then
        element.masterIdentifier := ParseIdentifier(child, path+'/masterIdentifier') {b}
      else if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'recipient') then
        element.recipientList.Add(ParseReference{Resource}(child, path+'/recipient')){y.2}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'author') then
        element.authorList.Add(ParseReference{Resource}(child, path+'/author')){y.2}
      else if (child.localName = 'created') then
        element.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.localName = 'source') then
        element.sourceElement := ParseUri(child, path+'/source') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirDocumentReferenceStatusEnum, SYSTEMS_TFhirDocumentReferenceStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'content') then
        element.contentList.Add(ParseDocumentManifestContent(child, path+'/content')){y.2}
      else if (child.localName = 'related') then
        element.relatedList.Add(ParseDocumentManifestRelated(child, path+'/related')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDocumentManifest(xml : TXmlBuilder; name : String; elem : TFhirDocumentManifest);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDocumentManifestChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDocumentManifestChildren(xml : TXmlBuilder; elem : TFhirDocumentManifest);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('masterIdentifier') then
    ComposeIdentifier(xml, 'masterIdentifier', elem.masterIdentifier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recipient') then
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{Resource}(xml, 'recipient', elem.recipientList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{Resource}(xml, 'author', elem.authorList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTime(xml, 'created', elem.createdElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('source') then
    ComposeUri(xml, 'source', elem.sourceElement);{x.2b}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirDocumentReferenceStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  for i := 0 to elem.contentList.Count - 1 do
      ComposeDocumentManifestContent(xml, 'content', elem.contentList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('related') then
    for i := 0 to elem.relatedList.Count - 1 do
      ComposeDocumentManifestRelated(xml, 'related', elem.relatedList[i]);
end;

{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
function TFHIRXmlParser.ParseDocumentReferenceRelatesTo(element : TMXmlElement; path : string) : TFhirDocumentReferenceRelatesTo;
var
  child : TMXmlElement;
begin
  result := TFhirDocumentReferenceRelatesTo.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDocumentReferenceRelatesToChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDocumentReferenceRelatesToChild(element : TFhirDocumentReferenceRelatesTo; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.codeElement := ParseEnum(CODES_TFhirDocumentRelationshipTypeEnum, SYSTEMS_TFhirDocumentRelationshipTypeEnum, path+'/code', child){1a}
      else if (child.localName = 'target') then
        element.target := ParseReference{TFhirDocumentReference}(child, path+'/target') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDocumentReferenceRelatesTo(xml : TXmlBuilder; name : String; elem : TFhirDocumentReferenceRelatesTo);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDocumentReferenceRelatesToChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDocumentReferenceRelatesToChildren(xml : TXmlBuilder; elem : TFhirDocumentReferenceRelatesTo);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'code', elem.CodeElement, CODES_TFhirDocumentRelationshipTypeEnum);
  ComposeReference{TFhirDocumentReference}(xml, 'target', elem.target);{x.2a}
end;

function TFHIRXmlParser.ParseDocumentReferenceContent(element : TMXmlElement; path : string) : TFhirDocumentReferenceContent;
var
  child : TMXmlElement;
begin
  result := TFhirDocumentReferenceContent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDocumentReferenceContentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDocumentReferenceContentChild(element : TFhirDocumentReferenceContent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'attachment') then
        element.attachment := ParseAttachment(child, path+'/attachment') {b}
      else if (child.localName = 'format') then
        element.formatList.Add(ParseCoding(child, path+'/format')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDocumentReferenceContent(xml : TXmlBuilder; name : String; elem : TFhirDocumentReferenceContent);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDocumentReferenceContentChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDocumentReferenceContentChildren(xml : TXmlBuilder; elem : TFhirDocumentReferenceContent);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeAttachment(xml, 'attachment', elem.attachment);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.formatList.Count - 1 do
      ComposeCoding(xml, 'format', elem.formatList[i]);
end;

function TFHIRXmlParser.ParseDocumentReferenceContext(element : TMXmlElement; path : string) : TFhirDocumentReferenceContext;
var
  child : TMXmlElement;
begin
  result := TFhirDocumentReferenceContext.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDocumentReferenceContextChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDocumentReferenceContextChild(element : TFhirDocumentReferenceContext; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'encounter') then
        element.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.localName = 'event') then
        element.eventList.Add(ParseCodeableConcept(child, path+'/event')){y.2}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if (child.localName = 'facilityType') then
        element.facilityType := ParseCodeableConcept(child, path+'/facilityType') {b}
      else if (child.localName = 'practiceSetting') then
        element.practiceSetting := ParseCodeableConcept(child, path+'/practiceSetting') {b}
      else if (child.localName = 'sourcePatientInfo') then
        element.sourcePatientInfo := ParseReference{TFhirPatient}(child, path+'/sourcePatientInfo') {b}
      else if (child.localName = 'related') then
        element.relatedList.Add(ParseDocumentReferenceContextRelated(child, path+'/related')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDocumentReferenceContext(xml : TXmlBuilder; name : String; elem : TFhirDocumentReferenceContext);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDocumentReferenceContextChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDocumentReferenceContextChildren(xml : TXmlBuilder; elem : TFhirDocumentReferenceContext);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.eventList.Count - 1 do
      ComposeCodeableConcept(xml, 'event', elem.eventList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'facilityType', elem.facilityType);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'practiceSetting', elem.practiceSetting);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPatient}(xml, 'sourcePatientInfo', elem.sourcePatientInfo);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.relatedList.Count - 1 do
      ComposeDocumentReferenceContextRelated(xml, 'related', elem.relatedList[i]);
end;

function TFHIRXmlParser.ParseDocumentReferenceContextRelated(element : TMXmlElement; path : string) : TFhirDocumentReferenceContextRelated;
var
  child : TMXmlElement;
begin
  result := TFhirDocumentReferenceContextRelated.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDocumentReferenceContextRelatedChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDocumentReferenceContextRelatedChild(element : TFhirDocumentReferenceContextRelated; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'ref') then
        element.ref := ParseReference{TFhirReference}(child, path+'/ref') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDocumentReferenceContextRelated(xml : TXmlBuilder; name : String; elem : TFhirDocumentReferenceContextRelated);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDocumentReferenceContextRelatedChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDocumentReferenceContextRelatedChildren(xml : TXmlBuilder; elem : TFhirDocumentReferenceContextRelated);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(xml, 'ref', elem.ref);{x.2a}
end;

function TFHIRXmlParser.ParseDocumentReference(element : TMXmlElement; path : string) : TFhirDocumentReference;
var
  child : TMXmlElement;
begin
  result := TFhirDocumentReference.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseDocumentReferenceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDocumentReferenceChild(element : TFhirDocumentReference; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'masterIdentifier') then
        element.masterIdentifier := ParseIdentifier(child, path+'/masterIdentifier') {b}
      else if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'class') then
        element.class_ := ParseCodeableConcept(child, path+'/class') {b}
      else if (child.localName = 'author') then
        element.authorList.Add(ParseReference{Resource}(child, path+'/author')){y.2}
      else if (child.localName = 'custodian') then
        element.custodian := ParseReference{TFhirOrganization}(child, path+'/custodian') {b}
      else if (child.localName = 'authenticator') then
        element.authenticator := ParseReference{Resource}(child, path+'/authenticator') {b}
      else if (child.localName = 'created') then
        element.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.localName = 'indexed') then
        element.indexedElement := ParseInstant(child, path+'/indexed') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirDocumentReferenceStatusEnum, SYSTEMS_TFhirDocumentReferenceStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'docStatus') then
        element.docStatus := ParseCodeableConcept(child, path+'/docStatus') {b}
      else if (child.localName = 'relatesTo') then
        element.relatesToList.Add(ParseDocumentReferenceRelatesTo(child, path+'/relatesTo')){y.2}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'securityLabel') then
        element.securityLabelList.Add(ParseCodeableConcept(child, path+'/securityLabel')){y.2}
      else if (child.localName = 'content') then
        element.contentList.Add(ParseDocumentReferenceContent(child, path+'/content')){y.2}
      else if (child.localName = 'context') then
        element.context := ParseDocumentReferenceContext(child, path+'/context') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeDocumentReference(xml : TXmlBuilder; name : String; elem : TFhirDocumentReference);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeDocumentReferenceChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeDocumentReferenceChildren(xml : TXmlBuilder; elem : TFhirDocumentReference);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('masterIdentifier') then
    ComposeIdentifier(xml, 'masterIdentifier', elem.masterIdentifier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('class_') then
    ComposeCodeableConcept(xml, 'class', elem.class_);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    for i := 0 to elem.authorList.Count - 1 do
      ComposeReference{Resource}(xml, 'author', elem.authorList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('custodian') then
    ComposeReference{TFhirOrganization}(xml, 'custodian', elem.custodian);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authenticator') then
    ComposeReference{Resource}(xml, 'authenticator', elem.authenticator);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTime(xml, 'created', elem.createdElement);{x.2b}
  ComposeInstant(xml, 'indexed', elem.indexedElement);{x.2b}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirDocumentReferenceStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('docStatus') then
    ComposeCodeableConcept(xml, 'docStatus', elem.docStatus);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('relatesTo') then
    for i := 0 to elem.relatesToList.Count - 1 do
      ComposeDocumentReferenceRelatesTo(xml, 'relatesTo', elem.relatesToList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('securityLabel') then
    for i := 0 to elem.securityLabelList.Count - 1 do
      ComposeCodeableConcept(xml, 'securityLabel', elem.securityLabelList[i]);
  for i := 0 to elem.contentList.Count - 1 do
      ComposeDocumentReferenceContent(xml, 'content', elem.contentList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    ComposeDocumentReferenceContext(xml, 'context', elem.context);{x.2a}
end;

{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ELIGIBILITYREQUEST}
function TFHIRXmlParser.ParseEligibilityRequest(element : TMXmlElement; path : string) : TFhirEligibilityRequest;
var
  child : TMXmlElement;
begin
  result := TFhirEligibilityRequest.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEligibilityRequestChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEligibilityRequestChild(element : TFhirEligibilityRequest; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'ruleset') then
        element.ruleset := ParseCoding(child, path+'/ruleset') {b}
      else if (child.localName = 'originalRuleset') then
        element.originalRuleset := ParseCoding(child, path+'/originalRuleset') {b}
      else if (child.localName = 'created') then
        element.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.localName = 'target') then
        element.target := ParseReference{TFhirOrganization}(child, path+'/target') {b}
      else if (child.localName = 'provider') then
        element.provider := ParseReference{TFhirPractitioner}(child, path+'/provider') {b}
      else if (child.localName = 'organization') then
        element.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEligibilityRequest(xml : TXmlBuilder; name : String; elem : TFhirEligibilityRequest);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEligibilityRequestChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEligibilityRequestChildren(xml : TXmlBuilder; elem : TFhirEligibilityRequest);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ruleset') then
    ComposeCoding(xml, 'ruleset', elem.ruleset);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('originalRuleset') then
    ComposeCoding(xml, 'originalRuleset', elem.originalRuleset);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTime(xml, 'created', elem.createdElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('target') then
    ComposeReference{TFhirOrganization}(xml, 'target', elem.target);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('provider') then
    ComposeReference{TFhirPractitioner}(xml, 'provider', elem.provider);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2a}
end;

{$ENDIF FHIR_ELIGIBILITYREQUEST}
{$IFDEF FHIR_ELIGIBILITYRESPONSE}
function TFHIRXmlParser.ParseEligibilityResponse(element : TMXmlElement; path : string) : TFhirEligibilityResponse;
var
  child : TMXmlElement;
begin
  result := TFhirEligibilityResponse.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEligibilityResponseChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEligibilityResponseChild(element : TFhirEligibilityResponse; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'request') then
        element.request := ParseReference{TFhirEligibilityRequest}(child, path+'/request') {b}
      else if (child.localName = 'outcome') then
        element.outcomeElement := ParseEnum(CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum, path+'/outcome', child){1a}
      else if (child.localName = 'disposition') then
        element.dispositionElement := ParseString(child, path+'/disposition') {b}
      else if (child.localName = 'ruleset') then
        element.ruleset := ParseCoding(child, path+'/ruleset') {b}
      else if (child.localName = 'originalRuleset') then
        element.originalRuleset := ParseCoding(child, path+'/originalRuleset') {b}
      else if (child.localName = 'created') then
        element.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.localName = 'organization') then
        element.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.localName = 'requestProvider') then
        element.requestProvider := ParseReference{TFhirPractitioner}(child, path+'/requestProvider') {b}
      else if (child.localName = 'requestOrganization') then
        element.requestOrganization := ParseReference{TFhirOrganization}(child, path+'/requestOrganization') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEligibilityResponse(xml : TXmlBuilder; name : String; elem : TFhirEligibilityResponse);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEligibilityResponseChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEligibilityResponseChildren(xml : TXmlBuilder; elem : TFhirEligibilityResponse);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('request') then
    ComposeReference{TFhirEligibilityRequest}(xml, 'request', elem.request);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcome') then
    ComposeEnum(xml, 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('disposition') then
    ComposeString(xml, 'disposition', elem.dispositionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ruleset') then
    ComposeCoding(xml, 'ruleset', elem.ruleset);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('originalRuleset') then
    ComposeCoding(xml, 'originalRuleset', elem.originalRuleset);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTime(xml, 'created', elem.createdElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestProvider') then
    ComposeReference{TFhirPractitioner}(xml, 'requestProvider', elem.requestProvider);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestOrganization') then
    ComposeReference{TFhirOrganization}(xml, 'requestOrganization', elem.requestOrganization);{x.2a}
end;

{$ENDIF FHIR_ELIGIBILITYRESPONSE}
{$IFDEF FHIR_ENCOUNTER}
function TFHIRXmlParser.ParseEncounterStatusHistory(element : TMXmlElement; path : string) : TFhirEncounterStatusHistory;
var
  child : TMXmlElement;
begin
  result := TFhirEncounterStatusHistory.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEncounterStatusHistoryChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEncounterStatusHistoryChild(element : TFhirEncounterStatusHistory; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirEncounterStateEnum, SYSTEMS_TFhirEncounterStateEnum, path+'/status', child){1a}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEncounterStatusHistory(xml : TXmlBuilder; name : String; elem : TFhirEncounterStatusHistory);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEncounterStatusHistoryChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEncounterStatusHistoryChildren(xml : TXmlBuilder; elem : TFhirEncounterStatusHistory);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirEncounterStateEnum);
  ComposePeriod(xml, 'period', elem.period);{x.2a}
end;

function TFHIRXmlParser.ParseEncounterParticipant(element : TMXmlElement; path : string) : TFhirEncounterParticipant;
var
  child : TMXmlElement;
begin
  result := TFhirEncounterParticipant.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEncounterParticipantChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEncounterParticipantChild(element : TFhirEncounterParticipant; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_List.Add(ParseCodeableConcept(child, path+'/type')){y.2}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if (child.localName = 'individual') then
        element.individual := ParseReference{Resource}(child, path+'/individual') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEncounterParticipant(xml : TXmlBuilder; name : String; elem : TFhirEncounterParticipant);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEncounterParticipantChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEncounterParticipantChildren(xml : TXmlBuilder; elem : TFhirEncounterParticipant);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', elem.type_List[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'individual', elem.individual);{x.2a}
end;

function TFHIRXmlParser.ParseEncounterHospitalization(element : TMXmlElement; path : string) : TFhirEncounterHospitalization;
var
  child : TMXmlElement;
begin
  result := TFhirEncounterHospitalization.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEncounterHospitalizationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEncounterHospitalizationChild(element : TFhirEncounterHospitalization; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'preAdmissionIdentifier') then
        element.preAdmissionIdentifier := ParseIdentifier(child, path+'/preAdmissionIdentifier') {b}
      else if (child.localName = 'origin') then
        element.origin := ParseReference{TFhirLocation}(child, path+'/origin') {b}
      else if (child.localName = 'admitSource') then
        element.admitSource := ParseCodeableConcept(child, path+'/admitSource') {b}
      else if (child.localName = 'admittingDiagnosis') then
        element.admittingDiagnosisList.Add(ParseReference{TFhirCondition}(child, path+'/admittingDiagnosis')){y.2}
      else if (child.localName = 'reAdmission') then
        element.reAdmission := ParseCodeableConcept(child, path+'/reAdmission') {b}
      else if (child.localName = 'dietPreference') then
        element.dietPreferenceList.Add(ParseCodeableConcept(child, path+'/dietPreference')){y.2}
      else if (child.localName = 'specialCourtesy') then
        element.specialCourtesyList.Add(ParseCodeableConcept(child, path+'/specialCourtesy')){y.2}
      else if (child.localName = 'specialArrangement') then
        element.specialArrangementList.Add(ParseCodeableConcept(child, path+'/specialArrangement')){y.2}
      else if (child.localName = 'destination') then
        element.destination := ParseReference{TFhirLocation}(child, path+'/destination') {b}
      else if (child.localName = 'dischargeDisposition') then
        element.dischargeDisposition := ParseCodeableConcept(child, path+'/dischargeDisposition') {b}
      else if (child.localName = 'dischargeDiagnosis') then
        element.dischargeDiagnosisList.Add(ParseReference{TFhirCondition}(child, path+'/dischargeDiagnosis')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEncounterHospitalization(xml : TXmlBuilder; name : String; elem : TFhirEncounterHospitalization);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEncounterHospitalizationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEncounterHospitalizationChildren(xml : TXmlBuilder; elem : TFhirEncounterHospitalization);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeIdentifier(xml, 'preAdmissionIdentifier', elem.preAdmissionIdentifier);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(xml, 'origin', elem.origin);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'admitSource', elem.admitSource);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.admittingDiagnosisList.Count - 1 do
      ComposeReference{TFhirCondition}(xml, 'admittingDiagnosis', elem.admittingDiagnosisList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'reAdmission', elem.reAdmission);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.dietPreferenceList.Count - 1 do
      ComposeCodeableConcept(xml, 'dietPreference', elem.dietPreferenceList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.specialCourtesyList.Count - 1 do
      ComposeCodeableConcept(xml, 'specialCourtesy', elem.specialCourtesyList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.specialArrangementList.Count - 1 do
      ComposeCodeableConcept(xml, 'specialArrangement', elem.specialArrangementList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirLocation}(xml, 'destination', elem.destination);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'dischargeDisposition', elem.dischargeDisposition);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.dischargeDiagnosisList.Count - 1 do
      ComposeReference{TFhirCondition}(xml, 'dischargeDiagnosis', elem.dischargeDiagnosisList[i]);
end;

function TFHIRXmlParser.ParseEncounterLocation(element : TMXmlElement; path : string) : TFhirEncounterLocation;
var
  child : TMXmlElement;
begin
  result := TFhirEncounterLocation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEncounterLocationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEncounterLocationChild(element : TFhirEncounterLocation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'location') then
        element.location := ParseReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirEncounterLocationStatusEnum, SYSTEMS_TFhirEncounterLocationStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEncounterLocation(xml : TXmlBuilder; name : String; elem : TFhirEncounterLocation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEncounterLocationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEncounterLocationChildren(xml : TXmlBuilder; elem : TFhirEncounterLocation);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeReference{TFhirLocation}(xml, 'location', elem.location);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirEncounterLocationStatusEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
end;

function TFHIRXmlParser.ParseEncounter(element : TMXmlElement; path : string) : TFhirEncounter;
var
  child : TMXmlElement;
begin
  result := TFhirEncounter.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEncounterChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEncounterChild(element : TFhirEncounter; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirEncounterStateEnum, SYSTEMS_TFhirEncounterStateEnum, path+'/status', child){1a}
      else if (child.localName = 'statusHistory') then
        element.statusHistoryList.Add(ParseEncounterStatusHistory(child, path+'/statusHistory')){y.2}
      else if (child.localName = 'class') then
        element.class_Element := ParseEnum(CODES_TFhirEncounterClassEnum, SYSTEMS_TFhirEncounterClassEnum, path+'/class', child){1a}
      else if (child.localName = 'type') then
        element.type_List.Add(ParseCodeableConcept(child, path+'/type')){y.2}
      else if (child.localName = 'priority') then
        element.priority := ParseCodeableConcept(child, path+'/priority') {b}
      else if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'episodeOfCare') then
        element.episodeOfCareList.Add(ParseReference{TFhirEpisodeOfCare}(child, path+'/episodeOfCare')){y.2}
      else if (child.localName = 'incomingReferral') then
        element.incomingReferralList.Add(ParseReference{TFhirReferralRequest}(child, path+'/incomingReferral')){y.2}
      else if (child.localName = 'participant') then
        element.participantList.Add(ParseEncounterParticipant(child, path+'/participant')){y.2}
      else if (child.localName = 'appointment') then
        element.appointment := ParseReference{TFhirAppointment}(child, path+'/appointment') {b}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if (child.localName = 'length') then
        element.length := ParseQuantity(child, path+'/length') {b}
      else if (child.localName = 'reason') then
        element.reasonList.Add(ParseCodeableConcept(child, path+'/reason')){y.2}
      else if (child.localName = 'indication') then
        element.indicationList.Add(ParseReference{Resource}(child, path+'/indication')){y.2}
      else if (child.localName = 'hospitalization') then
        element.hospitalization := ParseEncounterHospitalization(child, path+'/hospitalization') {b}
      else if (child.localName = 'location') then
        element.locationList.Add(ParseEncounterLocation(child, path+'/location')){y.2}
      else if (child.localName = 'serviceProvider') then
        element.serviceProvider := ParseReference{TFhirOrganization}(child, path+'/serviceProvider') {b}
      else if (child.localName = 'partOf') then
        element.partOf := ParseReference{TFhirEncounter}(child, path+'/partOf') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEncounter(xml : TXmlBuilder; name : String; elem : TFhirEncounter);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEncounterChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEncounterChildren(xml : TXmlBuilder; elem : TFhirEncounter);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirEncounterStateEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('statusHistory') then
    for i := 0 to elem.statusHistoryList.Count - 1 do
      ComposeEncounterStatusHistory(xml, 'statusHistory', elem.statusHistoryList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('class_') then
    ComposeEnum(xml, 'class', elem.Class_Element, CODES_TFhirEncounterClassEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', elem.type_List[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('priority') then
    ComposeCodeableConcept(xml, 'priority', elem.priority);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('episodeOfCare') then
    for i := 0 to elem.episodeOfCareList.Count - 1 do
      ComposeReference{TFhirEpisodeOfCare}(xml, 'episodeOfCare', elem.episodeOfCareList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('incomingReferral') then
    for i := 0 to elem.incomingReferralList.Count - 1 do
      ComposeReference{TFhirReferralRequest}(xml, 'incomingReferral', elem.incomingReferralList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('participant') then
    for i := 0 to elem.participantList.Count - 1 do
      ComposeEncounterParticipant(xml, 'participant', elem.participantList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('appointment') then
    ComposeReference{TFhirAppointment}(xml, 'appointment', elem.appointment);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('period') then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('length') then
    ComposeQuantity(xml, 'length', elem.length);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reason') then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(xml, 'reason', elem.reasonList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('indication') then
    for i := 0 to elem.indicationList.Count - 1 do
      ComposeReference{Resource}(xml, 'indication', elem.indicationList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('hospitalization') then
    ComposeEncounterHospitalization(xml, 'hospitalization', elem.hospitalization);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('location') then
    for i := 0 to elem.locationList.Count - 1 do
      ComposeEncounterLocation(xml, 'location', elem.locationList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('serviceProvider') then
    ComposeReference{TFhirOrganization}(xml, 'serviceProvider', elem.serviceProvider);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('partOf') then
    ComposeReference{TFhirEncounter}(xml, 'partOf', elem.partOf);{x.2a}
end;

{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENROLLMENTREQUEST}
function TFHIRXmlParser.ParseEnrollmentRequest(element : TMXmlElement; path : string) : TFhirEnrollmentRequest;
var
  child : TMXmlElement;
begin
  result := TFhirEnrollmentRequest.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEnrollmentRequestChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEnrollmentRequestChild(element : TFhirEnrollmentRequest; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'ruleset') then
        element.ruleset := ParseCoding(child, path+'/ruleset') {b}
      else if (child.localName = 'originalRuleset') then
        element.originalRuleset := ParseCoding(child, path+'/originalRuleset') {b}
      else if (child.localName = 'created') then
        element.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.localName = 'target') then
        element.target := ParseReference{TFhirOrganization}(child, path+'/target') {b}
      else if (child.localName = 'provider') then
        element.provider := ParseReference{TFhirPractitioner}(child, path+'/provider') {b}
      else if (child.localName = 'organization') then
        element.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{TFhirPatient}(child, path+'/subject') {b}
      else if (child.localName = 'coverage') then
        element.coverage := ParseReference{TFhirCoverage}(child, path+'/coverage') {b}
      else if (child.localName = 'relationship') then
        element.relationship := ParseCoding(child, path+'/relationship') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEnrollmentRequest(xml : TXmlBuilder; name : String; elem : TFhirEnrollmentRequest);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEnrollmentRequestChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEnrollmentRequestChildren(xml : TXmlBuilder; elem : TFhirEnrollmentRequest);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ruleset') then
    ComposeCoding(xml, 'ruleset', elem.ruleset);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('originalRuleset') then
    ComposeCoding(xml, 'originalRuleset', elem.originalRuleset);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTime(xml, 'created', elem.createdElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('target') then
    ComposeReference{TFhirOrganization}(xml, 'target', elem.target);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('provider') then
    ComposeReference{TFhirPractitioner}(xml, 'provider', elem.provider);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2a}
  ComposeReference{TFhirPatient}(xml, 'subject', elem.subject);{x.2a}
  ComposeReference{TFhirCoverage}(xml, 'coverage', elem.coverage);{x.2a}
  ComposeCoding(xml, 'relationship', elem.relationship);{x.2a}
end;

{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
function TFHIRXmlParser.ParseEnrollmentResponse(element : TMXmlElement; path : string) : TFhirEnrollmentResponse;
var
  child : TMXmlElement;
begin
  result := TFhirEnrollmentResponse.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEnrollmentResponseChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEnrollmentResponseChild(element : TFhirEnrollmentResponse; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'request') then
        element.request := ParseReference{TFhirEnrollmentRequest}(child, path+'/request') {b}
      else if (child.localName = 'outcome') then
        element.outcomeElement := ParseEnum(CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum, path+'/outcome', child){1a}
      else if (child.localName = 'disposition') then
        element.dispositionElement := ParseString(child, path+'/disposition') {b}
      else if (child.localName = 'ruleset') then
        element.ruleset := ParseCoding(child, path+'/ruleset') {b}
      else if (child.localName = 'originalRuleset') then
        element.originalRuleset := ParseCoding(child, path+'/originalRuleset') {b}
      else if (child.localName = 'created') then
        element.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.localName = 'organization') then
        element.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.localName = 'requestProvider') then
        element.requestProvider := ParseReference{TFhirPractitioner}(child, path+'/requestProvider') {b}
      else if (child.localName = 'requestOrganization') then
        element.requestOrganization := ParseReference{TFhirOrganization}(child, path+'/requestOrganization') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEnrollmentResponse(xml : TXmlBuilder; name : String; elem : TFhirEnrollmentResponse);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEnrollmentResponseChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEnrollmentResponseChildren(xml : TXmlBuilder; elem : TFhirEnrollmentResponse);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('request') then
    ComposeReference{TFhirEnrollmentRequest}(xml, 'request', elem.request);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcome') then
    ComposeEnum(xml, 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('disposition') then
    ComposeString(xml, 'disposition', elem.dispositionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ruleset') then
    ComposeCoding(xml, 'ruleset', elem.ruleset);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('originalRuleset') then
    ComposeCoding(xml, 'originalRuleset', elem.originalRuleset);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTime(xml, 'created', elem.createdElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestProvider') then
    ComposeReference{TFhirPractitioner}(xml, 'requestProvider', elem.requestProvider);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestOrganization') then
    ComposeReference{TFhirOrganization}(xml, 'requestOrganization', elem.requestOrganization);{x.2a}
end;

{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
function TFHIRXmlParser.ParseEpisodeOfCareStatusHistory(element : TMXmlElement; path : string) : TFhirEpisodeOfCareStatusHistory;
var
  child : TMXmlElement;
begin
  result := TFhirEpisodeOfCareStatusHistory.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEpisodeOfCareStatusHistoryChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEpisodeOfCareStatusHistoryChild(element : TFhirEpisodeOfCareStatusHistory; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirEpisodeOfCareStatusEnum, SYSTEMS_TFhirEpisodeOfCareStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEpisodeOfCareStatusHistory(xml : TXmlBuilder; name : String; elem : TFhirEpisodeOfCareStatusHistory);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEpisodeOfCareStatusHistoryChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEpisodeOfCareStatusHistoryChildren(xml : TXmlBuilder; elem : TFhirEpisodeOfCareStatusHistory);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirEpisodeOfCareStatusEnum);
  ComposePeriod(xml, 'period', elem.period);{x.2a}
end;

function TFHIRXmlParser.ParseEpisodeOfCareCareTeam(element : TMXmlElement; path : string) : TFhirEpisodeOfCareCareTeam;
var
  child : TMXmlElement;
begin
  result := TFhirEpisodeOfCareCareTeam.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEpisodeOfCareCareTeamChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEpisodeOfCareCareTeamChild(element : TFhirEpisodeOfCareCareTeam; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'role') then
        element.roleList.Add(ParseCodeableConcept(child, path+'/role')){y.2}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if (child.localName = 'member') then
        element.member := ParseReference{Resource}(child, path+'/member') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEpisodeOfCareCareTeam(xml : TXmlBuilder; name : String; elem : TFhirEpisodeOfCareCareTeam);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEpisodeOfCareCareTeamChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEpisodeOfCareCareTeamChildren(xml : TXmlBuilder; elem : TFhirEpisodeOfCareCareTeam);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.roleList.Count - 1 do
      ComposeCodeableConcept(xml, 'role', elem.roleList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{Resource}(xml, 'member', elem.member);{x.2a}
end;

function TFHIRXmlParser.ParseEpisodeOfCare(element : TMXmlElement; path : string) : TFhirEpisodeOfCare;
var
  child : TMXmlElement;
begin
  result := TFhirEpisodeOfCare.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseEpisodeOfCareChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseEpisodeOfCareChild(element : TFhirEpisodeOfCare; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirEpisodeOfCareStatusEnum, SYSTEMS_TFhirEpisodeOfCareStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'statusHistory') then
        element.statusHistoryList.Add(ParseEpisodeOfCareStatusHistory(child, path+'/statusHistory')){y.2}
      else if (child.localName = 'type') then
        element.type_List.Add(ParseCodeableConcept(child, path+'/type')){y.2}
      else if (child.localName = 'condition') then
        element.conditionList.Add(ParseReference{TFhirCondition}(child, path+'/condition')){y.2}
      else if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'managingOrganization') then
        element.managingOrganization := ParseReference{TFhirOrganization}(child, path+'/managingOrganization') {b}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if (child.localName = 'referralRequest') then
        element.referralRequestList.Add(ParseReference{TFhirReferralRequest}(child, path+'/referralRequest')){y.2}
      else if (child.localName = 'careManager') then
        element.careManager := ParseReference{TFhirPractitioner}(child, path+'/careManager') {b}
      else if (child.localName = 'careTeam') then
        element.careTeamList.Add(ParseEpisodeOfCareCareTeam(child, path+'/careTeam')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeEpisodeOfCare(xml : TXmlBuilder; name : String; elem : TFhirEpisodeOfCare);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeEpisodeOfCareChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeEpisodeOfCareChildren(xml : TXmlBuilder; elem : TFhirEpisodeOfCare);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirEpisodeOfCareStatusEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('statusHistory') then
    for i := 0 to elem.statusHistoryList.Count - 1 do
      ComposeEpisodeOfCareStatusHistory(xml, 'statusHistory', elem.statusHistoryList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', elem.type_List[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('condition') then
    for i := 0 to elem.conditionList.Count - 1 do
      ComposeReference{TFhirCondition}(xml, 'condition', elem.conditionList[i]);
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('managingOrganization') then
    ComposeReference{TFhirOrganization}(xml, 'managingOrganization', elem.managingOrganization);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('referralRequest') then
    for i := 0 to elem.referralRequestList.Count - 1 do
      ComposeReference{TFhirReferralRequest}(xml, 'referralRequest', elem.referralRequestList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('careManager') then
    ComposeReference{TFhirPractitioner}(xml, 'careManager', elem.careManager);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('careTeam') then
    for i := 0 to elem.careTeamList.Count - 1 do
      ComposeEpisodeOfCareCareTeam(xml, 'careTeam', elem.careTeamList[i]);
end;

{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
function TFHIRXmlParser.ParseExplanationOfBenefit(element : TMXmlElement; path : string) : TFhirExplanationOfBenefit;
var
  child : TMXmlElement;
begin
  result := TFhirExplanationOfBenefit.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseExplanationOfBenefitChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseExplanationOfBenefitChild(element : TFhirExplanationOfBenefit; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'request') then
        element.request := ParseReference{TFhirClaim}(child, path+'/request') {b}
      else if (child.localName = 'outcome') then
        element.outcomeElement := ParseEnum(CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum, path+'/outcome', child){1a}
      else if (child.localName = 'disposition') then
        element.dispositionElement := ParseString(child, path+'/disposition') {b}
      else if (child.localName = 'ruleset') then
        element.ruleset := ParseCoding(child, path+'/ruleset') {b}
      else if (child.localName = 'originalRuleset') then
        element.originalRuleset := ParseCoding(child, path+'/originalRuleset') {b}
      else if (child.localName = 'created') then
        element.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.localName = 'organization') then
        element.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.localName = 'requestProvider') then
        element.requestProvider := ParseReference{TFhirPractitioner}(child, path+'/requestProvider') {b}
      else if (child.localName = 'requestOrganization') then
        element.requestOrganization := ParseReference{TFhirOrganization}(child, path+'/requestOrganization') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefit(xml : TXmlBuilder; name : String; elem : TFhirExplanationOfBenefit);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeExplanationOfBenefitChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeExplanationOfBenefitChildren(xml : TXmlBuilder; elem : TFhirExplanationOfBenefit);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('request') then
    ComposeReference{TFhirClaim}(xml, 'request', elem.request);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcome') then
    ComposeEnum(xml, 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('disposition') then
    ComposeString(xml, 'disposition', elem.dispositionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ruleset') then
    ComposeCoding(xml, 'ruleset', elem.ruleset);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('originalRuleset') then
    ComposeCoding(xml, 'originalRuleset', elem.originalRuleset);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTime(xml, 'created', elem.createdElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestProvider') then
    ComposeReference{TFhirPractitioner}(xml, 'requestProvider', elem.requestProvider);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestOrganization') then
    ComposeReference{TFhirOrganization}(xml, 'requestOrganization', elem.requestOrganization);{x.2a}
end;

{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
function TFHIRXmlParser.ParseFamilyMemberHistoryCondition(element : TMXmlElement; path : string) : TFhirFamilyMemberHistoryCondition;
var
  child : TMXmlElement;
begin
  result := TFhirFamilyMemberHistoryCondition.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseFamilyMemberHistoryConditionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseFamilyMemberHistoryConditionChild(element : TFhirFamilyMemberHistoryCondition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'outcome') then
        element.outcome := ParseCodeableConcept(child, path+'/outcome') {b}
      else if (child.localName = 'onsetQuantity') then
        element.onset := ParseQuantity(child, path+'/onsetQuantity'){x.3}
      else if (child.localName = 'onsetRange') then
        element.onset := ParseRange(child, path+'/onsetRange'){x.3}
      else if (child.localName = 'onsetPeriod') then
        element.onset := ParsePeriod(child, path+'/onsetPeriod'){x.3}
      else if (child.localName = 'onsetString') then
        element.onset := ParseString(child, path+'/onsetString'){x.3}
      else if (child.localName = 'note') then
        element.note := ParseAnnotation(child, path+'/note') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeFamilyMemberHistoryCondition(xml : TXmlBuilder; name : String; elem : TFhirFamilyMemberHistoryCondition);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeFamilyMemberHistoryConditionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeFamilyMemberHistoryConditionChildren(xml : TXmlBuilder; elem : TFhirFamilyMemberHistoryCondition);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'outcome', elem.outcome);{x.2a}
  if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'onsetQuantity', TFhirQuantity(elem.onset))
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirRange) {6} then
    ComposeRange(xml, 'onsetRange', TFhirRange(elem.onset))
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirPeriod) {6} then
    ComposePeriod(xml, 'onsetPeriod', TFhirPeriod(elem.onset))
  else if (SummaryOption in [soFull, soData]) and (elem.onset is TFhirString) {6} then
    ComposeString(xml, 'onsetString', TFhirString(elem.onset));
  if (SummaryOption in [soFull, soData]) then
    ComposeAnnotation(xml, 'note', elem.note);{x.2a}
end;

function TFHIRXmlParser.ParseFamilyMemberHistory(element : TMXmlElement; path : string) : TFhirFamilyMemberHistory;
var
  child : TMXmlElement;
begin
  result := TFhirFamilyMemberHistory.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseFamilyMemberHistoryChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseFamilyMemberHistoryChild(element : TFhirFamilyMemberHistory; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirHistoryStatusEnum, SYSTEMS_TFhirHistoryStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'relationship') then
        element.relationship := ParseCodeableConcept(child, path+'/relationship') {b}
      else if (child.localName = 'gender') then
        element.genderElement := ParseEnum(CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, path+'/gender', child){1a}
      else if (child.localName = 'bornPeriod') then
        element.born := ParsePeriod(child, path+'/bornPeriod'){x.3}
      else if (child.localName = 'bornDate') then
        element.born := ParseDate(child, path+'/bornDate'){x.3}
      else if (child.localName = 'bornString') then
        element.born := ParseString(child, path+'/bornString'){x.3}
      else if (child.localName = 'ageQuantity') then
        element.age := ParseQuantity(child, path+'/ageQuantity'){x.3}
      else if (child.localName = 'ageRange') then
        element.age := ParseRange(child, path+'/ageRange'){x.3}
      else if (child.localName = 'ageString') then
        element.age := ParseString(child, path+'/ageString'){x.3}
      else if (child.localName = 'deceasedQuantity') then
        element.deceased := ParseQuantity(child, path+'/deceasedQuantity'){x.3}
      else if (child.localName = 'deceasedRange') then
        element.deceased := ParseRange(child, path+'/deceasedRange'){x.3}
      else if (child.localName = 'deceasedBoolean') then
        element.deceased := ParseBoolean(child, path+'/deceasedBoolean'){x.3}
      else if (child.localName = 'deceasedDate') then
        element.deceased := ParseDate(child, path+'/deceasedDate'){x.3}
      else if (child.localName = 'deceasedString') then
        element.deceased := ParseString(child, path+'/deceasedString'){x.3}
      else if (child.localName = 'note') then
        element.note := ParseAnnotation(child, path+'/note') {b}
      else if (child.localName = 'condition') then
        element.conditionList.Add(ParseFamilyMemberHistoryCondition(child, path+'/condition')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeFamilyMemberHistory(xml : TXmlBuilder; name : String; elem : TFhirFamilyMemberHistory);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeFamilyMemberHistoryChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeFamilyMemberHistoryChildren(xml : TXmlBuilder; elem : TFhirFamilyMemberHistory);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirHistoryStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  ComposeCodeableConcept(xml, 'relationship', elem.relationship);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gender') then
    ComposeEnum(xml, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum);
  if (SummaryOption in [soFull, soData]) and (elem.born is TFhirPeriod) {6} then
    ComposePeriod(xml, 'bornPeriod', TFhirPeriod(elem.born))
  else if (SummaryOption in [soFull, soData]) and (elem.born is TFhirDate) {6} then
    ComposeDate(xml, 'bornDate', TFhirDate(elem.born))
  else if (SummaryOption in [soFull, soData]) and (elem.born is TFhirString) {6} then
    ComposeString(xml, 'bornString', TFhirString(elem.born));
  if (SummaryOption in [soFull, soData]) and (elem.age is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'ageQuantity', TFhirQuantity(elem.age))
  else if (SummaryOption in [soFull, soData]) and (elem.age is TFhirRange) {6} then
    ComposeRange(xml, 'ageRange', TFhirRange(elem.age))
  else if (SummaryOption in [soFull, soData]) and (elem.age is TFhirString) {6} then
    ComposeString(xml, 'ageString', TFhirString(elem.age));
  if (SummaryOption in [soFull, soData]) and (elem.deceased is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'deceasedQuantity', TFhirQuantity(elem.deceased))
  else if (SummaryOption in [soFull, soData]) and (elem.deceased is TFhirRange) {6} then
    ComposeRange(xml, 'deceasedRange', TFhirRange(elem.deceased))
  else if (SummaryOption in [soFull, soData]) and (elem.deceased is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'deceasedBoolean', TFhirBoolean(elem.deceased))
  else if (SummaryOption in [soFull, soData]) and (elem.deceased is TFhirDate) {6} then
    ComposeDate(xml, 'deceasedDate', TFhirDate(elem.deceased))
  else if (SummaryOption in [soFull, soData]) and (elem.deceased is TFhirString) {6} then
    ComposeString(xml, 'deceasedString', TFhirString(elem.deceased));
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    ComposeAnnotation(xml, 'note', elem.note);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('condition') then
    for i := 0 to elem.conditionList.Count - 1 do
      ComposeFamilyMemberHistoryCondition(xml, 'condition', elem.conditionList[i]);
end;

{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
function TFHIRXmlParser.ParseFlag(element : TMXmlElement; path : string) : TFhirFlag;
var
  child : TMXmlElement;
begin
  result := TFhirFlag.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseFlagChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseFlagChild(element : TFhirFlag; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'category') then
        element.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirFlagStatusEnum, SYSTEMS_TFhirFlagStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'encounter') then
        element.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.localName = 'author') then
        element.author := ParseReference{Resource}(child, path+'/author') {b}
      else if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeFlag(xml : TXmlBuilder; name : String; elem : TFhirFlag);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeFlagChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeFlagChildren(xml : TXmlBuilder; elem : TFhirFlag);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeCodeableConcept(xml, 'category', elem.category);{x.2a}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirFlagStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
  ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{Resource}(xml, 'author', elem.author);{x.2a}
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
end;

{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
function TFHIRXmlParser.ParseGoalOutcome(element : TMXmlElement; path : string) : TFhirGoalOutcome;
var
  child : TMXmlElement;
begin
  result := TFhirGoalOutcome.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseGoalOutcomeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseGoalOutcomeChild(element : TFhirGoalOutcome; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'resultCodeableConcept') then
        element.result := ParseCodeableConcept(child, path+'/resultCodeableConcept'){x.3}
      else if (child.localName = 'resultReference') then
        element.result := ParseReference(child, path+'/resultReference') {a}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeGoalOutcome(xml : TXmlBuilder; name : String; elem : TFhirGoalOutcome);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeGoalOutcomeChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeGoalOutcomeChildren(xml : TXmlBuilder; elem : TFhirGoalOutcome);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and (elem.result is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'resultCodeableConcept', TFhirCodeableConcept(elem.result))
  else if (SummaryOption in [soFull, soData]) and (elem.result is TFhirReference) {2} then
    ComposeReference(xml, 'resultReference', TFhirReference(elem.result));
end;

function TFHIRXmlParser.ParseGoal(element : TMXmlElement; path : string) : TFhirGoal;
var
  child : TMXmlElement;
begin
  result := TFhirGoal.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseGoalChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseGoalChild(element : TFhirGoal; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'startCodeableConcept') then
        element.start := ParseCodeableConcept(child, path+'/startCodeableConcept'){x.3}
      else if (child.localName = 'startDate') then
        element.start := ParseDate(child, path+'/startDate'){x.3}
      else if (child.localName = 'targetQuantity') then
        element.target := ParseQuantity(child, path+'/targetQuantity'){x.3}
      else if (child.localName = 'targetDate') then
        element.target := ParseDate(child, path+'/targetDate'){x.3}
      else if (child.localName = 'category') then
        element.categoryList.Add(ParseCodeableConcept(child, path+'/category')){y.2}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirGoalStatusEnum, SYSTEMS_TFhirGoalStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'statusDate') then
        element.statusDateElement := ParseDate(child, path+'/statusDate') {b}
      else if (child.localName = 'statusReason') then
        element.statusReason := ParseCodeableConcept(child, path+'/statusReason') {b}
      else if (child.localName = 'author') then
        element.author := ParseReference{Resource}(child, path+'/author') {b}
      else if (child.localName = 'priority') then
        element.priority := ParseCodeableConcept(child, path+'/priority') {b}
      else if (child.localName = 'addresses') then
        element.addressesList.Add(ParseReference{Resource}(child, path+'/addresses')){y.2}
      else if (child.localName = 'note') then
        element.noteList.Add(ParseAnnotation(child, path+'/note')){y.2}
      else if (child.localName = 'outcome') then
        element.outcomeList.Add(ParseGoalOutcome(child, path+'/outcome')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeGoal(xml : TXmlBuilder; name : String; elem : TFhirGoal);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeGoalChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeGoalChildren(xml : TXmlBuilder; elem : TFhirGoal);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.start is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'startCodeableConcept', TFhirCodeableConcept(elem.start))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.start is TFhirDate) {6} then
    ComposeDate(xml, 'startDate', TFhirDate(elem.start));
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.target is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'targetQuantity', TFhirQuantity(elem.target))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.target is TFhirDate) {6} then
    ComposeDate(xml, 'targetDate', TFhirDate(elem.target));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', elem.categoryList[i]);
  ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirGoalStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('statusDate') then
    ComposeDate(xml, 'statusDate', elem.statusDateElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('statusReason') then
    ComposeCodeableConcept(xml, 'statusReason', elem.statusReason);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{Resource}(xml, 'author', elem.author);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeCodeableConcept(xml, 'priority', elem.priority);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('addresses') then
    for i := 0 to elem.addressesList.Count - 1 do
      ComposeReference{Resource}(xml, 'addresses', elem.addressesList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', elem.noteList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('outcome') then
    for i := 0 to elem.outcomeList.Count - 1 do
      ComposeGoalOutcome(xml, 'outcome', elem.outcomeList[i]);
end;

{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GROUP}
function TFHIRXmlParser.ParseGroupCharacteristic(element : TMXmlElement; path : string) : TFhirGroupCharacteristic;
var
  child : TMXmlElement;
begin
  result := TFhirGroupCharacteristic.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseGroupCharacteristicChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseGroupCharacteristicChild(element : TFhirGroupCharacteristic; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'valueCodeableConcept') then
        element.value := ParseCodeableConcept(child, path+'/valueCodeableConcept'){x.3}
      else if (child.localName = 'valueQuantity') then
        element.value := ParseQuantity(child, path+'/valueQuantity'){x.3}
      else if (child.localName = 'valueRange') then
        element.value := ParseRange(child, path+'/valueRange'){x.3}
      else if (child.localName = 'valueBoolean') then
        element.value := ParseBoolean(child, path+'/valueBoolean'){x.3}
      else if (child.localName = 'exclude') then
        element.excludeElement := ParseBoolean(child, path+'/exclude') {b}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeGroupCharacteristic(xml : TXmlBuilder; name : String; elem : TFhirGroupCharacteristic);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeGroupCharacteristicChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeGroupCharacteristicChildren(xml : TXmlBuilder; elem : TFhirGroupCharacteristic);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(elem.value))
  else if (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(elem.value))
  else if (elem.value is TFhirRange) {6} then
    ComposeRange(xml, 'valueRange', TFhirRange(elem.value))
  else if (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(elem.value));
  ComposeBoolean(xml, 'exclude', elem.excludeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
end;

function TFHIRXmlParser.ParseGroupMember(element : TMXmlElement; path : string) : TFhirGroupMember;
var
  child : TMXmlElement;
begin
  result := TFhirGroupMember.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseGroupMemberChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseGroupMemberChild(element : TFhirGroupMember; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'entity') then
        element.entity := ParseReference{Resource}(child, path+'/entity') {b}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if (child.localName = 'inactive') then
        element.inactiveElement := ParseBoolean(child, path+'/inactive') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeGroupMember(xml : TXmlBuilder; name : String; elem : TFhirGroupMember);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeGroupMemberChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeGroupMemberChildren(xml : TXmlBuilder; elem : TFhirGroupMember);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeReference{Resource}(xml, 'entity', elem.entity);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.inactive <> false)) then
    ComposeBoolean(xml, 'inactive', elem.inactiveElement);{x.2b}
end;

function TFHIRXmlParser.ParseGroup(element : TMXmlElement; path : string) : TFhirGroup;
var
  child : TMXmlElement;
begin
  result := TFhirGroup.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseGroupChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseGroupChild(element : TFhirGroup; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirGroupTypeEnum, SYSTEMS_TFhirGroupTypeEnum, path+'/type', child){1a}
      else if (child.localName = 'actual') then
        element.actualElement := ParseBoolean(child, path+'/actual') {b}
      else if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'quantity') then
        element.quantityElement := ParseUnsignedInt(child, path+'/quantity') {b}
      else if (child.localName = 'characteristic') then
        element.characteristicList.Add(ParseGroupCharacteristic(child, path+'/characteristic')){y.2}
      else if (child.localName = 'member') then
        element.memberList.Add(ParseGroupMember(child, path+'/member')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeGroup(xml : TXmlBuilder; name : String; elem : TFhirGroup);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeGroupChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeGroupChildren(xml : TXmlBuilder; elem : TFhirGroup);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirGroupTypeEnum);
  ComposeBoolean(xml, 'actual', elem.actualElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('quantity') then
    ComposeUnsignedInt(xml, 'quantity', elem.quantityElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('characteristic') then
    for i := 0 to elem.characteristicList.Count - 1 do
      ComposeGroupCharacteristic(xml, 'characteristic', elem.characteristicList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('member') then
    for i := 0 to elem.memberList.Count - 1 do
      ComposeGroupMember(xml, 'member', elem.memberList[i]);
end;

{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_HEALTHCARESERVICE}
function TFHIRXmlParser.ParseHealthcareServiceServiceType(element : TMXmlElement; path : string) : TFhirHealthcareServiceServiceType;
var
  child : TMXmlElement;
begin
  result := TFhirHealthcareServiceServiceType.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseHealthcareServiceServiceTypeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseHealthcareServiceServiceTypeChild(element : TFhirHealthcareServiceServiceType; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'specialty') then
        element.specialtyList.Add(ParseCodeableConcept(child, path+'/specialty')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeHealthcareServiceServiceType(xml : TXmlBuilder; name : String; elem : TFhirHealthcareServiceServiceType);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeHealthcareServiceServiceTypeChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeHealthcareServiceServiceTypeChildren(xml : TXmlBuilder; elem : TFhirHealthcareServiceServiceType);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.specialtyList.Count - 1 do
      ComposeCodeableConcept(xml, 'specialty', elem.specialtyList[i]);
end;

function TFHIRXmlParser.ParseHealthcareServiceAvailableTime(element : TMXmlElement; path : string) : TFhirHealthcareServiceAvailableTime;
var
  child : TMXmlElement;
begin
  result := TFhirHealthcareServiceAvailableTime.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseHealthcareServiceAvailableTimeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseHealthcareServiceAvailableTimeChild(element : TFhirHealthcareServiceAvailableTime; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'daysOfWeek') then
        element.daysOfWeekList.Add(ParseEnum(CODES_TFhirDaysOfWeekEnum, SYSTEMS_TFhirDaysOfWeekEnum, path+'/daysOfWeek', child)){y.1}
      else if (child.localName = 'allDay') then
        element.allDayElement := ParseBoolean(child, path+'/allDay') {b}
      else if (child.localName = 'availableStartTime') then
        element.availableStartTimeElement := ParseTime(child, path+'/availableStartTime') {b}
      else if (child.localName = 'availableEndTime') then
        element.availableEndTimeElement := ParseTime(child, path+'/availableEndTime') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeHealthcareServiceAvailableTime(xml : TXmlBuilder; name : String; elem : TFhirHealthcareServiceAvailableTime);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeHealthcareServiceAvailableTimeChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeHealthcareServiceAvailableTimeChildren(xml : TXmlBuilder; elem : TFhirHealthcareServiceAvailableTime);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.daysOfWeekList.Count - 1 do
      ComposeEnum(xml, 'daysOfWeek', elem.daysOfWeekList[i], CODES_TFhirDaysOfWeekEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'allDay', elem.allDayElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeTime(xml, 'availableStartTime', elem.availableStartTimeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeTime(xml, 'availableEndTime', elem.availableEndTimeElement);{x.2b}
end;

function TFHIRXmlParser.ParseHealthcareServiceNotAvailable(element : TMXmlElement; path : string) : TFhirHealthcareServiceNotAvailable;
var
  child : TMXmlElement;
begin
  result := TFhirHealthcareServiceNotAvailable.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseHealthcareServiceNotAvailableChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseHealthcareServiceNotAvailableChild(element : TFhirHealthcareServiceNotAvailable; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'during') then
        element.during := ParsePeriod(child, path+'/during') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeHealthcareServiceNotAvailable(xml : TXmlBuilder; name : String; elem : TFhirHealthcareServiceNotAvailable);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeHealthcareServiceNotAvailableChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeHealthcareServiceNotAvailableChildren(xml : TXmlBuilder; elem : TFhirHealthcareServiceNotAvailable);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'during', elem.during);{x.2a}
end;

function TFHIRXmlParser.ParseHealthcareService(element : TMXmlElement; path : string) : TFhirHealthcareService;
var
  child : TMXmlElement;
begin
  result := TFhirHealthcareService.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseHealthcareServiceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseHealthcareServiceChild(element : TFhirHealthcareService; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'providedBy') then
        element.providedBy := ParseReference{TFhirOrganization}(child, path+'/providedBy') {b}
      else if (child.localName = 'serviceCategory') then
        element.serviceCategory := ParseCodeableConcept(child, path+'/serviceCategory') {b}
      else if (child.localName = 'serviceType') then
        element.serviceTypeList.Add(ParseHealthcareServiceServiceType(child, path+'/serviceType')){y.2}
      else if (child.localName = 'location') then
        element.location := ParseReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.localName = 'serviceName') then
        element.serviceNameElement := ParseString(child, path+'/serviceName') {b}
      else if (child.localName = 'comment') then
        element.commentElement := ParseString(child, path+'/comment') {b}
      else if (child.localName = 'extraDetails') then
        element.extraDetailsElement := ParseString(child, path+'/extraDetails') {b}
      else if (child.localName = 'photo') then
        element.photo := ParseAttachment(child, path+'/photo') {b}
      else if (child.localName = 'telecom') then
        element.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.localName = 'coverageArea') then
        element.coverageAreaList.Add(ParseReference{TFhirLocation}(child, path+'/coverageArea')){y.2}
      else if (child.localName = 'serviceProvisionCode') then
        element.serviceProvisionCodeList.Add(ParseCodeableConcept(child, path+'/serviceProvisionCode')){y.2}
      else if (child.localName = 'eligibility') then
        element.eligibility := ParseCodeableConcept(child, path+'/eligibility') {b}
      else if (child.localName = 'eligibilityNote') then
        element.eligibilityNoteElement := ParseString(child, path+'/eligibilityNote') {b}
      else if (child.localName = 'programName') then
        element.programNameList.Add(ParseString(child, path+'/programName')){y.2}
      else if (child.localName = 'characteristic') then
        element.characteristicList.Add(ParseCodeableConcept(child, path+'/characteristic')){y.2}
      else if (child.localName = 'referralMethod') then
        element.referralMethodList.Add(ParseCodeableConcept(child, path+'/referralMethod')){y.2}
      else if (child.localName = 'publicKey') then
        element.publicKeyElement := ParseString(child, path+'/publicKey') {b}
      else if (child.localName = 'appointmentRequired') then
        element.appointmentRequiredElement := ParseBoolean(child, path+'/appointmentRequired') {b}
      else if (child.localName = 'availableTime') then
        element.availableTimeList.Add(ParseHealthcareServiceAvailableTime(child, path+'/availableTime')){y.2}
      else if (child.localName = 'notAvailable') then
        element.notAvailableList.Add(ParseHealthcareServiceNotAvailable(child, path+'/notAvailable')){y.2}
      else if (child.localName = 'availabilityExceptions') then
        element.availabilityExceptionsElement := ParseString(child, path+'/availabilityExceptions') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeHealthcareService(xml : TXmlBuilder; name : String; elem : TFhirHealthcareService);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeHealthcareServiceChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeHealthcareServiceChildren(xml : TXmlBuilder; elem : TFhirHealthcareService);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('providedBy') then
    ComposeReference{TFhirOrganization}(xml, 'providedBy', elem.providedBy);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('serviceCategory') then
    ComposeCodeableConcept(xml, 'serviceCategory', elem.serviceCategory);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('serviceType') then
    for i := 0 to elem.serviceTypeList.Count - 1 do
      ComposeHealthcareServiceServiceType(xml, 'serviceType', elem.serviceTypeList[i]);
  ComposeReference{TFhirLocation}(xml, 'location', elem.location);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('serviceName') then
    ComposeString(xml, 'serviceName', elem.serviceNameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('comment') then
    ComposeString(xml, 'comment', elem.commentElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('extraDetails') then
    ComposeString(xml, 'extraDetails', elem.extraDetailsElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('photo') then
    ComposeAttachment(xml, 'photo', elem.photo);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('telecom') then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('coverageArea') then
    for i := 0 to elem.coverageAreaList.Count - 1 do
      ComposeReference{TFhirLocation}(xml, 'coverageArea', elem.coverageAreaList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('serviceProvisionCode') then
    for i := 0 to elem.serviceProvisionCodeList.Count - 1 do
      ComposeCodeableConcept(xml, 'serviceProvisionCode', elem.serviceProvisionCodeList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('eligibility') then
    ComposeCodeableConcept(xml, 'eligibility', elem.eligibility);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('eligibilityNote') then
    ComposeString(xml, 'eligibilityNote', elem.eligibilityNoteElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('programName') then
    for i := 0 to elem.programNameList.Count - 1 do
      ComposeString(xml, 'programName', elem.programNameList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('characteristic') then
    for i := 0 to elem.characteristicList.Count - 1 do
      ComposeCodeableConcept(xml, 'characteristic', elem.characteristicList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('referralMethod') then
    for i := 0 to elem.referralMethodList.Count - 1 do
      ComposeCodeableConcept(xml, 'referralMethod', elem.referralMethodList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('publicKey') then
    ComposeString(xml, 'publicKey', elem.publicKeyElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('appointmentRequired') then
    ComposeBoolean(xml, 'appointmentRequired', elem.appointmentRequiredElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('availableTime') then
    for i := 0 to elem.availableTimeList.Count - 1 do
      ComposeHealthcareServiceAvailableTime(xml, 'availableTime', elem.availableTimeList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('notAvailable') then
    for i := 0 to elem.notAvailableList.Count - 1 do
      ComposeHealthcareServiceNotAvailable(xml, 'notAvailable', elem.notAvailableList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('availabilityExceptions') then
    ComposeString(xml, 'availabilityExceptions', elem.availabilityExceptionsElement);{x.2b}
end;

{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGOBJECTSELECTION}
function TFHIRXmlParser.ParseImagingObjectSelectionStudy(element : TMXmlElement; path : string) : TFhirImagingObjectSelectionStudy;
var
  child : TMXmlElement;
begin
  result := TFhirImagingObjectSelectionStudy.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImagingObjectSelectionStudyChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImagingObjectSelectionStudyChild(element : TFhirImagingObjectSelectionStudy; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'uid') then
        element.uidElement := ParseOid(child, path+'/uid') {b}
      else if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'imagingStudy') then
        element.imagingStudy := ParseReference{TFhirImagingStudy}(child, path+'/imagingStudy') {b}
      else if (child.localName = 'series') then
        element.seriesList.Add(ParseImagingObjectSelectionStudySeries(child, path+'/series')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImagingObjectSelectionStudy(xml : TXmlBuilder; name : String; elem : TFhirImagingObjectSelectionStudy);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImagingObjectSelectionStudyChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImagingObjectSelectionStudyChildren(xml : TXmlBuilder; elem : TFhirImagingObjectSelectionStudy);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeOid(xml, 'uid', elem.uidElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirImagingStudy}(xml, 'imagingStudy', elem.imagingStudy);{x.2a}
  for i := 0 to elem.seriesList.Count - 1 do
      ComposeImagingObjectSelectionStudySeries(xml, 'series', elem.seriesList[i]);
end;

function TFHIRXmlParser.ParseImagingObjectSelectionStudySeries(element : TMXmlElement; path : string) : TFhirImagingObjectSelectionStudySeries;
var
  child : TMXmlElement;
begin
  result := TFhirImagingObjectSelectionStudySeries.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImagingObjectSelectionStudySeriesChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImagingObjectSelectionStudySeriesChild(element : TFhirImagingObjectSelectionStudySeries; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'uid') then
        element.uidElement := ParseOid(child, path+'/uid') {b}
      else if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'instance') then
        element.instanceList.Add(ParseImagingObjectSelectionStudySeriesInstance(child, path+'/instance')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImagingObjectSelectionStudySeries(xml : TXmlBuilder; name : String; elem : TFhirImagingObjectSelectionStudySeries);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImagingObjectSelectionStudySeriesChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImagingObjectSelectionStudySeriesChildren(xml : TXmlBuilder; elem : TFhirImagingObjectSelectionStudySeries);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeOid(xml, 'uid', elem.uidElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  for i := 0 to elem.instanceList.Count - 1 do
      ComposeImagingObjectSelectionStudySeriesInstance(xml, 'instance', elem.instanceList[i]);
end;

function TFHIRXmlParser.ParseImagingObjectSelectionStudySeriesInstance(element : TMXmlElement; path : string) : TFhirImagingObjectSelectionStudySeriesInstance;
var
  child : TMXmlElement;
begin
  result := TFhirImagingObjectSelectionStudySeriesInstance.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImagingObjectSelectionStudySeriesInstanceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImagingObjectSelectionStudySeriesInstanceChild(element : TFhirImagingObjectSelectionStudySeriesInstance; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sopClass') then
        element.sopClassElement := ParseOid(child, path+'/sopClass') {b}
      else if (child.localName = 'uid') then
        element.uidElement := ParseOid(child, path+'/uid') {b}
      else if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'frames') then
        element.framesList.Add(ParseImagingObjectSelectionStudySeriesInstanceFrames(child, path+'/frames')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImagingObjectSelectionStudySeriesInstance(xml : TXmlBuilder; name : String; elem : TFhirImagingObjectSelectionStudySeriesInstance);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImagingObjectSelectionStudySeriesInstanceChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImagingObjectSelectionStudySeriesInstanceChildren(xml : TXmlBuilder; elem : TFhirImagingObjectSelectionStudySeriesInstance);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeOid(xml, 'sopClass', elem.sopClassElement);{x.2b}
  ComposeOid(xml, 'uid', elem.uidElement);{x.2b}
  ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.framesList.Count - 1 do
      ComposeImagingObjectSelectionStudySeriesInstanceFrames(xml, 'frames', elem.framesList[i]);
end;

function TFHIRXmlParser.ParseImagingObjectSelectionStudySeriesInstanceFrames(element : TMXmlElement; path : string) : TFhirImagingObjectSelectionStudySeriesInstanceFrames;
var
  child : TMXmlElement;
begin
  result := TFhirImagingObjectSelectionStudySeriesInstanceFrames.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImagingObjectSelectionStudySeriesInstanceFramesChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImagingObjectSelectionStudySeriesInstanceFramesChild(element : TFhirImagingObjectSelectionStudySeriesInstanceFrames; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'frameNumbers') then
        element.frameNumbersList.Add(ParseUnsignedInt(child, path+'/frameNumbers')){y.2}
      else if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImagingObjectSelectionStudySeriesInstanceFrames(xml : TXmlBuilder; name : String; elem : TFhirImagingObjectSelectionStudySeriesInstanceFrames);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImagingObjectSelectionStudySeriesInstanceFramesChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImagingObjectSelectionStudySeriesInstanceFramesChildren(xml : TXmlBuilder; elem : TFhirImagingObjectSelectionStudySeriesInstanceFrames);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.frameNumbersList.Count - 1 do
      ComposeUnsignedInt(xml, 'frameNumbers', elem.frameNumbersList[i]);
  ComposeUri(xml, 'url', elem.urlElement);{x.2b}
end;

function TFHIRXmlParser.ParseImagingObjectSelection(element : TMXmlElement; path : string) : TFhirImagingObjectSelection;
var
  child : TMXmlElement;
begin
  result := TFhirImagingObjectSelection.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImagingObjectSelectionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImagingObjectSelectionChild(element : TFhirImagingObjectSelection; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'uid') then
        element.uidElement := ParseOid(child, path+'/uid') {b}
      else if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'title') then
        element.title := ParseCodeableConcept(child, path+'/title') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'author') then
        element.author := ParseReference{Resource}(child, path+'/author') {b}
      else if (child.localName = 'authoringTime') then
        element.authoringTimeElement := ParseDateTime(child, path+'/authoringTime') {b}
      else if (child.localName = 'study') then
        element.studyList.Add(ParseImagingObjectSelectionStudy(child, path+'/study')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImagingObjectSelection(xml : TXmlBuilder; name : String; elem : TFhirImagingObjectSelection);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImagingObjectSelectionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImagingObjectSelectionChildren(xml : TXmlBuilder; elem : TFhirImagingObjectSelection);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  ComposeOid(xml, 'uid', elem.uidElement);{x.2b}
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  ComposeCodeableConcept(xml, 'title', elem.title);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{Resource}(xml, 'author', elem.author);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authoringTime') then
    ComposeDateTime(xml, 'authoringTime', elem.authoringTimeElement);{x.2b}
  for i := 0 to elem.studyList.Count - 1 do
      ComposeImagingObjectSelectionStudy(xml, 'study', elem.studyList[i]);
end;

{$ENDIF FHIR_IMAGINGOBJECTSELECTION}
{$IFDEF FHIR_IMAGINGSTUDY}
function TFHIRXmlParser.ParseImagingStudySeries(element : TMXmlElement; path : string) : TFhirImagingStudySeries;
var
  child : TMXmlElement;
begin
  result := TFhirImagingStudySeries.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImagingStudySeriesChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImagingStudySeriesChild(element : TFhirImagingStudySeries; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'number') then
        element.numberElement := ParseUnsignedInt(child, path+'/number') {b}
      else if (child.localName = 'modality') then
        element.modality := ParseCoding(child, path+'/modality') {b}
      else if (child.localName = 'uid') then
        element.uidElement := ParseOid(child, path+'/uid') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'numberOfInstances') then
        element.numberOfInstancesElement := ParseUnsignedInt(child, path+'/numberOfInstances') {b}
      else if (child.localName = 'availability') then
        element.availabilityElement := ParseEnum(CODES_TFhirInstanceAvailabilityEnum, SYSTEMS_TFhirInstanceAvailabilityEnum, path+'/availability', child){1a}
      else if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'bodySite') then
        element.bodySite := ParseCoding(child, path+'/bodySite') {b}
      else if (child.localName = 'laterality') then
        element.laterality := ParseCoding(child, path+'/laterality') {b}
      else if (child.localName = 'started') then
        element.startedElement := ParseDateTime(child, path+'/started') {b}
      else if (child.localName = 'instance') then
        element.instanceList.Add(ParseImagingStudySeriesInstance(child, path+'/instance')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImagingStudySeries(xml : TXmlBuilder; name : String; elem : TFhirImagingStudySeries);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImagingStudySeriesChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImagingStudySeriesChildren(xml : TXmlBuilder; elem : TFhirImagingStudySeries);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(xml, 'number', elem.numberElement);{x.2b}
  ComposeCoding(xml, 'modality', elem.modality);{x.2a}
  ComposeOid(xml, 'uid', elem.uidElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  ComposeUnsignedInt(xml, 'numberOfInstances', elem.numberOfInstancesElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'availability', elem.AvailabilityElement, CODES_TFhirInstanceAvailabilityEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'bodySite', elem.bodySite);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'laterality', elem.laterality);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'started', elem.startedElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.instanceList.Count - 1 do
      ComposeImagingStudySeriesInstance(xml, 'instance', elem.instanceList[i]);
end;

function TFHIRXmlParser.ParseImagingStudySeriesInstance(element : TMXmlElement; path : string) : TFhirImagingStudySeriesInstance;
var
  child : TMXmlElement;
begin
  result := TFhirImagingStudySeriesInstance.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImagingStudySeriesInstanceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImagingStudySeriesInstanceChild(element : TFhirImagingStudySeriesInstance; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'number') then
        element.numberElement := ParseUnsignedInt(child, path+'/number') {b}
      else if (child.localName = 'uid') then
        element.uidElement := ParseOid(child, path+'/uid') {b}
      else if (child.localName = 'sopClass') then
        element.sopClassElement := ParseOid(child, path+'/sopClass') {b}
      else if (child.localName = 'type') then
        element.type_Element := ParseString(child, path+'/type') {b}
      else if (child.localName = 'title') then
        element.titleElement := ParseString(child, path+'/title') {b}
      else if (child.localName = 'content') then
        element.contentList.Add(ParseAttachment(child, path+'/content')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImagingStudySeriesInstance(xml : TXmlBuilder; name : String; elem : TFhirImagingStudySeriesInstance);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImagingStudySeriesInstanceChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImagingStudySeriesInstanceChildren(xml : TXmlBuilder; elem : TFhirImagingStudySeriesInstance);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUnsignedInt(xml, 'number', elem.numberElement);{x.2b}
  ComposeOid(xml, 'uid', elem.uidElement);{x.2b}
  ComposeOid(xml, 'sopClass', elem.sopClassElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'type', elem.type_Element);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'title', elem.titleElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.contentList.Count - 1 do
      ComposeAttachment(xml, 'content', elem.contentList[i]);
end;

function TFHIRXmlParser.ParseImagingStudy(element : TMXmlElement; path : string) : TFhirImagingStudy;
var
  child : TMXmlElement;
begin
  result := TFhirImagingStudy.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImagingStudyChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImagingStudyChild(element : TFhirImagingStudy; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'started') then
        element.startedElement := ParseDateTime(child, path+'/started') {b}
      else if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'uid') then
        element.uidElement := ParseOid(child, path+'/uid') {b}
      else if (child.localName = 'accession') then
        element.accession := ParseIdentifier(child, path+'/accession') {b}
      else if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'order') then
        element.orderList.Add(ParseReference{TFhirDiagnosticOrder}(child, path+'/order')){y.2}
      else if (child.localName = 'modalityList') then
        element.modalityListList.Add(ParseCoding(child, path+'/modalityList')){y.2}
      else if (child.localName = 'referrer') then
        element.referrer := ParseReference{TFhirPractitioner}(child, path+'/referrer') {b}
      else if (child.localName = 'availability') then
        element.availabilityElement := ParseEnum(CODES_TFhirInstanceAvailabilityEnum, SYSTEMS_TFhirInstanceAvailabilityEnum, path+'/availability', child){1a}
      else if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'numberOfSeries') then
        element.numberOfSeriesElement := ParseUnsignedInt(child, path+'/numberOfSeries') {b}
      else if (child.localName = 'numberOfInstances') then
        element.numberOfInstancesElement := ParseUnsignedInt(child, path+'/numberOfInstances') {b}
      else if (child.localName = 'procedure') then
        element.procedure_List.Add(ParseReference{TFhirProcedure}(child, path+'/procedure')){y.2}
      else if (child.localName = 'interpreter') then
        element.interpreter := ParseReference{TFhirPractitioner}(child, path+'/interpreter') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'series') then
        element.seriesList.Add(ParseImagingStudySeries(child, path+'/series')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImagingStudy(xml : TXmlBuilder; name : String; elem : TFhirImagingStudy);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImagingStudyChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImagingStudyChildren(xml : TXmlBuilder; elem : TFhirImagingStudy);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('started') then
    ComposeDateTime(xml, 'started', elem.startedElement);{x.2b}
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  ComposeOid(xml, 'uid', elem.uidElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('accession') then
    ComposeIdentifier(xml, 'accession', elem.accession);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('order') then
    for i := 0 to elem.orderList.Count - 1 do
      ComposeReference{TFhirDiagnosticOrder}(xml, 'order', elem.orderList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('modalityList') then
    for i := 0 to elem.modalityListList.Count - 1 do
      ComposeCoding(xml, 'modalityList', elem.modalityListList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('referrer') then
    ComposeReference{TFhirPractitioner}(xml, 'referrer', elem.referrer);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('availability') then
    ComposeEnum(xml, 'availability', elem.AvailabilityElement, CODES_TFhirInstanceAvailabilityEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  ComposeUnsignedInt(xml, 'numberOfSeries', elem.numberOfSeriesElement);{x.2b}
  ComposeUnsignedInt(xml, 'numberOfInstances', elem.numberOfInstancesElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('procedure_') then
    for i := 0 to elem.procedure_List.Count - 1 do
      ComposeReference{TFhirProcedure}(xml, 'procedure', elem.procedure_List[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('interpreter') then
    ComposeReference{TFhirPractitioner}(xml, 'interpreter', elem.interpreter);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('series') then
    for i := 0 to elem.seriesList.Count - 1 do
      ComposeImagingStudySeries(xml, 'series', elem.seriesList[i]);
end;

{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
function TFHIRXmlParser.ParseImmunizationExplanation(element : TMXmlElement; path : string) : TFhirImmunizationExplanation;
var
  child : TMXmlElement;
begin
  result := TFhirImmunizationExplanation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImmunizationExplanationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImmunizationExplanationChild(element : TFhirImmunizationExplanation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'reason') then
        element.reasonList.Add(ParseCodeableConcept(child, path+'/reason')){y.2}
      else if (child.localName = 'reasonNotGiven') then
        element.reasonNotGivenList.Add(ParseCodeableConcept(child, path+'/reasonNotGiven')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImmunizationExplanation(xml : TXmlBuilder; name : String; elem : TFhirImmunizationExplanation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImmunizationExplanationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImmunizationExplanationChildren(xml : TXmlBuilder; elem : TFhirImmunizationExplanation);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(xml, 'reason', elem.reasonList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.reasonNotGivenList.Count - 1 do
      ComposeCodeableConcept(xml, 'reasonNotGiven', elem.reasonNotGivenList[i]);
end;

function TFHIRXmlParser.ParseImmunizationReaction(element : TMXmlElement; path : string) : TFhirImmunizationReaction;
var
  child : TMXmlElement;
begin
  result := TFhirImmunizationReaction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImmunizationReactionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImmunizationReactionChild(element : TFhirImmunizationReaction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'detail') then
        element.detail := ParseReference{TFhirObservation}(child, path+'/detail') {b}
      else if (child.localName = 'reported') then
        element.reportedElement := ParseBoolean(child, path+'/reported') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImmunizationReaction(xml : TXmlBuilder; name : String; elem : TFhirImmunizationReaction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImmunizationReactionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImmunizationReactionChildren(xml : TXmlBuilder; elem : TFhirImmunizationReaction);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirObservation}(xml, 'detail', elem.detail);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'reported', elem.reportedElement);{x.2b}
end;

function TFHIRXmlParser.ParseImmunizationVaccinationProtocol(element : TMXmlElement; path : string) : TFhirImmunizationVaccinationProtocol;
var
  child : TMXmlElement;
begin
  result := TFhirImmunizationVaccinationProtocol.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImmunizationVaccinationProtocolChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImmunizationVaccinationProtocolChild(element : TFhirImmunizationVaccinationProtocol; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'doseSequence') then
        element.doseSequenceElement := ParsePositiveInt(child, path+'/doseSequence') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'authority') then
        element.authority := ParseReference{TFhirOrganization}(child, path+'/authority') {b}
      else if (child.localName = 'series') then
        element.seriesElement := ParseString(child, path+'/series') {b}
      else if (child.localName = 'seriesDoses') then
        element.seriesDosesElement := ParsePositiveInt(child, path+'/seriesDoses') {b}
      else if (child.localName = 'targetDisease') then
        element.targetDiseaseList.Add(ParseCodeableConcept(child, path+'/targetDisease')){y.2}
      else if (child.localName = 'doseStatus') then
        element.doseStatus := ParseCodeableConcept(child, path+'/doseStatus') {b}
      else if (child.localName = 'doseStatusReason') then
        element.doseStatusReason := ParseCodeableConcept(child, path+'/doseStatusReason') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImmunizationVaccinationProtocol(xml : TXmlBuilder; name : String; elem : TFhirImmunizationVaccinationProtocol);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImmunizationVaccinationProtocolChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImmunizationVaccinationProtocolChildren(xml : TXmlBuilder; elem : TFhirImmunizationVaccinationProtocol);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposePositiveInt(xml, 'doseSequence', elem.doseSequenceElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'authority', elem.authority);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'series', elem.seriesElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposePositiveInt(xml, 'seriesDoses', elem.seriesDosesElement);{x.2b}
  for i := 0 to elem.targetDiseaseList.Count - 1 do
      ComposeCodeableConcept(xml, 'targetDisease', elem.targetDiseaseList[i]);
  ComposeCodeableConcept(xml, 'doseStatus', elem.doseStatus);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'doseStatusReason', elem.doseStatusReason);{x.2a}
end;

function TFHIRXmlParser.ParseImmunization(element : TMXmlElement; path : string) : TFhirImmunization;
var
  child : TMXmlElement;
begin
  result := TFhirImmunization.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImmunizationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImmunizationChild(element : TFhirImmunization; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirMedicationAdminStatusEnum, SYSTEMS_TFhirMedicationAdminStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'vaccineCode') then
        element.vaccineCode := ParseCodeableConcept(child, path+'/vaccineCode') {b}
      else if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'wasNotGiven') then
        element.wasNotGivenElement := ParseBoolean(child, path+'/wasNotGiven') {b}
      else if (child.localName = 'reported') then
        element.reportedElement := ParseBoolean(child, path+'/reported') {b}
      else if (child.localName = 'performer') then
        element.performer := ParseReference{TFhirPractitioner}(child, path+'/performer') {b}
      else if (child.localName = 'requester') then
        element.requester := ParseReference{TFhirPractitioner}(child, path+'/requester') {b}
      else if (child.localName = 'encounter') then
        element.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.localName = 'manufacturer') then
        element.manufacturer := ParseReference{TFhirOrganization}(child, path+'/manufacturer') {b}
      else if (child.localName = 'location') then
        element.location := ParseReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.localName = 'lotNumber') then
        element.lotNumberElement := ParseString(child, path+'/lotNumber') {b}
      else if (child.localName = 'expirationDate') then
        element.expirationDateElement := ParseDate(child, path+'/expirationDate') {b}
      else if (child.localName = 'site') then
        element.site := ParseCodeableConcept(child, path+'/site') {b}
      else if (child.localName = 'route') then
        element.route := ParseCodeableConcept(child, path+'/route') {b}
      else if (child.localName = 'doseQuantity') then
        element.doseQuantity := ParseQuantity(child, path+'/doseQuantity') {b}
      else if (child.localName = 'note') then
        element.noteList.Add(ParseAnnotation(child, path+'/note')){y.2}
      else if (child.localName = 'explanation') then
        element.explanation := ParseImmunizationExplanation(child, path+'/explanation') {b}
      else if (child.localName = 'reaction') then
        element.reactionList.Add(ParseImmunizationReaction(child, path+'/reaction')){y.2}
      else if (child.localName = 'vaccinationProtocol') then
        element.vaccinationProtocolList.Add(ParseImmunizationVaccinationProtocol(child, path+'/vaccinationProtocol')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImmunization(xml : TXmlBuilder; name : String; elem : TFhirImmunization);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImmunizationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImmunizationChildren(xml : TXmlBuilder; elem : TFhirImmunization);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirMedicationAdminStatusEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  ComposeCodeableConcept(xml, 'vaccineCode', elem.vaccineCode);{x.2a}
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  ComposeBoolean(xml, 'wasNotGiven', elem.wasNotGivenElement);{x.2b}
  ComposeBoolean(xml, 'reported', elem.reportedElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('performer') then
    ComposeReference{TFhirPractitioner}(xml, 'performer', elem.performer);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('requester') then
    ComposeReference{TFhirPractitioner}(xml, 'requester', elem.requester);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('manufacturer') then
    ComposeReference{TFhirOrganization}(xml, 'manufacturer', elem.manufacturer);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('location') then
    ComposeReference{TFhirLocation}(xml, 'location', elem.location);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('lotNumber') then
    ComposeString(xml, 'lotNumber', elem.lotNumberElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('expirationDate') then
    ComposeDate(xml, 'expirationDate', elem.expirationDateElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('site') then
    ComposeCodeableConcept(xml, 'site', elem.site);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('route') then
    ComposeCodeableConcept(xml, 'route', elem.route);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('doseQuantity') then
    ComposeQuantity(xml, 'doseQuantity', elem.doseQuantity);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposeAnnotation(xml, 'note', elem.noteList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('explanation') then
    ComposeImmunizationExplanation(xml, 'explanation', elem.explanation);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('reaction') then
    for i := 0 to elem.reactionList.Count - 1 do
      ComposeImmunizationReaction(xml, 'reaction', elem.reactionList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('vaccinationProtocol') then
    for i := 0 to elem.vaccinationProtocolList.Count - 1 do
      ComposeImmunizationVaccinationProtocol(xml, 'vaccinationProtocol', elem.vaccinationProtocolList[i]);
end;

{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
function TFHIRXmlParser.ParseImmunizationRecommendationRecommendation(element : TMXmlElement; path : string) : TFhirImmunizationRecommendationRecommendation;
var
  child : TMXmlElement;
begin
  result := TFhirImmunizationRecommendationRecommendation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImmunizationRecommendationRecommendationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImmunizationRecommendationRecommendationChild(element : TFhirImmunizationRecommendationRecommendation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'vaccineCode') then
        element.vaccineCode := ParseCodeableConcept(child, path+'/vaccineCode') {b}
      else if (child.localName = 'doseNumber') then
        element.doseNumberElement := ParsePositiveInt(child, path+'/doseNumber') {b}
      else if (child.localName = 'forecastStatus') then
        element.forecastStatus := ParseCodeableConcept(child, path+'/forecastStatus') {b}
      else if (child.localName = 'dateCriterion') then
        element.dateCriterionList.Add(ParseImmunizationRecommendationRecommendationDateCriterion(child, path+'/dateCriterion')){y.2}
      else if (child.localName = 'protocol') then
        element.protocol := ParseImmunizationRecommendationRecommendationProtocol(child, path+'/protocol') {b}
      else if (child.localName = 'supportingImmunization') then
        element.supportingImmunizationList.Add(ParseReference{TFhirImmunization}(child, path+'/supportingImmunization')){y.2}
      else if (child.localName = 'supportingPatientInformation') then
        element.supportingPatientInformationList.Add(ParseReference{Resource}(child, path+'/supportingPatientInformation')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImmunizationRecommendationRecommendation(xml : TXmlBuilder; name : String; elem : TFhirImmunizationRecommendationRecommendation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImmunizationRecommendationRecommendationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImmunizationRecommendationRecommendationChildren(xml : TXmlBuilder; elem : TFhirImmunizationRecommendationRecommendation);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  ComposeCodeableConcept(xml, 'vaccineCode', elem.vaccineCode);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(xml, 'doseNumber', elem.doseNumberElement);{x.2b}
  ComposeCodeableConcept(xml, 'forecastStatus', elem.forecastStatus);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.dateCriterionList.Count - 1 do
      ComposeImmunizationRecommendationRecommendationDateCriterion(xml, 'dateCriterion', elem.dateCriterionList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeImmunizationRecommendationRecommendationProtocol(xml, 'protocol', elem.protocol);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.supportingImmunizationList.Count - 1 do
      ComposeReference{TFhirImmunization}(xml, 'supportingImmunization', elem.supportingImmunizationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.supportingPatientInformationList.Count - 1 do
      ComposeReference{Resource}(xml, 'supportingPatientInformation', elem.supportingPatientInformationList[i]);
end;

function TFHIRXmlParser.ParseImmunizationRecommendationRecommendationDateCriterion(element : TMXmlElement; path : string) : TFhirImmunizationRecommendationRecommendationDateCriterion;
var
  child : TMXmlElement;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImmunizationRecommendationRecommendationDateCriterionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImmunizationRecommendationRecommendationDateCriterionChild(element : TFhirImmunizationRecommendationRecommendationDateCriterion; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'value') then
        element.valueElement := ParseDateTime(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImmunizationRecommendationRecommendationDateCriterion(xml : TXmlBuilder; name : String; elem : TFhirImmunizationRecommendationRecommendationDateCriterion);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImmunizationRecommendationRecommendationDateCriterionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImmunizationRecommendationRecommendationDateCriterionChildren(xml : TXmlBuilder; elem : TFhirImmunizationRecommendationRecommendationDateCriterion);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  ComposeDateTime(xml, 'value', elem.valueElement);{x.2b}
end;

function TFHIRXmlParser.ParseImmunizationRecommendationRecommendationProtocol(element : TMXmlElement; path : string) : TFhirImmunizationRecommendationRecommendationProtocol;
var
  child : TMXmlElement;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocol.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImmunizationRecommendationRecommendationProtocolChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImmunizationRecommendationRecommendationProtocolChild(element : TFhirImmunizationRecommendationRecommendationProtocol; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'doseSequence') then
        element.doseSequenceElement := ParseInteger(child, path+'/doseSequence') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'authority') then
        element.authority := ParseReference{TFhirOrganization}(child, path+'/authority') {b}
      else if (child.localName = 'series') then
        element.seriesElement := ParseString(child, path+'/series') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImmunizationRecommendationRecommendationProtocol(xml : TXmlBuilder; name : String; elem : TFhirImmunizationRecommendationRecommendationProtocol);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImmunizationRecommendationRecommendationProtocolChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImmunizationRecommendationRecommendationProtocolChildren(xml : TXmlBuilder; elem : TFhirImmunizationRecommendationRecommendationProtocol);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(xml, 'doseSequence', elem.doseSequenceElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'authority', elem.authority);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'series', elem.seriesElement);{x.2b}
end;

function TFHIRXmlParser.ParseImmunizationRecommendation(element : TMXmlElement; path : string) : TFhirImmunizationRecommendation;
var
  child : TMXmlElement;
begin
  result := TFhirImmunizationRecommendation.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImmunizationRecommendationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImmunizationRecommendationChild(element : TFhirImmunizationRecommendation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'recommendation') then
        element.recommendationList.Add(ParseImmunizationRecommendationRecommendation(child, path+'/recommendation')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImmunizationRecommendation(xml : TXmlBuilder; name : String; elem : TFhirImmunizationRecommendation);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImmunizationRecommendationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImmunizationRecommendationChildren(xml : TXmlBuilder; elem : TFhirImmunizationRecommendation);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  for i := 0 to elem.recommendationList.Count - 1 do
      ComposeImmunizationRecommendationRecommendation(xml, 'recommendation', elem.recommendationList[i]);
end;

{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
function TFHIRXmlParser.ParseImplementationGuideContact(element : TMXmlElement; path : string) : TFhirImplementationGuideContact;
var
  child : TMXmlElement;
begin
  result := TFhirImplementationGuideContact.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImplementationGuideContactChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImplementationGuideContactChild(element : TFhirImplementationGuideContact; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'telecom') then
        element.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuideContact(xml : TXmlBuilder; name : String; elem : TFhirImplementationGuideContact);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImplementationGuideContactChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuideContactChildren(xml : TXmlBuilder; elem : TFhirImplementationGuideContact);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
end;

function TFHIRXmlParser.ParseImplementationGuideDependency(element : TMXmlElement; path : string) : TFhirImplementationGuideDependency;
var
  child : TMXmlElement;
begin
  result := TFhirImplementationGuideDependency.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImplementationGuideDependencyChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImplementationGuideDependencyChild(element : TFhirImplementationGuideDependency; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirGuideDependencyTypeEnum, SYSTEMS_TFhirGuideDependencyTypeEnum, path+'/type', child){1a}
      else if (child.localName = 'uri') then
        element.uriElement := ParseUri(child, path+'/uri') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuideDependency(xml : TXmlBuilder; name : String; elem : TFhirImplementationGuideDependency);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImplementationGuideDependencyChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuideDependencyChildren(xml : TXmlBuilder; elem : TFhirImplementationGuideDependency);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirGuideDependencyTypeEnum);
  ComposeUri(xml, 'uri', elem.uriElement);{x.2b}
end;

function TFHIRXmlParser.ParseImplementationGuidePackage(element : TMXmlElement; path : string) : TFhirImplementationGuidePackage;
var
  child : TMXmlElement;
begin
  result := TFhirImplementationGuidePackage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImplementationGuidePackageChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImplementationGuidePackageChild(element : TFhirImplementationGuidePackage; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'resource') then
        element.resourceList.Add(ParseImplementationGuidePackageResource(child, path+'/resource')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuidePackage(xml : TXmlBuilder; name : String; elem : TFhirImplementationGuidePackage);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImplementationGuidePackageChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuidePackageChildren(xml : TXmlBuilder; elem : TFhirImplementationGuidePackage);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  for i := 0 to elem.resourceList.Count - 1 do
      ComposeImplementationGuidePackageResource(xml, 'resource', elem.resourceList[i]);
end;

function TFHIRXmlParser.ParseImplementationGuidePackageResource(element : TMXmlElement; path : string) : TFhirImplementationGuidePackageResource;
var
  child : TMXmlElement;
begin
  result := TFhirImplementationGuidePackageResource.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImplementationGuidePackageResourceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImplementationGuidePackageResourceChild(element : TFhirImplementationGuidePackageResource; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'purpose') then
        element.purposeElement := ParseEnum(CODES_TFhirGuideResourcePurposeEnum, SYSTEMS_TFhirGuideResourcePurposeEnum, path+'/purpose', child){1a}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'acronym') then
        element.acronymElement := ParseString(child, path+'/acronym') {b}
      else if (child.localName = 'sourceReference') then
        element.source := ParseReference(child, path+'/sourceReference') {a}
      else if (child.localName = 'sourceUri') then
        element.source := ParseUri(child, path+'/sourceUri'){x.3}
      else if (child.localName = 'exampleFor') then
        element.exampleFor := ParseReference{TFhirStructureDefinition}(child, path+'/exampleFor') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuidePackageResource(xml : TXmlBuilder; name : String; elem : TFhirImplementationGuidePackageResource);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImplementationGuidePackageResourceChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuidePackageResourceChildren(xml : TXmlBuilder; elem : TFhirImplementationGuidePackageResource);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'purpose', elem.PurposeElement, CODES_TFhirGuideResourcePurposeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'acronym', elem.acronymElement);{x.2b}
  if (elem.source is TFhirReference) {2} then
    ComposeReference(xml, 'sourceReference', TFhirReference(elem.source))
  else if (elem.source is TFhirUri) {6} then
    ComposeUri(xml, 'sourceUri', TFhirUri(elem.source));
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirStructureDefinition}(xml, 'exampleFor', elem.exampleFor);{x.2a}
end;

function TFHIRXmlParser.ParseImplementationGuideGlobal(element : TMXmlElement; path : string) : TFhirImplementationGuideGlobal;
var
  child : TMXmlElement;
begin
  result := TFhirImplementationGuideGlobal.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImplementationGuideGlobalChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImplementationGuideGlobalChild(element : TFhirImplementationGuideGlobal; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, path+'/type', child){1a}
      else if (child.localName = 'profile') then
        element.profile := ParseReference{TFhirStructureDefinition}(child, path+'/profile') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuideGlobal(xml : TXmlBuilder; name : String; elem : TFhirImplementationGuideGlobal);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImplementationGuideGlobalChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuideGlobalChildren(xml : TXmlBuilder; elem : TFhirImplementationGuideGlobal);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirResourceTypesEnum);
  ComposeReference{TFhirStructureDefinition}(xml, 'profile', elem.profile);{x.2a}
end;

function TFHIRXmlParser.ParseImplementationGuidePage(element : TMXmlElement; path : string) : TFhirImplementationGuidePage;
var
  child : TMXmlElement;
begin
  result := TFhirImplementationGuidePage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImplementationGuidePageChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImplementationGuidePageChild(element : TFhirImplementationGuidePage; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'source') then
        element.sourceElement := ParseUri(child, path+'/source') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'kind') then
        element.kindElement := ParseEnum(CODES_TFhirGuidePageKindEnum, SYSTEMS_TFhirGuidePageKindEnum, path+'/kind', child){1a}
      else if (child.localName = 'type') then
        element.type_.Add(ParseEnum(CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, path+'/type', child)){y.1}
      else if (child.localName = 'package') then
        element.packageList.Add(ParseString(child, path+'/package')){y.2}
      else if (child.localName = 'format') then
        element.formatElement := ParseCode(child, path+'/format') {b}
      else if (child.localName = 'page') then
        element.pageList.Add(ParseImplementationGuidePage(child, path+'/page')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuidePage(xml : TXmlBuilder; name : String; elem : TFhirImplementationGuidePage);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImplementationGuidePageChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuidePageChildren(xml : TXmlBuilder; elem : TFhirImplementationGuidePage);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeUri(xml, 'source', elem.sourceElement);{x.2b}
  ComposeString(xml, 'name', elem.nameElement);{x.2b}
  ComposeEnum(xml, 'kind', elem.KindElement, CODES_TFhirGuidePageKindEnum);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.type_.Count - 1 do
      ComposeEnum(xml, 'type', elem.type_[i], CODES_TFhirResourceTypesEnum);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.packageList.Count - 1 do
      ComposeString(xml, 'package', elem.packageList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'format', elem.formatElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.pageList.Count - 1 do
      ComposeImplementationGuidePage(xml, 'page', elem.pageList[i]);
end;

function TFHIRXmlParser.ParseImplementationGuide(element : TMXmlElement; path : string) : TFhirImplementationGuide;
var
  child : TMXmlElement;
begin
  result := TFhirImplementationGuide.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseImplementationGuideChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseImplementationGuideChild(element : TFhirImplementationGuide; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'experimental') then
        element.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.localName = 'publisher') then
        element.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.localName = 'contact') then
        element.contactList.Add(ParseImplementationGuideContact(child, path+'/contact')){y.2}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'useContext') then
        element.useContextList.Add(ParseCodeableConcept(child, path+'/useContext')){y.2}
      else if (child.localName = 'copyright') then
        element.copyrightElement := ParseString(child, path+'/copyright') {b}
      else if (child.localName = 'fhirVersion') then
        element.fhirVersionElement := ParseId(child, path+'/fhirVersion') {b}
      else if (child.localName = 'dependency') then
        element.dependencyList.Add(ParseImplementationGuideDependency(child, path+'/dependency')){y.2}
      else if (child.localName = 'package') then
        element.packageList.Add(ParseImplementationGuidePackage(child, path+'/package')){y.2}
      else if (child.localName = 'global') then
        element.globalList.Add(ParseImplementationGuideGlobal(child, path+'/global')){y.2}
      else if (child.localName = 'binary') then
        element.binaryList.Add(ParseUri(child, path+'/binary')){y.2}
      else if (child.localName = 'page') then
        element.page := ParseImplementationGuidePage(child, path+'/page') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuide(xml : TXmlBuilder; name : String; elem : TFhirImplementationGuide);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeImplementationGuideChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeImplementationGuideChildren(xml : TXmlBuilder; elem : TFhirImplementationGuide);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(xml, 'version', elem.versionElement);{x.2b}
  ComposeString(xml, 'name', elem.nameElement);{x.2b}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeImplementationGuideContact(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(xml, 'useContext', elem.useContextList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeString(xml, 'copyright', elem.copyrightElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('fhirVersion') then
    ComposeId(xml, 'fhirVersion', elem.fhirVersionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dependency') then
    for i := 0 to elem.dependencyList.Count - 1 do
      ComposeImplementationGuideDependency(xml, 'dependency', elem.dependencyList[i]);
  for i := 0 to elem.packageList.Count - 1 do
      ComposeImplementationGuidePackage(xml, 'package', elem.packageList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('global') then
    for i := 0 to elem.globalList.Count - 1 do
      ComposeImplementationGuideGlobal(xml, 'global', elem.globalList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('binary') then
    for i := 0 to elem.binaryList.Count - 1 do
      ComposeUri(xml, 'binary', elem.binaryList[i]);
  ComposeImplementationGuidePage(xml, 'page', elem.page);{x.2a}
end;

{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_LIST}
function TFHIRXmlParser.ParseListEntry(element : TMXmlElement; path : string) : TFhirListEntry;
var
  child : TMXmlElement;
begin
  result := TFhirListEntry.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseListEntryChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseListEntryChild(element : TFhirListEntry; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'flag') then
        element.flag := ParseCodeableConcept(child, path+'/flag') {b}
      else if (child.localName = 'deleted') then
        element.deletedElement := ParseBoolean(child, path+'/deleted') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'item') then
        element.item := ParseReference{TFhirReference}(child, path+'/item') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeListEntry(xml : TXmlBuilder; name : String; elem : TFhirListEntry);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeListEntryChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeListEntryChildren(xml : TXmlBuilder; elem : TFhirListEntry);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'flag', elem.flag);{x.2a}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.deleted <> false)) then
    ComposeBoolean(xml, 'deleted', elem.deletedElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  ComposeReference{TFhirReference}(xml, 'item', elem.item);{x.2a}
end;

function TFHIRXmlParser.ParseList(element : TMXmlElement; path : string) : TFhirList;
var
  child : TMXmlElement;
begin
  result := TFhirList.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseListChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseListChild(element : TFhirList; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'title') then
        element.titleElement := ParseString(child, path+'/title') {b}
      else if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'source') then
        element.source := ParseReference{Resource}(child, path+'/source') {b}
      else if (child.localName = 'encounter') then
        element.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirListStatusEnum, SYSTEMS_TFhirListStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'orderedBy') then
        element.orderedBy := ParseCodeableConcept(child, path+'/orderedBy') {b}
      else if (child.localName = 'mode') then
        element.modeElement := ParseEnum(CODES_TFhirListModeEnum, SYSTEMS_TFhirListModeEnum, path+'/mode', child){1a}
      else if (child.localName = 'note') then
        element.noteElement := ParseString(child, path+'/note') {b}
      else if (child.localName = 'entry') then
        element.entryList.Add(ParseListEntry(child, path+'/entry')){y.2}
      else if (child.localName = 'emptyReason') then
        element.emptyReason := ParseCodeableConcept(child, path+'/emptyReason') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeList(xml : TXmlBuilder; name : String; elem : TFhirList);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeListChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeListChildren(xml : TXmlBuilder; elem : TFhirList);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('title') then
    ComposeString(xml, 'title', elem.titleElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('source') then
    ComposeReference{Resource}(xml, 'source', elem.source);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2a}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirListStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('orderedBy') then
    ComposeCodeableConcept(xml, 'orderedBy', elem.orderedBy);{x.2a}
  ComposeEnum(xml, 'mode', elem.ModeElement, CODES_TFhirListModeEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('note') then
    ComposeString(xml, 'note', elem.noteElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('entry') then
    for i := 0 to elem.entryList.Count - 1 do
      ComposeListEntry(xml, 'entry', elem.entryList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('emptyReason') then
    ComposeCodeableConcept(xml, 'emptyReason', elem.emptyReason);{x.2a}
end;

{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
function TFHIRXmlParser.ParseLocationPosition(element : TMXmlElement; path : string) : TFhirLocationPosition;
var
  child : TMXmlElement;
begin
  result := TFhirLocationPosition.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseLocationPositionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseLocationPositionChild(element : TFhirLocationPosition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'longitude') then
        element.longitudeElement := ParseDecimal(child, path+'/longitude') {b}
      else if (child.localName = 'latitude') then
        element.latitudeElement := ParseDecimal(child, path+'/latitude') {b}
      else if (child.localName = 'altitude') then
        element.altitudeElement := ParseDecimal(child, path+'/altitude') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeLocationPosition(xml : TXmlBuilder; name : String; elem : TFhirLocationPosition);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeLocationPositionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeLocationPositionChildren(xml : TXmlBuilder; elem : TFhirLocationPosition);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeDecimal(xml, 'longitude', elem.longitudeElement);{x.2b}
  ComposeDecimal(xml, 'latitude', elem.latitudeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'altitude', elem.altitudeElement);{x.2b}
end;

function TFHIRXmlParser.ParseLocation(element : TMXmlElement; path : string) : TFhirLocation;
var
  child : TMXmlElement;
begin
  result := TFhirLocation.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseLocationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseLocationChild(element : TFhirLocation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirLocationStatusEnum, SYSTEMS_TFhirLocationStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'mode') then
        element.modeElement := ParseEnum(CODES_TFhirLocationModeEnum, SYSTEMS_TFhirLocationModeEnum, path+'/mode', child){1a}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'telecom') then
        element.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.localName = 'address') then
        element.address := ParseAddress(child, path+'/address') {b}
      else if (child.localName = 'physicalType') then
        element.physicalType := ParseCodeableConcept(child, path+'/physicalType') {b}
      else if (child.localName = 'position') then
        element.position := ParseLocationPosition(child, path+'/position') {b}
      else if (child.localName = 'managingOrganization') then
        element.managingOrganization := ParseReference{TFhirOrganization}(child, path+'/managingOrganization') {b}
      else if (child.localName = 'partOf') then
        element.partOf := ParseReference{TFhirLocation}(child, path+'/partOf') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeLocation(xml : TXmlBuilder; name : String; elem : TFhirLocation);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeLocationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeLocationChildren(xml : TXmlBuilder; elem : TFhirLocation);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirLocationStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('mode') then
    ComposeEnum(xml, 'mode', elem.ModeElement, CODES_TFhirLocationModeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('telecom') then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('address') then
    ComposeAddress(xml, 'address', elem.address);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('physicalType') then
    ComposeCodeableConcept(xml, 'physicalType', elem.physicalType);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('position') then
    ComposeLocationPosition(xml, 'position', elem.position);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('managingOrganization') then
    ComposeReference{TFhirOrganization}(xml, 'managingOrganization', elem.managingOrganization);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('partOf') then
    ComposeReference{TFhirLocation}(xml, 'partOf', elem.partOf);{x.2a}
end;

{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEDIA}
function TFHIRXmlParser.ParseMedia(element : TMXmlElement; path : string) : TFhirMedia;
var
  child : TMXmlElement;
begin
  result := TFhirMedia.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMediaChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMediaChild(element : TFhirMedia; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirDigitalMediaTypeEnum, SYSTEMS_TFhirDigitalMediaTypeEnum, path+'/type', child){1a}
      else if (child.localName = 'subtype') then
        element.subtype := ParseCodeableConcept(child, path+'/subtype') {b}
      else if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'operator') then
        element.operator := ParseReference{TFhirPractitioner}(child, path+'/operator') {b}
      else if (child.localName = 'view') then
        element.view := ParseCodeableConcept(child, path+'/view') {b}
      else if (child.localName = 'deviceName') then
        element.deviceNameElement := ParseString(child, path+'/deviceName') {b}
      else if (child.localName = 'height') then
        element.heightElement := ParsePositiveInt(child, path+'/height') {b}
      else if (child.localName = 'width') then
        element.widthElement := ParsePositiveInt(child, path+'/width') {b}
      else if (child.localName = 'frames') then
        element.framesElement := ParsePositiveInt(child, path+'/frames') {b}
      else if (child.localName = 'duration') then
        element.durationElement := ParseUnsignedInt(child, path+'/duration') {b}
      else if (child.localName = 'content') then
        element.content := ParseAttachment(child, path+'/content') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedia(xml : TXmlBuilder; name : String; elem : TFhirMedia);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMediaChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMediaChildren(xml : TXmlBuilder; elem : TFhirMedia);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirDigitalMediaTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subtype') then
    ComposeCodeableConcept(xml, 'subtype', elem.subtype);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('operator') then
    ComposeReference{TFhirPractitioner}(xml, 'operator', elem.operator);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('view') then
    ComposeCodeableConcept(xml, 'view', elem.view);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('deviceName') then
    ComposeString(xml, 'deviceName', elem.deviceNameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('height') then
    ComposePositiveInt(xml, 'height', elem.heightElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('width') then
    ComposePositiveInt(xml, 'width', elem.widthElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.frames <> '1')) and doCompose('frames') then
    ComposePositiveInt(xml, 'frames', elem.framesElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('duration') then
    ComposeUnsignedInt(xml, 'duration', elem.durationElement);{x.2b}
  ComposeAttachment(xml, 'content', elem.content);{x.2a}
end;

{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
function TFHIRXmlParser.ParseMedicationProduct(element : TMXmlElement; path : string) : TFhirMedicationProduct;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationProduct.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationProductChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationProductChild(element : TFhirMedicationProduct; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'form') then
        element.form := ParseCodeableConcept(child, path+'/form') {b}
      else if (child.localName = 'ingredient') then
        element.ingredientList.Add(ParseMedicationProductIngredient(child, path+'/ingredient')){y.2}
      else if (child.localName = 'batch') then
        element.batchList.Add(ParseMedicationProductBatch(child, path+'/batch')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationProduct(xml : TXmlBuilder; name : String; elem : TFhirMedicationProduct);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationProductChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationProductChildren(xml : TXmlBuilder; elem : TFhirMedicationProduct);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'form', elem.form);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.ingredientList.Count - 1 do
      ComposeMedicationProductIngredient(xml, 'ingredient', elem.ingredientList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.batchList.Count - 1 do
      ComposeMedicationProductBatch(xml, 'batch', elem.batchList[i]);
end;

function TFHIRXmlParser.ParseMedicationProductIngredient(element : TMXmlElement; path : string) : TFhirMedicationProductIngredient;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationProductIngredient.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationProductIngredientChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationProductIngredientChild(element : TFhirMedicationProductIngredient; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'item') then
        element.item := ParseReference{Resource}(child, path+'/item') {b}
      else if (child.localName = 'amount') then
        element.amount := ParseRatio(child, path+'/amount') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationProductIngredient(xml : TXmlBuilder; name : String; elem : TFhirMedicationProductIngredient);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationProductIngredientChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationProductIngredientChildren(xml : TXmlBuilder; elem : TFhirMedicationProductIngredient);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeReference{Resource}(xml, 'item', elem.item);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeRatio(xml, 'amount', elem.amount);{x.2a}
end;

function TFHIRXmlParser.ParseMedicationProductBatch(element : TMXmlElement; path : string) : TFhirMedicationProductBatch;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationProductBatch.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationProductBatchChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationProductBatchChild(element : TFhirMedicationProductBatch; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'lotNumber') then
        element.lotNumberElement := ParseString(child, path+'/lotNumber') {b}
      else if (child.localName = 'expirationDate') then
        element.expirationDateElement := ParseDateTime(child, path+'/expirationDate') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationProductBatch(xml : TXmlBuilder; name : String; elem : TFhirMedicationProductBatch);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationProductBatchChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationProductBatchChildren(xml : TXmlBuilder; elem : TFhirMedicationProductBatch);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'lotNumber', elem.lotNumberElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeDateTime(xml, 'expirationDate', elem.expirationDateElement);{x.2b}
end;

function TFHIRXmlParser.ParseMedicationPackage(element : TMXmlElement; path : string) : TFhirMedicationPackage;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationPackage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationPackageChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationPackageChild(element : TFhirMedicationPackage; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'container') then
        element.container := ParseCodeableConcept(child, path+'/container') {b}
      else if (child.localName = 'content') then
        element.contentList.Add(ParseMedicationPackageContent(child, path+'/content')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationPackage(xml : TXmlBuilder; name : String; elem : TFhirMedicationPackage);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationPackageChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationPackageChildren(xml : TXmlBuilder; elem : TFhirMedicationPackage);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'container', elem.container);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.contentList.Count - 1 do
      ComposeMedicationPackageContent(xml, 'content', elem.contentList[i]);
end;

function TFHIRXmlParser.ParseMedicationPackageContent(element : TMXmlElement; path : string) : TFhirMedicationPackageContent;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationPackageContent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationPackageContentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationPackageContentChild(element : TFhirMedicationPackageContent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'item') then
        element.item := ParseReference{TFhirMedication}(child, path+'/item') {b}
      else if (child.localName = 'amount') then
        element.amount := ParseQuantity(child, path+'/amount') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationPackageContent(xml : TXmlBuilder; name : String; elem : TFhirMedicationPackageContent);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationPackageContentChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationPackageContentChildren(xml : TXmlBuilder; elem : TFhirMedicationPackageContent);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeReference{TFhirMedication}(xml, 'item', elem.item);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'amount', elem.amount);{x.2a}
end;

function TFHIRXmlParser.ParseMedication(element : TMXmlElement; path : string) : TFhirMedication;
var
  child : TMXmlElement;
begin
  result := TFhirMedication.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationChild(element : TFhirMedication; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'isBrand') then
        element.isBrandElement := ParseBoolean(child, path+'/isBrand') {b}
      else if (child.localName = 'manufacturer') then
        element.manufacturer := ParseReference{TFhirOrganization}(child, path+'/manufacturer') {b}
      else if (child.localName = 'product') then
        element.product := ParseMedicationProduct(child, path+'/product') {b}
      else if (child.localName = 'package') then
        element.package := ParseMedicationPackage(child, path+'/package') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedication(xml : TXmlBuilder; name : String; elem : TFhirMedication);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationChildren(xml : TXmlBuilder; elem : TFhirMedication);
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('isBrand') then
    ComposeBoolean(xml, 'isBrand', elem.isBrandElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('manufacturer') then
    ComposeReference{TFhirOrganization}(xml, 'manufacturer', elem.manufacturer);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('product') then
    ComposeMedicationProduct(xml, 'product', elem.product);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('package') then
    ComposeMedicationPackage(xml, 'package', elem.package);{x.2a}
end;

{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
function TFHIRXmlParser.ParseMedicationAdministrationDosage(element : TMXmlElement; path : string) : TFhirMedicationAdministrationDosage;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationAdministrationDosage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationAdministrationDosageChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationAdministrationDosageChild(element : TFhirMedicationAdministrationDosage; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'text') then
        element.textElement := ParseString(child, path+'/text') {b}
      else if (child.localName = 'siteCodeableConcept') then
        element.site := ParseCodeableConcept(child, path+'/siteCodeableConcept'){x.3}
      else if (child.localName = 'siteReference') then
        element.site := ParseReference(child, path+'/siteReference') {a}
      else if (child.localName = 'route') then
        element.route := ParseCodeableConcept(child, path+'/route') {b}
      else if (child.localName = 'method') then
        element.method := ParseCodeableConcept(child, path+'/method') {b}
      else if (child.localName = 'quantity') then
        element.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.localName = 'rateRatio') then
        element.rate := ParseRatio(child, path+'/rateRatio'){x.3}
      else if (child.localName = 'rateRange') then
        element.rate := ParseRange(child, path+'/rateRange'){x.3}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationAdministrationDosage(xml : TXmlBuilder; name : String; elem : TFhirMedicationAdministrationDosage);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationAdministrationDosageChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationAdministrationDosageChildren(xml : TXmlBuilder; elem : TFhirMedicationAdministrationDosage);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'siteCodeableConcept', TFhirCodeableConcept(elem.site))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirReference) {2} then
    ComposeReference(xml, 'siteReference', TFhirReference(elem.site));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'route', elem.route);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'method', elem.method);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRatio) {6} then
    ComposeRatio(xml, 'rateRatio', TFhirRatio(elem.rate))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRange) {6} then
    ComposeRange(xml, 'rateRange', TFhirRange(elem.rate));
end;

function TFHIRXmlParser.ParseMedicationAdministration(element : TMXmlElement; path : string) : TFhirMedicationAdministration;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationAdministration.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationAdministrationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationAdministrationChild(element : TFhirMedicationAdministration; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirMedicationAdminStatusEnum, SYSTEMS_TFhirMedicationAdminStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'practitioner') then
        element.practitioner := ParseReference{Resource}(child, path+'/practitioner') {b}
      else if (child.localName = 'encounter') then
        element.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.localName = 'prescription') then
        element.prescription := ParseReference{TFhirMedicationOrder}(child, path+'/prescription') {b}
      else if (child.localName = 'wasNotGiven') then
        element.wasNotGivenElement := ParseBoolean(child, path+'/wasNotGiven') {b}
      else if (child.localName = 'reasonNotGiven') then
        element.reasonNotGivenList.Add(ParseCodeableConcept(child, path+'/reasonNotGiven')){y.2}
      else if (child.localName = 'reasonGiven') then
        element.reasonGivenList.Add(ParseCodeableConcept(child, path+'/reasonGiven')){y.2}
      else if (child.localName = 'effectiveTimePeriod') then
        element.effectiveTime := ParsePeriod(child, path+'/effectiveTimePeriod'){x.3}
      else if (child.localName = 'effectiveTimeDateTime') then
        element.effectiveTime := ParseDateTime(child, path+'/effectiveTimeDateTime'){x.3}
      else if (child.localName = 'medicationCodeableConcept') then
        element.medication := ParseCodeableConcept(child, path+'/medicationCodeableConcept'){x.3}
      else if (child.localName = 'medicationReference') then
        element.medication := ParseReference(child, path+'/medicationReference') {a}
      else if (child.localName = 'device') then
        element.deviceList.Add(ParseReference{TFhirDevice}(child, path+'/device')){y.2}
      else if (child.localName = 'note') then
        element.noteElement := ParseString(child, path+'/note') {b}
      else if (child.localName = 'dosage') then
        element.dosage := ParseMedicationAdministrationDosage(child, path+'/dosage') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationAdministration(xml : TXmlBuilder; name : String; elem : TFhirMedicationAdministration);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationAdministrationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationAdministrationChildren(xml : TXmlBuilder; elem : TFhirMedicationAdministration);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirMedicationAdminStatusEnum);
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('practitioner') then
    ComposeReference{Resource}(xml, 'practitioner', elem.practitioner);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('prescription') then
    ComposeReference{TFhirMedicationOrder}(xml, 'prescription', elem.prescription);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('wasNotGiven') then
    ComposeBoolean(xml, 'wasNotGiven', elem.wasNotGivenElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonNotGiven') then
    for i := 0 to elem.reasonNotGivenList.Count - 1 do
      ComposeCodeableConcept(xml, 'reasonNotGiven', elem.reasonNotGivenList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonGiven') then
    for i := 0 to elem.reasonGivenList.Count - 1 do
      ComposeCodeableConcept(xml, 'reasonGiven', elem.reasonGivenList[i]);
  if (elem.effectiveTime is TFhirPeriod) {6} then
    ComposePeriod(xml, 'effectiveTimePeriod', TFhirPeriod(elem.effectiveTime))
  else if (elem.effectiveTime is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'effectiveTimeDateTime', TFhirDateTime(elem.effectiveTime));
  if (elem.medication is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication))
  else if (elem.medication is TFhirReference) {2} then
    ComposeReference(xml, 'medicationReference', TFhirReference(elem.medication));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('device') then
    for i := 0 to elem.deviceList.Count - 1 do
      ComposeReference{TFhirDevice}(xml, 'device', elem.deviceList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('note') then
    ComposeString(xml, 'note', elem.noteElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dosage') then
    ComposeMedicationAdministrationDosage(xml, 'dosage', elem.dosage);{x.2a}
end;

{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
function TFHIRXmlParser.ParseMedicationDispenseDosageInstruction(element : TMXmlElement; path : string) : TFhirMedicationDispenseDosageInstruction;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationDispenseDosageInstruction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationDispenseDosageInstructionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationDispenseDosageInstructionChild(element : TFhirMedicationDispenseDosageInstruction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'text') then
        element.textElement := ParseString(child, path+'/text') {b}
      else if (child.localName = 'additionalInstructions') then
        element.additionalInstructions := ParseCodeableConcept(child, path+'/additionalInstructions') {b}
      else if (child.localName = 'timing') then
        element.timing := ParseTiming(child, path+'/timing') {b}
      else if (child.localName = 'asNeededCodeableConcept') then
        element.asNeeded := ParseCodeableConcept(child, path+'/asNeededCodeableConcept'){x.3}
      else if (child.localName = 'asNeededBoolean') then
        element.asNeeded := ParseBoolean(child, path+'/asNeededBoolean'){x.3}
      else if (child.localName = 'siteCodeableConcept') then
        element.site := ParseCodeableConcept(child, path+'/siteCodeableConcept'){x.3}
      else if (child.localName = 'siteReference') then
        element.site := ParseReference(child, path+'/siteReference') {a}
      else if (child.localName = 'route') then
        element.route := ParseCodeableConcept(child, path+'/route') {b}
      else if (child.localName = 'method') then
        element.method := ParseCodeableConcept(child, path+'/method') {b}
      else if (child.localName = 'doseRange') then
        element.dose := ParseRange(child, path+'/doseRange'){x.3}
      else if (child.localName = 'doseQuantity') then
        element.dose := ParseQuantity(child, path+'/doseQuantity'){x.3}
      else if (child.localName = 'rateRatio') then
        element.rate := ParseRatio(child, path+'/rateRatio'){x.3}
      else if (child.localName = 'rateRange') then
        element.rate := ParseRange(child, path+'/rateRange'){x.3}
      else if (child.localName = 'maxDosePerPeriod') then
        element.maxDosePerPeriod := ParseRatio(child, path+'/maxDosePerPeriod') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationDispenseDosageInstruction(xml : TXmlBuilder; name : String; elem : TFhirMedicationDispenseDosageInstruction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationDispenseDosageInstructionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationDispenseDosageInstructionChildren(xml : TXmlBuilder; elem : TFhirMedicationDispenseDosageInstruction);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'additionalInstructions', elem.additionalInstructions);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTiming(xml, 'timing', elem.timing);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'asNeededBoolean', TFhirBoolean(elem.asNeeded));
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'siteCodeableConcept', TFhirCodeableConcept(elem.site))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirReference) {2} then
    ComposeReference(xml, 'siteReference', TFhirReference(elem.site));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'route', elem.route);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'method', elem.method);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.dose is TFhirRange) {6} then
    ComposeRange(xml, 'doseRange', TFhirRange(elem.dose))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.dose is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'doseQuantity', TFhirQuantity(elem.dose));
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRatio) {6} then
    ComposeRatio(xml, 'rateRatio', TFhirRatio(elem.rate))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRange) {6} then
    ComposeRange(xml, 'rateRange', TFhirRange(elem.rate));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(xml, 'maxDosePerPeriod', elem.maxDosePerPeriod);{x.2a}
end;

function TFHIRXmlParser.ParseMedicationDispenseSubstitution(element : TMXmlElement; path : string) : TFhirMedicationDispenseSubstitution;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationDispenseSubstitution.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationDispenseSubstitutionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationDispenseSubstitutionChild(element : TFhirMedicationDispenseSubstitution; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'reason') then
        element.reasonList.Add(ParseCodeableConcept(child, path+'/reason')){y.2}
      else if (child.localName = 'responsibleParty') then
        element.responsiblePartyList.Add(ParseReference{TFhirPractitioner}(child, path+'/responsibleParty')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationDispenseSubstitution(xml : TXmlBuilder; name : String; elem : TFhirMedicationDispenseSubstitution);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationDispenseSubstitutionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationDispenseSubstitutionChildren(xml : TXmlBuilder; elem : TFhirMedicationDispenseSubstitution);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(xml, 'reason', elem.reasonList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.responsiblePartyList.Count - 1 do
      ComposeReference{TFhirPractitioner}(xml, 'responsibleParty', elem.responsiblePartyList[i]);
end;

function TFHIRXmlParser.ParseMedicationDispense(element : TMXmlElement; path : string) : TFhirMedicationDispense;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationDispense.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationDispenseChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationDispenseChild(element : TFhirMedicationDispense; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirMedicationDispenseStatusEnum, SYSTEMS_TFhirMedicationDispenseStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'dispenser') then
        element.dispenser := ParseReference{TFhirPractitioner}(child, path+'/dispenser') {b}
      else if (child.localName = 'authorizingPrescription') then
        element.authorizingPrescriptionList.Add(ParseReference{TFhirMedicationOrder}(child, path+'/authorizingPrescription')){y.2}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'quantity') then
        element.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.localName = 'daysSupply') then
        element.daysSupply := ParseQuantity(child, path+'/daysSupply') {b}
      else if (child.localName = 'medicationCodeableConcept') then
        element.medication := ParseCodeableConcept(child, path+'/medicationCodeableConcept'){x.3}
      else if (child.localName = 'medicationReference') then
        element.medication := ParseReference(child, path+'/medicationReference') {a}
      else if (child.localName = 'whenPrepared') then
        element.whenPreparedElement := ParseDateTime(child, path+'/whenPrepared') {b}
      else if (child.localName = 'whenHandedOver') then
        element.whenHandedOverElement := ParseDateTime(child, path+'/whenHandedOver') {b}
      else if (child.localName = 'destination') then
        element.destination := ParseReference{TFhirLocation}(child, path+'/destination') {b}
      else if (child.localName = 'receiver') then
        element.receiverList.Add(ParseReference{Resource}(child, path+'/receiver')){y.2}
      else if (child.localName = 'note') then
        element.noteElement := ParseString(child, path+'/note') {b}
      else if (child.localName = 'dosageInstruction') then
        element.dosageInstructionList.Add(ParseMedicationDispenseDosageInstruction(child, path+'/dosageInstruction')){y.2}
      else if (child.localName = 'substitution') then
        element.substitution := ParseMedicationDispenseSubstitution(child, path+'/substitution') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationDispense(xml : TXmlBuilder; name : String; elem : TFhirMedicationDispense);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationDispenseChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationDispenseChildren(xml : TXmlBuilder; elem : TFhirMedicationDispense);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirMedicationDispenseStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dispenser') then
    ComposeReference{TFhirPractitioner}(xml, 'dispenser', elem.dispenser);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authorizingPrescription') then
    for i := 0 to elem.authorizingPrescriptionList.Count - 1 do
      ComposeReference{TFhirMedicationOrder}(xml, 'authorizingPrescription', elem.authorizingPrescriptionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('quantity') then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('daysSupply') then
    ComposeQuantity(xml, 'daysSupply', elem.daysSupply);{x.2a}
  if (elem.medication is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication))
  else if (elem.medication is TFhirReference) {2} then
    ComposeReference(xml, 'medicationReference', TFhirReference(elem.medication));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('whenPrepared') then
    ComposeDateTime(xml, 'whenPrepared', elem.whenPreparedElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('whenHandedOver') then
    ComposeDateTime(xml, 'whenHandedOver', elem.whenHandedOverElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('destination') then
    ComposeReference{TFhirLocation}(xml, 'destination', elem.destination);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('receiver') then
    for i := 0 to elem.receiverList.Count - 1 do
      ComposeReference{Resource}(xml, 'receiver', elem.receiverList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('note') then
    ComposeString(xml, 'note', elem.noteElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dosageInstruction') then
    for i := 0 to elem.dosageInstructionList.Count - 1 do
      ComposeMedicationDispenseDosageInstruction(xml, 'dosageInstruction', elem.dosageInstructionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('substitution') then
    ComposeMedicationDispenseSubstitution(xml, 'substitution', elem.substitution);{x.2a}
end;

{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONORDER}
function TFHIRXmlParser.ParseMedicationOrderDosageInstruction(element : TMXmlElement; path : string) : TFhirMedicationOrderDosageInstruction;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationOrderDosageInstruction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationOrderDosageInstructionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationOrderDosageInstructionChild(element : TFhirMedicationOrderDosageInstruction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'text') then
        element.textElement := ParseString(child, path+'/text') {b}
      else if (child.localName = 'additionalInstructions') then
        element.additionalInstructions := ParseCodeableConcept(child, path+'/additionalInstructions') {b}
      else if (child.localName = 'timing') then
        element.timing := ParseTiming(child, path+'/timing') {b}
      else if (child.localName = 'asNeededCodeableConcept') then
        element.asNeeded := ParseCodeableConcept(child, path+'/asNeededCodeableConcept'){x.3}
      else if (child.localName = 'asNeededBoolean') then
        element.asNeeded := ParseBoolean(child, path+'/asNeededBoolean'){x.3}
      else if (child.localName = 'siteCodeableConcept') then
        element.site := ParseCodeableConcept(child, path+'/siteCodeableConcept'){x.3}
      else if (child.localName = 'siteReference') then
        element.site := ParseReference(child, path+'/siteReference') {a}
      else if (child.localName = 'route') then
        element.route := ParseCodeableConcept(child, path+'/route') {b}
      else if (child.localName = 'method') then
        element.method := ParseCodeableConcept(child, path+'/method') {b}
      else if (child.localName = 'doseRange') then
        element.dose := ParseRange(child, path+'/doseRange'){x.3}
      else if (child.localName = 'doseQuantity') then
        element.dose := ParseQuantity(child, path+'/doseQuantity'){x.3}
      else if (child.localName = 'rateRatio') then
        element.rate := ParseRatio(child, path+'/rateRatio'){x.3}
      else if (child.localName = 'rateRange') then
        element.rate := ParseRange(child, path+'/rateRange'){x.3}
      else if (child.localName = 'maxDosePerPeriod') then
        element.maxDosePerPeriod := ParseRatio(child, path+'/maxDosePerPeriod') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationOrderDosageInstruction(xml : TXmlBuilder; name : String; elem : TFhirMedicationOrderDosageInstruction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationOrderDosageInstructionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationOrderDosageInstructionChildren(xml : TXmlBuilder; elem : TFhirMedicationOrderDosageInstruction);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'additionalInstructions', elem.additionalInstructions);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTiming(xml, 'timing', elem.timing);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'asNeededBoolean', TFhirBoolean(elem.asNeeded));
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'siteCodeableConcept', TFhirCodeableConcept(elem.site))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirReference) {2} then
    ComposeReference(xml, 'siteReference', TFhirReference(elem.site));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'route', elem.route);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'method', elem.method);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.dose is TFhirRange) {6} then
    ComposeRange(xml, 'doseRange', TFhirRange(elem.dose))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.dose is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'doseQuantity', TFhirQuantity(elem.dose));
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRatio) {6} then
    ComposeRatio(xml, 'rateRatio', TFhirRatio(elem.rate))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRange) {6} then
    ComposeRange(xml, 'rateRange', TFhirRange(elem.rate));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(xml, 'maxDosePerPeriod', elem.maxDosePerPeriod);{x.2a}
end;

function TFHIRXmlParser.ParseMedicationOrderDispenseRequest(element : TMXmlElement; path : string) : TFhirMedicationOrderDispenseRequest;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationOrderDispenseRequest.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationOrderDispenseRequestChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationOrderDispenseRequestChild(element : TFhirMedicationOrderDispenseRequest; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'medicationCodeableConcept') then
        element.medication := ParseCodeableConcept(child, path+'/medicationCodeableConcept'){x.3}
      else if (child.localName = 'medicationReference') then
        element.medication := ParseReference(child, path+'/medicationReference') {a}
      else if (child.localName = 'validityPeriod') then
        element.validityPeriod := ParsePeriod(child, path+'/validityPeriod') {b}
      else if (child.localName = 'numberOfRepeatsAllowed') then
        element.numberOfRepeatsAllowedElement := ParsePositiveInt(child, path+'/numberOfRepeatsAllowed') {b}
      else if (child.localName = 'quantity') then
        element.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.localName = 'expectedSupplyDuration') then
        element.expectedSupplyDuration := ParseQuantity(child, path+'/expectedSupplyDuration') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationOrderDispenseRequest(xml : TXmlBuilder; name : String; elem : TFhirMedicationOrderDispenseRequest);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationOrderDispenseRequestChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationOrderDispenseRequestChildren(xml : TXmlBuilder; elem : TFhirMedicationOrderDispenseRequest);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.medication is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.medication is TFhirReference) {2} then
    ComposeReference(xml, 'medicationReference', TFhirReference(elem.medication));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'validityPeriod', elem.validityPeriod);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePositiveInt(xml, 'numberOfRepeatsAllowed', elem.numberOfRepeatsAllowedElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'expectedSupplyDuration', elem.expectedSupplyDuration);{x.2a}
end;

function TFHIRXmlParser.ParseMedicationOrderSubstitution(element : TMXmlElement; path : string) : TFhirMedicationOrderSubstitution;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationOrderSubstitution.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationOrderSubstitutionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationOrderSubstitutionChild(element : TFhirMedicationOrderSubstitution; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'reason') then
        element.reason := ParseCodeableConcept(child, path+'/reason') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationOrderSubstitution(xml : TXmlBuilder; name : String; elem : TFhirMedicationOrderSubstitution);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationOrderSubstitutionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationOrderSubstitutionChildren(xml : TXmlBuilder; elem : TFhirMedicationOrderSubstitution);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'reason', elem.reason);{x.2a}
end;

function TFHIRXmlParser.ParseMedicationOrder(element : TMXmlElement; path : string) : TFhirMedicationOrder;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationOrder.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationOrderChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationOrderChild(element : TFhirMedicationOrder; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'dateWritten') then
        element.dateWrittenElement := ParseDateTime(child, path+'/dateWritten') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirMedicationOrderStatusEnum, SYSTEMS_TFhirMedicationOrderStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'dateEnded') then
        element.dateEndedElement := ParseDateTime(child, path+'/dateEnded') {b}
      else if (child.localName = 'reasonEnded') then
        element.reasonEnded := ParseCodeableConcept(child, path+'/reasonEnded') {b}
      else if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'prescriber') then
        element.prescriber := ParseReference{TFhirPractitioner}(child, path+'/prescriber') {b}
      else if (child.localName = 'encounter') then
        element.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.localName = 'reasonCodeableConcept') then
        element.reason := ParseCodeableConcept(child, path+'/reasonCodeableConcept'){x.3}
      else if (child.localName = 'reasonReference') then
        element.reason := ParseReference(child, path+'/reasonReference') {a}
      else if (child.localName = 'note') then
        element.noteElement := ParseString(child, path+'/note') {b}
      else if (child.localName = 'medicationCodeableConcept') then
        element.medication := ParseCodeableConcept(child, path+'/medicationCodeableConcept'){x.3}
      else if (child.localName = 'medicationReference') then
        element.medication := ParseReference(child, path+'/medicationReference') {a}
      else if (child.localName = 'dosageInstruction') then
        element.dosageInstructionList.Add(ParseMedicationOrderDosageInstruction(child, path+'/dosageInstruction')){y.2}
      else if (child.localName = 'dispenseRequest') then
        element.dispenseRequest := ParseMedicationOrderDispenseRequest(child, path+'/dispenseRequest') {b}
      else if (child.localName = 'substitution') then
        element.substitution := ParseMedicationOrderSubstitution(child, path+'/substitution') {b}
      else if (child.localName = 'priorPrescription') then
        element.priorPrescription := ParseReference{TFhirMedicationOrder}(child, path+'/priorPrescription') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationOrder(xml : TXmlBuilder; name : String; elem : TFhirMedicationOrder);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationOrderChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationOrderChildren(xml : TXmlBuilder; elem : TFhirMedicationOrder);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dateWritten') then
    ComposeDateTime(xml, 'dateWritten', elem.dateWrittenElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirMedicationOrderStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dateEnded') then
    ComposeDateTime(xml, 'dateEnded', elem.dateEndedElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonEnded') then
    ComposeCodeableConcept(xml, 'reasonEnded', elem.reasonEnded);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('prescriber') then
    ComposeReference{TFhirPractitioner}(xml, 'prescriber', elem.prescriber);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirReference) {2} then
    ComposeReference(xml, 'reasonReference', TFhirReference(elem.reason));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('note') then
    ComposeString(xml, 'note', elem.noteElement);{x.2b}
  if (elem.medication is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication))
  else if (elem.medication is TFhirReference) {2} then
    ComposeReference(xml, 'medicationReference', TFhirReference(elem.medication));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dosageInstruction') then
    for i := 0 to elem.dosageInstructionList.Count - 1 do
      ComposeMedicationOrderDosageInstruction(xml, 'dosageInstruction', elem.dosageInstructionList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dispenseRequest') then
    ComposeMedicationOrderDispenseRequest(xml, 'dispenseRequest', elem.dispenseRequest);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('substitution') then
    ComposeMedicationOrderSubstitution(xml, 'substitution', elem.substitution);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priorPrescription') then
    ComposeReference{TFhirMedicationOrder}(xml, 'priorPrescription', elem.priorPrescription);{x.2a}
end;

{$ENDIF FHIR_MEDICATIONORDER}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
function TFHIRXmlParser.ParseMedicationStatementDosage(element : TMXmlElement; path : string) : TFhirMedicationStatementDosage;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationStatementDosage.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationStatementDosageChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationStatementDosageChild(element : TFhirMedicationStatementDosage; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'text') then
        element.textElement := ParseString(child, path+'/text') {b}
      else if (child.localName = 'timing') then
        element.timing := ParseTiming(child, path+'/timing') {b}
      else if (child.localName = 'asNeededCodeableConcept') then
        element.asNeeded := ParseCodeableConcept(child, path+'/asNeededCodeableConcept'){x.3}
      else if (child.localName = 'asNeededBoolean') then
        element.asNeeded := ParseBoolean(child, path+'/asNeededBoolean'){x.3}
      else if (child.localName = 'siteCodeableConcept') then
        element.site := ParseCodeableConcept(child, path+'/siteCodeableConcept'){x.3}
      else if (child.localName = 'siteReference') then
        element.site := ParseReference(child, path+'/siteReference') {a}
      else if (child.localName = 'route') then
        element.route := ParseCodeableConcept(child, path+'/route') {b}
      else if (child.localName = 'method') then
        element.method := ParseCodeableConcept(child, path+'/method') {b}
      else if (child.localName = 'quantityQuantity') then
        element.quantity := ParseQuantity(child, path+'/quantityQuantity'){x.3}
      else if (child.localName = 'quantityRange') then
        element.quantity := ParseRange(child, path+'/quantityRange'){x.3}
      else if (child.localName = 'rateRatio') then
        element.rate := ParseRatio(child, path+'/rateRatio'){x.3}
      else if (child.localName = 'rateRange') then
        element.rate := ParseRange(child, path+'/rateRange'){x.3}
      else if (child.localName = 'maxDosePerPeriod') then
        element.maxDosePerPeriod := ParseRatio(child, path+'/maxDosePerPeriod') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationStatementDosage(xml : TXmlBuilder; name : String; elem : TFhirMedicationStatementDosage);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationStatementDosageChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationStatementDosageChildren(xml : TXmlBuilder; elem : TFhirMedicationStatementDosage);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTiming(xml, 'timing', elem.timing);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'asNeededBoolean', TFhirBoolean(elem.asNeeded));
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'siteCodeableConcept', TFhirCodeableConcept(elem.site))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.site is TFhirReference) {2} then
    ComposeReference(xml, 'siteReference', TFhirReference(elem.site));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'route', elem.route);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'method', elem.method);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.quantity is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'quantityQuantity', TFhirQuantity(elem.quantity))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.quantity is TFhirRange) {6} then
    ComposeRange(xml, 'quantityRange', TFhirRange(elem.quantity));
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRatio) {6} then
    ComposeRatio(xml, 'rateRatio', TFhirRatio(elem.rate))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.rate is TFhirRange) {6} then
    ComposeRange(xml, 'rateRange', TFhirRange(elem.rate));
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(xml, 'maxDosePerPeriod', elem.maxDosePerPeriod);{x.2a}
end;

function TFHIRXmlParser.ParseMedicationStatement(element : TMXmlElement; path : string) : TFhirMedicationStatement;
var
  child : TMXmlElement;
begin
  result := TFhirMedicationStatement.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMedicationStatementChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMedicationStatementChild(element : TFhirMedicationStatement; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'informationSource') then
        element.informationSource := ParseReference{Resource}(child, path+'/informationSource') {b}
      else if (child.localName = 'dateAsserted') then
        element.dateAssertedElement := ParseDateTime(child, path+'/dateAsserted') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirMedicationStatementStatusEnum, SYSTEMS_TFhirMedicationStatementStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'wasNotTaken') then
        element.wasNotTakenElement := ParseBoolean(child, path+'/wasNotTaken') {b}
      else if (child.localName = 'reasonNotTaken') then
        element.reasonNotTakenList.Add(ParseCodeableConcept(child, path+'/reasonNotTaken')){y.2}
      else if (child.localName = 'reasonForUseCodeableConcept') then
        element.reasonForUse := ParseCodeableConcept(child, path+'/reasonForUseCodeableConcept'){x.3}
      else if (child.localName = 'reasonForUseReference') then
        element.reasonForUse := ParseReference(child, path+'/reasonForUseReference') {a}
      else if (child.localName = 'effectivePeriod') then
        element.effective := ParsePeriod(child, path+'/effectivePeriod'){x.3}
      else if (child.localName = 'effectiveDateTime') then
        element.effective := ParseDateTime(child, path+'/effectiveDateTime'){x.3}
      else if (child.localName = 'note') then
        element.noteElement := ParseString(child, path+'/note') {b}
      else if (child.localName = 'supportingInformation') then
        element.supportingInformationList.Add(ParseReference{TFhirReference}(child, path+'/supportingInformation')){y.2}
      else if (child.localName = 'medicationCodeableConcept') then
        element.medication := ParseCodeableConcept(child, path+'/medicationCodeableConcept'){x.3}
      else if (child.localName = 'medicationReference') then
        element.medication := ParseReference(child, path+'/medicationReference') {a}
      else if (child.localName = 'dosage') then
        element.dosageList.Add(ParseMedicationStatementDosage(child, path+'/dosage')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMedicationStatement(xml : TXmlBuilder; name : String; elem : TFhirMedicationStatement);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMedicationStatementChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMedicationStatementChildren(xml : TXmlBuilder; elem : TFhirMedicationStatement);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('informationSource') then
    ComposeReference{Resource}(xml, 'informationSource', elem.informationSource);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dateAsserted') then
    ComposeDateTime(xml, 'dateAsserted', elem.dateAssertedElement);{x.2b}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirMedicationStatementStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('wasNotTaken') then
    ComposeBoolean(xml, 'wasNotTaken', elem.wasNotTakenElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reasonNotTaken') then
    for i := 0 to elem.reasonNotTakenList.Count - 1 do
      ComposeCodeableConcept(xml, 'reasonNotTaken', elem.reasonNotTakenList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reasonForUse is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'reasonForUseCodeableConcept', TFhirCodeableConcept(elem.reasonForUse))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reasonForUse is TFhirReference) {2} then
    ComposeReference(xml, 'reasonForUseReference', TFhirReference(elem.reasonForUse));
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirPeriod) {6} then
    ComposePeriod(xml, 'effectivePeriod', TFhirPeriod(elem.effective))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'effectiveDateTime', TFhirDateTime(elem.effective));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('note') then
    ComposeString(xml, 'note', elem.noteElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('supportingInformation') then
    for i := 0 to elem.supportingInformationList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'supportingInformation', elem.supportingInformationList[i]);
  if (elem.medication is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'medicationCodeableConcept', TFhirCodeableConcept(elem.medication))
  else if (elem.medication is TFhirReference) {2} then
    ComposeReference(xml, 'medicationReference', TFhirReference(elem.medication));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dosage') then
    for i := 0 to elem.dosageList.Count - 1 do
      ComposeMedicationStatementDosage(xml, 'dosage', elem.dosageList[i]);
end;

{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MESSAGEHEADER}
function TFHIRXmlParser.ParseMessageHeaderResponse(element : TMXmlElement; path : string) : TFhirMessageHeaderResponse;
var
  child : TMXmlElement;
begin
  result := TFhirMessageHeaderResponse.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMessageHeaderResponseChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMessageHeaderResponseChild(element : TFhirMessageHeaderResponse; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierElement := ParseId(child, path+'/identifier') {b}
      else if (child.localName = 'code') then
        element.codeElement := ParseEnum(CODES_TFhirResponseCodeEnum, SYSTEMS_TFhirResponseCodeEnum, path+'/code', child){1a}
      else if (child.localName = 'details') then
        element.details := ParseReference{TFhirOperationOutcome}(child, path+'/details') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMessageHeaderResponse(xml : TXmlBuilder; name : String; elem : TFhirMessageHeaderResponse);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMessageHeaderResponseChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMessageHeaderResponseChildren(xml : TXmlBuilder; elem : TFhirMessageHeaderResponse);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeId(xml, 'identifier', elem.identifierElement);{x.2b}
  ComposeEnum(xml, 'code', elem.CodeElement, CODES_TFhirResponseCodeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOperationOutcome}(xml, 'details', elem.details);{x.2a}
end;

function TFHIRXmlParser.ParseMessageHeaderSource(element : TMXmlElement; path : string) : TFhirMessageHeaderSource;
var
  child : TMXmlElement;
begin
  result := TFhirMessageHeaderSource.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMessageHeaderSourceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMessageHeaderSourceChild(element : TFhirMessageHeaderSource; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'software') then
        element.softwareElement := ParseString(child, path+'/software') {b}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if (child.localName = 'contact') then
        element.contact := ParseContactPoint(child, path+'/contact') {b}
      else if (child.localName = 'endpoint') then
        element.endpointElement := ParseUri(child, path+'/endpoint') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMessageHeaderSource(xml : TXmlBuilder; name : String; elem : TFhirMessageHeaderSource);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMessageHeaderSourceChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMessageHeaderSourceChildren(xml : TXmlBuilder; elem : TFhirMessageHeaderSource);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'software', elem.softwareElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', elem.versionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeContactPoint(xml, 'contact', elem.contact);{x.2a}
  ComposeUri(xml, 'endpoint', elem.endpointElement);{x.2b}
end;

function TFHIRXmlParser.ParseMessageHeaderDestination(element : TMXmlElement; path : string) : TFhirMessageHeaderDestination;
var
  child : TMXmlElement;
begin
  result := TFhirMessageHeaderDestination.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMessageHeaderDestinationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMessageHeaderDestinationChild(element : TFhirMessageHeaderDestination; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'target') then
        element.target := ParseReference{TFhirDevice}(child, path+'/target') {b}
      else if (child.localName = 'endpoint') then
        element.endpointElement := ParseUri(child, path+'/endpoint') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMessageHeaderDestination(xml : TXmlBuilder; name : String; elem : TFhirMessageHeaderDestination);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMessageHeaderDestinationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMessageHeaderDestinationChildren(xml : TXmlBuilder; elem : TFhirMessageHeaderDestination);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirDevice}(xml, 'target', elem.target);{x.2a}
  ComposeUri(xml, 'endpoint', elem.endpointElement);{x.2b}
end;

function TFHIRXmlParser.ParseMessageHeader(element : TMXmlElement; path : string) : TFhirMessageHeader;
var
  child : TMXmlElement;
begin
  result := TFhirMessageHeader.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseMessageHeaderChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMessageHeaderChild(element : TFhirMessageHeader; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'timestamp') then
        element.timestampElement := ParseInstant(child, path+'/timestamp') {b}
      else if (child.localName = 'event') then
        element.event := ParseCoding(child, path+'/event') {b}
      else if (child.localName = 'response') then
        element.response := ParseMessageHeaderResponse(child, path+'/response') {b}
      else if (child.localName = 'source') then
        element.source := ParseMessageHeaderSource(child, path+'/source') {b}
      else if (child.localName = 'destination') then
        element.destinationList.Add(ParseMessageHeaderDestination(child, path+'/destination')){y.2}
      else if (child.localName = 'enterer') then
        element.enterer := ParseReference{TFhirPractitioner}(child, path+'/enterer') {b}
      else if (child.localName = 'author') then
        element.author := ParseReference{TFhirPractitioner}(child, path+'/author') {b}
      else if (child.localName = 'receiver') then
        element.receiver := ParseReference{Resource}(child, path+'/receiver') {b}
      else if (child.localName = 'responsible') then
        element.responsible := ParseReference{Resource}(child, path+'/responsible') {b}
      else if (child.localName = 'reason') then
        element.reason := ParseCodeableConcept(child, path+'/reason') {b}
      else if (child.localName = 'data') then
        element.dataList.Add(ParseReference{TFhirReference}(child, path+'/data')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeMessageHeader(xml : TXmlBuilder; name : String; elem : TFhirMessageHeader);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeMessageHeaderChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeMessageHeaderChildren(xml : TXmlBuilder; elem : TFhirMessageHeader);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  ComposeInstant(xml, 'timestamp', elem.timestampElement);{x.2b}
  ComposeCoding(xml, 'event', elem.event);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('response') then
    ComposeMessageHeaderResponse(xml, 'response', elem.response);{x.2a}
  ComposeMessageHeaderSource(xml, 'source', elem.source);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('destination') then
    for i := 0 to elem.destinationList.Count - 1 do
      ComposeMessageHeaderDestination(xml, 'destination', elem.destinationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('enterer') then
    ComposeReference{TFhirPractitioner}(xml, 'enterer', elem.enterer);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{TFhirPractitioner}(xml, 'author', elem.author);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('receiver') then
    ComposeReference{Resource}(xml, 'receiver', elem.receiver);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('responsible') then
    ComposeReference{Resource}(xml, 'responsible', elem.responsible);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reason') then
    ComposeCodeableConcept(xml, 'reason', elem.reason);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('data') then
    for i := 0 to elem.dataList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'data', elem.dataList[i]);
end;

{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_NAMINGSYSTEM}
function TFHIRXmlParser.ParseNamingSystemContact(element : TMXmlElement; path : string) : TFhirNamingSystemContact;
var
  child : TMXmlElement;
begin
  result := TFhirNamingSystemContact.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNamingSystemContactChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNamingSystemContactChild(element : TFhirNamingSystemContact; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'telecom') then
        element.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNamingSystemContact(xml : TXmlBuilder; name : String; elem : TFhirNamingSystemContact);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNamingSystemContactChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNamingSystemContactChildren(xml : TXmlBuilder; elem : TFhirNamingSystemContact);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
end;

function TFHIRXmlParser.ParseNamingSystemUniqueId(element : TMXmlElement; path : string) : TFhirNamingSystemUniqueId;
var
  child : TMXmlElement;
begin
  result := TFhirNamingSystemUniqueId.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNamingSystemUniqueIdChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNamingSystemUniqueIdChild(element : TFhirNamingSystemUniqueId; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirNamingsystemIdentifierTypeEnum, SYSTEMS_TFhirNamingsystemIdentifierTypeEnum, path+'/type', child){1a}
      else if (child.localName = 'value') then
        element.valueElement := ParseString(child, path+'/value') {b}
      else if (child.localName = 'preferred') then
        element.preferredElement := ParseBoolean(child, path+'/preferred') {b}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNamingSystemUniqueId(xml : TXmlBuilder; name : String; elem : TFhirNamingSystemUniqueId);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNamingSystemUniqueIdChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNamingSystemUniqueIdChildren(xml : TXmlBuilder; elem : TFhirNamingSystemUniqueId);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirNamingsystemIdentifierTypeEnum);
  ComposeString(xml, 'value', elem.valueElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'preferred', elem.preferredElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
end;

function TFHIRXmlParser.ParseNamingSystem(element : TMXmlElement; path : string) : TFhirNamingSystem;
var
  child : TMXmlElement;
begin
  result := TFhirNamingSystem.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNamingSystemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNamingSystemChild(element : TFhirNamingSystem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'kind') then
        element.kindElement := ParseEnum(CODES_TFhirNamingsystemTypeEnum, SYSTEMS_TFhirNamingsystemTypeEnum, path+'/kind', child){1a}
      else if (child.localName = 'publisher') then
        element.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.localName = 'contact') then
        element.contactList.Add(ParseNamingSystemContact(child, path+'/contact')){y.2}
      else if (child.localName = 'responsible') then
        element.responsibleElement := ParseString(child, path+'/responsible') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'useContext') then
        element.useContextList.Add(ParseCodeableConcept(child, path+'/useContext')){y.2}
      else if (child.localName = 'usage') then
        element.usageElement := ParseString(child, path+'/usage') {b}
      else if (child.localName = 'uniqueId') then
        element.uniqueIdList.Add(ParseNamingSystemUniqueId(child, path+'/uniqueId')){y.2}
      else if (child.localName = 'replacedBy') then
        element.replacedBy := ParseReference{TFhirNamingSystem}(child, path+'/replacedBy') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNamingSystem(xml : TXmlBuilder; name : String; elem : TFhirNamingSystem);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNamingSystemChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNamingSystemChildren(xml : TXmlBuilder; elem : TFhirNamingSystem);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameElement);{x.2b}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum);
  ComposeEnum(xml, 'kind', elem.KindElement, CODES_TFhirNamingsystemTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeNamingSystemContact(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('responsible') then
    ComposeString(xml, 'responsible', elem.responsibleElement);{x.2b}
  ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('type_') then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(xml, 'useContext', elem.useContextList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('usage') then
    ComposeString(xml, 'usage', elem.usageElement);{x.2b}
  for i := 0 to elem.uniqueIdList.Count - 1 do
      ComposeNamingSystemUniqueId(xml, 'uniqueId', elem.uniqueIdList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('replacedBy') then
    ComposeReference{TFhirNamingSystem}(xml, 'replacedBy', elem.replacedBy);{x.2a}
end;

{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
function TFHIRXmlParser.ParseNutritionOrderOralDiet(element : TMXmlElement; path : string) : TFhirNutritionOrderOralDiet;
var
  child : TMXmlElement;
begin
  result := TFhirNutritionOrderOralDiet.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNutritionOrderOralDietChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNutritionOrderOralDietChild(element : TFhirNutritionOrderOralDiet; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_List.Add(ParseCodeableConcept(child, path+'/type')){y.2}
      else if (child.localName = 'schedule') then
        element.scheduleList.Add(ParseTiming(child, path+'/schedule')){y.2}
      else if (child.localName = 'nutrient') then
        element.nutrientList.Add(ParseNutritionOrderOralDietNutrient(child, path+'/nutrient')){y.2}
      else if (child.localName = 'texture') then
        element.textureList.Add(ParseNutritionOrderOralDietTexture(child, path+'/texture')){y.2}
      else if (child.localName = 'fluidConsistencyType') then
        element.fluidConsistencyTypeList.Add(ParseCodeableConcept(child, path+'/fluidConsistencyType')){y.2}
      else if (child.localName = 'instruction') then
        element.instructionElement := ParseString(child, path+'/instruction') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderOralDiet(xml : TXmlBuilder; name : String; elem : TFhirNutritionOrderOralDiet);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNutritionOrderOralDietChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderOralDietChildren(xml : TXmlBuilder; elem : TFhirNutritionOrderOralDiet);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', elem.type_List[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.scheduleList.Count - 1 do
      ComposeTiming(xml, 'schedule', elem.scheduleList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.nutrientList.Count - 1 do
      ComposeNutritionOrderOralDietNutrient(xml, 'nutrient', elem.nutrientList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.textureList.Count - 1 do
      ComposeNutritionOrderOralDietTexture(xml, 'texture', elem.textureList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.fluidConsistencyTypeList.Count - 1 do
      ComposeCodeableConcept(xml, 'fluidConsistencyType', elem.fluidConsistencyTypeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'instruction', elem.instructionElement);{x.2b}
end;

function TFHIRXmlParser.ParseNutritionOrderOralDietNutrient(element : TMXmlElement; path : string) : TFhirNutritionOrderOralDietNutrient;
var
  child : TMXmlElement;
begin
  result := TFhirNutritionOrderOralDietNutrient.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNutritionOrderOralDietNutrientChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNutritionOrderOralDietNutrientChild(element : TFhirNutritionOrderOralDietNutrient; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'modifier') then
        element.modifier := ParseCodeableConcept(child, path+'/modifier') {b}
      else if (child.localName = 'amount') then
        element.amount := ParseQuantity(child, path+'/amount') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderOralDietNutrient(xml : TXmlBuilder; name : String; elem : TFhirNutritionOrderOralDietNutrient);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNutritionOrderOralDietNutrientChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderOralDietNutrientChildren(xml : TXmlBuilder; elem : TFhirNutritionOrderOralDietNutrient);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'modifier', elem.modifier);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'amount', elem.amount);{x.2a}
end;

function TFHIRXmlParser.ParseNutritionOrderOralDietTexture(element : TMXmlElement; path : string) : TFhirNutritionOrderOralDietTexture;
var
  child : TMXmlElement;
begin
  result := TFhirNutritionOrderOralDietTexture.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNutritionOrderOralDietTextureChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNutritionOrderOralDietTextureChild(element : TFhirNutritionOrderOralDietTexture; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'modifier') then
        element.modifier := ParseCodeableConcept(child, path+'/modifier') {b}
      else if (child.localName = 'foodType') then
        element.foodType := ParseCodeableConcept(child, path+'/foodType') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderOralDietTexture(xml : TXmlBuilder; name : String; elem : TFhirNutritionOrderOralDietTexture);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNutritionOrderOralDietTextureChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderOralDietTextureChildren(xml : TXmlBuilder; elem : TFhirNutritionOrderOralDietTexture);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'modifier', elem.modifier);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'foodType', elem.foodType);{x.2a}
end;

function TFHIRXmlParser.ParseNutritionOrderSupplement(element : TMXmlElement; path : string) : TFhirNutritionOrderSupplement;
var
  child : TMXmlElement;
begin
  result := TFhirNutritionOrderSupplement.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNutritionOrderSupplementChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNutritionOrderSupplementChild(element : TFhirNutritionOrderSupplement; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'productName') then
        element.productNameElement := ParseString(child, path+'/productName') {b}
      else if (child.localName = 'schedule') then
        element.scheduleList.Add(ParseTiming(child, path+'/schedule')){y.2}
      else if (child.localName = 'quantity') then
        element.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.localName = 'instruction') then
        element.instructionElement := ParseString(child, path+'/instruction') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderSupplement(xml : TXmlBuilder; name : String; elem : TFhirNutritionOrderSupplement);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNutritionOrderSupplementChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderSupplementChildren(xml : TXmlBuilder; elem : TFhirNutritionOrderSupplement);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'productName', elem.productNameElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.scheduleList.Count - 1 do
      ComposeTiming(xml, 'schedule', elem.scheduleList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'instruction', elem.instructionElement);{x.2b}
end;

function TFHIRXmlParser.ParseNutritionOrderEnteralFormula(element : TMXmlElement; path : string) : TFhirNutritionOrderEnteralFormula;
var
  child : TMXmlElement;
begin
  result := TFhirNutritionOrderEnteralFormula.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNutritionOrderEnteralFormulaChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNutritionOrderEnteralFormulaChild(element : TFhirNutritionOrderEnteralFormula; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'baseFormulaType') then
        element.baseFormulaType := ParseCodeableConcept(child, path+'/baseFormulaType') {b}
      else if (child.localName = 'baseFormulaProductName') then
        element.baseFormulaProductNameElement := ParseString(child, path+'/baseFormulaProductName') {b}
      else if (child.localName = 'additiveType') then
        element.additiveType := ParseCodeableConcept(child, path+'/additiveType') {b}
      else if (child.localName = 'additiveProductName') then
        element.additiveProductNameElement := ParseString(child, path+'/additiveProductName') {b}
      else if (child.localName = 'caloricDensity') then
        element.caloricDensity := ParseQuantity(child, path+'/caloricDensity') {b}
      else if (child.localName = 'routeofAdministration') then
        element.routeofAdministration := ParseCodeableConcept(child, path+'/routeofAdministration') {b}
      else if (child.localName = 'administration') then
        element.administrationList.Add(ParseNutritionOrderEnteralFormulaAdministration(child, path+'/administration')){y.2}
      else if (child.localName = 'maxVolumeToDeliver') then
        element.maxVolumeToDeliver := ParseQuantity(child, path+'/maxVolumeToDeliver') {b}
      else if (child.localName = 'administrationInstruction') then
        element.administrationInstructionElement := ParseString(child, path+'/administrationInstruction') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderEnteralFormula(xml : TXmlBuilder; name : String; elem : TFhirNutritionOrderEnteralFormula);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNutritionOrderEnteralFormulaChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderEnteralFormulaChildren(xml : TXmlBuilder; elem : TFhirNutritionOrderEnteralFormula);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'baseFormulaType', elem.baseFormulaType);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'baseFormulaProductName', elem.baseFormulaProductNameElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'additiveType', elem.additiveType);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'additiveProductName', elem.additiveProductNameElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'caloricDensity', elem.caloricDensity);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'routeofAdministration', elem.routeofAdministration);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.administrationList.Count - 1 do
      ComposeNutritionOrderEnteralFormulaAdministration(xml, 'administration', elem.administrationList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'maxVolumeToDeliver', elem.maxVolumeToDeliver);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'administrationInstruction', elem.administrationInstructionElement);{x.2b}
end;

function TFHIRXmlParser.ParseNutritionOrderEnteralFormulaAdministration(element : TMXmlElement; path : string) : TFhirNutritionOrderEnteralFormulaAdministration;
var
  child : TMXmlElement;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministration.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNutritionOrderEnteralFormulaAdministrationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNutritionOrderEnteralFormulaAdministrationChild(element : TFhirNutritionOrderEnteralFormulaAdministration; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'schedule') then
        element.schedule := ParseTiming(child, path+'/schedule') {b}
      else if (child.localName = 'quantity') then
        element.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.localName = 'rateQuantity') then
        element.rate := ParseQuantity(child, path+'/rateQuantity'){x.3}
      else if (child.localName = 'rateRatio') then
        element.rate := ParseRatio(child, path+'/rateRatio'){x.3}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderEnteralFormulaAdministration(xml : TXmlBuilder; name : String; elem : TFhirNutritionOrderEnteralFormulaAdministration);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNutritionOrderEnteralFormulaAdministrationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderEnteralFormulaAdministrationChildren(xml : TXmlBuilder; elem : TFhirNutritionOrderEnteralFormulaAdministration);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeTiming(xml, 'schedule', elem.schedule);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2a}
  if (SummaryOption in [soFull, soData]) and (elem.rate is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'rateQuantity', TFhirQuantity(elem.rate))
  else if (SummaryOption in [soFull, soData]) and (elem.rate is TFhirRatio) {6} then
    ComposeRatio(xml, 'rateRatio', TFhirRatio(elem.rate));
end;

function TFHIRXmlParser.ParseNutritionOrder(element : TMXmlElement; path : string) : TFhirNutritionOrder;
var
  child : TMXmlElement;
begin
  result := TFhirNutritionOrder.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseNutritionOrderChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNutritionOrderChild(element : TFhirNutritionOrder; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'orderer') then
        element.orderer := ParseReference{TFhirPractitioner}(child, path+'/orderer') {b}
      else if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'encounter') then
        element.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.localName = 'dateTime') then
        element.dateTimeElement := ParseDateTime(child, path+'/dateTime') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirNutritionOrderStatusEnum, SYSTEMS_TFhirNutritionOrderStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'allergyIntolerance') then
        element.allergyIntoleranceList.Add(ParseReference{TFhirAllergyIntolerance}(child, path+'/allergyIntolerance')){y.2}
      else if (child.localName = 'foodPreferenceModifier') then
        element.foodPreferenceModifierList.Add(ParseCodeableConcept(child, path+'/foodPreferenceModifier')){y.2}
      else if (child.localName = 'excludeFoodModifier') then
        element.excludeFoodModifierList.Add(ParseCodeableConcept(child, path+'/excludeFoodModifier')){y.2}
      else if (child.localName = 'oralDiet') then
        element.oralDiet := ParseNutritionOrderOralDiet(child, path+'/oralDiet') {b}
      else if (child.localName = 'supplement') then
        element.supplementList.Add(ParseNutritionOrderSupplement(child, path+'/supplement')){y.2}
      else if (child.localName = 'enteralFormula') then
        element.enteralFormula := ParseNutritionOrderEnteralFormula(child, path+'/enteralFormula') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrder(xml : TXmlBuilder; name : String; elem : TFhirNutritionOrder);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeNutritionOrderChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeNutritionOrderChildren(xml : TXmlBuilder; elem : TFhirNutritionOrder);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('orderer') then
    ComposeReference{TFhirPractitioner}(xml, 'orderer', elem.orderer);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2a}
  ComposeDateTime(xml, 'dateTime', elem.dateTimeElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirNutritionOrderStatusEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('allergyIntolerance') then
    for i := 0 to elem.allergyIntoleranceList.Count - 1 do
      ComposeReference{TFhirAllergyIntolerance}(xml, 'allergyIntolerance', elem.allergyIntoleranceList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('foodPreferenceModifier') then
    for i := 0 to elem.foodPreferenceModifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'foodPreferenceModifier', elem.foodPreferenceModifierList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('excludeFoodModifier') then
    for i := 0 to elem.excludeFoodModifierList.Count - 1 do
      ComposeCodeableConcept(xml, 'excludeFoodModifier', elem.excludeFoodModifierList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('oralDiet') then
    ComposeNutritionOrderOralDiet(xml, 'oralDiet', elem.oralDiet);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('supplement') then
    for i := 0 to elem.supplementList.Count - 1 do
      ComposeNutritionOrderSupplement(xml, 'supplement', elem.supplementList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('enteralFormula') then
    ComposeNutritionOrderEnteralFormula(xml, 'enteralFormula', elem.enteralFormula);{x.2a}
end;

{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
function TFHIRXmlParser.ParseObservationReferenceRange(element : TMXmlElement; path : string) : TFhirObservationReferenceRange;
var
  child : TMXmlElement;
begin
  result := TFhirObservationReferenceRange.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseObservationReferenceRangeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseObservationReferenceRangeChild(element : TFhirObservationReferenceRange; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'low') then
        element.low := ParseQuantity(child, path+'/low') {b}
      else if (child.localName = 'high') then
        element.high := ParseQuantity(child, path+'/high') {b}
      else if (child.localName = 'meaning') then
        element.meaning := ParseCodeableConcept(child, path+'/meaning') {b}
      else if (child.localName = 'age') then
        element.age := ParseRange(child, path+'/age') {b}
      else if (child.localName = 'text') then
        element.textElement := ParseString(child, path+'/text') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeObservationReferenceRange(xml : TXmlBuilder; name : String; elem : TFhirObservationReferenceRange);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeObservationReferenceRangeChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeObservationReferenceRangeChildren(xml : TXmlBuilder; elem : TFhirObservationReferenceRange);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'low', elem.low);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'high', elem.high);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'meaning', elem.meaning);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeRange(xml, 'age', elem.age);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2b}
end;

function TFHIRXmlParser.ParseObservationRelated(element : TMXmlElement; path : string) : TFhirObservationRelated;
var
  child : TMXmlElement;
begin
  result := TFhirObservationRelated.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseObservationRelatedChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseObservationRelatedChild(element : TFhirObservationRelated; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirObservationRelationshiptypesEnum, SYSTEMS_TFhirObservationRelationshiptypesEnum, path+'/type', child){1a}
      else if (child.localName = 'target') then
        element.target := ParseReference{Resource}(child, path+'/target') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeObservationRelated(xml : TXmlBuilder; name : String; elem : TFhirObservationRelated);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeObservationRelatedChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeObservationRelatedChildren(xml : TXmlBuilder; elem : TFhirObservationRelated);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirObservationRelationshiptypesEnum);
  ComposeReference{Resource}(xml, 'target', elem.target);{x.2a}
end;

function TFHIRXmlParser.ParseObservationComponent(element : TMXmlElement; path : string) : TFhirObservationComponent;
var
  child : TMXmlElement;
begin
  result := TFhirObservationComponent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseObservationComponentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseObservationComponentChild(element : TFhirObservationComponent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'valueQuantity') then
        element.value := ParseQuantity(child, path+'/valueQuantity'){x.3}
      else if (child.localName = 'valueCodeableConcept') then
        element.value := ParseCodeableConcept(child, path+'/valueCodeableConcept'){x.3}
      else if (child.localName = 'valueRange') then
        element.value := ParseRange(child, path+'/valueRange'){x.3}
      else if (child.localName = 'valueRatio') then
        element.value := ParseRatio(child, path+'/valueRatio'){x.3}
      else if (child.localName = 'valueSampledData') then
        element.value := ParseSampledData(child, path+'/valueSampledData'){x.3}
      else if (child.localName = 'valueAttachment') then
        element.value := ParseAttachment(child, path+'/valueAttachment'){x.3}
      else if (child.localName = 'valuePeriod') then
        element.value := ParsePeriod(child, path+'/valuePeriod'){x.3}
      else if (child.localName = 'valueString') then
        element.value := ParseString(child, path+'/valueString'){x.3}
      else if (child.localName = 'valueTime') then
        element.value := ParseTime(child, path+'/valueTime'){x.3}
      else if (child.localName = 'valueDateTime') then
        element.value := ParseDateTime(child, path+'/valueDateTime'){x.3}
      else if (child.localName = 'dataAbsentReason') then
        element.dataAbsentReason := ParseCodeableConcept(child, path+'/dataAbsentReason') {b}
      else if (child.localName = 'referenceRange') then
        element.referenceRangeList.Add(ParseObservationReferenceRange(child, path+'/referenceRange')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeObservationComponent(xml : TXmlBuilder; name : String; elem : TFhirObservationComponent);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeObservationComponentChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeObservationComponentChildren(xml : TXmlBuilder; elem : TFhirObservationComponent);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirRange) {6} then
    ComposeRange(xml, 'valueRange', TFhirRange(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirRatio) {6} then
    ComposeRatio(xml, 'valueRatio', TFhirRatio(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirSampledData) {6} then
    ComposeSampledData(xml, 'valueSampledData', TFhirSampledData(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirPeriod) {6} then
    ComposePeriod(xml, 'valuePeriod', TFhirPeriod(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirTime) {6} then
    ComposeTime(xml, 'valueTime', TFhirTime(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(elem.value));
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'dataAbsentReason', elem.dataAbsentReason);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.referenceRangeList.Count - 1 do
      ComposeObservationReferenceRange(xml, 'referenceRange', elem.referenceRangeList[i]);
end;

function TFHIRXmlParser.ParseObservation(element : TMXmlElement; path : string) : TFhirObservation;
var
  child : TMXmlElement;
begin
  result := TFhirObservation.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseObservationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseObservationChild(element : TFhirObservation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirObservationStatusEnum, SYSTEMS_TFhirObservationStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'category') then
        element.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'encounter') then
        element.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.localName = 'effectivePeriod') then
        element.effective := ParsePeriod(child, path+'/effectivePeriod'){x.3}
      else if (child.localName = 'effectiveDateTime') then
        element.effective := ParseDateTime(child, path+'/effectiveDateTime'){x.3}
      else if (child.localName = 'issued') then
        element.issuedElement := ParseInstant(child, path+'/issued') {b}
      else if (child.localName = 'performer') then
        element.performerList.Add(ParseReference{Resource}(child, path+'/performer')){y.2}
      else if (child.localName = 'valueQuantity') then
        element.value := ParseQuantity(child, path+'/valueQuantity'){x.3}
      else if (child.localName = 'valueCodeableConcept') then
        element.value := ParseCodeableConcept(child, path+'/valueCodeableConcept'){x.3}
      else if (child.localName = 'valueRange') then
        element.value := ParseRange(child, path+'/valueRange'){x.3}
      else if (child.localName = 'valueRatio') then
        element.value := ParseRatio(child, path+'/valueRatio'){x.3}
      else if (child.localName = 'valueSampledData') then
        element.value := ParseSampledData(child, path+'/valueSampledData'){x.3}
      else if (child.localName = 'valueAttachment') then
        element.value := ParseAttachment(child, path+'/valueAttachment'){x.3}
      else if (child.localName = 'valuePeriod') then
        element.value := ParsePeriod(child, path+'/valuePeriod'){x.3}
      else if (child.localName = 'valueString') then
        element.value := ParseString(child, path+'/valueString'){x.3}
      else if (child.localName = 'valueTime') then
        element.value := ParseTime(child, path+'/valueTime'){x.3}
      else if (child.localName = 'valueDateTime') then
        element.value := ParseDateTime(child, path+'/valueDateTime'){x.3}
      else if (child.localName = 'dataAbsentReason') then
        element.dataAbsentReason := ParseCodeableConcept(child, path+'/dataAbsentReason') {b}
      else if (child.localName = 'interpretation') then
        element.interpretation := ParseCodeableConcept(child, path+'/interpretation') {b}
      else if (child.localName = 'comments') then
        element.commentsElement := ParseString(child, path+'/comments') {b}
      else if (child.localName = 'bodySite') then
        element.bodySite := ParseCodeableConcept(child, path+'/bodySite') {b}
      else if (child.localName = 'method') then
        element.method := ParseCodeableConcept(child, path+'/method') {b}
      else if (child.localName = 'specimen') then
        element.specimen := ParseReference{TFhirSpecimen}(child, path+'/specimen') {b}
      else if (child.localName = 'device') then
        element.device := ParseReference{Resource}(child, path+'/device') {b}
      else if (child.localName = 'referenceRange') then
        element.referenceRangeList.Add(ParseObservationReferenceRange(child, path+'/referenceRange')){y.2}
      else if (child.localName = 'related') then
        element.relatedList.Add(ParseObservationRelated(child, path+'/related')){y.2}
      else if (child.localName = 'component') then
        element.componentList.Add(ParseObservationComponent(child, path+'/component')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeObservation(xml : TXmlBuilder; name : String; elem : TFhirObservation);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeObservationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeObservationChildren(xml : TXmlBuilder; elem : TFhirObservation);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirObservationStatusEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('category') then
    ComposeCodeableConcept(xml, 'category', elem.category);{x.2a}
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirPeriod) {6} then
    ComposePeriod(xml, 'effectivePeriod', TFhirPeriod(elem.effective))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.effective is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'effectiveDateTime', TFhirDateTime(elem.effective));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('issued') then
    ComposeInstant(xml, 'issued', elem.issuedElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') then
    for i := 0 to elem.performerList.Count - 1 do
      ComposeReference{Resource}(xml, 'performer', elem.performerList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'valueCodeableConcept', TFhirCodeableConcept(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirRange) {6} then
    ComposeRange(xml, 'valueRange', TFhirRange(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirRatio) {6} then
    ComposeRatio(xml, 'valueRatio', TFhirRatio(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirSampledData) {6} then
    ComposeSampledData(xml, 'valueSampledData', TFhirSampledData(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirPeriod) {6} then
    ComposePeriod(xml, 'valuePeriod', TFhirPeriod(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirTime) {6} then
    ComposeTime(xml, 'valueTime', TFhirTime(elem.value))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(elem.value));
  if (SummaryOption in [soFull, soData]) and doCompose('dataAbsentReason') then
    ComposeCodeableConcept(xml, 'dataAbsentReason', elem.dataAbsentReason);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('interpretation') then
    ComposeCodeableConcept(xml, 'interpretation', elem.interpretation);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('comments') then
    ComposeString(xml, 'comments', elem.commentsElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('bodySite') then
    ComposeCodeableConcept(xml, 'bodySite', elem.bodySite);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('method') then
    ComposeCodeableConcept(xml, 'method', elem.method);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('specimen') then
    ComposeReference{TFhirSpecimen}(xml, 'specimen', elem.specimen);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('device') then
    ComposeReference{Resource}(xml, 'device', elem.device);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('referenceRange') then
    for i := 0 to elem.referenceRangeList.Count - 1 do
      ComposeObservationReferenceRange(xml, 'referenceRange', elem.referenceRangeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('related') then
    for i := 0 to elem.relatedList.Count - 1 do
      ComposeObservationRelated(xml, 'related', elem.relatedList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('component') then
    for i := 0 to elem.componentList.Count - 1 do
      ComposeObservationComponent(xml, 'component', elem.componentList[i]);
end;

{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OPERATIONDEFINITION}
function TFHIRXmlParser.ParseOperationDefinitionContact(element : TMXmlElement; path : string) : TFhirOperationDefinitionContact;
var
  child : TMXmlElement;
begin
  result := TFhirOperationDefinitionContact.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseOperationDefinitionContactChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseOperationDefinitionContactChild(element : TFhirOperationDefinitionContact; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'telecom') then
        element.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeOperationDefinitionContact(xml : TXmlBuilder; name : String; elem : TFhirOperationDefinitionContact);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeOperationDefinitionContactChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeOperationDefinitionContactChildren(xml : TXmlBuilder; elem : TFhirOperationDefinitionContact);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
end;

function TFHIRXmlParser.ParseOperationDefinitionParameter(element : TMXmlElement; path : string) : TFhirOperationDefinitionParameter;
var
  child : TMXmlElement;
begin
  result := TFhirOperationDefinitionParameter.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseOperationDefinitionParameterChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseOperationDefinitionParameterChild(element : TFhirOperationDefinitionParameter; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseCode(child, path+'/name') {b}
      else if (child.localName = 'use') then
        element.useElement := ParseEnum(CODES_TFhirOperationParameterUseEnum, SYSTEMS_TFhirOperationParameterUseEnum, path+'/use', child){1a}
      else if (child.localName = 'min') then
        element.minElement := ParseInteger(child, path+'/min') {b}
      else if (child.localName = 'max') then
        element.maxElement := ParseString(child, path+'/max') {b}
      else if (child.localName = 'documentation') then
        element.documentationElement := ParseString(child, path+'/documentation') {b}
      else if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirOperationParameterTypeEnum, SYSTEMS_TFhirOperationParameterTypeEnum, path+'/type', child){1a}
      else if (child.localName = 'profile') then
        element.profile := ParseReference{TFhirStructureDefinition}(child, path+'/profile') {b}
      else if (child.localName = 'binding') then
        element.binding := ParseOperationDefinitionParameterBinding(child, path+'/binding') {b}
      else if (child.localName = 'part') then
        element.partList.Add(ParseOperationDefinitionParameter(child, path+'/part')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeOperationDefinitionParameter(xml : TXmlBuilder; name : String; elem : TFhirOperationDefinitionParameter);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeOperationDefinitionParameterChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeOperationDefinitionParameterChildren(xml : TXmlBuilder; elem : TFhirOperationDefinitionParameter);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCode(xml, 'name', elem.nameElement);{x.2b}
  ComposeEnum(xml, 'use', elem.UseElement, CODES_TFhirOperationParameterUseEnum);
  ComposeInteger(xml, 'min', elem.minElement);{x.2b}
  ComposeString(xml, 'max', elem.maxElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'documentation', elem.documentationElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirOperationParameterTypeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirStructureDefinition}(xml, 'profile', elem.profile);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeOperationDefinitionParameterBinding(xml, 'binding', elem.binding);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.partList.Count - 1 do
      ComposeOperationDefinitionParameter(xml, 'part', elem.partList[i]);
end;

function TFHIRXmlParser.ParseOperationDefinitionParameterBinding(element : TMXmlElement; path : string) : TFhirOperationDefinitionParameterBinding;
var
  child : TMXmlElement;
begin
  result := TFhirOperationDefinitionParameterBinding.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseOperationDefinitionParameterBindingChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseOperationDefinitionParameterBindingChild(element : TFhirOperationDefinitionParameterBinding; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'strength') then
        element.strengthElement := ParseEnum(CODES_TFhirBindingStrengthEnum, SYSTEMS_TFhirBindingStrengthEnum, path+'/strength', child){1a}
      else if (child.localName = 'valueSetReference') then
        element.valueSet := ParseReference(child, path+'/valueSetReference') {a}
      else if (child.localName = 'valueSetUri') then
        element.valueSet := ParseUri(child, path+'/valueSetUri'){x.3}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeOperationDefinitionParameterBinding(xml : TXmlBuilder; name : String; elem : TFhirOperationDefinitionParameterBinding);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeOperationDefinitionParameterBindingChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeOperationDefinitionParameterBindingChildren(xml : TXmlBuilder; elem : TFhirOperationDefinitionParameterBinding);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'strength', elem.StrengthElement, CODES_TFhirBindingStrengthEnum);
  if (elem.valueSet is TFhirReference) {2} then
    ComposeReference(xml, 'valueSetReference', TFhirReference(elem.valueSet))
  else if (elem.valueSet is TFhirUri) {6} then
    ComposeUri(xml, 'valueSetUri', TFhirUri(elem.valueSet));
end;

function TFHIRXmlParser.ParseOperationDefinition(element : TMXmlElement; path : string) : TFhirOperationDefinition;
var
  child : TMXmlElement;
begin
  result := TFhirOperationDefinition.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseOperationDefinitionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseOperationDefinitionChild(element : TFhirOperationDefinition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'kind') then
        element.kindElement := ParseEnum(CODES_TFhirOperationKindEnum, SYSTEMS_TFhirOperationKindEnum, path+'/kind', child){1a}
      else if (child.localName = 'experimental') then
        element.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.localName = 'publisher') then
        element.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.localName = 'contact') then
        element.contactList.Add(ParseOperationDefinitionContact(child, path+'/contact')){y.2}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'requirements') then
        element.requirementsElement := ParseString(child, path+'/requirements') {b}
      else if (child.localName = 'idempotent') then
        element.idempotentElement := ParseBoolean(child, path+'/idempotent') {b}
      else if (child.localName = 'code') then
        element.codeElement := ParseCode(child, path+'/code') {b}
      else if (child.localName = 'notes') then
        element.notesElement := ParseString(child, path+'/notes') {b}
      else if (child.localName = 'base') then
        element.base := ParseReference{TFhirOperationDefinition}(child, path+'/base') {b}
      else if (child.localName = 'system') then
        element.systemElement := ParseBoolean(child, path+'/system') {b}
      else if (child.localName = 'type') then
        element.type_.Add(ParseEnum(CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, path+'/type', child)){y.1}
      else if (child.localName = 'instance') then
        element.instanceElement := ParseBoolean(child, path+'/instance') {b}
      else if (child.localName = 'parameter') then
        element.parameterList.Add(ParseOperationDefinitionParameter(child, path+'/parameter')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeOperationDefinition(xml : TXmlBuilder; name : String; elem : TFhirOperationDefinition);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeOperationDefinitionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeOperationDefinitionChildren(xml : TXmlBuilder; elem : TFhirOperationDefinition);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('url') then
    ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('version') then
    ComposeString(xml, 'version', elem.versionElement);{x.2b}
  ComposeString(xml, 'name', elem.nameElement);{x.2b}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum);
  ComposeEnum(xml, 'kind', elem.KindElement, CODES_TFhirOperationKindEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('experimental') then
    ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeOperationDefinitionContact(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('requirements') then
    ComposeString(xml, 'requirements', elem.requirementsElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('idempotent') then
    ComposeBoolean(xml, 'idempotent', elem.idempotentElement);{x.2b}
  ComposeCode(xml, 'code', elem.codeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('notes') then
    ComposeString(xml, 'notes', elem.notesElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('base') then
    ComposeReference{TFhirOperationDefinition}(xml, 'base', elem.base);{x.2a}
  ComposeBoolean(xml, 'system', elem.systemElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('type_') then
    for i := 0 to elem.type_.Count - 1 do
      ComposeEnum(xml, 'type', elem.type_[i], CODES_TFhirResourceTypesEnum);
  ComposeBoolean(xml, 'instance', elem.instanceElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('parameter') then
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeOperationDefinitionParameter(xml, 'parameter', elem.parameterList[i]);
end;

{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
function TFHIRXmlParser.ParseOperationOutcomeIssue(element : TMXmlElement; path : string) : TFhirOperationOutcomeIssue;
var
  child : TMXmlElement;
begin
  result := TFhirOperationOutcomeIssue.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseOperationOutcomeIssueChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseOperationOutcomeIssueChild(element : TFhirOperationOutcomeIssue; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'severity') then
        element.severityElement := ParseEnum(CODES_TFhirIssueSeverityEnum, SYSTEMS_TFhirIssueSeverityEnum, path+'/severity', child){1a}
      else if (child.localName = 'code') then
        element.codeElement := ParseEnum(CODES_TFhirIssueTypeEnum, SYSTEMS_TFhirIssueTypeEnum, path+'/code', child){1a}
      else if (child.localName = 'details') then
        element.details := ParseCodeableConcept(child, path+'/details') {b}
      else if (child.localName = 'diagnostics') then
        element.diagnosticsElement := ParseString(child, path+'/diagnostics') {b}
      else if (child.localName = 'location') then
        element.locationList.Add(ParseString(child, path+'/location')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeOperationOutcomeIssue(xml : TXmlBuilder; name : String; elem : TFhirOperationOutcomeIssue);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeOperationOutcomeIssueChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeOperationOutcomeIssueChildren(xml : TXmlBuilder; elem : TFhirOperationOutcomeIssue);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'severity', elem.SeverityElement, CODES_TFhirIssueSeverityEnum);
  ComposeEnum(xml, 'code', elem.CodeElement, CODES_TFhirIssueTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'details', elem.details);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'diagnostics', elem.diagnosticsElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.locationList.Count - 1 do
      ComposeString(xml, 'location', elem.locationList[i]);
end;

function TFHIRXmlParser.ParseOperationOutcome(element : TMXmlElement; path : string) : TFhirOperationOutcome;
var
  child : TMXmlElement;
begin
  result := TFhirOperationOutcome.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseOperationOutcomeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseOperationOutcomeChild(element : TFhirOperationOutcome; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'issue') then
        element.issueList.Add(ParseOperationOutcomeIssue(child, path+'/issue')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeOperationOutcome(xml : TXmlBuilder; name : String; elem : TFhirOperationOutcome);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeOperationOutcomeChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeOperationOutcomeChildren(xml : TXmlBuilder; elem : TFhirOperationOutcome);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.issueList.Count - 1 do
      ComposeOperationOutcomeIssue(xml, 'issue', elem.issueList[i]);
end;

{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORDER}
function TFHIRXmlParser.ParseOrderWhen(element : TMXmlElement; path : string) : TFhirOrderWhen;
var
  child : TMXmlElement;
begin
  result := TFhirOrderWhen.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseOrderWhenChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseOrderWhenChild(element : TFhirOrderWhen; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'schedule') then
        element.schedule := ParseTiming(child, path+'/schedule') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeOrderWhen(xml : TXmlBuilder; name : String; elem : TFhirOrderWhen);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeOrderWhenChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeOrderWhenChildren(xml : TXmlBuilder; elem : TFhirOrderWhen);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTiming(xml, 'schedule', elem.schedule);{x.2a}
end;

function TFHIRXmlParser.ParseOrder(element : TMXmlElement; path : string) : TFhirOrder;
var
  child : TMXmlElement;
begin
  result := TFhirOrder.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseOrderChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseOrderChild(element : TFhirOrder; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'source') then
        element.source := ParseReference{Resource}(child, path+'/source') {b}
      else if (child.localName = 'target') then
        element.target := ParseReference{Resource}(child, path+'/target') {b}
      else if (child.localName = 'reasonCodeableConcept') then
        element.reason := ParseCodeableConcept(child, path+'/reasonCodeableConcept'){x.3}
      else if (child.localName = 'reasonReference') then
        element.reason := ParseReference(child, path+'/reasonReference') {a}
      else if (child.localName = 'when') then
        element.when := ParseOrderWhen(child, path+'/when') {b}
      else if (child.localName = 'detail') then
        element.detailList.Add(ParseReference{TFhirReference}(child, path+'/detail')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeOrder(xml : TXmlBuilder; name : String; elem : TFhirOrder);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeOrderChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeOrderChildren(xml : TXmlBuilder; elem : TFhirOrder);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('source') then
    ComposeReference{Resource}(xml, 'source', elem.source);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('target') then
    ComposeReference{Resource}(xml, 'target', elem.target);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirReference) {2} then
    ComposeReference(xml, 'reasonReference', TFhirReference(elem.reason));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('when') then
    ComposeOrderWhen(xml, 'when', elem.when);{x.2a}
  for i := 0 to elem.detailList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'detail', elem.detailList[i]);
end;

{$ENDIF FHIR_ORDER}
{$IFDEF FHIR_ORDERRESPONSE}
function TFHIRXmlParser.ParseOrderResponse(element : TMXmlElement; path : string) : TFhirOrderResponse;
var
  child : TMXmlElement;
begin
  result := TFhirOrderResponse.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseOrderResponseChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseOrderResponseChild(element : TFhirOrderResponse; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'request') then
        element.request := ParseReference{TFhirOrder}(child, path+'/request') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'who') then
        element.who := ParseReference{Resource}(child, path+'/who') {b}
      else if (child.localName = 'orderStatus') then
        element.orderStatusElement := ParseEnum(CODES_TFhirOrderStatusEnum, SYSTEMS_TFhirOrderStatusEnum, path+'/orderStatus', child){1a}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'fulfillment') then
        element.fulfillmentList.Add(ParseReference{TFhirReference}(child, path+'/fulfillment')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeOrderResponse(xml : TXmlBuilder; name : String; elem : TFhirOrderResponse);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeOrderResponseChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeOrderResponseChildren(xml : TXmlBuilder; elem : TFhirOrderResponse);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{TFhirOrder}(xml, 'request', elem.request);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('who') then
    ComposeReference{Resource}(xml, 'who', elem.who);{x.2a}
  ComposeEnum(xml, 'orderStatus', elem.OrderStatusElement, CODES_TFhirOrderStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('fulfillment') then
    for i := 0 to elem.fulfillmentList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'fulfillment', elem.fulfillmentList[i]);
end;

{$ENDIF FHIR_ORDERRESPONSE}
{$IFDEF FHIR_ORGANIZATION}
function TFHIRXmlParser.ParseOrganizationContact(element : TMXmlElement; path : string) : TFhirOrganizationContact;
var
  child : TMXmlElement;
begin
  result := TFhirOrganizationContact.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseOrganizationContactChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseOrganizationContactChild(element : TFhirOrganizationContact; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'purpose') then
        element.purpose := ParseCodeableConcept(child, path+'/purpose') {b}
      else if (child.localName = 'name') then
        element.name := ParseHumanName(child, path+'/name') {b}
      else if (child.localName = 'telecom') then
        element.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.localName = 'address') then
        element.address := ParseAddress(child, path+'/address') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeOrganizationContact(xml : TXmlBuilder; name : String; elem : TFhirOrganizationContact);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeOrganizationContactChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeOrganizationContactChildren(xml : TXmlBuilder; elem : TFhirOrganizationContact);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'purpose', elem.purpose);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeHumanName(xml, 'name', elem.name);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeAddress(xml, 'address', elem.address);{x.2a}
end;

function TFHIRXmlParser.ParseOrganization(element : TMXmlElement; path : string) : TFhirOrganization;
var
  child : TMXmlElement;
begin
  result := TFhirOrganization.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseOrganizationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseOrganizationChild(element : TFhirOrganization; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'active') then
        element.activeElement := ParseBoolean(child, path+'/active') {b}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'telecom') then
        element.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.localName = 'address') then
        element.addressList.Add(ParseAddress(child, path+'/address')){y.2}
      else if (child.localName = 'partOf') then
        element.partOf := ParseReference{TFhirOrganization}(child, path+'/partOf') {b}
      else if (child.localName = 'contact') then
        element.contactList.Add(ParseOrganizationContact(child, path+'/contact')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeOrganization(xml : TXmlBuilder; name : String; elem : TFhirOrganization);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeOrganizationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeOrganizationChildren(xml : TXmlBuilder; elem : TFhirOrganization);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.active <> true)) and doCompose('active') then
    ComposeBoolean(xml, 'active', elem.activeElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('telecom') then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('address') then
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(xml, 'address', elem.addressList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('partOf') then
    ComposeReference{TFhirOrganization}(xml, 'partOf', elem.partOf);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeOrganizationContact(xml, 'contact', elem.contactList[i]);
end;

{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_PATIENT}
function TFHIRXmlParser.ParsePatientContact(element : TMXmlElement; path : string) : TFhirPatientContact;
var
  child : TMXmlElement;
begin
  result := TFhirPatientContact.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePatientContactChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePatientContactChild(element : TFhirPatientContact; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'relationship') then
        element.relationshipList.Add(ParseCodeableConcept(child, path+'/relationship')){y.2}
      else if (child.localName = 'name') then
        element.name := ParseHumanName(child, path+'/name') {b}
      else if (child.localName = 'telecom') then
        element.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.localName = 'address') then
        element.address := ParseAddress(child, path+'/address') {b}
      else if (child.localName = 'gender') then
        element.genderElement := ParseEnum(CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, path+'/gender', child){1a}
      else if (child.localName = 'organization') then
        element.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePatientContact(xml : TXmlBuilder; name : String; elem : TFhirPatientContact);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePatientContactChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePatientContactChildren(xml : TXmlBuilder; elem : TFhirPatientContact);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.relationshipList.Count - 1 do
      ComposeCodeableConcept(xml, 'relationship', elem.relationshipList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeHumanName(xml, 'name', elem.name);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeAddress(xml, 'address', elem.address);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
end;

function TFHIRXmlParser.ParsePatientAnimal(element : TMXmlElement; path : string) : TFhirPatientAnimal;
var
  child : TMXmlElement;
begin
  result := TFhirPatientAnimal.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePatientAnimalChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePatientAnimalChild(element : TFhirPatientAnimal; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'species') then
        element.species := ParseCodeableConcept(child, path+'/species') {b}
      else if (child.localName = 'breed') then
        element.breed := ParseCodeableConcept(child, path+'/breed') {b}
      else if (child.localName = 'genderStatus') then
        element.genderStatus := ParseCodeableConcept(child, path+'/genderStatus') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePatientAnimal(xml : TXmlBuilder; name : String; elem : TFhirPatientAnimal);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePatientAnimalChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePatientAnimalChildren(xml : TXmlBuilder; elem : TFhirPatientAnimal);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'species', elem.species);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'breed', elem.breed);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'genderStatus', elem.genderStatus);{x.2a}
end;

function TFHIRXmlParser.ParsePatientCommunication(element : TMXmlElement; path : string) : TFhirPatientCommunication;
var
  child : TMXmlElement;
begin
  result := TFhirPatientCommunication.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePatientCommunicationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePatientCommunicationChild(element : TFhirPatientCommunication; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'language') then
        element.language := ParseCodeableConcept(child, path+'/language') {b}
      else if (child.localName = 'preferred') then
        element.preferredElement := ParseBoolean(child, path+'/preferred') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePatientCommunication(xml : TXmlBuilder; name : String; elem : TFhirPatientCommunication);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePatientCommunicationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePatientCommunicationChildren(xml : TXmlBuilder; elem : TFhirPatientCommunication);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'language', elem.language);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'preferred', elem.preferredElement);{x.2b}
end;

function TFHIRXmlParser.ParsePatientLink(element : TMXmlElement; path : string) : TFhirPatientLink;
var
  child : TMXmlElement;
begin
  result := TFhirPatientLink.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePatientLinkChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePatientLinkChild(element : TFhirPatientLink; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'other') then
        element.other := ParseReference{TFhirPatient}(child, path+'/other') {b}
      else if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirLinkTypeEnum, SYSTEMS_TFhirLinkTypeEnum, path+'/type', child){1a}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePatientLink(xml : TXmlBuilder; name : String; elem : TFhirPatientLink);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePatientLinkChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePatientLinkChildren(xml : TXmlBuilder; elem : TFhirPatientLink);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeReference{TFhirPatient}(xml, 'other', elem.other);{x.2a}
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirLinkTypeEnum);
end;

function TFHIRXmlParser.ParsePatient(element : TMXmlElement; path : string) : TFhirPatient;
var
  child : TMXmlElement;
begin
  result := TFhirPatient.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePatientChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePatientChild(element : TFhirPatient; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'active') then
        element.activeElement := ParseBoolean(child, path+'/active') {b}
      else if (child.localName = 'name') then
        element.nameList.Add(ParseHumanName(child, path+'/name')){y.2}
      else if (child.localName = 'telecom') then
        element.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.localName = 'gender') then
        element.genderElement := ParseEnum(CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, path+'/gender', child){1a}
      else if (child.localName = 'birthDate') then
        element.birthDateElement := ParseDate(child, path+'/birthDate') {b}
      else if (child.localName = 'deceasedBoolean') then
        element.deceased := ParseBoolean(child, path+'/deceasedBoolean'){x.3}
      else if (child.localName = 'deceasedDateTime') then
        element.deceased := ParseDateTime(child, path+'/deceasedDateTime'){x.3}
      else if (child.localName = 'address') then
        element.addressList.Add(ParseAddress(child, path+'/address')){y.2}
      else if (child.localName = 'maritalStatus') then
        element.maritalStatus := ParseCodeableConcept(child, path+'/maritalStatus') {b}
      else if (child.localName = 'multipleBirthBoolean') then
        element.multipleBirth := ParseBoolean(child, path+'/multipleBirthBoolean'){x.3}
      else if (child.localName = 'multipleBirthInteger') then
        element.multipleBirth := ParseInteger(child, path+'/multipleBirthInteger'){x.3}
      else if (child.localName = 'photo') then
        element.photoList.Add(ParseAttachment(child, path+'/photo')){y.2}
      else if (child.localName = 'contact') then
        element.contactList.Add(ParsePatientContact(child, path+'/contact')){y.2}
      else if (child.localName = 'animal') then
        element.animal := ParsePatientAnimal(child, path+'/animal') {b}
      else if (child.localName = 'communication') then
        element.communicationList.Add(ParsePatientCommunication(child, path+'/communication')){y.2}
      else if (child.localName = 'careProvider') then
        element.careProviderList.Add(ParseReference{Resource}(child, path+'/careProvider')){y.2}
      else if (child.localName = 'managingOrganization') then
        element.managingOrganization := ParseReference{TFhirOrganization}(child, path+'/managingOrganization') {b}
      else if (child.localName = 'link') then
        element.link_List.Add(ParsePatientLink(child, path+'/link')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePatient(xml : TXmlBuilder; name : String; elem : TFhirPatient);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePatientChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePatientChildren(xml : TXmlBuilder; elem : TFhirPatient);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.active <> true)) and doCompose('active') then
    ComposeBoolean(xml, 'active', elem.activeElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    for i := 0 to elem.nameList.Count - 1 do
      ComposeHumanName(xml, 'name', elem.nameList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('telecom') then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gender') then
    ComposeEnum(xml, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('birthDate') then
    ComposeDate(xml, 'birthDate', elem.birthDateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.deceased is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'deceasedBoolean', TFhirBoolean(elem.deceased))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.deceased is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'deceasedDateTime', TFhirDateTime(elem.deceased));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('address') then
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(xml, 'address', elem.addressList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('maritalStatus') then
    ComposeCodeableConcept(xml, 'maritalStatus', elem.maritalStatus);{x.2a}
  if (SummaryOption in [soFull, soData]) and (elem.multipleBirth is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'multipleBirthBoolean', TFhirBoolean(elem.multipleBirth))
  else if (SummaryOption in [soFull, soData]) and (elem.multipleBirth is TFhirInteger) {6} then
    ComposeInteger(xml, 'multipleBirthInteger', TFhirInteger(elem.multipleBirth));
  if (SummaryOption in [soFull, soData]) and doCompose('photo') then
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(xml, 'photo', elem.photoList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposePatientContact(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('animal') then
    ComposePatientAnimal(xml, 'animal', elem.animal);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('communication') then
    for i := 0 to elem.communicationList.Count - 1 do
      ComposePatientCommunication(xml, 'communication', elem.communicationList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('careProvider') then
    for i := 0 to elem.careProviderList.Count - 1 do
      ComposeReference{Resource}(xml, 'careProvider', elem.careProviderList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('managingOrganization') then
    ComposeReference{TFhirOrganization}(xml, 'managingOrganization', elem.managingOrganization);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('link_') then
    for i := 0 to elem.link_List.Count - 1 do
      ComposePatientLink(xml, 'link', elem.link_List[i]);
end;

{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
function TFHIRXmlParser.ParsePaymentNotice(element : TMXmlElement; path : string) : TFhirPaymentNotice;
var
  child : TMXmlElement;
begin
  result := TFhirPaymentNotice.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePaymentNoticeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePaymentNoticeChild(element : TFhirPaymentNotice; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'ruleset') then
        element.ruleset := ParseCoding(child, path+'/ruleset') {b}
      else if (child.localName = 'originalRuleset') then
        element.originalRuleset := ParseCoding(child, path+'/originalRuleset') {b}
      else if (child.localName = 'created') then
        element.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.localName = 'target') then
        element.target := ParseReference{TFhirOrganization}(child, path+'/target') {b}
      else if (child.localName = 'provider') then
        element.provider := ParseReference{TFhirPractitioner}(child, path+'/provider') {b}
      else if (child.localName = 'organization') then
        element.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.localName = 'request') then
        element.request := ParseReference{TFhirReference}(child, path+'/request') {b}
      else if (child.localName = 'response') then
        element.response := ParseReference{TFhirReference}(child, path+'/response') {b}
      else if (child.localName = 'paymentStatus') then
        element.paymentStatus := ParseCoding(child, path+'/paymentStatus') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePaymentNotice(xml : TXmlBuilder; name : String; elem : TFhirPaymentNotice);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePaymentNoticeChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePaymentNoticeChildren(xml : TXmlBuilder; elem : TFhirPaymentNotice);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ruleset') then
    ComposeCoding(xml, 'ruleset', elem.ruleset);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('originalRuleset') then
    ComposeCoding(xml, 'originalRuleset', elem.originalRuleset);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTime(xml, 'created', elem.createdElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('target') then
    ComposeReference{TFhirOrganization}(xml, 'target', elem.target);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('provider') then
    ComposeReference{TFhirPractitioner}(xml, 'provider', elem.provider);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('request') then
    ComposeReference{TFhirReference}(xml, 'request', elem.request);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('response') then
    ComposeReference{TFhirReference}(xml, 'response', elem.response);{x.2a}
  ComposeCoding(xml, 'paymentStatus', elem.paymentStatus);{x.2a}
end;

{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
function TFHIRXmlParser.ParsePaymentReconciliationDetail(element : TMXmlElement; path : string) : TFhirPaymentReconciliationDetail;
var
  child : TMXmlElement;
begin
  result := TFhirPaymentReconciliationDetail.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePaymentReconciliationDetailChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePaymentReconciliationDetailChild(element : TFhirPaymentReconciliationDetail; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.localName = 'request') then
        element.request := ParseReference{TFhirReference}(child, path+'/request') {b}
      else if (child.localName = 'responce') then
        element.responce := ParseReference{TFhirReference}(child, path+'/responce') {b}
      else if (child.localName = 'submitter') then
        element.submitter := ParseReference{TFhirOrganization}(child, path+'/submitter') {b}
      else if (child.localName = 'payee') then
        element.payee := ParseReference{TFhirOrganization}(child, path+'/payee') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDate(child, path+'/date') {b}
      else if (child.localName = 'amount') then
        element.amount := ParseQuantity(child, path+'/amount') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePaymentReconciliationDetail(xml : TXmlBuilder; name : String; elem : TFhirPaymentReconciliationDetail);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePaymentReconciliationDetailChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePaymentReconciliationDetailChildren(xml : TXmlBuilder; elem : TFhirPaymentReconciliationDetail);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCoding(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(xml, 'request', elem.request);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirReference}(xml, 'responce', elem.responce);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'submitter', elem.submitter);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'payee', elem.payee);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDate(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'amount', elem.amount);{x.2a}
end;

function TFHIRXmlParser.ParsePaymentReconciliationNote(element : TMXmlElement; path : string) : TFhirPaymentReconciliationNote;
var
  child : TMXmlElement;
begin
  result := TFhirPaymentReconciliationNote.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePaymentReconciliationNoteChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePaymentReconciliationNoteChild(element : TFhirPaymentReconciliationNote; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.localName = 'text') then
        element.textElement := ParseString(child, path+'/text') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePaymentReconciliationNote(xml : TXmlBuilder; name : String; elem : TFhirPaymentReconciliationNote);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePaymentReconciliationNoteChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePaymentReconciliationNoteChildren(xml : TXmlBuilder; elem : TFhirPaymentReconciliationNote);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2b}
end;

function TFHIRXmlParser.ParsePaymentReconciliation(element : TMXmlElement; path : string) : TFhirPaymentReconciliation;
var
  child : TMXmlElement;
begin
  result := TFhirPaymentReconciliation.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePaymentReconciliationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePaymentReconciliationChild(element : TFhirPaymentReconciliation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'request') then
        element.request := ParseReference{TFhirProcessRequest}(child, path+'/request') {b}
      else if (child.localName = 'outcome') then
        element.outcomeElement := ParseEnum(CODES_TFhirRemittanceOutcomeEnum, SYSTEMS_TFhirRemittanceOutcomeEnum, path+'/outcome', child){1a}
      else if (child.localName = 'disposition') then
        element.dispositionElement := ParseString(child, path+'/disposition') {b}
      else if (child.localName = 'ruleset') then
        element.ruleset := ParseCoding(child, path+'/ruleset') {b}
      else if (child.localName = 'originalRuleset') then
        element.originalRuleset := ParseCoding(child, path+'/originalRuleset') {b}
      else if (child.localName = 'created') then
        element.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if (child.localName = 'organization') then
        element.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.localName = 'requestProvider') then
        element.requestProvider := ParseReference{TFhirPractitioner}(child, path+'/requestProvider') {b}
      else if (child.localName = 'requestOrganization') then
        element.requestOrganization := ParseReference{TFhirOrganization}(child, path+'/requestOrganization') {b}
      else if (child.localName = 'detail') then
        element.detailList.Add(ParsePaymentReconciliationDetail(child, path+'/detail')){y.2}
      else if (child.localName = 'form') then
        element.form := ParseCoding(child, path+'/form') {b}
      else if (child.localName = 'total') then
        element.total := ParseQuantity(child, path+'/total') {b}
      else if (child.localName = 'note') then
        element.noteList.Add(ParsePaymentReconciliationNote(child, path+'/note')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePaymentReconciliation(xml : TXmlBuilder; name : String; elem : TFhirPaymentReconciliation);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePaymentReconciliationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePaymentReconciliationChildren(xml : TXmlBuilder; elem : TFhirPaymentReconciliation);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('request') then
    ComposeReference{TFhirProcessRequest}(xml, 'request', elem.request);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcome') then
    ComposeEnum(xml, 'outcome', elem.OutcomeElement, CODES_TFhirRemittanceOutcomeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('disposition') then
    ComposeString(xml, 'disposition', elem.dispositionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ruleset') then
    ComposeCoding(xml, 'ruleset', elem.ruleset);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('originalRuleset') then
    ComposeCoding(xml, 'originalRuleset', elem.originalRuleset);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTime(xml, 'created', elem.createdElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestProvider') then
    ComposeReference{TFhirPractitioner}(xml, 'requestProvider', elem.requestProvider);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestOrganization') then
    ComposeReference{TFhirOrganization}(xml, 'requestOrganization', elem.requestOrganization);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('detail') then
    for i := 0 to elem.detailList.Count - 1 do
      ComposePaymentReconciliationDetail(xml, 'detail', elem.detailList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('form') then
    ComposeCoding(xml, 'form', elem.form);{x.2a}
  ComposeQuantity(xml, 'total', elem.total);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('note') then
    for i := 0 to elem.noteList.Count - 1 do
      ComposePaymentReconciliationNote(xml, 'note', elem.noteList[i]);
end;

{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
function TFHIRXmlParser.ParsePersonLink(element : TMXmlElement; path : string) : TFhirPersonLink;
var
  child : TMXmlElement;
begin
  result := TFhirPersonLink.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePersonLinkChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePersonLinkChild(element : TFhirPersonLink; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'target') then
        element.target := ParseReference{Resource}(child, path+'/target') {b}
      else if (child.localName = 'assurance') then
        element.assuranceElement := ParseEnum(CODES_TFhirIdentityAssuranceLevelEnum, SYSTEMS_TFhirIdentityAssuranceLevelEnum, path+'/assurance', child){1a}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePersonLink(xml : TXmlBuilder; name : String; elem : TFhirPersonLink);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePersonLinkChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePersonLinkChildren(xml : TXmlBuilder; elem : TFhirPersonLink);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeReference{Resource}(xml, 'target', elem.target);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'assurance', elem.AssuranceElement, CODES_TFhirIdentityAssuranceLevelEnum);
end;

function TFHIRXmlParser.ParsePerson(element : TMXmlElement; path : string) : TFhirPerson;
var
  child : TMXmlElement;
begin
  result := TFhirPerson.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePersonChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePersonChild(element : TFhirPerson; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'name') then
        element.nameList.Add(ParseHumanName(child, path+'/name')){y.2}
      else if (child.localName = 'telecom') then
        element.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.localName = 'gender') then
        element.genderElement := ParseEnum(CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, path+'/gender', child){1a}
      else if (child.localName = 'birthDate') then
        element.birthDateElement := ParseDate(child, path+'/birthDate') {b}
      else if (child.localName = 'address') then
        element.addressList.Add(ParseAddress(child, path+'/address')){y.2}
      else if (child.localName = 'photo') then
        element.photo := ParseAttachment(child, path+'/photo') {b}
      else if (child.localName = 'managingOrganization') then
        element.managingOrganization := ParseReference{TFhirOrganization}(child, path+'/managingOrganization') {b}
      else if (child.localName = 'active') then
        element.activeElement := ParseBoolean(child, path+'/active') {b}
      else if (child.localName = 'link') then
        element.link_List.Add(ParsePersonLink(child, path+'/link')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePerson(xml : TXmlBuilder; name : String; elem : TFhirPerson);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePersonChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePersonChildren(xml : TXmlBuilder; elem : TFhirPerson);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    for i := 0 to elem.nameList.Count - 1 do
      ComposeHumanName(xml, 'name', elem.nameList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('telecom') then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gender') then
    ComposeEnum(xml, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('birthDate') then
    ComposeDate(xml, 'birthDate', elem.birthDateElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('address') then
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(xml, 'address', elem.addressList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('photo') then
    ComposeAttachment(xml, 'photo', elem.photo);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('managingOrganization') then
    ComposeReference{TFhirOrganization}(xml, 'managingOrganization', elem.managingOrganization);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('active') then
    ComposeBoolean(xml, 'active', elem.activeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('link_') then
    for i := 0 to elem.link_List.Count - 1 do
      ComposePersonLink(xml, 'link', elem.link_List[i]);
end;

{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PRACTITIONER}
function TFHIRXmlParser.ParsePractitionerPractitionerRole(element : TMXmlElement; path : string) : TFhirPractitionerPractitionerRole;
var
  child : TMXmlElement;
begin
  result := TFhirPractitionerPractitionerRole.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePractitionerPractitionerRoleChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePractitionerPractitionerRoleChild(element : TFhirPractitionerPractitionerRole; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'managingOrganization') then
        element.managingOrganization := ParseReference{TFhirOrganization}(child, path+'/managingOrganization') {b}
      else if (child.localName = 'role') then
        element.role := ParseCodeableConcept(child, path+'/role') {b}
      else if (child.localName = 'specialty') then
        element.specialtyList.Add(ParseCodeableConcept(child, path+'/specialty')){y.2}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if (child.localName = 'location') then
        element.locationList.Add(ParseReference{TFhirLocation}(child, path+'/location')){y.2}
      else if (child.localName = 'healthcareService') then
        element.healthcareServiceList.Add(ParseReference{TFhirHealthcareService}(child, path+'/healthcareService')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePractitionerPractitionerRole(xml : TXmlBuilder; name : String; elem : TFhirPractitionerPractitionerRole);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePractitionerPractitionerRoleChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePractitionerPractitionerRoleChildren(xml : TXmlBuilder; elem : TFhirPractitionerPractitionerRole);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'managingOrganization', elem.managingOrganization);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'role', elem.role);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.specialtyList.Count - 1 do
      ComposeCodeableConcept(xml, 'specialty', elem.specialtyList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.locationList.Count - 1 do
      ComposeReference{TFhirLocation}(xml, 'location', elem.locationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.healthcareServiceList.Count - 1 do
      ComposeReference{TFhirHealthcareService}(xml, 'healthcareService', elem.healthcareServiceList[i]);
end;

function TFHIRXmlParser.ParsePractitionerQualification(element : TMXmlElement; path : string) : TFhirPractitionerQualification;
var
  child : TMXmlElement;
begin
  result := TFhirPractitionerQualification.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePractitionerQualificationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePractitionerQualificationChild(element : TFhirPractitionerQualification; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if (child.localName = 'issuer') then
        element.issuer := ParseReference{TFhirOrganization}(child, path+'/issuer') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePractitionerQualification(xml : TXmlBuilder; name : String; elem : TFhirPractitionerQualification);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePractitionerQualificationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePractitionerQualificationChildren(xml : TXmlBuilder; elem : TFhirPractitionerQualification);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirOrganization}(xml, 'issuer', elem.issuer);{x.2a}
end;

function TFHIRXmlParser.ParsePractitioner(element : TMXmlElement; path : string) : TFhirPractitioner;
var
  child : TMXmlElement;
begin
  result := TFhirPractitioner.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParsePractitionerChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePractitionerChild(element : TFhirPractitioner; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'active') then
        element.activeElement := ParseBoolean(child, path+'/active') {b}
      else if (child.localName = 'name') then
        element.name := ParseHumanName(child, path+'/name') {b}
      else if (child.localName = 'telecom') then
        element.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.localName = 'address') then
        element.addressList.Add(ParseAddress(child, path+'/address')){y.2}
      else if (child.localName = 'gender') then
        element.genderElement := ParseEnum(CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, path+'/gender', child){1a}
      else if (child.localName = 'birthDate') then
        element.birthDateElement := ParseDate(child, path+'/birthDate') {b}
      else if (child.localName = 'photo') then
        element.photoList.Add(ParseAttachment(child, path+'/photo')){y.2}
      else if (child.localName = 'practitionerRole') then
        element.practitionerRoleList.Add(ParsePractitionerPractitionerRole(child, path+'/practitionerRole')){y.2}
      else if (child.localName = 'qualification') then
        element.qualificationList.Add(ParsePractitionerQualification(child, path+'/qualification')){y.2}
      else if (child.localName = 'communication') then
        element.communicationList.Add(ParseCodeableConcept(child, path+'/communication')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposePractitioner(xml : TXmlBuilder; name : String; elem : TFhirPractitioner);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composePractitionerChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposePractitionerChildren(xml : TXmlBuilder; elem : TFhirPractitioner);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (not isCanonical or (elem.active <> true)) and doCompose('active') then
    ComposeBoolean(xml, 'active', elem.activeElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeHumanName(xml, 'name', elem.name);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('telecom') then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('address') then
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(xml, 'address', elem.addressList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gender') then
    ComposeEnum(xml, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('birthDate') then
    ComposeDate(xml, 'birthDate', elem.birthDateElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('photo') then
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(xml, 'photo', elem.photoList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('practitionerRole') then
    for i := 0 to elem.practitionerRoleList.Count - 1 do
      ComposePractitionerPractitionerRole(xml, 'practitionerRole', elem.practitionerRoleList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('qualification') then
    for i := 0 to elem.qualificationList.Count - 1 do
      ComposePractitionerQualification(xml, 'qualification', elem.qualificationList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('communication') then
    for i := 0 to elem.communicationList.Count - 1 do
      ComposeCodeableConcept(xml, 'communication', elem.communicationList[i]);
end;

{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PROCEDURE}
function TFHIRXmlParser.ParseProcedurePerformer(element : TMXmlElement; path : string) : TFhirProcedurePerformer;
var
  child : TMXmlElement;
begin
  result := TFhirProcedurePerformer.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseProcedurePerformerChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseProcedurePerformerChild(element : TFhirProcedurePerformer; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'actor') then
        element.actor := ParseReference{Resource}(child, path+'/actor') {b}
      else if (child.localName = 'role') then
        element.role := ParseCodeableConcept(child, path+'/role') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeProcedurePerformer(xml : TXmlBuilder; name : String; elem : TFhirProcedurePerformer);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeProcedurePerformerChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeProcedurePerformerChildren(xml : TXmlBuilder; elem : TFhirProcedurePerformer);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'actor', elem.actor);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'role', elem.role);{x.2a}
end;

function TFHIRXmlParser.ParseProcedureFocalDevice(element : TMXmlElement; path : string) : TFhirProcedureFocalDevice;
var
  child : TMXmlElement;
begin
  result := TFhirProcedureFocalDevice.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseProcedureFocalDeviceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseProcedureFocalDeviceChild(element : TFhirProcedureFocalDevice; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'action') then
        element.action := ParseCodeableConcept(child, path+'/action') {b}
      else if (child.localName = 'manipulated') then
        element.manipulated := ParseReference{TFhirDevice}(child, path+'/manipulated') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeProcedureFocalDevice(xml : TXmlBuilder; name : String; elem : TFhirProcedureFocalDevice);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeProcedureFocalDeviceChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeProcedureFocalDeviceChildren(xml : TXmlBuilder; elem : TFhirProcedureFocalDevice);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'action', elem.action);{x.2a}
  ComposeReference{TFhirDevice}(xml, 'manipulated', elem.manipulated);{x.2a}
end;

function TFHIRXmlParser.ParseProcedure(element : TMXmlElement; path : string) : TFhirProcedure;
var
  child : TMXmlElement;
begin
  result := TFhirProcedure.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseProcedureChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseProcedureChild(element : TFhirProcedure; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirProcedureStatusEnum, SYSTEMS_TFhirProcedureStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'category') then
        element.category := ParseCodeableConcept(child, path+'/category') {b}
      else if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'notPerformed') then
        element.notPerformedElement := ParseBoolean(child, path+'/notPerformed') {b}
      else if (child.localName = 'reasonNotPerformed') then
        element.reasonNotPerformedList.Add(ParseCodeableConcept(child, path+'/reasonNotPerformed')){y.2}
      else if (child.localName = 'bodySite') then
        element.bodySiteList.Add(ParseCodeableConcept(child, path+'/bodySite')){y.2}
      else if (child.localName = 'reasonCodeableConcept') then
        element.reason := ParseCodeableConcept(child, path+'/reasonCodeableConcept'){x.3}
      else if (child.localName = 'reasonReference') then
        element.reason := ParseReference(child, path+'/reasonReference') {a}
      else if (child.localName = 'performer') then
        element.performerList.Add(ParseProcedurePerformer(child, path+'/performer')){y.2}
      else if (child.localName = 'performedPeriod') then
        element.performed := ParsePeriod(child, path+'/performedPeriod'){x.3}
      else if (child.localName = 'performedDateTime') then
        element.performed := ParseDateTime(child, path+'/performedDateTime'){x.3}
      else if (child.localName = 'encounter') then
        element.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.localName = 'location') then
        element.location := ParseReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.localName = 'outcome') then
        element.outcome := ParseCodeableConcept(child, path+'/outcome') {b}
      else if (child.localName = 'report') then
        element.reportList.Add(ParseReference{TFhirDiagnosticReport}(child, path+'/report')){y.2}
      else if (child.localName = 'complication') then
        element.complicationList.Add(ParseCodeableConcept(child, path+'/complication')){y.2}
      else if (child.localName = 'followUp') then
        element.followUpList.Add(ParseCodeableConcept(child, path+'/followUp')){y.2}
      else if (child.localName = 'request') then
        element.request := ParseReference{Resource}(child, path+'/request') {b}
      else if (child.localName = 'notes') then
        element.notesList.Add(ParseAnnotation(child, path+'/notes')){y.2}
      else if (child.localName = 'focalDevice') then
        element.focalDeviceList.Add(ParseProcedureFocalDevice(child, path+'/focalDevice')){y.2}
      else if (child.localName = 'used') then
        element.usedList.Add(ParseReference{Resource}(child, path+'/used')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeProcedure(xml : TXmlBuilder; name : String; elem : TFhirProcedure);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeProcedureChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeProcedureChildren(xml : TXmlBuilder; elem : TFhirProcedure);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirProcedureStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    ComposeCodeableConcept(xml, 'category', elem.category);{x.2a}
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.notPerformed <> false)) and doCompose('notPerformed') then
    ComposeBoolean(xml, 'notPerformed', elem.notPerformedElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('reasonNotPerformed') then
    for i := 0 to elem.reasonNotPerformedList.Count - 1 do
      ComposeCodeableConcept(xml, 'reasonNotPerformed', elem.reasonNotPerformedList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('bodySite') then
    for i := 0 to elem.bodySiteList.Count - 1 do
      ComposeCodeableConcept(xml, 'bodySite', elem.bodySiteList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirReference) {2} then
    ComposeReference(xml, 'reasonReference', TFhirReference(elem.reason));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') then
    for i := 0 to elem.performerList.Count - 1 do
      ComposeProcedurePerformer(xml, 'performer', elem.performerList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.performed is TFhirPeriod) {6} then
    ComposePeriod(xml, 'performedPeriod', TFhirPeriod(elem.performed))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.performed is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'performedDateTime', TFhirDateTime(elem.performed));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('location') then
    ComposeReference{TFhirLocation}(xml, 'location', elem.location);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcome') then
    ComposeCodeableConcept(xml, 'outcome', elem.outcome);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('report') then
    for i := 0 to elem.reportList.Count - 1 do
      ComposeReference{TFhirDiagnosticReport}(xml, 'report', elem.reportList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('complication') then
    for i := 0 to elem.complicationList.Count - 1 do
      ComposeCodeableConcept(xml, 'complication', elem.complicationList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('followUp') then
    for i := 0 to elem.followUpList.Count - 1 do
      ComposeCodeableConcept(xml, 'followUp', elem.followUpList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('request') then
    ComposeReference{Resource}(xml, 'request', elem.request);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('notes') then
    for i := 0 to elem.notesList.Count - 1 do
      ComposeAnnotation(xml, 'notes', elem.notesList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('focalDevice') then
    for i := 0 to elem.focalDeviceList.Count - 1 do
      ComposeProcedureFocalDevice(xml, 'focalDevice', elem.focalDeviceList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('used') then
    for i := 0 to elem.usedList.Count - 1 do
      ComposeReference{Resource}(xml, 'used', elem.usedList[i]);
end;

{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROCEDUREREQUEST}
function TFHIRXmlParser.ParseProcedureRequest(element : TMXmlElement; path : string) : TFhirProcedureRequest;
var
  child : TMXmlElement;
begin
  result := TFhirProcedureRequest.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseProcedureRequestChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseProcedureRequestChild(element : TFhirProcedureRequest; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'bodySite') then
        element.bodySiteList.Add(ParseCodeableConcept(child, path+'/bodySite')){y.2}
      else if (child.localName = 'reasonCodeableConcept') then
        element.reason := ParseCodeableConcept(child, path+'/reasonCodeableConcept'){x.3}
      else if (child.localName = 'reasonReference') then
        element.reason := ParseReference(child, path+'/reasonReference') {a}
      else if (child.localName = 'scheduledPeriod') then
        element.scheduled := ParsePeriod(child, path+'/scheduledPeriod'){x.3}
      else if (child.localName = 'scheduledTiming') then
        element.scheduled := ParseTiming(child, path+'/scheduledTiming'){x.3}
      else if (child.localName = 'scheduledDateTime') then
        element.scheduled := ParseDateTime(child, path+'/scheduledDateTime'){x.3}
      else if (child.localName = 'encounter') then
        element.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.localName = 'performer') then
        element.performer := ParseReference{Resource}(child, path+'/performer') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirProcedureRequestStatusEnum, SYSTEMS_TFhirProcedureRequestStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'notes') then
        element.notesList.Add(ParseAnnotation(child, path+'/notes')){y.2}
      else if (child.localName = 'asNeededCodeableConcept') then
        element.asNeeded := ParseCodeableConcept(child, path+'/asNeededCodeableConcept'){x.3}
      else if (child.localName = 'asNeededBoolean') then
        element.asNeeded := ParseBoolean(child, path+'/asNeededBoolean'){x.3}
      else if (child.localName = 'orderedOn') then
        element.orderedOnElement := ParseDateTime(child, path+'/orderedOn') {b}
      else if (child.localName = 'orderer') then
        element.orderer := ParseReference{Resource}(child, path+'/orderer') {b}
      else if (child.localName = 'priority') then
        element.priorityElement := ParseEnum(CODES_TFhirProcedureRequestPriorityEnum, SYSTEMS_TFhirProcedureRequestPriorityEnum, path+'/priority', child){1a}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeProcedureRequest(xml : TXmlBuilder; name : String; elem : TFhirProcedureRequest);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeProcedureRequestChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeProcedureRequestChildren(xml : TXmlBuilder; elem : TFhirProcedureRequest);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('bodySite') then
    for i := 0 to elem.bodySiteList.Count - 1 do
      ComposeCodeableConcept(xml, 'bodySite', elem.bodySiteList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirReference) {2} then
    ComposeReference(xml, 'reasonReference', TFhirReference(elem.reason));
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.scheduled is TFhirPeriod) {6} then
    ComposePeriod(xml, 'scheduledPeriod', TFhirPeriod(elem.scheduled))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.scheduled is TFhirTiming) {6} then
    ComposeTiming(xml, 'scheduledTiming', TFhirTiming(elem.scheduled))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.scheduled is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'scheduledDateTime', TFhirDateTime(elem.scheduled));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') then
    ComposeReference{Resource}(xml, 'performer', elem.performer);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirProcedureRequestStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('notes') then
    for i := 0 to elem.notesList.Count - 1 do
      ComposeAnnotation(xml, 'notes', elem.notesList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'asNeededCodeableConcept', TFhirCodeableConcept(elem.asNeeded))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.asNeeded is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'asNeededBoolean', TFhirBoolean(elem.asNeeded));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('orderedOn') then
    ComposeDateTime(xml, 'orderedOn', elem.orderedOnElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('orderer') then
    ComposeReference{Resource}(xml, 'orderer', elem.orderer);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeEnum(xml, 'priority', elem.PriorityElement, CODES_TFhirProcedureRequestPriorityEnum);
end;

{$ENDIF FHIR_PROCEDUREREQUEST}
{$IFDEF FHIR_PROCESSREQUEST}
function TFHIRXmlParser.ParseProcessRequestItem(element : TMXmlElement; path : string) : TFhirProcessRequestItem;
var
  child : TMXmlElement;
begin
  result := TFhirProcessRequestItem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseProcessRequestItemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseProcessRequestItemChild(element : TFhirProcessRequestItem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'sequenceLinkId') then
        element.sequenceLinkIdElement := ParseInteger(child, path+'/sequenceLinkId') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeProcessRequestItem(xml : TXmlBuilder; name : String; elem : TFhirProcessRequestItem);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeProcessRequestItemChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeProcessRequestItemChildren(xml : TXmlBuilder; elem : TFhirProcessRequestItem);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeInteger(xml, 'sequenceLinkId', elem.sequenceLinkIdElement);{x.2b}
end;

function TFHIRXmlParser.ParseProcessRequest(element : TMXmlElement; path : string) : TFhirProcessRequest;
var
  child : TMXmlElement;
begin
  result := TFhirProcessRequest.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseProcessRequestChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseProcessRequestChild(element : TFhirProcessRequest; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'action') then
        element.actionElement := ParseEnum(CODES_TFhirActionlistEnum, SYSTEMS_TFhirActionlistEnum, path+'/action', child){1a}
      else if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'ruleset') then
        element.ruleset := ParseCoding(child, path+'/ruleset') {b}
      else if (child.localName = 'originalRuleset') then
        element.originalRuleset := ParseCoding(child, path+'/originalRuleset') {b}
      else if (child.localName = 'created') then
        element.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.localName = 'target') then
        element.target := ParseReference{TFhirOrganization}(child, path+'/target') {b}
      else if (child.localName = 'provider') then
        element.provider := ParseReference{TFhirPractitioner}(child, path+'/provider') {b}
      else if (child.localName = 'organization') then
        element.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.localName = 'request') then
        element.request := ParseReference{TFhirReference}(child, path+'/request') {b}
      else if (child.localName = 'response') then
        element.response := ParseReference{TFhirReference}(child, path+'/response') {b}
      else if (child.localName = 'nullify') then
        element.nullifyElement := ParseBoolean(child, path+'/nullify') {b}
      else if (child.localName = 'reference') then
        element.referenceElement := ParseString(child, path+'/reference') {b}
      else if (child.localName = 'item') then
        element.itemList.Add(ParseProcessRequestItem(child, path+'/item')){y.2}
      else if (child.localName = 'include') then
        element.includeList.Add(ParseString(child, path+'/include')){y.2}
      else if (child.localName = 'exclude') then
        element.excludeList.Add(ParseString(child, path+'/exclude')){y.2}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeProcessRequest(xml : TXmlBuilder; name : String; elem : TFhirProcessRequest);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeProcessRequestChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeProcessRequestChildren(xml : TXmlBuilder; elem : TFhirProcessRequest);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  ComposeEnum(xml, 'action', elem.ActionElement, CODES_TFhirActionlistEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ruleset') then
    ComposeCoding(xml, 'ruleset', elem.ruleset);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('originalRuleset') then
    ComposeCoding(xml, 'originalRuleset', elem.originalRuleset);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTime(xml, 'created', elem.createdElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('target') then
    ComposeReference{TFhirOrganization}(xml, 'target', elem.target);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('provider') then
    ComposeReference{TFhirPractitioner}(xml, 'provider', elem.provider);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('request') then
    ComposeReference{TFhirReference}(xml, 'request', elem.request);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('response') then
    ComposeReference{TFhirReference}(xml, 'response', elem.response);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('nullify') then
    ComposeBoolean(xml, 'nullify', elem.nullifyElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reference') then
    ComposeString(xml, 'reference', elem.referenceElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('item') then
    for i := 0 to elem.itemList.Count - 1 do
      ComposeProcessRequestItem(xml, 'item', elem.itemList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('include') then
    for i := 0 to elem.includeList.Count - 1 do
      ComposeString(xml, 'include', elem.includeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('exclude') then
    for i := 0 to elem.excludeList.Count - 1 do
      ComposeString(xml, 'exclude', elem.excludeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
end;

{$ENDIF FHIR_PROCESSREQUEST}
{$IFDEF FHIR_PROCESSRESPONSE}
function TFHIRXmlParser.ParseProcessResponseNotes(element : TMXmlElement; path : string) : TFhirProcessResponseNotes;
var
  child : TMXmlElement;
begin
  result := TFhirProcessResponseNotes.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseProcessResponseNotesChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseProcessResponseNotesChild(element : TFhirProcessResponseNotes; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.localName = 'text') then
        element.textElement := ParseString(child, path+'/text') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeProcessResponseNotes(xml : TXmlBuilder; name : String; elem : TFhirProcessResponseNotes);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeProcessResponseNotesChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeProcessResponseNotesChildren(xml : TXmlBuilder; elem : TFhirProcessResponseNotes);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCoding(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2b}
end;

function TFHIRXmlParser.ParseProcessResponse(element : TMXmlElement; path : string) : TFhirProcessResponse;
var
  child : TMXmlElement;
begin
  result := TFhirProcessResponse.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseProcessResponseChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseProcessResponseChild(element : TFhirProcessResponse; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'request') then
        element.request := ParseReference{TFhirReference}(child, path+'/request') {b}
      else if (child.localName = 'outcome') then
        element.outcome := ParseCoding(child, path+'/outcome') {b}
      else if (child.localName = 'disposition') then
        element.dispositionElement := ParseString(child, path+'/disposition') {b}
      else if (child.localName = 'ruleset') then
        element.ruleset := ParseCoding(child, path+'/ruleset') {b}
      else if (child.localName = 'originalRuleset') then
        element.originalRuleset := ParseCoding(child, path+'/originalRuleset') {b}
      else if (child.localName = 'created') then
        element.createdElement := ParseDateTime(child, path+'/created') {b}
      else if (child.localName = 'organization') then
        element.organization := ParseReference{TFhirOrganization}(child, path+'/organization') {b}
      else if (child.localName = 'requestProvider') then
        element.requestProvider := ParseReference{TFhirPractitioner}(child, path+'/requestProvider') {b}
      else if (child.localName = 'requestOrganization') then
        element.requestOrganization := ParseReference{TFhirOrganization}(child, path+'/requestOrganization') {b}
      else if (child.localName = 'form') then
        element.form := ParseCoding(child, path+'/form') {b}
      else if (child.localName = 'notes') then
        element.notesList.Add(ParseProcessResponseNotes(child, path+'/notes')){y.2}
      else if (child.localName = 'error') then
        element.errorList.Add(ParseCoding(child, path+'/error')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeProcessResponse(xml : TXmlBuilder; name : String; elem : TFhirProcessResponse);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeProcessResponseChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeProcessResponseChildren(xml : TXmlBuilder; elem : TFhirProcessResponse);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('request') then
    ComposeReference{TFhirReference}(xml, 'request', elem.request);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('outcome') then
    ComposeCoding(xml, 'outcome', elem.outcome);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('disposition') then
    ComposeString(xml, 'disposition', elem.dispositionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ruleset') then
    ComposeCoding(xml, 'ruleset', elem.ruleset);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('originalRuleset') then
    ComposeCoding(xml, 'originalRuleset', elem.originalRuleset);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('created') then
    ComposeDateTime(xml, 'created', elem.createdElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('organization') then
    ComposeReference{TFhirOrganization}(xml, 'organization', elem.organization);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestProvider') then
    ComposeReference{TFhirPractitioner}(xml, 'requestProvider', elem.requestProvider);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requestOrganization') then
    ComposeReference{TFhirOrganization}(xml, 'requestOrganization', elem.requestOrganization);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('form') then
    ComposeCoding(xml, 'form', elem.form);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('notes') then
    for i := 0 to elem.notesList.Count - 1 do
      ComposeProcessResponseNotes(xml, 'notes', elem.notesList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('error') then
    for i := 0 to elem.errorList.Count - 1 do
      ComposeCoding(xml, 'error', elem.errorList[i]);
end;

{$ENDIF FHIR_PROCESSRESPONSE}
{$IFDEF FHIR_PROVENANCE}
function TFHIRXmlParser.ParseProvenanceAgent(element : TMXmlElement; path : string) : TFhirProvenanceAgent;
var
  child : TMXmlElement;
begin
  result := TFhirProvenanceAgent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseProvenanceAgentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseProvenanceAgentChild(element : TFhirProvenanceAgent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'role') then
        element.role := ParseCoding(child, path+'/role') {b}
      else if (child.localName = 'actor') then
        element.actor := ParseReference{Resource}(child, path+'/actor') {b}
      else if (child.localName = 'userId') then
        element.userId := ParseIdentifier(child, path+'/userId') {b}
      else if (child.localName = 'relatedAgent') then
        element.relatedAgentList.Add(ParseProvenanceAgentRelatedAgent(child, path+'/relatedAgent')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeProvenanceAgent(xml : TXmlBuilder; name : String; elem : TFhirProvenanceAgent);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeProvenanceAgentChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeProvenanceAgentChildren(xml : TXmlBuilder; elem : TFhirProvenanceAgent);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCoding(xml, 'role', elem.role);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{Resource}(xml, 'actor', elem.actor);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'userId', elem.userId);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.relatedAgentList.Count - 1 do
      ComposeProvenanceAgentRelatedAgent(xml, 'relatedAgent', elem.relatedAgentList[i]);
end;

function TFHIRXmlParser.ParseProvenanceAgentRelatedAgent(element : TMXmlElement; path : string) : TFhirProvenanceAgentRelatedAgent;
var
  child : TMXmlElement;
begin
  result := TFhirProvenanceAgentRelatedAgent.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseProvenanceAgentRelatedAgentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseProvenanceAgentRelatedAgentChild(element : TFhirProvenanceAgentRelatedAgent; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'target') then
        element.targetElement := ParseUri(child, path+'/target') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeProvenanceAgentRelatedAgent(xml : TXmlBuilder; name : String; elem : TFhirProvenanceAgentRelatedAgent);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeProvenanceAgentRelatedAgentChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeProvenanceAgentRelatedAgentChildren(xml : TXmlBuilder; elem : TFhirProvenanceAgentRelatedAgent);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  ComposeUri(xml, 'target', elem.targetElement);{x.2b}
end;

function TFHIRXmlParser.ParseProvenanceEntity(element : TMXmlElement; path : string) : TFhirProvenanceEntity;
var
  child : TMXmlElement;
begin
  result := TFhirProvenanceEntity.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseProvenanceEntityChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseProvenanceEntityChild(element : TFhirProvenanceEntity; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'role') then
        element.roleElement := ParseEnum(CODES_TFhirProvenanceEntityRoleEnum, SYSTEMS_TFhirProvenanceEntityRoleEnum, path+'/role', child){1a}
      else if (child.localName = 'type') then
        element.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.localName = 'reference') then
        element.referenceElement := ParseUri(child, path+'/reference') {b}
      else if (child.localName = 'display') then
        element.displayElement := ParseString(child, path+'/display') {b}
      else if (child.localName = 'agent') then
        element.agent := ParseProvenanceAgent(child, path+'/agent') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeProvenanceEntity(xml : TXmlBuilder; name : String; elem : TFhirProvenanceEntity);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeProvenanceEntityChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeProvenanceEntityChildren(xml : TXmlBuilder; elem : TFhirProvenanceEntity);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'role', elem.RoleElement, CODES_TFhirProvenanceEntityRoleEnum);
  ComposeCoding(xml, 'type', elem.type_);{x.2a}
  ComposeUri(xml, 'reference', elem.referenceElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'display', elem.displayElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeProvenanceAgent(xml, 'agent', elem.agent);{x.2a}
end;

function TFHIRXmlParser.ParseProvenance(element : TMXmlElement; path : string) : TFhirProvenance;
var
  child : TMXmlElement;
begin
  result := TFhirProvenance.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseProvenanceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseProvenanceChild(element : TFhirProvenance; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'target') then
        element.targetList.Add(ParseReference{TFhirReference}(child, path+'/target')){y.2}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if (child.localName = 'recorded') then
        element.recordedElement := ParseInstant(child, path+'/recorded') {b}
      else if (child.localName = 'reason') then
        element.reasonList.Add(ParseCodeableConcept(child, path+'/reason')){y.2}
      else if (child.localName = 'activity') then
        element.activity := ParseCodeableConcept(child, path+'/activity') {b}
      else if (child.localName = 'location') then
        element.location := ParseReference{TFhirLocation}(child, path+'/location') {b}
      else if (child.localName = 'policy') then
        element.policyList.Add(ParseUri(child, path+'/policy')){y.2}
      else if (child.localName = 'agent') then
        element.agentList.Add(ParseProvenanceAgent(child, path+'/agent')){y.2}
      else if (child.localName = 'entity') then
        element.entityList.Add(ParseProvenanceEntity(child, path+'/entity')){y.2}
      else if (child.localName = 'signature') then
        element.signatureList.Add(ParseSignature(child, path+'/signature')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeProvenance(xml : TXmlBuilder; name : String; elem : TFhirProvenance);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeProvenanceChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeProvenanceChildren(xml : TXmlBuilder; elem : TFhirProvenance);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  for i := 0 to elem.targetList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'target', elem.targetList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('period') then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
  ComposeInstant(xml, 'recorded', elem.recordedElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reason') then
    for i := 0 to elem.reasonList.Count - 1 do
      ComposeCodeableConcept(xml, 'reason', elem.reasonList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('activity') then
    ComposeCodeableConcept(xml, 'activity', elem.activity);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('location') then
    ComposeReference{TFhirLocation}(xml, 'location', elem.location);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('policy') then
    for i := 0 to elem.policyList.Count - 1 do
      ComposeUri(xml, 'policy', elem.policyList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('agent') then
    for i := 0 to elem.agentList.Count - 1 do
      ComposeProvenanceAgent(xml, 'agent', elem.agentList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('entity') then
    for i := 0 to elem.entityList.Count - 1 do
      ComposeProvenanceEntity(xml, 'entity', elem.entityList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('signature') then
    for i := 0 to elem.signatureList.Count - 1 do
      ComposeSignature(xml, 'signature', elem.signatureList[i]);
end;

{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
function TFHIRXmlParser.ParseQuestionnaireGroup(element : TMXmlElement; path : string) : TFhirQuestionnaireGroup;
var
  child : TMXmlElement;
begin
  result := TFhirQuestionnaireGroup.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseQuestionnaireGroupChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseQuestionnaireGroupChild(element : TFhirQuestionnaireGroup; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'linkId') then
        element.linkIdElement := ParseString(child, path+'/linkId') {b}
      else if (child.localName = 'title') then
        element.titleElement := ParseString(child, path+'/title') {b}
      else if (child.localName = 'concept') then
        element.conceptList.Add(ParseCoding(child, path+'/concept')){y.2}
      else if (child.localName = 'text') then
        element.textElement := ParseString(child, path+'/text') {b}
      else if (child.localName = 'required') then
        element.requiredElement := ParseBoolean(child, path+'/required') {b}
      else if (child.localName = 'repeats') then
        element.repeatsElement := ParseBoolean(child, path+'/repeats') {b}
      else if (child.localName = 'group') then
        element.groupList.Add(ParseQuestionnaireGroup(child, path+'/group')){y.2}
      else if (child.localName = 'question') then
        element.questionList.Add(ParseQuestionnaireGroupQuestion(child, path+'/question')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireGroup(xml : TXmlBuilder; name : String; elem : TFhirQuestionnaireGroup);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeQuestionnaireGroupChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireGroupChildren(xml : TXmlBuilder; elem : TFhirQuestionnaireGroup);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'linkId', elem.linkIdElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'title', elem.titleElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeCoding(xml, 'concept', elem.conceptList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.required <> false)) then
    ComposeBoolean(xml, 'required', elem.requiredElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.repeats <> false)) then
    ComposeBoolean(xml, 'repeats', elem.repeatsElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.groupList.Count - 1 do
      ComposeQuestionnaireGroup(xml, 'group', elem.groupList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.questionList.Count - 1 do
      ComposeQuestionnaireGroupQuestion(xml, 'question', elem.questionList[i]);
end;

function TFHIRXmlParser.ParseQuestionnaireGroupQuestion(element : TMXmlElement; path : string) : TFhirQuestionnaireGroupQuestion;
var
  child : TMXmlElement;
begin
  result := TFhirQuestionnaireGroupQuestion.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseQuestionnaireGroupQuestionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseQuestionnaireGroupQuestionChild(element : TFhirQuestionnaireGroupQuestion; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'linkId') then
        element.linkIdElement := ParseString(child, path+'/linkId') {b}
      else if (child.localName = 'concept') then
        element.conceptList.Add(ParseCoding(child, path+'/concept')){y.2}
      else if (child.localName = 'text') then
        element.textElement := ParseString(child, path+'/text') {b}
      else if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirAnswerFormatEnum, SYSTEMS_TFhirAnswerFormatEnum, path+'/type', child){1a}
      else if (child.localName = 'required') then
        element.requiredElement := ParseBoolean(child, path+'/required') {b}
      else if (child.localName = 'repeats') then
        element.repeatsElement := ParseBoolean(child, path+'/repeats') {b}
      else if (child.localName = 'options') then
        element.options := ParseReference{TFhirValueSet}(child, path+'/options') {b}
      else if (child.localName = 'option') then
        element.optionList.Add(ParseCoding(child, path+'/option')){y.2}
      else if (child.localName = 'group') then
        element.groupList.Add(ParseQuestionnaireGroup(child, path+'/group')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireGroupQuestion(xml : TXmlBuilder; name : String; elem : TFhirQuestionnaireGroupQuestion);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeQuestionnaireGroupQuestionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireGroupQuestionChildren(xml : TXmlBuilder; elem : TFhirQuestionnaireGroupQuestion);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'linkId', elem.linkIdElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeCoding(xml, 'concept', elem.conceptList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirAnswerFormatEnum);
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.required <> false)) then
    ComposeBoolean(xml, 'required', elem.requiredElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.repeats <> false)) then
    ComposeBoolean(xml, 'repeats', elem.repeatsElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirValueSet}(xml, 'options', elem.options);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.optionList.Count - 1 do
      ComposeCoding(xml, 'option', elem.optionList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.groupList.Count - 1 do
      ComposeQuestionnaireGroup(xml, 'group', elem.groupList[i]);
end;

function TFHIRXmlParser.ParseQuestionnaire(element : TMXmlElement; path : string) : TFhirQuestionnaire;
var
  child : TMXmlElement;
begin
  result := TFhirQuestionnaire.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseQuestionnaireChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseQuestionnaireChild(element : TFhirQuestionnaire; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirQuestionnaireStatusEnum, SYSTEMS_TFhirQuestionnaireStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'publisher') then
        element.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.localName = 'telecom') then
        element.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.localName = 'subjectType') then
        element.subjectType.Add(ParseEnum(CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, path+'/subjectType', child)){y.1}
      else if (child.localName = 'group') then
        element.group := ParseQuestionnaireGroup(child, path+'/group') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaire(xml : TXmlBuilder; name : String; elem : TFhirQuestionnaire);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeQuestionnaireChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireChildren(xml : TXmlBuilder; elem : TFhirQuestionnaire);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(xml, 'version', elem.versionElement);{x.2b}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirQuestionnaireStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('telecom') then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subjectType') then
    for i := 0 to elem.subjectType.Count - 1 do
      ComposeEnum(xml, 'subjectType', elem.subjectType[i], CODES_TFhirResourceTypesEnum);
  ComposeQuestionnaireGroup(xml, 'group', elem.group);{x.2a}
end;

{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
function TFHIRXmlParser.ParseQuestionnaireResponseGroup(element : TMXmlElement; path : string) : TFhirQuestionnaireResponseGroup;
var
  child : TMXmlElement;
begin
  result := TFhirQuestionnaireResponseGroup.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseQuestionnaireResponseGroupChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseQuestionnaireResponseGroupChild(element : TFhirQuestionnaireResponseGroup; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'linkId') then
        element.linkIdElement := ParseString(child, path+'/linkId') {b}
      else if (child.localName = 'title') then
        element.titleElement := ParseString(child, path+'/title') {b}
      else if (child.localName = 'text') then
        element.textElement := ParseString(child, path+'/text') {b}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{TFhirReference}(child, path+'/subject') {b}
      else if (child.localName = 'group') then
        element.groupList.Add(ParseQuestionnaireResponseGroup(child, path+'/group')){y.2}
      else if (child.localName = 'question') then
        element.questionList.Add(ParseQuestionnaireResponseGroupQuestion(child, path+'/question')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireResponseGroup(xml : TXmlBuilder; name : String; elem : TFhirQuestionnaireResponseGroup);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeQuestionnaireResponseGroupChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireResponseGroupChildren(xml : TXmlBuilder; elem : TFhirQuestionnaireResponseGroup);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'linkId', elem.linkIdElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'title', elem.titleElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.groupList.Count - 1 do
      ComposeQuestionnaireResponseGroup(xml, 'group', elem.groupList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.questionList.Count - 1 do
      ComposeQuestionnaireResponseGroupQuestion(xml, 'question', elem.questionList[i]);
end;

function TFHIRXmlParser.ParseQuestionnaireResponseGroupQuestion(element : TMXmlElement; path : string) : TFhirQuestionnaireResponseGroupQuestion;
var
  child : TMXmlElement;
begin
  result := TFhirQuestionnaireResponseGroupQuestion.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseQuestionnaireResponseGroupQuestionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseQuestionnaireResponseGroupQuestionChild(element : TFhirQuestionnaireResponseGroupQuestion; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'linkId') then
        element.linkIdElement := ParseString(child, path+'/linkId') {b}
      else if (child.localName = 'text') then
        element.textElement := ParseString(child, path+'/text') {b}
      else if (child.localName = 'answer') then
        element.answerList.Add(ParseQuestionnaireResponseGroupQuestionAnswer(child, path+'/answer')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireResponseGroupQuestion(xml : TXmlBuilder; name : String; elem : TFhirQuestionnaireResponseGroupQuestion);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeQuestionnaireResponseGroupQuestionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireResponseGroupQuestionChildren(xml : TXmlBuilder; elem : TFhirQuestionnaireResponseGroupQuestion);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'linkId', elem.linkIdElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'text', elem.textElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.answerList.Count - 1 do
      ComposeQuestionnaireResponseGroupQuestionAnswer(xml, 'answer', elem.answerList[i]);
end;

function TFHIRXmlParser.ParseQuestionnaireResponseGroupQuestionAnswer(element : TMXmlElement; path : string) : TFhirQuestionnaireResponseGroupQuestionAnswer;
var
  child : TMXmlElement;
begin
  result := TFhirQuestionnaireResponseGroupQuestionAnswer.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseQuestionnaireResponseGroupQuestionAnswerChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseQuestionnaireResponseGroupQuestionAnswerChild(element : TFhirQuestionnaireResponseGroupQuestionAnswer; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'valueAttachment') then
        element.value := ParseAttachment(child, path+'/valueAttachment'){x.3}
      else if (child.localName = 'valueCoding') then
        element.value := ParseCoding(child, path+'/valueCoding'){x.3}
      else if (child.localName = 'valueQuantity') then
        element.value := ParseQuantity(child, path+'/valueQuantity'){x.3}
      else if (child.localName = 'valueReference') then
        element.value := ParseReference(child, path+'/valueReference') {a}
      else if (child.localName = 'valueBoolean') then
        element.value := ParseBoolean(child, path+'/valueBoolean'){x.3}
      else if (child.localName = 'valueDecimal') then
        element.value := ParseDecimal(child, path+'/valueDecimal'){x.3}
      else if (child.localName = 'valueInteger') then
        element.value := ParseInteger(child, path+'/valueInteger'){x.3}
      else if (child.localName = 'valueDate') then
        element.value := ParseDate(child, path+'/valueDate'){x.3}
      else if (child.localName = 'valueDateTime') then
        element.value := ParseDateTime(child, path+'/valueDateTime'){x.3}
      else if (child.localName = 'valueInstant') then
        element.value := ParseInstant(child, path+'/valueInstant'){x.3}
      else if (child.localName = 'valueTime') then
        element.value := ParseTime(child, path+'/valueTime'){x.3}
      else if (child.localName = 'valueString') then
        element.value := ParseString(child, path+'/valueString'){x.3}
      else if (child.localName = 'valueUri') then
        element.value := ParseUri(child, path+'/valueUri'){x.3}
      else if (child.localName = 'group') then
        element.groupList.Add(ParseQuestionnaireResponseGroup(child, path+'/group')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireResponseGroupQuestionAnswer(xml : TXmlBuilder; name : String; elem : TFhirQuestionnaireResponseGroupQuestionAnswer);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeQuestionnaireResponseGroupQuestionAnswerChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireResponseGroupQuestionAnswerChildren(xml : TXmlBuilder; elem : TFhirQuestionnaireResponseGroupQuestionAnswer);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and (elem.value is TFhirAttachment) {6} then
    ComposeAttachment(xml, 'valueAttachment', TFhirAttachment(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirCoding) {6} then
    ComposeCoding(xml, 'valueCoding', TFhirCoding(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirQuantity) {6} then
    ComposeQuantity(xml, 'valueQuantity', TFhirQuantity(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirReference) {2} then
    ComposeReference(xml, 'valueReference', TFhirReference(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'valueDecimal', TFhirDecimal(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirInteger) {6} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirDate) {6} then
    ComposeDate(xml, 'valueDate', TFhirDate(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'valueDateTime', TFhirDateTime(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirInstant) {6} then
    ComposeInstant(xml, 'valueInstant', TFhirInstant(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirTime) {6} then
    ComposeTime(xml, 'valueTime', TFhirTime(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirUri) {6} then
    ComposeUri(xml, 'valueUri', TFhirUri(elem.value));
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.groupList.Count - 1 do
      ComposeQuestionnaireResponseGroup(xml, 'group', elem.groupList[i]);
end;

function TFHIRXmlParser.ParseQuestionnaireResponse(element : TMXmlElement; path : string) : TFhirQuestionnaireResponse;
var
  child : TMXmlElement;
begin
  result := TFhirQuestionnaireResponse.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseQuestionnaireResponseChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseQuestionnaireResponseChild(element : TFhirQuestionnaireResponse; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'questionnaire') then
        element.questionnaire := ParseReference{TFhirQuestionnaire}(child, path+'/questionnaire') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirQuestionnaireAnswersStatusEnum, SYSTEMS_TFhirQuestionnaireAnswersStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{TFhirReference}(child, path+'/subject') {b}
      else if (child.localName = 'author') then
        element.author := ParseReference{Resource}(child, path+'/author') {b}
      else if (child.localName = 'authored') then
        element.authoredElement := ParseDateTime(child, path+'/authored') {b}
      else if (child.localName = 'source') then
        element.source := ParseReference{Resource}(child, path+'/source') {b}
      else if (child.localName = 'encounter') then
        element.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.localName = 'group') then
        element.group := ParseQuestionnaireResponseGroup(child, path+'/group') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireResponse(xml : TXmlBuilder; name : String; elem : TFhirQuestionnaireResponse);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeQuestionnaireResponseChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeQuestionnaireResponseChildren(xml : TXmlBuilder; elem : TFhirQuestionnaireResponse);
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('questionnaire') then
    ComposeReference{TFhirQuestionnaire}(xml, 'questionnaire', elem.questionnaire);{x.2a}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirQuestionnaireAnswersStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{TFhirReference}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('author') then
    ComposeReference{Resource}(xml, 'author', elem.author);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('authored') then
    ComposeDateTime(xml, 'authored', elem.authoredElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('source') then
    ComposeReference{Resource}(xml, 'source', elem.source);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('group') then
    ComposeQuestionnaireResponseGroup(xml, 'group', elem.group);{x.2a}
end;

{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REFERRALREQUEST}
function TFHIRXmlParser.ParseReferralRequest(element : TMXmlElement; path : string) : TFhirReferralRequest;
var
  child : TMXmlElement;
begin
  result := TFhirReferralRequest.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseReferralRequestChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseReferralRequestChild(element : TFhirReferralRequest; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirReferralstatusEnum, SYSTEMS_TFhirReferralstatusEnum, path+'/status', child){1a}
      else if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'specialty') then
        element.specialty := ParseCodeableConcept(child, path+'/specialty') {b}
      else if (child.localName = 'priority') then
        element.priority := ParseCodeableConcept(child, path+'/priority') {b}
      else if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'requester') then
        element.requester := ParseReference{Resource}(child, path+'/requester') {b}
      else if (child.localName = 'recipient') then
        element.recipientList.Add(ParseReference{Resource}(child, path+'/recipient')){y.2}
      else if (child.localName = 'encounter') then
        element.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.localName = 'dateSent') then
        element.dateSentElement := ParseDateTime(child, path+'/dateSent') {b}
      else if (child.localName = 'reason') then
        element.reason := ParseCodeableConcept(child, path+'/reason') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'serviceRequested') then
        element.serviceRequestedList.Add(ParseCodeableConcept(child, path+'/serviceRequested')){y.2}
      else if (child.localName = 'supportingInformation') then
        element.supportingInformationList.Add(ParseReference{TFhirReference}(child, path+'/supportingInformation')){y.2}
      else if (child.localName = 'fulfillmentTime') then
        element.fulfillmentTime := ParsePeriod(child, path+'/fulfillmentTime') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeReferralRequest(xml : TXmlBuilder; name : String; elem : TFhirReferralRequest);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeReferralRequestChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeReferralRequestChildren(xml : TXmlBuilder; elem : TFhirReferralRequest);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirReferralstatusEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('specialty') then
    ComposeCodeableConcept(xml, 'specialty', elem.specialty);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('priority') then
    ComposeCodeableConcept(xml, 'priority', elem.priority);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('requester') then
    ComposeReference{Resource}(xml, 'requester', elem.requester);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('recipient') then
    for i := 0 to elem.recipientList.Count - 1 do
      ComposeReference{Resource}(xml, 'recipient', elem.recipientList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dateSent') then
    ComposeDateTime(xml, 'dateSent', elem.dateSentElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('reason') then
    ComposeCodeableConcept(xml, 'reason', elem.reason);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('description') then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('serviceRequested') then
    for i := 0 to elem.serviceRequestedList.Count - 1 do
      ComposeCodeableConcept(xml, 'serviceRequested', elem.serviceRequestedList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('supportingInformation') then
    for i := 0 to elem.supportingInformationList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'supportingInformation', elem.supportingInformationList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('fulfillmentTime') then
    ComposePeriod(xml, 'fulfillmentTime', elem.fulfillmentTime);{x.2a}
end;

{$ENDIF FHIR_REFERRALREQUEST}
{$IFDEF FHIR_RELATEDPERSON}
function TFHIRXmlParser.ParseRelatedPerson(element : TMXmlElement; path : string) : TFhirRelatedPerson;
var
  child : TMXmlElement;
begin
  result := TFhirRelatedPerson.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseRelatedPersonChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseRelatedPersonChild(element : TFhirRelatedPerson; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'relationship') then
        element.relationship := ParseCodeableConcept(child, path+'/relationship') {b}
      else if (child.localName = 'name') then
        element.name := ParseHumanName(child, path+'/name') {b}
      else if (child.localName = 'telecom') then
        element.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if (child.localName = 'gender') then
        element.genderElement := ParseEnum(CODES_TFhirAdministrativeGenderEnum, SYSTEMS_TFhirAdministrativeGenderEnum, path+'/gender', child){1a}
      else if (child.localName = 'birthDate') then
        element.birthDateElement := ParseDate(child, path+'/birthDate') {b}
      else if (child.localName = 'address') then
        element.addressList.Add(ParseAddress(child, path+'/address')){y.2}
      else if (child.localName = 'photo') then
        element.photoList.Add(ParseAttachment(child, path+'/photo')){y.2}
      else if (child.localName = 'period') then
        element.period := ParsePeriod(child, path+'/period') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeRelatedPerson(xml : TXmlBuilder; name : String; elem : TFhirRelatedPerson);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeRelatedPersonChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeRelatedPersonChildren(xml : TXmlBuilder; elem : TFhirRelatedPerson);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('relationship') then
    ComposeCodeableConcept(xml, 'relationship', elem.relationship);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeHumanName(xml, 'name', elem.name);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('telecom') then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('gender') then
    ComposeEnum(xml, 'gender', elem.GenderElement, CODES_TFhirAdministrativeGenderEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('birthDate') then
    ComposeDate(xml, 'birthDate', elem.birthDateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('address') then
    for i := 0 to elem.addressList.Count - 1 do
      ComposeAddress(xml, 'address', elem.addressList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('photo') then
    for i := 0 to elem.photoList.Count - 1 do
      ComposeAttachment(xml, 'photo', elem.photoList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('period') then
    ComposePeriod(xml, 'period', elem.period);{x.2a}
end;

{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_RISKASSESSMENT}
function TFHIRXmlParser.ParseRiskAssessmentPrediction(element : TMXmlElement; path : string) : TFhirRiskAssessmentPrediction;
var
  child : TMXmlElement;
begin
  result := TFhirRiskAssessmentPrediction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseRiskAssessmentPredictionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseRiskAssessmentPredictionChild(element : TFhirRiskAssessmentPrediction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'outcome') then
        element.outcome := ParseCodeableConcept(child, path+'/outcome') {b}
      else if (child.localName = 'probabilityRange') then
        element.probability := ParseRange(child, path+'/probabilityRange'){x.3}
      else if (child.localName = 'probabilityCodeableConcept') then
        element.probability := ParseCodeableConcept(child, path+'/probabilityCodeableConcept'){x.3}
      else if (child.localName = 'probabilityDecimal') then
        element.probability := ParseDecimal(child, path+'/probabilityDecimal'){x.3}
      else if (child.localName = 'relativeRisk') then
        element.relativeRiskElement := ParseDecimal(child, path+'/relativeRisk') {b}
      else if (child.localName = 'whenPeriod') then
        element.when := ParsePeriod(child, path+'/whenPeriod'){x.3}
      else if (child.localName = 'whenRange') then
        element.when := ParseRange(child, path+'/whenRange'){x.3}
      else if (child.localName = 'rationale') then
        element.rationaleElement := ParseString(child, path+'/rationale') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeRiskAssessmentPrediction(xml : TXmlBuilder; name : String; elem : TFhirRiskAssessmentPrediction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeRiskAssessmentPredictionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeRiskAssessmentPredictionChildren(xml : TXmlBuilder; elem : TFhirRiskAssessmentPrediction);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCodeableConcept(xml, 'outcome', elem.outcome);{x.2a}
  if (SummaryOption in [soFull, soData]) and (elem.probability is TFhirRange) {6} then
    ComposeRange(xml, 'probabilityRange', TFhirRange(elem.probability))
  else if (SummaryOption in [soFull, soData]) and (elem.probability is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'probabilityCodeableConcept', TFhirCodeableConcept(elem.probability))
  else if (SummaryOption in [soFull, soData]) and (elem.probability is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'probabilityDecimal', TFhirDecimal(elem.probability));
  if (SummaryOption in [soFull, soData]) then
    ComposeDecimal(xml, 'relativeRisk', elem.relativeRiskElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and (elem.when is TFhirPeriod) {6} then
    ComposePeriod(xml, 'whenPeriod', TFhirPeriod(elem.when))
  else if (SummaryOption in [soFull, soData]) and (elem.when is TFhirRange) {6} then
    ComposeRange(xml, 'whenRange', TFhirRange(elem.when));
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'rationale', elem.rationaleElement);{x.2b}
end;

function TFHIRXmlParser.ParseRiskAssessment(element : TMXmlElement; path : string) : TFhirRiskAssessment;
var
  child : TMXmlElement;
begin
  result := TFhirRiskAssessment.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseRiskAssessmentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseRiskAssessmentChild(element : TFhirRiskAssessment; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'condition') then
        element.condition := ParseReference{TFhirCondition}(child, path+'/condition') {b}
      else if (child.localName = 'encounter') then
        element.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.localName = 'performer') then
        element.performer := ParseReference{Resource}(child, path+'/performer') {b}
      else if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'method') then
        element.method := ParseCodeableConcept(child, path+'/method') {b}
      else if (child.localName = 'basis') then
        element.basisList.Add(ParseReference{TFhirReference}(child, path+'/basis')){y.2}
      else if (child.localName = 'prediction') then
        element.predictionList.Add(ParseRiskAssessmentPrediction(child, path+'/prediction')){y.2}
      else if (child.localName = 'mitigation') then
        element.mitigationElement := ParseString(child, path+'/mitigation') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeRiskAssessment(xml : TXmlBuilder; name : String; elem : TFhirRiskAssessment);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeRiskAssessmentChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeRiskAssessmentChildren(xml : TXmlBuilder; elem : TFhirRiskAssessment);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('subject') then
    ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('condition') then
    ComposeReference{TFhirCondition}(xml, 'condition', elem.condition);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('performer') then
    ComposeReference{Resource}(xml, 'performer', elem.performer);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('method') then
    ComposeCodeableConcept(xml, 'method', elem.method);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('basis') then
    for i := 0 to elem.basisList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'basis', elem.basisList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('prediction') then
    for i := 0 to elem.predictionList.Count - 1 do
      ComposeRiskAssessmentPrediction(xml, 'prediction', elem.predictionList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('mitigation') then
    ComposeString(xml, 'mitigation', elem.mitigationElement);{x.2b}
end;

{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
function TFHIRXmlParser.ParseSchedule(element : TMXmlElement; path : string) : TFhirSchedule;
var
  child : TMXmlElement;
begin
  result := TFhirSchedule.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseScheduleChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseScheduleChild(element : TFhirSchedule; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'type') then
        element.type_List.Add(ParseCodeableConcept(child, path+'/type')){y.2}
      else if (child.localName = 'actor') then
        element.actor := ParseReference{Resource}(child, path+'/actor') {b}
      else if (child.localName = 'planningHorizon') then
        element.planningHorizon := ParsePeriod(child, path+'/planningHorizon') {b}
      else if (child.localName = 'comment') then
        element.commentElement := ParseString(child, path+'/comment') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSchedule(xml : TXmlBuilder; name : String; elem : TFhirSchedule);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeScheduleChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeScheduleChildren(xml : TXmlBuilder; elem : TFhirSchedule);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('type_') then
    for i := 0 to elem.type_List.Count - 1 do
      ComposeCodeableConcept(xml, 'type', elem.type_List[i]);
  ComposeReference{Resource}(xml, 'actor', elem.actor);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('planningHorizon') then
    ComposePeriod(xml, 'planningHorizon', elem.planningHorizon);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeString(xml, 'comment', elem.commentElement);{x.2b}
end;

{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
function TFHIRXmlParser.ParseSearchParameterContact(element : TMXmlElement; path : string) : TFhirSearchParameterContact;
var
  child : TMXmlElement;
begin
  result := TFhirSearchParameterContact.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSearchParameterContactChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSearchParameterContactChild(element : TFhirSearchParameterContact; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'telecom') then
        element.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSearchParameterContact(xml : TXmlBuilder; name : String; elem : TFhirSearchParameterContact);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSearchParameterContactChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSearchParameterContactChildren(xml : TXmlBuilder; elem : TFhirSearchParameterContact);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
end;

function TFHIRXmlParser.ParseSearchParameter(element : TMXmlElement; path : string) : TFhirSearchParameter;
var
  child : TMXmlElement;
begin
  result := TFhirSearchParameter.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSearchParameterChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSearchParameterChild(element : TFhirSearchParameter; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'experimental') then
        element.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.localName = 'publisher') then
        element.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.localName = 'contact') then
        element.contactList.Add(ParseSearchParameterContact(child, path+'/contact')){y.2}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'requirements') then
        element.requirementsElement := ParseString(child, path+'/requirements') {b}
      else if (child.localName = 'code') then
        element.codeElement := ParseCode(child, path+'/code') {b}
      else if (child.localName = 'base') then
        element.baseElement := ParseEnum(CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, path+'/base', child){1a}
      else if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirSearchParamTypeEnum, SYSTEMS_TFhirSearchParamTypeEnum, path+'/type', child){1a}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'xpath') then
        element.xpathElement := ParseString(child, path+'/xpath') {b}
      else if (child.localName = 'xpathUsage') then
        element.xpathUsageElement := ParseEnum(CODES_TFhirSearchXpathUsageEnum, SYSTEMS_TFhirSearchXpathUsageEnum, path+'/xpathUsage', child){1a}
      else if (child.localName = 'target') then
        element.target.Add(ParseEnum(CODES_TFhirResourceTypesEnum, SYSTEMS_TFhirResourceTypesEnum, path+'/target', child)){y.1}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSearchParameter(xml : TXmlBuilder; name : String; elem : TFhirSearchParameter);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSearchParameterChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSearchParameterChildren(xml : TXmlBuilder; elem : TFhirSearchParameter);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeSearchParameterContact(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('requirements') then
    ComposeString(xml, 'requirements', elem.requirementsElement);{x.2b}
  ComposeCode(xml, 'code', elem.codeElement);{x.2b}
  ComposeEnum(xml, 'base', elem.BaseElement, CODES_TFhirResourceTypesEnum);
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirSearchParamTypeEnum);
  ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('xpath') then
    ComposeString(xml, 'xpath', elem.xpathElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('xpathUsage') then
    ComposeEnum(xml, 'xpathUsage', elem.XpathUsageElement, CODES_TFhirSearchXpathUsageEnum);
  if (SummaryOption in [soFull, soData]) and doCompose('target') then
    for i := 0 to elem.target.Count - 1 do
      ComposeEnum(xml, 'target', elem.target[i], CODES_TFhirResourceTypesEnum);
end;

{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SLOT}
function TFHIRXmlParser.ParseSlot(element : TMXmlElement; path : string) : TFhirSlot;
var
  child : TMXmlElement;
begin
  result := TFhirSlot.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSlotChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSlotChild(element : TFhirSlot; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'schedule') then
        element.schedule := ParseReference{TFhirSchedule}(child, path+'/schedule') {b}
      else if (child.localName = 'freeBusyType') then
        element.freeBusyTypeElement := ParseEnum(CODES_TFhirSlotstatusEnum, SYSTEMS_TFhirSlotstatusEnum, path+'/freeBusyType', child){1a}
      else if (child.localName = 'start') then
        element.startElement := ParseInstant(child, path+'/start') {b}
      else if (child.localName = 'end') then
        element.end_Element := ParseInstant(child, path+'/end') {b}
      else if (child.localName = 'overbooked') then
        element.overbookedElement := ParseBoolean(child, path+'/overbooked') {b}
      else if (child.localName = 'comment') then
        element.commentElement := ParseString(child, path+'/comment') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSlot(xml : TXmlBuilder; name : String; elem : TFhirSlot);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSlotChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSlotChildren(xml : TXmlBuilder; elem : TFhirSlot);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('type_') then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  ComposeReference{TFhirSchedule}(xml, 'schedule', elem.schedule);{x.2a}
  ComposeEnum(xml, 'freeBusyType', elem.FreeBusyTypeElement, CODES_TFhirSlotstatusEnum);
  ComposeInstant(xml, 'start', elem.startElement);{x.2b}
  ComposeInstant(xml, 'end', elem.end_Element);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('overbooked') then
    ComposeBoolean(xml, 'overbooked', elem.overbookedElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('comment') then
    ComposeString(xml, 'comment', elem.commentElement);{x.2b}
end;

{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
function TFHIRXmlParser.ParseSpecimenCollection(element : TMXmlElement; path : string) : TFhirSpecimenCollection;
var
  child : TMXmlElement;
begin
  result := TFhirSpecimenCollection.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSpecimenCollectionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSpecimenCollectionChild(element : TFhirSpecimenCollection; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'collector') then
        element.collector := ParseReference{TFhirPractitioner}(child, path+'/collector') {b}
      else if (child.localName = 'comment') then
        element.commentList.Add(ParseString(child, path+'/comment')){y.2}
      else if (child.localName = 'collectedPeriod') then
        element.collected := ParsePeriod(child, path+'/collectedPeriod'){x.3}
      else if (child.localName = 'collectedDateTime') then
        element.collected := ParseDateTime(child, path+'/collectedDateTime'){x.3}
      else if (child.localName = 'quantity') then
        element.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.localName = 'method') then
        element.method := ParseCodeableConcept(child, path+'/method') {b}
      else if (child.localName = 'bodySite') then
        element.bodySite := ParseCodeableConcept(child, path+'/bodySite') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSpecimenCollection(xml : TXmlBuilder; name : String; elem : TFhirSpecimenCollection);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSpecimenCollectionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSpecimenCollectionChildren(xml : TXmlBuilder; elem : TFhirSpecimenCollection);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeReference{TFhirPractitioner}(xml, 'collector', elem.collector);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.commentList.Count - 1 do
      ComposeString(xml, 'comment', elem.commentList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.collected is TFhirPeriod) {6} then
    ComposePeriod(xml, 'collectedPeriod', TFhirPeriod(elem.collected))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.collected is TFhirDateTime) {6} then
    ComposeDateTime(xml, 'collectedDateTime', TFhirDateTime(elem.collected));
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'method', elem.method);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'bodySite', elem.bodySite);{x.2a}
end;

function TFHIRXmlParser.ParseSpecimenTreatment(element : TMXmlElement; path : string) : TFhirSpecimenTreatment;
var
  child : TMXmlElement;
begin
  result := TFhirSpecimenTreatment.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSpecimenTreatmentChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSpecimenTreatmentChild(element : TFhirSpecimenTreatment; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'procedure') then
        element.procedure_ := ParseCodeableConcept(child, path+'/procedure') {b}
      else if (child.localName = 'additive') then
        element.additiveList.Add(ParseReference{TFhirSubstance}(child, path+'/additive')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSpecimenTreatment(xml : TXmlBuilder; name : String; elem : TFhirSpecimenTreatment);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSpecimenTreatmentChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSpecimenTreatmentChildren(xml : TXmlBuilder; elem : TFhirSpecimenTreatment);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'procedure', elem.procedure_);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.additiveList.Count - 1 do
      ComposeReference{TFhirSubstance}(xml, 'additive', elem.additiveList[i]);
end;

function TFHIRXmlParser.ParseSpecimenContainer(element : TMXmlElement; path : string) : TFhirSpecimenContainer;
var
  child : TMXmlElement;
begin
  result := TFhirSpecimenContainer.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSpecimenContainerChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSpecimenContainerChild(element : TFhirSpecimenContainer; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'capacity') then
        element.capacity := ParseQuantity(child, path+'/capacity') {b}
      else if (child.localName = 'specimenQuantity') then
        element.specimenQuantity := ParseQuantity(child, path+'/specimenQuantity') {b}
      else if (child.localName = 'additiveCodeableConcept') then
        element.additive := ParseCodeableConcept(child, path+'/additiveCodeableConcept'){x.3}
      else if (child.localName = 'additiveReference') then
        element.additive := ParseReference(child, path+'/additiveReference') {a}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSpecimenContainer(xml : TXmlBuilder; name : String; elem : TFhirSpecimenContainer);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSpecimenContainerChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSpecimenContainerChildren(xml : TXmlBuilder; elem : TFhirSpecimenContainer);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'capacity', elem.capacity);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeQuantity(xml, 'specimenQuantity', elem.specimenQuantity);{x.2a}
  if (SummaryOption in [soFull, soData]) and (elem.additive is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'additiveCodeableConcept', TFhirCodeableConcept(elem.additive))
  else if (SummaryOption in [soFull, soData]) and (elem.additive is TFhirReference) {2} then
    ComposeReference(xml, 'additiveReference', TFhirReference(elem.additive));
end;

function TFHIRXmlParser.ParseSpecimen(element : TMXmlElement; path : string) : TFhirSpecimen;
var
  child : TMXmlElement;
begin
  result := TFhirSpecimen.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSpecimenChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSpecimenChild(element : TFhirSpecimen; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirSpecimenStatusEnum, SYSTEMS_TFhirSpecimenStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'parent') then
        element.parentList.Add(ParseReference{TFhirSpecimen}(child, path+'/parent')){y.2}
      else if (child.localName = 'subject') then
        element.subject := ParseReference{Resource}(child, path+'/subject') {b}
      else if (child.localName = 'accessionIdentifier') then
        element.accessionIdentifier := ParseIdentifier(child, path+'/accessionIdentifier') {b}
      else if (child.localName = 'receivedTime') then
        element.receivedTimeElement := ParseDateTime(child, path+'/receivedTime') {b}
      else if (child.localName = 'collection') then
        element.collection := ParseSpecimenCollection(child, path+'/collection') {b}
      else if (child.localName = 'treatment') then
        element.treatmentList.Add(ParseSpecimenTreatment(child, path+'/treatment')){y.2}
      else if (child.localName = 'container') then
        element.containerList.Add(ParseSpecimenContainer(child, path+'/container')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSpecimen(xml : TXmlBuilder; name : String; elem : TFhirSpecimen);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSpecimenChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSpecimenChildren(xml : TXmlBuilder; elem : TFhirSpecimen);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirSpecimenStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('parent') then
    for i := 0 to elem.parentList.Count - 1 do
      ComposeReference{TFhirSpecimen}(xml, 'parent', elem.parentList[i]);
  ComposeReference{Resource}(xml, 'subject', elem.subject);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('accessionIdentifier') then
    ComposeIdentifier(xml, 'accessionIdentifier', elem.accessionIdentifier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('receivedTime') then
    ComposeDateTime(xml, 'receivedTime', elem.receivedTimeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('collection') then
    ComposeSpecimenCollection(xml, 'collection', elem.collection);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('treatment') then
    for i := 0 to elem.treatmentList.Count - 1 do
      ComposeSpecimenTreatment(xml, 'treatment', elem.treatmentList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('container') then
    for i := 0 to elem.containerList.Count - 1 do
      ComposeSpecimenContainer(xml, 'container', elem.containerList[i]);
end;

{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_STRUCTUREDEFINITION}
function TFHIRXmlParser.ParseStructureDefinitionContact(element : TMXmlElement; path : string) : TFhirStructureDefinitionContact;
var
  child : TMXmlElement;
begin
  result := TFhirStructureDefinitionContact.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseStructureDefinitionContactChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseStructureDefinitionContactChild(element : TFhirStructureDefinitionContact; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'telecom') then
        element.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeStructureDefinitionContact(xml : TXmlBuilder; name : String; elem : TFhirStructureDefinitionContact);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeStructureDefinitionContactChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeStructureDefinitionContactChildren(xml : TXmlBuilder; elem : TFhirStructureDefinitionContact);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
end;

function TFHIRXmlParser.ParseStructureDefinitionMapping(element : TMXmlElement; path : string) : TFhirStructureDefinitionMapping;
var
  child : TMXmlElement;
begin
  result := TFhirStructureDefinitionMapping.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseStructureDefinitionMappingChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseStructureDefinitionMappingChild(element : TFhirStructureDefinitionMapping; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identity') then
        element.identityElement := ParseId(child, path+'/identity') {b}
      else if (child.localName = 'uri') then
        element.uriElement := ParseUri(child, path+'/uri') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'comments') then
        element.commentsElement := ParseString(child, path+'/comments') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeStructureDefinitionMapping(xml : TXmlBuilder; name : String; elem : TFhirStructureDefinitionMapping);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeStructureDefinitionMappingChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeStructureDefinitionMappingChildren(xml : TXmlBuilder; elem : TFhirStructureDefinitionMapping);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeId(xml, 'identity', elem.identityElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'uri', elem.uriElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'comments', elem.commentsElement);{x.2b}
end;

function TFHIRXmlParser.ParseStructureDefinitionSnapshot(element : TMXmlElement; path : string) : TFhirStructureDefinitionSnapshot;
var
  child : TMXmlElement;
begin
  result := TFhirStructureDefinitionSnapshot.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseStructureDefinitionSnapshotChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseStructureDefinitionSnapshotChild(element : TFhirStructureDefinitionSnapshot; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'element') then
        element.elementList.Add(ParseElementDefinition(child, path+'/element')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeStructureDefinitionSnapshot(xml : TXmlBuilder; name : String; elem : TFhirStructureDefinitionSnapshot);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeStructureDefinitionSnapshotChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeStructureDefinitionSnapshotChildren(xml : TXmlBuilder; elem : TFhirStructureDefinitionSnapshot);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.elementList.Count - 1 do
      ComposeElementDefinition(xml, 'element', elem.elementList[i]);
end;

function TFHIRXmlParser.ParseStructureDefinitionDifferential(element : TMXmlElement; path : string) : TFhirStructureDefinitionDifferential;
var
  child : TMXmlElement;
begin
  result := TFhirStructureDefinitionDifferential.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseStructureDefinitionDifferentialChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseStructureDefinitionDifferentialChild(element : TFhirStructureDefinitionDifferential; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'element') then
        element.elementList.Add(ParseElementDefinition(child, path+'/element')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeStructureDefinitionDifferential(xml : TXmlBuilder; name : String; elem : TFhirStructureDefinitionDifferential);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeStructureDefinitionDifferentialChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeStructureDefinitionDifferentialChildren(xml : TXmlBuilder; elem : TFhirStructureDefinitionDifferential);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.elementList.Count - 1 do
      ComposeElementDefinition(xml, 'element', elem.elementList[i]);
end;

function TFHIRXmlParser.ParseStructureDefinition(element : TMXmlElement; path : string) : TFhirStructureDefinition;
var
  child : TMXmlElement;
begin
  result := TFhirStructureDefinition.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseStructureDefinitionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseStructureDefinitionChild(element : TFhirStructureDefinition; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'display') then
        element.displayElement := ParseString(child, path+'/display') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'experimental') then
        element.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.localName = 'publisher') then
        element.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.localName = 'contact') then
        element.contactList.Add(ParseStructureDefinitionContact(child, path+'/contact')){y.2}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'useContext') then
        element.useContextList.Add(ParseCodeableConcept(child, path+'/useContext')){y.2}
      else if (child.localName = 'requirements') then
        element.requirementsElement := ParseString(child, path+'/requirements') {b}
      else if (child.localName = 'copyright') then
        element.copyrightElement := ParseString(child, path+'/copyright') {b}
      else if (child.localName = 'code') then
        element.codeList.Add(ParseCoding(child, path+'/code')){y.2}
      else if (child.localName = 'fhirVersion') then
        element.fhirVersionElement := ParseId(child, path+'/fhirVersion') {b}
      else if (child.localName = 'mapping') then
        element.mappingList.Add(ParseStructureDefinitionMapping(child, path+'/mapping')){y.2}
      else if (child.localName = 'kind') then
        element.kindElement := ParseEnum(CODES_TFhirStructureDefinitionKindEnum, SYSTEMS_TFhirStructureDefinitionKindEnum, path+'/kind', child){1a}
      else if (child.localName = 'constrainedType') then
        element.constrainedTypeElement := ParseCode(child, path+'/constrainedType') {b}
      else if (child.localName = 'abstract') then
        element.abstractElement := ParseBoolean(child, path+'/abstract') {b}
      else if (child.localName = 'contextType') then
        element.contextTypeElement := ParseEnum(CODES_TFhirExtensionContextEnum, SYSTEMS_TFhirExtensionContextEnum, path+'/contextType', child){1a}
      else if (child.localName = 'context') then
        element.contextList.Add(ParseString(child, path+'/context')){y.2}
      else if (child.localName = 'base') then
        element.baseElement := ParseUri(child, path+'/base') {b}
      else if (child.localName = 'snapshot') then
        element.snapshot := ParseStructureDefinitionSnapshot(child, path+'/snapshot') {b}
      else if (child.localName = 'differential') then
        element.differential := ParseStructureDefinitionDifferential(child, path+'/differential') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeStructureDefinition(xml : TXmlBuilder; name : String; elem : TFhirStructureDefinition);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeStructureDefinitionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeStructureDefinitionChildren(xml : TXmlBuilder; elem : TFhirStructureDefinition);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(xml, 'version', elem.versionElement);{x.2b}
  ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('display') then
    ComposeString(xml, 'display', elem.displayElement);{x.2b}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeStructureDefinitionContact(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(xml, 'useContext', elem.useContextList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('requirements') then
    ComposeString(xml, 'requirements', elem.requirementsElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeString(xml, 'copyright', elem.copyrightElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('code') then
    for i := 0 to elem.codeList.Count - 1 do
      ComposeCoding(xml, 'code', elem.codeList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('fhirVersion') then
    ComposeId(xml, 'fhirVersion', elem.fhirVersionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('mapping') then
    for i := 0 to elem.mappingList.Count - 1 do
      ComposeStructureDefinitionMapping(xml, 'mapping', elem.mappingList[i]);
  ComposeEnum(xml, 'kind', elem.KindElement, CODES_TFhirStructureDefinitionKindEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('constrainedType') then
    ComposeCode(xml, 'constrainedType', elem.constrainedTypeElement);{x.2b}
  ComposeBoolean(xml, 'abstract', elem.abstractElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contextType') then
    ComposeEnum(xml, 'contextType', elem.ContextTypeElement, CODES_TFhirExtensionContextEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('context') then
    for i := 0 to elem.contextList.Count - 1 do
      ComposeString(xml, 'context', elem.contextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('base') then
    ComposeUri(xml, 'base', elem.baseElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('snapshot') then
    ComposeStructureDefinitionSnapshot(xml, 'snapshot', elem.snapshot);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('differential') then
    ComposeStructureDefinitionDifferential(xml, 'differential', elem.differential);{x.2a}
end;

{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_SUBSCRIPTION}
function TFHIRXmlParser.ParseSubscriptionChannel(element : TMXmlElement; path : string) : TFhirSubscriptionChannel;
var
  child : TMXmlElement;
begin
  result := TFhirSubscriptionChannel.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubscriptionChannelChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubscriptionChannelChild(element : TFhirSubscriptionChannel; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_Element := ParseEnum(CODES_TFhirSubscriptionChannelTypeEnum, SYSTEMS_TFhirSubscriptionChannelTypeEnum, path+'/type', child){1a}
      else if (child.localName = 'endpoint') then
        element.endpointElement := ParseUri(child, path+'/endpoint') {b}
      else if (child.localName = 'payload') then
        element.payloadElement := ParseString(child, path+'/payload') {b}
      else if (child.localName = 'header') then
        element.headerElement := ParseString(child, path+'/header') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubscriptionChannel(xml : TXmlBuilder; name : String; elem : TFhirSubscriptionChannel);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubscriptionChannelChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubscriptionChannelChildren(xml : TXmlBuilder; elem : TFhirSubscriptionChannel);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeEnum(xml, 'type', elem.Type_Element, CODES_TFhirSubscriptionChannelTypeEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeUri(xml, 'endpoint', elem.endpointElement);{x.2b}
  ComposeString(xml, 'payload', elem.payloadElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'header', elem.headerElement);{x.2b}
end;

function TFHIRXmlParser.ParseSubscription(element : TMXmlElement; path : string) : TFhirSubscription;
var
  child : TMXmlElement;
begin
  result := TFhirSubscription.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubscriptionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubscriptionChild(element : TFhirSubscription; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'criteria') then
        element.criteriaElement := ParseString(child, path+'/criteria') {b}
      else if (child.localName = 'contact') then
        element.contactList.Add(ParseContactPoint(child, path+'/contact')){y.2}
      else if (child.localName = 'reason') then
        element.reasonElement := ParseString(child, path+'/reason') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirSubscriptionStatusEnum, SYSTEMS_TFhirSubscriptionStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'error') then
        element.errorElement := ParseString(child, path+'/error') {b}
      else if (child.localName = 'channel') then
        element.channel := ParseSubscriptionChannel(child, path+'/channel') {b}
      else if (child.localName = 'end') then
        element.end_Element := ParseInstant(child, path+'/end') {b}
      else if (child.localName = 'tag') then
        element.tagList.Add(ParseCoding(child, path+'/tag')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubscription(xml : TXmlBuilder; name : String; elem : TFhirSubscription);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubscriptionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubscriptionChildren(xml : TXmlBuilder; elem : TFhirSubscription);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  ComposeString(xml, 'criteria', elem.criteriaElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeContactPoint(xml, 'contact', elem.contactList[i]);
  ComposeString(xml, 'reason', elem.reasonElement);{x.2b}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirSubscriptionStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('error') then
    ComposeString(xml, 'error', elem.errorElement);{x.2b}
  ComposeSubscriptionChannel(xml, 'channel', elem.channel);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('end_') then
    ComposeInstant(xml, 'end', elem.end_Element);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('tag') then
    for i := 0 to elem.tagList.Count - 1 do
      ComposeCoding(xml, 'tag', elem.tagList[i]);
end;

{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
function TFHIRXmlParser.ParseSubstanceInstance(element : TMXmlElement; path : string) : TFhirSubstanceInstance;
var
  child : TMXmlElement;
begin
  result := TFhirSubstanceInstance.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubstanceInstanceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubstanceInstanceChild(element : TFhirSubstanceInstance; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'expiry') then
        element.expiryElement := ParseDateTime(child, path+'/expiry') {b}
      else if (child.localName = 'quantity') then
        element.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubstanceInstance(xml : TXmlBuilder; name : String; elem : TFhirSubstanceInstance);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubstanceInstanceChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubstanceInstanceChildren(xml : TXmlBuilder; elem : TFhirSubstanceInstance);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDateTime(xml, 'expiry', elem.expiryElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2a}
end;

function TFHIRXmlParser.ParseSubstanceIngredient(element : TMXmlElement; path : string) : TFhirSubstanceIngredient;
var
  child : TMXmlElement;
begin
  result := TFhirSubstanceIngredient.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubstanceIngredientChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubstanceIngredientChild(element : TFhirSubstanceIngredient; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'quantity') then
        element.quantity := ParseRatio(child, path+'/quantity') {b}
      else if (child.localName = 'substance') then
        element.substance := ParseReference{TFhirSubstance}(child, path+'/substance') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubstanceIngredient(xml : TXmlBuilder; name : String; elem : TFhirSubstanceIngredient);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubstanceIngredientChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubstanceIngredientChildren(xml : TXmlBuilder; elem : TFhirSubstanceIngredient);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeRatio(xml, 'quantity', elem.quantity);{x.2a}
  ComposeReference{TFhirSubstance}(xml, 'substance', elem.substance);{x.2a}
end;

function TFHIRXmlParser.ParseSubstance(element : TMXmlElement; path : string) : TFhirSubstance;
var
  child : TMXmlElement;
begin
  result := TFhirSubstance.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSubstanceChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSubstanceChild(element : TFhirSubstance; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'category') then
        element.categoryList.Add(ParseCodeableConcept(child, path+'/category')){y.2}
      else if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'instance') then
        element.instanceList.Add(ParseSubstanceInstance(child, path+'/instance')){y.2}
      else if (child.localName = 'ingredient') then
        element.ingredientList.Add(ParseSubstanceIngredient(child, path+'/ingredient')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSubstance(xml : TXmlBuilder; name : String; elem : TFhirSubstance);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSubstanceChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSubstanceChildren(xml : TXmlBuilder; elem : TFhirSubstance);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('category') then
    for i := 0 to elem.categoryList.Count - 1 do
      ComposeCodeableConcept(xml, 'category', elem.categoryList[i]);
  ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('instance') then
    for i := 0 to elem.instanceList.Count - 1 do
      ComposeSubstanceInstance(xml, 'instance', elem.instanceList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('ingredient') then
    for i := 0 to elem.ingredientList.Count - 1 do
      ComposeSubstanceIngredient(xml, 'ingredient', elem.ingredientList[i]);
end;

{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUPPLYDELIVERY}
function TFHIRXmlParser.ParseSupplyDelivery(element : TMXmlElement; path : string) : TFhirSupplyDelivery;
var
  child : TMXmlElement;
begin
  result := TFhirSupplyDelivery.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSupplyDeliveryChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSupplyDeliveryChild(element : TFhirSupplyDelivery; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirSupplydeliveryStatusEnum, SYSTEMS_TFhirSupplydeliveryStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'type') then
        element.type_ := ParseCodeableConcept(child, path+'/type') {b}
      else if (child.localName = 'quantity') then
        element.quantity := ParseQuantity(child, path+'/quantity') {b}
      else if (child.localName = 'suppliedItem') then
        element.suppliedItem := ParseReference{Resource}(child, path+'/suppliedItem') {b}
      else if (child.localName = 'supplier') then
        element.supplier := ParseReference{TFhirPractitioner}(child, path+'/supplier') {b}
      else if (child.localName = 'whenPrepared') then
        element.whenPrepared := ParsePeriod(child, path+'/whenPrepared') {b}
      else if (child.localName = 'time') then
        element.timeElement := ParseDateTime(child, path+'/time') {b}
      else if (child.localName = 'destination') then
        element.destination := ParseReference{TFhirLocation}(child, path+'/destination') {b}
      else if (child.localName = 'receiver') then
        element.receiverList.Add(ParseReference{TFhirPractitioner}(child, path+'/receiver')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSupplyDelivery(xml : TXmlBuilder; name : String; elem : TFhirSupplyDelivery);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSupplyDeliveryChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSupplyDeliveryChildren(xml : TXmlBuilder; elem : TFhirSupplyDelivery);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirSupplydeliveryStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('type_') then
    ComposeCodeableConcept(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('quantity') then
    ComposeQuantity(xml, 'quantity', elem.quantity);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('suppliedItem') then
    ComposeReference{Resource}(xml, 'suppliedItem', elem.suppliedItem);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('supplier') then
    ComposeReference{TFhirPractitioner}(xml, 'supplier', elem.supplier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('whenPrepared') then
    ComposePeriod(xml, 'whenPrepared', elem.whenPrepared);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('time') then
    ComposeDateTime(xml, 'time', elem.timeElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('destination') then
    ComposeReference{TFhirLocation}(xml, 'destination', elem.destination);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('receiver') then
    for i := 0 to elem.receiverList.Count - 1 do
      ComposeReference{TFhirPractitioner}(xml, 'receiver', elem.receiverList[i]);
end;

{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
function TFHIRXmlParser.ParseSupplyRequestWhen(element : TMXmlElement; path : string) : TFhirSupplyRequestWhen;
var
  child : TMXmlElement;
begin
  result := TFhirSupplyRequestWhen.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSupplyRequestWhenChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSupplyRequestWhenChild(element : TFhirSupplyRequestWhen; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.code := ParseCodeableConcept(child, path+'/code') {b}
      else if (child.localName = 'schedule') then
        element.schedule := ParseTiming(child, path+'/schedule') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSupplyRequestWhen(xml : TXmlBuilder; name : String; elem : TFhirSupplyRequestWhen);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSupplyRequestWhenChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSupplyRequestWhenChildren(xml : TXmlBuilder; elem : TFhirSupplyRequestWhen);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeCodeableConcept(xml, 'code', elem.code);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeTiming(xml, 'schedule', elem.schedule);{x.2a}
end;

function TFHIRXmlParser.ParseSupplyRequest(element : TMXmlElement; path : string) : TFhirSupplyRequest;
var
  child : TMXmlElement;
begin
  result := TFhirSupplyRequest.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseSupplyRequestChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSupplyRequestChild(element : TFhirSupplyRequest; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'source') then
        element.source := ParseReference{Resource}(child, path+'/source') {b}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirSupplyrequestStatusEnum, SYSTEMS_TFhirSupplyrequestStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'kind') then
        element.kind := ParseCodeableConcept(child, path+'/kind') {b}
      else if (child.localName = 'orderedItem') then
        element.orderedItem := ParseReference{Resource}(child, path+'/orderedItem') {b}
      else if (child.localName = 'supplier') then
        element.supplierList.Add(ParseReference{TFhirOrganization}(child, path+'/supplier')){y.2}
      else if (child.localName = 'reasonCodeableConcept') then
        element.reason := ParseCodeableConcept(child, path+'/reasonCodeableConcept'){x.3}
      else if (child.localName = 'reasonReference') then
        element.reason := ParseReference(child, path+'/reasonReference') {a}
      else if (child.localName = 'when') then
        element.when := ParseSupplyRequestWhen(child, path+'/when') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeSupplyRequest(xml : TXmlBuilder; name : String; elem : TFhirSupplyRequest);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeSupplyRequestChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeSupplyRequestChildren(xml : TXmlBuilder; elem : TFhirSupplyRequest);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('source') then
    ComposeReference{Resource}(xml, 'source', elem.source);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('status') then
    ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirSupplyrequestStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('kind') then
    ComposeCodeableConcept(xml, 'kind', elem.kind);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('orderedItem') then
    ComposeReference{Resource}(xml, 'orderedItem', elem.orderedItem);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('supplier') then
    for i := 0 to elem.supplierList.Count - 1 do
      ComposeReference{TFhirOrganization}(xml, 'supplier', elem.supplierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirReference) {2} then
    ComposeReference(xml, 'reasonReference', TFhirReference(elem.reason));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('when') then
    ComposeSupplyRequestWhen(xml, 'when', elem.when);{x.2a}
end;

{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TESTSCRIPT}
function TFHIRXmlParser.ParseTestScriptContact(element : TMXmlElement; path : string) : TFhirTestScriptContact;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptContact.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptContactChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptContactChild(element : TFhirTestScriptContact; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'telecom') then
        element.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptContact(xml : TXmlBuilder; name : String; elem : TFhirTestScriptContact);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptContactChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptContactChildren(xml : TXmlBuilder; elem : TFhirTestScriptContact);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
end;

function TFHIRXmlParser.ParseTestScriptMetadata(element : TMXmlElement; path : string) : TFhirTestScriptMetadata;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptMetadata.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptMetadataChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptMetadataChild(element : TFhirTestScriptMetadata; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'link') then
        element.link_List.Add(ParseTestScriptMetadataLink(child, path+'/link')){y.2}
      else if (child.localName = 'capability') then
        element.capabilityList.Add(ParseTestScriptMetadataCapability(child, path+'/capability')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptMetadata(xml : TXmlBuilder; name : String; elem : TFhirTestScriptMetadata);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptMetadataChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptMetadataChildren(xml : TXmlBuilder; elem : TFhirTestScriptMetadata);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.link_List.Count - 1 do
      ComposeTestScriptMetadataLink(xml, 'link', elem.link_List[i]);
  for i := 0 to elem.capabilityList.Count - 1 do
      ComposeTestScriptMetadataCapability(xml, 'capability', elem.capabilityList[i]);
end;

function TFHIRXmlParser.ParseTestScriptMetadataLink(element : TMXmlElement; path : string) : TFhirTestScriptMetadataLink;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptMetadataLink.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptMetadataLinkChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptMetadataLinkChild(element : TFhirTestScriptMetadataLink; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptMetadataLink(xml : TXmlBuilder; name : String; elem : TFhirTestScriptMetadataLink);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptMetadataLinkChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptMetadataLinkChildren(xml : TXmlBuilder; elem : TFhirTestScriptMetadataLink);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
end;

function TFHIRXmlParser.ParseTestScriptMetadataCapability(element : TMXmlElement; path : string) : TFhirTestScriptMetadataCapability;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptMetadataCapability.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptMetadataCapabilityChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptMetadataCapabilityChild(element : TFhirTestScriptMetadataCapability; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'required') then
        element.requiredElement := ParseBoolean(child, path+'/required') {b}
      else if (child.localName = 'validated') then
        element.validatedElement := ParseBoolean(child, path+'/validated') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'destination') then
        element.destinationElement := ParseInteger(child, path+'/destination') {b}
      else if (child.localName = 'link') then
        element.link_List.Add(ParseUri(child, path+'/link')){y.2}
      else if (child.localName = 'conformance') then
        element.conformance := ParseReference{TFhirConformance}(child, path+'/conformance') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptMetadataCapability(xml : TXmlBuilder; name : String; elem : TFhirTestScriptMetadataCapability);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptMetadataCapabilityChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptMetadataCapabilityChildren(xml : TXmlBuilder; elem : TFhirTestScriptMetadataCapability);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.required <> false)) then
    ComposeBoolean(xml, 'required', elem.requiredElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.validated <> false)) then
    ComposeBoolean(xml, 'validated', elem.validatedElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(xml, 'destination', elem.destinationElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.link_List.Count - 1 do
      ComposeUri(xml, 'link', elem.link_List[i]);
  ComposeReference{TFhirConformance}(xml, 'conformance', elem.conformance);{x.2a}
end;

function TFHIRXmlParser.ParseTestScriptFixture(element : TMXmlElement; path : string) : TFhirTestScriptFixture;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptFixture.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptFixtureChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptFixtureChild(element : TFhirTestScriptFixture; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'autocreate') then
        element.autocreateElement := ParseBoolean(child, path+'/autocreate') {b}
      else if (child.localName = 'autodelete') then
        element.autodeleteElement := ParseBoolean(child, path+'/autodelete') {b}
      else if (child.localName = 'resource') then
        element.resource := ParseReference{TFhirReference}(child, path+'/resource') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptFixture(xml : TXmlBuilder; name : String; elem : TFhirTestScriptFixture);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptFixtureChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptFixtureChildren(xml : TXmlBuilder; elem : TFhirTestScriptFixture);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'autocreate', elem.autocreateElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'autodelete', elem.autodeleteElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeReference{TFhirReference}(xml, 'resource', elem.resource);{x.2a}
end;

function TFHIRXmlParser.ParseTestScriptVariable(element : TMXmlElement; path : string) : TFhirTestScriptVariable;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptVariable.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptVariableChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptVariableChild(element : TFhirTestScriptVariable; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'headerField') then
        element.headerFieldElement := ParseString(child, path+'/headerField') {b}
      else if (child.localName = 'path') then
        element.pathElement := ParseString(child, path+'/path') {b}
      else if (child.localName = 'sourceId') then
        element.sourceIdElement := ParseId(child, path+'/sourceId') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptVariable(xml : TXmlBuilder; name : String; elem : TFhirTestScriptVariable);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptVariableChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptVariableChildren(xml : TXmlBuilder; elem : TFhirTestScriptVariable);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'headerField', elem.headerFieldElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'path', elem.pathElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeId(xml, 'sourceId', elem.sourceIdElement);{x.2b}
end;

function TFHIRXmlParser.ParseTestScriptSetup(element : TMXmlElement; path : string) : TFhirTestScriptSetup;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptSetup.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptSetupChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptSetupChild(element : TFhirTestScriptSetup; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'metadata') then
        element.metadata := ParseTestScriptMetadata(child, path+'/metadata') {b}
      else if (child.localName = 'action') then
        element.actionList.Add(ParseTestScriptSetupAction(child, path+'/action')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetup(xml : TXmlBuilder; name : String; elem : TFhirTestScriptSetup);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptSetupChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetupChildren(xml : TXmlBuilder; elem : TFhirTestScriptSetup);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptMetadata(xml, 'metadata', elem.metadata);{x.2a}
  for i := 0 to elem.actionList.Count - 1 do
      ComposeTestScriptSetupAction(xml, 'action', elem.actionList[i]);
end;

function TFHIRXmlParser.ParseTestScriptSetupAction(element : TMXmlElement; path : string) : TFhirTestScriptSetupAction;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptSetupAction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptSetupActionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptSetupActionChild(element : TFhirTestScriptSetupAction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'operation') then
        element.operation := ParseTestScriptSetupActionOperation(child, path+'/operation') {b}
      else if (child.localName = 'assert') then
        element.assert := ParseTestScriptSetupActionAssert(child, path+'/assert') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetupAction(xml : TXmlBuilder; name : String; elem : TFhirTestScriptSetupAction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptSetupActionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetupActionChildren(xml : TXmlBuilder; elem : TFhirTestScriptSetupAction);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionOperation(xml, 'operation', elem.operation);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionAssert(xml, 'assert', elem.assert);{x.2a}
end;

function TFHIRXmlParser.ParseTestScriptSetupActionOperation(element : TMXmlElement; path : string) : TFhirTestScriptSetupActionOperation;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptSetupActionOperation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptSetupActionOperationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptSetupActionOperationChild(element : TFhirTestScriptSetupActionOperation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'type') then
        element.type_ := ParseCoding(child, path+'/type') {b}
      else if (child.localName = 'resource') then
        element.resourceElement := ParseCode(child, path+'/resource') {b}
      else if (child.localName = 'label') then
        element.label_Element := ParseString(child, path+'/label') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'accept') then
        element.acceptElement := ParseEnum(CODES_TFhirContentTypeEnum, SYSTEMS_TFhirContentTypeEnum, path+'/accept', child){1a}
      else if (child.localName = 'contentType') then
        element.contentTypeElement := ParseEnum(CODES_TFhirContentTypeEnum, SYSTEMS_TFhirContentTypeEnum, path+'/contentType', child){1a}
      else if (child.localName = 'destination') then
        element.destinationElement := ParseInteger(child, path+'/destination') {b}
      else if (child.localName = 'encodeRequestUrl') then
        element.encodeRequestUrlElement := ParseBoolean(child, path+'/encodeRequestUrl') {b}
      else if (child.localName = 'params') then
        element.paramsElement := ParseString(child, path+'/params') {b}
      else if (child.localName = 'requestHeader') then
        element.requestHeaderList.Add(ParseTestScriptSetupActionOperationRequestHeader(child, path+'/requestHeader')){y.2}
      else if (child.localName = 'responseId') then
        element.responseIdElement := ParseId(child, path+'/responseId') {b}
      else if (child.localName = 'sourceId') then
        element.sourceIdElement := ParseId(child, path+'/sourceId') {b}
      else if (child.localName = 'targetId') then
        element.targetIdElement := ParseId(child, path+'/targetId') {b}
      else if (child.localName = 'url') then
        element.urlElement := ParseString(child, path+'/url') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetupActionOperation(xml : TXmlBuilder; name : String; elem : TFhirTestScriptSetupActionOperation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptSetupActionOperationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetupActionOperationChildren(xml : TXmlBuilder; elem : TFhirTestScriptSetupActionOperation);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(xml, 'type', elem.type_);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'resource', elem.resourceElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'label', elem.label_Element);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'accept', elem.AcceptElement, CODES_TFhirContentTypeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'contentType', elem.ContentTypeElement, CODES_TFhirContentTypeEnum);
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.destination <> '0')) then
    ComposeInteger(xml, 'destination', elem.destinationElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.encodeRequestUrl <> true)) then
    ComposeBoolean(xml, 'encodeRequestUrl', elem.encodeRequestUrlElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'params', elem.paramsElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.requestHeaderList.Count - 1 do
      ComposeTestScriptSetupActionOperationRequestHeader(xml, 'requestHeader', elem.requestHeaderList[i]);
  if (SummaryOption in [soFull, soData]) then
    ComposeId(xml, 'responseId', elem.responseIdElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeId(xml, 'sourceId', elem.sourceIdElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeId(xml, 'targetId', elem.targetIdElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'url', elem.urlElement);{x.2b}
end;

function TFHIRXmlParser.ParseTestScriptSetupActionOperationRequestHeader(element : TMXmlElement; path : string) : TFhirTestScriptSetupActionOperationRequestHeader;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptSetupActionOperationRequestHeader.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptSetupActionOperationRequestHeaderChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptSetupActionOperationRequestHeaderChild(element : TFhirTestScriptSetupActionOperationRequestHeader; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'field') then
        element.fieldElement := ParseString(child, path+'/field') {b}
      else if (child.localName = 'value') then
        element.valueElement := ParseString(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetupActionOperationRequestHeader(xml : TXmlBuilder; name : String; elem : TFhirTestScriptSetupActionOperationRequestHeader);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptSetupActionOperationRequestHeaderChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetupActionOperationRequestHeaderChildren(xml : TXmlBuilder; elem : TFhirTestScriptSetupActionOperationRequestHeader);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'field', elem.fieldElement);{x.2b}
  ComposeString(xml, 'value', elem.valueElement);{x.2b}
end;

function TFHIRXmlParser.ParseTestScriptSetupActionAssert(element : TMXmlElement; path : string) : TFhirTestScriptSetupActionAssert;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptSetupActionAssert.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptSetupActionAssertChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptSetupActionAssertChild(element : TFhirTestScriptSetupActionAssert; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'label') then
        element.label_Element := ParseString(child, path+'/label') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'direction') then
        element.directionElement := ParseEnum(CODES_TFhirAssertDirectionCodesEnum, SYSTEMS_TFhirAssertDirectionCodesEnum, path+'/direction', child){1a}
      else if (child.localName = 'compareToSourceId') then
        element.compareToSourceIdElement := ParseString(child, path+'/compareToSourceId') {b}
      else if (child.localName = 'compareToSourcePath') then
        element.compareToSourcePathElement := ParseString(child, path+'/compareToSourcePath') {b}
      else if (child.localName = 'contentType') then
        element.contentTypeElement := ParseEnum(CODES_TFhirContentTypeEnum, SYSTEMS_TFhirContentTypeEnum, path+'/contentType', child){1a}
      else if (child.localName = 'headerField') then
        element.headerFieldElement := ParseString(child, path+'/headerField') {b}
      else if (child.localName = 'minimumId') then
        element.minimumIdElement := ParseString(child, path+'/minimumId') {b}
      else if (child.localName = 'navigationLinks') then
        element.navigationLinksElement := ParseBoolean(child, path+'/navigationLinks') {b}
      else if (child.localName = 'operator') then
        element.operatorElement := ParseEnum(CODES_TFhirAssertOperatorCodesEnum, SYSTEMS_TFhirAssertOperatorCodesEnum, path+'/operator', child){1a}
      else if (child.localName = 'path') then
        element.pathElement := ParseString(child, path+'/path') {b}
      else if (child.localName = 'resource') then
        element.resourceElement := ParseCode(child, path+'/resource') {b}
      else if (child.localName = 'response') then
        element.responseElement := ParseEnum(CODES_TFhirAssertResponseCodeTypesEnum, SYSTEMS_TFhirAssertResponseCodeTypesEnum, path+'/response', child){1a}
      else if (child.localName = 'responseCode') then
        element.responseCodeElement := ParseString(child, path+'/responseCode') {b}
      else if (child.localName = 'sourceId') then
        element.sourceIdElement := ParseId(child, path+'/sourceId') {b}
      else if (child.localName = 'validateProfileId') then
        element.validateProfileIdElement := ParseId(child, path+'/validateProfileId') {b}
      else if (child.localName = 'value') then
        element.valueElement := ParseString(child, path+'/value') {b}
      else if (child.localName = 'warningOnly') then
        element.warningOnlyElement := ParseBoolean(child, path+'/warningOnly') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetupActionAssert(xml : TXmlBuilder; name : String; elem : TFhirTestScriptSetupActionAssert);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptSetupActionAssertChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptSetupActionAssertChildren(xml : TXmlBuilder; elem : TFhirTestScriptSetupActionAssert);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'label', elem.label_Element);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'direction', elem.DirectionElement, CODES_TFhirAssertDirectionCodesEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'compareToSourceId', elem.compareToSourceIdElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'compareToSourcePath', elem.compareToSourcePathElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'contentType', elem.ContentTypeElement, CODES_TFhirContentTypeEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'headerField', elem.headerFieldElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'minimumId', elem.minimumIdElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'navigationLinks', elem.navigationLinksElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'operator', elem.OperatorElement, CODES_TFhirAssertOperatorCodesEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'path', elem.pathElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'resource', elem.resourceElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeEnum(xml, 'response', elem.ResponseElement, CODES_TFhirAssertResponseCodeTypesEnum);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'responseCode', elem.responseCodeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeId(xml, 'sourceId', elem.sourceIdElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeId(xml, 'validateProfileId', elem.validateProfileIdElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'value', elem.valueElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.warningOnly <> false)) then
    ComposeBoolean(xml, 'warningOnly', elem.warningOnlyElement);{x.2b}
end;

function TFHIRXmlParser.ParseTestScriptTest(element : TMXmlElement; path : string) : TFhirTestScriptTest;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptTest.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptTestChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptTestChild(element : TFhirTestScriptTest; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'metadata') then
        element.metadata := ParseTestScriptMetadata(child, path+'/metadata') {b}
      else if (child.localName = 'action') then
        element.actionList.Add(ParseTestScriptTestAction(child, path+'/action')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptTest(xml : TXmlBuilder; name : String; elem : TFhirTestScriptTest);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptTestChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptTestChildren(xml : TXmlBuilder; elem : TFhirTestScriptTest);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptMetadata(xml, 'metadata', elem.metadata);{x.2a}
  for i := 0 to elem.actionList.Count - 1 do
      ComposeTestScriptTestAction(xml, 'action', elem.actionList[i]);
end;

function TFHIRXmlParser.ParseTestScriptTestAction(element : TMXmlElement; path : string) : TFhirTestScriptTestAction;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptTestAction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptTestActionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptTestActionChild(element : TFhirTestScriptTestAction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'operation') then
        element.operation := ParseTestScriptSetupActionOperation(child, path+'/operation') {b}
      else if (child.localName = 'assert') then
        element.assert := ParseTestScriptSetupActionAssert(child, path+'/assert') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptTestAction(xml : TXmlBuilder; name : String; elem : TFhirTestScriptTestAction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptTestActionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptTestActionChildren(xml : TXmlBuilder; elem : TFhirTestScriptTestAction);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionOperation(xml, 'operation', elem.operation);{x.2a}
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionAssert(xml, 'assert', elem.assert);{x.2a}
end;

function TFHIRXmlParser.ParseTestScriptTeardown(element : TMXmlElement; path : string) : TFhirTestScriptTeardown;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptTeardown.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptTeardownChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptTeardownChild(element : TFhirTestScriptTeardown; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'action') then
        element.actionList.Add(ParseTestScriptTeardownAction(child, path+'/action')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptTeardown(xml : TXmlBuilder; name : String; elem : TFhirTestScriptTeardown);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptTeardownChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptTeardownChildren(xml : TXmlBuilder; elem : TFhirTestScriptTeardown);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  for i := 0 to elem.actionList.Count - 1 do
      ComposeTestScriptTeardownAction(xml, 'action', elem.actionList[i]);
end;

function TFHIRXmlParser.ParseTestScriptTeardownAction(element : TMXmlElement; path : string) : TFhirTestScriptTeardownAction;
var
  child : TMXmlElement;
begin
  result := TFhirTestScriptTeardownAction.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptTeardownActionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptTeardownActionChild(element : TFhirTestScriptTeardownAction; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'operation') then
        element.operation := ParseTestScriptSetupActionOperation(child, path+'/operation') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScriptTeardownAction(xml : TXmlBuilder; name : String; elem : TFhirTestScriptTeardownAction);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptTeardownActionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptTeardownActionChildren(xml : TXmlBuilder; elem : TFhirTestScriptTeardownAction);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeTestScriptSetupActionOperation(xml, 'operation', elem.operation);{x.2a}
end;

function TFHIRXmlParser.ParseTestScript(element : TMXmlElement; path : string) : TFhirTestScript;
var
  child : TMXmlElement;
begin
  result := TFhirTestScript.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseTestScriptChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseTestScriptChild(element : TFhirTestScript; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'experimental') then
        element.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.localName = 'publisher') then
        element.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.localName = 'contact') then
        element.contactList.Add(ParseTestScriptContact(child, path+'/contact')){y.2}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'useContext') then
        element.useContextList.Add(ParseCodeableConcept(child, path+'/useContext')){y.2}
      else if (child.localName = 'requirements') then
        element.requirementsElement := ParseString(child, path+'/requirements') {b}
      else if (child.localName = 'copyright') then
        element.copyrightElement := ParseString(child, path+'/copyright') {b}
      else if (child.localName = 'metadata') then
        element.metadata := ParseTestScriptMetadata(child, path+'/metadata') {b}
      else if (child.localName = 'multiserver') then
        element.multiserverElement := ParseBoolean(child, path+'/multiserver') {b}
      else if (child.localName = 'fixture') then
        element.fixtureList.Add(ParseTestScriptFixture(child, path+'/fixture')){y.2}
      else if (child.localName = 'profile') then
        element.profileList.Add(ParseReference{TFhirReference}(child, path+'/profile')){y.2}
      else if (child.localName = 'variable') then
        element.variableList.Add(ParseTestScriptVariable(child, path+'/variable')){y.2}
      else if (child.localName = 'setup') then
        element.setup := ParseTestScriptSetup(child, path+'/setup') {b}
      else if (child.localName = 'test') then
        element.testList.Add(ParseTestScriptTest(child, path+'/test')){y.2}
      else if (child.localName = 'teardown') then
        element.teardown := ParseTestScriptTeardown(child, path+'/teardown') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeTestScript(xml : TXmlBuilder; name : String; elem : TFhirTestScript);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeTestScriptChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeTestScriptChildren(xml : TXmlBuilder; elem : TFhirTestScript);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(xml, 'version', elem.versionElement);{x.2b}
  ComposeString(xml, 'name', elem.nameElement);{x.2b}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeTestScriptContact(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(xml, 'useContext', elem.useContextList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('requirements') then
    ComposeString(xml, 'requirements', elem.requirementsElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeString(xml, 'copyright', elem.copyrightElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('metadata') then
    ComposeTestScriptMetadata(xml, 'metadata', elem.metadata);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('multiserver') then
    ComposeBoolean(xml, 'multiserver', elem.multiserverElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('fixture') then
    for i := 0 to elem.fixtureList.Count - 1 do
      ComposeTestScriptFixture(xml, 'fixture', elem.fixtureList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('profile') then
    for i := 0 to elem.profileList.Count - 1 do
      ComposeReference{TFhirReference}(xml, 'profile', elem.profileList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('variable') then
    for i := 0 to elem.variableList.Count - 1 do
      ComposeTestScriptVariable(xml, 'variable', elem.variableList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('setup') then
    ComposeTestScriptSetup(xml, 'setup', elem.setup);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('test') then
    for i := 0 to elem.testList.Count - 1 do
      ComposeTestScriptTest(xml, 'test', elem.testList[i]);
  if (SummaryOption in [soFull, soData]) and doCompose('teardown') then
    ComposeTestScriptTeardown(xml, 'teardown', elem.teardown);{x.2a}
end;

{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
function TFHIRXmlParser.ParseValueSetContact(element : TMXmlElement; path : string) : TFhirValueSetContact;
var
  child : TMXmlElement;
begin
  result := TFhirValueSetContact.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseValueSetContactChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseValueSetContactChild(element : TFhirValueSetContact; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'telecom') then
        element.telecomList.Add(ParseContactPoint(child, path+'/telecom')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeValueSetContact(xml : TXmlBuilder; name : String; elem : TFhirValueSetContact);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeValueSetContactChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeValueSetContactChildren(xml : TXmlBuilder; elem : TFhirValueSetContact);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.telecomList.Count - 1 do
      ComposeContactPoint(xml, 'telecom', elem.telecomList[i]);
end;

function TFHIRXmlParser.ParseValueSetCodeSystem(element : TMXmlElement; path : string) : TFhirValueSetCodeSystem;
var
  child : TMXmlElement;
begin
  result := TFhirValueSetCodeSystem.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseValueSetCodeSystemChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseValueSetCodeSystemChild(element : TFhirValueSetCodeSystem; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'system') then
        element.systemElement := ParseUri(child, path+'/system') {b}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if (child.localName = 'caseSensitive') then
        element.caseSensitiveElement := ParseBoolean(child, path+'/caseSensitive') {b}
      else if (child.localName = 'concept') then
        element.conceptList.Add(ParseValueSetCodeSystemConcept(child, path+'/concept')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeValueSetCodeSystem(xml : TXmlBuilder; name : String; elem : TFhirValueSetCodeSystem);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeValueSetCodeSystemChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeValueSetCodeSystemChildren(xml : TXmlBuilder; elem : TFhirValueSetCodeSystem);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeUri(xml, 'system', elem.systemElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', elem.versionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeBoolean(xml, 'caseSensitive', elem.caseSensitiveElement);{x.2b}
  for i := 0 to elem.conceptList.Count - 1 do
      ComposeValueSetCodeSystemConcept(xml, 'concept', elem.conceptList[i]);
end;

function TFHIRXmlParser.ParseValueSetCodeSystemConcept(element : TMXmlElement; path : string) : TFhirValueSetCodeSystemConcept;
var
  child : TMXmlElement;
begin
  result := TFhirValueSetCodeSystemConcept.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseValueSetCodeSystemConceptChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseValueSetCodeSystemConceptChild(element : TFhirValueSetCodeSystemConcept; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.codeElement := ParseCode(child, path+'/code') {b}
      else if (child.localName = 'abstract') then
        element.abstractElement := ParseBoolean(child, path+'/abstract') {b}
      else if (child.localName = 'display') then
        element.displayElement := ParseString(child, path+'/display') {b}
      else if (child.localName = 'definition') then
        element.definitionElement := ParseString(child, path+'/definition') {b}
      else if (child.localName = 'designation') then
        element.designationList.Add(ParseValueSetCodeSystemConceptDesignation(child, path+'/designation')){y.2}
      else if (child.localName = 'concept') then
        element.conceptList.Add(ParseValueSetCodeSystemConcept(child, path+'/concept')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeValueSetCodeSystemConcept(xml : TXmlBuilder; name : String; elem : TFhirValueSetCodeSystemConcept);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeValueSetCodeSystemConceptChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeValueSetCodeSystemConceptChildren(xml : TXmlBuilder; elem : TFhirValueSetCodeSystemConcept);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCode(xml, 'code', elem.codeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and (not isCanonical or (elem.abstract <> false)) then
    ComposeBoolean(xml, 'abstract', elem.abstractElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'display', elem.displayElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'definition', elem.definitionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.designationList.Count - 1 do
      ComposeValueSetCodeSystemConceptDesignation(xml, 'designation', elem.designationList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeValueSetCodeSystemConcept(xml, 'concept', elem.conceptList[i]);
end;

function TFHIRXmlParser.ParseValueSetCodeSystemConceptDesignation(element : TMXmlElement; path : string) : TFhirValueSetCodeSystemConceptDesignation;
var
  child : TMXmlElement;
begin
  result := TFhirValueSetCodeSystemConceptDesignation.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseValueSetCodeSystemConceptDesignationChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseValueSetCodeSystemConceptDesignationChild(element : TFhirValueSetCodeSystemConceptDesignation; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'language') then
        element.languageElement := ParseCode(child, path+'/language') {b}
      else if (child.localName = 'use') then
        element.use := ParseCoding(child, path+'/use') {b}
      else if (child.localName = 'value') then
        element.valueElement := ParseString(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeValueSetCodeSystemConceptDesignation(xml : TXmlBuilder; name : String; elem : TFhirValueSetCodeSystemConceptDesignation);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeValueSetCodeSystemConceptDesignationChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeValueSetCodeSystemConceptDesignationChildren(xml : TXmlBuilder; elem : TFhirValueSetCodeSystemConceptDesignation);
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'language', elem.languageElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeCoding(xml, 'use', elem.use);{x.2a}
  ComposeString(xml, 'value', elem.valueElement);{x.2b}
end;

function TFHIRXmlParser.ParseValueSetCompose(element : TMXmlElement; path : string) : TFhirValueSetCompose;
var
  child : TMXmlElement;
begin
  result := TFhirValueSetCompose.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseValueSetComposeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseValueSetComposeChild(element : TFhirValueSetCompose; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'import') then
        element.importList.Add(ParseUri(child, path+'/import')){y.2}
      else if (child.localName = 'include') then
        element.includeList.Add(ParseValueSetComposeInclude(child, path+'/include')){y.2}
      else if (child.localName = 'exclude') then
        element.excludeList.Add(ParseValueSetComposeInclude(child, path+'/exclude')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeValueSetCompose(xml : TXmlBuilder; name : String; elem : TFhirValueSetCompose);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeValueSetComposeChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeValueSetComposeChildren(xml : TXmlBuilder; elem : TFhirValueSetCompose);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.importList.Count - 1 do
      ComposeUri(xml, 'import', elem.importList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) then
    for i := 0 to elem.includeList.Count - 1 do
      ComposeValueSetComposeInclude(xml, 'include', elem.includeList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.excludeList.Count - 1 do
      ComposeValueSetComposeInclude(xml, 'exclude', elem.excludeList[i]);
end;

function TFHIRXmlParser.ParseValueSetComposeInclude(element : TMXmlElement; path : string) : TFhirValueSetComposeInclude;
var
  child : TMXmlElement;
begin
  result := TFhirValueSetComposeInclude.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseValueSetComposeIncludeChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseValueSetComposeIncludeChild(element : TFhirValueSetComposeInclude; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'system') then
        element.systemElement := ParseUri(child, path+'/system') {b}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if (child.localName = 'concept') then
        element.conceptList.Add(ParseValueSetComposeIncludeConcept(child, path+'/concept')){y.2}
      else if (child.localName = 'filter') then
        element.filterList.Add(ParseValueSetComposeIncludeFilter(child, path+'/filter')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeValueSetComposeInclude(xml : TXmlBuilder; name : String; elem : TFhirValueSetComposeInclude);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeValueSetComposeIncludeChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeValueSetComposeIncludeChildren(xml : TXmlBuilder; elem : TFhirValueSetComposeInclude);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeUri(xml, 'system', elem.systemElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'version', elem.versionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.conceptList.Count - 1 do
      ComposeValueSetComposeIncludeConcept(xml, 'concept', elem.conceptList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.filterList.Count - 1 do
      ComposeValueSetComposeIncludeFilter(xml, 'filter', elem.filterList[i]);
end;

function TFHIRXmlParser.ParseValueSetComposeIncludeConcept(element : TMXmlElement; path : string) : TFhirValueSetComposeIncludeConcept;
var
  child : TMXmlElement;
begin
  result := TFhirValueSetComposeIncludeConcept.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseValueSetComposeIncludeConceptChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseValueSetComposeIncludeConceptChild(element : TFhirValueSetComposeIncludeConcept; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'code') then
        element.codeElement := ParseCode(child, path+'/code') {b}
      else if (child.localName = 'display') then
        element.displayElement := ParseString(child, path+'/display') {b}
      else if (child.localName = 'designation') then
        element.designationList.Add(ParseValueSetCodeSystemConceptDesignation(child, path+'/designation')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeValueSetComposeIncludeConcept(xml : TXmlBuilder; name : String; elem : TFhirValueSetComposeIncludeConcept);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeValueSetComposeIncludeConceptChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeValueSetComposeIncludeConceptChildren(xml : TXmlBuilder; elem : TFhirValueSetComposeIncludeConcept);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCode(xml, 'code', elem.codeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'display', elem.displayElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.designationList.Count - 1 do
      ComposeValueSetCodeSystemConceptDesignation(xml, 'designation', elem.designationList[i]);
end;

function TFHIRXmlParser.ParseValueSetComposeIncludeFilter(element : TMXmlElement; path : string) : TFhirValueSetComposeIncludeFilter;
var
  child : TMXmlElement;
begin
  result := TFhirValueSetComposeIncludeFilter.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseValueSetComposeIncludeFilterChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseValueSetComposeIncludeFilterChild(element : TFhirValueSetComposeIncludeFilter; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'property') then
        element.property_Element := ParseCode(child, path+'/property') {b}
      else if (child.localName = 'op') then
        element.opElement := ParseEnum(CODES_TFhirFilterOperatorEnum, SYSTEMS_TFhirFilterOperatorEnum, path+'/op', child){1a}
      else if (child.localName = 'value') then
        element.valueElement := ParseCode(child, path+'/value') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeValueSetComposeIncludeFilter(xml : TXmlBuilder; name : String; elem : TFhirValueSetComposeIncludeFilter);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeValueSetComposeIncludeFilterChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeValueSetComposeIncludeFilterChildren(xml : TXmlBuilder; elem : TFhirValueSetComposeIncludeFilter);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCode(xml, 'property', elem.property_Element);{x.2b}
  ComposeEnum(xml, 'op', elem.OpElement, CODES_TFhirFilterOperatorEnum);
  ComposeCode(xml, 'value', elem.valueElement);{x.2b}
end;

function TFHIRXmlParser.ParseValueSetExpansion(element : TMXmlElement; path : string) : TFhirValueSetExpansion;
var
  child : TMXmlElement;
begin
  result := TFhirValueSetExpansion.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseValueSetExpansionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseValueSetExpansionChild(element : TFhirValueSetExpansion; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierElement := ParseUri(child, path+'/identifier') {b}
      else if (child.localName = 'timestamp') then
        element.timestampElement := ParseDateTime(child, path+'/timestamp') {b}
      else if (child.localName = 'total') then
        element.totalElement := ParseInteger(child, path+'/total') {b}
      else if (child.localName = 'offset') then
        element.offsetElement := ParseInteger(child, path+'/offset') {b}
      else if (child.localName = 'parameter') then
        element.parameterList.Add(ParseValueSetExpansionParameter(child, path+'/parameter')){y.2}
      else if (child.localName = 'contains') then
        element.containsList.Add(ParseValueSetExpansionContains(child, path+'/contains')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeValueSetExpansion(xml : TXmlBuilder; name : String; elem : TFhirValueSetExpansion);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeValueSetExpansionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeValueSetExpansionChildren(xml : TXmlBuilder; elem : TFhirValueSetExpansion);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  ComposeUri(xml, 'identifier', elem.identifierElement);{x.2b}
  ComposeDateTime(xml, 'timestamp', elem.timestampElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(xml, 'total', elem.totalElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeInteger(xml, 'offset', elem.offsetElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.parameterList.Count - 1 do
      ComposeValueSetExpansionParameter(xml, 'parameter', elem.parameterList[i]);
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.containsList.Count - 1 do
      ComposeValueSetExpansionContains(xml, 'contains', elem.containsList[i]);
end;

function TFHIRXmlParser.ParseValueSetExpansionParameter(element : TMXmlElement; path : string) : TFhirValueSetExpansionParameter;
var
  child : TMXmlElement;
begin
  result := TFhirValueSetExpansionParameter.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseValueSetExpansionParameterChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseValueSetExpansionParameterChild(element : TFhirValueSetExpansionParameter; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'valueCode') then
        element.value := ParseCode(child, path+'/valueCode'){x.3}
      else if (child.localName = 'valueString') then
        element.value := ParseString(child, path+'/valueString'){x.3}
      else if (child.localName = 'valueBoolean') then
        element.value := ParseBoolean(child, path+'/valueBoolean'){x.3}
      else if (child.localName = 'valueInteger') then
        element.value := ParseInteger(child, path+'/valueInteger'){x.3}
      else if (child.localName = 'valueDecimal') then
        element.value := ParseDecimal(child, path+'/valueDecimal'){x.3}
      else if (child.localName = 'valueUri') then
        element.value := ParseUri(child, path+'/valueUri'){x.3}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeValueSetExpansionParameter(xml : TXmlBuilder; name : String; elem : TFhirValueSetExpansionParameter);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeValueSetExpansionParameterChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeValueSetExpansionParameterChildren(xml : TXmlBuilder; elem : TFhirValueSetExpansionParameter);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeString(xml, 'name', elem.nameElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and (elem.value is TFhirCode) {6} then
    ComposeCode(xml, 'valueCode', TFhirCode(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirString) {6} then
    ComposeString(xml, 'valueString', TFhirString(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirBoolean) {6} then
    ComposeBoolean(xml, 'valueBoolean', TFhirBoolean(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirInteger) {6} then
    ComposeInteger(xml, 'valueInteger', TFhirInteger(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirDecimal) {6} then
    ComposeDecimal(xml, 'valueDecimal', TFhirDecimal(elem.value))
  else if (SummaryOption in [soFull, soData]) and (elem.value is TFhirUri) {6} then
    ComposeUri(xml, 'valueUri', TFhirUri(elem.value));
end;

function TFHIRXmlParser.ParseValueSetExpansionContains(element : TMXmlElement; path : string) : TFhirValueSetExpansionContains;
var
  child : TMXmlElement;
begin
  result := TFhirValueSetExpansionContains.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseValueSetExpansionContainsChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseValueSetExpansionContainsChild(element : TFhirValueSetExpansionContains; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'system') then
        element.systemElement := ParseUri(child, path+'/system') {b}
      else if (child.localName = 'abstract') then
        element.abstractElement := ParseBoolean(child, path+'/abstract') {b}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if (child.localName = 'code') then
        element.codeElement := ParseCode(child, path+'/code') {b}
      else if (child.localName = 'display') then
        element.displayElement := ParseString(child, path+'/display') {b}
      else if (child.localName = 'contains') then
        element.containsList.Add(ParseValueSetExpansionContains(child, path+'/contains')){y.2}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeValueSetExpansionContains(xml : TXmlBuilder; name : String; elem : TFhirValueSetExpansionContains);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeValueSetExpansionContainsChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeValueSetExpansionContainsChildren(xml : TXmlBuilder; elem : TFhirValueSetExpansionContains);
var
  i : integer;
begin
  composeBackboneElementChildren(xml, elem);
  if (SummaryOption in [soFull, soData]) then
    ComposeUri(xml, 'system', elem.systemElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeBoolean(xml, 'abstract', elem.abstractElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'version', elem.versionElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeCode(xml, 'code', elem.codeElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    ComposeString(xml, 'display', elem.displayElement);{x.2b}
  if (SummaryOption in [soFull, soData]) then
    for i := 0 to elem.containsList.Count - 1 do
      ComposeValueSetExpansionContains(xml, 'contains', elem.containsList[i]);
end;

function TFHIRXmlParser.ParseValueSet(element : TMXmlElement; path : string) : TFhirValueSet;
var
  child : TMXmlElement;
begin
  result := TFhirValueSet.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseValueSetChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseValueSetChild(element : TFhirValueSet; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'url') then
        element.urlElement := ParseUri(child, path+'/url') {b}
      else if (child.localName = 'identifier') then
        element.identifier := ParseIdentifier(child, path+'/identifier') {b}
      else if (child.localName = 'version') then
        element.versionElement := ParseString(child, path+'/version') {b}
      else if (child.localName = 'name') then
        element.nameElement := ParseString(child, path+'/name') {b}
      else if (child.localName = 'status') then
        element.statusElement := ParseEnum(CODES_TFhirConformanceResourceStatusEnum, SYSTEMS_TFhirConformanceResourceStatusEnum, path+'/status', child){1a}
      else if (child.localName = 'experimental') then
        element.experimentalElement := ParseBoolean(child, path+'/experimental') {b}
      else if (child.localName = 'publisher') then
        element.publisherElement := ParseString(child, path+'/publisher') {b}
      else if (child.localName = 'contact') then
        element.contactList.Add(ParseValueSetContact(child, path+'/contact')){y.2}
      else if (child.localName = 'date') then
        element.dateElement := ParseDateTime(child, path+'/date') {b}
      else if (child.localName = 'lockedDate') then
        element.lockedDateElement := ParseDate(child, path+'/lockedDate') {b}
      else if (child.localName = 'description') then
        element.descriptionElement := ParseString(child, path+'/description') {b}
      else if (child.localName = 'useContext') then
        element.useContextList.Add(ParseCodeableConcept(child, path+'/useContext')){y.2}
      else if (child.localName = 'immutable') then
        element.immutableElement := ParseBoolean(child, path+'/immutable') {b}
      else if (child.localName = 'requirements') then
        element.requirementsElement := ParseString(child, path+'/requirements') {b}
      else if (child.localName = 'copyright') then
        element.copyrightElement := ParseString(child, path+'/copyright') {b}
      else if (child.localName = 'extensible') then
        element.extensibleElement := ParseBoolean(child, path+'/extensible') {b}
      else if (child.localName = 'codeSystem') then
        element.codeSystem := ParseValueSetCodeSystem(child, path+'/codeSystem') {b}
      else if (child.localName = 'compose') then
        element.compose := ParseValueSetCompose(child, path+'/compose') {b}
      else if (child.localName = 'expansion') then
        element.expansion := ParseValueSetExpansion(child, path+'/expansion') {b}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeValueSet(xml : TXmlBuilder; name : String; elem : TFhirValueSet);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeValueSetChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeValueSetChildren(xml : TXmlBuilder; elem : TFhirValueSet);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('url') then
    ComposeUri(xml, 'url', elem.urlElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    ComposeIdentifier(xml, 'identifier', elem.identifier);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('version') then
    ComposeString(xml, 'version', elem.versionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('name') then
    ComposeString(xml, 'name', elem.nameElement);{x.2b}
  ComposeEnum(xml, 'status', elem.StatusElement, CODES_TFhirConformanceResourceStatusEnum);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('experimental') then
    ComposeBoolean(xml, 'experimental', elem.experimentalElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('publisher') then
    ComposeString(xml, 'publisher', elem.publisherElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('contact') then
    for i := 0 to elem.contactList.Count - 1 do
      ComposeValueSetContact(xml, 'contact', elem.contactList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('date') then
    ComposeDateTime(xml, 'date', elem.dateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('lockedDate') then
    ComposeDate(xml, 'lockedDate', elem.lockedDateElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('description') then
    ComposeString(xml, 'description', elem.descriptionElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('useContext') then
    for i := 0 to elem.useContextList.Count - 1 do
      ComposeCodeableConcept(xml, 'useContext', elem.useContextList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('immutable') then
    ComposeBoolean(xml, 'immutable', elem.immutableElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('requirements') then
    ComposeString(xml, 'requirements', elem.requirementsElement);{x.2b}
  if (SummaryOption in [soFull, soData]) and doCompose('copyright') then
    ComposeString(xml, 'copyright', elem.copyrightElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('extensible') then
    ComposeBoolean(xml, 'extensible', elem.extensibleElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('codeSystem') then
    ComposeValueSetCodeSystem(xml, 'codeSystem', elem.codeSystem);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('compose') then
    ComposeValueSetCompose(xml, 'compose', elem.compose);{x.2a}
  if (SummaryOption in [soFull, soData]) and doCompose('expansion') then
    ComposeValueSetExpansion(xml, 'expansion', elem.expansion);{x.2a}
end;

{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VISIONPRESCRIPTION}
function TFHIRXmlParser.ParseVisionPrescriptionDispense(element : TMXmlElement; path : string) : TFhirVisionPrescriptionDispense;
var
  child : TMXmlElement;
begin
  result := TFhirVisionPrescriptionDispense.create;
  try
    parseElementAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseVisionPrescriptionDispenseChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseVisionPrescriptionDispenseChild(element : TFhirVisionPrescriptionDispense; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'product') then
        element.product := ParseCoding(child, path+'/product') {b}
      else if (child.localName = 'eye') then
        element.eyeElement := ParseEnum(CODES_TFhirVisionEyeCodesEnum, SYSTEMS_TFhirVisionEyeCodesEnum, path+'/eye', child){1a}
      else if (child.localName = 'sphere') then
        element.sphereElement := ParseDecimal(child, path+'/sphere') {b}
      else if (child.localName = 'cylinder') then
        element.cylinderElement := ParseDecimal(child, path+'/cylinder') {b}
      else if (child.localName = 'axis') then
        element.axisElement := ParseInteger(child, path+'/axis') {b}
      else if (child.localName = 'prism') then
        element.prismElement := ParseDecimal(child, path+'/prism') {b}
      else if (child.localName = 'base') then
        element.baseElement := ParseEnum(CODES_TFhirVisionBaseCodesEnum, SYSTEMS_TFhirVisionBaseCodesEnum, path+'/base', child){1a}
      else if (child.localName = 'add') then
        element.addElement := ParseDecimal(child, path+'/add') {b}
      else if (child.localName = 'power') then
        element.powerElement := ParseDecimal(child, path+'/power') {b}
      else if (child.localName = 'backCurve') then
        element.backCurveElement := ParseDecimal(child, path+'/backCurve') {b}
      else if (child.localName = 'diameter') then
        element.diameterElement := ParseDecimal(child, path+'/diameter') {b}
      else if (child.localName = 'duration') then
        element.duration := ParseQuantity(child, path+'/duration') {b}
      else if (child.localName = 'color') then
        element.colorElement := ParseString(child, path+'/color') {b}
      else if (child.localName = 'brand') then
        element.brandElement := ParseString(child, path+'/brand') {b}
      else if (child.localName = 'notes') then
        element.notesElement := ParseString(child, path+'/notes') {b}
      else if Not ParseBackboneElementChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeVisionPrescriptionDispense(xml : TXmlBuilder; name : String; elem : TFhirVisionPrescriptionDispense);
begin
  if (elem = nil) then
    exit;
  composeElementAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeVisionPrescriptionDispenseChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeVisionPrescriptionDispenseChildren(xml : TXmlBuilder; elem : TFhirVisionPrescriptionDispense);
begin
  composeBackboneElementChildren(xml, elem);
  ComposeCoding(xml, 'product', elem.product);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'eye', elem.EyeElement, CODES_TFhirVisionEyeCodesEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'sphere', elem.sphereElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'cylinder', elem.cylinderElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeInteger(xml, 'axis', elem.axisElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'prism', elem.prismElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeEnum(xml, 'base', elem.BaseElement, CODES_TFhirVisionBaseCodesEnum);
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'add', elem.addElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'power', elem.powerElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'backCurve', elem.backCurveElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeDecimal(xml, 'diameter', elem.diameterElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeQuantity(xml, 'duration', elem.duration);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'color', elem.colorElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'brand', elem.brandElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) then
    ComposeString(xml, 'notes', elem.notesElement);{x.2b}
end;

function TFHIRXmlParser.ParseVisionPrescription(element : TMXmlElement; path : string) : TFhirVisionPrescription;
var
  child : TMXmlElement;
begin
  result := TFhirVisionPrescription.create;
  try
    parseDomainResourceAttributes(result, path, element);
    child := FirstChild(element);
    while (child <> nil) do
    begin
      if not ParseVisionPrescriptionChild(result, path, child) then
        UnknownContent(child, path);
      child := NextSibling(child);
    end;
    closeOutElement(result, element);

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseVisionPrescriptionChild(element : TFhirVisionPrescription; path : string; child : TMXmlElement) : boolean;
begin
  result := true;
      if (child.localName = 'identifier') then
        element.identifierList.Add(ParseIdentifier(child, path+'/identifier')){y.2}
      else if (child.localName = 'dateWritten') then
        element.dateWrittenElement := ParseDateTime(child, path+'/dateWritten') {b}
      else if (child.localName = 'patient') then
        element.patient := ParseReference{TFhirPatient}(child, path+'/patient') {b}
      else if (child.localName = 'prescriber') then
        element.prescriber := ParseReference{TFhirPractitioner}(child, path+'/prescriber') {b}
      else if (child.localName = 'encounter') then
        element.encounter := ParseReference{TFhirEncounter}(child, path+'/encounter') {b}
      else if (child.localName = 'reasonCodeableConcept') then
        element.reason := ParseCodeableConcept(child, path+'/reasonCodeableConcept'){x.3}
      else if (child.localName = 'reasonReference') then
        element.reason := ParseReference(child, path+'/reasonReference') {a}
      else if (child.localName = 'dispense') then
        element.dispenseList.Add(ParseVisionPrescriptionDispense(child, path+'/dispense')){y.2}
      else if Not ParseDomainResourceChild(element, path, child) then
    result := false;
end;

procedure TFHIRXmlComposer.ComposeVisionPrescription(xml : TXmlBuilder; name : String; elem : TFhirVisionPrescription);
begin
  if (elem = nil) then
    exit;
  composeDomainResourceAttributes(xml, elem);
  if KeepLocationData then elem.LocationData.ComposeStart := xml.SourceLocation;
  xml.open(name);
  composeVisionPrescriptionChildren(xml, elem);
  closeOutElement(xml, elem);
  xml.close(name);
  if KeepLocationData then elem.LocationData.ComposeFinish := xml.SourceLocation;
end;

procedure TFHIRXmlComposer.ComposeVisionPrescriptionChildren(xml : TXmlBuilder; elem : TFhirVisionPrescription);
var
  i : integer;
begin
  composeDomainResourceChildren(xml, elem);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('identifier') then
    for i := 0 to elem.identifierList.Count - 1 do
      ComposeIdentifier(xml, 'identifier', elem.identifierList[i]);
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dateWritten') then
    ComposeDateTime(xml, 'dateWritten', elem.dateWrittenElement);{x.2b}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('patient') then
    ComposeReference{TFhirPatient}(xml, 'patient', elem.patient);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('prescriber') then
    ComposeReference{TFhirPractitioner}(xml, 'prescriber', elem.prescriber);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('encounter') then
    ComposeReference{TFhirEncounter}(xml, 'encounter', elem.encounter);{x.2a}
  if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirCodeableConcept) {6} then
    ComposeCodeableConcept(xml, 'reasonCodeableConcept', TFhirCodeableConcept(elem.reason))
  else if (SummaryOption in [soFull, soSummary, soData]) and (elem.reason is TFhirReference) {2} then
    ComposeReference(xml, 'reasonReference', TFhirReference(elem.reason));
  if (SummaryOption in [soFull, soSummary, soData]) and doCompose('dispense') then
    for i := 0 to elem.dispenseList.Count - 1 do
      ComposeVisionPrescriptionDispense(xml, 'dispense', elem.dispenseList[i]);
end;

{$ENDIF FHIR_VISIONPRESCRIPTION}
function TFHIRXmlParser.ParseResource(element : TMXmlElement; path : String) : TFhirResource;
begin
  if (element = nil) Then
    Raise EXmlException.Create('error - element is nil')
{$IFDEF FHIR_PARAMETERS}
  else if element.localName = 'Parameters' Then
    result := ParseParameters(element, path+'/Parameters')
{$ENDIF FHIR_PARAMETERS}
{$IFDEF FHIR_ACCOUNT}
  {$IFDEF FHIR_ACCOUNT}
   else if element.localName = 'Account' Then
    result := ParseAccount(element, path+'/Account') 
  {$ENDIF}
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
  {$IFDEF FHIR_ALLERGYINTOLERANCE}
   else if element.localName = 'AllergyIntolerance' Then
    result := ParseAllergyIntolerance(element, path+'/AllergyIntolerance') 
  {$ENDIF}
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
  {$IFDEF FHIR_APPOINTMENT}
   else if element.localName = 'Appointment' Then
    result := ParseAppointment(element, path+'/Appointment') 
  {$ENDIF}
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
  {$IFDEF FHIR_APPOINTMENTRESPONSE}
   else if element.localName = 'AppointmentResponse' Then
    result := ParseAppointmentResponse(element, path+'/AppointmentResponse') 
  {$ENDIF}
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
  {$IFDEF FHIR_AUDITEVENT}
   else if element.localName = 'AuditEvent' Then
    result := ParseAuditEvent(element, path+'/AuditEvent') 
  {$ENDIF}
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
  {$IFDEF FHIR_BASIC}
   else if element.localName = 'Basic' Then
    result := ParseBasic(element, path+'/Basic') 
  {$ENDIF}
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
  {$IFDEF FHIR_BINARY}
   else if element.localName = 'Binary' Then
    result := ParseBinary(element, path+'/Binary') 
  {$ENDIF}
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BODYSITE}
  {$IFDEF FHIR_BODYSITE}
   else if element.localName = 'BodySite' Then
    result := ParseBodySite(element, path+'/BodySite') 
  {$ENDIF}
{$ENDIF FHIR_BODYSITE}
{$IFDEF FHIR_BUNDLE}
  {$IFDEF FHIR_BUNDLE}
   else if element.localName = 'Bundle' Then
    result := ParseBundle(element, path+'/Bundle') 
  {$ENDIF}
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAREPLAN}
  {$IFDEF FHIR_CAREPLAN}
   else if element.localName = 'CarePlan' Then
    result := ParseCarePlan(element, path+'/CarePlan') 
  {$ENDIF}
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CLAIM}
  {$IFDEF FHIR_CLAIM}
   else if element.localName = 'Claim' Then
    result := ParseClaim(element, path+'/Claim') 
  {$ENDIF}
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
  {$IFDEF FHIR_CLAIMRESPONSE}
   else if element.localName = 'ClaimResponse' Then
    result := ParseClaimResponse(element, path+'/ClaimResponse') 
  {$ENDIF}
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
  {$IFDEF FHIR_CLINICALIMPRESSION}
   else if element.localName = 'ClinicalImpression' Then
    result := ParseClinicalImpression(element, path+'/ClinicalImpression') 
  {$ENDIF}
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_COMMUNICATION}
  {$IFDEF FHIR_COMMUNICATION}
   else if element.localName = 'Communication' Then
    result := ParseCommunication(element, path+'/Communication') 
  {$ENDIF}
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
  {$IFDEF FHIR_COMMUNICATIONREQUEST}
   else if element.localName = 'CommunicationRequest' Then
    result := ParseCommunicationRequest(element, path+'/CommunicationRequest') 
  {$ENDIF}
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPOSITION}
  {$IFDEF FHIR_COMPOSITION}
   else if element.localName = 'Composition' Then
    result := ParseComposition(element, path+'/Composition') 
  {$ENDIF}
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
  {$IFDEF FHIR_CONCEPTMAP}
   else if element.localName = 'ConceptMap' Then
    result := ParseConceptMap(element, path+'/ConceptMap') 
  {$ENDIF}
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
  {$IFDEF FHIR_CONDITION}
   else if element.localName = 'Condition' Then
    result := ParseCondition(element, path+'/Condition') 
  {$ENDIF}
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONFORMANCE}
  {$IFDEF FHIR_CONFORMANCE}
   else if element.localName = 'Conformance' Then
    result := ParseConformance(element, path+'/Conformance') 
  {$ENDIF}
{$ENDIF FHIR_CONFORMANCE}
{$IFDEF FHIR_CONTRACT}
  {$IFDEF FHIR_CONTRACT}
   else if element.localName = 'Contract' Then
    result := ParseContract(element, path+'/Contract') 
  {$ENDIF}
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
  {$IFDEF FHIR_COVERAGE}
   else if element.localName = 'Coverage' Then
    result := ParseCoverage(element, path+'/Coverage') 
  {$ENDIF}
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_DATAELEMENT}
  {$IFDEF FHIR_DATAELEMENT}
   else if element.localName = 'DataElement' Then
    result := ParseDataElement(element, path+'/DataElement') 
  {$ENDIF}
{$ENDIF FHIR_DATAELEMENT}
{$IFDEF FHIR_DETECTEDISSUE}
  {$IFDEF FHIR_DETECTEDISSUE}
   else if element.localName = 'DetectedIssue' Then
    result := ParseDetectedIssue(element, path+'/DetectedIssue') 
  {$ENDIF}
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
  {$IFDEF FHIR_DEVICE}
   else if element.localName = 'Device' Then
    result := ParseDevice(element, path+'/Device') 
  {$ENDIF}
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICECOMPONENT}
  {$IFDEF FHIR_DEVICECOMPONENT}
   else if element.localName = 'DeviceComponent' Then
    result := ParseDeviceComponent(element, path+'/DeviceComponent') 
  {$ENDIF}
{$ENDIF FHIR_DEVICECOMPONENT}
{$IFDEF FHIR_DEVICEMETRIC}
  {$IFDEF FHIR_DEVICEMETRIC}
   else if element.localName = 'DeviceMetric' Then
    result := ParseDeviceMetric(element, path+'/DeviceMetric') 
  {$ENDIF}
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEUSEREQUEST}
  {$IFDEF FHIR_DEVICEUSEREQUEST}
   else if element.localName = 'DeviceUseRequest' Then
    result := ParseDeviceUseRequest(element, path+'/DeviceUseRequest') 
  {$ENDIF}
{$ENDIF FHIR_DEVICEUSEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
  {$IFDEF FHIR_DEVICEUSESTATEMENT}
   else if element.localName = 'DeviceUseStatement' Then
    result := ParseDeviceUseStatement(element, path+'/DeviceUseStatement') 
  {$ENDIF}
{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICORDER}
  {$IFDEF FHIR_DIAGNOSTICORDER}
   else if element.localName = 'DiagnosticOrder' Then
    result := ParseDiagnosticOrder(element, path+'/DiagnosticOrder') 
  {$ENDIF}
{$ENDIF FHIR_DIAGNOSTICORDER}
{$IFDEF FHIR_DIAGNOSTICREPORT}
  {$IFDEF FHIR_DIAGNOSTICREPORT}
   else if element.localName = 'DiagnosticReport' Then
    result := ParseDiagnosticReport(element, path+'/DiagnosticReport') 
  {$ENDIF}
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
  {$IFDEF FHIR_DOCUMENTMANIFEST}
   else if element.localName = 'DocumentManifest' Then
    result := ParseDocumentManifest(element, path+'/DocumentManifest') 
  {$ENDIF}
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
  {$IFDEF FHIR_DOCUMENTREFERENCE}
   else if element.localName = 'DocumentReference' Then
    result := ParseDocumentReference(element, path+'/DocumentReference') 
  {$ENDIF}
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ELIGIBILITYREQUEST}
  {$IFDEF FHIR_ELIGIBILITYREQUEST}
   else if element.localName = 'EligibilityRequest' Then
    result := ParseEligibilityRequest(element, path+'/EligibilityRequest') 
  {$ENDIF}
{$ENDIF FHIR_ELIGIBILITYREQUEST}
{$IFDEF FHIR_ELIGIBILITYRESPONSE}
  {$IFDEF FHIR_ELIGIBILITYRESPONSE}
   else if element.localName = 'EligibilityResponse' Then
    result := ParseEligibilityResponse(element, path+'/EligibilityResponse') 
  {$ENDIF}
{$ENDIF FHIR_ELIGIBILITYRESPONSE}
{$IFDEF FHIR_ENCOUNTER}
  {$IFDEF FHIR_ENCOUNTER}
   else if element.localName = 'Encounter' Then
    result := ParseEncounter(element, path+'/Encounter') 
  {$ENDIF}
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENROLLMENTREQUEST}
  {$IFDEF FHIR_ENROLLMENTREQUEST}
   else if element.localName = 'EnrollmentRequest' Then
    result := ParseEnrollmentRequest(element, path+'/EnrollmentRequest') 
  {$ENDIF}
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
  {$IFDEF FHIR_ENROLLMENTRESPONSE}
   else if element.localName = 'EnrollmentResponse' Then
    result := ParseEnrollmentResponse(element, path+'/EnrollmentResponse') 
  {$ENDIF}
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
  {$IFDEF FHIR_EPISODEOFCARE}
   else if element.localName = 'EpisodeOfCare' Then
    result := ParseEpisodeOfCare(element, path+'/EpisodeOfCare') 
  {$ENDIF}
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
  {$IFDEF FHIR_EXPLANATIONOFBENEFIT}
   else if element.localName = 'ExplanationOfBenefit' Then
    result := ParseExplanationOfBenefit(element, path+'/ExplanationOfBenefit') 
  {$ENDIF}
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
  {$IFDEF FHIR_FAMILYMEMBERHISTORY}
   else if element.localName = 'FamilyMemberHistory' Then
    result := ParseFamilyMemberHistory(element, path+'/FamilyMemberHistory') 
  {$ENDIF}
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
  {$IFDEF FHIR_FLAG}
   else if element.localName = 'Flag' Then
    result := ParseFlag(element, path+'/Flag') 
  {$ENDIF}
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
  {$IFDEF FHIR_GOAL}
   else if element.localName = 'Goal' Then
    result := ParseGoal(element, path+'/Goal') 
  {$ENDIF}
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GROUP}
  {$IFDEF FHIR_GROUP}
   else if element.localName = 'Group' Then
    result := ParseGroup(element, path+'/Group') 
  {$ENDIF}
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_HEALTHCARESERVICE}
  {$IFDEF FHIR_HEALTHCARESERVICE}
   else if element.localName = 'HealthcareService' Then
    result := ParseHealthcareService(element, path+'/HealthcareService') 
  {$ENDIF}
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGOBJECTSELECTION}
  {$IFDEF FHIR_IMAGINGOBJECTSELECTION}
   else if element.localName = 'ImagingObjectSelection' Then
    result := ParseImagingObjectSelection(element, path+'/ImagingObjectSelection') 
  {$ENDIF}
{$ENDIF FHIR_IMAGINGOBJECTSELECTION}
{$IFDEF FHIR_IMAGINGSTUDY}
  {$IFDEF FHIR_IMAGINGSTUDY}
   else if element.localName = 'ImagingStudy' Then
    result := ParseImagingStudy(element, path+'/ImagingStudy') 
  {$ENDIF}
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
  {$IFDEF FHIR_IMMUNIZATION}
   else if element.localName = 'Immunization' Then
    result := ParseImmunization(element, path+'/Immunization') 
  {$ENDIF}
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
  {$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
   else if element.localName = 'ImmunizationRecommendation' Then
    result := ParseImmunizationRecommendation(element, path+'/ImmunizationRecommendation') 
  {$ENDIF}
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
  {$IFDEF FHIR_IMPLEMENTATIONGUIDE}
   else if element.localName = 'ImplementationGuide' Then
    result := ParseImplementationGuide(element, path+'/ImplementationGuide') 
  {$ENDIF}
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_LIST}
  {$IFDEF FHIR_LIST}
   else if element.localName = 'List' Then
    result := ParseList(element, path+'/List') 
  {$ENDIF}
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
  {$IFDEF FHIR_LOCATION}
   else if element.localName = 'Location' Then
    result := ParseLocation(element, path+'/Location') 
  {$ENDIF}
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEDIA}
  {$IFDEF FHIR_MEDIA}
   else if element.localName = 'Media' Then
    result := ParseMedia(element, path+'/Media') 
  {$ENDIF}
{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
  {$IFDEF FHIR_MEDICATION}
   else if element.localName = 'Medication' Then
    result := ParseMedication(element, path+'/Medication') 
  {$ENDIF}
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
  {$IFDEF FHIR_MEDICATIONADMINISTRATION}
   else if element.localName = 'MedicationAdministration' Then
    result := ParseMedicationAdministration(element, path+'/MedicationAdministration') 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
  {$IFDEF FHIR_MEDICATIONDISPENSE}
   else if element.localName = 'MedicationDispense' Then
    result := ParseMedicationDispense(element, path+'/MedicationDispense') 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONORDER}
  {$IFDEF FHIR_MEDICATIONORDER}
   else if element.localName = 'MedicationOrder' Then
    result := ParseMedicationOrder(element, path+'/MedicationOrder') 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONORDER}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
  {$IFDEF FHIR_MEDICATIONSTATEMENT}
   else if element.localName = 'MedicationStatement' Then
    result := ParseMedicationStatement(element, path+'/MedicationStatement') 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MESSAGEHEADER}
  {$IFDEF FHIR_MESSAGEHEADER}
   else if element.localName = 'MessageHeader' Then
    result := ParseMessageHeader(element, path+'/MessageHeader') 
  {$ENDIF}
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_NAMINGSYSTEM}
  {$IFDEF FHIR_NAMINGSYSTEM}
   else if element.localName = 'NamingSystem' Then
    result := ParseNamingSystem(element, path+'/NamingSystem') 
  {$ENDIF}
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
  {$IFDEF FHIR_NUTRITIONORDER}
   else if element.localName = 'NutritionOrder' Then
    result := ParseNutritionOrder(element, path+'/NutritionOrder') 
  {$ENDIF}
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
  {$IFDEF FHIR_OBSERVATION}
   else if element.localName = 'Observation' Then
    result := ParseObservation(element, path+'/Observation') 
  {$ENDIF}
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OPERATIONDEFINITION}
  {$IFDEF FHIR_OPERATIONDEFINITION}
   else if element.localName = 'OperationDefinition' Then
    result := ParseOperationDefinition(element, path+'/OperationDefinition') 
  {$ENDIF}
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
  {$IFDEF FHIR_OPERATIONOUTCOME}
   else if element.localName = 'OperationOutcome' Then
    result := ParseOperationOutcome(element, path+'/OperationOutcome') 
  {$ENDIF}
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORDER}
  {$IFDEF FHIR_ORDER}
   else if element.localName = 'Order' Then
    result := ParseOrder(element, path+'/Order') 
  {$ENDIF}
{$ENDIF FHIR_ORDER}
{$IFDEF FHIR_ORDERRESPONSE}
  {$IFDEF FHIR_ORDERRESPONSE}
   else if element.localName = 'OrderResponse' Then
    result := ParseOrderResponse(element, path+'/OrderResponse') 
  {$ENDIF}
{$ENDIF FHIR_ORDERRESPONSE}
{$IFDEF FHIR_ORGANIZATION}
  {$IFDEF FHIR_ORGANIZATION}
   else if element.localName = 'Organization' Then
    result := ParseOrganization(element, path+'/Organization') 
  {$ENDIF}
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_PATIENT}
  {$IFDEF FHIR_PATIENT}
   else if element.localName = 'Patient' Then
    result := ParsePatient(element, path+'/Patient') 
  {$ENDIF}
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
  {$IFDEF FHIR_PAYMENTNOTICE}
   else if element.localName = 'PaymentNotice' Then
    result := ParsePaymentNotice(element, path+'/PaymentNotice') 
  {$ENDIF}
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
  {$IFDEF FHIR_PAYMENTRECONCILIATION}
   else if element.localName = 'PaymentReconciliation' Then
    result := ParsePaymentReconciliation(element, path+'/PaymentReconciliation') 
  {$ENDIF}
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
  {$IFDEF FHIR_PERSON}
   else if element.localName = 'Person' Then
    result := ParsePerson(element, path+'/Person') 
  {$ENDIF}
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PRACTITIONER}
  {$IFDEF FHIR_PRACTITIONER}
   else if element.localName = 'Practitioner' Then
    result := ParsePractitioner(element, path+'/Practitioner') 
  {$ENDIF}
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PROCEDURE}
  {$IFDEF FHIR_PROCEDURE}
   else if element.localName = 'Procedure' Then
    result := ParseProcedure(element, path+'/Procedure') 
  {$ENDIF}
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROCEDUREREQUEST}
  {$IFDEF FHIR_PROCEDUREREQUEST}
   else if element.localName = 'ProcedureRequest' Then
    result := ParseProcedureRequest(element, path+'/ProcedureRequest') 
  {$ENDIF}
{$ENDIF FHIR_PROCEDUREREQUEST}
{$IFDEF FHIR_PROCESSREQUEST}
  {$IFDEF FHIR_PROCESSREQUEST}
   else if element.localName = 'ProcessRequest' Then
    result := ParseProcessRequest(element, path+'/ProcessRequest') 
  {$ENDIF}
{$ENDIF FHIR_PROCESSREQUEST}
{$IFDEF FHIR_PROCESSRESPONSE}
  {$IFDEF FHIR_PROCESSRESPONSE}
   else if element.localName = 'ProcessResponse' Then
    result := ParseProcessResponse(element, path+'/ProcessResponse') 
  {$ENDIF}
{$ENDIF FHIR_PROCESSRESPONSE}
{$IFDEF FHIR_PROVENANCE}
  {$IFDEF FHIR_PROVENANCE}
   else if element.localName = 'Provenance' Then
    result := ParseProvenance(element, path+'/Provenance') 
  {$ENDIF}
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
  {$IFDEF FHIR_QUESTIONNAIRE}
   else if element.localName = 'Questionnaire' Then
    result := ParseQuestionnaire(element, path+'/Questionnaire') 
  {$ENDIF}
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
  {$IFDEF FHIR_QUESTIONNAIRERESPONSE}
   else if element.localName = 'QuestionnaireResponse' Then
    result := ParseQuestionnaireResponse(element, path+'/QuestionnaireResponse') 
  {$ENDIF}
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REFERRALREQUEST}
  {$IFDEF FHIR_REFERRALREQUEST}
   else if element.localName = 'ReferralRequest' Then
    result := ParseReferralRequest(element, path+'/ReferralRequest') 
  {$ENDIF}
{$ENDIF FHIR_REFERRALREQUEST}
{$IFDEF FHIR_RELATEDPERSON}
  {$IFDEF FHIR_RELATEDPERSON}
   else if element.localName = 'RelatedPerson' Then
    result := ParseRelatedPerson(element, path+'/RelatedPerson') 
  {$ENDIF}
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_RISKASSESSMENT}
  {$IFDEF FHIR_RISKASSESSMENT}
   else if element.localName = 'RiskAssessment' Then
    result := ParseRiskAssessment(element, path+'/RiskAssessment') 
  {$ENDIF}
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
  {$IFDEF FHIR_SCHEDULE}
   else if element.localName = 'Schedule' Then
    result := ParseSchedule(element, path+'/Schedule') 
  {$ENDIF}
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
  {$IFDEF FHIR_SEARCHPARAMETER}
   else if element.localName = 'SearchParameter' Then
    result := ParseSearchParameter(element, path+'/SearchParameter') 
  {$ENDIF}
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SLOT}
  {$IFDEF FHIR_SLOT}
   else if element.localName = 'Slot' Then
    result := ParseSlot(element, path+'/Slot') 
  {$ENDIF}
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
  {$IFDEF FHIR_SPECIMEN}
   else if element.localName = 'Specimen' Then
    result := ParseSpecimen(element, path+'/Specimen') 
  {$ENDIF}
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_STRUCTUREDEFINITION}
  {$IFDEF FHIR_STRUCTUREDEFINITION}
   else if element.localName = 'StructureDefinition' Then
    result := ParseStructureDefinition(element, path+'/StructureDefinition') 
  {$ENDIF}
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_SUBSCRIPTION}
  {$IFDEF FHIR_SUBSCRIPTION}
   else if element.localName = 'Subscription' Then
    result := ParseSubscription(element, path+'/Subscription') 
  {$ENDIF}
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
  {$IFDEF FHIR_SUBSTANCE}
   else if element.localName = 'Substance' Then
    result := ParseSubstance(element, path+'/Substance') 
  {$ENDIF}
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUPPLYDELIVERY}
  {$IFDEF FHIR_SUPPLYDELIVERY}
   else if element.localName = 'SupplyDelivery' Then
    result := ParseSupplyDelivery(element, path+'/SupplyDelivery') 
  {$ENDIF}
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
  {$IFDEF FHIR_SUPPLYREQUEST}
   else if element.localName = 'SupplyRequest' Then
    result := ParseSupplyRequest(element, path+'/SupplyRequest') 
  {$ENDIF}
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TESTSCRIPT}
  {$IFDEF FHIR_TESTSCRIPT}
   else if element.localName = 'TestScript' Then
    result := ParseTestScript(element, path+'/TestScript') 
  {$ENDIF}
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
  {$IFDEF FHIR_VALUESET}
   else if element.localName = 'ValueSet' Then
    result := ParseValueSet(element, path+'/ValueSet') 
  {$ENDIF}
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VISIONPRESCRIPTION}
  {$IFDEF FHIR_VISIONPRESCRIPTION}
   else if element.localName = 'VisionPrescription' Then
    result := ParseVisionPrescription(element, path+'/VisionPrescription') 
  {$ENDIF}
{$ENDIF FHIR_VISIONPRESCRIPTION}
  else
    raise EXmlException.Create('Error: the element '+element.localName+' is not recognised as a valid resource name');
end;

procedure TFHIRXmlComposer.ComposeResource(xml : TXmlBuilder; resource: TFhirResource);
begin
  if (resource = nil) Then
    Raise EXmlException.Create('error - resource is nil');
  Case resource.ResourceType of
{$IFDEF FHIR_PARAMETERS}
    frtParameters: ComposeParameters(xml, 'Parameters', TFhirParameters(resource));
{$ENDIF FHIR_PARAMETERS}
{$IFDEF FHIR_ACCOUNT}
  {$IFDEF FHIR_ACCOUNT}
     frtAccount: ComposeAccount(xml, 'Account', TFhirAccount(resource)); 
  {$ENDIF}
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
  {$IFDEF FHIR_ALLERGYINTOLERANCE}
     frtAllergyIntolerance: ComposeAllergyIntolerance(xml, 'AllergyIntolerance', TFhirAllergyIntolerance(resource)); 
  {$ENDIF}
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
  {$IFDEF FHIR_APPOINTMENT}
     frtAppointment: ComposeAppointment(xml, 'Appointment', TFhirAppointment(resource)); 
  {$ENDIF}
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
  {$IFDEF FHIR_APPOINTMENTRESPONSE}
     frtAppointmentResponse: ComposeAppointmentResponse(xml, 'AppointmentResponse', TFhirAppointmentResponse(resource)); 
  {$ENDIF}
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
  {$IFDEF FHIR_AUDITEVENT}
     frtAuditEvent: ComposeAuditEvent(xml, 'AuditEvent', TFhirAuditEvent(resource)); 
  {$ENDIF}
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
  {$IFDEF FHIR_BASIC}
     frtBasic: ComposeBasic(xml, 'Basic', TFhirBasic(resource)); 
  {$ENDIF}
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
  {$IFDEF FHIR_BINARY}
     frtBinary: ComposeBinary(xml, 'Binary', TFhirBinary(resource)); 
  {$ENDIF}
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BODYSITE}
  {$IFDEF FHIR_BODYSITE}
     frtBodySite: ComposeBodySite(xml, 'BodySite', TFhirBodySite(resource)); 
  {$ENDIF}
{$ENDIF FHIR_BODYSITE}
{$IFDEF FHIR_BUNDLE}
  {$IFDEF FHIR_BUNDLE}
     frtBundle: ComposeBundle(xml, 'Bundle', TFhirBundle(resource)); 
  {$ENDIF}
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAREPLAN}
  {$IFDEF FHIR_CAREPLAN}
     frtCarePlan: ComposeCarePlan(xml, 'CarePlan', TFhirCarePlan(resource)); 
  {$ENDIF}
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CLAIM}
  {$IFDEF FHIR_CLAIM}
     frtClaim: ComposeClaim(xml, 'Claim', TFhirClaim(resource)); 
  {$ENDIF}
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
  {$IFDEF FHIR_CLAIMRESPONSE}
     frtClaimResponse: ComposeClaimResponse(xml, 'ClaimResponse', TFhirClaimResponse(resource)); 
  {$ENDIF}
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
  {$IFDEF FHIR_CLINICALIMPRESSION}
     frtClinicalImpression: ComposeClinicalImpression(xml, 'ClinicalImpression', TFhirClinicalImpression(resource)); 
  {$ENDIF}
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_COMMUNICATION}
  {$IFDEF FHIR_COMMUNICATION}
     frtCommunication: ComposeCommunication(xml, 'Communication', TFhirCommunication(resource)); 
  {$ENDIF}
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
  {$IFDEF FHIR_COMMUNICATIONREQUEST}
     frtCommunicationRequest: ComposeCommunicationRequest(xml, 'CommunicationRequest', TFhirCommunicationRequest(resource)); 
  {$ENDIF}
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPOSITION}
  {$IFDEF FHIR_COMPOSITION}
     frtComposition: ComposeComposition(xml, 'Composition', TFhirComposition(resource)); 
  {$ENDIF}
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
  {$IFDEF FHIR_CONCEPTMAP}
     frtConceptMap: ComposeConceptMap(xml, 'ConceptMap', TFhirConceptMap(resource)); 
  {$ENDIF}
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
  {$IFDEF FHIR_CONDITION}
     frtCondition: ComposeCondition(xml, 'Condition', TFhirCondition(resource)); 
  {$ENDIF}
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONFORMANCE}
  {$IFDEF FHIR_CONFORMANCE}
     frtConformance: ComposeConformance(xml, 'Conformance', TFhirConformance(resource)); 
  {$ENDIF}
{$ENDIF FHIR_CONFORMANCE}
{$IFDEF FHIR_CONTRACT}
  {$IFDEF FHIR_CONTRACT}
     frtContract: ComposeContract(xml, 'Contract', TFhirContract(resource)); 
  {$ENDIF}
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
  {$IFDEF FHIR_COVERAGE}
     frtCoverage: ComposeCoverage(xml, 'Coverage', TFhirCoverage(resource)); 
  {$ENDIF}
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_DATAELEMENT}
  {$IFDEF FHIR_DATAELEMENT}
     frtDataElement: ComposeDataElement(xml, 'DataElement', TFhirDataElement(resource)); 
  {$ENDIF}
{$ENDIF FHIR_DATAELEMENT}
{$IFDEF FHIR_DETECTEDISSUE}
  {$IFDEF FHIR_DETECTEDISSUE}
     frtDetectedIssue: ComposeDetectedIssue(xml, 'DetectedIssue', TFhirDetectedIssue(resource)); 
  {$ENDIF}
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
  {$IFDEF FHIR_DEVICE}
     frtDevice: ComposeDevice(xml, 'Device', TFhirDevice(resource)); 
  {$ENDIF}
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICECOMPONENT}
  {$IFDEF FHIR_DEVICECOMPONENT}
     frtDeviceComponent: ComposeDeviceComponent(xml, 'DeviceComponent', TFhirDeviceComponent(resource)); 
  {$ENDIF}
{$ENDIF FHIR_DEVICECOMPONENT}
{$IFDEF FHIR_DEVICEMETRIC}
  {$IFDEF FHIR_DEVICEMETRIC}
     frtDeviceMetric: ComposeDeviceMetric(xml, 'DeviceMetric', TFhirDeviceMetric(resource)); 
  {$ENDIF}
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEUSEREQUEST}
  {$IFDEF FHIR_DEVICEUSEREQUEST}
     frtDeviceUseRequest: ComposeDeviceUseRequest(xml, 'DeviceUseRequest', TFhirDeviceUseRequest(resource)); 
  {$ENDIF}
{$ENDIF FHIR_DEVICEUSEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
  {$IFDEF FHIR_DEVICEUSESTATEMENT}
     frtDeviceUseStatement: ComposeDeviceUseStatement(xml, 'DeviceUseStatement', TFhirDeviceUseStatement(resource)); 
  {$ENDIF}
{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICORDER}
  {$IFDEF FHIR_DIAGNOSTICORDER}
     frtDiagnosticOrder: ComposeDiagnosticOrder(xml, 'DiagnosticOrder', TFhirDiagnosticOrder(resource)); 
  {$ENDIF}
{$ENDIF FHIR_DIAGNOSTICORDER}
{$IFDEF FHIR_DIAGNOSTICREPORT}
  {$IFDEF FHIR_DIAGNOSTICREPORT}
     frtDiagnosticReport: ComposeDiagnosticReport(xml, 'DiagnosticReport', TFhirDiagnosticReport(resource)); 
  {$ENDIF}
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
  {$IFDEF FHIR_DOCUMENTMANIFEST}
     frtDocumentManifest: ComposeDocumentManifest(xml, 'DocumentManifest', TFhirDocumentManifest(resource)); 
  {$ENDIF}
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
  {$IFDEF FHIR_DOCUMENTREFERENCE}
     frtDocumentReference: ComposeDocumentReference(xml, 'DocumentReference', TFhirDocumentReference(resource)); 
  {$ENDIF}
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ELIGIBILITYREQUEST}
  {$IFDEF FHIR_ELIGIBILITYREQUEST}
     frtEligibilityRequest: ComposeEligibilityRequest(xml, 'EligibilityRequest', TFhirEligibilityRequest(resource)); 
  {$ENDIF}
{$ENDIF FHIR_ELIGIBILITYREQUEST}
{$IFDEF FHIR_ELIGIBILITYRESPONSE}
  {$IFDEF FHIR_ELIGIBILITYRESPONSE}
     frtEligibilityResponse: ComposeEligibilityResponse(xml, 'EligibilityResponse', TFhirEligibilityResponse(resource)); 
  {$ENDIF}
{$ENDIF FHIR_ELIGIBILITYRESPONSE}
{$IFDEF FHIR_ENCOUNTER}
  {$IFDEF FHIR_ENCOUNTER}
     frtEncounter: ComposeEncounter(xml, 'Encounter', TFhirEncounter(resource)); 
  {$ENDIF}
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENROLLMENTREQUEST}
  {$IFDEF FHIR_ENROLLMENTREQUEST}
     frtEnrollmentRequest: ComposeEnrollmentRequest(xml, 'EnrollmentRequest', TFhirEnrollmentRequest(resource)); 
  {$ENDIF}
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
  {$IFDEF FHIR_ENROLLMENTRESPONSE}
     frtEnrollmentResponse: ComposeEnrollmentResponse(xml, 'EnrollmentResponse', TFhirEnrollmentResponse(resource)); 
  {$ENDIF}
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
  {$IFDEF FHIR_EPISODEOFCARE}
     frtEpisodeOfCare: ComposeEpisodeOfCare(xml, 'EpisodeOfCare', TFhirEpisodeOfCare(resource)); 
  {$ENDIF}
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
  {$IFDEF FHIR_EXPLANATIONOFBENEFIT}
     frtExplanationOfBenefit: ComposeExplanationOfBenefit(xml, 'ExplanationOfBenefit', TFhirExplanationOfBenefit(resource)); 
  {$ENDIF}
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
  {$IFDEF FHIR_FAMILYMEMBERHISTORY}
     frtFamilyMemberHistory: ComposeFamilyMemberHistory(xml, 'FamilyMemberHistory', TFhirFamilyMemberHistory(resource)); 
  {$ENDIF}
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
  {$IFDEF FHIR_FLAG}
     frtFlag: ComposeFlag(xml, 'Flag', TFhirFlag(resource)); 
  {$ENDIF}
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
  {$IFDEF FHIR_GOAL}
     frtGoal: ComposeGoal(xml, 'Goal', TFhirGoal(resource)); 
  {$ENDIF}
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GROUP}
  {$IFDEF FHIR_GROUP}
     frtGroup: ComposeGroup(xml, 'Group', TFhirGroup(resource)); 
  {$ENDIF}
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_HEALTHCARESERVICE}
  {$IFDEF FHIR_HEALTHCARESERVICE}
     frtHealthcareService: ComposeHealthcareService(xml, 'HealthcareService', TFhirHealthcareService(resource)); 
  {$ENDIF}
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGOBJECTSELECTION}
  {$IFDEF FHIR_IMAGINGOBJECTSELECTION}
     frtImagingObjectSelection: ComposeImagingObjectSelection(xml, 'ImagingObjectSelection', TFhirImagingObjectSelection(resource)); 
  {$ENDIF}
{$ENDIF FHIR_IMAGINGOBJECTSELECTION}
{$IFDEF FHIR_IMAGINGSTUDY}
  {$IFDEF FHIR_IMAGINGSTUDY}
     frtImagingStudy: ComposeImagingStudy(xml, 'ImagingStudy', TFhirImagingStudy(resource)); 
  {$ENDIF}
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
  {$IFDEF FHIR_IMMUNIZATION}
     frtImmunization: ComposeImmunization(xml, 'Immunization', TFhirImmunization(resource)); 
  {$ENDIF}
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
  {$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
     frtImmunizationRecommendation: ComposeImmunizationRecommendation(xml, 'ImmunizationRecommendation', TFhirImmunizationRecommendation(resource)); 
  {$ENDIF}
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
  {$IFDEF FHIR_IMPLEMENTATIONGUIDE}
     frtImplementationGuide: ComposeImplementationGuide(xml, 'ImplementationGuide', TFhirImplementationGuide(resource)); 
  {$ENDIF}
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_LIST}
  {$IFDEF FHIR_LIST}
     frtList: ComposeList(xml, 'List', TFhirList(resource)); 
  {$ENDIF}
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
  {$IFDEF FHIR_LOCATION}
     frtLocation: ComposeLocation(xml, 'Location', TFhirLocation(resource)); 
  {$ENDIF}
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEDIA}
  {$IFDEF FHIR_MEDIA}
     frtMedia: ComposeMedia(xml, 'Media', TFhirMedia(resource)); 
  {$ENDIF}
{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
  {$IFDEF FHIR_MEDICATION}
     frtMedication: ComposeMedication(xml, 'Medication', TFhirMedication(resource)); 
  {$ENDIF}
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
  {$IFDEF FHIR_MEDICATIONADMINISTRATION}
     frtMedicationAdministration: ComposeMedicationAdministration(xml, 'MedicationAdministration', TFhirMedicationAdministration(resource)); 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
  {$IFDEF FHIR_MEDICATIONDISPENSE}
     frtMedicationDispense: ComposeMedicationDispense(xml, 'MedicationDispense', TFhirMedicationDispense(resource)); 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONORDER}
  {$IFDEF FHIR_MEDICATIONORDER}
     frtMedicationOrder: ComposeMedicationOrder(xml, 'MedicationOrder', TFhirMedicationOrder(resource)); 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONORDER}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
  {$IFDEF FHIR_MEDICATIONSTATEMENT}
     frtMedicationStatement: ComposeMedicationStatement(xml, 'MedicationStatement', TFhirMedicationStatement(resource)); 
  {$ENDIF}
{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MESSAGEHEADER}
  {$IFDEF FHIR_MESSAGEHEADER}
     frtMessageHeader: ComposeMessageHeader(xml, 'MessageHeader', TFhirMessageHeader(resource)); 
  {$ENDIF}
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_NAMINGSYSTEM}
  {$IFDEF FHIR_NAMINGSYSTEM}
     frtNamingSystem: ComposeNamingSystem(xml, 'NamingSystem', TFhirNamingSystem(resource)); 
  {$ENDIF}
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
  {$IFDEF FHIR_NUTRITIONORDER}
     frtNutritionOrder: ComposeNutritionOrder(xml, 'NutritionOrder', TFhirNutritionOrder(resource)); 
  {$ENDIF}
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
  {$IFDEF FHIR_OBSERVATION}
     frtObservation: ComposeObservation(xml, 'Observation', TFhirObservation(resource)); 
  {$ENDIF}
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OPERATIONDEFINITION}
  {$IFDEF FHIR_OPERATIONDEFINITION}
     frtOperationDefinition: ComposeOperationDefinition(xml, 'OperationDefinition', TFhirOperationDefinition(resource)); 
  {$ENDIF}
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
  {$IFDEF FHIR_OPERATIONOUTCOME}
     frtOperationOutcome: ComposeOperationOutcome(xml, 'OperationOutcome', TFhirOperationOutcome(resource)); 
  {$ENDIF}
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORDER}
  {$IFDEF FHIR_ORDER}
     frtOrder: ComposeOrder(xml, 'Order', TFhirOrder(resource)); 
  {$ENDIF}
{$ENDIF FHIR_ORDER}
{$IFDEF FHIR_ORDERRESPONSE}
  {$IFDEF FHIR_ORDERRESPONSE}
     frtOrderResponse: ComposeOrderResponse(xml, 'OrderResponse', TFhirOrderResponse(resource)); 
  {$ENDIF}
{$ENDIF FHIR_ORDERRESPONSE}
{$IFDEF FHIR_ORGANIZATION}
  {$IFDEF FHIR_ORGANIZATION}
     frtOrganization: ComposeOrganization(xml, 'Organization', TFhirOrganization(resource)); 
  {$ENDIF}
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_PATIENT}
  {$IFDEF FHIR_PATIENT}
     frtPatient: ComposePatient(xml, 'Patient', TFhirPatient(resource)); 
  {$ENDIF}
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
  {$IFDEF FHIR_PAYMENTNOTICE}
     frtPaymentNotice: ComposePaymentNotice(xml, 'PaymentNotice', TFhirPaymentNotice(resource)); 
  {$ENDIF}
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
  {$IFDEF FHIR_PAYMENTRECONCILIATION}
     frtPaymentReconciliation: ComposePaymentReconciliation(xml, 'PaymentReconciliation', TFhirPaymentReconciliation(resource)); 
  {$ENDIF}
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
  {$IFDEF FHIR_PERSON}
     frtPerson: ComposePerson(xml, 'Person', TFhirPerson(resource)); 
  {$ENDIF}
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PRACTITIONER}
  {$IFDEF FHIR_PRACTITIONER}
     frtPractitioner: ComposePractitioner(xml, 'Practitioner', TFhirPractitioner(resource)); 
  {$ENDIF}
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PROCEDURE}
  {$IFDEF FHIR_PROCEDURE}
     frtProcedure: ComposeProcedure(xml, 'Procedure', TFhirProcedure(resource)); 
  {$ENDIF}
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROCEDUREREQUEST}
  {$IFDEF FHIR_PROCEDUREREQUEST}
     frtProcedureRequest: ComposeProcedureRequest(xml, 'ProcedureRequest', TFhirProcedureRequest(resource)); 
  {$ENDIF}
{$ENDIF FHIR_PROCEDUREREQUEST}
{$IFDEF FHIR_PROCESSREQUEST}
  {$IFDEF FHIR_PROCESSREQUEST}
     frtProcessRequest: ComposeProcessRequest(xml, 'ProcessRequest', TFhirProcessRequest(resource)); 
  {$ENDIF}
{$ENDIF FHIR_PROCESSREQUEST}
{$IFDEF FHIR_PROCESSRESPONSE}
  {$IFDEF FHIR_PROCESSRESPONSE}
     frtProcessResponse: ComposeProcessResponse(xml, 'ProcessResponse', TFhirProcessResponse(resource)); 
  {$ENDIF}
{$ENDIF FHIR_PROCESSRESPONSE}
{$IFDEF FHIR_PROVENANCE}
  {$IFDEF FHIR_PROVENANCE}
     frtProvenance: ComposeProvenance(xml, 'Provenance', TFhirProvenance(resource)); 
  {$ENDIF}
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
  {$IFDEF FHIR_QUESTIONNAIRE}
     frtQuestionnaire: ComposeQuestionnaire(xml, 'Questionnaire', TFhirQuestionnaire(resource)); 
  {$ENDIF}
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
  {$IFDEF FHIR_QUESTIONNAIRERESPONSE}
     frtQuestionnaireResponse: ComposeQuestionnaireResponse(xml, 'QuestionnaireResponse', TFhirQuestionnaireResponse(resource)); 
  {$ENDIF}
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REFERRALREQUEST}
  {$IFDEF FHIR_REFERRALREQUEST}
     frtReferralRequest: ComposeReferralRequest(xml, 'ReferralRequest', TFhirReferralRequest(resource)); 
  {$ENDIF}
{$ENDIF FHIR_REFERRALREQUEST}
{$IFDEF FHIR_RELATEDPERSON}
  {$IFDEF FHIR_RELATEDPERSON}
     frtRelatedPerson: ComposeRelatedPerson(xml, 'RelatedPerson', TFhirRelatedPerson(resource)); 
  {$ENDIF}
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_RISKASSESSMENT}
  {$IFDEF FHIR_RISKASSESSMENT}
     frtRiskAssessment: ComposeRiskAssessment(xml, 'RiskAssessment', TFhirRiskAssessment(resource)); 
  {$ENDIF}
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
  {$IFDEF FHIR_SCHEDULE}
     frtSchedule: ComposeSchedule(xml, 'Schedule', TFhirSchedule(resource)); 
  {$ENDIF}
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
  {$IFDEF FHIR_SEARCHPARAMETER}
     frtSearchParameter: ComposeSearchParameter(xml, 'SearchParameter', TFhirSearchParameter(resource)); 
  {$ENDIF}
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SLOT}
  {$IFDEF FHIR_SLOT}
     frtSlot: ComposeSlot(xml, 'Slot', TFhirSlot(resource)); 
  {$ENDIF}
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
  {$IFDEF FHIR_SPECIMEN}
     frtSpecimen: ComposeSpecimen(xml, 'Specimen', TFhirSpecimen(resource)); 
  {$ENDIF}
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_STRUCTUREDEFINITION}
  {$IFDEF FHIR_STRUCTUREDEFINITION}
     frtStructureDefinition: ComposeStructureDefinition(xml, 'StructureDefinition', TFhirStructureDefinition(resource)); 
  {$ENDIF}
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_SUBSCRIPTION}
  {$IFDEF FHIR_SUBSCRIPTION}
     frtSubscription: ComposeSubscription(xml, 'Subscription', TFhirSubscription(resource)); 
  {$ENDIF}
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
  {$IFDEF FHIR_SUBSTANCE}
     frtSubstance: ComposeSubstance(xml, 'Substance', TFhirSubstance(resource)); 
  {$ENDIF}
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUPPLYDELIVERY}
  {$IFDEF FHIR_SUPPLYDELIVERY}
     frtSupplyDelivery: ComposeSupplyDelivery(xml, 'SupplyDelivery', TFhirSupplyDelivery(resource)); 
  {$ENDIF}
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
  {$IFDEF FHIR_SUPPLYREQUEST}
     frtSupplyRequest: ComposeSupplyRequest(xml, 'SupplyRequest', TFhirSupplyRequest(resource)); 
  {$ENDIF}
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TESTSCRIPT}
  {$IFDEF FHIR_TESTSCRIPT}
     frtTestScript: ComposeTestScript(xml, 'TestScript', TFhirTestScript(resource)); 
  {$ENDIF}
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
  {$IFDEF FHIR_VALUESET}
     frtValueSet: ComposeValueSet(xml, 'ValueSet', TFhirValueSet(resource)); 
  {$ENDIF}
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VISIONPRESCRIPTION}
  {$IFDEF FHIR_VISIONPRESCRIPTION}
     frtVisionPrescription: ComposeVisionPrescription(xml, 'VisionPrescription', TFhirVisionPrescription(resource)); 
  {$ENDIF}
{$ENDIF FHIR_VISIONPRESCRIPTION}
  else
    raise EXmlException.Create('Internal error: the resource type '+CODES_TFhirResourceType[resource.ResourceType]+' is not a valid resource type');
  end;
end;

function TFHIRXmlParser.ParseFragment(element : TMXmlElement) : TFHIRObject;
begin
   if SameText(element.Name, 'TFhirElement') then
    result := parseElement(element, element.Name)
  else if SameText(element.Name, 'TFhirBackboneElement') then
    result := parseBackboneElement(element, element.Name)
{$IFDEF FHIR_PARAMETERS}
  else if SameText(element.Name, 'TFhirParameters') then
    result := parseParameters(element, element.Name)
{$ENDIF FHIR_PARAMETERS}
  else if SameText(element.Name, 'TFhirExtension') then
    result := parseExtension(element, element.Name)
  else if SameText(element.Name, 'TFhirNarrative') then
    result := parseNarrative(element, element.Name)
  else if SameText(element.Name, 'TFhirIdentifier') then
    result := parseIdentifier(element, element.Name)
  else if SameText(element.Name, 'TFhirCoding') then
    result := parseCoding(element, element.Name)
  else if SameText(element.Name, 'TFhirReference') then
    result := parseReference(element, element.Name)
  else if SameText(element.Name, 'TFhirSignature') then
    result := parseSignature(element, element.Name)
  else if SameText(element.Name, 'TFhirSampledData') then
    result := parseSampledData(element, element.Name)
  else if SameText(element.Name, 'TFhirPeriod') then
    result := parsePeriod(element, element.Name)
  else if SameText(element.Name, 'TFhirQuantity') then
    result := parseQuantity(element, element.Name)
  else if SameText(element.Name, 'TFhirAttachment') then
    result := parseAttachment(element, element.Name)
  else if SameText(element.Name, 'TFhirRatio') then
    result := parseRatio(element, element.Name)
  else if SameText(element.Name, 'TFhirRange') then
    result := parseRange(element, element.Name)
  else if SameText(element.Name, 'TFhirAnnotation') then
    result := parseAnnotation(element, element.Name)
  else if SameText(element.Name, 'TFhirCodeableConcept') then
    result := parseCodeableConcept(element, element.Name)
  else if SameText(element.Name, 'TFhirHumanName') then
    result := parseHumanName(element, element.Name)
  else if SameText(element.Name, 'TFhirMeta') then
    result := parseMeta(element, element.Name)
  else if SameText(element.Name, 'TFhirContactPoint') then
    result := parseContactPoint(element, element.Name)
  else if SameText(element.Name, 'TFhirAddress') then
    result := parseAddress(element, element.Name)
  else if SameText(element.Name, 'TFhirElementDefinition') then
    result := parseElementDefinition(element, element.Name)
  else if SameText(element.Name, 'TFhirTiming') then
    result := parseTiming(element, element.Name)
{$IFDEF FHIR_ACCOUNT}
  else if SameText(element.Name, 'TFhirAccount') then
    result := parseAccount(element, element.Name)
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
  else if SameText(element.Name, 'TFhirAllergyIntolerance') then
    result := parseAllergyIntolerance(element, element.Name)
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
  else if SameText(element.Name, 'TFhirAppointment') then
    result := parseAppointment(element, element.Name)
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
  else if SameText(element.Name, 'TFhirAppointmentResponse') then
    result := parseAppointmentResponse(element, element.Name)
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
  else if SameText(element.Name, 'TFhirAuditEvent') then
    result := parseAuditEvent(element, element.Name)
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
  else if SameText(element.Name, 'TFhirBasic') then
    result := parseBasic(element, element.Name)
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
  else if SameText(element.Name, 'TFhirBinary') then
    result := parseBinary(element, element.Name)
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BODYSITE}
  else if SameText(element.Name, 'TFhirBodySite') then
    result := parseBodySite(element, element.Name)
{$ENDIF FHIR_BODYSITE}
{$IFDEF FHIR_BUNDLE}
  else if SameText(element.Name, 'TFhirBundle') then
    result := parseBundle(element, element.Name)
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAREPLAN}
  else if SameText(element.Name, 'TFhirCarePlan') then
    result := parseCarePlan(element, element.Name)
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CLAIM}
  else if SameText(element.Name, 'TFhirClaim') then
    result := parseClaim(element, element.Name)
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
  else if SameText(element.Name, 'TFhirClaimResponse') then
    result := parseClaimResponse(element, element.Name)
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
  else if SameText(element.Name, 'TFhirClinicalImpression') then
    result := parseClinicalImpression(element, element.Name)
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_COMMUNICATION}
  else if SameText(element.Name, 'TFhirCommunication') then
    result := parseCommunication(element, element.Name)
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
  else if SameText(element.Name, 'TFhirCommunicationRequest') then
    result := parseCommunicationRequest(element, element.Name)
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPOSITION}
  else if SameText(element.Name, 'TFhirComposition') then
    result := parseComposition(element, element.Name)
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
  else if SameText(element.Name, 'TFhirConceptMap') then
    result := parseConceptMap(element, element.Name)
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
  else if SameText(element.Name, 'TFhirCondition') then
    result := parseCondition(element, element.Name)
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONFORMANCE}
  else if SameText(element.Name, 'TFhirConformance') then
    result := parseConformance(element, element.Name)
{$ENDIF FHIR_CONFORMANCE}
{$IFDEF FHIR_CONTRACT}
  else if SameText(element.Name, 'TFhirContract') then
    result := parseContract(element, element.Name)
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
  else if SameText(element.Name, 'TFhirCoverage') then
    result := parseCoverage(element, element.Name)
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_DATAELEMENT}
  else if SameText(element.Name, 'TFhirDataElement') then
    result := parseDataElement(element, element.Name)
{$ENDIF FHIR_DATAELEMENT}
{$IFDEF FHIR_DETECTEDISSUE}
  else if SameText(element.Name, 'TFhirDetectedIssue') then
    result := parseDetectedIssue(element, element.Name)
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
  else if SameText(element.Name, 'TFhirDevice') then
    result := parseDevice(element, element.Name)
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICECOMPONENT}
  else if SameText(element.Name, 'TFhirDeviceComponent') then
    result := parseDeviceComponent(element, element.Name)
{$ENDIF FHIR_DEVICECOMPONENT}
{$IFDEF FHIR_DEVICEMETRIC}
  else if SameText(element.Name, 'TFhirDeviceMetric') then
    result := parseDeviceMetric(element, element.Name)
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEUSEREQUEST}
  else if SameText(element.Name, 'TFhirDeviceUseRequest') then
    result := parseDeviceUseRequest(element, element.Name)
{$ENDIF FHIR_DEVICEUSEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
  else if SameText(element.Name, 'TFhirDeviceUseStatement') then
    result := parseDeviceUseStatement(element, element.Name)
{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICORDER}
  else if SameText(element.Name, 'TFhirDiagnosticOrder') then
    result := parseDiagnosticOrder(element, element.Name)
{$ENDIF FHIR_DIAGNOSTICORDER}
{$IFDEF FHIR_DIAGNOSTICREPORT}
  else if SameText(element.Name, 'TFhirDiagnosticReport') then
    result := parseDiagnosticReport(element, element.Name)
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
  else if SameText(element.Name, 'TFhirDocumentManifest') then
    result := parseDocumentManifest(element, element.Name)
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
  else if SameText(element.Name, 'TFhirDocumentReference') then
    result := parseDocumentReference(element, element.Name)
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ELIGIBILITYREQUEST}
  else if SameText(element.Name, 'TFhirEligibilityRequest') then
    result := parseEligibilityRequest(element, element.Name)
{$ENDIF FHIR_ELIGIBILITYREQUEST}
{$IFDEF FHIR_ELIGIBILITYRESPONSE}
  else if SameText(element.Name, 'TFhirEligibilityResponse') then
    result := parseEligibilityResponse(element, element.Name)
{$ENDIF FHIR_ELIGIBILITYRESPONSE}
{$IFDEF FHIR_ENCOUNTER}
  else if SameText(element.Name, 'TFhirEncounter') then
    result := parseEncounter(element, element.Name)
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENROLLMENTREQUEST}
  else if SameText(element.Name, 'TFhirEnrollmentRequest') then
    result := parseEnrollmentRequest(element, element.Name)
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
  else if SameText(element.Name, 'TFhirEnrollmentResponse') then
    result := parseEnrollmentResponse(element, element.Name)
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
  else if SameText(element.Name, 'TFhirEpisodeOfCare') then
    result := parseEpisodeOfCare(element, element.Name)
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
  else if SameText(element.Name, 'TFhirExplanationOfBenefit') then
    result := parseExplanationOfBenefit(element, element.Name)
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
  else if SameText(element.Name, 'TFhirFamilyMemberHistory') then
    result := parseFamilyMemberHistory(element, element.Name)
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
  else if SameText(element.Name, 'TFhirFlag') then
    result := parseFlag(element, element.Name)
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
  else if SameText(element.Name, 'TFhirGoal') then
    result := parseGoal(element, element.Name)
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GROUP}
  else if SameText(element.Name, 'TFhirGroup') then
    result := parseGroup(element, element.Name)
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_HEALTHCARESERVICE}
  else if SameText(element.Name, 'TFhirHealthcareService') then
    result := parseHealthcareService(element, element.Name)
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGOBJECTSELECTION}
  else if SameText(element.Name, 'TFhirImagingObjectSelection') then
    result := parseImagingObjectSelection(element, element.Name)
{$ENDIF FHIR_IMAGINGOBJECTSELECTION}
{$IFDEF FHIR_IMAGINGSTUDY}
  else if SameText(element.Name, 'TFhirImagingStudy') then
    result := parseImagingStudy(element, element.Name)
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
  else if SameText(element.Name, 'TFhirImmunization') then
    result := parseImmunization(element, element.Name)
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
  else if SameText(element.Name, 'TFhirImmunizationRecommendation') then
    result := parseImmunizationRecommendation(element, element.Name)
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
  else if SameText(element.Name, 'TFhirImplementationGuide') then
    result := parseImplementationGuide(element, element.Name)
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_LIST}
  else if SameText(element.Name, 'TFhirList') then
    result := parseList(element, element.Name)
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
  else if SameText(element.Name, 'TFhirLocation') then
    result := parseLocation(element, element.Name)
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEDIA}
  else if SameText(element.Name, 'TFhirMedia') then
    result := parseMedia(element, element.Name)
{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
  else if SameText(element.Name, 'TFhirMedication') then
    result := parseMedication(element, element.Name)
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
  else if SameText(element.Name, 'TFhirMedicationAdministration') then
    result := parseMedicationAdministration(element, element.Name)
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
  else if SameText(element.Name, 'TFhirMedicationDispense') then
    result := parseMedicationDispense(element, element.Name)
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONORDER}
  else if SameText(element.Name, 'TFhirMedicationOrder') then
    result := parseMedicationOrder(element, element.Name)
{$ENDIF FHIR_MEDICATIONORDER}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
  else if SameText(element.Name, 'TFhirMedicationStatement') then
    result := parseMedicationStatement(element, element.Name)
{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MESSAGEHEADER}
  else if SameText(element.Name, 'TFhirMessageHeader') then
    result := parseMessageHeader(element, element.Name)
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_NAMINGSYSTEM}
  else if SameText(element.Name, 'TFhirNamingSystem') then
    result := parseNamingSystem(element, element.Name)
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
  else if SameText(element.Name, 'TFhirNutritionOrder') then
    result := parseNutritionOrder(element, element.Name)
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
  else if SameText(element.Name, 'TFhirObservation') then
    result := parseObservation(element, element.Name)
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OPERATIONDEFINITION}
  else if SameText(element.Name, 'TFhirOperationDefinition') then
    result := parseOperationDefinition(element, element.Name)
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
  else if SameText(element.Name, 'TFhirOperationOutcome') then
    result := parseOperationOutcome(element, element.Name)
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORDER}
  else if SameText(element.Name, 'TFhirOrder') then
    result := parseOrder(element, element.Name)
{$ENDIF FHIR_ORDER}
{$IFDEF FHIR_ORDERRESPONSE}
  else if SameText(element.Name, 'TFhirOrderResponse') then
    result := parseOrderResponse(element, element.Name)
{$ENDIF FHIR_ORDERRESPONSE}
{$IFDEF FHIR_ORGANIZATION}
  else if SameText(element.Name, 'TFhirOrganization') then
    result := parseOrganization(element, element.Name)
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_PATIENT}
  else if SameText(element.Name, 'TFhirPatient') then
    result := parsePatient(element, element.Name)
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
  else if SameText(element.Name, 'TFhirPaymentNotice') then
    result := parsePaymentNotice(element, element.Name)
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
  else if SameText(element.Name, 'TFhirPaymentReconciliation') then
    result := parsePaymentReconciliation(element, element.Name)
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
  else if SameText(element.Name, 'TFhirPerson') then
    result := parsePerson(element, element.Name)
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PRACTITIONER}
  else if SameText(element.Name, 'TFhirPractitioner') then
    result := parsePractitioner(element, element.Name)
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PROCEDURE}
  else if SameText(element.Name, 'TFhirProcedure') then
    result := parseProcedure(element, element.Name)
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROCEDUREREQUEST}
  else if SameText(element.Name, 'TFhirProcedureRequest') then
    result := parseProcedureRequest(element, element.Name)
{$ENDIF FHIR_PROCEDUREREQUEST}
{$IFDEF FHIR_PROCESSREQUEST}
  else if SameText(element.Name, 'TFhirProcessRequest') then
    result := parseProcessRequest(element, element.Name)
{$ENDIF FHIR_PROCESSREQUEST}
{$IFDEF FHIR_PROCESSRESPONSE}
  else if SameText(element.Name, 'TFhirProcessResponse') then
    result := parseProcessResponse(element, element.Name)
{$ENDIF FHIR_PROCESSRESPONSE}
{$IFDEF FHIR_PROVENANCE}
  else if SameText(element.Name, 'TFhirProvenance') then
    result := parseProvenance(element, element.Name)
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
  else if SameText(element.Name, 'TFhirQuestionnaire') then
    result := parseQuestionnaire(element, element.Name)
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
  else if SameText(element.Name, 'TFhirQuestionnaireResponse') then
    result := parseQuestionnaireResponse(element, element.Name)
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REFERRALREQUEST}
  else if SameText(element.Name, 'TFhirReferralRequest') then
    result := parseReferralRequest(element, element.Name)
{$ENDIF FHIR_REFERRALREQUEST}
{$IFDEF FHIR_RELATEDPERSON}
  else if SameText(element.Name, 'TFhirRelatedPerson') then
    result := parseRelatedPerson(element, element.Name)
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_RISKASSESSMENT}
  else if SameText(element.Name, 'TFhirRiskAssessment') then
    result := parseRiskAssessment(element, element.Name)
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
  else if SameText(element.Name, 'TFhirSchedule') then
    result := parseSchedule(element, element.Name)
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
  else if SameText(element.Name, 'TFhirSearchParameter') then
    result := parseSearchParameter(element, element.Name)
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SLOT}
  else if SameText(element.Name, 'TFhirSlot') then
    result := parseSlot(element, element.Name)
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
  else if SameText(element.Name, 'TFhirSpecimen') then
    result := parseSpecimen(element, element.Name)
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_STRUCTUREDEFINITION}
  else if SameText(element.Name, 'TFhirStructureDefinition') then
    result := parseStructureDefinition(element, element.Name)
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_SUBSCRIPTION}
  else if SameText(element.Name, 'TFhirSubscription') then
    result := parseSubscription(element, element.Name)
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
  else if SameText(element.Name, 'TFhirSubstance') then
    result := parseSubstance(element, element.Name)
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUPPLYDELIVERY}
  else if SameText(element.Name, 'TFhirSupplyDelivery') then
    result := parseSupplyDelivery(element, element.Name)
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
  else if SameText(element.Name, 'TFhirSupplyRequest') then
    result := parseSupplyRequest(element, element.Name)
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TESTSCRIPT}
  else if SameText(element.Name, 'TFhirTestScript') then
    result := parseTestScript(element, element.Name)
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
  else if SameText(element.Name, 'TFhirValueSet') then
    result := parseValueSet(element, element.Name)
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VISIONPRESCRIPTION}
  else if SameText(element.Name, 'TFhirVisionPrescription') then
    result := parseVisionPrescription(element, element.Name)
{$ENDIF FHIR_VISIONPRESCRIPTION}
  else
    raise EXmlException.Create('error: the element '+element.Name+' is not a valid fragment name');
end;

function TFHIRXmlParser.ParseDataType(element : TMXmlElement; name : String; type_ : TFHIRTypeClass) : TFhirType;
begin
    if (name <> '') and (name <> element.localName) then
    raise EXmlException.Create('Expected Name mismatch : expected "'+name+'"+, but found "'+element.localName+'"');
 if (type_ = TFhirExtension) then
    result := parseExtension(element, name)
  else if (type_ = TFhirNarrative) then
    result := parseNarrative(element, name)
  else if (type_ = TFhirIdentifier) then
    result := parseIdentifier(element, name)
  else if (type_ = TFhirCoding) then
    result := parseCoding(element, name)
  else if (type_ = TFhirReference) then
    result := parseReference(element, name)
  else if (type_ = TFhirSignature) then
    result := parseSignature(element, name)
  else if (type_ = TFhirSampledData) then
    result := parseSampledData(element, name)
  else if (type_ = TFhirPeriod) then
    result := parsePeriod(element, name)
  else if (type_ = TFhirQuantity) then
    result := parseQuantity(element, name)
  else if (type_ = TFhirAttachment) then
    result := parseAttachment(element, name)
  else if (type_ = TFhirRatio) then
    result := parseRatio(element, name)
  else if (type_ = TFhirRange) then
    result := parseRange(element, name)
  else if (type_ = TFhirAnnotation) then
    result := parseAnnotation(element, name)
  else if (type_ = TFhirCodeableConcept) then
    result := parseCodeableConcept(element, name)
  else if (type_ = TFhirHumanName) then
    result := parseHumanName(element, name)
  else if (type_ = TFhirMeta) then
    result := parseMeta(element, name)
  else if (type_ = TFhirContactPoint) then
    result := parseContactPoint(element, name)
  else if (type_ = TFhirAddress) then
    result := parseAddress(element, name)
  else if (type_ = TFhirElementDefinition) then
    result := parseElementDefinition(element, name)
  else if (type_ = TFhirTiming) then
    result := parseTiming(element, name)
  else
    raise EXmlException.Create('Unknown Type');
end;

procedure TFHIRXmlComposer.ComposeBase(xml : TXmlBuilder; name : String; base : TFHIRObject);
begin
   if (base is TFhirDateTime) then
    composeDateTime(xml, name,  TFhirDateTime(base))
  else if (base is TFhirDate) then
    composeDate(xml, name,  TFhirDate(base))
  else if (base is TFhirString) then
    composeString(xml, name,  TFhirString(base))
  else if (base is TFhirInteger) then
    composeInteger(xml, name,  TFhirInteger(base))
  else if (base is TFhirUri) then
    composeUri(xml, name,  TFhirUri(base))
  else if (base is TFhirInstant) then
    composeInstant(xml, name,  TFhirInstant(base))
  else if (base is TFhirBoolean) then
    composeBoolean(xml, name,  TFhirBoolean(base))
  else if (base is TFhirBase64Binary) then
    composeBase64Binary(xml, name,  TFhirBase64Binary(base))
  else if (base is TFhirTime) then
    composeTime(xml, name,  TFhirTime(base))
  else if (base is TFhirDecimal) then
    composeDecimal(xml, name,  TFhirDecimal(base))
  else if (base is TFhirCode) then
    composeCode(xml, name,  TFhirCode(base))
  else if (base is TFhirOid) then
    composeOid(xml, name,  TFhirOid(base))
  else if (base is TFhirUuid) then
    composeUuid(xml, name,  TFhirUuid(base))
  else if (base is TFhirMarkdown) then
    composeMarkdown(xml, name,  TFhirMarkdown(base))
  else if (base is TFhirUnsignedInt) then
    composeUnsignedInt(xml, name,  TFhirUnsignedInt(base))
  else if (base is TFhirId) then
    composeId(xml, name,  TFhirId(base))
  else if (base is TFhirPositiveInt) then
    composePositiveInt(xml, name,  TFhirPositiveInt(base))
{$IFDEF FHIR_PARAMETERS}
  else if (base is TFhirParametersParameter) then
    composeParametersParameter(xml, name,  TFhirParametersParameter(base))
  else if (base is TFhirParameters) then
    composeParameters(xml, name,  TFhirParameters(base))
{$ENDIF FHIR_PARAMETERS}
  else if (base is TFhirExtension) then
    composeExtension(xml, name,  TFhirExtension(base))
  else if (base is TFhirNarrative) then
    composeNarrative(xml, name,  TFhirNarrative(base))
  else if (base is TFhirIdentifier) then
    composeIdentifier(xml, name,  TFhirIdentifier(base))
  else if (base is TFhirCoding) then
    composeCoding(xml, name,  TFhirCoding(base))
  else if (base is TFhirReference) then
    composeReference(xml, name,  TFhirReference(base))
  else if (base is TFhirSignature) then
    composeSignature(xml, name,  TFhirSignature(base))
  else if (base is TFhirSampledData) then
    composeSampledData(xml, name,  TFhirSampledData(base))
  else if (base is TFhirPeriod) then
    composePeriod(xml, name,  TFhirPeriod(base))
  else if (base is TFhirQuantity) then
    composeQuantity(xml, name,  TFhirQuantity(base))
  else if (base is TFhirAttachment) then
    composeAttachment(xml, name,  TFhirAttachment(base))
  else if (base is TFhirRatio) then
    composeRatio(xml, name,  TFhirRatio(base))
  else if (base is TFhirRange) then
    composeRange(xml, name,  TFhirRange(base))
  else if (base is TFhirAnnotation) then
    composeAnnotation(xml, name,  TFhirAnnotation(base))
  else if (base is TFhirCodeableConcept) then
    composeCodeableConcept(xml, name,  TFhirCodeableConcept(base))
  else if (base is TFhirHumanName) then
    composeHumanName(xml, name,  TFhirHumanName(base))
  else if (base is TFhirMeta) then
    composeMeta(xml, name,  TFhirMeta(base))
  else if (base is TFhirContactPoint) then
    composeContactPoint(xml, name,  TFhirContactPoint(base))
  else if (base is TFhirAddress) then
    composeAddress(xml, name,  TFhirAddress(base))
  else if (base is TFhirElementDefinitionSlicing) then
    composeElementDefinitionSlicing(xml, name,  TFhirElementDefinitionSlicing(base))
  else if (base is TFhirElementDefinitionBase) then
    composeElementDefinitionBase(xml, name,  TFhirElementDefinitionBase(base))
  else if (base is TFhirElementDefinitionType) then
    composeElementDefinitionType(xml, name,  TFhirElementDefinitionType(base))
  else if (base is TFhirElementDefinitionConstraint) then
    composeElementDefinitionConstraint(xml, name,  TFhirElementDefinitionConstraint(base))
  else if (base is TFhirElementDefinitionBinding) then
    composeElementDefinitionBinding(xml, name,  TFhirElementDefinitionBinding(base))
  else if (base is TFhirElementDefinitionMapping) then
    composeElementDefinitionMapping(xml, name,  TFhirElementDefinitionMapping(base))
  else if (base is TFhirElementDefinition) then
    composeElementDefinition(xml, name,  TFhirElementDefinition(base))
  else if (base is TFhirTimingRepeat) then
    composeTimingRepeat(xml, name,  TFhirTimingRepeat(base))
  else if (base is TFhirTiming) then
    composeTiming(xml, name,  TFhirTiming(base))
{$IFDEF FHIR_ACCOUNT}
  else if (base is TFhirAccount) then
    composeAccount(xml, name,  TFhirAccount(base))
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
  else if (base is TFhirAllergyIntoleranceReaction) then
    composeAllergyIntoleranceReaction(xml, name,  TFhirAllergyIntoleranceReaction(base))
  else if (base is TFhirAllergyIntolerance) then
    composeAllergyIntolerance(xml, name,  TFhirAllergyIntolerance(base))
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
  else if (base is TFhirAppointmentParticipant) then
    composeAppointmentParticipant(xml, name,  TFhirAppointmentParticipant(base))
  else if (base is TFhirAppointment) then
    composeAppointment(xml, name,  TFhirAppointment(base))
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
  else if (base is TFhirAppointmentResponse) then
    composeAppointmentResponse(xml, name,  TFhirAppointmentResponse(base))
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_AUDITEVENT}
  else if (base is TFhirAuditEventEvent) then
    composeAuditEventEvent(xml, name,  TFhirAuditEventEvent(base))
  else if (base is TFhirAuditEventParticipant) then
    composeAuditEventParticipant(xml, name,  TFhirAuditEventParticipant(base))
  else if (base is TFhirAuditEventParticipantNetwork) then
    composeAuditEventParticipantNetwork(xml, name,  TFhirAuditEventParticipantNetwork(base))
  else if (base is TFhirAuditEventSource) then
    composeAuditEventSource(xml, name,  TFhirAuditEventSource(base))
  else if (base is TFhirAuditEventObject) then
    composeAuditEventObject(xml, name,  TFhirAuditEventObject(base))
  else if (base is TFhirAuditEventObjectDetail) then
    composeAuditEventObjectDetail(xml, name,  TFhirAuditEventObjectDetail(base))
  else if (base is TFhirAuditEvent) then
    composeAuditEvent(xml, name,  TFhirAuditEvent(base))
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BASIC}
  else if (base is TFhirBasic) then
    composeBasic(xml, name,  TFhirBasic(base))
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BINARY}
  else if (base is TFhirBinary) then
    composeBinary(xml, name,  TFhirBinary(base))
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BODYSITE}
  else if (base is TFhirBodySite) then
    composeBodySite(xml, name,  TFhirBodySite(base))
{$ENDIF FHIR_BODYSITE}
{$IFDEF FHIR_BUNDLE}
  else if (base is TFhirBundleLink) then
    composeBundleLink(xml, name,  TFhirBundleLink(base))
  else if (base is TFhirBundleEntry) then
    composeBundleEntry(xml, name,  TFhirBundleEntry(base))
  else if (base is TFhirBundleEntrySearch) then
    composeBundleEntrySearch(xml, name,  TFhirBundleEntrySearch(base))
  else if (base is TFhirBundleEntryRequest) then
    composeBundleEntryRequest(xml, name,  TFhirBundleEntryRequest(base))
  else if (base is TFhirBundleEntryResponse) then
    composeBundleEntryResponse(xml, name,  TFhirBundleEntryResponse(base))
  else if (base is TFhirBundle) then
    composeBundle(xml, name,  TFhirBundle(base))
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CAREPLAN}
  else if (base is TFhirCarePlanRelatedPlan) then
    composeCarePlanRelatedPlan(xml, name,  TFhirCarePlanRelatedPlan(base))
  else if (base is TFhirCarePlanParticipant) then
    composeCarePlanParticipant(xml, name,  TFhirCarePlanParticipant(base))
  else if (base is TFhirCarePlanActivity) then
    composeCarePlanActivity(xml, name,  TFhirCarePlanActivity(base))
  else if (base is TFhirCarePlanActivityDetail) then
    composeCarePlanActivityDetail(xml, name,  TFhirCarePlanActivityDetail(base))
  else if (base is TFhirCarePlan) then
    composeCarePlan(xml, name,  TFhirCarePlan(base))
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CLAIM}
  else if (base is TFhirClaimPayee) then
    composeClaimPayee(xml, name,  TFhirClaimPayee(base))
  else if (base is TFhirClaimDiagnosis) then
    composeClaimDiagnosis(xml, name,  TFhirClaimDiagnosis(base))
  else if (base is TFhirClaimCoverage) then
    composeClaimCoverage(xml, name,  TFhirClaimCoverage(base))
  else if (base is TFhirClaimItem) then
    composeClaimItem(xml, name,  TFhirClaimItem(base))
  else if (base is TFhirClaimItemDetail) then
    composeClaimItemDetail(xml, name,  TFhirClaimItemDetail(base))
  else if (base is TFhirClaimItemDetailSubDetail) then
    composeClaimItemDetailSubDetail(xml, name,  TFhirClaimItemDetailSubDetail(base))
  else if (base is TFhirClaimItemProsthesis) then
    composeClaimItemProsthesis(xml, name,  TFhirClaimItemProsthesis(base))
  else if (base is TFhirClaimMissingTeeth) then
    composeClaimMissingTeeth(xml, name,  TFhirClaimMissingTeeth(base))
  else if (base is TFhirClaim) then
    composeClaim(xml, name,  TFhirClaim(base))
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
  else if (base is TFhirClaimResponseItem) then
    composeClaimResponseItem(xml, name,  TFhirClaimResponseItem(base))
  else if (base is TFhirClaimResponseItemAdjudication) then
    composeClaimResponseItemAdjudication(xml, name,  TFhirClaimResponseItemAdjudication(base))
  else if (base is TFhirClaimResponseItemDetail) then
    composeClaimResponseItemDetail(xml, name,  TFhirClaimResponseItemDetail(base))
  else if (base is TFhirClaimResponseItemDetailAdjudication) then
    composeClaimResponseItemDetailAdjudication(xml, name,  TFhirClaimResponseItemDetailAdjudication(base))
  else if (base is TFhirClaimResponseItemDetailSubDetail) then
    composeClaimResponseItemDetailSubDetail(xml, name,  TFhirClaimResponseItemDetailSubDetail(base))
  else if (base is TFhirClaimResponseItemDetailSubDetailAdjudication) then
    composeClaimResponseItemDetailSubDetailAdjudication(xml, name,  TFhirClaimResponseItemDetailSubDetailAdjudication(base))
  else if (base is TFhirClaimResponseAddItem) then
    composeClaimResponseAddItem(xml, name,  TFhirClaimResponseAddItem(base))
  else if (base is TFhirClaimResponseAddItemAdjudication) then
    composeClaimResponseAddItemAdjudication(xml, name,  TFhirClaimResponseAddItemAdjudication(base))
  else if (base is TFhirClaimResponseAddItemDetail) then
    composeClaimResponseAddItemDetail(xml, name,  TFhirClaimResponseAddItemDetail(base))
  else if (base is TFhirClaimResponseAddItemDetailAdjudication) then
    composeClaimResponseAddItemDetailAdjudication(xml, name,  TFhirClaimResponseAddItemDetailAdjudication(base))
  else if (base is TFhirClaimResponseError) then
    composeClaimResponseError(xml, name,  TFhirClaimResponseError(base))
  else if (base is TFhirClaimResponseNote) then
    composeClaimResponseNote(xml, name,  TFhirClaimResponseNote(base))
  else if (base is TFhirClaimResponseCoverage) then
    composeClaimResponseCoverage(xml, name,  TFhirClaimResponseCoverage(base))
  else if (base is TFhirClaimResponse) then
    composeClaimResponse(xml, name,  TFhirClaimResponse(base))
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_CLINICALIMPRESSION}
  else if (base is TFhirClinicalImpressionInvestigations) then
    composeClinicalImpressionInvestigations(xml, name,  TFhirClinicalImpressionInvestigations(base))
  else if (base is TFhirClinicalImpressionFinding) then
    composeClinicalImpressionFinding(xml, name,  TFhirClinicalImpressionFinding(base))
  else if (base is TFhirClinicalImpressionRuledOut) then
    composeClinicalImpressionRuledOut(xml, name,  TFhirClinicalImpressionRuledOut(base))
  else if (base is TFhirClinicalImpression) then
    composeClinicalImpression(xml, name,  TFhirClinicalImpression(base))
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_COMMUNICATION}
  else if (base is TFhirCommunicationPayload) then
    composeCommunicationPayload(xml, name,  TFhirCommunicationPayload(base))
  else if (base is TFhirCommunication) then
    composeCommunication(xml, name,  TFhirCommunication(base))
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
  else if (base is TFhirCommunicationRequestPayload) then
    composeCommunicationRequestPayload(xml, name,  TFhirCommunicationRequestPayload(base))
  else if (base is TFhirCommunicationRequest) then
    composeCommunicationRequest(xml, name,  TFhirCommunicationRequest(base))
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPOSITION}
  else if (base is TFhirCompositionAttester) then
    composeCompositionAttester(xml, name,  TFhirCompositionAttester(base))
  else if (base is TFhirCompositionEvent) then
    composeCompositionEvent(xml, name,  TFhirCompositionEvent(base))
  else if (base is TFhirCompositionSection) then
    composeCompositionSection(xml, name,  TFhirCompositionSection(base))
  else if (base is TFhirComposition) then
    composeComposition(xml, name,  TFhirComposition(base))
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONCEPTMAP}
  else if (base is TFhirConceptMapContact) then
    composeConceptMapContact(xml, name,  TFhirConceptMapContact(base))
  else if (base is TFhirConceptMapElement) then
    composeConceptMapElement(xml, name,  TFhirConceptMapElement(base))
  else if (base is TFhirConceptMapElementTarget) then
    composeConceptMapElementTarget(xml, name,  TFhirConceptMapElementTarget(base))
  else if (base is TFhirConceptMapElementTargetDependsOn) then
    composeConceptMapElementTargetDependsOn(xml, name,  TFhirConceptMapElementTargetDependsOn(base))
  else if (base is TFhirConceptMap) then
    composeConceptMap(xml, name,  TFhirConceptMap(base))
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_CONDITION}
  else if (base is TFhirConditionStage) then
    composeConditionStage(xml, name,  TFhirConditionStage(base))
  else if (base is TFhirConditionEvidence) then
    composeConditionEvidence(xml, name,  TFhirConditionEvidence(base))
  else if (base is TFhirCondition) then
    composeCondition(xml, name,  TFhirCondition(base))
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_CONFORMANCE}
  else if (base is TFhirConformanceContact) then
    composeConformanceContact(xml, name,  TFhirConformanceContact(base))
  else if (base is TFhirConformanceSoftware) then
    composeConformanceSoftware(xml, name,  TFhirConformanceSoftware(base))
  else if (base is TFhirConformanceImplementation) then
    composeConformanceImplementation(xml, name,  TFhirConformanceImplementation(base))
  else if (base is TFhirConformanceRest) then
    composeConformanceRest(xml, name,  TFhirConformanceRest(base))
  else if (base is TFhirConformanceRestSecurity) then
    composeConformanceRestSecurity(xml, name,  TFhirConformanceRestSecurity(base))
  else if (base is TFhirConformanceRestSecurityCertificate) then
    composeConformanceRestSecurityCertificate(xml, name,  TFhirConformanceRestSecurityCertificate(base))
  else if (base is TFhirConformanceRestResource) then
    composeConformanceRestResource(xml, name,  TFhirConformanceRestResource(base))
  else if (base is TFhirConformanceRestResourceInteraction) then
    composeConformanceRestResourceInteraction(xml, name,  TFhirConformanceRestResourceInteraction(base))
  else if (base is TFhirConformanceRestResourceSearchParam) then
    composeConformanceRestResourceSearchParam(xml, name,  TFhirConformanceRestResourceSearchParam(base))
  else if (base is TFhirConformanceRestInteraction) then
    composeConformanceRestInteraction(xml, name,  TFhirConformanceRestInteraction(base))
  else if (base is TFhirConformanceRestOperation) then
    composeConformanceRestOperation(xml, name,  TFhirConformanceRestOperation(base))
  else if (base is TFhirConformanceMessaging) then
    composeConformanceMessaging(xml, name,  TFhirConformanceMessaging(base))
  else if (base is TFhirConformanceMessagingEndpoint) then
    composeConformanceMessagingEndpoint(xml, name,  TFhirConformanceMessagingEndpoint(base))
  else if (base is TFhirConformanceMessagingEvent) then
    composeConformanceMessagingEvent(xml, name,  TFhirConformanceMessagingEvent(base))
  else if (base is TFhirConformanceDocument) then
    composeConformanceDocument(xml, name,  TFhirConformanceDocument(base))
  else if (base is TFhirConformance) then
    composeConformance(xml, name,  TFhirConformance(base))
{$ENDIF FHIR_CONFORMANCE}
{$IFDEF FHIR_CONTRACT}
  else if (base is TFhirContractActor) then
    composeContractActor(xml, name,  TFhirContractActor(base))
  else if (base is TFhirContractValuedItem) then
    composeContractValuedItem(xml, name,  TFhirContractValuedItem(base))
  else if (base is TFhirContractSigner) then
    composeContractSigner(xml, name,  TFhirContractSigner(base))
  else if (base is TFhirContractTerm) then
    composeContractTerm(xml, name,  TFhirContractTerm(base))
  else if (base is TFhirContractTermActor) then
    composeContractTermActor(xml, name,  TFhirContractTermActor(base))
  else if (base is TFhirContractTermValuedItem) then
    composeContractTermValuedItem(xml, name,  TFhirContractTermValuedItem(base))
  else if (base is TFhirContractFriendly) then
    composeContractFriendly(xml, name,  TFhirContractFriendly(base))
  else if (base is TFhirContractLegal) then
    composeContractLegal(xml, name,  TFhirContractLegal(base))
  else if (base is TFhirContractRule) then
    composeContractRule(xml, name,  TFhirContractRule(base))
  else if (base is TFhirContract) then
    composeContract(xml, name,  TFhirContract(base))
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_COVERAGE}
  else if (base is TFhirCoverage) then
    composeCoverage(xml, name,  TFhirCoverage(base))
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_DATAELEMENT}
  else if (base is TFhirDataElementContact) then
    composeDataElementContact(xml, name,  TFhirDataElementContact(base))
  else if (base is TFhirDataElementMapping) then
    composeDataElementMapping(xml, name,  TFhirDataElementMapping(base))
  else if (base is TFhirDataElement) then
    composeDataElement(xml, name,  TFhirDataElement(base))
{$ENDIF FHIR_DATAELEMENT}
{$IFDEF FHIR_DETECTEDISSUE}
  else if (base is TFhirDetectedIssueMitigation) then
    composeDetectedIssueMitigation(xml, name,  TFhirDetectedIssueMitigation(base))
  else if (base is TFhirDetectedIssue) then
    composeDetectedIssue(xml, name,  TFhirDetectedIssue(base))
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICE}
  else if (base is TFhirDevice) then
    composeDevice(xml, name,  TFhirDevice(base))
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICECOMPONENT}
  else if (base is TFhirDeviceComponentProductionSpecification) then
    composeDeviceComponentProductionSpecification(xml, name,  TFhirDeviceComponentProductionSpecification(base))
  else if (base is TFhirDeviceComponent) then
    composeDeviceComponent(xml, name,  TFhirDeviceComponent(base))
{$ENDIF FHIR_DEVICECOMPONENT}
{$IFDEF FHIR_DEVICEMETRIC}
  else if (base is TFhirDeviceMetricCalibration) then
    composeDeviceMetricCalibration(xml, name,  TFhirDeviceMetricCalibration(base))
  else if (base is TFhirDeviceMetric) then
    composeDeviceMetric(xml, name,  TFhirDeviceMetric(base))
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_DEVICEUSEREQUEST}
  else if (base is TFhirDeviceUseRequest) then
    composeDeviceUseRequest(xml, name,  TFhirDeviceUseRequest(base))
{$ENDIF FHIR_DEVICEUSEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
  else if (base is TFhirDeviceUseStatement) then
    composeDeviceUseStatement(xml, name,  TFhirDeviceUseStatement(base))
{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICORDER}
  else if (base is TFhirDiagnosticOrderEvent) then
    composeDiagnosticOrderEvent(xml, name,  TFhirDiagnosticOrderEvent(base))
  else if (base is TFhirDiagnosticOrderItem) then
    composeDiagnosticOrderItem(xml, name,  TFhirDiagnosticOrderItem(base))
  else if (base is TFhirDiagnosticOrder) then
    composeDiagnosticOrder(xml, name,  TFhirDiagnosticOrder(base))
{$ENDIF FHIR_DIAGNOSTICORDER}
{$IFDEF FHIR_DIAGNOSTICREPORT}
  else if (base is TFhirDiagnosticReportImage) then
    composeDiagnosticReportImage(xml, name,  TFhirDiagnosticReportImage(base))
  else if (base is TFhirDiagnosticReport) then
    composeDiagnosticReport(xml, name,  TFhirDiagnosticReport(base))
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
  else if (base is TFhirDocumentManifestContent) then
    composeDocumentManifestContent(xml, name,  TFhirDocumentManifestContent(base))
  else if (base is TFhirDocumentManifestRelated) then
    composeDocumentManifestRelated(xml, name,  TFhirDocumentManifestRelated(base))
  else if (base is TFhirDocumentManifest) then
    composeDocumentManifest(xml, name,  TFhirDocumentManifest(base))
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
  else if (base is TFhirDocumentReferenceRelatesTo) then
    composeDocumentReferenceRelatesTo(xml, name,  TFhirDocumentReferenceRelatesTo(base))
  else if (base is TFhirDocumentReferenceContent) then
    composeDocumentReferenceContent(xml, name,  TFhirDocumentReferenceContent(base))
  else if (base is TFhirDocumentReferenceContext) then
    composeDocumentReferenceContext(xml, name,  TFhirDocumentReferenceContext(base))
  else if (base is TFhirDocumentReferenceContextRelated) then
    composeDocumentReferenceContextRelated(xml, name,  TFhirDocumentReferenceContextRelated(base))
  else if (base is TFhirDocumentReference) then
    composeDocumentReference(xml, name,  TFhirDocumentReference(base))
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_ELIGIBILITYREQUEST}
  else if (base is TFhirEligibilityRequest) then
    composeEligibilityRequest(xml, name,  TFhirEligibilityRequest(base))
{$ENDIF FHIR_ELIGIBILITYREQUEST}
{$IFDEF FHIR_ELIGIBILITYRESPONSE}
  else if (base is TFhirEligibilityResponse) then
    composeEligibilityResponse(xml, name,  TFhirEligibilityResponse(base))
{$ENDIF FHIR_ELIGIBILITYRESPONSE}
{$IFDEF FHIR_ENCOUNTER}
  else if (base is TFhirEncounterStatusHistory) then
    composeEncounterStatusHistory(xml, name,  TFhirEncounterStatusHistory(base))
  else if (base is TFhirEncounterParticipant) then
    composeEncounterParticipant(xml, name,  TFhirEncounterParticipant(base))
  else if (base is TFhirEncounterHospitalization) then
    composeEncounterHospitalization(xml, name,  TFhirEncounterHospitalization(base))
  else if (base is TFhirEncounterLocation) then
    composeEncounterLocation(xml, name,  TFhirEncounterLocation(base))
  else if (base is TFhirEncounter) then
    composeEncounter(xml, name,  TFhirEncounter(base))
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENROLLMENTREQUEST}
  else if (base is TFhirEnrollmentRequest) then
    composeEnrollmentRequest(xml, name,  TFhirEnrollmentRequest(base))
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
  else if (base is TFhirEnrollmentResponse) then
    composeEnrollmentResponse(xml, name,  TFhirEnrollmentResponse(base))
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EPISODEOFCARE}
  else if (base is TFhirEpisodeOfCareStatusHistory) then
    composeEpisodeOfCareStatusHistory(xml, name,  TFhirEpisodeOfCareStatusHistory(base))
  else if (base is TFhirEpisodeOfCareCareTeam) then
    composeEpisodeOfCareCareTeam(xml, name,  TFhirEpisodeOfCareCareTeam(base))
  else if (base is TFhirEpisodeOfCare) then
    composeEpisodeOfCare(xml, name,  TFhirEpisodeOfCare(base))
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
  else if (base is TFhirExplanationOfBenefit) then
    composeExplanationOfBenefit(xml, name,  TFhirExplanationOfBenefit(base))
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
  else if (base is TFhirFamilyMemberHistoryCondition) then
    composeFamilyMemberHistoryCondition(xml, name,  TFhirFamilyMemberHistoryCondition(base))
  else if (base is TFhirFamilyMemberHistory) then
    composeFamilyMemberHistory(xml, name,  TFhirFamilyMemberHistory(base))
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
  else if (base is TFhirFlag) then
    composeFlag(xml, name,  TFhirFlag(base))
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
  else if (base is TFhirGoalOutcome) then
    composeGoalOutcome(xml, name,  TFhirGoalOutcome(base))
  else if (base is TFhirGoal) then
    composeGoal(xml, name,  TFhirGoal(base))
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_GROUP}
  else if (base is TFhirGroupCharacteristic) then
    composeGroupCharacteristic(xml, name,  TFhirGroupCharacteristic(base))
  else if (base is TFhirGroupMember) then
    composeGroupMember(xml, name,  TFhirGroupMember(base))
  else if (base is TFhirGroup) then
    composeGroup(xml, name,  TFhirGroup(base))
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_HEALTHCARESERVICE}
  else if (base is TFhirHealthcareServiceServiceType) then
    composeHealthcareServiceServiceType(xml, name,  TFhirHealthcareServiceServiceType(base))
  else if (base is TFhirHealthcareServiceAvailableTime) then
    composeHealthcareServiceAvailableTime(xml, name,  TFhirHealthcareServiceAvailableTime(base))
  else if (base is TFhirHealthcareServiceNotAvailable) then
    composeHealthcareServiceNotAvailable(xml, name,  TFhirHealthcareServiceNotAvailable(base))
  else if (base is TFhirHealthcareService) then
    composeHealthcareService(xml, name,  TFhirHealthcareService(base))
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_IMAGINGOBJECTSELECTION}
  else if (base is TFhirImagingObjectSelectionStudy) then
    composeImagingObjectSelectionStudy(xml, name,  TFhirImagingObjectSelectionStudy(base))
  else if (base is TFhirImagingObjectSelectionStudySeries) then
    composeImagingObjectSelectionStudySeries(xml, name,  TFhirImagingObjectSelectionStudySeries(base))
  else if (base is TFhirImagingObjectSelectionStudySeriesInstance) then
    composeImagingObjectSelectionStudySeriesInstance(xml, name,  TFhirImagingObjectSelectionStudySeriesInstance(base))
  else if (base is TFhirImagingObjectSelectionStudySeriesInstanceFrames) then
    composeImagingObjectSelectionStudySeriesInstanceFrames(xml, name,  TFhirImagingObjectSelectionStudySeriesInstanceFrames(base))
  else if (base is TFhirImagingObjectSelection) then
    composeImagingObjectSelection(xml, name,  TFhirImagingObjectSelection(base))
{$ENDIF FHIR_IMAGINGOBJECTSELECTION}
{$IFDEF FHIR_IMAGINGSTUDY}
  else if (base is TFhirImagingStudySeries) then
    composeImagingStudySeries(xml, name,  TFhirImagingStudySeries(base))
  else if (base is TFhirImagingStudySeriesInstance) then
    composeImagingStudySeriesInstance(xml, name,  TFhirImagingStudySeriesInstance(base))
  else if (base is TFhirImagingStudy) then
    composeImagingStudy(xml, name,  TFhirImagingStudy(base))
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
  else if (base is TFhirImmunizationExplanation) then
    composeImmunizationExplanation(xml, name,  TFhirImmunizationExplanation(base))
  else if (base is TFhirImmunizationReaction) then
    composeImmunizationReaction(xml, name,  TFhirImmunizationReaction(base))
  else if (base is TFhirImmunizationVaccinationProtocol) then
    composeImmunizationVaccinationProtocol(xml, name,  TFhirImmunizationVaccinationProtocol(base))
  else if (base is TFhirImmunization) then
    composeImmunization(xml, name,  TFhirImmunization(base))
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
  else if (base is TFhirImmunizationRecommendationRecommendation) then
    composeImmunizationRecommendationRecommendation(xml, name,  TFhirImmunizationRecommendationRecommendation(base))
  else if (base is TFhirImmunizationRecommendationRecommendationDateCriterion) then
    composeImmunizationRecommendationRecommendationDateCriterion(xml, name,  TFhirImmunizationRecommendationRecommendationDateCriterion(base))
  else if (base is TFhirImmunizationRecommendationRecommendationProtocol) then
    composeImmunizationRecommendationRecommendationProtocol(xml, name,  TFhirImmunizationRecommendationRecommendationProtocol(base))
  else if (base is TFhirImmunizationRecommendation) then
    composeImmunizationRecommendation(xml, name,  TFhirImmunizationRecommendation(base))
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
  else if (base is TFhirImplementationGuideContact) then
    composeImplementationGuideContact(xml, name,  TFhirImplementationGuideContact(base))
  else if (base is TFhirImplementationGuideDependency) then
    composeImplementationGuideDependency(xml, name,  TFhirImplementationGuideDependency(base))
  else if (base is TFhirImplementationGuidePackage) then
    composeImplementationGuidePackage(xml, name,  TFhirImplementationGuidePackage(base))
  else if (base is TFhirImplementationGuidePackageResource) then
    composeImplementationGuidePackageResource(xml, name,  TFhirImplementationGuidePackageResource(base))
  else if (base is TFhirImplementationGuideGlobal) then
    composeImplementationGuideGlobal(xml, name,  TFhirImplementationGuideGlobal(base))
  else if (base is TFhirImplementationGuidePage) then
    composeImplementationGuidePage(xml, name,  TFhirImplementationGuidePage(base))
  else if (base is TFhirImplementationGuide) then
    composeImplementationGuide(xml, name,  TFhirImplementationGuide(base))
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_LIST}
  else if (base is TFhirListEntry) then
    composeListEntry(xml, name,  TFhirListEntry(base))
  else if (base is TFhirList) then
    composeList(xml, name,  TFhirList(base))
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_LOCATION}
  else if (base is TFhirLocationPosition) then
    composeLocationPosition(xml, name,  TFhirLocationPosition(base))
  else if (base is TFhirLocation) then
    composeLocation(xml, name,  TFhirLocation(base))
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEDIA}
  else if (base is TFhirMedia) then
    composeMedia(xml, name,  TFhirMedia(base))
{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATION}
  else if (base is TFhirMedicationProduct) then
    composeMedicationProduct(xml, name,  TFhirMedicationProduct(base))
  else if (base is TFhirMedicationProductIngredient) then
    composeMedicationProductIngredient(xml, name,  TFhirMedicationProductIngredient(base))
  else if (base is TFhirMedicationProductBatch) then
    composeMedicationProductBatch(xml, name,  TFhirMedicationProductBatch(base))
  else if (base is TFhirMedicationPackage) then
    composeMedicationPackage(xml, name,  TFhirMedicationPackage(base))
  else if (base is TFhirMedicationPackageContent) then
    composeMedicationPackageContent(xml, name,  TFhirMedicationPackageContent(base))
  else if (base is TFhirMedication) then
    composeMedication(xml, name,  TFhirMedication(base))
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
  else if (base is TFhirMedicationAdministrationDosage) then
    composeMedicationAdministrationDosage(xml, name,  TFhirMedicationAdministrationDosage(base))
  else if (base is TFhirMedicationAdministration) then
    composeMedicationAdministration(xml, name,  TFhirMedicationAdministration(base))
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
  else if (base is TFhirMedicationDispenseDosageInstruction) then
    composeMedicationDispenseDosageInstruction(xml, name,  TFhirMedicationDispenseDosageInstruction(base))
  else if (base is TFhirMedicationDispenseSubstitution) then
    composeMedicationDispenseSubstitution(xml, name,  TFhirMedicationDispenseSubstitution(base))
  else if (base is TFhirMedicationDispense) then
    composeMedicationDispense(xml, name,  TFhirMedicationDispense(base))
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONORDER}
  else if (base is TFhirMedicationOrderDosageInstruction) then
    composeMedicationOrderDosageInstruction(xml, name,  TFhirMedicationOrderDosageInstruction(base))
  else if (base is TFhirMedicationOrderDispenseRequest) then
    composeMedicationOrderDispenseRequest(xml, name,  TFhirMedicationOrderDispenseRequest(base))
  else if (base is TFhirMedicationOrderSubstitution) then
    composeMedicationOrderSubstitution(xml, name,  TFhirMedicationOrderSubstitution(base))
  else if (base is TFhirMedicationOrder) then
    composeMedicationOrder(xml, name,  TFhirMedicationOrder(base))
{$ENDIF FHIR_MEDICATIONORDER}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
  else if (base is TFhirMedicationStatementDosage) then
    composeMedicationStatementDosage(xml, name,  TFhirMedicationStatementDosage(base))
  else if (base is TFhirMedicationStatement) then
    composeMedicationStatement(xml, name,  TFhirMedicationStatement(base))
{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MESSAGEHEADER}
  else if (base is TFhirMessageHeaderResponse) then
    composeMessageHeaderResponse(xml, name,  TFhirMessageHeaderResponse(base))
  else if (base is TFhirMessageHeaderSource) then
    composeMessageHeaderSource(xml, name,  TFhirMessageHeaderSource(base))
  else if (base is TFhirMessageHeaderDestination) then
    composeMessageHeaderDestination(xml, name,  TFhirMessageHeaderDestination(base))
  else if (base is TFhirMessageHeader) then
    composeMessageHeader(xml, name,  TFhirMessageHeader(base))
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_NAMINGSYSTEM}
  else if (base is TFhirNamingSystemContact) then
    composeNamingSystemContact(xml, name,  TFhirNamingSystemContact(base))
  else if (base is TFhirNamingSystemUniqueId) then
    composeNamingSystemUniqueId(xml, name,  TFhirNamingSystemUniqueId(base))
  else if (base is TFhirNamingSystem) then
    composeNamingSystem(xml, name,  TFhirNamingSystem(base))
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_NUTRITIONORDER}
  else if (base is TFhirNutritionOrderOralDiet) then
    composeNutritionOrderOralDiet(xml, name,  TFhirNutritionOrderOralDiet(base))
  else if (base is TFhirNutritionOrderOralDietNutrient) then
    composeNutritionOrderOralDietNutrient(xml, name,  TFhirNutritionOrderOralDietNutrient(base))
  else if (base is TFhirNutritionOrderOralDietTexture) then
    composeNutritionOrderOralDietTexture(xml, name,  TFhirNutritionOrderOralDietTexture(base))
  else if (base is TFhirNutritionOrderSupplement) then
    composeNutritionOrderSupplement(xml, name,  TFhirNutritionOrderSupplement(base))
  else if (base is TFhirNutritionOrderEnteralFormula) then
    composeNutritionOrderEnteralFormula(xml, name,  TFhirNutritionOrderEnteralFormula(base))
  else if (base is TFhirNutritionOrderEnteralFormulaAdministration) then
    composeNutritionOrderEnteralFormulaAdministration(xml, name,  TFhirNutritionOrderEnteralFormulaAdministration(base))
  else if (base is TFhirNutritionOrder) then
    composeNutritionOrder(xml, name,  TFhirNutritionOrder(base))
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
  else if (base is TFhirObservationReferenceRange) then
    composeObservationReferenceRange(xml, name,  TFhirObservationReferenceRange(base))
  else if (base is TFhirObservationRelated) then
    composeObservationRelated(xml, name,  TFhirObservationRelated(base))
  else if (base is TFhirObservationComponent) then
    composeObservationComponent(xml, name,  TFhirObservationComponent(base))
  else if (base is TFhirObservation) then
    composeObservation(xml, name,  TFhirObservation(base))
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_OPERATIONDEFINITION}
  else if (base is TFhirOperationDefinitionContact) then
    composeOperationDefinitionContact(xml, name,  TFhirOperationDefinitionContact(base))
  else if (base is TFhirOperationDefinitionParameter) then
    composeOperationDefinitionParameter(xml, name,  TFhirOperationDefinitionParameter(base))
  else if (base is TFhirOperationDefinitionParameterBinding) then
    composeOperationDefinitionParameterBinding(xml, name,  TFhirOperationDefinitionParameterBinding(base))
  else if (base is TFhirOperationDefinition) then
    composeOperationDefinition(xml, name,  TFhirOperationDefinition(base))
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_OPERATIONOUTCOME}
  else if (base is TFhirOperationOutcomeIssue) then
    composeOperationOutcomeIssue(xml, name,  TFhirOperationOutcomeIssue(base))
  else if (base is TFhirOperationOutcome) then
    composeOperationOutcome(xml, name,  TFhirOperationOutcome(base))
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_ORDER}
  else if (base is TFhirOrderWhen) then
    composeOrderWhen(xml, name,  TFhirOrderWhen(base))
  else if (base is TFhirOrder) then
    composeOrder(xml, name,  TFhirOrder(base))
{$ENDIF FHIR_ORDER}
{$IFDEF FHIR_ORDERRESPONSE}
  else if (base is TFhirOrderResponse) then
    composeOrderResponse(xml, name,  TFhirOrderResponse(base))
{$ENDIF FHIR_ORDERRESPONSE}
{$IFDEF FHIR_ORGANIZATION}
  else if (base is TFhirOrganizationContact) then
    composeOrganizationContact(xml, name,  TFhirOrganizationContact(base))
  else if (base is TFhirOrganization) then
    composeOrganization(xml, name,  TFhirOrganization(base))
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_PATIENT}
  else if (base is TFhirPatientContact) then
    composePatientContact(xml, name,  TFhirPatientContact(base))
  else if (base is TFhirPatientAnimal) then
    composePatientAnimal(xml, name,  TFhirPatientAnimal(base))
  else if (base is TFhirPatientCommunication) then
    composePatientCommunication(xml, name,  TFhirPatientCommunication(base))
  else if (base is TFhirPatientLink) then
    composePatientLink(xml, name,  TFhirPatientLink(base))
  else if (base is TFhirPatient) then
    composePatient(xml, name,  TFhirPatient(base))
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PAYMENTNOTICE}
  else if (base is TFhirPaymentNotice) then
    composePaymentNotice(xml, name,  TFhirPaymentNotice(base))
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
  else if (base is TFhirPaymentReconciliationDetail) then
    composePaymentReconciliationDetail(xml, name,  TFhirPaymentReconciliationDetail(base))
  else if (base is TFhirPaymentReconciliationNote) then
    composePaymentReconciliationNote(xml, name,  TFhirPaymentReconciliationNote(base))
  else if (base is TFhirPaymentReconciliation) then
    composePaymentReconciliation(xml, name,  TFhirPaymentReconciliation(base))
{$ENDIF FHIR_PAYMENTRECONCILIATION}
{$IFDEF FHIR_PERSON}
  else if (base is TFhirPersonLink) then
    composePersonLink(xml, name,  TFhirPersonLink(base))
  else if (base is TFhirPerson) then
    composePerson(xml, name,  TFhirPerson(base))
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PRACTITIONER}
  else if (base is TFhirPractitionerPractitionerRole) then
    composePractitionerPractitionerRole(xml, name,  TFhirPractitionerPractitionerRole(base))
  else if (base is TFhirPractitionerQualification) then
    composePractitionerQualification(xml, name,  TFhirPractitionerQualification(base))
  else if (base is TFhirPractitioner) then
    composePractitioner(xml, name,  TFhirPractitioner(base))
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PROCEDURE}
  else if (base is TFhirProcedurePerformer) then
    composeProcedurePerformer(xml, name,  TFhirProcedurePerformer(base))
  else if (base is TFhirProcedureFocalDevice) then
    composeProcedureFocalDevice(xml, name,  TFhirProcedureFocalDevice(base))
  else if (base is TFhirProcedure) then
    composeProcedure(xml, name,  TFhirProcedure(base))
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROCEDUREREQUEST}
  else if (base is TFhirProcedureRequest) then
    composeProcedureRequest(xml, name,  TFhirProcedureRequest(base))
{$ENDIF FHIR_PROCEDUREREQUEST}
{$IFDEF FHIR_PROCESSREQUEST}
  else if (base is TFhirProcessRequestItem) then
    composeProcessRequestItem(xml, name,  TFhirProcessRequestItem(base))
  else if (base is TFhirProcessRequest) then
    composeProcessRequest(xml, name,  TFhirProcessRequest(base))
{$ENDIF FHIR_PROCESSREQUEST}
{$IFDEF FHIR_PROCESSRESPONSE}
  else if (base is TFhirProcessResponseNotes) then
    composeProcessResponseNotes(xml, name,  TFhirProcessResponseNotes(base))
  else if (base is TFhirProcessResponse) then
    composeProcessResponse(xml, name,  TFhirProcessResponse(base))
{$ENDIF FHIR_PROCESSRESPONSE}
{$IFDEF FHIR_PROVENANCE}
  else if (base is TFhirProvenanceAgent) then
    composeProvenanceAgent(xml, name,  TFhirProvenanceAgent(base))
  else if (base is TFhirProvenanceAgentRelatedAgent) then
    composeProvenanceAgentRelatedAgent(xml, name,  TFhirProvenanceAgentRelatedAgent(base))
  else if (base is TFhirProvenanceEntity) then
    composeProvenanceEntity(xml, name,  TFhirProvenanceEntity(base))
  else if (base is TFhirProvenance) then
    composeProvenance(xml, name,  TFhirProvenance(base))
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRE}
  else if (base is TFhirQuestionnaireGroup) then
    composeQuestionnaireGroup(xml, name,  TFhirQuestionnaireGroup(base))
  else if (base is TFhirQuestionnaireGroupQuestion) then
    composeQuestionnaireGroupQuestion(xml, name,  TFhirQuestionnaireGroupQuestion(base))
  else if (base is TFhirQuestionnaire) then
    composeQuestionnaire(xml, name,  TFhirQuestionnaire(base))
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
  else if (base is TFhirQuestionnaireResponseGroup) then
    composeQuestionnaireResponseGroup(xml, name,  TFhirQuestionnaireResponseGroup(base))
  else if (base is TFhirQuestionnaireResponseGroupQuestion) then
    composeQuestionnaireResponseGroupQuestion(xml, name,  TFhirQuestionnaireResponseGroupQuestion(base))
  else if (base is TFhirQuestionnaireResponseGroupQuestionAnswer) then
    composeQuestionnaireResponseGroupQuestionAnswer(xml, name,  TFhirQuestionnaireResponseGroupQuestionAnswer(base))
  else if (base is TFhirQuestionnaireResponse) then
    composeQuestionnaireResponse(xml, name,  TFhirQuestionnaireResponse(base))
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REFERRALREQUEST}
  else if (base is TFhirReferralRequest) then
    composeReferralRequest(xml, name,  TFhirReferralRequest(base))
{$ENDIF FHIR_REFERRALREQUEST}
{$IFDEF FHIR_RELATEDPERSON}
  else if (base is TFhirRelatedPerson) then
    composeRelatedPerson(xml, name,  TFhirRelatedPerson(base))
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_RISKASSESSMENT}
  else if (base is TFhirRiskAssessmentPrediction) then
    composeRiskAssessmentPrediction(xml, name,  TFhirRiskAssessmentPrediction(base))
  else if (base is TFhirRiskAssessment) then
    composeRiskAssessment(xml, name,  TFhirRiskAssessment(base))
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SCHEDULE}
  else if (base is TFhirSchedule) then
    composeSchedule(xml, name,  TFhirSchedule(base))
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SEARCHPARAMETER}
  else if (base is TFhirSearchParameterContact) then
    composeSearchParameterContact(xml, name,  TFhirSearchParameterContact(base))
  else if (base is TFhirSearchParameter) then
    composeSearchParameter(xml, name,  TFhirSearchParameter(base))
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SLOT}
  else if (base is TFhirSlot) then
    composeSlot(xml, name,  TFhirSlot(base))
{$ENDIF FHIR_SLOT}
{$IFDEF FHIR_SPECIMEN}
  else if (base is TFhirSpecimenCollection) then
    composeSpecimenCollection(xml, name,  TFhirSpecimenCollection(base))
  else if (base is TFhirSpecimenTreatment) then
    composeSpecimenTreatment(xml, name,  TFhirSpecimenTreatment(base))
  else if (base is TFhirSpecimenContainer) then
    composeSpecimenContainer(xml, name,  TFhirSpecimenContainer(base))
  else if (base is TFhirSpecimen) then
    composeSpecimen(xml, name,  TFhirSpecimen(base))
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_STRUCTUREDEFINITION}
  else if (base is TFhirStructureDefinitionContact) then
    composeStructureDefinitionContact(xml, name,  TFhirStructureDefinitionContact(base))
  else if (base is TFhirStructureDefinitionMapping) then
    composeStructureDefinitionMapping(xml, name,  TFhirStructureDefinitionMapping(base))
  else if (base is TFhirStructureDefinitionSnapshot) then
    composeStructureDefinitionSnapshot(xml, name,  TFhirStructureDefinitionSnapshot(base))
  else if (base is TFhirStructureDefinitionDifferential) then
    composeStructureDefinitionDifferential(xml, name,  TFhirStructureDefinitionDifferential(base))
  else if (base is TFhirStructureDefinition) then
    composeStructureDefinition(xml, name,  TFhirStructureDefinition(base))
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_SUBSCRIPTION}
  else if (base is TFhirSubscriptionChannel) then
    composeSubscriptionChannel(xml, name,  TFhirSubscriptionChannel(base))
  else if (base is TFhirSubscription) then
    composeSubscription(xml, name,  TFhirSubscription(base))
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSTANCE}
  else if (base is TFhirSubstanceInstance) then
    composeSubstanceInstance(xml, name,  TFhirSubstanceInstance(base))
  else if (base is TFhirSubstanceIngredient) then
    composeSubstanceIngredient(xml, name,  TFhirSubstanceIngredient(base))
  else if (base is TFhirSubstance) then
    composeSubstance(xml, name,  TFhirSubstance(base))
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUPPLYDELIVERY}
  else if (base is TFhirSupplyDelivery) then
    composeSupplyDelivery(xml, name,  TFhirSupplyDelivery(base))
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
  else if (base is TFhirSupplyRequestWhen) then
    composeSupplyRequestWhen(xml, name,  TFhirSupplyRequestWhen(base))
  else if (base is TFhirSupplyRequest) then
    composeSupplyRequest(xml, name,  TFhirSupplyRequest(base))
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_TESTSCRIPT}
  else if (base is TFhirTestScriptContact) then
    composeTestScriptContact(xml, name,  TFhirTestScriptContact(base))
  else if (base is TFhirTestScriptMetadata) then
    composeTestScriptMetadata(xml, name,  TFhirTestScriptMetadata(base))
  else if (base is TFhirTestScriptMetadataLink) then
    composeTestScriptMetadataLink(xml, name,  TFhirTestScriptMetadataLink(base))
  else if (base is TFhirTestScriptMetadataCapability) then
    composeTestScriptMetadataCapability(xml, name,  TFhirTestScriptMetadataCapability(base))
  else if (base is TFhirTestScriptFixture) then
    composeTestScriptFixture(xml, name,  TFhirTestScriptFixture(base))
  else if (base is TFhirTestScriptVariable) then
    composeTestScriptVariable(xml, name,  TFhirTestScriptVariable(base))
  else if (base is TFhirTestScriptSetup) then
    composeTestScriptSetup(xml, name,  TFhirTestScriptSetup(base))
  else if (base is TFhirTestScriptSetupAction) then
    composeTestScriptSetupAction(xml, name,  TFhirTestScriptSetupAction(base))
  else if (base is TFhirTestScriptSetupActionOperation) then
    composeTestScriptSetupActionOperation(xml, name,  TFhirTestScriptSetupActionOperation(base))
  else if (base is TFhirTestScriptSetupActionOperationRequestHeader) then
    composeTestScriptSetupActionOperationRequestHeader(xml, name,  TFhirTestScriptSetupActionOperationRequestHeader(base))
  else if (base is TFhirTestScriptSetupActionAssert) then
    composeTestScriptSetupActionAssert(xml, name,  TFhirTestScriptSetupActionAssert(base))
  else if (base is TFhirTestScriptTest) then
    composeTestScriptTest(xml, name,  TFhirTestScriptTest(base))
  else if (base is TFhirTestScriptTestAction) then
    composeTestScriptTestAction(xml, name,  TFhirTestScriptTestAction(base))
  else if (base is TFhirTestScriptTeardown) then
    composeTestScriptTeardown(xml, name,  TFhirTestScriptTeardown(base))
  else if (base is TFhirTestScriptTeardownAction) then
    composeTestScriptTeardownAction(xml, name,  TFhirTestScriptTeardownAction(base))
  else if (base is TFhirTestScript) then
    composeTestScript(xml, name,  TFhirTestScript(base))
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
  else if (base is TFhirValueSetContact) then
    composeValueSetContact(xml, name,  TFhirValueSetContact(base))
  else if (base is TFhirValueSetCodeSystem) then
    composeValueSetCodeSystem(xml, name,  TFhirValueSetCodeSystem(base))
  else if (base is TFhirValueSetCodeSystemConcept) then
    composeValueSetCodeSystemConcept(xml, name,  TFhirValueSetCodeSystemConcept(base))
  else if (base is TFhirValueSetCodeSystemConceptDesignation) then
    composeValueSetCodeSystemConceptDesignation(xml, name,  TFhirValueSetCodeSystemConceptDesignation(base))
  else if (base is TFhirValueSetCompose) then
    composeValueSetCompose(xml, name,  TFhirValueSetCompose(base))
  else if (base is TFhirValueSetComposeInclude) then
    composeValueSetComposeInclude(xml, name,  TFhirValueSetComposeInclude(base))
  else if (base is TFhirValueSetComposeIncludeConcept) then
    composeValueSetComposeIncludeConcept(xml, name,  TFhirValueSetComposeIncludeConcept(base))
  else if (base is TFhirValueSetComposeIncludeFilter) then
    composeValueSetComposeIncludeFilter(xml, name,  TFhirValueSetComposeIncludeFilter(base))
  else if (base is TFhirValueSetExpansion) then
    composeValueSetExpansion(xml, name,  TFhirValueSetExpansion(base))
  else if (base is TFhirValueSetExpansionParameter) then
    composeValueSetExpansionParameter(xml, name,  TFhirValueSetExpansionParameter(base))
  else if (base is TFhirValueSetExpansionContains) then
    composeValueSetExpansionContains(xml, name,  TFhirValueSetExpansionContains(base))
  else if (base is TFhirValueSet) then
    composeValueSet(xml, name,  TFhirValueSet(base))
{$ENDIF FHIR_VALUESET}
{$IFDEF FHIR_VISIONPRESCRIPTION}
  else if (base is TFhirVisionPrescriptionDispense) then
    composeVisionPrescriptionDispense(xml, name,  TFhirVisionPrescriptionDispense(base))
  else if (base is TFhirVisionPrescription) then
    composeVisionPrescription(xml, name,  TFhirVisionPrescription(base))
{$ENDIF FHIR_VISIONPRESCRIPTION}
  else
    inherited ComposeBase(xml, name, base);
end;


end.

